urn E_FAIL;
    }

    //
    // Can only decimate when using default relative position
    //

    // if (m_rRelPos.left != 0 || m_rRelPos.top != 0 ||
    //     m_rRelPos.right != MAX_REL_NUM || m_rRelPos.bottom != MAX_REL_NUM) {
    // 
    //     DBGLOG(("Can only decimate default relative position\n"));
    //     DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default relative position")));

    //     ResetDecimationIfSet();
    //     return E_FAIL;
    // }

    //
    // Must also be using the default source rectangle
    //

    if (WIDTH(&pWinInfo->SrcRect) != m_lSrcWidth ||
        HEIGHT(&pWinInfo->SrcRect) != m_lSrcHeight) {

        DBGLOG(("Can only decimate default source rectangle\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default source rectangle")));

        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Now try asking the upstream decoder if it wants to decimate to
    // the specified image size
    //

    LONG lWidth = WIDTH(&pWinInfo->DestRect);
    LONG lHeight = HEIGHT(&pWinInfo->DestRect);
    HRESULT hr = QueryDecimationOnPeer(lWidth, lHeight);
    if (SUCCEEDED(hr)) {
        m_bDecimating = TRUE;
        m_lWidth = lWidth;
        m_lHeight = lHeight;
    }
    else {
        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Adjust the source rect passed to UpdateOverlay to
    // reflect the image size
    //

    pWinInfo->SrcRect.right = lWidth;
    pWinInfo->SrcRect.bottom = lHeight;

    return S_OK;
}

/*****************************Private*Routine******************************\
* GetOverlayMinStretch
*
* Returns the stretching capabilities of the VGA overlay scaler
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
CVPMInputPin::GetOverlayMinStretch()
{
    AMTRACE((TEXT("CVPMInputPin::GetOverlayMinStretch")));

    // const DDCAPS* pDirectCaps = NULL;
    // pDirectCaps = m_pVPMFilter->GetHardwareCaps();
    // if ( pDirectCaps )
    //     return pDirectCaps->dwMinOverlayStretch;
    return 1000;
}




/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
* Determines if the current scale factor is outside the valid scale
* factors for the VGA overlay scaler.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVPMInputPin::BeyondOverlayCaps(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("CVPMInputPin::BeyondOverlayCaps")));

    return ScaleFactor < GetOverlayMinStretch();
}



/*****************************Private*Routine******************************\
* CropSourceRect
*
* Crops the video image by adjusting the source rectangle until the ratio
* between the source and target rectangles is within the specified minimum
* scale factor (dwMinZoomFactor)
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::CropSourceRect(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("CVPMInputPin::CropSourceRect")));

#if defined(DEBUG)
    if (GetProfileIntA("OVMixer", "NoCrop", 0))
        return S_FALSE;
#endif

    DWORD dCurZoomFactorX;
    DWORD dCurZoomFactorY;
    VPMUtil::GetCurrentScaleFactor( *pWinInfo, &dCurZoomFactorX, &dCurZoomFactorY);

    // AM_ASPECT_RATIO_MODE amAdjustedARMode = AM_ARMODE_STRETCHED;
    // HRESULT hr = GetAdjustedModeAndAspectRatio(&amAdjustedARMode, NULL, NULL);
    // ASSERT(SUCCEEDED(hr));
    // if (amAdjustedARMode == AM_ARMODE_STRETCHED) {
    LONG srcWidth = WIDTH(&pWinInfo->SrcRect);
    LONG srcHeight = HEIGHT(&pWinInfo->SrcRect);

    if( false ) {

        //
        // if we don't need to maintain the aspect ratio, we clip only as
        // little as possible, so we can maximize the viewing area
        //
        if (dCurZoomFactorX < dwMinZoomFactorX) {

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dCurZoomFactorX, 1000);
        }

        if (dCurZoomFactorY < dwMinZoomFactorY) {

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dCurZoomFactorY, 1000);
        }
    }
    else {

        //
        // in this mode we need to maintain the aspect-ratio. So the clipping
        // in x and y has be to done by reducing the width and height of the
        // source rect by the same factor
        //
        if (dCurZoomFactorX < dwMinZoomFactorX ||
            dCurZoomFactorY < dwMinZoomFactorY) {

            DWORD dwFactor;
            DWORD dwFactorX = MulDiv(dCurZoomFactorX, 1000, dwMinZoomFactorX);
            dwFactor = min(1000, dwFactorX);

            DWORD dwFactorY = MulDiv(dCurZoomFactorY, 1000, dwMinZoomFactorY);
            dwFactor = min(dwFactor, dwFactorY);

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dwFactor, 1000);

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dwFactor, 1000);
        }
    }

    return S_OK;
}


/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Non Video Port case
*
* This is where we enforce the chosen decimation strategy.
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
void
CVPMInputPin::ApplyDecimation(
    VPWININFO* pWinInfo
    )
{
    AMTRACE((TEXT("CVPMInputPin::ApplyDecimation")));

    DWORD dwMinStretch = GetOverlayMinStretch();

    if (Running()) {

        DWORD dwScaleFactor = VPMUtil::GetCurrentScaleFactor( *pWinInfo);
        if (VPMUtil::IsDecimationNeeded(dwScaleFactor)) {

            DECIMATION_USAGE dwUsage;
            GetDecimationUsage(&dwUsage);

            switch (dwUsage) {
            case DECIMATION_USE_OVERLAY_ONLY:
            case DECIMATION_LEGACY:
                ResetDecimationIfSet();
                if (BeyondOverlayCaps(dwScaleFactor)) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_DECODER_ONLY:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_VIDEOPORT_ONLY:
                ASSERT(FALSE);

                DBGLOG(("This mode makes no sense when not using Video Ports"));
                DBGLOG(("Falling thru to the new default case"));

            case DECIMATION_DEFAULT:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    if (BeyondOverlayCaps(dwScaleFactor)) {
                        CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                    }
                }
                break;
            }
        }
        else {
            ResetDecimationIfSet();
        }
    }

    //
    // If the filter graph is not running we should not ask the decoder
    // to do anymore decimation as the decoder will not be
    // sending anymore frames to us.  So, we should adjust pWinInfo to take
    // into account the decimation that has already been applied and then
    // perform any necessary cropping.
    //

    else {

        if (m_bDecimating) {
            pWinInfo->SrcRect.right = m_lWidth;
            pWinInfo->SrcRect.bottom = m_lHeight;
        }

        DWORD dwScaleFactor = VPMUtil::GetCurrentScaleFactor( *pWinInfo);
        if (BeyondOverlayCaps(dwScaleFactor)) {
            CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
        }
    }
}



/******************************Public*Routine******************************\
* GetMinZoomFactors
*
* Gets the minimum X and Y zoom factors for the given overlay and video port
* connection.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
void
CVideoPortObj::GetMinZoomFactors(
    const VPWININFO& winInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating,
    LPDWORD lpMinX,
    LPDWORD lpMinY
    )
{
    AMTRACE((TEXT("CVideoPortObj::GetMinZoomFactors")));
    DWORD dwMinBandWidthZoomFactorX = 0;
    const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();

    //
    // if type is DDVPBCAPS_DESTINATION, contraint is terms of min-zoom-factor
    //

    if (m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION) {

        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_DESTINATION")));
        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX < m_sBandwidth.dwOverlay)
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
    }
    else {

        //
        // if type is DDVPBCAPS_SOURCE, contraint is that the width of
        // the src-rect of the overlay must not be bigger than
        // m_lImageWidth*(value specified in m_sBandwidth)
        //

        ASSERT(m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE);
        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_SOURCE")));

        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));

        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX > m_sBandwidth.dwOverlay) {
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
        }

        ASSERT(dwMinBandWidthZoomFactorX <= 1000);
        ASSERT(dwMinBandWidthZoomFactorX > 0);

        //
        // since this bandwidth structure was computed by passing m_lImageWidth
        // as a paramter, the constraint is WIDTH(SrcRect of the overlay) <=
        // m_lImageWidth*dMinBandWidthZoomFactorX.
        // Another way of specifying this is terms of min-zoom-factor,
        // taking the current dest rect into account
        //

        DbgLog((LOG_TRACE, 1,
                TEXT("Mucking about with dwMinBandWidthZoomFactorX")));

        if (dwMinBandWidthZoomFactorX < 1000) {
            int iDstWidth = WIDTH(&winInfo.DestRect);
            dwMinBandWidthZoomFactorX = MulABC_DivDE(iDstWidth, 1000, 1000,
                                                     m_lImageWidth,
                                                     dwMinBandWidthZoomFactorX);
        }
        else {
            dwMinBandWidthZoomFactorX = 0;
        }
        DbgLog((LOG_TRACE, 1,
                TEXT("NEW dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
    }

    //
    // Calculate the minimum zoom factors first
    // minimum zoom factor in X depends upon the driver's capabilities to
    // stretch the overlay as well as the bandwidth restrictions.
    //

    *lpMinX = pDirectCaps->dwMinOverlayStretch;
    DbgLog((LOG_TRACE, 1, TEXT("dwMinOverlayStretch=%d"), *lpMinX));

    if (*lpMinX < dwMinBandWidthZoomFactorX) {
        *lpMinX = dwMinBandWidthZoomFactorX;
    }
    DbgLog((LOG_TRACE, 1, TEXT("dwMinZoomFactorX=%d"), *lpMinX));

    //
    // minimum zoom factor in Y depends only upon the driver's capabilities
    //
    *lpMinY = pDirectCaps->dwMinOverlayStretch;
}



/*****************************Private*Routine******************************\
* CheckVideoPortAlignment
*
* Checks that the specified pre-scale width is matches the alignment criteria
* set by the video port.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::CheckVideoPortAlignment(
    DWORD dwWidth
    )
{
    AMTRACE((TEXT("CVideoPortObj::CheckVideoPortAlignment")));
    if ((m_vpCaps.dwFlags & DDVPD_ALIGN) &&
         m_vpCaps.dwAlignVideoPortPrescaleWidth > 1) {

        if (dwWidth & (m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)) {

            return FALSE;
        }
    }

    return TRUE;
}

#if defined(DEBUG)
/*****************************Private*Routine******************************\
* CheckVideoPortScaler
*
* Checks that the video port scaler can actual scale the video image to the
* requested capture size.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::CheckVideoPortScaler(
    DECIMATE_MODE DecimationMode,
    DWORD ImageSize,
    DWORD PreScaleSize,
    ULONG ulDeciStep
    )
{
    AMTRACE((TEXT("CVideoPortObj::CheckVideoPortScaler")));
    BOOL fScalerOK = TRUE;

    if (ImageSize != PreScaleSize) {
        switch (DecimationMode) {
        case DECIMATE_ARB:
            break;

        case DECIMATE_INC:
            if (((ulDeciStep * PreScaleSize) % ImageSize) != 0) {

                DbgLog((LOG_ERROR, 1,
                        TEXT("Can't capture at this size")));

                DbgLog((LOG_ERROR, 1,
                        TEXT("%d is not a fraction of %d over %d"),
                        PreScaleSize, ImageSize, ulDeciStep));

                fScalerOK = FALSE;
            }
            break;

        case DECIMATE_BIN:
            {
                DWORD bin = 1;
                while ((ImageSize / bin) > PreScaleSize) {
                    bin *= 2;
                }

                if ((ImageSize % bin) != 0) {

                    DbgLog((LOG_ERROR, 1,
                            TEXT("Can't capture at this size")));

                    DbgLog((LOG_ERROR, 1,
                            TEXT("%d is not a fraction of %d over 2^n"),
                            PreScaleSize, ImageSize));

                    fScalerOK = FALSE;
                }
            }
            break;

        case DECIMATE_NONE:
            DbgLog((LOG_ERROR, 1,
                    TEXT("Can't capture at this width because the ")
                    TEXT("VideoPort can't scale in this direction")));
            fScalerOK = FALSE;
            break;
        }
    }

    return fScalerOK;
}
#endif

/*****************************Private*Routine******************************\
* AdjustSourceSizeForCapture
*
* Only gets called if we are capturing.
*
* First, we must make sure that the video comming over the video port is
* the correct size.  We do this by checking that m_lImageWidth is equal to
* m_cxCapture and that m_lImageHeight is equal to m_cyCapture.
*
* If they differ, then we pre-scale the video to the correct size.  This is
* the only pre-scaling that is performed.  This is normaly only performed
* once when the graph is first run.  The source rectangle is adjusted
* to accomodate the possibly changed video source size.
*
* Second, we determine the current shrink factor and if it is beyond the
* capabilities of the VGA scaler we CROP the source rectangle (maintaining the
* correct aspect ratio) to such a size that the VGA scaler can cope with
* scaling.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::AdjustSourceSizeForCapture(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    BOOL fUpdateRequired = FALSE;

    AMTRACE((TEXT("CVideoPortObj::AdjustSourceSizeForCapture")));

    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));
    DbgLog((LOG_TRACE, 1, TEXT("Dest(%d, %d, %d, %d)"),
            pWinInfo->DestRect.left, pWinInfo->DestRect.top,
            pWinInfo->DestRect.right, pWinInfo->DestRect.bottom));

    DWORD cyCapture = m_cyCapture;
    if (m_fCaptureInterleaved) {
        cyCapture /= 2;
    }

    //
    // First make sure that we are capturing at the correct size.
    //

    if (m_lDecoderImageWidth == m_cxCapture &&
        m_lDecoderImageHeight == cyCapture) {

        DbgLog((LOG_TRACE, 1, TEXT("Capture size matches image size")));

        //
        // We don't need to pre-scale at the video port, so make sure that it
        // is turned off.
        //
        if (m_svpInfo.dwPrescaleWidth != 0 || m_svpInfo.dwPrescaleHeight != 0) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning off PRE-SCALE")));

            m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = 0;
            m_svpInfo.dwPrescaleHeight = 0;
            fUpdateRequired = TRUE;
        }

        //
        // Reset the decimation ratio's
        //
        m_dwDeciNumX = 1000; m_dwDeciDenX = 1000;
        m_dwDeciNumY = 1000; m_dwDeciDenY = 1000;
    }
    else {

        //
        // We do need to pre-scale at the video port, make sure that it is
        // turned on.
        //

        if (m_svpInfo.dwPrescaleWidth != m_cxCapture ||
            m_svpInfo.dwPrescaleHeight != cyCapture) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning on PRE-SCALE at (%d, %d)"),
                    m_cxCapture, cyCapture ));

            //
            // Need to do some more checking here.  Basically, I'm relying on
            // the decoder connected to the video port to specify a size that
            // the video port can actually scale to.
            //

            ASSERT(CheckVideoPortAlignment(m_cxCapture) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeX, m_lDecoderImageWidth,
                                        m_cxCapture, m_ulDeciStepX) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeY, m_lDecoderImageHeight,
                                        cyCapture, m_ulDeciStepY) == TRUE);

            m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = m_cxCapture;
            m_svpInfo.dwPrescaleHeight = cyCapture;
            fUpdateRequired = TRUE;
        }


        //
        // Update the decimation ratio's
        //
        m_dwDeciDenX = 1000;
        m_dwDeciNumX = (DWORD)MulDiv(m_cxCapture, m_dwDeciDenX, m_lDecoderImageWidth);
        m_dwDeciDenY = 1000;
        m_dwDeciNumY = (DWORD)MulDiv(cyCapture, m_dwDeciDenY, m_lDecoderImageHeight);


        //
        // make sure that the source rectangle reflects the new source video
        // image file
        //
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.right  = rcSrc.left + m_cxCapture;
        rcSrc.bottom = rcSrc.top + m_cyCapture;
    }

    //
    // Second, make sure that any shrinking falls within the capabilities
    // of the scaler on the VGA chip, cropping if necessary
    //
    m_pIVideoPortControl->CropSourceRect(pWinInfo, dwMinZoomFactorX, dwMinZoomFactorY);


    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));

    return fUpdateRequired;
}


/*****************************Private*Routine******************************\
* Running
*
* Returns TRUE if the filter graph is in the "running" state.
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::Running()
{
    AMTRACE((TEXT("CVideoPortObj::Running")));

    return !(m_VPState == VPInfoState_STOPPED && !m_bStart);
}


/*****************************Private*Routine******************************\
* VideoPortDecimationBackend
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::VideoPortDecimationBackend(
    VPWININFO* pWinInfo,
    DWORD dwDecNumX,
    DWORD dwDecDenX,
    DWORD dwDecNumY,
    DWORD dwDecDenY
    )
{
    AMTRACE((TEXT("CVideoPortObj::VideoPortDecimationBackend")));

    //
    // This is the same backend processing as the legacy code,
    // should make this into a function and avoid the code duplication.
    //

    DDVIDEOPORTINFO svpInfo = m_svpInfo;
    if ((dwDecNumX != dwDecDenX) || (dwDecNumY != dwDecDenY)) {

        DbgLog((LOG_TRACE, 1,
                TEXT("prescaling, original image width is %d"),
                m_lImageWidth));

        //
        // Apply the video port pre-scale width factor
        //
        m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = MulDiv(m_lImageWidth, dwDecNumX, dwDecDenX);

        //
        // Check the video port is aligned to the specified boundardy
        //
        if (CheckVideoPortAlignment(m_svpInfo.dwPrescaleWidth) == FALSE) {

            DbgLog((LOG_TRACE, 1,
                    TEXT("pre aligned prescale width = %d"),
                    m_svpInfo.dwPrescaleWidth));

            DWORD dwPrescaleWidth = (m_svpInfo.dwPrescaleWidth &
                    (~(m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)));

            dwDecNumX = MulDiv(dwPrescaleWidth, dwDecDenX, m_lImageWidth);
            m_svpInfo.dwPrescaleWidth = dwPrescaleWidth;

            DbgLog((LOG_TRACE, 1,
                    TEXT("Cause of Alignment restrictions, now new")
                    TEXT(" m_svpInfo.dwPrescaleWidth = %d"),
                    m_svpInfo.dwPrescaleWidth));
        }

        m_svpInfo.dwPrescaleHeight =
            MulDiv(m_lImageHeight, dwDecNumY, dwDecDenY);

        DbgLog((LOG_TRACE, 1, TEXT("PrescaleWidth = %d, PrescaleHeight = %d"),
                m_svpInfo.dwPrescaleWidth, m_svpInfo.dwPrescaleHeight));

        // scale the SrcRect by the decimation values computed
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.left   = MulDiv(rcSrc.left,   dwDecNumX, dwDecDenX);
        rcSrc.right  = MulDiv(rcSrc.right,  dwDecNumX, dwDecDenX);
        rcSrc.top    = MulDiv(rcSrc.top ,   dwDecNumY, dwDecDenY);
        rcSrc.bottom = MulDiv(rcSrc.bottom, dwDecNumY, dwDecDenY);
        DbgLog((LOG_TRACE, 1,
                TEXT("Src(%d, %d, %d, %d)"),
                rcSrc.left, rcSrc.top, rcSrc.right, rcSrc.bottom));
        m_bVPDecimating = TRUE;
    }
    else {
        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;
    }

    m_dwDeciNumX = dwDecNumX;
    m_dwDeciDenX = dwDecDenX;
    m_dwDeciNumY = dwDecNumY;
    m_dwDeciDenY = dwDecDenY;

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumX = %d m_dwDeciDenX = %d"),
            m_dwDeciNumX, m_dwDeciDenX));

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumY = %d m_dwDeciDenY = %d"),
            m_dwDeciNumY, m_dwDeciDenY));

    return m_svpInfo.dwVPFlags != svpInfo.dwVPFlags ||
           m_svpInfo.dwPrescaleWidth != svpInfo.dwPrescaleWidth ||
           m_svpInfo.dwPrescaleHeight != svpInfo.dwPrescaleHeight;
}


/*****************************Private*Routine******************************\
* TryVideoPortDecimation
*
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
HRESULT
CVideoPortObj::TryVideoPortDecimation(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY,
    BOOL* lpUpdateRequired
    )
{
    AMTRACE((TEXT("CVideoPortObj::TryVideoPortDecimation")));

    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, E_INVALIDARG);


    //
    // By default we don't need to call UpdateVideo on the video port
    //

    *lpUpdateRequired = FALSE;


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);

    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return E_FAIL;
    }


    //
    // We only decimate at the video port if it supports arbitary scaling
    //

    if (m_DecimationModeX != DECIMATE_ARB ||
        m_DecimationModeY != DECIMATE_ARB) {

        return E_FAIL;
    }


    //
    // Work out the decimation width and height as a pair of ratios,
    // we do this to remain compatible with the legacy code.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecNumY = 1000;

    DWORD dwCurZoomX = MulDiv(WIDTH(&pWinInfo->DestRect), 1000, dwSrcWidth);
    DWORD dwCurZoomY = MulDiv(HEIGHT(&pWinInfo->DestRect), 1000, dwSrcHeight);

    if (dwCurZoomX < dwMinZoomFactorX) {
        // note that we round down here
        dwDecNumX = (1000 * dwCurZoomX) / dwMinZoomFactorX;
    }

    if (dwCurZoomY < dwMinZoomFactorY) {
        // note that we round down here
        dwDecNumY = (1000 * dwCurZoomY) / dwMinZoomFactorY;
    }


    *lpUpdateRequired = VideoPortDecimationBackend(pWinInfo, dwDecNumX, 1000,
                                                   dwDecNumY, 1000);
    return S_OK;
}

/*****************************Private*Routine******************************\
* AdjustSourceSize
*
* This function should only adjust the source rectangle if the source rectangle
* is actually larger than the destination rectangle AND the required shrink
* is beyond the capabilities of the scaler on the VGA chip.
*
* There is a special case if we are capturing, this case is identified by
* m_fCapturing being set to TRUE.  In this case we simply pass the parameters
* on to AdjustSourceSizeForCapture defined above.
*
* To ensure that the video image displayed still looks correct we make use of
* the scaling abilities of the video port.  We remove or reduce the shrink by
* reducing the size of the video coming over the video port.  This may be
* done in either the X or Y axis as necessary.
*
* The function first calculates the minimum shrink factor in both x and y
* directions.  The minimum factor in the x direction depends upon the bandwidth
* restrictions of the video port as well as the capabilities of the VGA scaler.
* The minimum shrink factor is scaled by 1000.
*
* Next for each axis we determine the current shrink factor, this is the ratio
* of the destination rectangle to the source rectangle scaled by 1000.
* If the current shrink factor is less than the minimum shrink factor we have to
* use the video port scaler to shrink the source rectangle to such a size that
* the VGA scaler is able to cope with the required scaling operation.
*
* There are three methods of scaling at the video port, the choice of method
* used is determined by querying the video port.  The three methods are:
*
* 1. Arbitrary:
* This means that the video port scaler can shrink the video
* to any requested size.  In this case we simply do all the scaling in the
* video port, the VGA scaler is not really used as the source rectangle is now
* the same size as the destination rectangle.
*
* 2. Increment:
* This means that the video port scaler can shrink the video in increments of
* x / N, where N is a constant integer returned from the video port and x is an
* variable integer in the range from 1 to (N-1).  We adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
* 3. Binary:
* Here the video port can only shrink the video by a binary factor, that is 1/x,
* where x is a power of 2.  Again we adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
*
* See additional comments in OVMixer.htm
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
BOOL
CVideoPortObj::AdjustSourceSize(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("CVideoPortObj::AdjustSourceSize")));
    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, FALSE);


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);
    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return FALSE;
    }


    //
    // Another special case for capturing, see the comments above.
    //
    if (m_fCapturing) {
        return AdjustSourceSizeForCapture(pWinInfo,dwMinZoomFactorX,
                                          dwMinZoomFactorY);
    }


    //
    // Determine the adjustment for the x axis.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecDenX = 1000;
    DWORD dwDstWidth  = WIDTH(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorX = MulDiv(dwDstWidth,  1000, dwSrcWidth);

    switch (m_DecimationModeX) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {
            dwDecNumX = dwCurZoomFactorX;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN X")));
        while ((DWORD)MulDiv(dwDstWidth, dwDecDenX, dwSrcWidth)
                < dwMinZoomFactorX)
        {
            dwDecDenX *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {

            dwDecNumX = MulABC_DivDE(dwDstWidth, m_ulDeciStepX, 1000,
                                     dwMinZoomFactorX, dwSrcWidth);
            dwDecDenX = m_ulDeciStepX;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumX = %d dwDecDenX = %d"),
                    dwDecNumX, dwDecDenX ));
        }
        break;
    }


    //
    // Determine the adjustment for the y axis.
    //
    DWORD dwDecNumY = 1000;
    DWORD dwDecDenY = 1000;
    DWORD dwDstHeight = HEIGHT(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorY = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    switch (m_DecimationModeY) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {
            dwDecNumY = dwCurZoomFactorY;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN Y")));
        while ((DWORD)MulDiv(dwDecDenY, dwDstWidth, dwSrcWidth)
                < dwMinZoomFactorY)
        {
            dwDecDenY *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {

            dwDecNumY = MulABC_DivDE(dwDstHeight, m_ulDeciStepY, 1000,
                                     dwMinZoomFactorY, dwSrcHeight);
            dwDecDenY = m_ulDeciStepY;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumY = %d dwDecDenY = %d"),
                    dwDecNumY, dwDecDenY ));
        }
        break;
    }

    return VideoPortDecimationBackend(pWinInfo, dwDecNumX, dwDecDenX,
                                      dwDecNumY, dwDecDenY);
}



/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::BeyondOverlayCaps(
    DWORD ScaleFactor,
    DWORD xMin,
    DWORD yMin
    )
{
    return ScaleFactor < xMin || ScaleFactor < yMin;
}



/*****************************Private*Routine******************************\
* TryDecoderDecimation
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVideoPortObj::TryDecoderDecimation(
    VPWININFO* pWinInfo
    )
{
    //
    // Extract the width and height that we are trying to decimate
    // the video image down too
    //

    DWORD dwWidth = WIDTH(&pWinInfo->DestRect);
    DWORD dwHeight = HEIGHT(&pWinInfo->DestRect);


    //
    // Try to use the new IDecimateVideoImage interface on our upstream
    // filter
    //

    IDecimateVideoImage* lpDVI;
    HRESULT hr = m_pIVideoPortControl->GetVideoDecimation(&lpDVI);
    if (SUCCEEDED(hr)) {
        hr = lpDVI->SetDecimationImageSize(dwWidth, dwHeight);
        lpDVI->Release();
    }


    //
    // If that failed try to decimate using the old IVPConfig interface
    //

    if (FAILED(hr)) {

        AMVPSIZE amvpSize;
        amvpSize.dwWidth = dwWidth;
        amvpSize.dwHeight = dwHeight;

        DbgLog((LOG_TRACE, 1,
                TEXT("SetScalingFactors to (%d, %d)"),
                amvpSize.dwWidth, amvpSize.dwHeight));

        hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
    }

    //
    // If we were successful update our state variables
    //
    if (SUCCEEDED(hr)) {

        m_bDecimating = TRUE;
        pWinInfo->SrcRect.right = m_lWidth = dwWidth;
        pWinInfo->SrcRect.bottom = m_lHeight = dwHeight;
    }
    else {
        ResetDecoderDecimationIfSet();
        hr = E_FAIL;
    }

    return hr;
}



/*****************************Private*Routine******************************\
* ResetVPDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::ResetVPDecimationIfSet()
{
    BOOL bUpdateRequired = m_bVPDecimating;
    if (m_bVPDecimating) {

        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;

        m_bVPDecimating = FALSE;
        m_dwDeciNumX = m_dwDeciDenX = 1000;
        m_dwDeciNumY = m_dwDeciDenY = 1000;
    }

    return bUpdateRequired;
}



/*****************************Private*Routine******************************\
* ResetDecoderDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
void
CVideoPortObj::ResetDecoderDecimationIfSet()
{
    if (m_bDecimating) {

        IDecimateVideoImage* lpDVI;
        HRESULT hr = m_pIVideoPortControl->GetVideoDecimation(&lpDVI);
        if (SUCCEEDED(hr)) {
            hr = lpDVI->ResetDecimationImageSize();
            lpDVI->Release();
        }


        if (FAILED(hr)) {
            AMVPSIZE amvpSize;
            amvpSize.dwWidth = m_lDecoderImageWidth;
            amvpSize.dwHeight = m_lDecoderImageHeight;

            DbgLog((LOG_TRACE,1,
                    TEXT("SetScalingFactors to (%d, %d)"),
                    amvpSize.dwWidth, amvpSize.dwHeight));

            hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
        }

        if (SUCCEEDED(hr)) {
            m_bDecimating = FALSE;
            m_lWidth = 0;
            m_lHeight = 0;
        }
    }
}



/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Video Port case
*
* This is where we enforce the chosen decimation strategy for the Video Port
* case.
*
* History:
* Tue 07/13/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::ApplyDecimation(
    VPWININFO* pWinInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating
    )
{
    AMTRACE((TEXT("CVideoPortObj::ApplyDecimation")));
    BOOL bUpdateRequired = FALSE;

    DECIMATION_USAGE dwUsage;
    m_pIVideoPortControl->GetDecimationUsage(&dwUsage);


    //
    // Determine the current min zoom factors givin the current overlay and
    // video port connection
    //

    DWORD dwMinZoomX, dwMinZoomY;
    GetMinZoomFactors( *pWinInfo, bColorKeying, bYInterpolating,
                      &dwMinZoomX, &dwMinZoomY);

    if ((dwUsage == DECIMATION_LEGACY) ||
        (dwUsage == DECIMATION_DEFAULT && m_fCapturing)) {

        bUpdateRequired = AdjustSourceSize(pWinInfo,
                                           dwMinZoomX,
                                           dwMinZoomY);
    }


    else {

        if (Running()) {

            DWORD ScaleFactor = VPMUtil::GetCurrentScaleFactor( *pWinInfo);
            if ( VPMUtil::IsDecimationNeeded(ScaleFactor)) {

                switch (dwUsage) {

                case DECIMATION_USE_OVERLAY_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                  dwMinZoomX,
                                                  dwMinZoomY);
                    break;

                case DECIMATION_USE_DECODER_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_USE_VIDEOPORT_ONLY:
                    ResetDecoderDecimationIfSet();
                    if (TryVideoPortDecimation(pWinInfo, 1000,
                                               1000,
                                               &bUpdateRequired) != S_OK) {

                        m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_DEFAULT:
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        if (BeyondOverlayCaps(ScaleFactor, dwMinZoomX,
                                              dwMinZoomY)) {

                            if (TryVideoPortDecimation(pWinInfo,
                                                       dwMinZoomX,
                                                       dwMinZoomY,
                                                       &bUpdateRequired) != S_OK) {

                                m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                              dwMinZoomX,
                                                              dwMinZoomY);
                            }
                        }
                    }
                    break;
                }
            }
            else {

                ResetDecoderDecimationIfSet();
                bUpdateRequired = ResetVPDecimationIfSet();
            }
        }


        else {

            if (m_bVPDecimating) {

                //
                // Apply the current pre-scale to the source image.
                //

                RECT &rcSrc = pWinInfo->SrcRect;
                rcSrc.left = MulDiv(rcSrc.left, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.top = MulDiv(rcSrc.top, m_dwDeciNumY, m_dwDeciDenY);
                rcSrc.right = MulDiv(rcSrc.right, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.bottom = MulDiv(rcSrc.bottom, m_dwDeciNumY, m_dwDeciDenY);
            }

            if (m_bDecimating) {

                //
                // Apply the current decoder decimation to the source image.
                //

                pWinInfo->SrcRect.right = m_lWidth;
                pWinInfo->SrcRect.bottom = m_lHeight;
            }

            //
            // Then make sure that any shrinking falls within the capabilities
            // of the scaler on the VGA chip, cropping if necessary.
            //

            m_pIVideoPortControl->CropSourceRect(pWinInfo, dwMinZoomX, dwMinZoomY);
        }
    }

    return bUpdateRequired;
}
/******************************Public*Routine******************************\
* MulABC_DivDE
*
* Performs the following calculation:  ((A*B*C) / (D*E)) rounding the result
* to the nearest integer.
*
* History:
* 3/3/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD MulABC_DivDE(DWORD A, DWORD B, DWORD C, DWORD D, DWORD E)
{

    unsigned __int64 Num = (unsigned __int64)A * (unsigned __int64)B;
    unsigned __int64 Den = (unsigned __int64)D * (unsigned __int64)E;

    Num *= (unsigned __int64)C;
    Num += (Den / 2);

    unsigned __int64 Res = Num / Den;

    return (DWORD)Res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmanager.h ===
/******************************Module*Header*******************************\
* Module Name: VPManager.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __VPManager__h
#define __VPManager__h

// IDirectDrawMediaSample
#include <amstream.h>

// IksPin
#include <ks.h>
#include <ksproxy.h>

#include <dvp.h>

#include <VPMPin.h>

/* -------------------------------------------------------------------------
** CVPManager class declaration
** -------------------------------------------------------------------------
*/
class CVPMOutputPin;
class CVPMInputPin;
class CVBIInputPin;
class PixelFormatList;

class DRect;
class CVPMThread;

struct VPInfo;

class CVPMFilter
: public CBaseFilter
, public ISpecifyPropertyPages
, public IQualProp
, public IAMVideoDecimationProperties
, public IKsPropertySet
, public IVPManager
{
public:
    // COM stuff
    static CUnknown* CreateInstance(LPUNKNOWN, HRESULT* );
    static CUnknown* CreateInstance2(LPUNKNOWN, HRESULT* );

    // (con/de)structors
    CVPMFilter(TCHAR* pName,LPUNKNOWN pUnk,HRESULT* phr );
    virtual ~CVPMFilter();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void**  ppv);

    // IVPManager
    STDMETHODIMP SetVideoPortIndex( DWORD dwVideoPortIndex );
    STDMETHODIMP GetVideoPortIndex( DWORD* pdwVideoPortIndex );

    // ISpecifyPropertyPages 
    STDMETHODIMP GetPages(CAUUID* pPages);

    // IQualProp property page support
    STDMETHODIMP get_FramesDroppedInRenderer(int* cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int* pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int* piAvgFrameRate);
    STDMETHODIMP get_Jitter(int* piJitter);
    STDMETHODIMP get_AvgSyncOffset(int* piAvg);
    STDMETHODIMP get_DevSyncOffset(int* piDev);

    //
    // IKsPropertySet interface methods
    //
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);

    STDMETHODIMP Get(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
                     DWORD* pcbReturned);

    STDMETHODIMP QuerySupported(REFGUID guidPropSet,
                                DWORD PropID, DWORD* pTypeSupport);


    virtual HRESULT SetMediaType(DWORD dwPinId, const CMediaType* pmt);
    virtual HRESULT CompleteConnect(DWORD dwPinId);
    virtual HRESULT BreakConnect(DWORD dwPinId);
    virtual HRESULT CheckMediaType(DWORD dwPinId, const CMediaType* mtIn)
                    { return NOERROR; }
    virtual HRESULT EndOfStream(DWORD dwPinId) { return NOERROR; }

    // IAMVideoDecimationProperties
    STDMETHODIMP    QueryDecimationUsage(DECIMATION_USAGE* lpUsage);
    STDMETHODIMP    SetDecimationUsage(DECIMATION_USAGE Usage);

    // CBaseFilter
    int             GetPinCount();
    CBasePin*       GetPin(int n);

public:
    // other non-interface methods

    int             GetPinPosFromId(DWORD dwPinId);

    STDMETHODIMP    Run(REFERENCE_TIME StartTime );
    STDMETHODIMP    Pause();
    STDMETHODIMP    Stop() ;
    STDMETHODIMP    GetState(DWORD dwMSecs,FILTER_STATE* pState);
    HRESULT         EventNotify(DWORD dwPinId,
                                long lEventCode,
                                DWORD_PTR lEventParam1,
                                DWORD_PTR lEventParam2);
    HRESULT         ConfirmPreConnectionState(DWORD dwExcludePinId = -1);
    HRESULT         CanExclusiveMode();

    HRESULT         GetPaletteEntries(DWORD* pdwNumPaletteEntries,
                                              PALETTEENTRY** ppPaletteEntries);
    CImageDisplay*  GetDisplay() { return &m_Display; }
    LPDIRECTDRAW7   GetDirectDraw();
    const DDCAPS*   GetHardwareCaps();
    HRESULT         SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP );
    HRESULT         CurrentInputMediaType(CMediaType* pmt);


    DWORD           KernelCaps() const { return m_dwKernelCaps;}

    HRESULT         ProcessNextSample( const DDVIDEOPORTNOTIFY& notify );
    HRESULT         GetAllOutputFormats( const PixelFormatList**);
    HRESULT         GetOutputFormat( DDPIXELFORMAT*);

    HRESULT         CanColorConvertBlitToRGB( const DDPIXELFORMAT& ddFormat );

    CCritSec&       GetFilterLock() { return m_csFilter; };
    CCritSec&       GetReceiveLock() { return m_csReceive; };
    HRESULT         GetRefClockTime( REFERENCE_TIME* pNow );

    HRESULT         GetVPInfo( VPInfo* pVPInfo );

protected:
    friend class CVPMInputPin;
    void    DeleteInputPin( CBaseInputPin* pPin);
private:
    // helper function to get IBaseVideo from outpun pin
    HRESULT     GetBasicVideoFromOutPin(IBasicVideo** pBasicVideo);

    HRESULT     HandleConnectInputWithoutOutput();
    HRESULT     HandleConnectInputWithOutput();

    HRESULT     CreateThread();

    // ddraw related functions
    HRESULT InitDirectDraw(LPDIRECTDRAW7 pDirectDraw);

    DWORD   ReleaseDirectDraw();
    HRESULT CheckSuitableVersion();
    HRESULT CheckCaps();

    HRESULT SetDirectDraw( LPDIRECTDRAW7 pDirectDraw );


    CCritSec                m_csFilter;             // filter wide lock (use in state changes / filter changes)
    CCritSec                m_csReceive;            // receive lock (use in state changes AND receive)

    // ddraw stuff
    LPDIRECTDRAW7           m_pDirectDraw;          // DirectDraw service provider
    DWORD                   m_dwVideoPortID;        // VP index on the card
    DDCAPS                  m_DirectCaps;           // Actual hardware capabilities
    DDCAPS                  m_DirectSoftCaps;       // Emulted capabilities
    DWORD                   m_dwKernelCaps;         // Kernel caps

    //
    CImageDisplay           m_Display;

    // Pins
    struct Pins {
        Pins( CVPMFilter& filter, HRESULT* phr );
        ~Pins();

        const DWORD             dwCount;
        CVPMInputPin            VPInput;
        CVBIInputPin            VBIInput;
        CVPMOutputPin           Output;           // output pin
    }* m_pPins;

    // Support IMediaSeeking
    IUnknown*                m_pPosition;

    // Support IEnumPinConfig
    DWORD                   m_dwPinConfigNext;


    // Support IAMVideoDecimationProperties
    DECIMATION_USAGE        m_dwDecimation;
#ifdef DEBUG
#define WM_DISPLAY_WINDOW_TEXT  (WM_USER+7837)
    TCHAR                   m_WindowText[80];
#endif

    // Pump thread
    CVPMThread*             m_pThread;
};

#endif //__VPManager__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vbiobj.h ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef __VBIOBJ__
#define __VBIOBJ__

#include <vptype.h>     // AMVP_MODE
#include <vpnotify.h>   // IVPVBINotify
#include <VPManager.h> // #include <kspin.h>         // IKsPin
#include <dvp.h>

//==========================================================================

interface IVPVBIConfig;

DECLARE_INTERFACE_(IVideoPortVBIObject, IUnknown)
{
    STDMETHOD (SetDirectDraw)(THIS_ LPDIRECTDRAW7 pDirectDraw) PURE;
    STDMETHOD (SetObjectLock)(THIS_ CCritSec *pMainObjLock) PURE;
    STDMETHOD (CheckMediaType)(THIS_ const CMediaType* pmt) PURE;
    STDMETHOD (GetMediaType)(THIS_ int iPosition, CMediaType *pMediaType) PURE;
    STDMETHOD (CheckConnect)(THIS_ IPin *pReceivePin) PURE;
    STDMETHOD (CompleteConnect)(THIS_ IPin *pReceivePin) PURE;
    STDMETHOD (BreakConnect)(THIS_) PURE;
    STDMETHOD (Active)(THIS_) PURE;
    STDMETHOD (Inactive)(THIS_) PURE;
    STDMETHOD (Run)(THIS_ REFERENCE_TIME tStart) PURE;
    STDMETHOD (RunToPause)(THIS_) PURE;
    STDMETHOD (GetVPDataInfo)(THIS_ AMVPDATAINFO *pAMVPDataInfo) PURE;
    STDMETHOD (CheckSurfaces)(THIS_) PURE;
    STDMETHOD (SetVideoPortID)      (THIS_ DWORD dwVideoPortId ) PURE;
};

class PixelFormatList;

//==========================================================================
class CVBIVideoPort
: public CUnknown
, public IVPVBINotify
, public IVideoPortVBIObject
, public IKsPropertySet
, public IKsPin
{
    
public:
    CVBIVideoPort(LPUNKNOWN pUnk, HRESULT *phr);
    ~CVBIVideoPort();
    
    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IVideoPortVBIObject Interface to the outside world

    STDMETHODIMP SetDirectDraw(LPDIRECTDRAW7 pDirectDraw);
    STDMETHODIMP SetObjectLock(CCritSec *pMainObjLock);
    STDMETHODIMP CheckMediaType(const CMediaType* pmt);
    STDMETHODIMP GetMediaType(int iPosition, CMediaType *pMediaType);
    STDMETHODIMP CheckConnect(IPin * pReceivePin);
    STDMETHODIMP CompleteConnect(IPin *pReceivePin);
    STDMETHODIMP BreakConnect();
    STDMETHODIMP Active();
    STDMETHODIMP Inactive();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP RunToPause();
    STDMETHODIMP GetVPDataInfo(AMVPDATAINFO *pAMVPDataInfo);
    STDMETHODIMP CheckSurfaces();
    STDMETHODIMP SetVideoPortID( DWORD dwVideoPortId );

    // IVPVBINotify functions here
    STDMETHODIMP RenegotiateVPParameters();

    // IKsPropertySet implementation
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
        { return E_NOTIMPL; }
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport);

    // IKsPin implementation
    STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM *pMediumList);
    STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM *pInterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium)
        { return E_UNEXPECTED; }
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION *pCommunication, KSPIN_INTERFACE *pInterface, KSPIN_MEDIUM *pMedium);
    STDMETHODIMP KsPropagateAcquire()
        { return NOERROR; }
    STDMETHODIMP KsDeliver(IMediaSample *pSample, ULONG Flags)
        { return E_UNEXPECTED; }
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation)
        { return NULL; }
    STDMETHODIMP KsReceiveAllocator( IMemAllocator *pMemAllocator)
        { return E_UNEXPECTED; }
    STDMETHODIMP KsRenegotiateAllocator()
        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount()
        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount()
        { return E_UNEXPECTED; }
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta)
        { return E_UNEXPECTED; };
    STDMETHODIMP_(REFERENCE_TIME) KsGetStartTime()
        { return E_UNEXPECTED; };
    STDMETHODIMP KsMediaSamplesCompleted(PKSSTREAM_SEGMENT StreamSegment)
        { return E_UNEXPECTED; }


    // IKsPin stuff
protected:
    KSPIN_MEDIUM m_Medium;
    GUID m_CategoryGUID;
    KSPIN_COMMUNICATION m_Communication;

    // helper functions
    void SetKsMedium(const KSPIN_MEDIUM *pMedium) {m_Medium = *pMedium;};
    void SetKsCategory (const GUID *pCategory) {m_CategoryGUID = *pCategory;};

private:
    // called in CompleteConnect
    HRESULT NegotiateConnectionParameters();
    HRESULT GetDecoderVPDataInfo();

    // All these functions are called from within StartVideo
    HRESULT GetVideoPortCaps();
    static HRESULT CALLBACK EnumCallback (DDVIDEOPORTCAPS* lpCaps, LPVOID lpContext);
    BOOL EqualPixelFormats(DDPIXELFORMAT* lpFormat1, DDPIXELFORMAT* lpFormat2);
    HRESULT GetBestFormat(DWORD dwNumInputFormats, DDPIXELFORMAT* lpddInputFormats,
        LPDWORD lpdwBestEntry, DDPIXELFORMAT* lpddBestOutputFormat);
    HRESULT CreateVideoPort();
    HRESULT CreateVPSurface(void);
    HRESULT SetDDrawKernelHandles();

    HRESULT GetInputPixelFormats( PixelFormatList* pList );
    HRESULT GetOutputPixelFormats( const PixelFormatList& ddInputFormats,
                PixelFormatList* pddOutputFormats );
    HRESULT NegotiatePixelFormat();
    HRESULT SetInputPixelFormat( DDPIXELFORMAT& ddFormat );

    HRESULT InitializeVideoPortInfo();

    // Other internal functions
    HRESULT SetupVideoPort();
    HRESULT TearDownVideoPort();
    HRESULT StartVideo();
    HRESULT StopVideo();

private:
    // Critical sections
    CCritSec*                m_pMainObjLock;                // Lock given by controlling object

    // ddraw stuff
    LPDIRECTDRAW7            m_pDirectDraw;                  // DirectDraw service provider

    // surface related stuff
    LPDIRECTDRAWSURFACE7     m_pOffscreenSurf;
    LPDIRECTDRAWSURFACE     m_pOffscreenSurf1;
    

    // enum to specify, whether the videoport is in a stopped or running state
    // or has been torn down because its surfaces were stolen by a full-screen DOS app
    // or a DirectX app.
    enum VP_STATE {VP_STATE_NO_VP, VP_STATE_STOPPED, VP_STATE_RUNNING};

    // variables to store current state etc
    VP_STATE                m_VPState;
    BOOL                    m_bConnected;
    BOOL                    m_bFilterRunning;
    
    // vp data structures
    IVPVBIConfig*           m_pIVPConfig;
    DWORD                   m_dwVideoPortId;
    DWORD                   m_dwPixelsPerSecond;
    LPDDVIDEOPORTCONTAINER  m_pDDVPContainer;
    LPDIRECTDRAWVIDEOPORT   m_pVideoPort;
    DDVIDEOPORTINFO         m_svpInfo;
    DDVIDEOPORTCAPS         m_vpCaps;
    DDVIDEOPORTCONNECT      m_vpConnectInfo;

    // capture driver structures
    AMVPDATAINFO            m_capVPDataInfo;
    
    // All the pixel formats (Video)
    DWORD                   m_dwDefaultOutputFormat;    // which one we'll assume for the connection
    DDPIXELFORMAT           m_ddVPInputVideoFormat;
    DDPIXELFORMAT           m_ddVPOutputVideoFormat;

    BOOL    m_bHalfLineFix;
    // surface parameters
    DWORD m_dwSurfacePitch;
    DWORD m_dwSurfaceHeight;
    DWORD m_dwSurfaceOriginX;
    DWORD m_dwSurfaceOriginY;


};

#endif //__VBIOBJ__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmoutpin.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <VPManager.h>
#include <VPMPin.h>
#include <VPMUtil.h>

// VIDEOINFOHDR2
#include <dvdmedia.h>


static HRESULT GetSurfaceFromSample( LPDIRECTDRAWSURFACE7* ppDDSurf7, IMediaSample* pSample )
{
    AMTRACE((TEXT("GetSurfaceFromSample")));
    HRESULT hr = E_FAIL;
    {
        // make sure its a VMRSurfaceAlloc or a DirectDrawSurfaceAlloc for now
        IVMRSurface* pVMRSurf;
        hr = pSample->QueryInterface( IID_IVMRSurface, (VOID **) &pVMRSurf );
        if( SUCCEEDED( hr )) {
            // the AM_GBF_NODDSURFACELOCK flag avoids the need to lock the surface
            hr = pVMRSurf->GetSurface( ppDDSurf7 );
        }
        pVMRSurf->Release();
    }
#if 0
    // try direct draw sample alloc
    if( FAILED(hr)) {
        // make sure its a VMRSurfaceAlloc or a DirectDrawSurfaceAlloc for now
        IDirectDrawMediaSample* pDDSample;
        HRESULT hr = pSample->QueryInterface( IID_IDirectDrawMediaSample, (VOID **) &pDDSample );
        if( SUCCEEDED( hr )) {
            LPDIRECTDRAWSURFACE pDDSurf;
            hr = pDDSample->GetSurfaceAndReleaseLock( &pDDSurf, NULL );
            if( SUCCEEDED( hr )) {
                hr = pDDSurf->QueryInterface( IID_IDirectDrawSurface7, (VOID **) &ppDDSurf7 );
                pDDSurf->Release();
            }
            pDDSample->Release();
        }
    }
#endif
    if( FAILED(hr)) {
        // TBD: create a DDraw wrapper for the surface
        ASSERT(!"VPM: Can't handle non-DDraw sample from downstream filter");
    }
    return hr;
}

// constructor
CVPMOutputPin::CVPMOutputPin(TCHAR *pObjectName, CVPMFilter& pFilter,
                             HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo)
: CBaseOutputPin(pObjectName, &pFilter, &pFilter.GetFilterLock(), phr, pPinName)
, CVPMPin( dwPinNo, pFilter )
, m_pPosition( NULL )
{
    AMTRACE((TEXT("CVPMOutputPin::Constructor")));
    return;
}

// destructor
CVPMOutputPin::~CVPMOutputPin()
{
    AMTRACE((TEXT("CVPMOutputPin::Destructor")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    RELEASE( m_pPosition );
    return;
}

// overriden to expose IMediaPosition and IMediaSeeking control interfaces
STDMETHODIMP CVPMOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;



    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking)
    {
        // we should have an input pin by now
        CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
        if (m_pPosition == NULL)
        {
            hr = CreatePosPassThru(GetOwner(), FALSE, (IPin *)m_pVPMFilter.GetPin(0), &m_pPosition);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
        hr = m_pPosition->QueryInterface(riid, ppv);
        goto CleanUp;
    }

    // This gets annoying since IMediaSeeking is polled, so move below it
    {
        AMTRACE((TEXT("CVPMOutputPin::NonDelegatingQueryInterface")));
        DbgLog((LOG_TRACE, 5, TEXT("QI'ing CBaseOutputPin")));
        hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("CBaseOutputPin::NonDelegatingQueryInterface(riid) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

CleanUp:
    return hr;
}

// check a given transform
HRESULT CVPMOutputPin::CheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMOutputPin::CheckMediaType")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // we only allow a VideoInfoHeader2 connections
    if( pmt->majortype != MEDIATYPE_Video ||
        !VPMUtil::GetVideoInfoHeader2( pmt ) )
    {
        hr = S_FALSE;
        goto CleanUp;
    }

    // Only accept VideoInfoHeader2 format types


    // tell the owning filter
    hr = m_pVPMFilter.CheckMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5, TEXT("m_pVPMFilter.CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

enum ENUM_MEDIA_TYPE   {MT_RGB32, MT_RGB24, MT_RGB565, MT_RGB555,
                        MT_LAST };

HRESULT CVPMOutputPin::GetMediaType(int iPosition,CMediaType *pmt)
{
    AMTRACE((TEXT("CVPMOutputPin::GetMediaType")));

    //  Can't be < 0 - it's the base classes calling us
    ASSERT(iPosition >= 0);
    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());


    DDPIXELFORMAT ddOutputVideoFormat;
    HRESULT hr = m_pVPMFilter.GetOutputFormat( &ddOutputVideoFormat );
    if( FAILED( hr )) {
        // when input pin is not connected, it returns VFW_E_NOT_CONNECTED
        return hr;
    }

    // limit scope of cmt & associated pointers to it
    {
        CMediaType cmt;
        hr = m_pVPMFilter.CurrentInputMediaType( &cmt );
        if( FAILED( hr )) {
            return hr;
        }
        VIDEOINFOHEADER2 *pVideoInfoHeader2;
        if (*cmt.Type() != MEDIATYPE_Video) {
            ASSERT( !"none video type from VPE" );
            pVideoInfoHeader2 = VPMUtil::SetToVideoInfoHeader2( &cmt, sizeof(TRUECOLORINFO) );
            if (pVideoInfoHeader2 == NULL) {
                return E_OUTOFMEMORY;
            }
        } else {
            pVideoInfoHeader2 = VPMUtil::GetVideoInfoHeader2( &cmt );
        }

        // only support the connected VPE format, ignore the lists
        // match the VPE pin for now
        BITMAPINFOHEADER *pHeader = VPMUtil::GetbmiHeader( &cmt );

        if ( ! pHeader )
        {
            return E_FAIL;
        }

        const DDPIXELFORMAT& ddFormat = ddOutputVideoFormat; // (*pddAllOutputVideoFormats)[iPosition];

        DWORD dwFourCC = ddFormat.dwFourCC;

        switch( dwFourCC ) {
            case mmioFOURCC('Y','V','1','2'):
            case mmioFOURCC('Y','U','Y','2'):
            case mmioFOURCC('U','Y','V','Y'):
                pHeader->biBitCount  = (USHORT) ddFormat.dwYUVBitCount;
                break;

            default:
            pHeader->biBitCount = (USHORT) ddFormat.dwRGBBitCount;
            break;
        }
        // map the FourCC code into a guid
        FOURCCMap guid( dwFourCC );
        cmt.SetSubtype(&guid);
        pHeader->biCompression = dwFourCC;

        *pmt = cmt;
        if (pmt->pbFormat == NULL) {
                return E_OUTOFMEMORY;
        }
    }

    // get mode info so we know how many interlace formats to propose
    VPInfo vpInfo;
    hr = m_pVPMFilter.GetVPInfo( &vpInfo );

    VIDEOINFOHEADER2 *pVideoInfoHeader2 = VPMUtil::GetVideoInfoHeader2( pmt );
    pVideoInfoHeader2->dwInterlaceFlags = 0;

    // TBD: we should query the video port for a list of available modes
    //          and set it using the mode.  Right now we'll assume the hardware
    //         can support the videoport's output.
    //
    DWORD dwNumFormats = 1;

    if( iPosition >= (int) dwNumFormats ) {
        return VFW_S_NO_MORE_ITEMS;
    }

    if( SUCCEEDED( hr )) {
        pVideoInfoHeader2->dwPictAspectRatioX = vpInfo.vpDataInfo.dwPictAspectRatioX;
        pVideoInfoHeader2->dwPictAspectRatioY = vpInfo.vpDataInfo.dwPictAspectRatioY;

        switch( vpInfo.mode ) {
            case AMVP_MODE_BOBNONINTERLEAVED:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_IsInterlaced | AMINTERLACE_1FieldPerSample | AMINTERLACE_DisplayModeBobOnly;
                break;
            case AMVP_MODE_BOBINTERLEAVED:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_IsInterlaced | AMINTERLACE_DisplayModeBobOnly;
                pVideoInfoHeader2->bmiHeader.biHeight *= 2;
                break;
            case AMVP_MODE_WEAVE:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_IsInterlaced | AMINTERLACE_FieldPatBothRegular | AMINTERLACE_DisplayModeWeaveOnly;
                pVideoInfoHeader2->bmiHeader.biHeight *= 2;
                break;
            case AMVP_MODE_SKIPEVEN:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_1FieldPerSample | AMINTERLACE_FieldPatField1Only;
                break;
            case AMVP_MODE_SKIPODD:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_1FieldPerSample | AMINTERLACE_FieldPatField2Only;
                break;
            default:
                ASSERT( !"VPM in an invalid state" );
                pVideoInfoHeader2->dwInterlaceFlags = 0;
                break;
        }
        // AMINTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
        if( vpInfo.vpDataInfo.bFieldPolarityInverted ) {            // Device inverts the polarity by default
            pVideoInfoHeader2->dwInterlaceFlags |= AMINTERLACE_Field1First;
        }
    } else {
        pVideoInfoHeader2->dwPictAspectRatioX = 1; // (DWORD)(pVideoInfoHeader22->bmiHeader.biWidth * m_seqInfo.lYPelsPerMeter);
        pVideoInfoHeader2->dwPictAspectRatioY = 1; // (DWORD)(pVideoInfoHeader22->bmiHeader.biHeight * m_seqInfo.lXPelsPerMeter);
    }
    return hr;
}

// called after we have agreed a media type to actually set it
HRESULT CVPMOutputPin::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMOutputPin::SetMediaType")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Set the base class media type (should always succeed)

    // Sets m_mt = *pmt;

    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pVPMFilter.SetMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// Complete Connect
HRESULT CVPMOutputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    DWORD dwAdvise = 0, dwInputPinCount = 0, i = 0;
    DDSURFACEDESC SurfaceDescP;
    CVPMInputPin *pInputPin = NULL;
    BOOL bDoDeletePrimSurface = TRUE;

    AMTRACE((TEXT("CVPMOutputPin::CompleteConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // call the base class
    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::CompleteConnect failed, hr = 0x%x"),
            hr));
        goto CleanUp;
    }

    ASSERT(m_pAllocator);

    // tell the owning filter
    hr = m_pVPMFilter.CompleteConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

HRESULT CVPMOutputPin::BreakConnect()
{
    HRESULT hr = NOERROR;
    DWORD dwInputPinCount = 0, i = 0;
    CVPMInputPin *pInputPin;

    AMTRACE((TEXT("CVPMOutputPin::BreakConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // call the base class
    hr = CBaseOutputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::BreakConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pVPMFilter.BreakConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.BreakConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

HRESULT CVPMOutputPin::CheckConnect(IPin* pPin)
{
    AMTRACE((TEXT("CVPMOutputPin::CheckConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    HRESULT hr = CBaseOutputPin::CheckConnect( pPin );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::CheckConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

STDMETHODIMP CVPMOutputPin::Notify(IBaseFilter * pSender, Quality q)
{
    return S_OK;
}



HRESULT CVPMOutputPin::GetNextBuffer( LPDIRECTDRAWSURFACE7* ppSurface, IMediaSample** ppSample )
{
    AMTRACE((TEXT("CVPMOutputPin::GetNextBuffer")));

    CAutoLock cLock(&m_pVPMFilter.GetReceiveLock());
    HRESULT hr = E_FAIL;

    if( m_pAllocator ) {
        hr = m_pAllocator->GetBuffer( ppSample, NULL, NULL, AM_GBF_NODDSURFACELOCK );
        if( SUCCEEDED( hr )) {
            // now see if we can get the surface
            hr = GetSurfaceFromSample( ppSurface, *ppSample );
        }
    }
    return hr;
}

HRESULT CVPMOutputPin::SendSample( IMediaSample* pSample )
{
    AMTRACE((TEXT("CVPMOutputPin::SendSample")));

    // DbgLog((LOG_TRACE, 1, TEXT("CVPMOutputPin::SendSample %x%x"), DWORD( rtStart>>32), DWORD(rtStart) ));

    CAutoLock cLock(&m_pVPMFilter.GetReceiveLock());
    HRESULT hr = E_FAIL;

    if( m_pInputPin ) {
        hr = m_pInputPin->Receive( pSample );
    }
    return hr;
}

// we don't have an allocator, so fail any connections that don't supply one for us
// (we don't want the default one for now);
HRESULT CVPMOutputPin::InitAllocator(IMemAllocator **ppAlloc)
{
    return E_FAIL;
}

HRESULT CVPMOutputPin::DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pRequestedProperties)
{
    AMTRACE((TEXT("CVPMOutputPin::DecideBufferSize")));
    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.

    pRequestedProperties->cBuffers = 1;
    pRequestedProperties->cbBuffer = m_mt.GetSampleSize();

    ASSERT(pRequestedProperties->cbBuffer > 0);

    ALLOCATOR_PROPERTIES propActual;
    HRESULT hr = pAllocator->SetProperties(pRequestedProperties, &propActual );
    if (FAILED(hr)) {
        return hr;
    }

    // if (propActual.cbBuffer < (LONG)m_pOutput->CurrentMediaType().GetSampleSize()) {
    //     // can't use this allocator
    //     return E_INVALIDARG;
    // }

    //  We don't really mind if we get > 1 buffer because we always
    //  blt the entire image

    return S_OK;
}

static bool IsVMR( IMemInputPin *pMemPin )
{
    IPin* pPin;
    HRESULT hr = pMemPin->QueryInterface( IID_IPin, (LPVOID*) &pPin );
    if( SUCCEEDED(hr )) {
        PIN_INFO PinInfo;
        hr = pPin->QueryPinInfo(&PinInfo);
        if (SUCCEEDED(hr)) {
            IVMRFilterConfig* pVMRFilterConfig = NULL;

            hr = PinInfo.pFilter->QueryInterface(IID_IVMRFilterConfig, (LPVOID*)&pVMRFilterConfig);
            PinInfo.pFilter->Release();
            if( SUCCEEDED( hr )) {
                pVMRFilterConfig->Release();
            }
        }
        pPin->Release();
    }
    return SUCCEEDED( hr );
}

HRESULT CVPMOutputPin::DecideAllocator(
    IMemInputPin *pPin,
    IMemAllocator **ppAlloc
)
{
    HRESULT hr = NOERROR;

    // make sure downstream filter support IVPMAlloc
    if( IsVMR( pPin ) )
    {
        return CBaseOutputPin::DecideAllocator( pPin, ppAlloc );
    } else {
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmfilter.cpp ===
/******************************Module*Header*******************************\
* Module Name: CVPMFilter.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Glenn Evans [GlennE]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <limits.h>

// IID_IDirectDraw7
#include <ddraw.h>

#ifdef FILTER_DLL
#include <initguid.h>
DEFINE_GUID(IID_IDirectDraw7, 0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b);
#endif

#include <VPManager.h>
#include <VPMExtern.h>
#include <VPMPin.h>
#include "DRect.h"
#include "VPMUtil.h"
#include "VPMThread.h"
#include <VBIObj.h>

// VIDEOINFOHEADER1/2
#include <dvdmedia.h>

// IDirectDrawKernel / GetKernCaps
#include <ddkernel.h>


// Setup data
AMOVIESETUP_MEDIATYPE sudPinOutputTypes[] =
{
    {
        &MEDIATYPE_Video,      // Major type
        &MEDIASUBTYPE_NULL     // Minor type
    }
};
AMOVIESETUP_MEDIATYPE sudPinInputTypesVP[] =
{
    {
        &MEDIATYPE_Video,      // Major type
        &MEDIASUBTYPE_VPVideo  // Minor type
    },
};

AMOVIESETUP_MEDIATYPE sudPinInputTypesVBI[] =
{
    {
        &MEDIATYPE_Video,      // Major type
        &MEDIASUBTYPE_VPVBI    // Minor type
    }
};

AMOVIESETUP_PIN psudPins[] =
{
    {
        L"VPIn",                    // Pin's string name
        FALSE,                      // Is it rendered
        FALSE,                      // Is it an output
        FALSE,                      // Allowed none
        FALSE,                      // Allowed many
        &CLSID_NULL,                // Connects to filter
        L"Output",                  // Connects to pin
        NUMELMS(sudPinInputTypesVP),// Number of types
        sudPinInputTypesVP          // Pin information
    },
    {
        L"VBIIn",                   // Pin's string name
        FALSE,                      // Is it rendered
        FALSE,                      // Is it an output
        FALSE,                      // Allowed none
        FALSE,                      // Allowed many
        &CLSID_NULL,                // Connects to filter
        NULL,                       // Connects to pin
        NUMELMS(sudPinInputTypesVBI),// Number of types
        sudPinInputTypesVBI         // Pin information
    },
    {
        L"Output",                  // Pin's string name
        FALSE,                      // Is it rendered
        TRUE,                       // Is it an output
        FALSE,                      // Allowed none
        FALSE,                      // Allowed many
        &CLSID_NULL,                // Connects to filter
        L"VPIn",                    // Connects to pin
        NUMELMS(sudPinOutputTypes), // Number of types
        sudPinOutputTypes           // Pin information
    }
};

const AMOVIESETUP_FILTER sudVPManager =
{
    &CLSID_VideoPortManager,     // Filter CLSID
    L"Video Port Manager", // Filter name
    MERIT_NORMAL ,    // Filter merit
    sizeof(psudPins) / sizeof(AMOVIESETUP_PIN), // Number pins
    psudPins                  // Pin details
};

#ifdef FILTER_DLL
// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance
//
//  Property set defines for notifying owner.
//
// {7B390654-9F74-11d1-AA80-00C04FC31D60}
//#define DO_INIT_GUID
// DEFINE_GUID(AMPROPSETID_NotifyOwner,
//             0x7b390654, 0x9f74, 0x11d1, 0xaa, 0x80, 0x0, 0xc0, 0x4f, 0xc3, 0x1d, 0x60);
//#undef DO_INIT_GUID

CFactoryTemplate g_Templates[] =
{
    { L"Video Port Manager", &CLSID_VideoPortManager, CVPMFilter::CreateInstance, NULL, &sudVPManager },
    //{ L"", &CLSID_COMQualityProperties,COMQualityProperties::CreateInstance},
    //{ L"", &CLSID_COMPinConfigProperties,COMPinConfigProperties::CreateInstance},
    //{ L"", &CLSID_COMPositionProperties,COMPositionProperties::CreateInstance},
    //{ L"", &CLSID_COMVPInfoProperties,COMVPInfoProperties::CreateInstance}

};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// DllRegisterSever
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
} // DllRegisterServer


// DllUnregisterServer
HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
} // DllUnregisterServer

#endif // FILTER_DLL

// CreateInstance
CUnknown* CVPMFilter_CreateInstance(LPUNKNOWN pUnk, HRESULT* phr)
{
    return CVPMFilter::CreateInstance( pUnk, phr);
}

// This goes in the factory template table to create new filter instances
CUnknown *CVPMFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CVPMFilter(NAME("VideoPort Manager"), pUnk, phr );
} // CreateInstance

#pragma warning(disable:4355)

CVPMFilter::Pins::Pins( CVPMFilter& filter, HRESULT* phr )
: VPInput(NAME("VPManager Input pin"), filter, phr, L"VP Input", 0)
, VBIInput(NAME("VPManager Input pin"), filter, phr, L"VPVBI Input", 1)
, Output( NAME("VPManager Output pin"), filter, phr, L"Output", 2)
, dwCount( 3 )
{
}

CVPMFilter::Pins::~Pins()
{
}

// Constructor
CVPMFilter::CVPMFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
: CBaseFilter(pName, pUnk, &this->m_csFilter, CLSID_VideoPortManager, phr)
, m_pPosition(NULL)
, m_dwKernelCaps(0)
, m_dwPinConfigNext(0)
, m_pDirectDraw( NULL )
, m_dwDecimation( DECIMATION_LEGACY )
, m_pPins( NULL )
, m_pThread( NULL )
, m_dwVideoPortID( 0 )
    // create the pins
{
    AMTRACE((TEXT("Entering CVPMFilter::CVPMFilter")));
    m_pPins = new Pins( *this, phr );    // must be init'd after filter constructor since depends on 'this'
    if( !m_pPins ) {
        *phr = E_OUTOFMEMORY;
    } else {
        IncrementPinVersion();

        ZeroStruct( m_DirectCaps );
        ZeroStruct( m_DirectSoftCaps );

        HRESULT hr = NOERROR;
        ASSERT(phr != NULL);

        //
        // Initialize DDraw the MMon structures
        //

        SetDecimationUsage(DECIMATION_DEFAULT);

        // distribute DDraw object to the pins
        hr = InitDirectDraw(NULL);

        // can fail if the hardware caps are not usable
        if( SUCCEEDED( hr ) ) {
            SetDirectDraw( m_pDirectDraw );
        }
    }
}

CVPMFilter::~CVPMFilter()
{
    AMTRACE((TEXT("Entering CVPMFilter::~CVPMFilter")));
    delete m_pThread;
    m_pThread = NULL;

    RELEASE( m_pPosition );
    // release directdraw, Source surface etc.
    ReleaseDirectDraw();

    RELEASE( m_pPosition ); // release IMediaSeeking pass through
    delete m_pPins;
}

// NonDelegatingQueryInterface
STDMETHODIMP CVPMFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    AMTRACE((TEXT("CVPMFilter::NonDelegatingQueryInterface")));
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    if( riid == IID_IVPManager ) {
        return GetInterface( static_cast<IVPManager *>(this), ppv );
    }
    else if (riid == IID_IAMVideoDecimationProperties) {
        return GetInterface( static_cast<IAMVideoDecimationProperties *>( this ), ppv);
    } else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        // we should have an input pin by now
        if (m_pPosition == NULL) {
            HRESULT hr = CreatePosPassThru(GetOwner(), FALSE, &m_pPins->VPInput, &m_pPosition);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1, TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
                return hr;
            }
        }
        return m_pPosition->QueryInterface(riid, ppv);
    } else if (riid == IID_ISpecifyPropertyPages && 0 != VPMUtil::GetPropPagesRegistryDword( 0) ) {
        return GetInterface( static_cast<ISpecifyPropertyPages *>( this ), ppv);
    } else if (riid == IID_IQualProp) {
        return GetInterface( static_cast<IQualProp *>( this ), ppv);
    } else if (riid == IID_IKsPropertySet) {
        return GetInterface( static_cast<IKsPropertySet *>( this ), ppv);
    }

    CAutoLock lFilter( &GetFilterLock() );

    //
    //  BUGBUG - this is not COM.  This would imply that our input
    //  pin is the same object as our filter

    //  We should proxy these calls

    if (riid == IID_IVPNotify || riid == IID_IVPNotify2 || riid == IID_IVideoPortInfo) {
        ASSERT( !"VPNotify nondel QI'd" );
        return m_pPins->VPInput.NonDelegatingQueryInterface(riid, ppv);
    } else if (riid == IID_IVPVBINotify) {
        ASSERT( !"IID_IVPVBINotify nondel QI'd" );
        return m_pPins->VBIInput.NonDelegatingQueryInterface(riid, ppv);
    }

    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CVPMFilter::GetPages(CAUUID *pPages)
{
#if 0
#if defined(DEBUG)
    pPages->cElems = 4+m_dwInputPinCount;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(4+m_dwInputPinCount));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

    #define COM_QUAL
    #ifdef COM_QUAL
        pPages->pElems[0]   = CLSID_COMQualityProperties;
    #else
        pPages->pElems[0]   = CLSID_QualityProperties;
    #endif

    pPages->pElems[1] = CLSID_COMPositionProperties;
    pPages->pElems[2] = CLSID_COMVPInfoProperties;
    pPages->pElems[3] = CLSID_COMDecimationProperties;

    // Add PinConfig page for all input pins first
    for (unsigned int i=0; i<m_dwInputPinCount; i++)
    {
        pPages->pElems[4+i] = CLSID_COMPinConfigProperties;
    }
#else
    pPages->cElems = 3+m_dwInputPinCount;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(3+m_dwInputPinCount));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

    #define COM_QUAL
    #ifdef COM_QUAL
        pPages->pElems[0]   = CLSID_COMQualityProperties;
    #else
        pPages->pElems[0]   = CLSID_QualityProperties;
    #endif

    pPages->pElems[1] = CLSID_COMPositionProperties;
    pPages->pElems[2] = CLSID_COMVPInfoProperties;

    // Add PinConfig page for all input pins first
    for (unsigned int i=0; i<m_dwInputPinCount; i++)
    {
        pPages->pElems[3+i] = CLSID_COMPinConfigProperties;
    }

#endif
#endif
    return NOERROR;
}

// IQualProp property page support

STDMETHODIMP CVPMFilter::get_FramesDroppedInRenderer(int *cFramesDropped)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_FramesDroppedInRenderer(cFramesDropped);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_FramesDrawn(int *pcFramesDrawn)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_FramesDrawn(pcFramesDrawn);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_AvgFrameRate(int *piAvgFrameRate)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_AvgFrameRate(piAvgFrameRate);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_Jitter(int *piJitter)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_Jitter(piJitter);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_AvgSyncOffset(int *piAvg)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_AvgSyncOffset(piAvg);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_DevSyncOffset(int *piDev)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_DevSyncOffset(piDev);
    return S_FALSE;
}

int CVPMFilter::GetPinCount()
{
    return m_pPins->dwCount;
}

// returns a non-addrefed CBasePin *
CBasePin* CVPMFilter::GetPin(int n)
{
    AMTRACE((TEXT("CVPMFilter::GetPin")));

    CAutoLock lFilter( &GetFilterLock() );

    // check that the pin requested is within range
    if (n >= (int)m_pPins->dwCount)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Bad Pin Requested, n = %d, No. of Pins = %d"),
            n, m_pPins->dwCount+1));
        return NULL;
    }
    switch( n ) {
    case 0:
        return &m_pPins->VPInput;
    case 1:
        return &m_pPins->VBIInput;
    default:
        return &m_pPins->Output;
    }
}

HRESULT CVPMFilter::CreateThread()
{
    if( !m_pThread ) {
        m_pThread = new CVPMThread( this );
        if( !m_pThread ) {
            return E_OUTOFMEMORY;
        }

        LPDIRECTDRAWVIDEOPORT pVP = NULL;
        HRESULT hr = m_pPins->VPInput.m_pIVPObject->GetDirectDrawVideoPort( &pVP );
        m_pThread->SignalNewVP( pVP );
        RELEASE( pVP );
    }
    return S_OK;
}


/******************************Public*Routine******************************\
* CVPMFilter::Run
*
*
*
* History:
* Fri 02/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::Run(
    REFERENCE_TIME StartTime
    )
{
    AMTRACE((TEXT("CVPMFilter::Run")));
    CAutoLock lFilter( &GetFilterLock() );

    if (m_State == State_Running) {
        NOTE("State set");
        return S_OK;
    }

    DbgLog((LOG_TRACE, 2, TEXT("Changing state to running")));
    HRESULT hr = CBaseFilter::Run(StartTime);
    if( SUCCEEDED( hr )) {
        hr = CreateThread();
        if( SUCCEEDED( hr )) {
            hr = m_pThread->Run();
        }
    }
    return hr;
}

// the base classes inform the pins of every state transition except from
// run to pause. Overriding Pause to inform the input pins about that transition also
STDMETHODIMP CVPMFilter::Pause()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMFilter::Pause")));

    CAutoLock lFilter( &GetFilterLock() );

    switch( m_State ) {
        case State_Paused:
            hr = m_pPins->VPInput.CompleteStateChange(State_Paused);
            if( FAILED(hr)) {
                return hr;
            }
            break;

        case State_Running:
            m_State = State_Paused;
            // set the pointer to DirectDraw and the SourceSurface on All the Input Pins
            if( m_pPins->VPInput.IsConnected() ) {
                hr = m_pPins->VPInput.RunToPause();
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR, 1, TEXT("GetVPInputPin.RunToPause failed, hr = 0x%x"), hr));
                    return hr;
                }
            }
            if( m_pPins->VBIInput.IsConnected() ) {
                hr = m_pPins->VBIInput.RunToPause();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 1, TEXT("GetVBIInputPin.RunToPause failed, hr = 0x%x"), hr));
                    return hr;
                }
            }
            break;

        default:
            break;
    }
    hr = CBaseFilter::Pause();
    if( SUCCEEDED(hr)) {
        if ( m_State != State_Paused )
        {
            hr = m_pPins->VPInput.CompleteStateChange(State_Paused);
            if( SUCCEEDED( hr )) {
                hr = CreateThread();
            }
            if( SUCCEEDED( hr ) ) {
                // we don't want to hold the filter lock and wait for the thread
                // since we'll deadlock if it uses any of our methods
                hr = m_pThread->Pause();
            }
        }
    }
    return hr;
}

// Overridden the base class Stop() method just to stop MV.
STDMETHODIMP CVPMFilter::Stop()
{
    AMTRACE((TEXT("CVPMFilter::Stop")));

    CAutoLock lFilter( &GetFilterLock() ) ;

    // stop thread BEFORE taking the receive lock (otherwise we'll hold it and the thread
    // could want it to send a sample)
    HRESULT  hr = NOERROR ;
    if( m_pThread ) {
        hr = m_pThread->Stop();
        ASSERT( SUCCEEDED( hr ));
    }

    CAutoLock lReceive( &GetReceiveLock() );
    hr = CBaseFilter::Stop() ;
    return hr ;
}


int CVPMFilter::GetPinPosFromId(DWORD dwPinId)
{
    if ( m_pPins->VPInput.GetPinId() == dwPinId) {
        return 0;
    }
    if ( m_pPins->VBIInput.GetPinId() == dwPinId) {
        return 1;
    }
    if ( m_pPins->Output.GetPinId() == dwPinId) {
        return 2;
    }
    return -1;
}


// reconnect the output pin based on the mediatype of the input pin
HRESULT CVPMFilter::HandleConnectInputWithOutput()
{
    // we won't allow this, you must disconnect the output first
    // Future: We could try a dynamic reconnect on the output...
    return E_FAIL;
#if 0
    return S_OK;
    // find the renderer's pin
    pPeerOutputPin = m_pPins->Output.GetConnected();
    if (pPeerOutputPin == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("ConnectedTo failed")));
        goto CleanUp;
    }
    ASSERT(pPeerOutputPin);

    // find the output pin connection mediatype
    hr = m_pPins->Output.ConnectionMediaType(&outPinMediaType);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("ConnectionMediaType failed")));
        goto CleanUp;
    }


    pHeader = VPMUtil::GetbmiHeader(&outPinMediaType);
    if (!pHeader)
    {
        hr = E_FAIL;
        goto CleanUp;
    }


    // compare the new values with the current ones.
    // See if we need to reconnect at all
    if (pHeader->biWidth != (LONG)m_dwAdjustedVideoWidth ||
        pHeader->biHeight != (LONG)m_dwAdjustedVideoHeight)
    {
        bNeededReconnection = TRUE;
    }

    // If we don't need reconnection, bail out
    if (bNeededReconnection)
    {

        // Ok we do need reconnection, set the right values
        pHeader->biWidth = m_dwAdjustedVideoWidth;
        pHeader->biHeight = m_dwAdjustedVideoHeight;
        if (outPinMediaType.formattype == FORMAT_VideoInfo)
        {
            VIDEOINFOHEADER* pVIHeader = (VIDEOINFOHEADER*)(outPinMediaType.pbFormat);
            SetRect(&pVIHeader->rcSource, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
            SetRect(&pVIHeader->rcTarget, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
        }
        else if (outPinMediaType.formattype == FORMAT_VideoInfo2)
        {
            VIDEOINFOHEADER2* pVIHeader = (VIDEOINFOHEADER2*)(outPinMediaType.pbFormat);
            SetRect(&pVIHeader->rcSource, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
            SetRect(&pVIHeader->rcTarget, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
        }


        // Query the upstream filter asking if it will accept the new media type.
        hr = pPeerOutputPin->QueryAccept(&outPinMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("m_pVPDraw->QueryAccept failed")));
            goto CleanUp;
        }

        // Reconnect using the new media type.
        hr = ReconnectPin(pPeerOutputPin, &outPinMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("m_pVPDraw->Reconnect failed")));
            goto CleanUp;
        }
    }
#endif
}


HRESULT CVPMFilter::CompleteConnect(DWORD dwPinId)
{
    AMTRACE((TEXT("CVPMFilter::CompleteConnect")));

    CAutoLock lFilter( &GetFilterLock() );
    CAutoLock lReceive( &GetReceiveLock() );

    int iPinPos = GetPinPosFromId(dwPinId);
    ASSERT(iPinPos >= 0 );

    // we only care about format conflicts between the VP & output, VBI isn't an issue (just allocating memory for someone else)
    HRESULT hr;
    if ( m_pPins->VPInput.GetPinId() == dwPinId ) {
        if( !m_pPins->Output.IsConnected() ) {
            hr = HandleConnectInputWithoutOutput();
        } else {
            hr = HandleConnectInputWithOutput();
        }
    } else if( m_pPins->Output.GetPinId() == dwPinId ) {
        if( !m_pPins->VPInput.IsConnected() ) {
            // HandleConnectOutputWithoutInput();
            // We need an input...
            return E_FAIL;
        } else {
            //  HandleConnectOutputWithInput();
            // we have already created a source surface, we restrict format types
            // on the output pin to avoid conversions in the VPM
            return S_OK;
        }
    } else {
        hr = S_OK;
    }
    return hr;
}

HRESULT CVPMFilter::HandleConnectInputWithoutOutput()
{
    AMTRACE((TEXT("CVPMFilter::HandleConnectInputWithoutOutput")));

    CMediaType inPinMediaType;
    CMediaType outPinMediaType;

    IPin *pPeerOutputPin = NULL;

    BOOL bNeededReconnection = FALSE;
    DWORD dwNewWidth = 0, dwNewHeight = 0, dwPictAspectRatioX = 0, dwPictAspectRatioY = 0;
    DRect rdDim;
    RECT rDim;
    BITMAPINFOHEADER *pHeader = NULL;

    // find the input pin connection mediatype
    HRESULT hr = m_pPins->VPInput.CurrentMediaType(&inPinMediaType);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("CurrentMediaType failed")));
        goto CleanUp;
    }

    pHeader = VPMUtil::GetbmiHeader(&inPinMediaType);
    if (!pHeader)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    hr = VPMUtil::GetPictAspectRatio( inPinMediaType, &dwPictAspectRatioX, &dwPictAspectRatioY);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetPictAspectRatio failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwPictAspectRatioX > 0);
    ASSERT(dwPictAspectRatioY > 0);

    hr = m_pPins->VPInput.AttachVideoPortToSurface();
    // ASSERT( SUCCEEDED( hr) );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->AttachVideoPortToSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
CleanUp:
    return hr;
}

HRESULT CVPMFilter::BreakConnect(DWORD dwPinId)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVPMFilter::BreakConnect")));

    CAutoLock lFilter( &GetFilterLock() );
    CAutoLock lReceive( &GetReceiveLock() );

    int iPinPos = GetPinPosFromId(dwPinId);
    ASSERT(iPinPos >= 0 );

    // if atleast one pin is connected, we are not going to do anything
    hr = ConfirmPreConnectionState(dwPinId);
    if (FAILED(hr))
    {

        DbgLog((LOG_TRACE, 3, TEXT("filter not in preconnection state, hr = 0x%x"), hr));
        goto CleanUp;
    }


CleanUp:
    return NOERROR;
}

HRESULT CVPMFilter::SetMediaType(DWORD dwPinId, const CMediaType *pmt)
{
    AMTRACE((TEXT("CVPMFilter::SetMediaType")));

    CAutoLock lFilter( &GetFilterLock() );

    // reject all SetMediaTypes if the DDraw object wasn't compatible
    if( m_pDirectDraw ) {
        return NOERROR;
    } else {
        return E_FAIL;
    }
}

// gets events notifications from pins
HRESULT CVPMFilter::EventNotify(    DWORD dwPinId,
                                long lEventCode,
                                DWORD_PTR lEventParam1,
                                DWORD_PTR lEventParam2)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EventNotify")));

    CAutoLock lFilter( &GetFilterLock() );

    if (lEventCode == EC_COMPLETE)
    {
        IPin *pRendererPin = m_pPins->Output.CurrentPeer();

        //  Output pin may not be connected (for instance
        //  RenegotiateVPParameters can fail while connecting
        if (pRendererPin) {
            pRendererPin->EndOfStream();
        }
    } else {
        NotifyEvent(lEventCode, lEventParam1, lEventParam2);
    }

    return hr;
}

STDMETHODIMP CVPMFilter::GetState(DWORD dwMSecs,FILTER_STATE *pState)
{
    HRESULT hr = NOERROR;

    CAutoLock lFilter( &GetFilterLock() );

    hr = m_pPins->VPInput.GetState(dwMSecs, pState);
    if (hr == E_NOTIMPL)
    {
        hr = CBaseFilter::GetState(dwMSecs, pState);
    }
    return hr;
}



const DDCAPS* CVPMFilter::GetHardwareCaps()
{
    HRESULT hr;

    AMTRACE((TEXT("CVPMFilter::GetHardwareCaps")));

    CAutoLock lFilter( &GetFilterLock() );

    if (!m_pDirectDraw) {
        return NULL;
    } else {
        return &m_DirectCaps;
    }
}

static HRESULT PropagateMediaType( CBaseOutputPin* pOutPin )
{
    // if the output pin is connected and there's a new video port, send a new media type change
    HRESULT hr = S_OK;
    if( pOutPin->IsConnected() ) {
        CMediaType cmt;

        // rebuild media type from current VPInfo
        hr = pOutPin->GetMediaType(0, &cmt );
        if( SUCCEEDED( hr )) {
            IPin* pVMRPin;
            hr =  pOutPin->ConnectedTo( &pVMRPin );
            if( SUCCEEDED( hr )) {
                hr = pVMRPin->ReceiveConnection( pOutPin, &cmt );
                // this should not fail as before we assumed that it would ALWAYS work
                // even when the res mode changed
                ASSERT( SUCCEEDED( hr ));
                pVMRPin->Release();
            }
        }
    }
    return hr;
}

HRESULT CVPMFilter::SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP )
{
    HRESULT hr;

    AMTRACE((TEXT("CVPMFilter::SignalNewVP")));
    CAutoLock lReceive( &GetFilterLock() );

    // tell the thread to remove any references to the videoport
    // This avoids the situation where we do a dynamic reconnect,
    // but the VPM thread is holding onto a sample (so the dynamic reconnect fails)

    if( m_pThread ) {
        hr = m_pThread->SignalNewVP( NULL );
    }

    if( pVP ) {
        hr = PropagateMediaType( &m_pPins->Output );
    }
    if( m_pThread ) {
        hr = m_pThread->SignalNewVP( pVP );
    } else {
        // not really a failure if there isn't a thread
        hr = S_FALSE;
    }
    return hr;
}

static BOOL WINAPI GetPrimaryCallbackEx(
  GUID FAR *lpGUID,
  LPSTR     lpDriverDescription,
  LPSTR     lpDriverName,
  LPVOID    lpContext,
  HMONITOR  hm
)
{
    GUID&  guid = *((GUID *)lpContext);
    if( !lpGUID ) {
        guid = GUID_NULL;
    } else {
        guid = *lpGUID;
    }
    return TRUE;
}

/*****************************Private*Routine******************************\
* CreateDirectDrawObject
*
*
*
* History:
* Fri 08/20/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CreateDirectDrawObject(
    const GUID* pGUID,
    LPDIRECTDRAW7 *ppDirectDraw
    )
{
    UINT ErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    HRESULT hr = DirectDrawCreateEx( const_cast<GUID*>(pGUID), (LPVOID *)ppDirectDraw,
                                            IID_IDirectDraw7, NULL);
    SetErrorMode(ErrorMode);
    return hr;
}


// This function is used to allocate the direct-draw related resources.
// This includes allocating the direct-draw service provider
HRESULT CVPMFilter::InitDirectDraw(LPDIRECTDRAW7 pDirectDraw)
{
    HRESULT hr = NOERROR;
    HRESULT hrFailure = VFW_E_DDRAW_CAPS_NOT_SUITABLE;
    DDSURFACEDESC SurfaceDescP;
    int i;

    AMTRACE((TEXT("CVPMFilter::InitDirectDraw")));

    CAutoLock lFilter( &GetFilterLock() );

    // addref the new ddraw object
    if (pDirectDraw)
    {
        pDirectDraw->AddRef();
    }
    // release the previous direct draw object if any
    ReleaseDirectDraw();

    // if given a valid ddraw object, make a copy of it (we have already addref'd it)
    // else allocate your own
    if (NULL == pDirectDraw)
    {
        // Ask the loader to create an instance
        GUID primary;
        hr = DirectDrawEnumerateExA(GetPrimaryCallbackEx,&primary,DDENUM_ATTACHEDSECONDARYDEVICES);
        if( FAILED(hr)) {
            ASSERT( !"Can't get primary" );
            goto CleanUp;
        }
        hr = CreateDirectDrawObject( &primary, &pDirectDraw);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function InitDirectDraw, LoadDirectDraw failed")));
            hr = hrFailure;
            goto CleanUp;
        }
        // Set the cooperation level on the surface to be shared
        hr = pDirectDraw->SetCooperativeLevel(NULL, DDSCL_FPUPRESERVE | DDSCL_NORMAL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDraw->SetCooperativeLevel failed")));
            hr = hrFailure;
            goto CleanUp;
        }
    }
    SetDirectDraw( pDirectDraw );

    // Initialise our capabilities structures
    ASSERT(m_pDirectDraw);

    INITDDSTRUCT(m_DirectCaps);
    INITDDSTRUCT(m_DirectSoftCaps);

    // Load the hardware and emulation capabilities
    hr = m_pDirectDraw->GetCaps(&m_DirectCaps,&m_DirectSoftCaps);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDraw->GetCapsGetCaps failed")));
        hr = hrFailure;
        goto CleanUp;
    }

    // Get the kernel caps only if we have a video port, in which case the driver
    // should implement them.  CheckMediaType verifies that we have a videoport
    // before connecting.
    if( m_DirectCaps.dwCaps2 & DDCAPS2_VIDEOPORT ) {
        IDirectDrawKernel *pDDKernel;
        if (SUCCEEDED(m_pDirectDraw->QueryInterface(
                IID_IDirectDrawKernel, (void **)&pDDKernel))) {
            DDKERNELCAPS ddCaps;
            ddCaps.dwSize = sizeof(ddCaps);
            if (SUCCEEDED(pDDKernel->GetCaps(&ddCaps))) {
                m_dwKernelCaps = ddCaps.dwCaps;
            }
            pDDKernel->Release();
        } else {
            ASSERT( !"Can't get kernel caps");
        }
    }
    // make sure the caps are ok
    hr = CheckCaps();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckCaps failed")));
        goto CleanUp;
    }

    // if we have reached this point, we should have a valid ddraw object
    ASSERT(m_pDirectDraw);

CleanUp:

    // anything fails, might as well as release the whole thing
    if (FAILED(hr))
    {
        ReleaseDirectDraw();
    }
    return hr;
}

HRESULT CVPMFilter::CheckCaps()
{
    HRESULT hr = NOERROR;
    DWORD dwMinStretch, dwMaxStretch;

    AMTRACE((TEXT("CVPMFilter::CheckCaps")));

    CAutoLock lReceive( &GetReceiveLock() );

    // Output misc debug info (see below for items we actually check)
    //
    if(m_DirectCaps.dwCaps & DDCAPS_OVERLAY) {
        DbgLog((LOG_TRACE, 1, TEXT("Device does support Overlays")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Device does not support Overlays")));
    }

    // get all direct-draw capabilities
    if (m_DirectCaps.dwCaps & DDCAPS_OVERLAYSTRETCH) {
        DbgLog((LOG_TRACE, 1, TEXT("hardware can support overlay strecthing")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("hardware can't support overlay strecthing")));
    }

    // get the alignment restriction on src boundary
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNBOUNDARYSRC) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignBoundarySrc = %d"), m_DirectCaps.dwAlignBoundarySrc));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on BoundarySrc")));
    }

    // get the alignment restriction on dest boundary
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNBOUNDARYDEST) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignBoundaryDest = %d"), m_DirectCaps.dwAlignBoundaryDest));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on BoundaryDest")));
    }

    // get the alignment restriction on src size
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNSIZESRC) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignSizeSrc = %d"), m_DirectCaps.dwAlignSizeSrc));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on SizeSrc")));
    }

    // get the alignment restriction on dest size
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNSIZEDEST) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignSizeDest = %d"), m_DirectCaps.dwAlignSizeDest));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on SizeDest")));
    }

    if (m_DirectCaps.dwMinOverlayStretch) {
        dwMinStretch = m_DirectCaps.dwMinOverlayStretch;
        DbgLog((LOG_TRACE, 1, TEXT("Min Stretch = %d"), dwMinStretch));
    }

    if (m_DirectCaps.dwMaxOverlayStretch) {
        dwMaxStretch = m_DirectCaps.dwMaxOverlayStretch;
        DbgLog((LOG_TRACE, 1, TEXT("Max Stretch = %d"), dwMaxStretch));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKX)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKX")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKXN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKXN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKY)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKY")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKYN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKYN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHX)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHX")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHXN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHXN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHY)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHY")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHYN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHYN")));
    }

    if ((m_DirectCaps.dwSVBFXCaps & DDFXCAPS_BLTARITHSTRETCHY)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver uses arithmetic operations to blt from system to video")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver uses pixel-doubling to blt from system to video")));
    }

    //
    // Items that we actually check for ...
    //
    if (m_DirectCaps.dwCaps2 & DDCAPS2_VIDEOPORT) {
        DbgLog((LOG_TRACE, 1, TEXT("Device does support a Video Port")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Device does not support a Video Port --> Failing connection")));
        hr = E_NOTIMPL;
    }

    if( m_dwKernelCaps & DDIRQ_VPORT0_VSYNC ) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver support DDIRQ_VPORT0_VSYNC")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver does not support DDIRQ_VPORT0_VSYNC --> Failing VPM connection")));
        hr = E_NOTIMPL;
    }

    if( m_dwKernelCaps & DDKERNELCAPS_FIELDPOLARITY ) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver support DDKERNELCAPS_FIELDPOLARITY")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver does not support DDKERNELCAPS_FIELDPOLARITY --> Failing VPM connection")));
        hr = E_NOTIMPL;
    }

    if( m_dwKernelCaps & DDKERNELCAPS_AUTOFLIP ) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver support DDKERNELCAPS_AUTOFLIP")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver does not support DDKERNELCAPS_AUTOFLIP --> Failing VPM connection")));
        hr = E_NOTIMPL;
    }


    return hr;
}

//
//  Actually sets the variable & distributes it to the pins
//
HRESULT CVPMFilter::SetDirectDraw( LPDIRECTDRAW7 pDirectDraw )
{
    m_pDirectDraw = pDirectDraw;
    m_pPins->VBIInput.SetDirectDraw( m_pDirectDraw );
    return S_OK;
}

// this function is used to release the resources allocated by the function
// "InitDirectDraw". these include the direct-draw service provider and the
// Source surfaces
DWORD CVPMFilter::ReleaseDirectDraw()
{
    AMTRACE((TEXT("CVPMFilter::ReleaseDirectDraw")));
    DWORD dwRefCnt = 0;

    CAutoLock lFilter( &GetFilterLock() );

    // Release any DirectDraw provider interface
    DbgLog((LOG_TRACE, 1, TEXT("Release DDObj 0x%p\n"), m_pDirectDraw));
    if (m_pDirectDraw)
    {
        dwRefCnt = m_pDirectDraw->Release();
        SetDirectDraw( NULL );
    }

    ZeroStruct( m_DirectCaps );
    ZeroStruct( m_DirectSoftCaps );

    return dwRefCnt;
}

/******************************Public*Routine******************************\
* QueryDecimationUsage
*
*
*
* History:
* Wed 07/07/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::QueryDecimationUsage(
    DECIMATION_USAGE* lpUsage
    )
{
    if (lpUsage) {
        *lpUsage = m_dwDecimation;
        return S_OK;
    }
    return E_POINTER;
}


/******************************Public*Routine******************************\
* SetDecimationUsage
*
*
*
* History:
* Wed 07/07/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::SetDecimationUsage(
    DECIMATION_USAGE Usage
    )
{
    CAutoLock lFilter( &GetFilterLock() );

    switch (Usage) {
    case DECIMATION_LEGACY:
    case DECIMATION_USE_DECODER_ONLY:
    case DECIMATION_USE_OVERLAY_ONLY:
    case DECIMATION_DEFAULT:
        break;

    case DECIMATION_USE_VIDEOPORT_ONLY:
        // only allow this mode if we are actually using a video port
        break;

        // else fall thru

    default:
        return E_INVALIDARG;
    }
    DECIMATION_USAGE dwOldUsage = m_dwDecimation;
    m_dwDecimation = Usage;


    // if (dwOldUsage != m_dwDecimation) {
    //     EventNotify(GetPinCount(), EC_OVMIXER_REDRAW_ALL, 0, 0);
    // }

    return S_OK;
}


/******************************Public*Routine******************************\
* Set
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::Set(
    REFGUID guidPropSet,
    DWORD dwPropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData
    )
{
    AMTRACE((TEXT("CVPMFilter::Set")));

    return E_PROP_SET_UNSUPPORTED ;
}


/******************************Public*Routine******************************\
* Get
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::Get(
    REFGUID guidPropSet,
    DWORD dwPropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData,
    DWORD *pcbReturned
    )
{
    AMTRACE((TEXT("CVPMFilter::Get")));
    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* QuerySupported
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::QuerySupported(
    REFGUID guidPropSet,
    DWORD dwPropID,
    DWORD *pTypeSupport
    )
{
    AMTRACE((TEXT("CVPMFilter::QuerySupported")));

    if (guidPropSet != AM_KSPROPSETID_FrameStep)
    {
        return E_PROP_SET_UNSUPPORTED;
    }

    if (dwPropID != AM_PROPERTY_FRAMESTEP_STEP &&
        dwPropID != AM_PROPERTY_FRAMESTEP_CANCEL)
    {
        return E_PROP_ID_UNSUPPORTED;
    }

    if (pTypeSupport)
    {
        *pTypeSupport = KSPROPERTY_SUPPORT_SET ;
    }

    return S_OK;
}

LPDIRECTDRAW7 CVPMFilter::GetDirectDraw()
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetDirectDraw")));

    CAutoLock lReceive( &GetReceiveLock() );

    if (!m_pDirectDraw)
    {
        hr = InitDirectDraw(NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function InitDirectDraw failed, hr = 0x%x"), hr));
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetDirectDraw")));
    ASSERT(m_pDirectDraw);
    return m_pDirectDraw;
}

template< class T >
static bool CheckConnected( T& pPin, DWORD dwExcludePinId )
{
    return ( pPin.GetPinId() != dwExcludePinId) && pPin.IsConnected();
}

HRESULT CVPMFilter::ConfirmPreConnectionState(DWORD dwExcludePinId)
{
    HRESULT hr = NOERROR;
    DWORD i = 0;

    // is the input pin already connected?
    if( CheckConnected( m_pPins->VPInput, dwExcludePinId) )
    {
        hr = VFW_E_ALREADY_CONNECTED;
        DbgLog((LOG_ERROR, 1, TEXT("GetVPInput[i]->IsConnected() , i = %d, returning hr = 0x%x"), i, hr));
        goto CleanUp;
    }
    if( CheckConnected( m_pPins->VBIInput, dwExcludePinId) )
    {
        hr = VFW_E_ALREADY_CONNECTED;
        DbgLog((LOG_ERROR, 1, TEXT("GetVBIInputPin[i]->IsConnected() , i = %d, returning hr = 0x%x"), i, hr));
        goto CleanUp;
    }
    // is the output pin already connected?
    if( CheckConnected( m_pPins->Output, dwExcludePinId) )
    {
        hr = VFW_E_ALREADY_CONNECTED;
        DbgLog((LOG_ERROR, 1, TEXT("GetOutputPin.IsConnected() , returning hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

//
// used by the output pin to publish the input format
//
HRESULT CVPMFilter::CurrentInputMediaType(CMediaType *pmt)
{
    HRESULT hr;
    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.CurrentMediaType(pmt);
    return hr;
}

HRESULT CVPMFilter::GetAllOutputFormats( const PixelFormatList** ppList )
{
    HRESULT hr;
    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.GetAllOutputFormats( ppList );
    return hr;
}

HRESULT CVPMFilter::GetOutputFormat( DDPIXELFORMAT* pFormat )
{
    HRESULT hr;
    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.GetOutputFormat( pFormat );
    return hr;
}

HRESULT CVPMFilter::ProcessNextSample( const DDVIDEOPORTNOTIFY& notify )
{
    AMTRACE((TEXT("CVPMFilter::ProcessNextSample")));
    CAutoLock lReceive( &GetReceiveLock() );

    VPInfo vpInfo = {0};
    HRESULT hr = m_pPins->VPInput.InPin_GetVPInfo( &vpInfo );
    ASSERT( SUCCEEDED(hr )); // can't fail

    bool fSkip = (vpInfo.vpInfo.dwVPFlags && DDVP_INTERLEAVE ) && (notify.lField == 0);
    if( !fSkip ) {

        // get a buffer
        LPDIRECTDRAWSURFACE7 pDestSurface;
        IMediaSample* pSample;

        // this will take care of getting the DDSurf7 (and possibly wrapping non DDSurf7)
        hr = m_pPins->Output.GetNextBuffer( &pDestSurface, &pSample );
        if( SUCCEEDED( hr )) {
            DWORD dwFlags;
            hr = m_pPins->VPInput.DoRenderSample( pSample, pDestSurface, notify, vpInfo );
            pDestSurface->Release();

            if( SUCCEEDED( hr )) {

                // send it
                hr = m_pPins->Output.SendSample( pSample );
                // tell the allocator that we're done with it
            }
            // otherwise we leak the sample if we can't restore the DDraw surface and run out of samples
            pSample->Release();
        }
    }
    return hr;
}

HRESULT CVPMFilter::CanColorConvertBlitToRGB( const DDPIXELFORMAT& ddFormat )
{
    if( m_pDirectDraw ) {
        if( m_DirectCaps.dwCaps & DDCAPS_BLTFOURCC ) {
            return S_OK;
        }

        // use m_DirectCaps, m_DirectSoftCaps
    }
    return E_FAIL;
}


#if 0
HRESULT CVPMFilter::CanStretch( const DDPIXELFORMAT& ddFormat )
{
    if( m_pDirectDraw ) {
        if( ddFormat.dwFourCC ) {
            if( m_DirectCaps.dwCaps2 & (DDCAPS2_COPYFOURCC )) {
                return S_OK;
            } else {
                return E_FAIL;
            }
        }
    }
    return S_OK;
}
#endif


STDMETHODIMP CVPMFilter::GetVideoPortIndex( DWORD* pdwIndex )
{
    AMTRACE((TEXT("CVPMFilter::GetVideoPortIndex")));
    CAutoLock lFilter( &GetFilterLock() );

    HRESULT hr = S_OK;
    if( !pdwIndex ) {
        return E_INVALIDARG;
    }
    *pdwIndex = m_dwVideoPortID;
    return hr;
}

STDMETHODIMP CVPMFilter::SetVideoPortIndex( DWORD dwIndex )
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVPMFilter::SetVideoPortIndex")));

    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.SetVideoPortID( dwIndex );
    if( SUCCEEDED( hr )) {
        hr = m_pPins->VBIInput.SetVideoPortID( dwIndex );

        // if the VP succeeds, there is no reason for the VBI to fail
        ASSERT( SUCCEEDED( hr ));

        if( SUCCEEDED( hr )) {
            m_dwVideoPortID = dwIndex;
        }
    }
    return hr;
}

HRESULT CVPMFilter::GetRefClockTime( REFERENCE_TIME* pNow )
{
    // Private method used by the input pin to determine the timestamp for
    // the next sample.  However, it has the receive lock.
    CAutoLock lFilter( &GetReceiveLock() );

    if( m_pClock ) {
        return m_pClock->GetTime( pNow );
    } else {
        return E_FAIL;
    }
}

HRESULT CVPMFilter::GetVPInfo( VPInfo* pVPInfo )
{
    CAutoLock lFilter( &GetFilterLock() );
    return m_pPins->VPInput.InPin_GetVPInfo( pVPInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmthread.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "dvp.h"
#include "vpmthread.h"
#include "VPManager.h"
#include "vpmpin.h"
#include "VPMUtil.h"

struct VPNotifyData
{
    VPNotifyData();

    HRESULT Init( LPDIRECTDRAWVIDEOPORT pVP );
    void    Reset();

    LPDIRECTDRAWVIDEOPORT pVP;
    LPDIRECTDRAWVIDEOPORTNOTIFY pNotify;
    HANDLE              hevSampleAvailable;
    DDVIDEOPORTNOTIFY   vpNotify;
};

VPNotifyData::VPNotifyData()
: pNotify( NULL )
, hevSampleAvailable( NULL )
, pVP( NULL )
{
    ZeroStruct( vpNotify );
    vpNotify.lField=1234; // stick in an invalid value that we can catch later (we except -1,0 or 1)
}

HRESULT VPNotifyData::Init( LPDIRECTDRAWVIDEOPORT pInVP )
{
    Reset();
    if( pInVP ) {
        pVP = pInVP;
        // add a ref since we're keeping 
        pVP->AddRef();

        HRESULT hr = pVP->QueryInterface( IID_IDirectDrawVideoPortNotify, (LPVOID *) &pNotify );
        if( SUCCEEDED( hr )) {
            hr = pNotify->AcquireNotification( &hevSampleAvailable, &vpNotify );
        } else {
            ASSERT( !"Failed IDirectDrawVideoPortNotify" );
        }
        if( SUCCEEDED( hr )) {
            // what does this do ? Signals the kernel we have it & advances to next frame ?
            vpNotify.lDone = 1;
        } else {
            ASSERT( !"Failed AcquireNotification" );
        }
        return hr;
    } else {
        return S_OK;
    }
}

void VPNotifyData::Reset()
{
    // Owning object told us the video port object changed.
    if ( pNotify && hevSampleAvailable ) {
        pNotify->ReleaseNotification( hevSampleAvailable );
    }
    hevSampleAvailable  = NULL;
    RELEASE( pNotify );
    RELEASE( pVP );
}

CVPMThread::CVPMThread( CVPMFilter* pFilter )
: m_hThread( NULL )
, m_dwThreadID( 0 )
, m_pFilter( pFilter )
, m_fProcessFrames( false )
, m_dwCount( 0 )
, m_pVPData( new VPNotifyData )
{
    AMTRACE((TEXT("CVPMThread::CVPMThread")));

    m_hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) StaticThreadProc, this, 0, &m_dwThreadID );
}

CVPMThread::~CVPMThread()
{
    AMTRACE((TEXT("CVPMThread::~CVPMThread")));
    if ( m_hThread )
    {
        EndThreadMessage msg;
        Post( &msg );
        WaitForSingleObject( m_hThread, INFINITE );
    }
    delete m_pVPData;
}

void CVPMThread::ProcessEvents( LPDDVIDEOPORTNOTIFY pNotify  )
{
    // must check process frames AND pVP, since ksproxy can tell us to reconfigure while
    // running, which discards the videoport (so fProcessFrames = true & pVP = NULL)
    if( m_fProcessFrames && m_pVPData->pVP ) {
        HRESULT hr = m_pFilter->ProcessNextSample( *pNotify );
        // HR can come back as DDERR_SURFACELOST if we're in a DX game / fullscreen DOS box
        // for now, just keep going since we don't know when we get back
        // from the dx game
    }
    InterlockedExchange( &pNotify->lDone, 1 );
}

EXTERN_C const GUID DECLSPEC_SELECTANY IID_IDirectDrawVideoPortNotify \
        = { 0xA655FB94,0x0589,0x4E57,0xB3,0x33,0x56,0x7A,0x89,0x46,0x8C,0x88 };

DWORD WINAPI
CVPMThread::StaticThreadProc(LPVOID pContext)
{
    CVPMThread *pThis = (CVPMThread *) pContext;
    return pThis->ThreadProc();
}


DWORD
CVPMThread::ThreadProc()
{
    AMTRACE((TEXT("CVPMThread::ThreadProc")));

    if( m_pVPData ) {
        // Notes:
        //  The video port notifications can occur before we have created the target surface.
        //  - IVPMFilter::ProcessNextSample must decide if the surface is present
        __try
        {
            for(;;)
            {
                HANDLE hHandles[] = {m_MsgQueue.m_ePost, m_pVPData->hevSampleAvailable };
                int numHandles = m_pVPData->pVP ? (int)NUMELMS(hHandles) : (int)NUMELMS(hHandles)-1;
                // Bob interleave is 1/30 sec, so run default timer at twice that (15fps)
                DWORD dwWaitStatus = WaitForMultipleObjects( numHandles, hHandles, FALSE, 66 /*ms*/ );

                switch( dwWaitStatus ) {
                case WAIT_OBJECT_0:
                {
                    Message* pMessage = m_MsgQueue.Remove();
                    if( pMessage ) {
                        bool fQuit;
                        HRESULT hr = ProcessMessage( pMessage, &fQuit );
                        pMessage->Reply( hr );
                        if( fQuit ) {
                            // VPMThread ending
                            ASSERT( m_MsgQueue.Remove() == NULL ); // should be empty
		                    DbgLog((LOG_ERROR, 1, TEXT("VPM Thread leaving") ));
                            __leave;
                        }
                    }
                    break;
                }
                case WAIT_OBJECT_0+1:
                case WAIT_TIMEOUT: // acts like a timer
                {
                    ProcessEvents( &m_pVPData->vpNotify );
                    break;
                }
                default:
                    // Windows message to die
                    ASSERT( !"VPMThread error" );
                    break;
                }
            }
        }
        __finally
        {
            m_pVPData->Reset();
        }
    }
	DbgLog((LOG_ERROR, 1, TEXT("VPM Thread exiting") ));
    return 0;
}

HRESULT
CVPMThread::Run()
{
    GraphStateMessage msg( State_Running );
    return Post( &msg );
}

HRESULT
CVPMThread::Pause()
{
    GraphStateMessage msg( State_Paused );
    return Post( &msg );
}

HRESULT
CVPMThread::Stop()
{
    GraphStateMessage msg( State_Stopped );
    return Post( &msg );
}

HRESULT
CVPMThread::SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP )
{
    VPMessage msg( pVP );
    return Post( &msg );
}

CVPMThread::MsgQueue::MsgQueue()
: m_pMsgList( NULL )
{
}

void CVPMThread::MsgQueue::Insert( Message* pMessage )
{

    CAutoLock lock(this);
    Message* pNode = m_pMsgList;

    // pre-end list
    pMessage->m_pNext = NULL;
    // find last node
    if( pNode ) {
        // find last node
        while( pNode->m_pNext ) {
            pNode = pNode->m_pNext;
        }
        // add after last node
        pNode->m_pNext = pMessage;
    } else {
        // empty list, insert at start
        m_pMsgList = pMessage;
    }
}

CVPMThread::Message* CVPMThread::MsgQueue::Remove()  // remove head
{
    CAutoLock lock(this);
    if( m_pMsgList ) {
        Message* pMsg = m_pMsgList;
        m_pMsgList = pMsg->m_pNext;
        return pMsg;
    } else {
        return NULL;
    }
}

HRESULT CVPMThread::Post( Message* pMessage )
{
    if( GetCurrentThreadId() == m_dwThreadID ) {
        // just execute the message if we're asking ourselves
        bool fIgnoreMe;
        return ProcessMessage( pMessage, &fIgnoreMe );
    } else {
        // otherwise ask server
        m_MsgQueue.Insert( pMessage );
        m_MsgQueue.m_ePost.Set();
        pMessage->m_eReply.Wait();
        return pMessage->m_hrResult;
    }
}

void CVPMThread::Message::Reply( HRESULT hr )
{
    m_hrResult = hr;
    m_eReply.Set();
}

HRESULT CVPMThread::ProcessMessage( Message* pMessage, bool* pfQuit )
{
    *pfQuit = false;

    switch( pMessage->m_Type )
    {
    case Message::kEndThread:
        *pfQuit = true;
        return S_OK;

    case Message::kVP:
        return ProcessVPMsg( static_cast<VPMessage*>( pMessage ) );

    case Message::kGraphState:
        return ProcessGraphStateMsg( static_cast<GraphStateMessage*>( pMessage ) );

    default:
        ASSERT( !"Unknown message type" );
        return E_UNEXPECTED;
    }
}

HRESULT CVPMThread::ProcessVPMsg( VPMessage* pVPMsg )
{
    // Owning object told us the video port object changed.
    return m_pVPData->Init( pVPMsg->m_pVP );
}

HRESULT CVPMThread::ProcessGraphStateMsg( GraphStateMessage* pStateMsg )
{
    switch( pStateMsg->m_state ) {
    case State_Running:
        m_fProcessFrames = true;
        break;
    case State_Paused:
    case State_Stopped:
        m_fProcessFrames = false;
        break;

    default:
        ASSERT( !"Unknown state" );
        m_fProcessFrames = false;
        return E_INVALIDARG;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmpin.h ===
/******************************Module*Header*******************************\
* Module Name: VPManager.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __VPMPin__h
#define __VPMPin__h

// IDirectDrawMediaSample
#include <amstream.h>

// IVideoPortControl
#include <VPObj.h>

// IksPin
#include <ks.h>
#include <ksproxy.h>

class CVPMFilter;

struct VPInfo
{
    AMVPDATAINFO    vpDataInfo;
    DDVIDEOPORTINFO vpInfo;
    AMVP_MODE       mode;
};

typedef enum
{
    // AM_KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT = 0,
    // AM_KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE = 1,

    // Extra flags not in KSPROPERTY_ALLOCATOR_CONTROL

    // W I (informns a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS = 2,

    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE = 3

} AM_KSPROPERTY_ALLOCATOR_CONTROL;

/* -------------------------------------------------------------------------
** CVPManager class declaration
** -------------------------------------------------------------------------
*/
class CVPMFilter;

class CDDrawMediaSample : public CMediaSample, public IDirectDrawMediaSample
{
public:

    CDDrawMediaSample(TCHAR* pName, CBaseAllocator* pAllocator, HRESULT* phr, LPBYTE pBuffer, LONG length,
                      bool bKernelLock);
    ~CDDrawMediaSample();

    /* Note the media sample does not delegate to its owner */
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef() { return CMediaSample::AddRef(); }
    STDMETHODIMP_(ULONG) Release() { return CMediaSample::Release(); }

    void SetDIBData(DIBDATA* pDibData);
    DIBDATA* GetDIBData();

    HRESULT SetDDrawSampleSize(DWORD dwDDrawSampleSize);
    HRESULT GetDDrawSampleSize(DWORD* pdwDDrawSampleSize);
    HRESULT SetDDrawSurface(LPDIRECTDRAWSURFACE7 pDirectDrawSurface);
    HRESULT GetDDrawSurface(LPDIRECTDRAWSURFACE7* ppDirectDrawSurface);

    // methods belonging to IDirectDrawMediaSample
    STDMETHODIMP GetSurfaceAndReleaseLock(IDirectDrawSurface** ppDirectDrawSurface, RECT* pRect);
    STDMETHODIMP LockMediaSamplePointer(void);
    
    /*  Hack to get at the list */
    CMediaSample*          &Next() { return m_pNext; }
private:
    DIBDATA                 m_DibData;                      // Information about the DIBSECTION
    LPDIRECTDRAWSURFACE7    m_pDirectDrawSurface;           // pointer to the direct draw surface
    DWORD                   m_dwDDrawSampleSize;            // ddraw sample size
    bool                    m_bInit;                        // Is the DIB information setup
    bool                    m_bSurfaceLocked;               // specifies whether surface is locked or not
    bool                    m_bKernelLock;                  // lock with no sys lock
    RECT                    m_SurfaceRect;                  // the part of the surface that is locked
};

// common functionality to all pins
class CVPMPin
{
public:
    CVPMPin( DWORD dwPinId, CVPMFilter& pFilter )
        : m_dwPinId( dwPinId )
        , m_pVPMFilter( pFilter )
    {}
    DWORD   GetPinId() const
                { return m_dwPinId; };
    CVPMFilter& GetFilter() { return m_pVPMFilter; };

protected:
    DWORD       m_dwPinId;
    CVPMFilter& m_pVPMFilter;
};


class CVPMInputAllocator
: public CBaseAllocator
{
    friend class CVPMInputPin;
public:

    CVPMInputAllocator( CVPMInputPin& pPin, HRESULT* phr);             // Return code
    ~CVPMInputAllocator();

    DECLARE_IUNKNOWN

    STDMETHODIMP CVPMInputAllocator::NonDelegatingQueryInterface(REFIID riid, void** ppv);

    STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
    STDMETHODIMP GetBuffer(IMediaSample** ppSample, REFERENCE_TIME* pStartTime,
                            REFERENCE_TIME* pEndTime, DWORD dwFlags);
    STDMETHODIMP ReleaseBuffer(IMediaSample* pMediaSample);

    //  Check all samples are returned
    BOOL CanFree() const
    {
        return m_lFree.GetCount() == m_lAllocated;
    }
protected:
    void    Free();
    HRESULT Alloc();

private:
    CVPMInputPin&   m_pPin;
};

class CVPMInputPin
: public CBaseInputPin
, public IKsPin
, public IKsPropertySet
, public ISpecifyPropertyPages
, public IPinConnection
, public IVideoPortControl
, public CVPMPin
{
public:
    CVPMInputPin(TCHAR* pObjectName, CVPMFilter& pFilter,
                    HRESULT* phr, LPCWSTR pPinName,
                    DWORD dwPinNo);
    ~CVPMInputPin();
    friend class CVPMInputAllocator;
    friend class CVPMFilter;

    DECLARE_IUNKNOWN

    STDMETHODIMP         NonDelegatingQueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //
    // --- ISpecifyPropertyPages ---
    //
    STDMETHODIMP GetPages(CAUUID* pPages);

    // Override ReceiveConnection to allow format changes while running
    STDMETHODIMP ReceiveConnection(IPin*  pConnector, const AM_MEDIA_TYPE* pmt);

    // connection related functions
    HRESULT CheckConnect(IPin*  pReceivePin);
    HRESULT CompleteConnect(IPin* pReceivePin);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int iPosition,CMediaType* pMediaType);
    HRESULT CheckInterlaceFlags(DWORD dwInterlaceFlags);
    HRESULT DynamicCheckMediaType(const CMediaType* pmt);
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT SetMediaType(const CMediaType* pmt);
    HRESULT FinalConnect();
    HRESULT UpdateMediaType();

    // streaming functions
    HRESULT         Active();
    HRESULT         Inactive();
    HRESULT         Run(REFERENCE_TIME tStart);
    HRESULT         RunToPause();
    STDMETHODIMP    BeginFlush();
    STDMETHODIMP    EndFlush();
    STDMETHODIMP    Receive(IMediaSample* pMediaSample);
    STDMETHODIMP    EndOfStream(void);
    STDMETHODIMP    GetState(DWORD dwMSecs,FILTER_STATE* pState);
    HRESULT         CompleteStateChange(FILTER_STATE OldState);
    HRESULT         OnReceiveFirstSample(IMediaSample* pMediaSample);

    // blt from source in VPObject to the output surface
    HRESULT         DoRenderSample( IMediaSample* pSample, LPDIRECTDRAWSURFACE7 pDestSurface, const DDVIDEOPORTNOTIFY& notify, const VPInfo& vpInfo );
    HRESULT         AttachVideoPortToSurface()
                    {
                        HRESULT hRes = m_pIVPObject->AttachVideoPortToSurface();
                        if( SUCCEEDED( hRes ) ) {
                            hRes = m_pIVPObject->SignalNewVP();
                        }
                        return hRes;
                    };
    HRESULT         InitVideo();

    // allocator related functions
    BOOL         UsingOurAllocator() { return m_bUsingOurAllocator; }
    STDMETHODIMP GetAllocator(IMemAllocator** ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator* pAllocator,BOOL bReadOnly);
    HRESULT      OnSetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
    HRESULT      OnAlloc(CDDrawMediaSample** ppSampleList, DWORD dwSampleCount);
    HRESULT      OnGetBuffer(   IMediaSample** ppSample,
                                REFERENCE_TIME* pStartTime,
                                REFERENCE_TIME* pEndTime,
                                DWORD dwFlags);
    HRESULT      OnReleaseBuffer(IMediaSample* pIMediaSample);
    HRESULT      CreateDDrawSurface(CMediaType* pMediaType,
                                    DWORD* dwMaxBufferCount, 
                                    LPDIRECTDRAWSURFACE7* ppDDrawSurface);

    // some helper functions
    BOOL    IsCompletelyConnected() { return m_bConnected; }
    DWORD   GetPinId() { return m_dwPinId; }
    HRESULT CurrentMediaType(CMediaType* pmt);
    IPin*   CurrentPeer() { return m_Connected; }
    void    DoQualityMessage();
    HRESULT GetSourceAndDest(RECT* prcSource, RECT* prcDest, DWORD* dwWidth, DWORD* dwHeight);
 
    HRESULT RestoreDDrawSurface();
    HRESULT SetVideoPortID( DWORD dwIndex );

    // IPinConnection
    // Do you accept this type change in your current state?
    STDMETHODIMP DynamicQueryAccept(const AM_MEDIA_TYPE* pmt);

    //  Set event when EndOfStream receive - do NOT pass it on
    //  This condition is cancelled by a flush or Stop
    STDMETHODIMP NotifyEndOfStream(HANDLE hNotifyEvent);

    //  Are you an 'end pin'
    STDMETHODIMP IsEndPin();
    STDMETHODIMP DynamicDisconnect();

    // functions belonging to IVideoPortControl
    STDMETHODIMP                        EventNotify(long lEventCode, DWORD_PTR lEventParam1,
                                                DWORD_PTR lEventParam2);
    STDMETHODIMP_(LPDIRECTDRAW7)        GetDirectDraw();
    STDMETHODIMP_(const DDCAPS*)        GetHardwareCaps();

    STDMETHODIMP StartVideo();

    STDMETHODIMP GetCaptureInfo(BOOL* lpCapturing,
                                DWORD* lpdwWidth,DWORD* lpdwHeight,
                                BOOL* lpInterleave);

    STDMETHODIMP GetVideoDecimation(IDecimateVideoImage** lplpDVI);
    STDMETHODIMP GetDecimationUsage(DECIMATION_USAGE* lpdwUsage);

    STDMETHODIMP CropSourceRect(VPWININFO* pWinInfo,
                                DWORD dwMinZoomFactorX,
                                DWORD dwMinZoomFactorY);
    STDMETHODIMP SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP );
    // End IVideoPortControl

    // helper functions
    void SetKsMedium(const KSPIN_MEDIUM* pMedium)
            {m_Medium =* pMedium;}
    void SetKsCategory(const GUID* pCategory)
            {m_CategoryGUID =* pCategory;}
    void SetStreamingInKernelMode(BOOL bStreamingInKernelMode)
            {m_bStreamingInKernelMode = bStreamingInKernelMode;}

    // IKsPropertySet implementation
    STDMETHODIMP Set(   REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
                        DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(   REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
                        DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD* pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD* pTypeSupport);

    // IKsPin implementation
    virtual STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM* pMediumList);
    virtual STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM* pInterfaceList);
    STDMETHODIMP    KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium)
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsGetCurrentCommunication(KSPIN_COMMUNICATION* pCommunication,
                            KSPIN_INTERFACE* pInterface, KSPIN_MEDIUM* pMedium);
    STDMETHODIMP    KsPropagateAcquire()
                        { return NOERROR; }
    STDMETHODIMP    KsDeliver(IMediaSample* pSample, ULONG Flags)
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsMediaSamplesCompleted(PKSSTREAM_SEGMENT StreamSegment)
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation)
                        { return NULL; }
    STDMETHODIMP    KsReceiveAllocator( IMemAllocator* pMemAllocator)
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsRenegotiateAllocator()
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount()
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount()
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta)
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(REFERENCE_TIME) KsGetStartTime()
                        { return E_UNEXPECTED; }

    // possible future VP->Overlay support
    DWORD           GetOverlayMinStretch();

    HRESULT         GetAllOutputFormats( const PixelFormatList** ppList );
    HRESULT         GetOutputFormat( DDPIXELFORMAT *);
    HRESULT         InPin_GetVPInfo( VPInfo* pVPInfo );

private:
    REFERENCE_TIME          m_rtNextSample;
    REFERENCE_TIME          m_rtLastRun;
    
    LONG                    m_cOurRef;                      // We maintain reference counting
    bool                    m_bWinInfoSet;                  // if false, Blt full image to full image
    VPWININFO               m_WinInfo;

public:
    IVideoPortObject*       m_pIVPObject;
    IVideoPortInfo*         m_pIVPInfo;
private:
    CVideoPortObj*          m_pVideoPortObject;

    // variables to implement IKsPin and IKsPropertySet
    KSPIN_MEDIUM            m_Medium;
    GUID                    m_CategoryGUID;
    KSPIN_COMMUNICATION     m_Communication;
    BOOL                    m_bStreamingInKernelMode;

    // ddraw stuff
    DWORD                   m_dwBackBufferCount;
    DWORD                   m_dwDirectDrawSurfaceWidth;
    DWORD                   m_dwMinCKStretchFactor;
    BYTE                    m_bSyncOnFill;
    BYTE                    m_bDontFlip ;
    BYTE                    m_bDynamicFormatNeeded;
    BYTE                    m_bNewPaletteSet;
    DWORD                   m_dwUpdateOverlayFlags;
    DWORD                   m_dwInterlaceFlags;
    DWORD                   m_dwFlipFlag;
    DWORD                   m_dwFlipFlag2;
    BOOL                    m_bConnected;
    BOOL                    m_bUsingOurAllocator;
    HDC                     m_hMemoryDC;
    BOOL                    m_bCanOverAllocateBuffers;

    BOOL                    m_bRuntimeNegotiationFailed;


    // Track frame delivery for QM
    REFERENCE_TIME          m_trLastFrame;

    HRESULT DrawGDISample(IMediaSample* pMediaSample);
    HRESULT DoRenderGDISample(IMediaSample* pMediaSample);

    // Decimation related functions and variables
    HRESULT QueryDecimationOnPeer(long lWidth, long lHeight);

    enum {
        DECIMATION_NOT_SUPPORTED,   // decimation not supported
        DECIMATING_SIZE_SET,        // decimation image size changed
        DECIMATING_SIZE_NOTSET,     // decimation size didn't change
        DECIMATING_SIZE_RESET,      // decimation has been reset
    };

    HRESULT ResetDecimationIfSet();
    HRESULT TryDecoderDecimation(VPWININFO* pWinInfo);
    BOOL    BeyondOverlayCaps(DWORD ScaleFactor);
    void    ApplyDecimation(VPWININFO* pWinInfo);
    BOOL    Running();
    // HRESULT GetUpstreamFilterName(TCHAR* FilterName);

    BOOL    m_bDecimating;
    LONG    m_lWidth;
    LONG    m_lHeight;
    LONG    m_lSrcWidth;
    LONG    m_lSrcHeight;

    // IPinConnection stuff
    HANDLE  m_hEndOfStream;
};


class CVPMOutputPin
: public CBaseOutputPin
, public CVPMPin
{
public:
                CVPMOutputPin(TCHAR* pObjectName, CVPMFilter& pFilter,
                            HRESULT* phr, LPCWSTR pPinName, DWORD dwPinNo);
                ~CVPMOutputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void**  ppv);

    HRESULT     CompleteConnect(IPin* pReceivePin);
    HRESULT     BreakConnect();
    HRESULT     CheckMediaType(const CMediaType* mtOut);
    HRESULT     GetMediaType(int iPosition,CMediaType* pmtOut);
    HRESULT     SetMediaType(const CMediaType* pmt);
    HRESULT     CheckConnect(IPin*  pPin);

    // override Notify method to keep base classes happy
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // HRESULT Active() { return NOERROR; }    // override this as we don't have any allocator
    // HRESULT Inactive() { return NOERROR; }  // override this as we don't have any allocator

    HRESULT     InitAllocator(IMemAllocator** ppAlloc);
    HRESULT     DecideBufferSize(IMemAllocator*  pAlloc, ALLOCATOR_PROPERTIES*  pProp);
    IPin*       CurrentPeer()
                    { return m_Connected; }
    HRESULT     DecideAllocator( IMemInputPin *pPin, IMemAllocator **ppAlloc );

    // get the next sample/surface to blt into
    HRESULT     GetNextBuffer( LPDIRECTDRAWSURFACE7* ppSurface, IMediaSample** pSample );
    HRESULT     SendSample( IMediaSample* pSample );

private:
    IUnknown*               m_pPosition;
};

interface IVideoPortVBIObject;
interface IVPVBINotify;
class CVBIVideoPort;

//==========================================================================
class CVBIInputPin
: public CBaseInputPin
, public IVPVBINotify
, public CVPMPin
{
public:
    CVBIInputPin(TCHAR* pObjectName, CVPMFilter& pFilter,
        HRESULT* phr, LPCWSTR pPinName, DWORD dwID );
    ~CVBIInputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);
    
    // connection related functions
    HRESULT CheckConnect(IPin*  pReceivePin);
    HRESULT CompleteConnect(IPin* pReceivePin);
    HRESULT BreakConnect();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT GetMediaType(int iPosition, CMediaType* pMediaType);
    HRESULT SetMediaType(const CMediaType* pmt);

    // streaming functions
    HRESULT     Active();
    HRESULT     Inactive();
    HRESULT     Run(REFERENCE_TIME tStart);
    HRESULT     RunToPause();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample* pMediaSample);
    STDMETHODIMP EndOfStream(void);

    // allocator related functions
    STDMETHODIMP GetAllocator(IMemAllocator** ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator* pAllocator,BOOL bReadOnly);

    // some helper fnctions
    CMediaType&     CurrentMediaType() { return m_mt; }
    IPin*           CurrentPeer() { return m_Connected; }
    HRESULT         EventNotify(long lEventCode, DWORD_PTR lEventParam1, DWORD_PTR lEventParam2);

    // ddraw, overlay related functions
    HRESULT         SetDirectDraw(LPDIRECTDRAW7 pDirectDraw);

    // IVPVBINotify functions
    STDMETHODIMP    RenegotiateVPParameters();

    HRESULT         SetVideoPortID( DWORD dwIndex );

private:
    // VideoPort related stuff
    CVBIVideoPort*          m_pVideoPortVBIObject;

    IVideoPortVBIObject*    m_pIVPObject;
    IVPVBINotify*           m_pIVPNotify;

    // ddraw stuff
    LPDIRECTDRAW7           m_pDirectDraw;  // DirectDraw service provide
};

#endif //__VPMPin__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmutil.cpp ===
/******************************Module*Header*******************************\
* Module Name: CVPMFilter.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Glenn Evans [GlennE]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <limits.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "VPMUtil.h"
#include "DRect.h"

#include <VPManager.h>
#include <VPMPin.h>

// VIDEOINFOHEADER1/2
#include <dvdmedia.h>

const TCHAR chRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\VideoPort Manager");
#define PALETTE_VERSION                     1

const BITMAPINFOHEADER *VPMUtil::GetbmiHeader( const CMediaType *pMediaType )
{
    return GetbmiHeader( const_cast<CMediaType *>(pMediaType) );
}

BITMAPINFOHEADER *VPMUtil::GetbmiHeader( CMediaType *pMediaType)
{
    BITMAPINFOHEADER *pHeader = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    if (!(pMediaType->pbFormat))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType->pbFormat is NULL")));
        goto CleanUp;
    }

    if ((pMediaType->formattype == FORMAT_VideoInfo) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER)))
    {
        pHeader = &(((VIDEOINFOHEADER*)(pMediaType->pbFormat))->bmiHeader);
        goto CleanUp;
    }


    if ((pMediaType->formattype == FORMAT_VideoInfo2) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER2)))

    {
        pHeader = &(((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->bmiHeader);
        goto CleanUp;
    }
CleanUp:
    return pHeader;
}

// Return the bit masks for the true colour VIDEOINFO or VIDEOINFO2 provided
const DWORD *VPMUtil::GetBitMasks(const CMediaType *pMediaType)
{
    static DWORD FailMasks[] = {0,0,0};
    const DWORD *pdwBitMasks = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        goto CleanUp;
    }

    if (pHeader->biCompression != BI_RGB)
    {
        pdwBitMasks = (const DWORD *)((LPBYTE)pHeader + pHeader->biSize);
        goto CleanUp;

    }

    ASSERT(pHeader->biCompression == BI_RGB);
    switch (pHeader->biBitCount)
    {
    case 16:
        {
            pdwBitMasks = bits555;
            break;
        }
    case 24:
        {
            pdwBitMasks = bits888;
            break;
        }

    case 32:
        {
            pdwBitMasks = bits888;
            break;
        }
    default:
        {
            pdwBitMasks = FailMasks;
            break;
        }
    }

CleanUp:
    return pdwBitMasks;
}

// Return the pointer to the byte after the header
const BYTE* VPMUtil::GetColorInfo(const CMediaType *pMediaType)
{
    BYTE *pColorInfo = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        goto CleanUp;
    }

    pColorInfo = ((LPBYTE)pHeader + pHeader->biSize);

CleanUp:
    return pColorInfo;
}

// checks whether the mediatype is palettised or not
HRESULT VPMUtil::IsPalettised(const CMediaType& mediaType, BOOL *pPalettised)
{
    HRESULT hr = NOERROR;

    if (!pPalettised)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pPalettised is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_FAIL;
        goto CleanUp;
    }

    if (pHeader->biBitCount <= iPALETTE)
        *pPalettised = TRUE;
    else
        *pPalettised = FALSE;

CleanUp:
    return hr;
}

HRESULT VPMUtil::GetPictAspectRatio(const CMediaType& mediaType, DWORD *pdwPictAspectRatioX, DWORD *pdwPictAspectRatioY)
{
    HRESULT hr = NOERROR;

    if (!(mediaType.pbFormat))
    {
        DbgLog((LOG_ERROR, 1, TEXT("mediaType.pbFormat is NULL")));
        goto CleanUp;
    }

    if (!pdwPictAspectRatioX)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwPictAspectRatioX is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pdwPictAspectRatioY)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwPictAspectRatioY is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }


    if ((mediaType.formattype == FORMAT_VideoInfo) &&
        (mediaType.cbFormat >= sizeof(VIDEOINFOHEADER)))
    {
        *pdwPictAspectRatioX = abs(((VIDEOINFOHEADER*)(mediaType.pbFormat))->bmiHeader.biWidth);
        *pdwPictAspectRatioY = abs(((VIDEOINFOHEADER*)(mediaType.pbFormat))->bmiHeader.biHeight);
        goto CleanUp;
    }

    if ((mediaType.formattype == FORMAT_VideoInfo2) &&
        (mediaType.cbFormat >= sizeof(VIDEOINFOHEADER2)))
    {
        *pdwPictAspectRatioX = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->dwPictAspectRatioX;
        *pdwPictAspectRatioY = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->dwPictAspectRatioY;
        goto CleanUp;
    }

CleanUp:
    return hr;
}



// get the InterlaceFlags from the mediatype. If the format is VideoInfo, it returns
// the flags as zero.
HRESULT VPMUtil::GetInterlaceFlagsFromMediaType(const CMediaType& mediaType, DWORD *pdwInterlaceFlags)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("GetInterlaceFlagsFromMediaType")));

    if (!pdwInterlaceFlags)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // get the header just to make sure the mediatype is ok
    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (mediaType.formattype == FORMAT_VideoInfo)
    {
        *pdwInterlaceFlags = 0;
    }
    else if (mediaType.formattype == FORMAT_VideoInfo2)
    {
        *pdwInterlaceFlags = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->dwInterlaceFlags;
    }

CleanUp:
    return hr;
}

// this function just tells whether each sample consists of one or two fields
static BOOL DisplayingFields(DWORD dwInterlaceFlags)
{
   if ((dwInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
        return TRUE;
    else
        return FALSE;
}

// get the rcSource from the mediatype
// if rcSource is empty, it means take the whole image
HRESULT VPMUtil::GetSrcRectFromMediaType(const CMediaType& mediaType, RECT *pRect)
{
    HRESULT hr = NOERROR;
    LONG dwWidth = 0, dwHeight = 0;

    AMTRACE((TEXT("GetSrcRectFromMediaType")));

    if (!pRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    dwWidth = abs(pHeader->biWidth);
    dwHeight = abs(pHeader->biHeight);

    ASSERT((mediaType.formattype == FORMAT_VideoInfo) || (mediaType.formattype == FORMAT_VideoInfo2));

    if (mediaType.formattype == FORMAT_VideoInfo)
    {
        *pRect = ((VIDEOINFOHEADER*)(mediaType.pbFormat))->rcSource;
    }
    else if (mediaType.formattype == FORMAT_VideoInfo2)
    {
        *pRect = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->rcSource;
    }

    DWORD dwInterlaceFlags;
    if (SUCCEEDED(GetInterlaceFlagsFromMediaType(mediaType, &dwInterlaceFlags)) &&
       DisplayingFields(dwInterlaceFlags)) {

        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            (pRect->bottom / 2) > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcSource of mediatype is invalid")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }
    else {
        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            pRect->bottom > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcSource of mediatype is invalid")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }

    // An empty rect means the whole image, Yuck!
    if (IsRectEmpty(pRect))
        SetRect(pRect, 0, 0, dwWidth, dwHeight);

    // if either the width or height is zero then better set the whole
    // rect to be empty so that the callee can catch it that way
    if (WIDTH(pRect) == 0 || HEIGHT(pRect) == 0)
        SetRect(pRect, 0, 0, 0, 0);

CleanUp:
    return hr;
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE* VPMUtil::AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource, GUID formattype)
{
    DWORD dwFormatSize = 0;
    BYTE *pFormatPtr = NULL;
    AM_MEDIA_TYPE *pMediaType = NULL;
    HRESULT hr = NOERROR;

    if (formattype == FORMAT_VideoInfo)
        dwFormatSize = sizeof(VIDEOINFO);
    else if (formattype == FORMAT_VideoInfo2)
        dwFormatSize = sizeof(TRUECOLORINFO) + sizeof(VIDEOINFOHEADER2) + 4;    // actually this should be sizeof sizeof(VIDEOINFO2) once we define that

    pMediaType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (!pMediaType)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    pFormatPtr = (BYTE *)CoTaskMemAlloc(dwFormatSize);
    if (!pFormatPtr)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    if (pmtSource)
    {
        *pMediaType = *pmtSource;
        pMediaType->cbFormat = dwFormatSize;
        CopyMemory(pFormatPtr, pmtSource->pbFormat, pmtSource->cbFormat);
    }
    else
    {
        ZeroStruct( *pMediaType );
        ZeroMemory(pFormatPtr, dwFormatSize);
        pMediaType->majortype = MEDIATYPE_Video;
        pMediaType->formattype = formattype;
        pMediaType->cbFormat = dwFormatSize;
    }
    pMediaType->pbFormat = pFormatPtr;

CleanUp:
    if (FAILED(hr))
    {
        if (pMediaType)
        {
            CoTaskMemFree((PVOID)pMediaType);
            pMediaType = NULL;
        }
        if (!pFormatPtr)
        {
            CoTaskMemFree((PVOID)pFormatPtr);
            pFormatPtr = NULL;
        }
    }
    return pMediaType;
}

// Helper function converts a DirectDraw surface to a media type.
// The surface description must have:
//  Height
//  Width
//  lPitch
//  PixelFormat

// Initialise our output type based on the DirectDraw surface. As DirectDraw
// only deals with top down display devices so we must convert the height of
// the surface returned in the DDSURFACEDESC into a negative height. This is
// because DIBs use a positive height to indicate a bottom up image. We also
// initialise the other VIDEOINFO fields although they're hardly ever needed

AM_MEDIA_TYPE *VPMUtil::ConvertSurfaceDescToMediaType(const LPDDSURFACEDESC pSurfaceDesc, BOOL bInvertSize, CMediaType cMediaType)
{
    HRESULT hr = NOERROR;
    AM_MEDIA_TYPE *pMediaType = NULL;

    if ((*cMediaType.FormatType() != FORMAT_VideoInfo ||
        cMediaType.FormatLength() < sizeof(VIDEOINFOHEADER)) &&
        (*cMediaType.FormatType() != FORMAT_VideoInfo2 ||
        cMediaType.FormatLength() < sizeof(VIDEOINFOHEADER2)))
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    pMediaType = AllocVideoMediaType(&cMediaType, cMediaType.formattype);
    if (pMediaType == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    BITMAPINFOHEADER *pbmiHeader = GetbmiHeader((CMediaType*)pMediaType);
    if (!pbmiHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pbmiHeader is NULL, UNEXPECTED!!")));
        hr = E_FAIL;
        goto CleanUp;
    }

    // Convert a DDSURFACEDESC into a BITMAPINFOHEADER (see notes later). The
    // bit depth of the surface can be retrieved from the DDPIXELFORMAT field
    // in the DDpSurfaceDesc-> The documentation is a little misleading because
    // it says the field is permutations of DDBD_*'s however in this case the
    // field is initialised by DirectDraw to be the actual surface bit depth

    pbmiHeader->biSize = sizeof(BITMAPINFOHEADER);

    if (pSurfaceDesc->dwFlags & DDSD_PITCH)
    {
        pbmiHeader->biWidth = pSurfaceDesc->lPitch;
        // Convert the pitch from a byte count to a pixel count.
        // For some weird reason if the format is not a standard bit depth the
        // width field in the BITMAPINFOHEADER should be set to the number of
        // bytes instead of the width in pixels. This supports odd YUV formats
        // like IF09 which uses 9bpp.
        int bpp = pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
        if (bpp == 8 || bpp == 16 || bpp == 24 || bpp == 32)
        {
            pbmiHeader->biWidth /= (bpp / 8);   // Divide by number of BYTES per pixel.
        }
    }
    else
    {
        pbmiHeader->biWidth = pSurfaceDesc->dwWidth;
        // BUGUBUG -- Do something odd here with strange YUV pixel formats?  Or does it matter?
    }

    pbmiHeader->biHeight = pSurfaceDesc->dwHeight;
    if (bInvertSize)
    {
        pbmiHeader->biHeight = -pbmiHeader->biHeight;
    }
    pbmiHeader->biPlanes        = 1;
    pbmiHeader->biBitCount      = (USHORT) pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
    pbmiHeader->biCompression   = pSurfaceDesc->ddpfPixelFormat.dwFourCC;
    pbmiHeader->biClrUsed       = 0;
    pbmiHeader->biClrImportant  = 0;


    // For true colour RGB formats tell the source there are bit fields
    if (pbmiHeader->biCompression == BI_RGB)
    {
        if (pbmiHeader->biBitCount == 16 || pbmiHeader->biBitCount == 32)
        {
            pbmiHeader->biCompression = BI_BITFIELDS;
        }
    }

    if (pbmiHeader->biBitCount <= iPALETTE)
    {
        pbmiHeader->biClrUsed = 1 << pbmiHeader->biBitCount;
    }

    pbmiHeader->biSizeImage = DIBSIZE(*pbmiHeader);



    // The RGB bit fields are in the same place as for YUV formats
    if (pbmiHeader->biCompression != BI_RGB)
    {
        DWORD *pdwBitMasks = NULL;
        pdwBitMasks = (DWORD*)(VPMUtil::GetBitMasks((const CMediaType *)pMediaType));
        if ( ! pdwBitMasks )
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }
        // GetBitMasks only returns the pointer to the actual bitmasks
        // in the mediatype if biCompression == BI_BITFIELDS
        pdwBitMasks[0] = pSurfaceDesc->ddpfPixelFormat.dwRBitMask;
        pdwBitMasks[1] = pSurfaceDesc->ddpfPixelFormat.dwGBitMask;
        pdwBitMasks[2] = pSurfaceDesc->ddpfPixelFormat.dwBBitMask;
    }

    // And finish it off with the other media type fields
    pMediaType->subtype = GetBitmapSubtype(pbmiHeader);
    pMediaType->lSampleSize = pbmiHeader->biSizeImage;

    // set the src and dest rects if necessary
    if (pMediaType->formattype == FORMAT_VideoInfo)
    {
        VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *)pMediaType->pbFormat;
        VIDEOINFOHEADER *pSrcVideoInfo = (VIDEOINFOHEADER *)cMediaType.pbFormat;

        // if the surface allocated is different than the size specified by the decoder
        // then use the src and dest to ask the decoder to clip the video
        if ((abs(pVideoInfo->bmiHeader.biHeight) != abs(pSrcVideoInfo->bmiHeader.biHeight)) ||
            (abs(pVideoInfo->bmiHeader.biWidth) != abs(pSrcVideoInfo->bmiHeader.biWidth)))
        {
            if (IsRectEmpty(&(pVideoInfo->rcSource)))
            {
                pVideoInfo->rcSource.left = pVideoInfo->rcSource.top = 0;
                pVideoInfo->rcSource.right = pSurfaceDesc->dwWidth;
                pVideoInfo->rcSource.bottom = pSurfaceDesc->dwHeight;
            }
            if (IsRectEmpty(&(pVideoInfo->rcTarget)))
            {
                pVideoInfo->rcTarget.left = pVideoInfo->rcTarget.top = 0;
                pVideoInfo->rcTarget.right = pSurfaceDesc->dwWidth;
                pVideoInfo->rcTarget.bottom = pSurfaceDesc->dwHeight;
            }
        }
    }
    else if (pMediaType->formattype == FORMAT_VideoInfo2)
    {
        VIDEOINFOHEADER2 *pVideoInfo2 = (VIDEOINFOHEADER2 *)pMediaType->pbFormat;
        VIDEOINFOHEADER2 *pSrcVideoInfo2 = (VIDEOINFOHEADER2 *)cMediaType.pbFormat;

        // if the surface allocated is different than the size specified by the decoder
        // then use the src and dest to ask the decoder to clip the video
        if ((abs(pVideoInfo2->bmiHeader.biHeight) != abs(pSrcVideoInfo2->bmiHeader.biHeight)) ||
            (abs(pVideoInfo2->bmiHeader.biWidth) != abs(pSrcVideoInfo2->bmiHeader.biWidth)))
        {
            if (IsRectEmpty(&(pVideoInfo2->rcSource)))
            {
                pVideoInfo2->rcSource.left = pVideoInfo2->rcSource.top = 0;
                pVideoInfo2->rcSource.right = pSurfaceDesc->dwWidth;
                pVideoInfo2->rcSource.bottom = pSurfaceDesc->dwHeight;
            }
            if (IsRectEmpty(&(pVideoInfo2->rcTarget)))
            {
                pVideoInfo2->rcTarget.left = pVideoInfo2->rcTarget.top = 0;
                pVideoInfo2->rcTarget.right = pSurfaceDesc->dwWidth;
                pVideoInfo2->rcTarget.bottom = pSurfaceDesc->dwHeight;
            }
        }
    }

CleanUp:
    if (FAILED(hr))
    {
        if (pMediaType)
        {
            FreeMediaType(*pMediaType);
            pMediaType = NULL;
        }
    }
    return pMediaType;
}

/******************************Public*Routine******************************\
* GetRegistryDword
*
*
*
\**************************************************************************/
int
VPMUtil::GetRegistryDword(
    HKEY hk,
    const TCHAR *pKey,
    int iDefault
)
{
    HKEY hKey;
    LONG lRet;
    int  iRet = iDefault;

    lRet = RegOpenKeyEx(hk, chRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;

        dwLen = sizeof(iRet);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, 0L, &dwType,
                                             (LPBYTE)&iRet, &dwLen)) {
            iRet = iDefault;
        }
        RegCloseKey(hKey);
    }
    return iRet;
}

static const TCHAR szPropPage[] = TEXT("Property Pages");

int
VPMUtil::GetPropPagesRegistryDword( int iDefault )
{
    return VPMUtil::GetRegistryDword(HKEY_CURRENT_USER, szPropPage, iDefault );
}

/******************************Public*Routine******************************\
* SetRegistryDword
*
*
*
\**************************************************************************/
LONG
VPMUtil::SetRegistryDword(
    HKEY hk,
    const TCHAR *pKey,
    int iRet
)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(hk, chRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, 0L, REG_DWORD,
                             (LPBYTE)&iRet, sizeof(iRet));
        RegCloseKey(hKey);
    }
    return lRet;
}


// This function allocates a shared memory block for use by the upstream filter
// generating DIBs to render. The memory block is created in shared
// memory so that GDI doesn't have to copy the memory in BitBlt
HRESULT VPMUtil::CreateDIB(LONG lSize, BITMAPINFO *pBitMapInfo, DIBDATA *pDibData)
{
    HRESULT hr = NOERROR;
    BYTE *pBase = NULL;            // Pointer to the actual image
    HANDLE hMapping = NULL;        // Handle to mapped object
    HBITMAP hBitmap = NULL;        // DIB section bitmap handle
    DWORD dwError = 0;

    AMTRACE((TEXT("CreateDIB")));

    // Create a file mapping object and map into our address space
    hMapping = CreateFileMapping(hMEMORY, NULL,  PAGE_READWRITE,  (DWORD) 0, lSize, NULL);           // No name to section
    if (hMapping == NULL)
    {
        dwError = GetLastError();
        hr = AmHresultFromWin32(dwError);
        goto CleanUp;
    }

    // create the DibSection
    hBitmap = CreateDIBSection((HDC)NULL, pBitMapInfo, DIB_RGB_COLORS,
        (void**) &pBase, hMapping, (DWORD) 0);
    if (hBitmap == NULL || pBase == NULL)
    {
        dwError = GetLastError();
        hr = AmHresultFromWin32(dwError);
        goto CleanUp;
    }

    // Initialise the DIB information structure
    pDibData->hBitmap = hBitmap;
    pDibData->hMapping = hMapping;
    pDibData->pBase = pBase;
    pDibData->PaletteVersion = PALETTE_VERSION;
    GetObject(hBitmap, sizeof(DIBSECTION), (void*)&(pDibData->DibSection));

CleanUp:
    if (FAILED(hr))
    {
        EXECUTE_ASSERT(CloseHandle(hMapping));
    }
    return hr;
}

// DeleteDIB
//
// This function just deletes DIB's created by the above CreateDIB function.
//
HRESULT VPMUtil::DeleteDIB(DIBDATA *pDibData)
{
    if (!pDibData)
    {
        return E_INVALIDARG;
    }

    if (pDibData->hBitmap)
    {
        DeleteObject(pDibData->hBitmap);
    }

    if (pDibData->hMapping)
    {
        CloseHandle(pDibData->hMapping);
    }

    ZeroStruct( *pDibData );

    return NOERROR;
}


// function used to blt the data from the source to the target dc
void VPMUtil::FastDIBBlt(DIBDATA *pDibData, HDC hTargetDC, HDC hSourceDC, RECT *prcTarget, RECT *prcSource)
{
    HBITMAP hOldBitmap = NULL;         // Store the old bitmap
    DWORD dwSourceWidth = 0, dwSourceHeight = 0, dwTargetWidth = 0, dwTargetHeight = 0;

    ASSERT(prcTarget);
    ASSERT(prcSource);

    dwSourceWidth = WIDTH(prcSource);
    dwSourceHeight = HEIGHT(prcSource);
    dwTargetWidth = WIDTH(prcTarget);
    dwTargetHeight = HEIGHT(prcTarget);

    hOldBitmap = (HBITMAP) SelectObject(hSourceDC, pDibData->hBitmap);


    // Is the destination the same size as the source
    if ((dwSourceWidth == dwTargetWidth) && (dwSourceHeight == dwTargetHeight))
    {
        // Put the image straight into the target dc
        BitBlt(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
               dwTargetHeight, hSourceDC, prcSource->left, prcSource->top,
               SRCCOPY);
    }
    else
    {
        // Stretch the image when copying to the target dc
        StretchBlt(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, hSourceDC, prcSource->left, prcSource->top,
            dwSourceWidth, dwSourceHeight, SRCCOPY);
    }

    // Put the old bitmap back into the device context so we don't leak
    SelectObject(hSourceDC, hOldBitmap);
}

// funtion used to transfer pixels from the DIB to the target dc
void VPMUtil::SlowDIBBlt(BYTE *pDibBits, BITMAPINFOHEADER *pHeader, HDC hTargetDC, RECT *prcTarget, RECT *prcSource)
{
    DWORD dwSourceWidth = 0, dwSourceHeight = 0, dwTargetWidth = 0, dwTargetHeight = 0;

    ASSERT(prcTarget);
    ASSERT(prcSource);

    dwSourceWidth = WIDTH(prcSource);
    dwSourceHeight = HEIGHT(prcSource);
    dwTargetWidth = WIDTH(prcTarget);
    dwTargetHeight = HEIGHT(prcTarget);

    // Is the destination the same size as the source
    if ((dwSourceWidth == dwTargetWidth) && (dwSourceHeight == dwTargetHeight))
    {
        UINT uStartScan = 0, cScanLines = pHeader->biHeight;

        // Put the image straight into the target dc
        SetDIBitsToDevice(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, prcSource->left, prcSource->top, uStartScan, cScanLines,
            pDibBits, (BITMAPINFO*) pHeader, DIB_RGB_COLORS);
    }
    else
    {
        // if the origin of bitmap is bottom-left, adjust soruce_rect_top
        // to be the bottom-left corner instead of the top-left.
        LONG lAdjustedSourceTop = (pHeader->biHeight > 0) ? (pHeader->biHeight - prcSource->bottom) :
            (prcSource->top);

        // stretch the image into the target dc
        StretchDIBits(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, prcSource->left, lAdjustedSourceTop, dwSourceWidth, dwSourceHeight,
            pDibBits, (BITMAPINFO*) pHeader, DIB_RGB_COLORS, SRCCOPY);
    }

}

// get the rcTarget from the mediatype, after converting it to base MAX_REL_NUM
// if rcTarget is empty, it means take the whole image
HRESULT VPMUtil::GetDestRectFromMediaType(const CMediaType& mediaType, RECT *pRect)
{
    HRESULT hr = NOERROR;
    LONG dwWidth = 0, dwHeight = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering GetDestRectFromMediaType")));

    if (!pRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    dwWidth = abs(pHeader->biWidth);
    dwHeight = abs(pHeader->biHeight);

    ASSERT((mediaType.formattype == FORMAT_VideoInfo) || (mediaType.formattype == FORMAT_VideoInfo2));

    if (mediaType.formattype == FORMAT_VideoInfo)
    {
        *pRect = ((VIDEOINFOHEADER*)(mediaType.pbFormat))->rcTarget;
    }
    else if (mediaType.formattype == FORMAT_VideoInfo2)
    {
        *pRect = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->rcTarget;
    }

    DWORD dwInterlaceFlags;
    if (SUCCEEDED(GetInterlaceFlagsFromMediaType(mediaType, &dwInterlaceFlags)) &&
       DisplayingFields(dwInterlaceFlags)) {

        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            (pRect->bottom / 2) > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcTarget of mediatype is invalid")));
            SetRect(pRect, 0, 0, dwWidth, dwHeight);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }
    else {
        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            pRect->bottom > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcTarget of mediatype is invalid")));
            SetRect(pRect, 0, 0, dwWidth, dwHeight);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }

    // An empty rect means the whole image, Yuck!
    if (IsRectEmpty(pRect))
        SetRect(pRect, 0, 0, dwWidth, dwHeight);

    // if either the width or height is zero then better set the whole
    // rect to be empty so that the callee can catch it that way
    if (WIDTH(pRect) == 0 || HEIGHT(pRect) == 0)
        SetRect(pRect, 0, 0, 0, 0);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving GetDestRectFromMediaType")));
    return hr;
}

/*****************************Private*Routine******************************\
* IsDecimationNeeded
*
* Decimation is needed if the current minimum scale factor (either vertical
* or horizontal) is less than 1000.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
VPMUtil::IsDecimationNeeded(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("::IsDecimationNeeded")));
    return ScaleFactor < 1000;
}


/*****************************Private*Routine******************************\
* GetCurrentScaleFactor
*
* Determines the x axis scale factor and the y axis scale factor.
* The minimum of these two values is the limiting scale factor.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
VPMUtil::GetCurrentScaleFactor(
    const VPWININFO& winInfo,
    DWORD* lpxScaleFactor,
    DWORD* lpyScaleFactor
    )
{
    AMTRACE((TEXT("::GetCurrentScaleFactor")));

    DWORD dwSrcWidth = WIDTH(&winInfo.SrcRect);
    DWORD dwSrcHeight = HEIGHT(&winInfo.SrcRect);

    DWORD dwDstWidth = WIDTH(&winInfo.DestRect);
    DWORD dwDstHeight = HEIGHT(&winInfo.DestRect);

    DWORD xScaleFactor = MulDiv(dwDstWidth, 1000, dwSrcWidth);
    DWORD yScaleFactor = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    if (lpxScaleFactor) *lpxScaleFactor = xScaleFactor;
    if (lpyScaleFactor) *lpyScaleFactor = yScaleFactor;

    return min(xScaleFactor, yScaleFactor);
}


VIDEOINFOHEADER2* VPMUtil::GetVideoInfoHeader2(CMediaType *pMediaType)
{
    if (pMediaType && pMediaType->formattype == FORMAT_VideoInfo2 ) {
        return (VIDEOINFOHEADER2*)(pMediaType->pbFormat);
    } else {
        return NULL;
    }
}

const VIDEOINFOHEADER2* VPMUtil::GetVideoInfoHeader2(const CMediaType *pMediaType)
{
    if (pMediaType && pMediaType->formattype == FORMAT_VideoInfo2 ) {
        return (VIDEOINFOHEADER2*)(pMediaType->pbFormat);
    } else {
        return NULL;
    }
}

/*****************************Private*Routine******************************\
* VPMUtil::EqualPixelFormats
*
* this is just a helper function used by the "NegotiatePixelFormat"
* function. Just compares two pixel-formats to see if they are the
* same. We can't use a memcmp because of the fourcc codes.
*
*
* History:
* Thu 09/09/1999 - GlennE - Added this comment and cleaned up the code
*
\**************************************************************************/
BOOL
VPMUtil::EqualPixelFormats(
    const DDPIXELFORMAT& ddFormat1,
    const DDPIXELFORMAT& ddFormat2)
{
    AMTRACE((TEXT("VPMUtil::EqualPixelFormats")));

    if (ddFormat1.dwFlags & ddFormat2.dwFlags & DDPF_RGB)
    {
        if (ddFormat1.dwRGBBitCount == ddFormat2.dwRGBBitCount &&
            ddFormat1.dwRBitMask == ddFormat2.dwRBitMask &&
            ddFormat1.dwGBitMask == ddFormat2.dwGBitMask &&
            ddFormat1.dwBBitMask == ddFormat2.dwBBitMask)
        {
            return TRUE;
        }
    }
    else if (ddFormat1.dwFlags & ddFormat2.dwFlags & DDPF_FOURCC)
    {
        if (ddFormat1.dwFourCC == ddFormat2.dwFourCC)
        {
            return TRUE;
        }
    }

    return FALSE;
}

struct VPEnumCallback
{
    VPEnumCallback( DDVIDEOPORTCAPS* pVPCaps, DWORD dwVideoPortId )
        : m_pVPCaps( pVPCaps )
        , m_dwVideoPortId( dwVideoPortId )
        , m_fFound( false )
    {};


    HRESULT CompareCaps( LPDDVIDEOPORTCAPS lpCaps )
    {
        if (lpCaps && !m_fFound ) {
            if( lpCaps->dwVideoPortID == m_dwVideoPortId ) {
                if( m_pVPCaps ) {
                    *m_pVPCaps = *lpCaps;
                }
                m_fFound = true;
            }
        }
        return S_OK;
    }

    static HRESULT CALLBACK    EnumCallback( LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext )
    {
        VPEnumCallback* thisPtr = (VPEnumCallback*)lpContext;
        if (thisPtr) {
            return thisPtr->CompareCaps( lpCaps );
        } else {
            DbgLog((LOG_ERROR,0,
                    TEXT("lpContext = NULL, THIS SHOULD NOT BE HAPPENING!!!")));
            return E_FAIL;
        }
    }
    DDVIDEOPORTCAPS* m_pVPCaps;
    DWORD            m_dwVideoPortId;
    bool             m_fFound;
};


HRESULT VPMUtil::FindVideoPortCaps( IDDVideoPortContainer* pVPContainer, DDVIDEOPORTCAPS* pVPCaps, DWORD dwVideoPortId )
{
    VPEnumCallback state( pVPCaps, dwVideoPortId );

    HRESULT hr = pVPContainer->EnumVideoPorts(0, NULL, &state, state.EnumCallback );
    if( SUCCEEDED( hr )) {
        if( state.m_fFound ) {
            return hr;
        } else {
            return S_FALSE;
        }
    }
    return hr;
}

HRESULT VPMUtil::FindVideoPortCaps( LPDIRECTDRAW7 pDirectDraw, DDVIDEOPORTCAPS* pVPCaps, DWORD dwVideoPortId )
{
    if( !pDirectDraw ) {
        return E_INVALIDARG;
    } else {
        IDDVideoPortContainer* pDVP = NULL;
        HRESULT hr = pDirectDraw->QueryInterface(IID_IDDVideoPortContainer, (LPVOID *)&pDVP);
        if( SUCCEEDED( hr )) {
            hr = FindVideoPortCaps( pDVP, pVPCaps, dwVideoPortId );
            RELEASE( pDVP );
        }
        return hr;
    }
}

void VPMUtil::FixupVideoInfoHeader2(
    VIDEOINFOHEADER2 *pVideoInfo,
    DWORD dwComppression,
    int nBitCount
    )
{
    ASSERT( pVideoInfo ); // should never be called as NULL
    if ( pVideoInfo )
    {
        LPBITMAPINFOHEADER lpbi = &pVideoInfo->bmiHeader;

        lpbi->biSize          = sizeof(BITMAPINFOHEADER);
        lpbi->biPlanes        = (WORD)1;
        lpbi->biBitCount      = (WORD)nBitCount;
        lpbi->biClrUsed   = 0;
        lpbi->biClrImportant = 0;

        //  From input
        lpbi->biXPelsPerMeter = 0; // m_seqInfo.lXPelsPerMeter;
        lpbi->biYPelsPerMeter = 0; // m_seqInfo.lYPelsPerMeter;

        lpbi->biCompression   = dwComppression;
        lpbi->biSizeImage     = GetBitmapSize(lpbi);

        DWORD dwBPP = DIBWIDTHBYTES(*lpbi);
        ASSERT( dwBPP );

        //
        // The "bit" rate is image size in bytes times 8 (to convert to bits)
        // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
        // so we multiply by 10000000 to convert to bits per second, this multiply
        // is combined with "times" 8 above so the calculations becomes:
        //
        // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
        //
        LARGE_INTEGER li;
        li.QuadPart = pVideoInfo->AvgTimePerFrame;
        pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000,
                                       li.LowPart);
        pVideoInfo->dwBitErrorRate = 0L;
    }
}

void VPMUtil::InitVideoInfoHeader2(
    VIDEOINFOHEADER2 *pVideoInfo )
{
    ASSERT( pVideoInfo ); // should never be called as NULL
    if ( pVideoInfo )
    {
        LPBITMAPINFOHEADER lpbi = &pVideoInfo->bmiHeader;

        lpbi->biSize          = sizeof(BITMAPINFOHEADER);
        lpbi->biPlanes        = (WORD)0;
        lpbi->biBitCount      = (WORD)0;
        lpbi->biClrUsed   = 0;
        lpbi->biClrImportant = 0;

        //  From input
        lpbi->biXPelsPerMeter = 0; // m_seqInfo.lXPelsPerMeter;
        lpbi->biYPelsPerMeter = 0; // m_seqInfo.lYPelsPerMeter;

        lpbi->biCompression   = 0;
        lpbi->biSizeImage     = GetBitmapSize(lpbi);

        lpbi->biWidth = 0;
        lpbi->biHeight = 0;

        //
        // The "bit" rate is image size in bytes times 8 (to convert to bits)
        // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
        // so we multiply by 10000000 to convert to bits per second, this multiply
        // is combined with "times" 8 above so the calculations becomes:
        //
        // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
        //
        LARGE_INTEGER li;
        li.QuadPart = pVideoInfo->AvgTimePerFrame;
        pVideoInfo->dwBitRate = 0;
        pVideoInfo->dwBitErrorRate = 0L;
    }
}
VIDEOINFOHEADER2* VPMUtil::SetToVideoInfoHeader2( CMediaType* pmt, DWORD dwExtraBytes )
{
    VIDEOINFOHEADER2* pVIH2 = (VIDEOINFOHEADER2 *)pmt->ReallocFormatBuffer(sizeof(VIDEOINFOHEADER2)+dwExtraBytes );
    if( pVIH2 ) {
        ZeroStruct( *pVIH2 );

        pmt->majortype = MEDIATYPE_Video;
        pmt->formattype = FORMAT_VideoInfo2;

        pmt->subtype   = MEDIASUBTYPE_None;
        InitVideoInfoHeader2( pVIH2 );
    }
    return pVIH2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpminpin.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <VPManager.h>
#include "VPMPin.h"
#include <VPMUtil.h>
#include <ddkernel.h>

#include <ksmedia.h>


// IVideoPortControl
#include <VPObj.h>

// AMINTERLACE_*
#include <dvdmedia.h>
#include "DRect.h"

extern "C"
const TCHAR szPropPage[] = TEXT("Property Pages");

//
//   Flipping surface implementation
//
//   To allow decoders to hold on to surfaces for out of order decode
//   we flip directly to the surface pass on Receive rather than
//   use the default NULL target surface for Flip().
//
//   This works in the following way
//
//   The COMPinputPin::m_pDirectDrawSurface points to the FRONT buffer
//
//   When Receive is called we Flip() the front buffer and because we
//   do an explicit Flip() DirectDraw swaps the memory pointers for the
//   current Front buffer and the surface passed in which is then attached
//   to the front buffer.
//
//   The received buffer is then put at the back of the queue so (correctly)
//   the previous front buffer is now at the back of the queue to be handed
//   to the application
//
//   The allocator actually has one more buffer than was actually requested
//   so the previous front buffer won't actually be requested until the next
//   Receive and hence the previous Flip() has time to complete.
//

//  Video accelerator disable interface


//
/////////////////////////////////////
// CLASS CVPMInputPin implemented here
/////////////////////////////////////

// constructor
CVPMInputPin::CVPMInputPin( TCHAR *pObjectName,
                           CVPMFilter& pFilter,
                           HRESULT *phr,
                           LPCWSTR pPinName,
                           DWORD dwPinNo)
: CBaseInputPin(pObjectName, &pFilter, &pFilter.GetFilterLock(), phr, pPinName)
, CVPMPin( dwPinNo, pFilter )
, m_cOurRef( 0 )
, m_pIVPObject( NULL )
, m_pIVPInfo(NULL)
, m_CategoryGUID( GUID_NULL )
, m_Communication( KSPIN_COMMUNICATION_SOURCE )
, m_bStreamingInKernelMode( FALSE )
, m_dwBackBufferCount( 0 )
, m_dwDirectDrawSurfaceWidth( 0 )
, m_dwMinCKStretchFactor( 0 )
, m_bSyncOnFill( FALSE )
, m_bDontFlip( FALSE  )
, m_bDynamicFormatNeeded( TRUE )
, m_bNewPaletteSet( TRUE )
, m_dwInterlaceFlags( 0 )
, m_dwFlipFlag( 0 )
, m_bConnected( FALSE )
, m_bUsingOurAllocator( FALSE )
, m_hMemoryDC( NULL )
, m_bCanOverAllocateBuffers( TRUE )
, m_hEndOfStream( NULL )
, m_bDecimating( FALSE )
, m_lWidth( 0L )
, m_lHeight( 0L )
, m_bRuntimeNegotiationFailed( FALSE)

, m_dwUpdateOverlayFlags( 0 )
, m_dwFlipFlag2( 0 )
, m_trLastFrame( 0 )
, m_lSrcWidth( 0 )
, m_lSrcHeight( 0 )

, m_rtNextSample( 0 )
, m_rtLastRun( 0 )
{
    AMTRACE((TEXT("CVPMInputPin::Constructor")));

    memset( &m_WinInfo, 0, sizeof(m_WinInfo) );
    m_bWinInfoSet = false;

    *phr = S_OK;
    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;

    HRESULT hr = NOERROR;
    LPUNKNOWN pUnkOuter;

    SetReconnectWhenActive(true);

#ifdef PERF
    m_PerfFrameFlipped = MSR_REGISTER(TEXT("Frame Drawn"));
#endif

    // See combase.cpp(107) for comments on this
    IUnknown* pThisUnknown = reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) );

    m_pVideoPortObject = new CVideoPortObj( pThisUnknown, phr, this );

    // alias pointer to interfaces (instead of QI'ing)
    m_pIVPObject = m_pVideoPortObject;
    m_pIVPInfo = m_pVideoPortObject;

    hr = m_pIVPObject->SetObjectLock( &m_pVPMFilter.GetFilterLock() );
    if (FAILED(hr))
    {
        *phr = hr;
    }
    return;
}

// destructor
CVPMInputPin::~CVPMInputPin(void)
{
    AMTRACE((TEXT("CVPMInputPin::Destructor")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // delete the inner object
    delete m_pVideoPortObject;
	m_pVideoPortObject = NULL;
}

// overriden to expose IMediaPosition and IMediaSeeking control interfaces
STDMETHODIMP CVPMInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::NonDelegatingQueryInterface")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (riid == IID_IVPNotify ) {
        hr = GetInterface( static_cast<IVPNotify*>(m_pVideoPortObject), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->QueryInterface failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IVPNotify2 ) { 
        hr = GetInterface( static_cast<IVPNotify2*>(m_pVideoPortObject), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->QueryInterface failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IKsPin) {
        hr = GetInterface(static_cast<IKsPin *>(this), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IKsPin*) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IKsPropertySet) {
        hr = GetInterface(static_cast<IKsPropertySet *>(this), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IKsPropertySet*) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IPinConnection) {
        hr = GetInterface(static_cast<IPinConnection*>(this), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IPinConnection, ppv) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_ISpecifyPropertyPages&& 0 != VPMUtil::GetPropPagesRegistryDword( 0)) {
        return GetInterface(static_cast<ISpecifyPropertyPages *>(this), ppv);
    } else {
        // call the base class
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
    }
    return hr;
}

//
// NonDelegatingAddRef/NonDelegatingRelease
//
//
STDMETHODIMP_(ULONG) CVPMInputPin::NonDelegatingAddRef(void)
{
    return m_pVPMFilter.AddRef();
} // NonDelegatingAddRef


STDMETHODIMP_(ULONG) CVPMInputPin::NonDelegatingRelease(void)
{
    return m_pVPMFilter.Release();
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CVPMInputPin::GetPages(CAUUID *pPages)
{
#if 0
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*1);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_COMPinConfigProperties;

    return NOERROR;
#else
    return E_NOTIMPL;
#endif
}


// this function just tells whether each sample consists of one or two fields
BOOL DisplayingFields(DWORD dwInterlaceFlags)
{
   if ((dwInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
        return TRUE;
    else
        return FALSE;
}


BOOL CheckTypeSpecificFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags)
{
    // first determine which field do we want to display here
    if ((dwInterlaceFlags & AMINTERLACE_1FieldPerSample) &&
        ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_INTERLEAVED_FRAME))
    {
        return FALSE;
    }

    if ((!(dwInterlaceFlags & AMINTERLACE_1FieldPerSample)) &&
        (((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1) ||
           ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD2)))
    {
        return FALSE;
    }

    if (dwTypeSpecificFlags & AM_VIDEO_FLAG_REPEAT_FIELD)
    {
        return FALSE;
    }

    return TRUE;
}

// given the interlace flags and the type-specific flags, this function determines whether we
// are supposed to display the sample in bob-mode or not. It also tells us, which direct-draw flag
// are we supposed to use when flipping. When displaying an interleaved frame, it assumes we are
// talking about the field which is supposed to be displayed first.
BOOL NeedToFlipOddEven(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags, DWORD *pdwFlipFlag)
{
    BOOL bDisplayField1 = TRUE;
    BOOL bField1IsOdd = TRUE;
    BOOL bNeedToFlipOddEven = FALSE;
    DWORD dwFlipFlag = 0;

    // if not interlaced content, mode is not bob
    if (!(dwInterlaceFlags & AMINTERLACE_IsInterlaced))
    {
        bNeedToFlipOddEven = FALSE;
        goto CleanUp;
    }

    // if sample have a single field, then check the field pattern
    if ((dwInterlaceFlags & AMINTERLACE_1FieldPerSample) &&
        (((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField1Only) ||
         ((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField2Only)))
    {
        bNeedToFlipOddEven = FALSE;
        goto CleanUp;
    }

    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOnly) ||
        (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOrWeave) &&
         (!(dwTypeSpecificFlags & AM_VIDEO_FLAG_WEAVE))))
    {
        // first determine which field do we want to display here
        if (dwInterlaceFlags & AMINTERLACE_1FieldPerSample)
        {
            // if we are in 1FieldPerSample mode, check which field is it
            ASSERT(((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1) ||
                ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD2));
            bDisplayField1 = ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1);
        }
        else
        {
            // ok the sample is an interleaved frame
            ASSERT((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_INTERLEAVED_FRAME);
            bDisplayField1 = (dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD1FIRST);
        }

        bField1IsOdd = (dwInterlaceFlags & AMINTERLACE_Field1First);

        // if we displaying field 1 and field 1 is odd or we are displaying field2 and field 2 is odd
        // then use DDFLIP_ODD. Exactly the opposite for DDFLIP_EVEN
        if ((bDisplayField1 && bField1IsOdd) || (!bDisplayField1 && !bField1IsOdd))
            dwFlipFlag = DDFLIP_ODD;
        else
            dwFlipFlag = DDFLIP_EVEN;

        bNeedToFlipOddEven = TRUE;
        goto CleanUp;
    }

CleanUp:
    if (pdwFlipFlag)
        *pdwFlipFlag = dwFlipFlag;
    return bNeedToFlipOddEven;
}

// given the interlace flags and the type-specific flags, this function determines whether we
// are supposed to display the sample in bob-mode or not. It also tells us, which direct-draw flag
// are we supposed to use when flipping. When displaying an interleaved frame, it assumes we are
// talking about the field which is supposed to be displayed first.
DWORD GetUpdateOverlayFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags)
{
    DWORD dwFlags = DDOVER_SHOW | DDOVER_KEYDEST;
    DWORD dwFlipFlag;

    if (NeedToFlipOddEven(dwInterlaceFlags, dwTypeSpecificFlags, &dwFlipFlag))
    {
        dwFlags |= DDOVER_BOB;
        if (!DisplayingFields(dwInterlaceFlags))
            dwFlags |= DDOVER_INTERLEAVED;
    }
    return dwFlags;
}

// this function checks if the InterlaceFlags are suitable or not
HRESULT CVPMInputPin::CheckInterlaceFlags(DWORD dwInterlaceFlags)
{
    HRESULT hr = NOERROR;


    AMTRACE((TEXT("CVPMInputPin::CheckInterlaceFlags")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (dwInterlaceFlags & AMINTERLACE_UNUSED)
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // check that the display mode is one of the three allowed values
    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOnly) &&
        ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeWeaveOnly) &&
        ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOrWeave))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // if content is not interlaced, other bits are irrelavant, so we are done
    if (!(dwInterlaceFlags & AMINTERLACE_IsInterlaced))
    {
        goto CleanUp;
    }

    // samples are frames, not fields (so we can handle any display mode)
    if (!(dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
    {
        goto CleanUp;
    }

    // can handle a stream of just field1 or field2, whatever the display mode
    if (((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField1Only) ||
        ((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField2Only))
    {
        goto CleanUp;
    }

    // can handle only bob-mode for field samples
    if ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOnly)
    {
        goto CleanUp;
    }

    // cannot handle only Weave mode or BobOrWeave mode for field samples
    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeWeaveOnly) ||
         ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOrWeave))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // we should have covered all possible scenarios by now, so assert here
    ASSERT(1);

CleanUp:

    // we cannot handle bob mode with an offscreen surface or if the driver can't support it
    if (SUCCEEDED(hr))
    {
        const DDCAPS* pDirectCaps = m_pVPMFilter.GetHardwareCaps();
        if ( pDirectCaps )
        {
            // call NeedToFlipOddEven with dwTypeSpecificFlags=0, to pretend that the
            // type-specific-flags is asking us to do bob-mode.
            bool bCanBob = false;
            if ( !bCanBob && NeedToFlipOddEven(dwInterlaceFlags, 0, NULL)  )
            {
                hr = VFW_E_TYPE_NOT_ACCEPTED;
            }
        }
    }
    return hr;
}

// this function check if the mediatype on a dynamic format change is suitable.
// No lock is taken here. It is the callee's responsibility to maintain integrity!
HRESULT CVPMInputPin::DynamicCheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    DWORD dwOldInterlaceFlags = 0, dwNewInterlaceFlags = 0, dwCompareSize = 0;
    BOOL bOld1FieldPerSample = FALSE, bNew1FieldPerSample = FALSE;
    BOOL b1, b2;

    AMTRACE((TEXT("CVPMInputPin::DynamicCheckMediaType")));

    // majortype and SubType are not allowed to change dynamically,
    // format type can change.
    CMediaType mtNew;
    hr = m_pIVPObject->CurrentMediaType( &mtNew );

    if (FAILED(hr) ||
	NULL == pmt ||
        (!(IsEqualGUID(pmt->majortype, mtNew.majortype))) ||
        (!(IsEqualGUID(pmt->subtype, mtNew.subtype))))
    {
        goto CleanUp;
    }

    // get the interlace flags of the new mediatype
    hr = VPMUtil::GetInterlaceFlagsFromMediaType( *pmt, &dwNewInterlaceFlags);
    if (FAILED(hr))
    {
        goto CleanUp;
    }

    // get the interlace flags of the new mediatype
    hr = VPMUtil::GetInterlaceFlagsFromMediaType( mtNew, &dwOldInterlaceFlags);
    if (FAILED(hr))
    {
        goto CleanUp;
    }

    //
    // There are several bugs in the following code !!
    // We goto CleanUp but hr has not been updated with a valid error code!!
    //

    bOld1FieldPerSample = (dwOldInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwOldInterlaceFlags & AMINTERLACE_1FieldPerSample);
    bNew1FieldPerSample = (dwNewInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwNewInterlaceFlags & AMINTERLACE_1FieldPerSample);


    // we do not allow dynamic format changes where you go from 1FieldsPerSample to
    // 2FieldsPerSample or vica-versa since that means reallocating the surfaces.
    if (bNew1FieldPerSample != bOld1FieldPerSample)
    {
        goto CleanUp;
    }

    const BITMAPINFOHEADER* pNewHeader = VPMUtil::GetbmiHeader(pmt);
    if (!pNewHeader)
    {
        goto CleanUp;
    }

    const BITMAPINFOHEADER* pOldHeader = VPMUtil::GetbmiHeader(&mtNew);
    if (!pNewHeader)
    {
        goto CleanUp;
    }

    dwCompareSize = FIELD_OFFSET(BITMAPINFOHEADER, biClrUsed);
    ASSERT(dwCompareSize < sizeof(BITMAPINFOHEADER));

    if (memcmp(pNewHeader, pOldHeader, dwCompareSize) != 0)
    {
        goto CleanUp;
    }

    hr = NOERROR;

CleanUp:
    // CVPMInputPin::DynamicCheckMediaType")));
    return hr;
}


// check that the mediatype is acceptable. No lock is taken here. It is the callee's
// responsibility to maintain integrity!
HRESULT CVPMInputPin::CheckMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CVPMInputPin::CheckMediaType")));

    // check if the VP component likes this mediatype
    // check if the videoport object likes it
    HRESULT hr = m_pIVPObject->CheckMediaType(pmt);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("m_pIVPObject->CheckMediaType failed, hr = 0x%x"), hr));
        ASSERT( hr == VFW_E_TYPE_NOT_ACCEPTED ); // can't fail with anything else
    } else {
        DbgLog((LOG_TRACE, 2, TEXT("m_pIVPObject->CheckMediaType succeeded, bAcceptableVPMediatype is TRUE")));
    }
    return hr;
}

// called after we have agreed a media type to actually set it
HRESULT CVPMInputPin::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::SetMediaType")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = VPMUtil::GetbmiHeader(pmt);
    if (pHeader)
    {
        // store the interlace flags since we use them again and again
        hr = VPMUtil::GetInterlaceFlagsFromMediaType( *pmt, &m_dwInterlaceFlags);
        ASSERT(SUCCEEDED(hr));

        // store the update overlay flags (give the type specific flag is WEAVE so that for BOB or WEAVE
        // mode, we not bob
        m_dwUpdateOverlayFlags = GetUpdateOverlayFlags(m_dwInterlaceFlags, AM_VIDEO_FLAG_WEAVE);
    }

    // Set the base class media type (should always succeed)
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    hr = m_pIVPObject->CheckMediaType(pmt);
    if (SUCCEEDED(hr))
    {
        m_pVPMFilter.SetDecimationUsage(DECIMATION_LEGACY);
        hr = m_pIVPObject->SetMediaType(pmt);
        ASSERT(SUCCEEDED(hr));
    }
   
    // tell the proxy not to allocate buffers if it is a videoport or overlay connection
    SetStreamingInKernelMode(TRUE);

    // tell the owning filter
    hr = m_pVPMFilter.SetMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }



CleanUp:
    return hr;
}


HRESULT CVPMInputPin::CurrentMediaType(CMediaType *pmt)
{
    ValidateReadWritePtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    /*  Copy constructor of m_mt allocates the memory */
    if (IsConnected())
    {
        if( m_pIVPObject ) {
            return m_pIVPObject->CurrentMediaType( pmt );
        } else {
            // shouldn't happen, we alloc this in our constructor
            pmt->InitMediaType();
            return E_FAIL;
        }
    } else {
        pmt->InitMediaType();
        return VFW_E_NOT_CONNECTED;
    }
}

#ifdef DEBUG
/*****************************Private*Routine******************************\
* VideoFormat2String
*
* Converts a video format block to a string - useful for debugging
*
* History:
* Tue 12/07/1999 - StEstrop - Created
*
\**************************************************************************/
void VideoFormat2String(
    LPTSTR szBuffer,
    const GUID* pFormatType,
    BYTE* pFormat,
    ULONG lFormatLength
    )
{
    if (!pFormat) {
        lstrcpy(szBuffer, TEXT("No format data specified"));
        return;
    }

    //
    // Video Format
    //
    if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo) ||
        IsEqualGUID(*pFormatType, FORMAT_MPEGVideo)) {

        VIDEOINFO * pVideoFormat = (VIDEOINFO *) pFormat;

        wsprintf(szBuffer, TEXT("%4.4hs %dx%d, %d bits"),
                 (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB " :
                 ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                 (LPSTR) &pVideoFormat->bmiHeader.biCompression),
                 pVideoFormat->bmiHeader.biWidth,
                 pVideoFormat->bmiHeader.biHeight,
                 pVideoFormat->bmiHeader.biBitCount);
    }
    else if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo2) ||
             IsEqualGUID(*pFormatType, FORMAT_MPEG2Video)) {

        VIDEOINFOHEADER2 * pVideoFormat = (VIDEOINFOHEADER2 *) pFormat;

        wsprintf(szBuffer, TEXT("%4.4hs %dx%d, %d bits"),
                 (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB " :
                 ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                 (LPSTR) &pVideoFormat->bmiHeader.biCompression ),
                 pVideoFormat->bmiHeader.biWidth,
                 pVideoFormat->bmiHeader.biHeight,
                 pVideoFormat->bmiHeader.biBitCount);

    }
    else {
        lstrcpy(szBuffer, TEXT("Unknown format"));
    }
}
#endif
// pConnector is the initiating connecting pin
// pmt is the media type we will exchange
// This function is also called while the graph is running when the
// up stream decoder filter wants to change the size of the
// decoded video.
//
// If the up stream decoder wants to change from one transport
// type to another, eg. from MoComp back to IMemInputPin then it
// should perform a dynamic filter reconnect via the IGraphConfig
// Reconnect method.
//
STDMETHODIMP CVPMInputPin::ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = NOERROR;
    CVPMInputAllocator * pAlloc = NULL;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    CheckPointer(pmt, E_POINTER);
    CMediaType cmt(*pmt);

    if (m_Connected != pConnector || pConnector == NULL)
    {
        hr = CBaseInputPin::ReceiveConnection(pConnector, &cmt);
        goto CleanUp;
    }

#ifdef DEBUG
    DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection when connected")));
    if (pmt)
    {
        TCHAR   szFmt[128];
        VideoFormat2String(szFmt, &pmt->formattype, pmt->pbFormat, pmt->cbFormat);
        DbgLog((LOG_TRACE, 2, TEXT("Format is: %s"), szFmt));
    }
#endif

    {
        /*  Can only do this if the allocator can be reconfigured */
        pAlloc = (CVPMInputAllocator *)m_pAllocator;
        if (!pAlloc)
        {
            hr = E_FAIL;
            DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: Failed because of no allocator")));
            goto CleanUp;
        }

        if (!pAlloc->CanFree())
        {
            hr = VFW_E_WRONG_STATE;
            DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: Failed because allocator can't free")));
            goto CleanUp;
        }
    }


    m_bConnected = FALSE;

    hr = CheckMediaType(&cmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: CheckMediaType failed")));
        goto CleanUp;
    }

    ALLOCATOR_PROPERTIES Props;
    {
        pAlloc->Decommit();
        pAlloc->GetProperties(&Props);

    }
    


    // back buffers are not addref'd so just set them to NULL
    m_dwBackBufferCount = 0;
    m_dwDirectDrawSurfaceWidth = 0;
    SetMediaType(&cmt);

    {
        ALLOCATOR_PROPERTIES PropsActual;
        Props.cbBuffer = pmt->lSampleSize;
        hr = pAlloc->SetProperties(&Props, &PropsActual);
        if (SUCCEEDED(hr))
        {
            hr = pAlloc->Commit();
        }
    }

    hr = UpdateMediaType();
    ASSERT(SUCCEEDED(hr));

    m_bConnected = TRUE;


CleanUp:
    return hr;
}

HRESULT CVPMInputPin::CheckConnect(IPin * pReceivePin)
{
    HRESULT hr = NOERROR;
    PKSMULTIPLE_ITEM pMediumList = NULL;
    IKsPin *pIKsPin = NULL;
    PKSPIN_MEDIUM pMedium = NULL;

    AMTRACE((TEXT("CVPMInputPin::CheckConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    hr = pReceivePin->QueryInterface(IID_IKsPin, (void **)&pIKsPin);
    if (SUCCEEDED(hr))
    {
        ASSERT(pIKsPin);
        hr = pIKsPin->KsQueryMediums(&pMediumList);
    }
    if( SUCCEEDED( hr )) {
        ASSERT(pMediumList);
        pMedium = (KSPIN_MEDIUM *)(pMediumList+1);
        SetKsMedium((const KSPIN_MEDIUM *)pMedium);
    }

// CleanUp:

    // call the base class
    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CheckConnect failed, hr = 0x%x"), hr));
    }

    RELEASE(pIKsPin);

    if (pMediumList)
    {
        CoTaskMemFree((void*)pMediumList);
        pMediumList = NULL;
    }

    return hr;
}

HRESULT CVPMInputPin::UpdateMediaType()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::UpdateMediaType")));
    return hr;
}

// final connect
HRESULT CVPMInputPin::FinalConnect()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::FinalConnect")));

    if (m_bConnected)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    // update the mediatype, tell the filter about the updated dimensions
    hr = UpdateMediaType();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("UpdateMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the filter (might involve a reconnection with the output pin)
    hr = m_pVPMFilter.CompleteConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    m_bConnected = TRUE;

CleanUp:
    return hr;
}

// Complete Connect
HRESULT CVPMInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    AMVPDATAINFO amvpDataInfo;
    BITMAPINFOHEADER *pHeader = NULL;

    AMTRACE((TEXT("CVPMInputPin::CompleteConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

   {
        // tell the videoport object
        hr = m_pIVPObject->CompleteConnect(pReceivePin);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->CompleteConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        m_bRuntimeNegotiationFailed = FALSE;
    }

    // call the base class
    hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    ASSERT(SUCCEEDED(hr));
    {
        // tell the proxy not to allocate buffers if it is a videoport or overlay connection
        SetStreamingInKernelMode(TRUE);

        hr = FinalConnect();
        // ASSERT(SUCCEEDED(hr));
        if( FAILED(hr) ) {
            SetStreamingInKernelMode(FALSE);
            DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::FinalConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    // the decoders can support a particular property set to tell the ovmixer to not to try to over-allocate
    // buffers incase they want complete control over the buffers etc
    {
        HRESULT hr1 = NOERROR;
        IKsPropertySet *pIKsPropertySet = NULL;
        DWORD dwVal = 0, dwBytesReturned = 0;


        hr1 = pReceivePin->QueryInterface(IID_IKsPropertySet, (void**)&pIKsPropertySet);
        if (SUCCEEDED(hr1))
        {
            ASSERT(pIKsPropertySet);

            if (!pIKsPropertySet)
            {
                DbgLog((LOG_ERROR, 1, TEXT("pIKsPropertySet == NULL, even though QI returned success")));
                goto CleanUp;
            }

            hr1 = pIKsPropertySet->Get( PROPSETID_ALLOCATOR_CONTROL, KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,
                        NULL, 0, &dwVal, sizeof(dwVal), &dwBytesReturned);
            DbgLog((LOG_TRACE, 2, TEXT("pIKsPropertySet->Get(KSPROPSETID_ALLOCATOR_CONTROL), hr1 = 0x%x, dwVal == %d, dwBytesReturned == %d"),
                hr1, dwVal, dwBytesReturned));


            // if the decoder supports this property
            // and its value is 1 and the decoder supports DDKERNELCAPS_FLIPOVERLAY,
            // than we will do exactly honour its request and the
            // and not make any attempt to allocate more in order to prevent tearing
            //
            if ((SUCCEEDED(hr1)) && (dwVal == 1) && (dwBytesReturned == sizeof(dwVal)) &&
                (DDKERNELCAPS_FLIPOVERLAY & m_pVPMFilter.KernelCaps()))
            {
                DbgLog((LOG_TRACE, 2, TEXT("setting m_bCanOverAllocateBuffers == FALSE")));
                m_bCanOverAllocateBuffers = FALSE;
            }
            pIKsPropertySet->Release();
        }
    }

CleanUp:
    return hr;
}


HRESULT CVPMInputPin::OnSetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr = NOERROR;

    IPin *pReceivePin = NULL;
    DDSURFACEDESC ddSurfaceDesc;
    IEnumMediaTypes *pEnumMediaTypes = NULL;
    CMediaType cMediaType;
    AM_MEDIA_TYPE *pNewMediaType = NULL, *pEnumeratedMediaType = NULL;
    ULONG ulFetched = 0;
    DWORD dwMaxBufferCount = 0;
    BOOL bFoundSuitableSurface = FALSE;
    BITMAPINFOHEADER *pHeader = NULL;
    LPDDCAPS pDirectCaps = NULL;

    AMTRACE((TEXT("CVPMInputPin::OnSetProperties")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // this function is only called after the base class CBaseAllocator::SetProperties() has been called
    // with the above parameters, so we don't have to do any parameter validation

    ASSERT(IsConnected());
    pReceivePin = CurrentPeer();
    ASSERT(pReceivePin);

    // we only care about the number of buffers requested, rest everything is ignored
    if (pRequest->cBuffers <= 0)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

CleanUp:
    return hr;
}


HRESULT CVPMInputPin::BreakConnect(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::BreakConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());


    {
        // tell the videoport object
        ASSERT(m_pIVPObject);
        hr = m_pIVPObject->BreakConnect();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->BreakConnect failed, hr = 0x%x"), hr));
        }
    }

    
    {
        

        // back buffers are not addref'd so just set them to NULL
        m_dwBackBufferCount = 0;
        m_dwDirectDrawSurfaceWidth = 0;

    }

    // initialize the behaviour to telling the proxy to allocate buffers
    SetStreamingInKernelMode(FALSE);

    m_bUsingOurAllocator = FALSE;
    m_bCanOverAllocateBuffers = TRUE;

    if (m_hMemoryDC)
    {
        EXECUTE_ASSERT(DeleteDC(m_hMemoryDC));
        m_hMemoryDC = NULL;
    }

    // call the base class
    hr = CBaseInputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::BreakConnect failed, hr = 0x%x"), hr));
    }

    // tell the owning filter
    hr = m_pVPMFilter.BreakConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.BreakConnect failed, hr = 0x%x"), hr));
    }

   
    m_bConnected = FALSE;
//CleanUp:
    return hr;
}

STDMETHODIMP CVPMInputPin::GetState(DWORD dwMSecs,FILTER_STATE *pState)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // if not connected or VideoPort Connection or IOverlay connection, then let the base class handle it
    // otherwise (overlay, offcreen, gdi, motion-comp) let the sync object handle it
    return E_NOTIMPL;
}

HRESULT CVPMInputPin::CompleteStateChange(FILTER_STATE OldState)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    return S_OK;
}

// transition from stop to pause state
HRESULT CVPMInputPin::Active(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::Active")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    m_hEndOfStream = NULL;

    {
        // tell the videoport object
        hr = m_pIVPObject->Active();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Active failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    // call the base class
    hr = CBaseInputPin::Active();
    // if it is a VP connection, this error is ok
    if (hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Active failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// transition from pause to stop state
HRESULT CVPMInputPin::Inactive(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::Inactive")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    {
        // tell the videoport object
        hr = m_pIVPObject->Inactive();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Inactive failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // make sure that if there is a run time error, stop succeeds
        if (m_bRuntimeNegotiationFailed && hr == VFW_E_NOT_CONNECTED)
        {
            hr = NOERROR;
        }
    }
    
    // call the base class
    hr = CBaseInputPin::Inactive();

    // if it is a VP connection, this error is ok
    if ( hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Inactive failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// transition from pause to run state
HRESULT CVPMInputPin::Run(REFERENCE_TIME tStart)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::Run")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    m_bDontFlip = FALSE ;   // need to reset it to do the right things in this session

    {
        // tell the videoport object
        hr = m_pIVPObject->Run(tStart);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Run() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    
    // call the base class
    hr = CBaseInputPin::Run(tStart);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Run failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    // TBD: figure out ... stream time
    m_rtNextSample = 0;
    m_rtLastRun = tStart;

    // just start the src video running, we'll have an output image when we get a sample
    hr = InitVideo();

CleanUp:
    m_trLastFrame = -1;
    return hr;
}

// transition from run to pause state
HRESULT CVPMInputPin::RunToPause(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::RunToPause")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // only if a vp pin
    if( m_pIVPObject ) {
        // tell the videoport object
        hr = m_pIVPObject->RunToPause();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->RunToPause() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    
CleanUp:
    return hr;
}



// signals start of flushing on the input pin
HRESULT CVPMInputPin::BeginFlush(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::BeginFlush")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    m_hEndOfStream = 0;

    if (m_bFlushing)
    {
        return E_FAIL;
    }

    // if the conection is VideoPort or IOverlay, we do not care about flushing
    
    // call the base class
    hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::BeginFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// signals end of flushing on the input pin
HRESULT CVPMInputPin::EndFlush(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EndFlush")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (!m_bFlushing)
    {
        return E_FAIL;
    }

    // if the conection is VideoPort or IOverlay, we do not care about flushing
    

    // call the base class
    hr = CBaseInputPin::EndFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::EndFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// Send a quality message if required - this is the hack version
// that just passes the lateness
void CVPMInputPin::DoQualityMessage()
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (m_pVPMFilter.m_State == State_Running &&
        SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID)
    {
        CRefTime CurTime;
        if (S_OK == m_pVPMFilter.StreamTime(CurTime))
        {
            const REFERENCE_TIME tStart = SampleProps()->tStart;
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = CurTime > tStart ? Flood : Famine;
            msg.Late = CurTime - tStart;
            msg.TimeStamp = tStart;
            PassNotify(msg);

            m_trLastFrame = CurTime;
        }
    }
}

// called when the upstream pin delivers us a sample
HRESULT CVPMInputPin::Receive(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;
    BOOL bNeedToFlipOddEven = FALSE;
    BOOL bDisplayingFields = FALSE;
    DWORD dwTypeSpecificFlags = 0;
    LPDIRECTDRAWSURFACE7 pPrimarySurface = NULL;

    AMTRACE((TEXT("CVPMInputPin::Receive")));

    // a videoport connection does not receive samples so bail out
    {
        hr = VFW_E_NOT_SAMPLE_CONNECTION;
        goto CleanUp;
    }

    
CleanUp:
    return hr;
}


HRESULT CVPMInputPin::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    ASSERT( !"OnReceiveFirstSample" );
    return NOERROR;
}

HRESULT CVPMInputPin::InitVideo()
{
    HRESULT hr = m_pIVPObject->StartVideo( &m_WinInfo );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->StartVideo failed, hr = 0x%x"), hr));
    }
    return hr;
}

// this function just tells whether each sample consists of one or two fields
static HRESULT SetTypeSpecificFlags(IMediaSample *pSample, DWORD dwTypeSpecificFlags )
{
    IMediaSample2 *pSample2 = NULL;

    /* Check for IMediaSample2 */
    HRESULT hr = pSample->QueryInterface(IID_IMediaSample2, (void **)&pSample2);
    if (SUCCEEDED(hr)) {
        AM_SAMPLE2_PROPERTIES SampleProps;
        hr = pSample2->GetProperties(sizeof(SampleProps), (PBYTE)&SampleProps);
        if( SUCCEEDED( hr )) {
            SampleProps.dwTypeSpecificFlags = dwTypeSpecificFlags;
            hr = pSample2->SetProperties(sizeof(SampleProps), (PBYTE)&SampleProps);
        }
        pSample2->Release();
    }
    return hr;
}

static REFERENCE_TIME ScaleMicroToRefTime( DWORD dwMicroseconds )
{
    // Reference time is in 100 ns = 0.1us, so multiply by 10
    ASSERT( 10*1000000 == UNITS );

    switch( dwMicroseconds ) {
    case 16667:
    case 16666: // 60hz
        return 166667;
    case 16683: // 59.94hz
        return 166834;
    case 20000: // 50hz PAL
        return REFERENCE_TIME(dwMicroseconds)*10;

    default:
        ASSERT( !"Missing ref scale" );
        return REFERENCE_TIME(dwMicroseconds)*10;
    }
}

HRESULT CVPMInputPin::DoRenderSample(IMediaSample* pSample, LPDIRECTDRAWSURFACE7 pDDDestSurface, const DDVIDEOPORTNOTIFY& notify,
                                      const VPInfo& vpInfo )
{
    if( !pDDDestSurface ) {
        return E_INVALIDARG;
    }

    AMTRACE((TEXT("CVPMInputPin::DoRenderSample")));

    CAutoLock cLock(&m_pVPMFilter.GetReceiveLock());

    HRESULT hr = S_OK;
    if( SUCCEEDED( hr )) {
        hr = m_pIVPObject->CallUpdateSurface( notify.dwSurfaceIndex, pDDDestSurface );
        if( SUCCEEDED( hr )) {
            REFERENCE_TIME rtStart = m_rtNextSample; // for debugging, assume continuous

            hr = m_pVPMFilter.GetRefClockTime( &rtStart );
            ASSERT( SUCCEEDED( hr ));

            // make time relative to last run time, i.e. timestamps after run begin at 0
            rtStart -= m_rtLastRun;

            // get the actual time
            REFERENCE_TIME rtInterval = ScaleMicroToRefTime( vpInfo.vpDataInfo.dwMicrosecondsPerField );

            // now set the field info
            DWORD dwTypeFlags=0;

#ifdef DEBUG
            static bool checked=false;
#endif
            switch( vpInfo.mode ) {
                case AMVP_MODE_BOBNONINTERLEAVED:
                    switch( notify.lField ) {
                    case 0:
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                        break;

                    case 1:
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD2;
                        break;

                    case -1:
#ifdef DEBUG
                        if( !checked ) {
                            ASSERT( !"Video driver doesn't known field for sample, VPM assuming Field1" );
                            checked=true;
                        }
#endif
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                        break;

                    default:
#ifdef DEBUG
                        if( !checked ) {
                            ASSERT( !"Bogus field value returned by video driver for sample, assuming Field1" );
                            checked=true;
                        }
#endif
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                        break;
                    }
                    break;
                case AMVP_MODE_BOBINTERLEAVED:
                    if( !vpInfo.vpDataInfo.bFieldPolarityInverted ) {           // Device inverts the polarity by default
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1FIRST;
                    }
                    rtInterval *= 2;    // 2 fields
                    break;
                case AMVP_MODE_WEAVE:
                    dwTypeFlags = AM_VIDEO_FLAG_WEAVE;
                    rtInterval *= 2;    // 2 fields
                    break;
                case AMVP_MODE_SKIPEVEN:
                    dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                    break;
                case AMVP_MODE_SKIPODD:
                    dwTypeFlags = AM_VIDEO_FLAG_FIELD2;
                    break;
                default:
                    break;
            }

            REFERENCE_TIME rtStop = rtStart+rtInterval;
            // set flags & timestamps
            hr = SetTypeSpecificFlags( pSample, dwTypeFlags);

            hr = pSample->SetTime(&rtStart, &rtStop);
            // assume next sample comes immediately afterwards
            m_rtNextSample += rtInterval;
        }
    }
    return hr;
}

HRESULT CVPMInputPin::StartVideo()
{
    HRESULT hr = m_pIVPObject->StartVideo( &m_WinInfo );
    ASSERT( SUCCEEDED( hr ));

    if (FAILED(hr))
    {

        DbgLog((LOG_ERROR, 0,  TEXT("InPin::StartVideo() failed, hr = %d"), hr & 0xffff));
    } else {
        // hack for now, force a new dest recalc
        SetRect( &m_WinInfo.DestRect, 0,0,0,0);
    }
    return hr;
}

// signals end of data stream on the input pin
STDMETHODIMP CVPMInputPin::EndOfStream(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EndOfStream")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    if (m_hEndOfStream) {
        EXECUTE_ASSERT(SetEvent(m_hEndOfStream));
        return S_OK;
    }

    // Make sure we're streaming ok

    hr = CheckStreaming();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckStreaming() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

   {
        // Pass EOS to the filter graph
        hr = m_pVPMFilter.EventNotify(m_dwPinId, EC_COMPLETE, S_OK, 0);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.EventNotify failed, hr = 0x%x"), hr));
        }
    }
    

CleanUp:
    return hr;
}

// signals end of data stream on the input pin
HRESULT CVPMInputPin::EventNotify(long lEventCode, DWORD_PTR lEventParam1, DWORD_PTR lEventParam2)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EventNotify")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // if (lEventCode == EC_OVMIXER_REDRAW_ALL || lEventCode == EC_REPAINT)
    // {
    //     m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
    //     goto CleanUp;
    // }

    // WARNING : we are assuming here that the input pin will be the first pin to be created
    if (lEventCode == EC_COMPLETE && m_dwPinId == 0)
    {
        m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        goto CleanUp;
    }

    if (lEventCode == EC_ERRORABORT)
    {
        m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        m_bRuntimeNegotiationFailed = TRUE;
        goto CleanUp;
    }

    if (lEventCode == EC_STEP_COMPLETE) {
        m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        goto CleanUp;
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* GetCaptureInfo
*
*
*
* History:
* 3/12/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::GetCaptureInfo(
    BOOL *lpCapturing,
    DWORD *lpdwWidth,
    DWORD *lpdwHeight,
    BOOL *lpInterleave
    )

{
    AMTRACE((TEXT("CVPMInputPin::GetCaptureInfo")));

    HRESULT hr = NOERROR;
    IKsPropertySet *pIKsPropertySet = NULL;
    DWORD dwVal[2], dwBytesReturned = 0;

    *lpCapturing = FALSE;

    if (!m_Connected) {

        DbgLog((LOG_TRACE, 1, TEXT("Input pin not connected!!")));
        hr = E_FAIL;
        goto CleanUp;
    }

#if defined(DEBUG)
    else {
        PIN_INFO PinInfo;
        hr = m_Connected->QueryPinInfo(&PinInfo);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE, 1, TEXT("Up stream pin name %ls"), PinInfo.achName));
            PinInfo.pFilter->Release();
        }
    }
#endif

    hr = m_Connected->QueryInterface(IID_IKsPropertySet,
                                     (void**)&pIKsPropertySet);
    if (SUCCEEDED(hr))
    {
        ASSERT(pIKsPropertySet);

        hr = pIKsPropertySet->Set(
                    PROPSETID_ALLOCATOR_CONTROL,
                    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
                    NULL, 0,
                    lpInterleave, sizeof(*lpInterleave));

        if (SUCCEEDED(hr)) {
            hr = pIKsPropertySet->Get(
                        PROPSETID_ALLOCATOR_CONTROL,
                        AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE,
                        NULL, 0,
                        lpInterleave, sizeof(*lpInterleave), &dwBytesReturned);

            if (FAILED(hr) || dwBytesReturned != sizeof(*lpInterleave)) {
                *lpInterleave = FALSE;
            }
        }
        else {
            *lpInterleave = FALSE;
        }


        hr = pIKsPropertySet->Get(
                    PROPSETID_ALLOCATOR_CONTROL,
                    KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,
                    NULL, 0, dwVal, sizeof(dwVal), &dwBytesReturned);

        DbgLog((LOG_TRACE, 2,
                TEXT("pIKsPropertySet->Get(")
                TEXT("PROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE),\n")
                TEXT("\thr = 0x%x, dwVal[0] == %d, dwVal[1] == %d, ")
                TEXT("dwBytesReturned == %d"),
                hr, dwVal[0], dwVal[1], dwBytesReturned));


        // if the decoder supports this property then we are capturing
        // and the intended capturing is size is given by
        // dwVal[0] and dwVal[1]
        //
        if (SUCCEEDED(hr) && dwBytesReturned == sizeof(dwVal))
        {
            *lpCapturing = TRUE;
            *lpdwWidth = dwVal[0];
            *lpdwHeight = dwVal[1];

            DbgLog((LOG_TRACE, 1,
                    TEXT("We are CAPTURING, intended size (%d, %d) interleave = %d"),
                    dwVal[0], dwVal[1], *lpInterleave));
        }

        pIKsPropertySet->Release();
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* GetDecimationUsage
*
*
*
* History:
* Thu 07/15/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::GetDecimationUsage(
    DECIMATION_USAGE *lpdwUsage
    )
{
    return m_pVPMFilter.QueryDecimationUsage(lpdwUsage);
}


// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVPMInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::GetAllocator")));

    if (!ppAllocator)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppAllocator is NULL")));
        hr = E_POINTER;
        goto CleanUp;
    }

    {
        CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

        // if vp connection, don't return any allocator
        {
            *ppAllocator = NULL;
            hr = VFW_E_NO_ALLOCATOR;
            goto CleanUp;
        }

        
    }

CleanUp:
    return hr;
} // GetAllocator

// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVPMInputPin::NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::NotifyAllocator")));

    if (!pAllocator)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppAllocator is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

        // if vp connection, don't care
        {
            goto CleanUp;
        }
    }

CleanUp:
    return hr;
} // NotifyAllocator

HRESULT CVPMInputPin::OnAlloc(CDDrawMediaSample **ppSampleList, DWORD dwSampleCount)
{
    HRESULT hr = NOERROR;
    DWORD i;
    LPDIRECTDRAWSURFACE7 pDDrawSurface = NULL, pBackBuffer = NULL;
    DDSCAPS ddSurfaceCaps;
    DWORD dwDDrawSampleSize = 0;
    BITMAPINFOHEADER *pHeader = NULL;
    DIBDATA DibData;

    AMTRACE((TEXT("CVPMInputPin::OnAlloc")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    ASSERT(IsConnected());

    // get the image size
    {
        CMediaType mtNew;
        hr = m_pIVPObject->CurrentMediaType( &mtNew );
        if( FAILED( hr )) {
            goto CleanUp;
        }
        pHeader = VPMUtil::GetbmiHeader(&mtNew);
        if ( ! pHeader )
        {
            hr = E_FAIL;
            goto CleanUp;
        }
        dwDDrawSampleSize = pHeader->biSizeImage;
    }
    ASSERT(dwDDrawSampleSize > 0);

    if (!ppSampleList)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppSampleList is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    for (i = 0; i < dwSampleCount; i++)
    {
        if (!ppSampleList[i])
        {
            DbgLog((LOG_ERROR, 1, TEXT("ppSampleList[%d] is NULL"), i));
            hr = E_INVALIDARG;
            goto CleanUp;
        }

        hr = ppSampleList[i]->SetDDrawSampleSize(dwDDrawSampleSize);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,  TEXT("ppSampleList[%d]->SetSampleSize failed, hr = 0x%x"), i, hr));
            goto CleanUp;
        }

        
    }  // end of for (i < dwSampleCount) loop

CleanUp:
    return hr;
}

// sets the pointer to directdraw
HRESULT CVPMInputPin::OnGetBuffer(IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
                                 REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
    HRESULT hr = NOERROR;
    CDDrawMediaSample *pCDDrawMediaSample = NULL;
    LPDIRECTDRAWSURFACE7 pBackBuffer = NULL;
    DDSURFACEDESC ddSurfaceDesc;
    BOOL bWaitForDraw = FALSE;
    BOOL bPalettised = FALSE;

    AMTRACE((TEXT("CVPMInputPin::OnGetBuffer")));

    // not valid for videoport
    ASSERT( FALSE ) ;


    return hr;
}

// In case of flipping surfaces, gets the back buffer
HRESULT CVPMInputPin::OnReleaseBuffer(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::OnReleaseBuffer")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    
    return hr;
}

#if 0
/*****************************Private*Routine******************************\
* GetUpstreamFilterName
*
*
*
* History:
* Tue 11/30/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::GetUpstreamFilterName(
    TCHAR* FilterName
    )
{
    PIN_INFO PinInfo;

    if (!m_Connected)
    {
        return VFW_E_NOT_CONNECTED;
    }

    HRESULT hr = m_Connected->QueryPinInfo(&PinInfo);
    if (SUCCEEDED(hr))
    {
        FILTER_INFO FilterInfo;
        hr = PinInfo.pFilter->QueryFilterInfo(&FilterInfo);
        if (SUCCEEDED(hr))
        {
#ifdef UNICODE
            wcscpy( FilterName, FilterInfo.achName );
#else
            wsprintf(FilterName, TEXT("%ls"), FilterInfo.achName);
#endif
            if (FilterInfo.pGraph)
            {
                FilterInfo.pGraph->Release();
            }
        }
        PinInfo.pFilter->Release();
    }

    return hr;
}
#endif

HRESULT CVPMInputPin::CreateDDrawSurface(CMediaType *pMediaType, DWORD *pdwMaxBufferCount, LPDIRECTDRAWSURFACE7 *ppDDrawSurface)
{
    HRESULT hr = NOERROR;
    DDSURFACEDESC2 SurfaceDesc;
    DWORD dwInterlaceFlags = 0, dwTotalBufferCount = 0, dwMinBufferCount = 0;
    DDSCAPS ddSurfaceCaps;
    BITMAPINFOHEADER *pHeader;
    FOURCCMap amFourCCMap(pMediaType->Subtype());

   
    AMTRACE((TEXT("CVPMInputPin::CreateDDrawSurface")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    LPDIRECTDRAW7 pDirectDraw = m_pVPMFilter.GetDirectDraw();
    ASSERT(pDirectDraw);

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!ppDDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppDDrawSurface is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// this function is used to restore the ddraw surface. In the videoport case, we just recreate
// the whole thing from scratch.
HRESULT CVPMInputPin::RestoreDDrawSurface()
{
    HRESULT hr = NOERROR;

    {
        // stop the video
        m_pIVPObject->Inactive();
        // don't have to give up the IVPConfig interface here
        m_pIVPObject->BreakConnect(TRUE);
        // redo the connection process
        hr = m_pIVPObject->CompleteConnect(NULL, TRUE);
    }

    return hr;
}

HRESULT CVPMInputPin::GetSourceAndDest(RECT *prcSource, RECT *prcDest, DWORD *dwWidth, DWORD *dwHeight)
{
    {
        m_pIVPObject->GetRectangles(prcSource, prcDest);
    }
    

    CMediaType mt;
    HRESULT hr = CurrentMediaType(&mt);

    if (SUCCEEDED(hr))
    {
        BITMAPINFOHEADER *pHeader = VPMUtil::GetbmiHeader(&mt);
        if ( ! pHeader )
        {
            hr = E_FAIL;
        }
        else
        {
            *dwWidth = abs(pHeader->biWidth);
            *dwHeight = abs(pHeader->biHeight);
        }
    }

    return hr;
}

STDMETHODIMP CVPMInputPin::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData,
                              LPVOID pPropData, DWORD cbPropData)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    return E_PROP_SET_UNSUPPORTED ;
}


STDMETHODIMP CVPMInputPin::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData,
                              LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    return E_PROP_SET_UNSUPPORTED;
}


STDMETHODIMP CVPMInputPin::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (AMPROPSETID_Pin == guidPropSet)
    {
        if (AMPROPERTY_PIN_CATEGORY != dwPropID && AMPROPERTY_PIN_MEDIUM != dwPropID )
            return E_PROP_ID_UNSUPPORTED ;

        if (pTypeSupport)
                *pTypeSupport = KSPROPERTY_SUPPORT_GET ;
        return S_OK;
    }
    return E_PROP_SET_UNSUPPORTED ;
}


STDMETHODIMP CVPMInputPin::KsQueryMediums(PKSMULTIPLE_ITEM* pMediumList)
{
    PKSPIN_MEDIUM pMedium;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    *pMediumList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pMediumList) + sizeof(*pMedium)));
    if (!*pMediumList)
    {
        return E_OUTOFMEMORY;
    }
    (*pMediumList)->Count = 1;
    (*pMediumList)->Size = sizeof(**pMediumList) + sizeof(*pMedium);
    pMedium = reinterpret_cast<PKSPIN_MEDIUM>(*pMediumList + 1);
    pMedium->Set   = m_Medium.Set;
    pMedium->Id    = m_Medium.Id;
    pMedium->Flags = m_Medium.Flags;

    // The following special return code notifies the proxy that this pin is
    // not available as a kernel mode connection
    return S_FALSE;
}


STDMETHODIMP CVPMInputPin::KsQueryInterfaces(PKSMULTIPLE_ITEM* pInterfaceList)
{
    PKSPIN_INTERFACE    pInterface;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    *pInterfaceList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pInterfaceList) + sizeof(*pInterface)));
    if (!*pInterfaceList)
    {
        return E_OUTOFMEMORY;
    }
    (*pInterfaceList)->Count = 1;
    (*pInterfaceList)->Size = sizeof(**pInterfaceList) + sizeof(*pInterface);
    pInterface = reinterpret_cast<PKSPIN_INTERFACE>(*pInterfaceList + 1);
    pInterface->Set = KSINTERFACESETID_Standard;
    pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
    pInterface->Flags = 0;
    return NOERROR;
}

STDMETHODIMP CVPMInputPin::KsGetCurrentCommunication(KSPIN_COMMUNICATION* pCommunication, KSPIN_INTERFACE* pInterface, KSPIN_MEDIUM* pMedium)
{
    HRESULT hr = NOERROR;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (!m_bStreamingInKernelMode)
        hr = S_FALSE;

    if (pCommunication != NULL)
    {
        *pCommunication = m_Communication;
    }
    if (pInterface != NULL)
    {
        pInterface->Set = KSINTERFACESETID_Standard;
        pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
        pInterface->Flags = 0;
    }
    if (pMedium != NULL)
    {
        *pMedium = m_Medium;
    }
    return hr;
}

/******************************Public*Routine******************************\
* DynamicQueryAccept
*
* Do you accept this type change in your current state?
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::DynamicQueryAccept(
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("CVPMInputPin::DynamicQueryAccept")));
    CheckPointer(pmt, E_POINTER);

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    //
    // I want CheckMedia type to behave as though we aren't connected to
    // anything yet - hence the messing about with m_bConnected.
    //
    CMediaType cmt(*pmt);
    BOOL bConnected = m_bConnected;
    m_bConnected = FALSE;
    HRESULT  hr = CheckMediaType(&cmt);
    m_bConnected = bConnected;

    return hr;
}

/******************************Public*Routine******************************\
* NotifyEndOfStream
*
*
* Set event when EndOfStream receive - do NOT pass it on
* This condition is cancelled by a flush or Stop
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::NotifyEndOfStream(
    HANDLE hNotifyEvent
    )
{
    AMTRACE((TEXT("CVPMInputPin::NotifyEndOfStream")));
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    m_hEndOfStream = hNotifyEvent;
    return S_OK;
}

/******************************Public*Routine******************************\
* IsEndPin
*
* Are you an 'end pin'
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::IsEndPin()
{
    AMTRACE((TEXT("CVPMInputPin::IsEndPin")));
    return S_OK;
}

/******************************Public*Routine******************************\
* DynamicDisconnect
*
* Disconnect while running
*
* History:
* Wed 2/7/1999 - SyonB - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::DynamicDisconnect()
{
    AMTRACE((TEXT("CVPMInputPin::DynamicDisconnect")));
    CAutoLock l(m_pLock);
    return CBaseInputPin::DisconnectInternal();
}

HRESULT CVPMInputPin::GetAllOutputFormats( const PixelFormatList** ppList )
{
    HRESULT hr;
    CAutoLock l(m_pLock);
    if (IsConnected() ) {
        hr = m_pIVPObject->GetAllOutputFormats( ppList );
    } else {
        hr = VFW_E_NOT_CONNECTED;
    }
    return hr;
}

HRESULT CVPMInputPin::GetOutputFormat( DDPIXELFORMAT* pFormat )
{
    HRESULT hr;
    CAutoLock l(m_pLock);
    if (IsConnected() ) {
        hr = m_pIVPObject->GetOutputFormat( pFormat );
    } else {
        hr = VFW_E_NOT_CONNECTED;
    }
    return hr;
}

HRESULT CVPMInputPin::SetVideoPortID( DWORD dwIndex )
{
    HRESULT hr = S_OK;
    CAutoLock l(m_pLock);
    if (m_pIVPObject ) {
        hr = m_pIVPObject->SetVideoPortID( dwIndex );
    }
    return hr;
}

HRESULT CVPMInputPin::InPin_GetVPInfo( VPInfo* pVPInfo )
{
    HRESULT hr = E_FAIL;

	// Private: must hold streaming lock
    CAutoLock l(&m_pVPMFilter.GetReceiveLock());
    if (m_pIVPInfo ) {
        hr = m_pIVPInfo->GetVPDataInfo( &pVPInfo->vpDataInfo );
        if( SUCCEEDED( hr )) {
            hr = m_pIVPInfo->GetVPInfo( &pVPInfo->vpInfo );
        }
        if( SUCCEEDED( hr )) {
            hr = m_pIVPObject->GetMode( &pVPInfo->mode );
        }
    }
    return hr;
}

LPDIRECTDRAW7 CVPMInputPin::GetDirectDraw()
{
    return m_pVPMFilter.GetDirectDraw();
}

const DDCAPS* CVPMInputPin::GetHardwareCaps()
{
    return m_pVPMFilter.GetHardwareCaps();
}

HRESULT CVPMInputPin::SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP )
{
    return m_pVPMFilter.SignalNewVP( pVP );
}

//==========================================================================
HRESULT CVPMInputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::GetMediaType")));

    HRESULT hr = m_pIVPObject->GetMediaType(iPosition, pmt);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmthread.h ===
// Copyright (c) 1997 - 2000  Microsoft Corporation.  All Rights Reserved.
#ifndef _CVPMThread
#define _CVPMThread

class CVPMFilter;
class CAMEvent;
struct VPNotifyData;

class CVPMThread
{
public:
    CVPMThread( CVPMFilter* pFilter );
    ~CVPMThread();

    HRESULT Run();
    HRESULT Pause();
    HRESULT Stop();
    HRESULT SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP );

    static DWORD WINAPI StaticThreadProc(LPVOID);

protected:
    virtual DWORD   ThreadProc();

private:
    void            ProcessEvents( LPDDVIDEOPORTNOTIFY pNotify);

    HRESULT         AdvanceTimer();

    HANDLE          m_hThread;
    DWORD           m_dwThreadID;

    CVPMFilter*     m_pFilter;
    IReferenceClock*    m_pClock;
    bool            m_fProcessFrames;   // nonzero means process frames, zero means do not.
    DWORD           m_dwCount;
    VPNotifyData*   m_pVPData;

    // mini client server message queue
    struct Message {
        enum Type {
            kVP,
            kEndThread,
            kGraphState
        };
                    Message( Type type )
                    : m_Type( type )
                    {}
        virtual     ~Message() {};
        void        Reply( HRESULT hr );

        Message*    m_pNext;
        CAMEvent    m_eReply;
        HRESULT     m_hrResult;

        Type        m_Type;

    };
    struct MsgQueue: public CCritSec
    {
        MsgQueue();
        CAMEvent        m_ePost;
        Message*        m_pMsgList;

        void            Insert( Message* pMessage );
        Message*        Remove();
    } m_MsgQueue;

    struct VPMessage: public Message
    {
        VPMessage( LPDIRECTDRAWVIDEOPORT pVP )
        : Message( kVP )
        , m_pVP( pVP )
        {}
        LPDIRECTDRAWVIDEOPORT   m_pVP;
    };

    struct EndThreadMessage: public Message
    {
        EndThreadMessage()
        : Message( kEndThread )
        {};
    };

    struct GraphStateMessage: public Message
    {
        GraphStateMessage( FILTER_STATE fs )
        : Message( kGraphState )
        , m_state( fs )
        {};
        FILTER_STATE    m_state;
    };

    HRESULT         Post( Message* pMessage );
private:
    HRESULT ProcessMessage( Message* pMessage, bool* pfQuit );
    HRESULT ProcessVPMsg( VPMessage* pVPMsg );
    HRESULT ProcessGraphStateMsg( GraphStateMessage* pStateMsg );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpmutil.h ===
/******************************Module*Header*******************************\
* Module Name: VPMUtil.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __VPMUtil__h
#define __VPMUtil__h

struct VPWININFO;

// global utility functions for the VPM
struct tagVIDEOINFOHEADER2;
typedef struct tagVIDEOINFOHEADER2 VIDEOINFOHEADER2;
#include <dvp.h>

namespace VPMUtil
{
    int             GetRegistryDword(HKEY hk, const TCHAR *pKey, int iDefault);
    int             GetPropPagesRegistryDword( int iDefault );
    LONG            SetRegistryDword( HKEY hk, const TCHAR *pKey, int iRet );
                                   
    BITMAPINFOHEADER* GetbmiHeader( CMediaType *pMediaType); 
    const BITMAPINFOHEADER* GetbmiHeader(const CMediaType *pMediaType);

    HRESULT         GetPictAspectRatio(const CMediaType& pMediaType, DWORD *pdwPictAspectRatioX, DWORD *pdwPictAspectRatioY);
    const DWORD*    WINAPI GetBitMasks(const CMediaType *pMediaType);
    const BYTE*     GetColorInfo(const CMediaType *pMediaType);
    HRESULT         GetSrcRectFromMediaType(const CMediaType& pMediaType, RECT *pRect);
    HRESULT         GetDestRectFromMediaType(const CMediaType& pMediaType, RECT *pRect);

    AM_MEDIA_TYPE*  AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource, GUID formattype);
    AM_MEDIA_TYPE*  ConvertSurfaceDescToMediaType(const LPDDSURFACEDESC pSurfaceDesc, BOOL bInvertSize, CMediaType cMediaType);
    HRESULT         IsPalettised(const CMediaType& mediaType, BOOL *pPalettised);
    HRESULT         GetInterlaceFlagsFromMediaType(const CMediaType& mediaType, DWORD *pdwInterlaceFlags);

    HRESULT         CreateDIB(LONG lSize, BITMAPINFO *pBitMapInfo, DIBDATA *pDibData);
    HRESULT         DeleteDIB(DIBDATA *pDibData);
    void            FastDIBBlt(DIBDATA *pDibData, HDC hTargetDC, HDC hSourceDC, RECT *prcTarget, RECT *prcSource);
    void            SlowDIBBlt(BYTE *pDibBits, BITMAPINFOHEADER *pHeader, HDC hTargetDC, RECT *prcTarget, RECT *prcSource);

    // decimation
    BOOL            IsDecimationNeeded( DWORD ScaleFactor );

    DWORD           GetCurrentScaleFactor( const VPWININFO& VPWinInfo,
                                   DWORD* lpxScaleFactor = NULL,
                                   DWORD* lpyScaleFactor = NULL);

    VIDEOINFOHEADER2* GetVideoInfoHeader2(CMediaType *pMediaType);
    const VIDEOINFOHEADER2* GetVideoInfoHeader2(const CMediaType *pMediaType);

    BOOL            EqualPixelFormats( const DDPIXELFORMAT& lpFormat1, const DDPIXELFORMAT& lpFormat2);

    HRESULT         FindVideoPortCaps( IDDVideoPortContainer* pVPContainer, LPDDVIDEOPORTCAPS pVPCaps, DWORD dwVideoPortId );
    HRESULT         FindVideoPortCaps( LPDIRECTDRAW7 pDirectDraw, LPDDVIDEOPORTCAPS pVPCaps, DWORD dwVideoPortId );

    void            FixupVideoInfoHeader2( VIDEOINFOHEADER2 *pVideoInfo, DWORD dwComppression, int nBitCount );
    void            InitVideoInfoHeader2( VIDEOINFOHEADER2 *pVideoInfo );
    VIDEOINFOHEADER2* SetToVideoInfoHeader2( CMediaType* pmt, DWORD dwExtraBytes = 0);
};

template <typename T>
__inline void ZeroStruct(T& t)
{
    ZeroMemory(&t, sizeof(t));
}
template <typename T>
__inline void ZeroArray(T* pArray, unsigned uCount)
{
    ZeroMemory(pArray, sizeof(pArray[0])*uCount);
}
template <typename T>
__inline void CopyArray(T* pDest, const T* pSrc, unsigned uCount)
{
    memcpy( pDest, pSrc, sizeof(pDest[0])*uCount);
}
template <typename T>
__inline void INITDDSTRUCT(T& dd)
{
    ZeroStruct(dd);
    dd.dwSize = sizeof(dd);
}

template<typename T>
__inline void RELEASE( T* &p )
{
    if( p ) {
        p->Release();
        p = NULL;
    }
}

#ifndef CHECK_HR
    #define CHECK_HR(expr) do { if (FAILED(expr)) __leave; } while(0);
#endif

#endif //__VPMUtil__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\wm\window.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Implements the CVMRVideoWindow class, Anthony Phillips, January 1995

#include <streams.h>
#include <windowsx.h>
#include <limits.h>
#include <measure.h>
#include <mmsystem.h>
#include <dvdmedia.h> // VIDEOINFO2
#include "..\video\VMRenderer.h"
#include "vmrwinctrl.h"
#include "vmrwindow.h"

//  When we are constructed we create a window and a separate thread to look
//  after it. We also create two device contexts for the window, one for the
//  window client area and another compatible with this for offscreen drawing.
//  Only source formats that match the display device format will be accepted,
//  other formats have to be converted through colour transformation filters.
//  The only exception to this being true colour devices which will normally
//  handle four and eight bit palettised images very efficiently.
//
//  When a connection has been made the output pin may ask us for an allocator
//  We provide an allocator that gives out one or more memory buffers that are
//  shared with GDI. These are created through CreateDIBSection. That requires
//  us to give it the connected source media type format BITMAPINFO structure.
//
//  When we come to rendering the images we have two separate code paths, one
//  for samples allocated with our shared memory allocator and another for the
//  normal memory buffers. As it turns out the shared memory allocator does
//  only marginally faster. However our memory allocator can also return DCI
//  and DirectDraw surfaces which can be drawn by display card hardware. DCI
//  and DirectDraw buffers may still need drawing (although not always as
//  in the case of primary surfaces) and if they do they also get sent to us
//  for synchronising. Our Render method will call the DirectDraw object if
//  it sees a DirectDraw sample, otherwise it passes it to our draw object.
//
//  For shared memory buffers we select the DIB data into the offscreen device
//  context which will also always have the source palette realized in it then
//  we BitBlt from that device context into the window device context. For the
//  normal non shared memory samples we simply call SetDIBitsToDevice and also
//  StretchDIBitsToDevice), GDI first maps the buffer into it's address space
//  (thereby making the buffer shared) and then copies it to the screen.


// Constructor

#pragma warning(disable:4355)

CVMRVideoWindow::CVMRVideoWindow(CVMRFilter *pRenderer,     // The owning renderer
                           CCritSec *pLock,           // Object to lock with
                           LPUNKNOWN pUnk,            // Owning object
                           HRESULT *phr) :            // OLE return code

    CVMRBaseControlWindow(pRenderer,pLock,NAME("Window object"),pUnk,phr),
    CVMRBaseControlVideo(pRenderer,pLock,NAME("Window object"),pUnk,phr),
    m_pRenderer(pRenderer),
    m_pInterfaceLock(pLock),
    m_bTargetSet(FALSE),
    m_pFormat(NULL),
    m_FormatSize(0)
{
    ASSERT(m_pRenderer);
    ASSERT(m_pInterfaceLock);

    // Create a default arrow cursor

    m_hCursor = (HCURSOR) LoadImage((HINSTANCE) NULL,
                                    MAKEINTRESOURCE(OCR_ARROW_DEFAULT),
		                    IMAGE_CURSOR,0,0,0);
}


// Must destroy the window before this destructor

CVMRVideoWindow::~CVMRVideoWindow()
{
    ASSERT(m_hwnd == NULL);
    ASSERT(m_hdc == NULL);
    ASSERT(m_MemoryDC == NULL);

    DestroyCursor(m_hCursor);
    if (m_pFormat)
	QzTaskMemFree(m_pFormat);
}

// Overriden to say what interfaces we support

STDMETHODIMP CVMRVideoWindow::NonDelegatingQueryInterface(REFIID riid,VOID **ppv)
{
    if (riid == IID_IVideoWindow) {
        return CVMRBaseControlWindow::NonDelegatingQueryInterface(riid,ppv);
    } else {
        ASSERT(riid == IID_IBasicVideo || riid == IID_IBasicVideo2);
        return CVMRBaseControlVideo::NonDelegatingQueryInterface(riid,ppv);
    }
}


HRESULT CVMRVideoWindow::PrepareWindow()
{

    // Register our special private messages
    m_VMRActivateWindow = RegisterWindowMessage(VMR_ACTIVATE_WINDOW);

    // RegisterWindowMessage() returns 0 if an error occurs.
    if (0 == m_VMRActivateWindow) {
        return AmGetLastErrorToHResult();
    }
    return CBaseWindow::PrepareWindow();
}

HRESULT CVMRVideoWindow::ActivateWindowAsync(BOOL fAvtivate)
{
    if (PostMessage(m_hwnd, m_VMRActivateWindow, (WPARAM)fAvtivate, 0)) {
        return S_OK;
    }
    return E_FAIL;
}

// Return the default client rectangle we would like

RECT CVMRVideoWindow::GetDefaultRect()
{
    CAutoLock cWindowLock(&m_WindowLock);

    RECT DefaultRect = {0,0,0,0};
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        LONG cx, cy;
        lpWLControl->GetNativeVideoSize(&cx, &cy, NULL, NULL);
        SetRect(&DefaultRect, 0, 0, cx, cy);
    }

    return DefaultRect;
}


// We are called when the user moves the cursor over the window client area
// If we are fullscreen then we should hide the pointer so that it matches
// the fullscreen renderer behaviour. We also set a default cursor if we're
// DirectDraw overlays as software cursors won't be visible. This means we
// change the cursor as the mouse is moved but at least a cursor is visible

BOOL CVMRVideoWindow::OnSetCursor(LPARAM lParam)
{
    // The base class that implements IVideoWindow looks after a flag that
    // says whether or not the cursor should be hidden. If so we hide the
    // cursor and return TRUE. Otherwise we pass to DefWindowProc to show
    // the cursor as normal. This is used when our window is stretched up
    // fullscreen to imitate the Modex filter that always hides the cursor

    if (IsCursorHidden() == TRUE) {
        SetCursor(NULL);
        return TRUE;
    }

    // Are DirectDraw colour key overlays visible

//  if ((m_pRenderer->m_DirectDraw.InSoftwareCursorMode() == FALSE) ||
//      (*m_pRenderer->m_mtIn.Subtype() == MEDIASUBTYPE_Overlay))
//  {
        if (LOWORD(lParam) == HTCLIENT) {
            SetCursor(m_hCursor);
            return TRUE;
        }
//  }

    return FALSE;
}


// We override the virtual CBaseWindow OnReceiveMessage call to handle more
// of the Windows messages. The base class handles some stuff like WM_CLOSE
// messages amongst others which we are also interested in. We don't need
// to use WM_SIZE and WM_MOVE messages to position source filters through
// IOverlay (with ADVISE_POSITION) as we poll with timers now. This is done
// because as a child window we cannot be guaranteed to see those messages
// Our global hook sends us WM_FREEZE and WM_THAW messages synchronously as
// it detects window changes in the system that might affect our clip list

LRESULT CVMRVideoWindow::OnReceiveMessage(HWND hwnd,         // Window handle
                                       UINT uMsg,         // Message ID
                                       WPARAM wParam,     // First parameter
                                       LPARAM lParam)     // Other parameter
{

    if (uMsg == m_VMRActivateWindow) {

        if (wParam) {
            CBaseWindow::ActivateWindow();
        }
        else {
            CBaseWindow::InactivateWindow();
        }
        return 0;
    }

    switch (uMsg) {

        // Handle cursors when fullscreen and in overlay mode

        case WM_SETCURSOR:

            if (OnSetCursor(lParam) == TRUE) {
                NOTE("Cursor handled");
                return (LRESULT) 0;
            }
            break;

        // We pass on WM_ACTIVATEAPP messages to the filtergraph so that the
        // IVideoWindow plug in distributor can switch us out of fullscreen
        // mode where appropriate. These messages may also be used by the
        // resource manager to keep track of which renderer has the focus

        case WM_ACTIVATEAPP:
        case WM_ACTIVATE:
        case WM_NCACTIVATE:
        case WM_MOUSEACTIVATE:
        {
            BOOL bActive = TRUE;
            IBaseFilter * const pFilter = m_pRenderer;
            switch (uMsg) {
            case WM_ACTIVATEAPP:
            case WM_NCACTIVATE:
                bActive = (BOOL)wParam;
                break;
            case WM_ACTIVATE:
                bActive = LOWORD(wParam) != WA_INACTIVE;
                break;
            }
            NOTE1("Notification of EC_ACTIVATE (%d)",bActive);
            m_pRenderer->NotifyEvent(EC_ACTIVATE,bActive,
                                     (LPARAM) pFilter);
            NOTE("EC_ACTIVATE signalled to filtergraph");

            break;
        }

        // When we detect a display change we send an EC_DISPLAY_CHANGED
        // message along with our input pin. The filtergraph will stop
        // everyone and reconnect our input pin. When being reconnected
        // we can then accept the media type that matches the new display
        // mode since we may no longer be able to draw the current format

        case WM_DISPLAYCHANGE:

            NOTE("Notification of WM_DISPLAYCHANGE");
            {
                IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
                if (lpWLControl) {
                    lpWLControl->DisplayModeChanged();
                }
                return (LRESULT) 0;
            }


        // Timers are used to have DirectDraw overlays positioned

        case WM_TIMER:
#ifdef DEBUG
            if (wParam ==  FRAME_RATE_TIMER) {

                TCHAR WindowText[64];
                int f;
                m_pRenderer->get_AvgFrameRate(&f);
                wsprintf(WindowText,
                         TEXT("ActiveMovie Window: Frame Rate %d.%.2d / Sec"),
                         f / 100, f % 100 );

                SetWindowText(m_hwnd, WindowText);
            }
#endif
            return (LRESULT) 0;

        case WM_ERASEBKGND:

            OnEraseBackground();
            return (LRESULT) 1;


        case WM_MOVE:
            //
            // The old renderer would pass this message onto the
            // base classes which would post a WM_PAINT message to
            // the window.  Unfortunately, the OnPaint message does
            // an BeginPaint/EndPaint call.  This confuses DDraw's
            // clipper resulting in artifacts being left on the screen.
            //
            {
                IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();

                if (lpWLControl) {

                    if (m_pRenderer->NumInputPinsConnected() > 0) {

                        lpWLControl->RepaintVideo(hwnd, NULL);
                    }
                    else {

                        COLORREF clr;
                        lpWLControl->GetBorderColor(&clr);
                        HDC hdc = GetDC(hwnd);
                        if (hdc) {

                            RECT TargetRect;
                            GetClientRect(m_hwnd, &TargetRect);

                            COLORREF BackColour = SetBkColor(hdc, clr);
                            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &TargetRect, NULL, 0, NULL);
                            SetBkColor(hdc, BackColour);
                            ReleaseDC(hwnd, hdc);
                        }
                    }
                }
            }
            return (LRESULT)0;

        case WM_SIZE:

            OnSize(LOWORD(lParam),HIWORD(lParam));
            OnUpdateRectangles();
            return (LRESULT) 0;

        // This tells us some of the window's client area has become exposed
        // If our connected filter is doing overlay work then we repaint the
        // background so that it will pick up the window clip changes. Those
        // filters will probably use an ADVISE_POSITION overlay notification

        case WM_PAINT:

            DoRealisePalette();
            OnPaint();
            return (LRESULT) 0;
    }
    return CBaseWindow::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}


// Used when the palette changes to clear the window

void CVMRVideoWindow::EraseVideoBackground()
{
    NOTE("EraseVideoBackground");
    RECT TargetRect;

    GetTargetRect(&TargetRect);
    COLORREF BackColour = SetBkColor(m_hdc,VIDEO_COLOUR);
    ExtTextOut(m_hdc,0,0,ETO_OPAQUE,&TargetRect,NULL,0,NULL);
    SetBkColor(m_hdc,BackColour);
}


// This erases the background of the video window that does not have any video
// being put in it. During normal processing we ignore paint messages because
// we will soon be putting the next frame over the top of it, however we may
// have the destination rectangle set by the IVideoWindow control interface
// such that there are areas left untouched - this method erases over them
// We must lock the critical section as the control interface may change it

void CVMRVideoWindow::OnEraseBackground()
{
    NOTE("Entering OnErasebackground");

    RECT ClientRect, TargetRect;
    EXECUTE_ASSERT(GetClientRect(m_hwnd,&ClientRect));
    CAutoLock cWindowLock(&m_WindowLock);
    GetTargetRect(&TargetRect);

    // Find that missing region

    HRGN ClientRgn = CreateRectRgnIndirect(&ClientRect);
    HRGN VideoRgn = CreateRectRgnIndirect(&TargetRect);
    HRGN EraseRgn = CreateRectRgn(0,0,0,0);
    HBRUSH hBrush = (HBRUSH) NULL;
    COLORREF Colour;

    if ( ( ! ClientRgn ) || ( ! VideoRgn ) || ( ! EraseRgn ) )
        goto Exit;

    CombineRgn(EraseRgn,ClientRgn,VideoRgn,RGN_DIFF);

    // Create a coloured brush to paint the window

    Colour = GetBorderColour();
    hBrush = CreateSolidBrush(Colour);
    FillRgn(m_hdc,EraseRgn,hBrush);

    // Delete the GDI objects we created
Exit:
    if ( ClientRgn ) DeleteObject( ClientRgn );
    if ( VideoRgn ) DeleteObject( VideoRgn );
    if ( EraseRgn ) DeleteObject( EraseRgn );
    if ( hBrush ) DeleteObject( hBrush );
}


// Initialise the draw object with the changed dimensions, we lock ourselves
// because the destination rectangle can be set via the IVideoWindow control
// interface. If the control interface has set a destination rectangle then
// we don't change it, otherwise we update the rectangle to match the window
// dimensions (in this case the left and top values should always be zero)

BOOL CVMRVideoWindow::OnSize(LONG Width,LONG Height)
{
    NOTE("Entering OnSize");

    CAutoLock cWindowLock(&m_WindowLock);
    if (m_bTargetSet == TRUE) {
        NOTE("Target set");
        return FALSE;
    }

    // Create a target rectangle for the window

    RECT TargetRect = {0,0,Width,Height};
    CBaseWindow::OnSize(Width,Height);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(NULL, &TargetRect);
    }

    return TRUE;
}


// This method handles the WM_CLOSE message

BOOL CVMRVideoWindow::OnClose()
{
    NOTE("Entering OnClose");

    m_pRenderer->SetAbortSignal(TRUE);
    m_pRenderer->NotifyEvent(EC_USERABORT,0,0);
    return CBaseWindow::OnClose();
}



// This is called when we receive a WM_PAINT message

BOOL CVMRVideoWindow::OnPaint()
{
    NOTE("Entering OnPaint");
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(m_hwnd,&ps);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();

    if (lpWLControl) {

        if (m_pRenderer->NumInputPinsConnected() > 0) {
            lpWLControl->RepaintVideo(m_hwnd, hdc);
        }
        else {
            COLORREF clr;
            lpWLControl->GetBorderColor(&clr);

            RECT TargetRect;
            GetClientRect(m_hwnd, &TargetRect);

            COLORREF BackColour = SetBkColor(hdc, clr);
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &TargetRect, NULL, 0, NULL);
            SetBkColor(hdc, BackColour);
        }
    }

    EndPaint(m_hwnd,&ps);
    return TRUE;
}


// The base control video class calls this method when it changes either
// the source or destination rectangles. We update the overlay object as
// so that it notifies the source of the rectangle clip change and then
// invalidate the window so that the video is displayed in the new place

HRESULT CVMRVideoWindow::OnUpdateRectangles()
{
    NOTE("Entering OnUpdateRectangles");
//  m_pRenderer->m_Overlay.NotifyChange(ADVISE_CLIPPING | ADVISE_POSITION);
//  m_pRenderer->m_VideoAllocator.OnDestinationChange();
    PaintWindow(TRUE);
    return NOERROR;
}


// When we call PrepareWindow in our constructor it will call this method as
// it is going to create the window to get our window and class styles. The
// return code is the class name and must be allocated in static storage. We
// specify a normal window during creation although the window styles as well
// as the extended styles may be changed by the application via IVideoWindow

LPTSTR CVMRVideoWindow::GetClassWindowStyles(DWORD *pClassStyles,
                                          DWORD *pWindowStyles,
                                          DWORD *pWindowStylesEx)
{
    *pClassStyles = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT | CS_DBLCLKS;
    *pWindowStyles = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
    *pWindowStylesEx = (DWORD) 0;
    return WindowClassName;
}


// Return the minimum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a minimum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRVideoWindow::GetMinIdealImageSize(long *pWidth,long *pHeight)
{
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    FILTER_STATE State;
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    // Must not be stopped for this to work correctly

    m_pRenderer->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    GetVideoSize(pWidth,pHeight);

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        return lpWLControl->GetMinIdealVideoSize(pWidth, pHeight);
    }

    return S_OK;
}


// Return the maximum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a maximum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRVideoWindow::GetMaxIdealImageSize(long *pWidth,long *pHeight)
{
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    FILTER_STATE State;
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    // Must not be stopped for this to work correctly

    m_pRenderer->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    GetVideoSize(pWidth,pHeight);

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        return lpWLControl->GetMaxIdealVideoSize(pWidth, pHeight);
    }

    return S_OK;
}

STDMETHODIMP
CVMRVideoWindow::GetPreferredAspectRatio(long *plAspectX, long *plAspectY)
{
    if (plAspectX == NULL || plAspectY == NULL) {
        return E_POINTER;
    }

    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetNativeVideoSize(NULL, NULL, plAspectX, plAspectY);
        return S_OK;
    }

    return E_NOTIMPL;
}


// Return a copy of the current image in the video renderer. The base control
// class implements a helper mathod that takes an IMediaSample interface and
// assuming it is a normal linear buffer copies the relevant section of the
// video into the output buffer provided. The method takes into account any
// source rectangle already specified by calling our GetSourceRect function

HRESULT CVMRVideoWindow::GetStaticImage(long *pVideoSize,long *pVideoImage)
{
#if 0
    NOTE("Entering GetStaticImage");
    IMediaSample *pMediaSample;
    RECT SourceRect;

    // Is there an image available

    pMediaSample = m_pRenderer->GetCurrentSample();
    if (pMediaSample == NULL) {
        return E_UNEXPECTED;
    }

    // Check the image isn't a DirectDraw sample

    if (m_pRenderer->m_VideoAllocator.GetDirectDrawStatus() == TRUE) {
        pMediaSample->Release();
        return E_FAIL;
    }

    // Find a scaled source rectangle for the current bitmap

    m_pRenderer->m_DrawVideo.GetSourceRect(&SourceRect);
    SourceRect = m_pRenderer->m_DrawVideo.ScaleSourceRect(&SourceRect);
    VIDEOINFO *pVideoInfo = (VIDEOINFO *) m_pRenderer->m_mtIn.Format();

    // Call the base class helper method to do the work

    HRESULT hr = CopyImage(pMediaSample,        // Buffer containing image
        (VIDEOINFOHEADER *)pVideoInfo,          // Type representing bitmap
                           pVideoSize,          // Size of buffer for DIB
                           (BYTE*) pVideoImage, // Data buffer for output
                           &SourceRect);        // Current source position

    pMediaSample->Release();
    return hr;
#else
    return E_NOTIMPL;
#endif
}


// The IVideoWindow control interface use this to reset the video destination
// We reset the flag that indicates whether we have a destination rectangle
// set explicitly or not, and then initialise the rectangle with the client
// window dimensions. These fields are used by the window thread when it does
// the drawing and also when it processes WM_SIZE messages (hence the lock)

HRESULT CVMRVideoWindow::SetDefaultTargetRect()
{
    CAutoLock cWindowLock(&m_WindowLock);
    RECT TargetRect;

    // Update the draw objects

    EXECUTE_ASSERT(GetClientRect(m_hwnd,&TargetRect));
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(NULL, &TargetRect);
    }

    m_bTargetSet = FALSE;
    return NOERROR;
}


// Return S_OK if using the default target otherwise S_FALSE

HRESULT CVMRVideoWindow::IsDefaultTargetRect()
{
    CAutoLock cWindowLock(&m_WindowLock);
    return (m_bTargetSet ? S_FALSE : S_OK);
}


// This sets the destination rectangle for the real video. The rectangle may
// be larger or smaller than the video window is and may be offset into it as
// well so we rely on the drawing operations to clip (such as the StretchBlt)

HRESULT CVMRVideoWindow::SetTargetRect(RECT *pTargetRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    m_bTargetSet = TRUE;

    // Update the draw objects
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(NULL, pTargetRect);
    }

    return NOERROR;
}


// This complements the SetTargetRect method to return the rectangle in use
// as the destination. If we have had no rectangle explicitly set then we
// will return the client window size as updated in the WM_SIZE messages

HRESULT CVMRVideoWindow::GetTargetRect(RECT *pTargetRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetVideoPosition(NULL, pTargetRect);
    }
    return NOERROR;
}


// Reset the source rectangle to be all the available video

HRESULT CVMRVideoWindow::SetDefaultSourceRect()
{
    CAutoLock cWindowLock(&m_WindowLock);

    RECT SourceRect = GetDefaultRect();

    // Update the draw objects

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(&SourceRect, NULL);
    }

    return NOERROR;
}


// Return S_OK if using the default source otherwise S_FALSE

HRESULT CVMRVideoWindow::IsDefaultSourceRect()
{

    RECT SourceRect;

    // Does the source match the native video size

    RECT VideoRect = GetDefaultRect();
    SIZE VideoSize;

    VideoSize.cx = VideoRect.right - VideoRect.left;
    VideoSize.cy = VideoRect.bottom - VideoRect.top;

    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetVideoPosition(&SourceRect, NULL);

        // Check the coordinates match the video dimensions

        if (SourceRect.right == VideoSize.cx) {
            if (SourceRect.bottom == VideoSize.cy) {
                if (SourceRect.left == 0) {
                    if (SourceRect.top == 0) {
                        return S_OK;
                    }
                }
            }
        }
    }

    return S_FALSE;
}


// This is called when we want to change the section of the image to draw. We
// use this information in the drawing operation calls later on. We must also
// see if the source and destination rectangles have the same dimensions. If
// not then we must stretch during the drawing rather than doing a pixel copy

HRESULT CVMRVideoWindow::SetSourceRect(RECT *pSourceRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(pSourceRect, NULL);
    }
    return NOERROR;
}


// This complements the SetSourceRect method

HRESULT CVMRVideoWindow::GetSourceRect(RECT *pSourceRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetVideoPosition(pSourceRect, NULL);
    }
    return NOERROR;
}


// We must override this to return a VIDEOINFO representing the video format
// The base class cannot call IPin ConnectionMediaType to get this format as
// dynamic type changes when using DirectDraw have the format show the image
// bitmap in terms of logical positions within a frame buffer surface, so a
// video might be returned as 1024x768 pixels, instead of the native 320x240

VIDEOINFOHEADER *CVMRVideoWindow::GetVideoFormat()
{
#if 0
    if (m_FormatSize < (int)m_pRenderer->m_mtIn.FormatLength()) {
        m_FormatSize = m_pRenderer->m_mtIn.FormatLength();
	if (m_pFormat)
	    QzTaskMemFree(m_pFormat);
        m_pFormat = (VIDEOINFOHEADER *)QzTaskMemAlloc(m_FormatSize);
	if (m_pFormat == NULL) {
	    m_FormatSize = 0;
	    return NULL;
	}
    }
    CopyMemory((PVOID)m_pFormat, (PVOID)m_pRenderer->m_mtIn.Format(),
              				m_pRenderer->m_mtIn.FormatLength());
    m_pFormat->bmiHeader.biWidth = m_pRenderer->m_VideoSize.cx;
    m_pFormat->bmiHeader.biHeight = m_pRenderer->m_VideoSize.cy;
    return m_pFormat;
#else
    return 0;
#endif
}

#ifdef DEBUG
void CVMRVideoWindow::StartFrameRateTimer()
{
    SetTimer(m_hwnd, FRAME_RATE_TIMER, 2000, NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpobj.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __VP_OBJECT__
#define __VP_OBJECT__

#include "vpinfo.h"
#include <dvp.h>
#include <vptype.h>

// IVPNotify2
#include <vpnotify.h>

// IVPConfig
#include <vpconfig.h>

// AMVP_MODE
#include <vpinfo.h>

#include <formatlist.h>

// #define EC_OVMIXER_REDRAW_ALL 0x100
// #define EC_UPDATE_MEDIATYPE 0x101

struct VPDRAWFLAGS
{
    BOOL bDoUpdateVideoPort;
    BOOL bDoTryDecimation;
    BOOL bDoTryAutoFlipping;
};

struct VPWININFO
{
    POINT TopLeftPoint;
    RECT SrcRect;
    RECT DestRect;
    RECT SrcClipRect;
    RECT DestClipRect;
};

DECLARE_INTERFACE_(IVideoPortObject, IUnknown)
{
    STDMETHOD (GetDirectDrawVideoPort)(THIS_ LPDIRECTDRAWVIDEOPORT* ppDirectDrawVideoPort ) PURE;
    STDMETHOD (SetObjectLock)       (THIS_ CCritSec* pMainObjLock ) PURE;
    STDMETHOD (SetMediaType)        (THIS_ const CMediaType* pmt ) PURE;
    STDMETHOD (CheckMediaType)      (THIS_ const CMediaType* pmt ) PURE;
    STDMETHOD (GetMediaType)        (THIS_ int iPosition, CMediaType *pMediaType) PURE;
    STDMETHOD (CompleteConnect)     (THIS_ IPin* pReceivePin, BOOL bRenegotiating = FALSE ) PURE;
    STDMETHOD (BreakConnect)        (THIS_ BOOL bRenegotiating = FALSE ) PURE;
    STDMETHOD (Active)              (THIS_ ) PURE;
    STDMETHOD (Inactive)            (THIS_ ) PURE;
    STDMETHOD (Run)                 (THIS_ REFERENCE_TIME tStart ) PURE;
    STDMETHOD (RunToPause)          (THIS_ ) PURE;
    STDMETHOD (CurrentMediaType)    (THIS_ AM_MEDIA_TYPE* pmt ) PURE;
    STDMETHOD (GetRectangles)       (THIS_ RECT* prcSource, RECT* prcDest) PURE;
    STDMETHOD (AttachVideoPortToSurface) (THIS_) PURE;
    STDMETHOD (SignalNewVP) (THIS_) PURE;
    STDMETHOD (GetAllOutputFormats) (THIS_ const PixelFormatList**) PURE;
    STDMETHOD (GetOutputFormat)     (THIS_ DDPIXELFORMAT*) PURE;
    STDMETHOD (StartVideo)          (THIS_ const VPWININFO* pWinInfo ) PURE;
    STDMETHOD (SetVideoPortID)      (THIS_ DWORD dwVideoPortId ) PURE;
    STDMETHOD (CallUpdateSurface)   (THIS_ DWORD dwSourceIndex, LPDIRECTDRAWSURFACE7 pDestSurface ) PURE;
    STDMETHOD (GetMode)             (THIS_ AMVP_MODE* pMode ) PURE;
};


DECLARE_INTERFACE_(IVideoPortControl, IUnknown)
{
    STDMETHOD (EventNotify)(THIS_
                            long lEventCode,
                            DWORD_PTR lEventParam1,
                            DWORD_PTR lEventParam2
                           ) PURE;

    STDMETHOD_(LPDIRECTDRAW7, GetDirectDraw) (THIS_ ) PURE;

    STDMETHOD_(const DDCAPS*, GetHardwareCaps) (THIS_
                                          ) PURE;

    STDMETHOD(GetCaptureInfo)(THIS_
                             BOOL* lpCapturing,
                             DWORD* lpdwWidth,
                             DWORD* lpdwHeight,
                             BOOL* lpInterleaved) PURE;

    STDMETHOD(GetVideoDecimation)(THIS_
                                  IDecimateVideoImage** lplpDVI) PURE;

    STDMETHOD(GetDecimationUsage)(THIS_
                                  DECIMATION_USAGE* lpdwUsage) PURE;

    STDMETHOD(CropSourceRect)(THIS_
                              VPWININFO* pWinInfo,
                              DWORD dwMinZoomFactorX,
                              DWORD dwMinZoomFactorY) PURE;

    STDMETHOD(StartVideo)(THIS_ ) PURE;
    STDMETHOD(SignalNewVP)(THIS_ LPDIRECTDRAWVIDEOPORT pVP) PURE;
};

class PixelFormatList;

class CVideoPortObj
: public CUnknown
, public IVPNotify2         // public
, public IVideoPortObject   // private between this videoport (on the input pin) & the VPM filter
, public IVideoPortInfo     // private to get stats on video port
{

public:
    CVideoPortObj(LPUNKNOWN pUnk, HRESULT* phr, IVideoPortControl* pVPControl );
    ~CVideoPortObj();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void* * ppv);

    // IVideoPortObject Interface to the outside world
    STDMETHODIMP GetDirectDrawVideoPort(LPDIRECTDRAWVIDEOPORT* ppDirectDrawVideoPort);
    STDMETHODIMP SetObjectLock(CCritSec* pMainObjLock);
    STDMETHODIMP SetMediaType(const CMediaType* pmt);
    STDMETHODIMP CheckMediaType(const CMediaType* pmt);
    STDMETHODIMP GetMediaType(int iPosition, CMediaType *pMediaType);
    STDMETHODIMP CompleteConnect(IPin* pReceivePin, BOOL bRenegotiating = FALSE);
    STDMETHODIMP BreakConnect(BOOL bRenegotiating = FALSE);
    STDMETHODIMP Active();
    STDMETHODIMP Inactive();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP RunToPause();
    STDMETHODIMP CurrentMediaType(AM_MEDIA_TYPE* pmt);
    STDMETHODIMP GetRectangles(RECT* prcSource, RECT* prcDest);
    STDMETHODIMP AttachVideoPortToSurface();
    STDMETHODIMP SignalNewVP();

    STDMETHODIMP GetAllOutputFormats( const PixelFormatList**);
    STDMETHODIMP GetOutputFormat( DDPIXELFORMAT* );
    STDMETHODIMP StartVideo( const VPWININFO* pWinInfo );
    STDMETHODIMP SetVideoPortID( DWORD dwVideoPortId );
    STDMETHODIMP CallUpdateSurface( DWORD dwSourceIndex, LPDIRECTDRAWSURFACE7 pDestSurface );
    STDMETHODIMP GetMode( AMVP_MODE* pMode );

    // Methods belonging to IVideoPortInfo
    STDMETHODIMP GetCropState(VPInfoCropState* pCropState);
    STDMETHODIMP GetPixelsPerSecond(DWORD* pPixelPerSec);
    STDMETHODIMP GetVPInfo(DDVIDEOPORTINFO* pVPInfo);
    STDMETHODIMP GetVPBandwidth(DDVIDEOPORTBANDWIDTH* pVPBandwidth);
    STDMETHODIMP GetVPCaps(DDVIDEOPORTCAPS* pVPCaps);
    STDMETHODIMP GetVPDataInfo(AMVPDATAINFO* pVPDataInfo);
    STDMETHODIMP GetVPInputFormat(LPDDPIXELFORMAT pVPFormat);
    STDMETHODIMP GetVPOutputFormat(LPDDPIXELFORMAT pVPFormat);

    // IVPNotify functions here
    STDMETHODIMP RenegotiateVPParameters();
    STDMETHODIMP SetDeinterlaceMode(AMVP_MODE mode);
    STDMETHODIMP GetDeinterlaceMode(AMVP_MODE* pMode);

    // functions added in IVPNotify2 here
    STDMETHODIMP SetVPSyncMaster(BOOL bVPSyncMaster);
    STDMETHODIMP GetVPSyncMaster(BOOL* pbVPSyncMaster);

private:
    // used to initialize all class member variables.
    // It is called from the contructor as well as CompleteConnect
    void InitVariables();


    // All these functions are called from within CompleteConnect
    HRESULT NegotiateConnectionParamaters();
    static HRESULT CALLBACK EnumCallback (LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext);
    HRESULT GetDataParameters();

    HRESULT GetInputPixelFormats( PixelFormatList* pList );
    HRESULT GetOutputPixelFormats( const PixelFormatList& ddInputFormats, PixelFormatList* pddOutputFormats );
    HRESULT SetInputPixelFormat( DDPIXELFORMAT& ddFormat );
    HRESULT NegotiatePixelFormat();

    HRESULT CreateVideoPort();
    HRESULT DetermineCroppingRestrictions();
    HRESULT CreateSourceSurface(BOOL bTryDoubleHeight, DWORD dwMaxBuffers, BOOL bPreferBuffers);
    HRESULT SetSurfaceParameters();
    HRESULT InitializeVideoPortInfo();
    HRESULT CheckDDrawVPCaps();
    HRESULT DetermineModeRestrictions();
    HRESULT SetDDrawKernelHandles();

    HRESULT SetUpMode( AMVP_MODE mode);

    // All these functions are called fro within OnClipChange
    // HRESULT DrawImage(const VPWININFO& pWinInfo, AMVP_MODE mode, const VPDRAWFLAGS& pvpDrawFlags, LPDIRECTDRAWSURFACE7 pDestSurface);


    HRESULT StartVideo();

    // Decimation functions
    BOOL
    ApplyDecimation(
        VPWININFO* pWinInfo,
        BOOL bColorKeying,
        BOOL bYInterpolating
        );

    HRESULT
    TryVideoPortDecimation(
        VPWININFO* pWinInfo,
        DWORD dwMinZoomFactorX,
        DWORD dwMinZoomFactorY,
        BOOL* lpUpdateRequired
        );

    HRESULT
    TryDecoderDecimation(
        VPWININFO* pWinInfo
        );

    void
    GetMinZoomFactors(
        const VPWININFO& pWinInfo,
        BOOL bColorKeying,
        BOOL bYInterpolating,
        LPDWORD lpMinX, LPDWORD lpMinY);


    BOOL
    Running();

    BOOL
    BeyondOverlayCaps(
        DWORD ScaleFactor,
        DWORD dwMinZoomFactorX,
        DWORD dwMinZoomFactorY
        );

    BOOL
    ResetVPDecimationIfSet();

    void
    ResetDecoderDecimationIfSet();

    void CropSourceSize(VPWININFO* pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSize(VPWININFO* pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSizeForCapture(VPWININFO* pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSizeWhenStopped(VPWININFO* pWinInfo,  DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL CheckVideoPortAlignment(DWORD dwWidth);

    BOOL
    VideoPortDecimationBackend(
        VPWININFO* pWinInfo,
        DWORD dwDexNumX,
        DWORD dwDexDenX,
        DWORD dwDexNumY,
        DWORD dwDexDenY
        );
    HRESULT ReconnectVideoPortToSurface();
    HRESULT StartVideoWithRetry();

public:
    HRESULT StopUsingVideoPort();
    HRESULT SetupVideoPort();

private:
    HRESULT ReleaseVideoPort();
    HRESULT RecreateSourceSurfaceChain();
    HRESULT DestroyOutputSurfaces();

    // Critical sections
    CCritSec*               m_pMainObjLock;                // Lock given by controlling object
    CCritSec                m_VPObjLock;                    // VP object wide lock
    IVideoPortControl*      m_pIVideoPortControl;

    // window information related stuff
    BOOL                    m_bStoredWinInfoSet;
    VPWININFO               m_StoredWinInfo;

    // image dimensions
    DWORD                   m_lImageWidth;
    DWORD                   m_lImageHeight;
    DWORD                   m_lDecoderImageWidth;
    DWORD                   m_lDecoderImageHeight;

    // info relating to capturing
    BOOL                    m_fCapturing;
    BOOL                    m_fCaptureInterleaved;
    DWORD                   m_cxCapture;
    DWORD                   m_cyCapture;

    // output surface related stuff
    struct Chain {
        LPDIRECTDRAWSURFACE7    pDDSurf;
        DWORD                   dwCount;
    };
    LPDIRECTDRAWSURFACE7    m_pOutputSurface;
    LPDIRECTDRAWSURFACE     m_pOutputSurface1;
    Chain *                 m_pChain;
    DWORD                   m_dwBackBufferCount;
     DWORD                   m_dwOutputSurfaceWidth;
    DWORD                   m_dwOutputSurfaceHeight;
    // DWORD                   m_dwOverlayFlags;

    // vp variables to store flags, current state etc
    IVPConfig*              m_pIVPConfig;
    BOOL                    m_bStart;

    BOOL                    m_bConnected;

    VPInfoState             m_VPState;
    AMVP_MODE               m_CurrentMode;
    // AMVP_MODE               m_StoredMode;
    VPInfoCropState         m_CropState;
    DWORD                   m_dwPixelsPerSecond;
    BOOL                    m_bVSInterlaced;
    bool                    m_fGarbageLine;
    bool                    m_fHalfHeightVideo;
    BOOL                    m_bVPSyncMaster;

    // vp data structures
    DWORD                   m_dwVideoPortId;
    LPDDVIDEOPORTCONTAINER  m_pDVP;
    LPDIRECTDRAWVIDEOPORT   m_pVideoPort;
    DDVIDEOPORTINFO         m_svpInfo;
    DDVIDEOPORTBANDWIDTH    m_sBandwidth;
    DDVIDEOPORTCAPS         m_vpCaps;
    DDVIDEOPORTCONNECT      m_ddConnectInfo;
    AMVPDATAINFO            m_VPDataInfo;

    // All the pixel formats (Video)
    DDPIXELFORMAT           m_ddVPInputVideoFormat;

    DWORD                   m_dwDefaultOutputFormat;    // which one we'll assume for the connection
    DDPIXELFORMAT           m_ddVPOutputVideoFormat;

    PixelFormatList         m_ddInputVideoFormats;
    PixelFormatList*        m_pddOutputVideoFormats;
    PixelFormatList         m_ddAllOutputVideoFormats;

    // can we support the different modes
    BOOL                    m_bCanWeave;
    BOOL                    m_bCanBobInterleaved;
    BOOL                    m_bCanBobNonInterleaved;
    BOOL                    m_bCanSkipOdd;
    BOOL                    m_bCanSkipEven;
    BOOL                    m_bCantInterleaveHalfline;

    // decimation parameters
    enum DECIMATE_MODE {DECIMATE_NONE, DECIMATE_ARB, DECIMATE_BIN, DECIMATE_INC};
#if defined(DEBUG)
    BOOL CheckVideoPortScaler(
        DECIMATE_MODE DecimationMode,
        DWORD ImageSize,
        DWORD PreScaleSize,
        ULONG ulDeciStep);
#endif
    DECIMATE_MODE           m_DecimationModeX;
    DWORD                   m_ulDeciStepX;
    DWORD                   m_dwDeciNumX;
    DWORD                   m_dwDeciDenX;

    DECIMATE_MODE           m_DecimationModeY;
    DWORD                   m_ulDeciStepY;
    DWORD                   m_dwDeciNumY;
    DWORD                   m_dwDeciDenY;

    BOOL                    m_bVPDecimating;
    BOOL                    m_bDecimating;
    LONG                    m_lWidth;
    LONG                    m_lHeight;

    // variables to store the current aspect ratio
    DWORD                   m_dwPictAspectRatioX;
    DWORD                   m_dwPictAspectRatioY;


    RECT                    m_rcSource;
    RECT                    m_rcDest;

};

DWORD MulABC_DivDE(DWORD A, DWORD B, DWORD C, DWORD D, DWORD E);

#endif //__VP_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\vpm\vpobj.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <VPObj.h>
#include <VPMUtil.h>
#include <dvp.h>
#include <ddkernel.h>

// VIDEOINFOHEADER2
#include <dvdmedia.h>

#include <FormatList.h>
#include <KHandleArray.h>

/******************************Public*Routine******************************\
* CVideoPortObj
*
* constructor
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
CVideoPortObj::CVideoPortObj( LPUNKNOWN pUnk, HRESULT *phr, IVideoPortControl* pVPControl )
: CUnknown(NAME("VP Object"), pUnk)
, m_bConnected( FALSE )
, m_pIVPConfig( NULL )
, m_bVPSyncMaster( FALSE )
, m_pMainObjLock( NULL )
, m_pIVideoPortControl( pVPControl )
, m_pddOutputVideoFormats( NULL )
, m_dwDefaultOutputFormat( 0 )
, m_dwVideoPortId( 0 )
, m_pDVP( NULL )
, m_pVideoPort( NULL )
{
    AMTRACE((TEXT("CVideoPortObj::Constructor")));
    InitVariables();
}

/******************************Public*Routine******************************\
* ~CVideoPortObj
*
* destructor
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
CVideoPortObj::~CVideoPortObj()
{
    AMTRACE((TEXT("CVideoPortObj::Destructor")));

    if (m_bConnected)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("Destructor called without calling breakconnect")));
        BreakConnect();
    }

    m_pIVideoPortControl = NULL;
}

/******************************Public*Routine******************************\
* CVideoPortObj::NonDelegatingQueryInterface
*
* overridden to expose IVPNotify and IVPObject
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::NonDelegatingQueryInterface")));

    if (riid == IID_IVPNotify) {
        hr = GetInterface(static_cast<IVPNotify*>(this), ppv);
    }  else if (riid == IID_IVPNotify2) {
        hr = GetInterface(static_cast<IVPNotify2*>(this), ppv);
    } else {
        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::InitVariables
*
* this function only initializes those variables which are supposed to be reset
* on RecreateVideoport
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
void CVideoPortObj::InitVariables()
{
    AMTRACE((TEXT("CVideoPortObj::InitVariables")));

    delete [] m_pddOutputVideoFormats;
    m_pddOutputVideoFormats = NULL;

    m_ddInputVideoFormats.Reset(0);

    ZeroStruct( m_rcDest );
    ZeroStruct( m_rcSource );

    // image dimensions
    m_lImageWidth = 0;
    m_lImageHeight = 0;
    m_lDecoderImageHeight = 0;
    m_lDecoderImageWidth = 0;

    // Capturing information
    m_fCapturing = FALSE;
    m_fCaptureInterleaved = FALSE;
    m_cxCapture = 0;
    m_cyCapture = 0;

    // overlay surface related stuff
    m_pOutputSurface = NULL;       // DirectDraw overlay surface
    m_pOutputSurface1 = NULL;

    m_pChain = NULL;
    m_dwBackBufferCount = 0;
    m_dwOutputSurfaceWidth = 0;
    m_dwOutputSurfaceHeight = 0;
    // m_dwOverlayFlags = 0;

    // vp variables to store flags, current state etc
    m_bStart = FALSE;
    m_VPState = VPInfoState_STOPPED; // current state: running, stopped
    m_CurrentMode = AMVP_MODE_WEAVE;
    // m_StoredMode = m_CurrentMode;
    m_CropState = VPInfoCropState_None;
    m_dwPixelsPerSecond = 0;
    m_bVSInterlaced = FALSE;
    m_fGarbageLine = false;
    m_fHalfHeightVideo = false;

    // vp data structures
    ASSERT( m_pDVP == NULL );
    RELEASE( m_pDVP );

    ASSERT( m_pVideoPort == NULL );
    RELEASE( m_pVideoPort );

    ZeroStruct( m_svpInfo );
    ZeroStruct( m_sBandwidth );
    ZeroStruct( m_vpCaps );
    ZeroStruct( m_ddConnectInfo );
    ZeroStruct( m_VPDataInfo );

    // All the pixel formats (Video/VBI)
    ZeroStruct( m_ddVPInputVideoFormat );
    ZeroStruct( m_ddVPOutputVideoFormat );

    // can we support the different modes
    m_bCanWeave = FALSE;
    m_bCanBobInterleaved = FALSE;
    m_bCanBobNonInterleaved = FALSE;
    m_bCanSkipOdd = FALSE;
    m_bCanSkipEven = FALSE;
    m_bCantInterleaveHalfline = FALSE;

    // decimation parameters
    m_ulDeciStepX = 0;
    m_dwDeciNumX = m_dwDeciDenX = 1000;
    m_ulDeciStepY = 0;
    m_dwDeciNumY = m_dwDeciDenY = 1000;
    m_DecimationModeX = DECIMATE_NONE;
    m_DecimationModeY = DECIMATE_NONE;

    m_bVPDecimating = FALSE;
    m_bDecimating = FALSE;
    m_lWidth = 0;
    m_lHeight = 0;

    // variables to store the current aspect ratio
    m_dwPictAspectRatioX = 1;
    m_dwPictAspectRatioY = 1;

    // misc
    m_CropState = VPInfoCropState_None;
    m_bStoredWinInfoSet = FALSE;
    ZeroStruct( m_StoredWinInfo );
}


/******************************Public*Routine******************************\
* CVideoPortObj::GetDirectDrawVideoPort
*
*
*
* History:
* Mon 10/16/2000 - NWilt - 
*
\**************************************************************************/
STDMETHODIMP
CVideoPortObj::GetDirectDrawVideoPort(LPDIRECTDRAWVIDEOPORT *ppDirectDrawVideoPort)
{
    AMTRACE((TEXT("CVideoPortObj::GetDirectDrawVideoPort")));
    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    if (!ppDirectDrawVideoPort ) {
        DbgLog((LOG_ERROR, 1,
                TEXT("value of ppDirectDrawVideoPort is invalid,")
                TEXT(" ppDirectDrawVideoPort = NULL")));
        return E_INVALIDARG;
    }
    // remove annoying double indirection since we now asserted its not null
    LPDIRECTDRAWVIDEOPORT& pDirectDrawVideoPort = *ppDirectDrawVideoPort;
    if(!m_bConnected)
    {
        // not connected, this function does not make much sense since the
        // surface wouldn't even have been allocated as yet
        DbgLog((LOG_ERROR, 1, TEXT("not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
    } else {
        pDirectDrawVideoPort = m_pVideoPort;
        if(! pDirectDrawVideoPort ) {
            hr = E_FAIL;
        } else {
            pDirectDrawVideoPort->AddRef();
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::SetObjectLock
*
* sets the pointer to the lock, which would be used to synchronize calls
* to the object.  It is the callee's responsiblility to synchronize this call
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetObjectLock(CCritSec *pMainObjLock)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::SetObjectLock")));

    if (!pMainObjLock)
    {
        DbgLog((LOG_ERROR, 0, TEXT("pMainObjLock is NULL")));
        hr = E_INVALIDARG;
    }
    else {
        m_pMainObjLock = pMainObjLock;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::SetMediaType
*
* check that the mediatype is acceptable
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CVideoPortObj::SetMediaType")));

    CAutoLock cObjectLock(m_pMainObjLock);
    HRESULT hr =  CheckMediaType(pmt);

#if defined(DEBUG)
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
    }
#endif

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::CheckMediaType
*
* check that the mediatype is acceptable. No lock is taken here.
* It is the callee's responsibility to maintain integrity!
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::CheckMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CVideoPortObj::CheckMediaType")));

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    if ((pmt->majortype == MEDIATYPE_Video) &&
        (pmt->subtype == MEDIASUBTYPE_VPVideo) &&
        (pmt->formattype == FORMAT_None))
    {
        // get the hardware caps
        const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
        if( pDirectCaps ) {
            hr = NOERROR;
        } else {
            // ASSERT( !"Warning: No VPE Support detected on video card" ); 
            DbgLog((LOG_ERROR, 2,
                    TEXT("no VPE support in hardware,")
                    TEXT("so not accepting this mediatype")));
        }
    }
    return hr;
}


HRESULT CVideoPortObj::NegotiatePixelFormat()
{
    HRESULT hr = GetInputPixelFormats( &m_ddInputVideoFormats );
    delete [] m_pddOutputVideoFormats;
    m_pddOutputVideoFormats = NULL;
    if( m_ddInputVideoFormats.GetCount() ) {
        m_pddOutputVideoFormats = new PixelFormatList[ m_ddInputVideoFormats.GetCount() ];
        if( !m_pddOutputVideoFormats ) {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        hr = GetOutputPixelFormats( m_ddInputVideoFormats, m_pddOutputVideoFormats );
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        // for every input format, figure out a table of every possible output format
        // Then we can offer a list of possible output formats.  When we need one of them, search
        // the input lists to locate it (and possibly select the conversion with the lowest bandwidth)
        m_ddAllOutputVideoFormats = PixelFormatList::Union( m_pddOutputVideoFormats, m_ddInputVideoFormats.GetCount() );

        // for the input pin connection we need a 'default' format
        // We'll use reconnect after we know what we're connected to.
        //
        //  Typically the VPE only supports one format so all of this is really
        // overkill ...
        if( m_ddAllOutputVideoFormats.GetCount() > 0 ) {
            m_ddVPOutputVideoFormat = m_ddAllOutputVideoFormats[ m_dwDefaultOutputFormat ];

            DWORD dwInput = PixelFormatList::FindListContaining(
                m_ddVPOutputVideoFormat, m_pddOutputVideoFormats, m_ddInputVideoFormats.GetCount() );
            if( dwInput < m_ddInputVideoFormats.GetCount() ) {
                hr = SetInputPixelFormat( m_ddInputVideoFormats[dwInput] );
            } else {
                // can't happen
                hr = E_FAIL;
                goto CleanUp;
            }
        }
    }
CleanUp:
    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::RecreateVideoPort
\**************************************************************************/

HRESULT CVideoPortObj::SetupVideoPort()
{
    AMTRACE((TEXT("CVideoPortObj::SetupVideoPort")));
    HRESULT hr = NOERROR;
    HRESULT hrFailure = VFW_E_VP_NEGOTIATION_FAILED;

    CAutoLock cObjectLock(m_pMainObjLock);

    InitVariables();

    LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    ASSERT(m_pIVPConfig);

    // create the VP container
    ASSERT(m_pDVP == NULL);
    ASSERT(pDirectDraw);

    hr = pDirectDraw->QueryInterface(IID_IDDVideoPortContainer, (LPVOID *)&m_pDVP);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                   TEXT("pDirectDraw->QueryInterface(IID_IDDVideoPortContainer)")
                   TEXT(" failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }


    // Get the Video Port caps
    // DDVIDEOPORTCAPS vpCaps;
    // INITDDSTRUCT(vpCaps);
    hr = VPMUtil::FindVideoPortCaps( m_pDVP, &m_vpCaps, m_dwVideoPortId );

    if (FAILED(hr) || S_FALSE == hr )
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->EnumVideoPorts failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    // negotiate the connection parameters
    // get/set connection info happens here
    hr = NegotiateConnectionParamaters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("NegotiateConnectionParamaters failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    //
    // Determine if we are capturing and if we are what the intended
    // capture image size is, first determine if the video port
    // supports interleaving interlaced fields in memory
    //

    BOOL fInterleave;
    if (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) {
        fInterleave = TRUE;
    }
    else {
        fInterleave = FALSE;
    }

    m_pIVideoPortControl->GetCaptureInfo(&m_fCapturing, &m_cxCapture,
                                  &m_cyCapture, &fInterleave);
    m_fCaptureInterleaved = fInterleave;

#if defined(DEBUG)
    if (m_fCapturing) {

        ASSERT(m_cxCapture > 0);
        ASSERT(m_cyCapture > 0);
        DbgLog((LOG_TRACE, 1,
                TEXT("We are CAPTURING, intended size (%d, %d)"),
                m_cxCapture, m_cyCapture));
    }
#endif

    
    for (DWORD i = 0; i < 2; i++)
    {
        AMVPSIZE amvpSize;
        DWORD dwNewWidth = 0;

        ZeroStruct( amvpSize );

        // get the rest of the data parameters
        hr = GetDataParameters();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("GetDataParameters failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // create the video port
        hr = CreateVideoPort();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CreateVideoPort failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // check if we need to crop at videoport or overlay or neither
        hr = DetermineCroppingRestrictions();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("DetermineCroppingRestrictions FAILED, hr = 0x%x"),
                    hr));
            hr = hrFailure;
            goto CleanUp;
        }


        m_lImageWidth  = WIDTH(&m_VPDataInfo.amvpDimInfo.rcValidRegion);
        m_lImageHeight = HEIGHT(&m_VPDataInfo.amvpDimInfo.rcValidRegion);

        m_lDecoderImageWidth = m_lImageWidth;
        m_lDecoderImageHeight = m_lImageHeight;

        if (m_fCapturing) {

            if (m_lImageWidth != m_cxCapture ||
                m_lImageHeight != m_cyCapture) {

                DbgLog((LOG_TRACE, 1,
                        TEXT("Adjust Decoder Image size to CaptureSize")));
            }

            m_lImageWidth = m_cxCapture;
            m_lImageHeight = m_cyCapture;
        }

        m_dwPictAspectRatioX = m_VPDataInfo.dwPictAspectRatioX;
        m_dwPictAspectRatioY = m_VPDataInfo.dwPictAspectRatioY;


        // negotiate the pixel format
        hr = NegotiatePixelFormat();
        
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // check the vp caps
        hr = CheckDDrawVPCaps();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CheckDDrawVPCaps FAILED, hr = 0x%x"), hr));
            // CheckDDrawVPCaps already returns a "proper" error code
            goto CleanUp;
        }

        if (i == 0)
        {

            dwNewWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
            if (m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE &&
                m_sBandwidth.dwYInterpAndColorkey < 900)
            {
                dwNewWidth = MulDiv(dwNewWidth,
                                    m_sBandwidth.dwYInterpAndColorkey, 1000);
            }
            else if (m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION &&
                     m_sBandwidth.dwYInterpAndColorkey > 1100)
            {
                dwNewWidth = MulDiv(dwNewWidth, 1000,
                                    m_sBandwidth.dwYInterpAndColorkey);
            }

            // VGA can't handle the bandwidth, ask decoder to down-scale
            if (dwNewWidth != m_VPDataInfo.amvpDimInfo.dwFieldWidth)
            {
                amvpSize.dwWidth = dwNewWidth;
                amvpSize.dwHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

                DbgLog((LOG_TRACE,1,
                        TEXT("SetScalingFactors to (%d, %d)"),
                        amvpSize.dwWidth, amvpSize.dwHeight));

                hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetScalingFactors")
                            TEXT("failed, hr = 0x%x"), hr));
                    break;
                }
                else
                {
                    // release the videoport
                    ASSERT(m_pVideoPort);
                    ReleaseVideoPort();

                    // initialize relevant structs
                    ZeroStruct( m_sBandwidth );
                    ZeroStruct( m_VPDataInfo );
                    ZeroStruct( m_ddVPInputVideoFormat );
                    ZeroStruct( m_ddVPOutputVideoFormat );

                    // initialize decimation parameters
                    m_ulDeciStepX = 0;
                    m_dwDeciNumX = m_dwDeciDenX = 1000;
                    m_DecimationModeX = DECIMATE_NONE;

                    m_ulDeciStepY = 0;
                    m_dwDeciNumY = m_dwDeciDenY = 1000;
                    m_DecimationModeY = DECIMATE_NONE;
                }
            }
            else
            {
                DbgLog((LOG_ERROR,0,TEXT("no need to scale at the decoder")));
                break;
            }
        }
    }


    // iniitalize the DDVideoPortInfo structure
    hr = InitializeVideoPortInfo();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("InitializeVideoPortInfo FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

#if 0
// quickly open & close to make sure that we have a notification
// The rapid switch doesn't work with most drivers though
static HRESULT CheckVPNotifiyValid( LPDIRECTDRAWVIDEOPORT pVP )
{
    HANDLE              hevSampleAvailable;
    DDVIDEOPORTNOTIFY   vpNotify;
    LPDIRECTDRAWVIDEOPORTNOTIFY pNotify;

    HRESULT hr = pVP->QueryInterface( IID_IDirectDrawVideoPortNotify, (LPVOID *) &pNotify );
    if( SUCCEEDED( hr )) {
        hr = pNotify->AcquireNotification( &hevSampleAvailable, &vpNotify );
        vpNotify.lDone = 1;
        pNotify->ReleaseNotification( hevSampleAvailable );
        RELEASE( pNotify );
    }
    return hr;
}
#endif

HRESULT CVideoPortObj::AttachVideoPortToSurface()
{
    HRESULT hr = S_OK;
    CAutoLock cObjectLock(m_pMainObjLock);

    LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

#ifdef DEBUG
#define DBGFLAG( f )  DbgLog((LOG_ERROR, 1, TEXT("%s = %s"), TEXT(#f), f ? TEXT("TRUE") : TEXT("FALSE") ))

    DBGFLAG (m_bVSInterlaced);
    DBGFLAG( m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP );
    DBGFLAG (m_vpCaps.dwFX & DDVPFX_INTERLEAVE);
    DBGFLAG (m_bCantInterleaveHalfline);
    DBGFLAG (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED);
    DBGFLAG (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED);
#undef DBGFLAG
#endif

    BOOL bCanWeave = FALSE;
    BOOL bCanBobInterleaved = FALSE;
    BOOL bCanBobNonInterleaved = FALSE;
    BOOL bTryDoubleHeight = FALSE, bPreferBuffers = FALSE;
    DWORD dwMaxOverlayBuffers;

    // can Weave only if content is non-interlaced (cause of motion
    // artifacts otherwise) and if videoport is capable of flipping and
    // supports interleaved data and if certain halfline scenarios do not
    // preclude interleaving
    //
    if ((!m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) &&
        (!m_bCantInterleaveHalfline))
    {
        bCanWeave = TRUE;
    }

    // can BobNonInterleaved only if content is interlaced and if videoport is
    // capable of flipping, is capable of bobing interleaved data and supports
    // interleaved data and if certain halfline scenarios do not preclude
    // interleaving
    //
    if ((m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED) &&
        (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) &&
        (!m_bCantInterleaveHalfline))
    {
        bCanBobInterleaved = TRUE;
    }

    // can BobInterleaved only if content is interlaced and if videoport is
    // capable of flipping and is capable of bobing non-interleaved data.
    //
    if ((m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED))
    {
        bCanBobNonInterleaved = TRUE;
    }

    // this just means that we would perfer higher number of
    // buffers instead of more height in the event of a conflict
    // (in cases like 2buffer, 1height versus 1buffer, 2height)
    //
    bPreferBuffers = TRUE;

    // we will try to allocate surface of double the field height only if
    // either mode weave or bob-interleaved are possible
    //
    bTryDoubleHeight = bCanWeave || bCanBobInterleaved;

    // 3 buffers prevents any waiting
    dwMaxOverlayBuffers = 3;

    // we will try to allocate multiple buffers only if either mode weave or
    // bob-interleaved or bob-non-interleaved are possible
    //
    if (bCanWeave || bCanBobInterleaved || bCanBobNonInterleaved)
    {
        //try to allocate min(m_vpCaps.dwNumAutoFlipSurfaces,
        // m_vpCaps.dwNumPreferredAutoflip) buffers
        //
        ASSERT(m_vpCaps.dwFlags & DDVPD_AUTOFLIP);
        if (m_vpCaps.dwFlags & DDVPD_PREFERREDAUTOFLIP)
        {
            dwMaxOverlayBuffers = min(m_vpCaps.dwNumAutoFlipSurfaces,
                                      m_vpCaps.dwNumPreferredAutoflip);
        }
        else
        {
            dwMaxOverlayBuffers = min(m_vpCaps.dwNumAutoFlipSurfaces, 3);
        }
    }

    // create the overlay surface
    hr = CreateSourceSurface(bTryDoubleHeight, dwMaxOverlayBuffers, bPreferBuffers);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CreateVPOverlay FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }

    // tell the upstream filter the valid data location on the ddraw surface
    hr = SetSurfaceParameters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetSurfaceParameters FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }

    // attach the overlay surface to the videoport
    hr = ReconnectVideoPortToSurface();
     
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->SetTargetSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (!(VPMUtil::EqualPixelFormats( m_ddVPInputVideoFormat, m_ddVPOutputVideoFormat)))
    {
        m_svpInfo.dwVPFlags |= DDVP_CONVERT;
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_CONVERT;
    }

    // determine which modes are possible now
    // depends upon the height, number of back buffers etc
    hr = DetermineModeRestrictions();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("DetermineModeRestrictions FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }
    //
    // try the various modes, this can be folded into DetermineModeRestrictions
    // instead of mindlessly pounding at cases (put into format negotiation code in VPMOutputPin ?)
    //
    hr = SetUpMode( m_CurrentMode );
    if( FAILED( hr )) {
        // switch modes
        AMVP_MODE modes[5]={AMVP_MODE_WEAVE,
                            AMVP_MODE_BOBINTERLEAVED, AMVP_MODE_BOBNONINTERLEAVED,
                            AMVP_MODE_SKIPODD, AMVP_MODE_SKIPEVEN
        };

        for( DWORD dwModeIndex = 0; dwModeIndex < NUMELMS( modes ); dwModeIndex++ ) {
            if( modes[dwModeIndex] != m_CurrentMode ) {
                hr = SetUpMode( modes[dwModeIndex] );
                if( SUCCEEDED(hr )) {
                    m_CurrentMode = modes[dwModeIndex];
                    break;
                }
            }
        }
    }

    // inform the decoder of the ddraw kernel handle, videoport id and surface
    // kernel handle
    hr = SetDDrawKernelHandles();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("SetDDrawKernelHandles failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

HRESULT CVideoPortObj::SignalNewVP()
{
    // finally notify the capture thread of the new surface
    ASSERT( m_pVideoPort );
    ASSERT( m_pChain );
    ASSERT( m_pChain[0].pDDSurf );
    HRESULT hRes = m_pIVideoPortControl->SignalNewVP( m_pVideoPort );
    return hRes;
}

/******************************Public*Routine******************************\
* CVideoPortObj::CompleteConnect
*
* supposed to be called when the host connects with the decoder
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP 
CVideoPortObj::CompleteConnect(IPin *pReceivePin, BOOL bRenegotiating)
{
    AMTRACE((TEXT("CVideoPortObj::CompleteConnect")));

    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    if (!bRenegotiating)
    {
        InitVariables();

        ASSERT(m_pIVPConfig == NULL);
        hr = pReceivePin->QueryInterface(IID_IVPConfig, (void **)&m_pIVPConfig);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,  TEXT("QueryInterface(IID_IVPConfig) failed, hr = 0x%x"), hr));
            hr = VFW_E_NO_TRANSPORT;
            goto CleanUp;
        }
    }

    ASSERT(m_pIVPConfig);

    hr = SetupVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("SetupVideoPort failed, hr = 0x%x"), hr));
        ASSERT(SUCCEEDED(hr));
        goto CleanUp;
    }
    m_bConnected = TRUE;


CleanUp:
    return hr;
}

HRESULT CVideoPortObj::StopUsingVideoPort()
{
    AMTRACE((TEXT("CVideoPortObj::StopUsingVideoPort")));

    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    // release the videoport
    if (m_pVideoPort)
    {
        hr = m_pVideoPort->StopVideo();
        ReleaseVideoPort();
    }

    // release the videoport container
    RELEASE( m_pDVP );

    // Release the DirectDraw overlay surface
    // Must release VideoPort first so that the thread doesn't use this
    hr = DestroyOutputSurfaces();
    return hr;
}

HRESULT
CVideoPortObj::DestroyOutputSurfaces()
{
    // ref counts on m_pChain match primary m_pOutputSurface
    delete [] m_pChain;
    m_pChain = NULL;

    RELEASE( m_pOutputSurface1 );
    RELEASE( m_pOutputSurface );
    return S_OK;
}

/******************************Public*Routine******************************\
* CVideoPortObj::BreakConnect
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP
CVideoPortObj::BreakConnect(BOOL bRenegotiating)
{
    AMTRACE((TEXT("CVideoPortObj::BreakConnect")));

    HRESULT hr = NOERROR;
    unsigned long ulCount;

    CAutoLock cObjectLock(m_pMainObjLock);

    hr = StopUsingVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("StopUsingVideoPort failed, hr = 0x%x"), hr));
    }
    if (!bRenegotiating)
    {
        // release the IVPConfig interface
        RELEASE (m_pIVPConfig);
    }

    m_bConnected = FALSE;

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::Active()
*
*
* transition from Stop to Pause.
* We do not need to to anything unless this is the very first time we are
* showing the overlay
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::Active()
{
    AMTRACE((TEXT("CVideoPortObj::Active")));

    CAutoLock cObjectLock(m_pMainObjLock);
    HRESULT hr = NOERROR;

    ASSERT(m_bConnected);
    ASSERT(m_VPState == VPInfoState_STOPPED);

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // make sure that a frame is visible by making an update overlay call
    m_bStart = TRUE;

    // now stop the video, so the user will just see a still frame
    hr = m_pVideoPort->StopVideo();

#if defined(DEBUG)
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
#endif

CleanUp:
    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::Inactive()
*
* transition (from Pause or Run) to Stop
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::Inactive()
{

    AMTRACE((TEXT("CVideoPortObj::Inactive")));

    HRESULT hr = NOERROR;
    CAutoLock cObjectLock(m_pMainObjLock);

    if (m_bConnected) {

        // Inactive is also called when going from pause to stop, in which case the
        // VideoPort would have already been stopped in the function RunToPause

        if (m_VPState == VPInfoState_RUNNING) {

            // stop the VideoPort
            if( m_pVideoPort )
                hr = m_pVideoPort->StopVideo();
            if (SUCCEEDED(hr)) {
                m_VPState = VPInfoState_STOPPED;
            }
            else {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
            }
        }
    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::Run
*
* transition from Pause to Run. We just start the VideoPort.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::Run(REFERENCE_TIME /* tStart */)
{
    AMTRACE((TEXT("CVideoPortObj::Run")));

    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_bConnected);
    ASSERT(m_VPState == VPInfoState_STOPPED);
    HRESULT hr = S_OK;

    if (m_bConnected)
    {
        // An UpdateOverlay is needed here. One example is, when we are
        // clipping video in Stop/Pause state since we can't do scaling
        // on the videoport. As soon as the user hits play, we should stop
        // clipping the video.

        m_bStart = TRUE;

        m_VPState = VPInfoState_RUNNING;
        // TBD: we need to kick a thread to start pumping frames from the videoport
        // to the output pin
    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::RunToPause()
*
* transition from Run to Pause. We just stop the VideoPort
* Note that transition from Run to Stop is caught by Inactive
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::RunToPause()
{

    AMTRACE((TEXT("CVideoPortObj::RunToPause")));

    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_bConnected);
    //ASSERT(m_VPState == VPInfoState_RUNNING);

    HRESULT hr;
    if (m_bConnected)
    {
        // stop the VideoPort
        hr = m_pVideoPort->StopVideo();
        if (SUCCEEDED(hr)) {

            m_VPState = VPInfoState_STOPPED;
        }
        else {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        }

    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::CurrentMediaType
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::CurrentMediaType(AM_MEDIA_TYPE *pMediaType)
{
    AMTRACE((TEXT("CVideoPortObj::CurrentMediaType")));

    CAutoLock cObjectLock(m_pMainObjLock);

    if (m_bConnected) {
        if (pMediaType) {
            VIDEOINFOHEADER2 *pVideoInfoHeader2 = VPMUtil::GetVideoInfoHeader2( (CMediaType *)pMediaType );

            // tweak it if it isn't the correct type
            if( !pVideoInfoHeader2 ) {
                pVideoInfoHeader2 = VPMUtil::SetToVideoInfoHeader2( (CMediaType *)pMediaType );
            }

            if( pVideoInfoHeader2 ) {
                VPMUtil::InitVideoInfoHeader2( pVideoInfoHeader2);

                pVideoInfoHeader2->bmiHeader.biWidth = m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                                   m_VPDataInfo.amvpDimInfo.rcValidRegion.left;
                pVideoInfoHeader2->bmiHeader.biHeight = m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom -
                                   m_VPDataInfo.amvpDimInfo.rcValidRegion.top;

                pVideoInfoHeader2->dwPictAspectRatioX = m_VPDataInfo.dwPictAspectRatioX;
                pVideoInfoHeader2->dwPictAspectRatioY = m_VPDataInfo.dwPictAspectRatioY;
                return S_OK;
            } else {
                DbgLog((LOG_ERROR, 2, TEXT("not videoheader2")));
                return NOERROR;
            }
        } else {
            DbgLog((LOG_ERROR, 2, TEXT("pMediaType is NULL")));
            return E_INVALIDARG;
        }
    } else {
        return VFW_E_NOT_CONNECTED;
    }
}

/******************************Public*Routine******************************\
* CVideoPortObj::GetRectangles
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetRectangles(RECT *prcSource, RECT *prcDest)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::GetRectangles")));

    if (prcSource && prcDest) {

        // adjust the source to be bigger to take into account the decimation
        // that's happening
        //
        prcSource->left   = MulDiv(m_rcSource.left,  m_dwDeciDenX, m_dwDeciNumX);
        prcSource->right  = MulDiv(m_rcSource.right, m_dwDeciDenX, m_dwDeciNumX);
        prcSource->top    = MulDiv(m_rcSource.top,   m_dwDeciDenY, m_dwDeciNumY);
        prcSource->bottom = MulDiv(m_rcSource.bottom,m_dwDeciDenY, m_dwDeciNumY);

        *prcDest = m_rcDest;
    }
    else {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR, 2, TEXT("prcSource or prcDest is NULL")));
    }

    return hr;
}


STDMETHODIMP CVideoPortObj::GetCropState(VPInfoCropState *pCropState)
{
    *pCropState = m_CropState;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetPixelsPerSecond(DWORD* pPixelPerSec)
{
    *pPixelPerSec = m_dwPixelsPerSecond;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPDataInfo(AMVPDATAINFO* pVPDataInfo)
{
    *pVPDataInfo = m_VPDataInfo;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPInfo(DDVIDEOPORTINFO* pVPInfo)
{
    *pVPInfo = m_svpInfo;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPBandwidth(DDVIDEOPORTBANDWIDTH* pVPBandwidth)
{
    *pVPBandwidth = m_sBandwidth;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPCaps(DDVIDEOPORTCAPS* pVPCaps)
{
    *pVPCaps = m_vpCaps;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPInputFormat(LPDDPIXELFORMAT pVPFormat)
{
    *pVPFormat = m_ddVPInputVideoFormat;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPOutputFormat(LPDDPIXELFORMAT pVPFormat)
{
    *pVPFormat = m_ddVPOutputVideoFormat;
    return NOERROR;
}

/******************************Public*Routine******************************\
* CVideoPortObj::StartVideo
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::ReconnectVideoPortToSurface()
{
    // not a high frequency event, so always try to reattach
    // if surfaces were lost for some reason, must be reattached
    HRESULT hResult;

	// we need a video port, StartWithRetry will create another videoport
	if( !m_pVideoPort ) {
		return E_FAIL;
	}
    if( !m_pOutputSurface || FAILED( hResult = m_pOutputSurface->Restore() )) { // == DDERR_WRONGMODE with Rage128
        // ASSERT( !"VPM: Can't restore surface, recreating" );
        hResult = AttachVideoPortToSurface();
        if( SUCCEEDED( hResult )) {
            hResult = SignalNewVP();
        }
    } else {
        hResult = m_pVideoPort->SetTargetSurface(m_pOutputSurface1, DDVPTARGET_VIDEO);

        // hack for bug where a running video port caused DDraw to stop it, discards the VPInfo, then tries
        // to start it, but returns E_INVALIDARG since the VPInfo is NULL!!
        if( FAILED( hResult )) {
            hResult = m_pVideoPort->SetTargetSurface(m_pOutputSurface1, DDVPTARGET_VIDEO);
        }
        // ASSERT( SUCCEEDED(hResult)); <- can fail if the videoport was lost during a res mode change (G400)
    }
    return hResult;
}

HRESULT CVideoPortObj::StartVideoWithRetry()
{
    HRESULT hr = E_FAIL;
    // Can be NULL if we call StartWithRetry twice and the VP failed
    if( m_pVideoPort ) {
        hr = m_pVideoPort->StartVideo(&m_svpInfo);
    }

    // This case SUCCEEDS on the G400 

    // Try again with ReconnectToSurf first
    if (FAILED(hr))
    {
        // ASSERT( !"StartWithRetry entering salvage mode" );
        hr = ReconnectVideoPortToSurface();
        if( SUCCEEDED( hr )) {
            hr = m_pVideoPort->StartVideo(&m_svpInfo);
        }
    }
    // Try again with CreateVP then ReconnectToSurf (first case FAILs on the Rage128) 
    if( FAILED(hr)) {
        // ASSERT( !"Recreating videoport" );
        // try replacing the video port
        hr = CreateVideoPort();
        if( SUCCEEDED( hr )) {
            hr = ReconnectVideoPortToSurface();
        }
        if( SUCCEEDED( hr )) {
            hr = m_pVideoPort->StartVideo(&m_svpInfo);
        }
    }
#if 0
    // Try again with SetupVP (CreateVP), ReconnectToSurf first
    // This implies the video port enumerator isn't valid any more.  I don't think
    // this should happen in practice, but just in case.
    if( FAILED(hr)) {
        ASSERT( !"Rebuilding videoport" );
        // really corrupt, start from the beginning
        hr = SetupVideoPort();
        if( SUCCEEDED( hr )) {
            hr = ReconnectVideoPortToSurface();
        }
        if( SUCCEEDED( hr )) {
            hr = m_pVideoPort->StartVideo(&m_svpInfo);
        }
    }
#endif
    return hr;
}

STDMETHODIMP CVideoPortObj::StartVideo(const VPWININFO* pWinInfo )
{
    AMTRACE((TEXT("CVideoPortObj::StartVideo")));

    HRESULT hr = NOERROR;
    if ( m_bStart) {
        VPWININFO CopyWinInfo;
        AMVP_MODE tryMode;

        CAutoLock cObjectLock(m_pMainObjLock);

        // no point making any videoport calls, if the video is stopped
        if (m_VPState == VPInfoState_RUNNING || m_bStart)
        {
            if (m_bStart)
            {
                DWORD dwSignalStatus;
                hr = StartVideoWithRetry();
                if( FAILED( hr )) {
                    hr = StartVideoWithRetry();
                    if( FAILED( hr )) {
                        goto CleanUp;
                    }
                }

                DbgLog((LOG_ERROR,0, TEXT("StartVideo DONE!!!")));

                // check if the videoport is receiving a signal.
                hr = m_pVideoPort->GetVideoSignalStatus(&dwSignalStatus);
                if ((SUCCEEDED(hr)) && (dwSignalStatus == DDVPSQ_SIGNALOK))
                {
                    m_pVideoPort->WaitForSync(DDVPWAIT_END, 0, 0);
                }
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pVideoPort->GetVideoSignalStatus() failed,")
                            TEXT(" hr = 0x%x"), hr));
                    hr = NOERROR;
                }


                m_bStart = FALSE;
            }
        }
    }
CleanUp:
    return hr;
}

static bool AreEqual( const DDVIDEOPORTCONNECT& proposed, const DDVIDEOPORTCONNECT& videoport )
{
    return (proposed.dwPortWidth == videoport.dwPortWidth) && 
           IsEqualIID(proposed.guidTypeID, videoport.guidTypeID);
}

/*****************************Private*Routine******************************\
* CVideoPortObj::NegotiateConnectionParamaters
*
* this functions negotiates the connection parameters with
* the decoder.
* Since this function might be called during renegotiation, the
* existing connection parameters are passed in as input and if
* possible, we try to use the same parameters.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::NegotiateConnectionParamaters()
{
    AMTRACE((TEXT("CVideoPortObj::NegotiateConnectionParamaters")));

    HRESULT hr = NOERROR;
    LPDDVIDEOPORTCONNECT lpddProposedConnect = NULL;
    DWORD dwNumProposedEntries = 0;
    DDVIDEOPORTSTATUS ddVPStatus = { sizeof(DDVIDEOPORTSTATUS)};
    LPDDVIDEOPORTCONNECT lpddVideoPortConnect = NULL;
    DWORD dwNumVideoPortEntries = 0;
    BOOL bIntersectionFound = FALSE;
    DWORD i, j;


    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_pIVPConfig);
    ASSERT(m_pDVP);

    // find the number of entries to be proposed
    hr = m_pIVPConfig->GetConnectInfo(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumProposedEntries);

    // allocate the necessary memory
    lpddProposedConnect = new DDVIDEOPORTCONNECT[dwNumProposedEntries];
    if (lpddProposedConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiateConnectionParamaters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroArray(lpddProposedConnect, dwNumProposedEntries );

    // set the right size in each of the structs.
    for (i = 0; i < dwNumProposedEntries; i++)
    {
        lpddProposedConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetConnectInfo(&dwNumProposedEntries, lpddProposedConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // get the status of the video port
    hr = m_pDVP->QueryVideoPortStatus(m_dwVideoPortId, &ddVPStatus);
    if (FAILED(hr))
    {
        //  Some cards don't implement this so just crash on
        ddVPStatus.bInUse = FALSE;
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->QueryVideoPortStatus failed, hr = 0x%x"), hr));
//  goto CleanUp;
    }

    // find the number of entries supported by the videoport
    hr = m_pDVP->GetVideoPortConnectInfo(m_dwVideoPortId, &dwNumVideoPortEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumVideoPortEntries);

    // allocate the necessary memory
    lpddVideoPortConnect = new DDVIDEOPORTCONNECT[dwNumVideoPortEntries];
    if (lpddVideoPortConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,
                TEXT("NegotiateConnectionParamaters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroMemory(lpddVideoPortConnect,
               dwNumVideoPortEntries*sizeof(DDVIDEOPORTCONNECT));

    // set the right size in each of the structs.
    for (i = 0; i < dwNumVideoPortEntries; i++)
    {
        lpddVideoPortConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries supported by the videoport
    hr = m_pDVP->GetVideoPortConnectInfo(m_dwVideoPortId, &dwNumVideoPortEntries,
                                         lpddVideoPortConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pDVP->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }


    // check if the video port is not already in use
    if (!ddVPStatus.bInUse)
    {

        // take the first element of the intersection of the two lists and
        // set that value on the decoder
        for (i = 0; i < dwNumProposedEntries && !bIntersectionFound; i++)
        {
            for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
            {
                if ( AreEqual( lpddProposedConnect[i], lpddVideoPortConnect[j]) )
                {
                    m_ddConnectInfo = lpddVideoPortConnect[j];
                    hr = m_pIVPConfig->SetConnectInfo(i);
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR,0,
                                TEXT("m_pIVPConfig->SetConnectInfo")
                                TEXT(" failed, hr = 0x%x"), hr));
                        goto CleanUp;
                    }

                    bIntersectionFound = TRUE;
                }
            }
        }
    }
    else
    {
        // take the first element of the list matching the current status
        for (i = 0; i < dwNumProposedEntries && !bIntersectionFound; i++)
        {
            if ( AreEqual(lpddProposedConnect[i], ddVPStatus.VideoPortType) )
            {
                for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
                {
                    if ( AreEqual(lpddProposedConnect[i], lpddVideoPortConnect[j]) )
                    {
                        m_ddConnectInfo = lpddVideoPortConnect[j];
                        bIntersectionFound = TRUE;
                    }
                }
                break;
            }
        }
    }

    if (!bIntersectionFound)
    {
        hr = E_FAIL;

        goto CleanUp;
    }

    // cleanup
CleanUp:
    delete [] lpddProposedConnect;
    delete [] lpddVideoPortConnect;
    return hr;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::GetDataParameters
*
*
* this functions gets various data parameters from the decoder
* parameters include dimensions, double-clock, vact etc
* Also maximum pixel rate the decoder will output
* this happens after the connnection parameters have been set-up
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::GetDataParameters()
{
    AMTRACE((TEXT("CVideoPortObj::GetDataParameters")));

    HRESULT hr = NOERROR;
    DWORD dwMaxPixelsPerSecond = 0;
    AMVPSIZE amvpSize;

    CAutoLock cObjectLock(m_pMainObjLock);


    // set the size of the struct
    m_VPDataInfo.dwSize = sizeof(AMVPDATAINFO);

    // get the VideoPort data information
    hr = m_pIVPConfig->GetVPDataInfo(&m_VPDataInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVPDataInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    /*
    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom > m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom = m_VPDataInfo.amvpDimInfo.dwFieldHeight;
    */

    // if decoder says data is not interlaced
    if (!(m_VPDataInfo.bDataIsInterlaced))
    {
        // this flag does not mean anything
        if (m_VPDataInfo.bFieldPolarityInverted)
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        // these don't mean anything either
        if ((m_VPDataInfo.lHalfLinesOdd != 0) ||
            (m_VPDataInfo.lHalfLinesEven != 0))
        {
            hr = E_FAIL;
            goto CleanUp;
        }
    }

    amvpSize.dwWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    amvpSize.dwHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

    // get the maximum pixel rate the decoder will output
    hr = m_pIVPConfig->GetMaxPixelRate(&amvpSize, &dwMaxPixelsPerSecond);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetMaxPixelRate failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_dwPixelsPerSecond = dwMaxPixelsPerSecond;



    CleanUp:
    DbgLog((LOG_TRACE, 5,TEXT("Leaving CVideoPortObj::GetDataParameters")));
    return hr;
}

static BOOL CanCreateSurface( LPDIRECTDRAW7 pDirectDraw, const DDPIXELFORMAT& ddFormat ) 
{

    // check if output format is suitable for a DDraw output device
   
    DDSURFACEDESC2 ddsdDesc;
    ddsdDesc.dwSize = sizeof(DDSURFACEDESC);
    ddsdDesc.dwFlags = DDSD_CAPS | DDSD_HEIGHT |
                       DDSD_WIDTH | DDSD_PIXELFORMAT;

    ddsdDesc.ddpfPixelFormat = ddFormat;

    ddsdDesc.ddsCaps.dwCaps = // DDSCAPS_OVERLAY |
                              DDSCAPS_VIDEOMEMORY |
                              DDSCAPS_VIDEOPORT;

    // the actual overlay surface created might be of different
    // dimensions, however we are just testing the pixel format
    ddsdDesc.dwWidth = 64;
    ddsdDesc.dwHeight = 64;

    ASSERT(pDirectDraw);
    LPDIRECTDRAWSURFACE7 pSurf;
    HRESULT hr = pDirectDraw->CreateSurface(&ddsdDesc, &pSurf, NULL);
    if( SUCCEEDED( hr )) {
        pSurf->Release();
    }
    return SUCCEEDED( hr );
}

/*****************************Private*Routine******************************\
* CVideoPortObj::GetBestFormat
*
* this function takes a list of inputformats and returns the
* "best" input and output format according to some criterion.
* It also checks if the output formats is suitable by trying
* to allocate a small surface and checking to see if the call
* succeeds. Since this is before the overlay surface has been
* created, that should be a ok. Right now the criterion just
* includes bestbendwidth, or if not that then just the first
* suitable one in the list.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT
CVideoPortObj::GetOutputPixelFormats(
    const PixelFormatList& ddInputFormats,
    PixelFormatList* pddOutputFormats )
{
    HRESULT hr = S_OK;
    AMTRACE((TEXT("CVideoPortObj::GetOutputFormats")));

    CAutoLock cObjectLock(m_pMainObjLock);

    for (DWORD i = 0; i < ddInputFormats.GetCount(); i++)
    {
        // For each input format, figure out the output formats
        DDPIXELFORMAT* pInputFormat = const_cast<DDPIXELFORMAT*>(&ddInputFormats[i]);
        DWORD dwNumOutputFormats;
        hr = m_pVideoPort->GetOutputFormats(pInputFormat,
                                            &dwNumOutputFormats,
                                            NULL, DDVPFORMAT_VIDEO);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            break;
        }
        ASSERT(dwNumOutputFormats);

        // allocate the necessary memory
        pddOutputFormats[i].Reset( dwNumOutputFormats );

        if (pddOutputFormats[i].GetEntries() == NULL)
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("new failed, failed to allocate memnory for ")
                    TEXT("lpddOutputFormats in NegotiatePixelFormat")));
            hr = E_OUTOFMEMORY;
            break;
        }

        // get the entries supported by the videoport
        hr = m_pVideoPort->GetOutputFormats(pInputFormat,
                                            &dwNumOutputFormats,
                                            pddOutputFormats[i].GetEntries(),
                                            DDVPFORMAT_VIDEO);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            break;
        }
    } // end of outer for loop
    return hr;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::NegotiatePixelFormat
*
* this function is used to negotiate the pixelformat with the decoder.
* It asks the decoder fot a list of input formats, intersects that list
* with the one the deocoder supports (while maintaining the order) and
* then calls "GetBestFormat" on that list to get the "best" input and
* output format. After that it calls "SetPixelFormat" on the decoder in
* order to inform the decoder of the decision.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::GetInputPixelFormats( PixelFormatList* pList )
{
    AMTRACE((TEXT("CVideoPortObj::NegotiatePixelFormat")));
    CAutoLock cObjectLock(m_pMainObjLock);

    HRESULT hr = NOERROR;
    // find the number of entries to be proposed
    DWORD dwNumProposedEntries = 0;
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumProposedEntries);

    // find the number of entries supported by the videoport
    DWORD dwNumVPInputEntries = 0;
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries, NULL, DDVPFORMAT_VIDEO);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumVPInputEntries);

    // allocate the necessary memory
    PixelFormatList lpddProposedFormats(dwNumProposedEntries);
    if (lpddProposedFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, lpddProposedFormats.GetEntries() );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }

    // allocate the necessary memory
    PixelFormatList lpddVPInputFormats(dwNumVPInputEntries);
    if (lpddVPInputFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries supported by the videoport
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries,
                                       lpddVPInputFormats.GetEntries(), DDVPFORMAT_VIDEO);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        return hr;
    }

    *pList = lpddVPInputFormats.IntersectWith( lpddProposedFormats );

    // the number of entries in the intersection is zero!!
    // Return failure.
    if (pList->GetCount() == 0)
    {
        hr = E_FAIL;
        return hr;
    }

    // call GetBestFormat with whatever search criterion you want
    // DWORD dwBestEntry;
    // hr = GetBestFormat(lpddIntersectionFormats.GetCount(),
    //                    lpddIntersectionFormats.GetEntries(), TRUE, &dwBestEntry,
    //                    &m_ddVPOutputVideoFormat);
    // if (FAILED(hr))
    // {
    //     DbgLog((LOG_ERROR,0,TEXT("GetBestFormat failed, hr = 0x%x"), hr));
    // } else {
    //      hr = SetVPInputPixelFormat( lpddIntersectionFormats[dwBestEntry] )
    // }
    return hr;
}

HRESULT CVideoPortObj::SetInputPixelFormat( DDPIXELFORMAT& ddFormat )
{
    HRESULT hr = NOERROR;
    // find the number of entries to be proposed
    DWORD dwNumProposedEntries = 0;
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumProposedEntries);

    PixelFormatList lpddProposedFormats(dwNumProposedEntries);
    if (lpddProposedFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, lpddProposedFormats.GetEntries() );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }

    // set the format the decoder is supposed to be using
    for (DWORD i = 0; i < dwNumProposedEntries; i++)
    {
        if (VPMUtil::EqualPixelFormats(lpddProposedFormats[i], ddFormat ))
        {
            hr = m_pIVPConfig->SetVideoFormat(i);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pIVPConfig->SetVideoFormat failed, hr = 0x%x"),
                        hr));
                return hr;
            }
            // cache the input format
            m_ddVPInputVideoFormat = ddFormat;

            break;
        }
    }
    return hr;
}


HRESULT CVideoPortObj::ReleaseVideoPort()
{
    HRESULT hr = S_OK;
    // tell the filter we've yanked the VP so that it doesn't hold onto refs to the VP
    if( m_pIVideoPortControl ) {
        hr = m_pIVideoPortControl->SignalNewVP( NULL );
    }
    // release it ourselves
    RELEASE( m_pVideoPort );
    return hr;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::CreateVideoPort
*
* Displays the Create Video Port dialog and calls DDRAW to actually
* create the port.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::CreateVideoPort()
{
    HRESULT hr = NOERROR;
    DDVIDEOPORTDESC svpDesc;
    DWORD dwTemp = 0, dwOldVal = 0;
    DWORD lHalfLinesOdd = 0, lHalfLinesEven = 0;
    AMTRACE((TEXT("CVideoPortObj::CreateVideoPort")));

    CAutoLock cObjectLock(m_pMainObjLock);

    INITDDSTRUCT(svpDesc);

    // if the decoder can send double clocked data and the videoport
    // supports it, then set that property. This field is only valid
    // with an external signal.
    if (m_VPDataInfo.bEnableDoubleClock &&
        m_ddConnectInfo.dwFlags & DDVPCONNECT_DOUBLECLOCK)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_DOUBLECLOCK;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_DOUBLECLOCK;
    }

    // if the decoder can give an external activation signal and the
    // videoport supports it, then set that property. This field is
    // only valid with an external signal.
    if (m_VPDataInfo.bEnableVACT &&
        m_ddConnectInfo.dwFlags & DDVPCONNECT_VACT)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_VACT;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_VACT;
    }

    // if the decoder can send interlaced data and the videoport
    // supports it, then set that property.
    if (m_VPDataInfo.bDataIsInterlaced)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INTERLACED;
        m_bVSInterlaced = TRUE;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_INTERLACED;
        m_bVSInterlaced = FALSE;
    }

    // handle the VREF stuff here
    if (m_ddConnectInfo.dwFlags & DDVPCONNECT_DISCARDSVREFDATA)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top -=
                m_VPDataInfo.dwNumLinesInVREF;

        if (m_VPDataInfo.amvpDimInfo.rcValidRegion.top < 0)
            m_VPDataInfo.amvpDimInfo.rcValidRegion.top = 0;
    }

    // handle the halfline stuff here
    lHalfLinesOdd = m_VPDataInfo.lHalfLinesOdd;
    lHalfLinesEven = m_VPDataInfo.lHalfLinesEven;

    // reset both the halfline and the invert polarity bits
    svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_HALFLINE;
    svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_INVERTPOLARITY;

    // if halflines are being reported assert that the data is interlaced
    if (lHalfLinesOdd != 0 || lHalfLinesEven != 0)
    {
        ASSERT(m_VPDataInfo.bDataIsInterlaced);
    }

    // whenever halflines exist, make sure to set the tell the hal
    if (((lHalfLinesOdd ==  1 || lHalfLinesEven ==  1) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) ||
        ((lHalfLinesOdd == -1 || lHalfLinesEven == -1) && (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))))
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_HALFLINE;
    }

    // In this case, the video is forced to move down one line
    // case 2 in scott's document
    if ((lHalfLinesOdd == 0) &&
        (lHalfLinesEven == 1) &&
        (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 1;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 2;
        m_fGarbageLine = true;

        // if the deocder is already not inverting fields and if the VGA supports
        // inverting polarities, then ask the VGA to invert polarities othwise ask
        // decoder to invert polarities.
        if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
        {
            svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
        }
        else
        {
            hr = m_pIVPConfig->SetInvertPolarity();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pIVPConfig->SetInvertPolarity failed, hr = 0x%x"),
                        hr));
                goto CleanUp;
            }
        }
    }
    // case 3 and 5 in scott's document
    else if ((lHalfLinesOdd == 1) &&
             (lHalfLinesEven == 0))
    {
        // case 5 (just shift by one, do not reverse polarities
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 1;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 2;
        m_fGarbageLine = true;
        m_bCantInterleaveHalfline = TRUE;


        // case 3 (shift by one and reverse polarities)
        if (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))
        {
            // if the deocder is already not inverting fields and if the
            // VGA supports inverting polarities, then ask the VGA to invert
            // polarities othwise ask decoder to invert polarities.
            //
            if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
            }
            else
            {
                hr = m_pIVPConfig->SetInvertPolarity();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetInvertPolarity failed,")
                            TEXT(" hr = 0x%x"),
                            hr));
                    goto CleanUp;
                }
            }
        }
    }
    // case 4 in scott's document
    else if ((lHalfLinesOdd == 0) &&
             (lHalfLinesEven == -1) &&
             (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)))
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 0;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 1;
        m_fGarbageLine = true;
    }
    else if (((lHalfLinesOdd ==  0) && (lHalfLinesEven ==  0)) ||
             ((lHalfLinesOdd == -1) && (lHalfLinesEven ==  0) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) ||
             ((lHalfLinesOdd ==  0) && (lHalfLinesEven == -1) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) || // opposite of case 4
             ((lHalfLinesOdd ==  0) && (lHalfLinesEven ==  1) && (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)))) // opposite of case 2
    {
        // if the deocder is already inverting fields and if the VGA supports
        // inverting polarities, then ask the VGA to invert polarities
        // othwise ask decoder to invert polarities.
        if (m_VPDataInfo.bFieldPolarityInverted)
        {
            if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
            }
            else
            {
                hr = m_pIVPConfig->SetInvertPolarity();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetInvertPolarity failed,")
                            TEXT(" hr = 0x%x"), hr));
                    goto CleanUp;
                }
            }
        }
    }
    else
    {
        // Potential bug : workaround for current BPC driver
        // hr = E_FAIL; // we can't handle these cases, FAIL
        // goto CleanUp;
    }

    if (m_VPDataInfo.amvpDimInfo.dwFieldHeight <
        (DWORD)m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom)
    {
        m_VPDataInfo.amvpDimInfo.dwFieldHeight =
            m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom;
    }

    if ((m_vpCaps.dwFlags & DDVPD_WIDTH) &&
        (m_VPDataInfo.amvpDimInfo.dwFieldWidth > m_vpCaps.dwMaxWidth))
    {
        m_VPDataInfo.amvpDimInfo.dwFieldWidth = m_vpCaps.dwMaxWidth;
    }

    if ((m_vpCaps.dwFlags & DDVPD_WIDTH) &&
        (m_VPDataInfo.amvpDimInfo.dwVBIWidth > m_vpCaps.dwMaxVBIWidth))
    {
        m_VPDataInfo.amvpDimInfo.dwVBIWidth = m_vpCaps.dwMaxVBIWidth;
    }

    if ((m_vpCaps.dwFlags & DDVPD_HEIGHT) &&
        (m_VPDataInfo.amvpDimInfo.dwFieldHeight > m_vpCaps.dwMaxHeight))
    {
        m_VPDataInfo.amvpDimInfo.dwFieldHeight = m_vpCaps.dwMaxHeight;
    }

    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.right >
        (LONG)m_VPDataInfo.amvpDimInfo.dwFieldWidth)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.right =
                (LONG)m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    }

    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom >
        (LONG)m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom =
            (LONG)m_VPDataInfo.amvpDimInfo.dwFieldHeight;
    }

    // fill up the fields of the description struct
    svpDesc.dwFieldWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    svpDesc.dwVBIWidth = m_VPDataInfo.amvpDimInfo.dwVBIWidth;
    svpDesc.dwFieldHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

    svpDesc.dwMicrosecondsPerField = m_VPDataInfo.dwMicrosecondsPerField;
    svpDesc.dwMaxPixelsPerSecond = m_dwPixelsPerSecond;
    svpDesc.dwVideoPortID = m_dwVideoPortId;
    svpDesc.VideoPortType.dwSize = sizeof(DDVIDEOPORTCONNECT);
    svpDesc.VideoPortType.dwPortWidth = m_ddConnectInfo.dwPortWidth;
    memcpy(&svpDesc.VideoPortType.guidTypeID, &m_ddConnectInfo.guidTypeID, sizeof(GUID));

    DbgLog((LOG_TRACE, 3, TEXT("svpDesc")));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldWidth = %u"), svpDesc.dwFieldWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwVBIWidth   = %u"), svpDesc.dwVBIWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldHeight= %u"), svpDesc.dwFieldHeight));
    DbgLog((LOG_TRACE, 3, TEXT("dwMicrosecondsPerField= %u"), svpDesc.dwMicrosecondsPerField));
    DbgLog((LOG_TRACE, 3, TEXT("dwMaxPixelsPerSecond= %u"), svpDesc.dwMaxPixelsPerSecond));
    DbgLog((LOG_TRACE, 3, TEXT("dwVideoPortID= %u"), svpDesc.dwVideoPortID));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize= %u"), svpDesc.VideoPortType.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwPortWidth= %u"), svpDesc.VideoPortType.dwPortWidth));

    // create the videoport. The first parameter is dwFlags, reserved for
    // future use by ddraw. The last parameter is pUnkOuter, again must be
    // NULL.
    //
    // use the DDVPCREATE_VIDEOONLY flag only if the hal is capable of
    // streaming VBI on a seperate surface
    //

    ReleaseVideoPort();

    if (m_vpCaps.dwCaps & DDVPCAPS_VBIANDVIDEOINDEPENDENT)
    {
        hr = m_pDVP->CreateVideoPort(DDVPCREATE_VIDEOONLY, &svpDesc,
                                     &m_pVideoPort, NULL);
        ASSERT( hr != DDERR_OUTOFCAPS ); // means videoport is in use, I.E. the VPM has leaked a ref count to the videoport
                                        // usually we forgot a RELEASE
        // ASSERT( SUCCEEDED(hr));
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pDVP->CreateVideoPort(DDVPCREATE_VIDEOONLY)")
                    TEXT(" failed, hr = 0x%x"), hr));
        }
    } else {
        hr = m_pDVP->CreateVideoPort(0, &svpDesc, &m_pVideoPort, NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pDVP->CreateVideoPort(0) failed, hr = 0x%x"), hr));
        }
    }
    // tell the filter about the new VP in ReconnectVideoPortToSurface after we have a new surface

CleanUp:
    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::DetermineCroppingRestrictions
*
*
* this function is used to check the cropping restrictions at the
* videoport and at the overlay. This function also decides where
* the cropping should be done (at videoport or at overlay).
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::DetermineCroppingRestrictions()
{
    AMTRACE((TEXT("CVideoPortObj::DetermineCroppingRestrictions")));
    HRESULT hr = NOERROR;

    BOOL bVideoPortCanCrop = TRUE, bOverlayCanCrop = TRUE;
    DWORD dwTemp = 0, dwOldVal = 0;
    DWORD dwCropOriginX = 0, dwCropOriginY = 0;
    DWORD dwCropWidth = 0, dwCropHeight=0;
    const DDCAPS* pDirectCaps = NULL;


    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    // cache the cropping paramters
    dwCropOriginX = m_VPDataInfo.amvpDimInfo.rcValidRegion.left;
    dwCropOriginY = m_VPDataInfo.amvpDimInfo.rcValidRegion.top;
    dwCropWidth = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                          m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
    dwCropHeight = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom -
                           m_VPDataInfo.amvpDimInfo.rcValidRegion.top);


    // Align the left boundary
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_ALIGN))
    {
        dwTemp = dwCropOriginX & (m_vpCaps.dwAlignVideoPortCropBoundary-1);
        if (dwTemp != 0)
        {
            dwOldVal = dwCropOriginX;
            dwCropOriginX = dwCropOriginX +
                            m_vpCaps.dwAlignVideoPortCropBoundary - dwTemp;

            m_VPDataInfo.amvpDimInfo.rcValidRegion.left = dwCropOriginX;
            dwCropWidth = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                                  m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
            DbgLog((LOG_TRACE,2,
                    TEXT("Alligning the left cropping boundary from %d to %d"),
                    dwOldVal, dwCropOriginX));
        }
    }

    // Align the width
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_ALIGN))
    {
        dwTemp = dwCropWidth & (m_vpCaps.dwAlignVideoPortCropWidth-1);
        if (dwTemp != 0)
        {
            dwOldVal = dwCropOriginX;
            dwCropWidth = dwCropWidth - dwTemp;
            m_VPDataInfo.amvpDimInfo.rcValidRegion.right =
                dwCropWidth + (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
            DbgLog((LOG_TRACE,2,
                    TEXT("Alligning the width of cropping rect from %d to %d"),
                    dwOldVal, dwCropWidth));
        }
    }

    // determine if we can do without any cropping at all
    if (dwCropOriginX == 0 && dwCropOriginY == 0 &&
        dwCropWidth == m_VPDataInfo.amvpDimInfo.dwFieldWidth &&
        dwCropHeight == m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    {
        // hurray we are home free!!!
        DbgLog((LOG_TRACE,1, TEXT("No cropping necessary")));
        m_CropState = VPInfoCropState_None;
        goto CleanUp;
    }

    // determine if the videoport can do the cropping for us

    // Can the videoport crop in the X direction
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_FX))
    {
        if (dwCropWidth != m_VPDataInfo.amvpDimInfo.dwFieldWidth &&
            (m_vpCaps.dwFX & DDVPFX_CROPX) == 0)
        {
            DbgLog((LOG_ERROR,1, TEXT("VideoPort can't crop, DDVPFX_CROPX == 0")));
            bVideoPortCanCrop = FALSE;
        }
    }

    // Can the videoport crop in the Y direction
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_FX))
    {
        if (dwCropHeight != m_VPDataInfo.amvpDimInfo.dwFieldHeight &&
            (m_vpCaps.dwFX & DDVPFX_CROPY) == 0 &&
            (m_vpCaps.dwFX & DDVPFX_CROPTOPDATA) == 0)
        {
            DbgLog((LOG_ERROR,1, TEXT("VideoPort can't crop, DDVPFX_CROPY == 0")));
            bVideoPortCanCrop = FALSE;
        }
    }


    // ok, so the videoport can crop for us. So no need to crop at the
    // overlay surface.
    if (bVideoPortCanCrop)
    {
        DbgLog((LOG_TRACE,2, TEXT("Cropping would be done at the videoport")));
        m_CropState = VPInfoCropState_AtVideoPort;
        goto CleanUp;
    }

    // determine if the overlay can do the cropping for us
    ASSERT( !"Cropping must be at overlay ... not supported" );
    // Is left boundary alligned
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNBOUNDARYDEST))
    {
        dwTemp = dwCropOriginX & (pDirectCaps->dwAlignBoundaryDest-1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.left = %d"),
                    dwTemp, dwCropOriginX));
            bOverlayCanCrop = FALSE;
        }
    }
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNBOUNDARYSRC))
    {
        dwTemp = dwCropOriginX & (pDirectCaps->dwAlignBoundarySrc-1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.left = %d"),
                    dwTemp, dwCropOriginX));
            bOverlayCanCrop = FALSE;
        }
    }

    // Is Width alligned
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNSIZEDEST))
    {
        dwTemp = dwCropWidth & (pDirectCaps->dwAlignSizeDest -1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.Width = %d"),
                    dwTemp, dwCropWidth));
            bOverlayCanCrop = FALSE;
        }
    }
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNSIZESRC))
    {
        dwTemp = dwCropWidth & (pDirectCaps->dwAlignSizeSrc -1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.Width = %d"),
                    dwTemp, dwCropWidth));
            bOverlayCanCrop = FALSE;
        }
    }

    // ok, the videoport was unsuitable but the overlay came through
    // this means more pain for me, no!!!
    if (bOverlayCanCrop)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    CleanUp:
    return hr;
}

HRESULT CVideoPortObj::RecreateSourceSurfaceChain()
{
    DWORD dwcSurfaces = m_dwBackBufferCount + 1;

    if( !m_pOutputSurface ) {
        return E_POINTER;
    }
    RELEASE( m_pOutputSurface1 );

    // required for SetTargetSurface for videoport
    HRESULT hResult = m_pOutputSurface->QueryInterface( IID_IDirectDrawSurface,  (VOID **)&m_pOutputSurface1 );
    if( FAILED( hResult )) {
        return hResult;
    }

    // otherwise we're leaking surface counts
    delete [] m_pChain;

    m_pChain = new Chain[dwcSurfaces];
    if ( ! m_pChain )
    {
        return E_OUTOFMEMORY;
    }
    m_pChain[0].pDDSurf = m_pOutputSurface;
    m_pChain[0].dwCount =0;
    if ( m_dwBackBufferCount )
    {
        LPDIRECTDRAWSURFACE7 pDDS = m_pOutputSurface;
        LPDIRECTDRAWSURFACE7 pDDSBack;
        for ( UINT i = 1; i < dwcSurfaces; i++ )
        {
            DDSCAPS2 caps = {0};
            m_pChain[i].pDDSurf = NULL;
            m_pChain[i].dwCount =0;

#ifdef DEBUG
            {
                DDSURFACEDESC2 ddSurfaceDesc;
                // get the surface description
                INITDDSTRUCT(ddSurfaceDesc);
                pDDS->GetSurfaceDesc(&ddSurfaceDesc);
            }
#endif

            if( i==1 ) {
                // for first attached get the back buffer
                caps.dwCaps = DDSCAPS_BACKBUFFER;
            } else {
                // for the rest get the complex surfaces
                // (since only the first has DDSCAPS_BACKBUFFER set)
                caps.dwCaps = DDSCAPS_COMPLEX;
            }
            if ( SUCCEEDED( pDDS->GetAttachedSurface( &caps, &pDDSBack ) ) )
            {
                m_pChain[i].pDDSurf = pDDSBack;
                pDDS = pDDSBack;
            } else {
                ASSERT( !"Fatal problem ... can't get attached surface (bug in video driver)" );
                return E_FAIL;
            }
        }
    }

    DbgLog((LOG_TRACE, 1,
            TEXT("Created an offscreen Surface of Width=%d,")
            TEXT(" Height=%d, Total-No-of-Buffers=%d"),
            m_dwOutputSurfaceWidth, m_dwOutputSurfaceHeight,
            dwcSurfaces ));
    return S_OK;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::CreateVPOverlay
*
* this function is used to allocate an overlay surface to attach to the
* videoport.
* The allocation order it tries is just in decreasing amount of memory
* required. Theres is one ambiguity, which is resolved by bPreferBuffers
* (3 buffers, double height)
* (2 buffers, double height)
* (3 buffers, single height)
* (2 buffers, single height) OR (1 buffer , double height) (depends upon bPreferBuffers)
* (1 buffer , single height).
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT
CVideoPortObj::CreateSourceSurface(
    BOOL bTryDoubleHeight,
    DWORD dwMaxBuffers,
    BOOL bPreferBuffers)
{
    DDSURFACEDESC2 ddsdDesc;
    HRESULT hr = NOERROR;
    DWORD dwMaxHeight = 0, dwMinHeight = 0, dwCurHeight = 0, dwCurBuffers = 0;
    LPDIRECTDRAW7 pDirectDraw = NULL;

    AMTRACE((TEXT("CVideoPortObj::CreateVPOverlay")));

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    // initialize the fields of ddsdDesc
    INITDDSTRUCT( ddsdDesc );
    ddsdDesc.dwFlags = DDSD_CAPS |
                       DDSD_HEIGHT |
                       DDSD_WIDTH |
                       DDSD_PIXELFORMAT;

    ddsdDesc.ddpfPixelFormat = m_ddVPOutputVideoFormat;

    ddsdDesc.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                              DDSCAPS_VIDEOMEMORY |
                              DDSCAPS_VIDEOPORT;
    ddsdDesc.dwWidth = m_lImageWidth;


    dwMaxHeight = dwMinHeight = m_lImageHeight;

    // make sure we don't leak the old surface
    DestroyOutputSurfaces();

    // we will try to allocate double height surface, only if the decoder is
    // sending interlaced data, and the videoport supports interlaced data
    // and can interleave interlaced data in memory and bTryDoubleHeight is true
    if (bTryDoubleHeight)
    {
        dwMaxHeight = 2 * m_lImageHeight;
    }
    else
    {
        // make sure that bPreferBuffers is TRUE here, since it is a single
        // height case making it FALSE would not make any sense
        bPreferBuffers = TRUE;
    }

    // we will only try to allocate more than one buffer, if the videoport
    // is cabable of autoflipping
    if (dwMaxBuffers > 1)
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;

        for (dwCurHeight = dwMaxHeight;
             !m_pOutputSurface && dwCurHeight >= dwMinHeight; dwCurHeight /= 2)
        {
            for (dwCurBuffers = dwMaxBuffers;
                 !m_pOutputSurface &&  dwCurBuffers >= 2; dwCurBuffers--)
            {

                // if the case is (2 buffers, single height) but we prefer
                // more height rather than more buffers, then postpone this
                // case. We will come to it eventually, if the other cases fail.
                if (!bPreferBuffers &&
                    dwCurBuffers == 2 &&
                    dwCurHeight == m_lImageHeight)
                {
                    continue;
                }

                ddsdDesc.dwHeight = dwCurHeight;
                ddsdDesc.dwBackBufferCount = dwCurBuffers-1;

                hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
                if (SUCCEEDED(hr))
                {
                    m_dwBackBufferCount = dwCurBuffers-1;
                    m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
                    m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
                    hr = RecreateSourceSurfaceChain();
                    goto CleanUp;
                }
            }
        }
    }

    // we should only reach this point when attempt to allocate multiple buffers
    // failed or no autoflip available or bPreferBuffers is FALSE


    // case (1 buffer, double height)
    if (dwMaxHeight == 2*m_lImageHeight)
    {
        ddsdDesc.dwHeight = 2*m_lImageHeight;
        ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
        ddsdDesc.dwBackBufferCount = 0;

        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 0;
            m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
            m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
            hr = RecreateSourceSurfaceChain();
            goto CleanUp;
        }
    }

    // case (2 buffer, single height) only if you prefer height to buffers
    if (bPreferBuffers && (dwMaxBuffers > 1) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP))
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;

        ddsdDesc.dwHeight = 2*m_lImageHeight;
        ddsdDesc.dwBackBufferCount = 1;
        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 1;
            m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
            m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
            hr = RecreateSourceSurfaceChain();
            goto CleanUp;
        }
    }

    // case (1 buffer, single height)
    {
        ddsdDesc.dwHeight = m_lImageHeight;
        ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
        ddsdDesc.dwBackBufferCount = 0;
        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 0;
            m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
            m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
            hr = RecreateSourceSurfaceChain();
            goto CleanUp;
        }
    }

    // ASSERT( m_pOutputSurface );
    DbgLog((LOG_TRACE, 1,  TEXT("Unable to create offset output surface")));

CleanUp:
    return hr;
}

static DWORD GetPitch( const DDSURFACEDESC2& ddSurf )
{
    const DDPIXELFORMAT& ddFormat = ddSurf.ddpfPixelFormat;

    if( ddSurf.dwFlags & DDSD_PITCH ) {
        return ddSurf.lPitch;
    } else {
        if( ddFormat.dwFlags & DDPF_FOURCC) {
            if( ddFormat.dwFourCC == mmioFOURCC('U','Y','V','Y') ) {
                return 2* ddSurf.dwWidth;
            }
        }
        return ddSurf.dwWidth;
    }
}


/*****************************Private*Routine******************************\
* CVideoPortObj::SetSurfaceParameters
*
* SetSurfaceParameters used to tell the decoder where the
* valid data is on the surface
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::SetSurfaceParameters()
{
    HRESULT hr = NOERROR;
    DWORD dwPitch = 0;
    DDSURFACEDESC2 ddSurfaceDesc;

    AMTRACE((TEXT("CVideoPortObj::SetSurfaceParameters")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // get the surface description
    INITDDSTRUCT(ddSurfaceDesc);
    hr = m_pOutputSurface->GetSurfaceDesc(&ddSurfaceDesc);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_pOutputSurface->GetSurfaceDesc failed, hr = 0x%x"),
                hr));
    }
    else
    {
        ASSERT(ddSurfaceDesc.dwFlags & DDSD_PITCH);
        dwPitch = GetPitch(ddSurfaceDesc);
    }

    hr = m_pIVPConfig->SetSurfaceParameters(dwPitch, 0, 0);

    // right now the proxy maps ERROR_SET_NOT_FOUND to an HRESULT and
    // returns that failure code if the driver does not implement a function
    //
    if (hr == E_NOTIMPL || hr == (HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)))
    {
        hr = NOERROR;
        DbgLog((LOG_TRACE, 5,TEXT("SetSurfaceParamters not implemented")));
        goto CleanUp;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5,TEXT("SetSurfaceParamters failed, hr = 0x%x"), hr));
    }

CleanUp:
    return hr;
}



/*****************************Private*Routine******************************\
* CVideoPortObj::InitializeVideoPortInfo
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::InitializeVideoPortInfo()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::InitializeVideoPortInfo")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // initialize the DDVIDEOPORTINFO struct to be passed to start-video
    INITDDSTRUCT(m_svpInfo);
    m_svpInfo.lpddpfInputFormat = &m_ddVPInputVideoFormat;
    m_svpInfo.dwVPFlags = DDVP_AUTOFLIP;

    if (m_CropState == VPInfoCropState_AtVideoPort)
    {
        m_svpInfo.rCrop = m_VPDataInfo.amvpDimInfo.rcValidRegion;
        m_svpInfo.dwVPFlags |= DDVP_CROP;

        // use the VBI height only if the hal is capable of streaming
        // VBI on a seperate surface
        if (m_vpCaps.dwCaps & DDVPCAPS_VBIANDVIDEOINDEPENDENT)
        {
            m_svpInfo.dwVBIHeight = m_VPDataInfo.amvpDimInfo.rcValidRegion.top;
        }
    } else {
        m_svpInfo.dwVPFlags &= ~DDVP_CROP;
    }

    if (m_bVPSyncMaster) {
        m_svpInfo.dwVPFlags |= DDVP_SYNCMASTER;
    } else {
        m_svpInfo.dwVPFlags &= ~DDVP_SYNCMASTER;
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::CheckDDrawVPCaps
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::CheckDDrawVPCaps()
{
    HRESULT hr = NOERROR;
    BOOL bAlwaysColorkey;

    AMTRACE((TEXT("CVideoPortObj::CheckDDrawVPCaps")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // Determine if we should always colorkey, or only when we need to.
    // At issue is the fact that some overlays cannot colorkey and Y
    // interpolate at the same time.  If not, we will only colorkey when
    // we have to.
    m_sBandwidth.dwSize = sizeof(DDVIDEOPORTBANDWIDTH);
    hr = m_pVideoPort->GetBandwidthInfo(&m_ddVPOutputVideoFormat,
                                        m_lImageWidth, m_lImageHeight,
                                        DDVPB_TYPE, &m_sBandwidth);

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pVideoPort->GetBandwidthInfo FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE)
    {
        hr = m_pVideoPort->GetBandwidthInfo(&m_ddVPOutputVideoFormat,
                                            m_lImageWidth, m_lImageHeight,
                                            DDVPB_OVERLAY, &m_sBandwidth);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pVideoPort->GetBandwidthInfo FAILED, hr = 0x%x"),
                    hr));
            goto CleanUp;
        }
        // store the caps info in this struct itself
        m_sBandwidth.dwCaps = DDVPBCAPS_SOURCE;
        if (m_sBandwidth.dwYInterpAndColorkey < m_sBandwidth.dwYInterpolate  &&
            m_sBandwidth.dwYInterpAndColorkey < m_sBandwidth.dwColorkey)
        {
            bAlwaysColorkey = FALSE;
        }
        else
        {
            bAlwaysColorkey = TRUE;
        }
    }
    else
    {
        ASSERT(m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION);


        DWORD dwImageHeight = m_lImageHeight;
        if (m_fCaptureInterleaved) {
            dwImageHeight /= 2;
        }

        hr = m_pVideoPort->GetBandwidthInfo(&m_ddVPOutputVideoFormat,
                                            m_lImageWidth, dwImageHeight,
                                            DDVPB_VIDEOPORT, &m_sBandwidth);
        if (hr != DD_OK)
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("GetBandwidthInfo FAILED, hr = 0x%x"), hr));
            goto CleanUp;
        }
        // store the caps info in this struct itself
        m_sBandwidth.dwCaps = DDVPBCAPS_DESTINATION;
        if (m_sBandwidth.dwYInterpAndColorkey > m_sBandwidth.dwYInterpolate &&
            m_sBandwidth.dwYInterpAndColorkey > m_sBandwidth.dwColorkey)
        {
            bAlwaysColorkey = FALSE;
        }
        else
        {
            bAlwaysColorkey = TRUE;
        }
    }

    // determine the decimation properties in the x direction

    // Data can be arbitrarily shrunk
    if (m_vpCaps.dwFX & DDVPFX_PRESHRINKX) {
        m_DecimationModeX = DECIMATE_ARB;
    }

    // Data can be shrunk in increments of 1/x in the X direction
    // (where x is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKXS) {

        m_DecimationModeX = DECIMATE_INC;
        m_ulDeciStepX = m_vpCaps.dwPreshrinkXStep;

        DbgLog((LOG_TRACE, 1,
                TEXT("preshrink X increment %d"), m_vpCaps.dwPreshrinkXStep));
    }

    // Data can be binary shrunk (1/2, 1/4, 1/8, etc.)
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKXB) {

        m_DecimationModeX = DECIMATE_BIN;
    }

    // no scaling at all supported !!
    else {

        m_DecimationModeX = DECIMATE_NONE;
    }

    // determine the decimation properties in the y direction

    // Data can be arbitrarily shrunk
    if (m_vpCaps.dwFX & DDVPFX_PRESHRINKY)
    {
        m_DecimationModeY = DECIMATE_ARB;
    }

    // Data can be shrunk in increments of 1/x in the Y direction
    // (where x is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKYS)
    {
        m_DecimationModeY = DECIMATE_INC;
        m_ulDeciStepX = m_vpCaps.dwPreshrinkYStep;
    }

    // Data can be binary shrunk (1/2, 1/4, 1/8, etc.)
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKYB)
    {
        m_DecimationModeY = DECIMATE_BIN;
    }

    else {
        m_DecimationModeY = DECIMATE_NONE;
    }

CleanUp:
    return hr;
}




/*****************************Private*Routine******************************\
* CVideoPortObj::DetermineModeRestrictions
*
* Determine if we can bob(interleaved/non), weave, or skip fields
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::DetermineModeRestrictions()
{
    AMTRACE((TEXT("CVideoPortObj::DetermineModeRestrictions")));
    HRESULT hr = NOERROR;
    const DDCAPS* pDirectCaps = NULL;

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    m_bCanWeave = FALSE;
    m_bCanBobInterleaved = FALSE;
    m_bCanBobNonInterleaved = FALSE;
    m_bCanSkipOdd = FALSE;
    m_bCanSkipEven = FALSE;

    // this is just a policy. Don't weave interlaced content cause of
    // motion artifacts
    if ((!m_bVSInterlaced) &&
        m_dwOutputSurfaceHeight >= m_lImageHeight * 2 &&
        m_dwBackBufferCount > 0)
    {
        m_bCanWeave = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Weave")));
    }

    if (m_bVSInterlaced &&
        m_dwOutputSurfaceHeight >= m_lImageHeight * 2 &&
        pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED)
    {
        m_bCanBobInterleaved = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Bob Interleaved")));
    }

    if (m_bVSInterlaced &&
        m_dwBackBufferCount > 0 &&
        pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED)
    {
        m_bCanBobNonInterleaved = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Bob NonInterleaved")));
    }

    if (m_vpCaps.dwCaps & DDVPCAPS_SKIPODDFIELDS)
    {
        m_bCanSkipOdd = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Skip Odd")));
    }

    if (m_vpCaps.dwCaps & DDVPCAPS_SKIPEVENFIELDS)
    {
        m_bCanSkipEven = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Skip Even")));
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::SetDDrawKernelHandles
*
* this function is used to inform the decoder of the various ddraw
* kernel handle using IVPConfig interface
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::SetDDrawKernelHandles()
{
    HRESULT hr = NOERROR, hrFailure = NOERROR;
    IDirectDrawKernel *pDDK = NULL;
    IDirectDrawSurfaceKernel *pDDSK = NULL;
    DWORD *pdwKernelHandleCount = 0;
    DWORD dwCount = 0;
    ULONG_PTR dwDDKernelHandle = 0;
    LPDIRECTDRAW7 pDirectDraw = NULL;

    AMTRACE((TEXT("CVideoPortObj::SetDDrawKernelHandles")));

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    // get the IDirectDrawKernel interface
    hr = pDirectDraw->QueryInterface(IID_IDirectDrawKernel, (LPVOID *)&pDDK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("QueryInterface for IDirectDrawKernel failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // get the kernel handle
    ASSERT(pDDK);
    hr = pDDK->GetKernelHandle(&dwDDKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("GetKernelHandle from IDirectDrawKernel failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // set the kernel handle to directdraw using IVPConfig
    ASSERT(m_pIVPConfig);
    ASSERT(dwDDKernelHandle);
    hr = m_pIVPConfig->SetDirectDrawKernelHandle(dwDDKernelHandle);
    if (FAILED(hr))
    {
        hrFailure = hr;
        DbgLog((LOG_ERROR,0,
                TEXT("IVPConfig::SetDirectDrawKernelHandle failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // set the VidceoPort Id using IVPConfig
    ASSERT(m_pIVPConfig);
    hr = m_pIVPConfig->SetVideoPortID(m_dwVideoPortId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("IVPConfig::SetVideoPortID failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    {
        KernelHandleArray pArray( m_pOutputSurface, hr );

        if( SUCCEEDED( hr )) {
            // set the kernel handle to the overlay surface using IVPConfig
            ASSERT(m_pIVPConfig);
            hr = m_pIVPConfig->SetDDSurfaceKernelHandles( pArray.GetCount(), pArray.GetHandles() );
            if (FAILED(hr))
            {
                hrFailure = hr;
                DbgLog((LOG_ERROR,0,
                        TEXT("IVPConfig::SetDirectDrawKernelHandles failed,")
                        TEXT(" hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
    }
CleanUp:
    // release the kernel ddraw handle
    RELEASE (pDDK);
    return hrFailure;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::SetUpMode
*
* This function is designed to be called everytime on an update-overlay call
* not just when the mode changes. This is basically to keep the code simple.
* Certain functions are supposed to be called in sequence,
* (SetUpMode, followedby AdjustSourceSize followedby SetDisplayRects).
* I just call them all everytime, eventhough it is possible to optimize on
* that. The logic is that since UpdateOverlay is so expensive, this is no
* performance hit.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::SetUpMode( AMVP_MODE mode )
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::SetUpMode")));

    CAutoLock cObjectLock(m_pMainObjLock);

    switch( mode ) {
        case AMVP_MODE_WEAVE:
        case AMVP_MODE_BOBINTERLEAVED:
        case AMVP_MODE_BOBNONINTERLEAVED:
        case AMVP_MODE_SKIPODD:
        case AMVP_MODE_SKIPEVEN:
        break;
        default:
            DbgLog((LOG_ERROR, 0,
                    TEXT("SetUpMode failed, mode value not valid, mode = %d"),
                    mode));
            hr = E_FAIL;
            goto CleanUp;
    }

    if (mode == AMVP_MODE_WEAVE && !m_bCanWeave)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_WEAVE")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_BOBINTERLEAVED && !m_bCanBobInterleaved)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_BOBINTERLEAVED")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_BOBNONINTERLEAVED && !m_bCanBobNonInterleaved)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_BOBNONINTERLEAVED")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_SKIPODD && !m_bCanSkipOdd)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_SKIPODD")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_SKIPEVEN && !m_bCanSkipEven)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_SKIPEVEN")));
        hr = E_FAIL;
        goto CleanUp;
    }

    // Determine if we should interleave this or not.
    // If we are doing weave, we certainly need to interleave.
    // Bob doesn't really care one way or the other (since it only
    // displays one field at a time), but interleaved makes it much
    // easier to switch from bob to weave.
    if (mode == AMVP_MODE_BOBINTERLEAVED ||
        mode == AMVP_MODE_WEAVE)
    {
        m_svpInfo.dwVPFlags |= DDVP_INTERLEAVE;

        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag interleaved")));
        m_fHalfHeightVideo = false;
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_INTERLEAVE;
        m_fHalfHeightVideo = true;
        // pWinInfo->SrcRect.top /= 2;
        // pWinInfo->SrcRect.bottom /= 2;
    }

    // if there is a garbage line at the top, we must clip it.
    // At this point the source rect is set up for a frame, so increment by 2
    // since we incremented the cropping rect height by 1, decrement the bottom
    // as well
    if (m_fGarbageLine)
    {
        // Done in blit
        //pWinInfo->SrcRect.top += 1;
        //pWinInfo->SrcRect.bottom -= 1;
        DbgLog((LOG_TRACE, 3,
                TEXT("m_fGarbageLine is TRUE, incrementing SrcRect.top")));
    }

    if (mode == AMVP_MODE_SKIPODD)
    {
        m_svpInfo.dwVPFlags |= DDVP_SKIPODDFIELDS;
        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag SkipOddFields")));
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_SKIPODDFIELDS;
    }

    if (mode == AMVP_MODE_SKIPEVEN)
    {
        m_svpInfo.dwVPFlags |= DDVP_SKIPEVENFIELDS;
        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag SkipEvenFields")));
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_SKIPEVENFIELDS;
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::RenegotiateVPParameters
*
* this function is used to redo the whole videoport connect process,
* while the graph maybe be running.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::RenegotiateVPParameters()
{
    HRESULT hr = NOERROR;
    VPInfoState vpOldState;

    AMTRACE((TEXT("CVideoPortObj::RenegotiateVPParameters")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // don't return an error code if not connected
    if (!m_bConnected)
    {
        hr = NOERROR;
        goto CleanUp;
    }

    LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    if( pDirectDraw ) {
        if( pDirectDraw->TestCooperativeLevel() != DD_OK ) {
            // Don't alter the videoport while in exclusive mode, otherwise
            // the DXG kernel layer drifts out of sync with DDraw
            return S_OK;
        }
    }

    // store the old state, we will need to restore it later
    vpOldState = m_VPState;

    if (m_VPState == VPInfoState_RUNNING)
    {
        m_VPState = VPInfoState_STOPPED;
    }

    // release everything except IVPConfig 
    hr = StopUsingVideoPort();


    // redo the connection process
    hr = SetupVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // also notifies VPMThread about new VP & surfaces
    hr = AttachVideoPortToSurface();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("AttachVideoPortToSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if the video was previously running, make sure that a frame is
    // visible by making an update overlay call
    if (vpOldState == VPInfoState_RUNNING)
    {
        m_bStart = TRUE;

        hr = m_pIVideoPortControl->StartVideo();

        ASSERT( SUCCEEDED(hr));
        if (FAILED(hr))
        {
           DbgLog((LOG_ERROR,0,
                   TEXT("Start video failed failed, hr = 0x%x"), hr));
           goto CleanUp;
        }

#if 0 // hack to get the Rage128 playing video again, probably the software autoflipping
        // is broken.  After a aspect ratio change or res mode change, the autoflipping doesn't start up again
        hr = m_pVideoPort->StopVideo();

        // ATI seems to want another set of stop/start's to actually start
        // autoflipping again...
        m_bStart = TRUE;
        hr = m_pIVideoPortControl->StartVideo();
#endif

        m_VPState = VPInfoState_RUNNING;
    }
    // send a dynamic reconnect to the downstream filter

    if( SUCCEEDED( hr )) {
        hr = SignalNewVP();
    }

CleanUp:
    if (FAILED(hr))
    {
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        BreakConnect(TRUE);

        m_pIVideoPortControl->EventNotify(EC_COMPLETE, S_OK, 0);
        m_pIVideoPortControl->EventNotify(EC_ERRORABORT, hr, 0);
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::SetDeinterlaceMode
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetDeinterlaceMode(AMVP_MODE mode)
{
    AMTRACE((TEXT("CVideoPortObj::SetMode")));
    return E_NOTIMPL;
}

/******************************Public*Routine******************************\
* CVideoPortObj::GetDeinterlaceMode
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetDeinterlaceMode(AMVP_MODE *pMode)
{
    AMTRACE((TEXT("CVideoPortObj::GetMode")));
    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* CVideoPortObj::SetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetVPSyncMaster(BOOL bVPSyncMaster)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVideoPortObj::SetVPSyncMaster")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // if value has not changed, no need to do anything
    if (m_bVPSyncMaster != bVPSyncMaster)
    {
        // store the new value
        m_bVPSyncMaster = bVPSyncMaster;

        // if not connected, connection process will take care of updating the
        // m_svpInfo struct
        if (!m_bConnected)
            goto CleanUp;

        // update the m_svpInfo struct
        if (m_bVPSyncMaster) {
            m_svpInfo.dwVPFlags |= DDVP_SYNCMASTER;
        }
        else {
            m_svpInfo.dwVPFlags &= ~DDVP_SYNCMASTER;
        }

        // if video is stopped currently, no need to do anything else
        if (m_VPState == VPInfoState_STOPPED)
            goto CleanUp;

        // Call UpdateVideo to make sure the change is reflected immediately
        ASSERT( m_svpInfo.dwVPFlags & DDVP_AUTOFLIP );
        hr = m_pVideoPort->UpdateVideo(&m_svpInfo);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0, TEXT("UpdateVideo failed, hr = 0x%x"), hr));
        }
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::GetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetVPSyncMaster(BOOL *pbVPSyncMaster)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVideoPortObj::SetVPSyncMaster")));

    CAutoLock cObjectLock(m_pMainObjLock);

    if (pbVPSyncMaster) {
        *pbVPSyncMaster = m_bVPSyncMaster;
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::GetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - GlennE - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetAllOutputFormats( const PixelFormatList** ppList )
{
    AMTRACE((TEXT("CVideoPortObj::GetAllOutputFormats")));
    CAutoLock cObjectLock(m_pMainObjLock);

    *ppList = &m_ddAllOutputVideoFormats;
    return S_OK;
}

STDMETHODIMP CVideoPortObj::GetOutputFormat( DDPIXELFORMAT* pFormat )
{
    AMTRACE((TEXT("CVideoPortObj::GetOutputFormat")));
    CAutoLock cObjectLock(m_pMainObjLock);

    *pFormat = m_ddVPOutputVideoFormat;
    return S_OK;
}

/******************************Public*Routine******************************\
* CVideoPortObj::SetVideoPortID
*
*
*
* History:
* Thu 09/09/1999 - GlennE - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetVideoPortID( DWORD dwVideoPortId )
{
    AMTRACE((TEXT("CVideoPortObj::SetVideoPortID")));
    CAutoLock cObjectLock(m_pMainObjLock);

    HRESULT hr = S_OK;
    if ( m_dwVideoPortId != dwVideoPortId ) {
        // we can't switch ports when running
        if( m_VPState != VPInfoState_STOPPED ) {
            hr = VFW_E_WRONG_STATE;
        } else {
            if( m_pDVP ) {
                hr = VPMUtil::FindVideoPortCaps( m_pDVP, NULL, m_dwVideoPortId );
            } else {
                LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
                hr = VPMUtil::FindVideoPortCaps( pDirectDraw, NULL, m_dwVideoPortId );
            }
            if( hr == S_OK) {
                m_dwVideoPortId = dwVideoPortId;
            } else if( hr == S_FALSE ) {
                return E_INVALIDARG;
            }// else fail 
        }
    }
    return hr;
}

static HRESULT GetRectFromImage( LPDIRECTDRAWSURFACE7 pSurf, RECT* pRect )
{
    // assume entire dest for now ....
    DDSURFACEDESC2 ddsd;
    INITDDSTRUCT( ddsd );
    HRESULT hr = pSurf->GetSurfaceDesc( &ddsd );
    if ( SUCCEEDED(hr) ) {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = ddsd.dwWidth;
        pRect->bottom = ddsd.dwHeight;
    }
    return hr;
}

#ifdef DEBUG
// #define DEBUG_BLTS
#endif

#ifdef DEBUG_BLTS
static BYTE Clamp(float clr)
{
    if (clr < 0.0f) {
        return (BYTE)0;
    } else if (clr > 255.0f) {
        return (BYTE)255;
    } else {
        return (BYTE)clr;
    }
}

static RGBQUAD
ConvertYCrCbToRGB(
    int y,
    int cr,
    int cb
    )
{
    RGBQUAD rgbq;

    float r = (1.1644f * (y-16)) + (1.5960f * (cr-128));
    float g = (1.1644f * (y-16)) - (0.8150f * (cr-128)) - (0.3912f * (cb-128));
    float b = (1.1644f * (y-16))                        + (2.0140f * (cb-128));


    rgbq.rgbBlue  = Clamp(b);
    rgbq.rgbGreen = Clamp(g);
    rgbq.rgbRed   = Clamp(r);
    rgbq.rgbReserved = 0; // Alpha

    return rgbq;
}

static void MyCopyBlt( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect, const UINT pixelSize )
{
    const LONG srcPitch = ddsdS.lPitch;
    const LONG destPitch = ddsdT.lPitch;

    const BYTE* pSrc = (BYTE *)ddsdS.lpSurface + pSrcRect->left * pixelSize;
    BYTE* pDest = (BYTE *)ddsdT.lpSurface + pDestRect->left * pixelSize;

    const UINT LineLength = (pSrcRect->right - pSrcRect->left) * pixelSize;

    for( INT y=pSrcRect->top; y < pSrcRect->bottom; y++ ) {
        CopyMemory( pDest + y * destPitch, pSrc + y * srcPitch, LineLength );
    }

}

static void CopyYUY2LineToRGBA( BYTE* pDest, const BYTE* pSrc, UINT width )
{
    while( width > 0 ) {
        int  y0 = (int)pSrc[0];
        int  cb = (int)pSrc[1];
        int  y1 = (int)pSrc[2];
        int  cr = (int)pSrc[3];

        pSrc += 4;

        RGBQUAD r = ConvertYCrCbToRGB(y0, cr, cb);
        pDest[0] = r.rgbBlue;
        pDest[1] = r.rgbGreen;
        pDest[2] = r.rgbRed;
        pDest[3] = 0; // Alpha

        pDest +=4;

        width--;
        if( width > 0 ) {
            pDest[0] = r.rgbBlue;
            pDest[1] = r.rgbGreen;
            pDest[2] = r.rgbRed;
            pDest[3] = 0; // Alpha

            pDest +=4;
            width--;
        }
    }   
}

static void MyCopyYUY2ToRGBA( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect )
{
    const LONG srcPitch = ddsdS.lPitch;
    const LONG destPitch = ddsdT.lPitch;

    ASSERT( (pSrcRect->left & 1) == 0 ); // can only convert on even edges for now
    ASSERT( (pSrcRect->right & 1) == 0 ); // can only convert on even edges for now
    
    const BYTE* pSrc = (BYTE *)ddsdS.lpSurface + pSrcRect->left * 2;
    BYTE* pDest = (BYTE *)ddsdT.lpSurface + pDestRect->left * 4;

    const UINT LineWidth = (pSrcRect->right - pSrcRect->left);

    for( INT y=pSrcRect->top; y < pSrcRect->bottom; y++ ) {
        CopyYUY2LineToRGBA( pDest + y * destPitch, pSrc + y * srcPitch, LineWidth );
    }

}

static void MyCopyYUY2Blt( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect )
{
	MyCopyBlt( ddsdS, pSrcRect, ddsdT, pDestRect,2 );
}

static void MyCopyUYVYBlt( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect )
{
	MyCopyBlt( ddsdS, pSrcRect, ddsdT, pDestRect,2 );
}

// handy debugging routine to test faulty UYVY blits
static HRESULT MyCopyUYVYSurf( LPDIRECTDRAWSURFACE7 pDestSurf, const RECT* pDestRect, LPDIRECTDRAWSURFACE7 pSrcSurf, const RECT* pSrcRect )
{
    DDSURFACEDESC2 ddsdS = {sizeof(ddsdS)};
    DDSURFACEDESC2 ddsdT = {sizeof(ddsdT)};

    HRESULT hr = pSrcSurf->Lock(NULL, &ddsdS, DDLOCK_NOSYSLOCK, NULL);
    ASSERT( SUCCEEDED( hr));
    if (hr != DD_OK) {
        return hr;
    }

    hr = pDestSurf->Lock(NULL, &ddsdT, DDLOCK_NOSYSLOCK, NULL);
    ASSERT( SUCCEEDED( hr));
    if (hr != DD_OK) {
        pSrcSurf->Unlock(NULL);
        return hr;
    }

    ASSERT( WIDTH( pSrcRect ) == WIDTH( pDestRect) );
    ASSERT( HEIGHT( pSrcRect ) == HEIGHT( pDestRect) );

    // we should not do conversions in the VPM, let the VMR do the work
    ASSERT( ddsdS.ddpfPixelFormat.dwFourCC == ddsdT.ddpfPixelFormat.dwFourCC );

	if( ddsdS.ddpfPixelFormat.dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y' ) &&
		ddsdT.ddpfPixelFormat.dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y' ) ) {
		MyCopyUYVYBlt( ddsdS, pSrcRect, ddsdT, pDestRect );
	} else
	if( ddsdS.ddpfPixelFormat.dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2' ) &&
		ddsdT.ddpfPixelFormat.dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2' ) ) {
		MyCopyYUY2Blt( ddsdS, pSrcRect, ddsdT, pDestRect );
    } else {
	// if( ddsdS.ddpfPixelFormat.dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2' ) &&
	//	ddsdT.ddpfPixelFormat.dwFourCC == 0 ) {
	// 	MyCopyYUY2ToRGBA( ddsdS, pSrcRect, ddsdT, pDestRect );
	// } else {
		ASSERT( !"Can't handle MyBlt format" );
	}

    pSrcSurf->Unlock(NULL);
    pDestSurf->Unlock(NULL);
    return S_OK;
}

#endif

static LPDIRECTDRAW7 GetDDrawFromSurface( LPDIRECTDRAWSURFACE7 pDestSurface )
{
    IUnknown  *pDDrawObjUnk ;
    HRESULT hr = pDestSurface->GetDDInterface((LPVOID*)&pDDrawObjUnk) ;
    if (SUCCEEDED(hr) ) {
        LPDIRECTDRAW7 pDDObj;
        hr = pDDrawObjUnk->QueryInterface(IID_IDirectDraw7, (LPVOID *) &pDDObj);
        pDDrawObjUnk->Release();
        if( SUCCEEDED( hr )) {
            return pDDObj;
        }
    }
    return NULL;
}

HRESULT CVideoPortObj::CallUpdateSurface( DWORD dwSourceIndex, LPDIRECTDRAWSURFACE7 pDestSurface )
{
    if ( dwSourceIndex > m_dwBackBufferCount ) {
        ASSERT( !"Invalid source index" );
        return E_INVALIDARG;
    }
    //Debug: use the previous surface
    // DWORD dwNumSurfaces= m_dwBackBufferCount+1;
    // dwSourceIndex = (dwNumSurfaces+dwSourceIndex-1) % dwNumSurfaces;

    ASSERT( m_pChain );
    LPDIRECTDRAWSURFACE7 pSourceSurface = m_pChain[dwSourceIndex].pDDSurf;

    // if we fail at this point, something is really wrong
    ASSERT( pDestSurface );
    ASSERT( pSourceSurface );

    if( !pSourceSurface || !pDestSurface ) {
        return E_FAIL;
    }
    // gather stats to verify distribution of surfaces
    m_pChain[dwSourceIndex].dwCount++;

    HRESULT hr = S_OK;

    RECT rSrc = m_VPDataInfo.amvpDimInfo.rcValidRegion;

    if( m_CropState == VPInfoCropState_AtVideoPort ) {
        // if cropping at the videoport, final image is translated back to (0,0)
        rSrc.right = WIDTH( &rSrc );
        rSrc.bottom = HEIGHT( &rSrc );
        rSrc.left = 0;
        rSrc.top = 0;
    }
    if( m_fGarbageLine ) {
        // crop top line
        rSrc.top ++;
        rSrc.bottom --;
    }
    if( !m_fHalfHeightVideo ) {
        // Bob interleaved or weave, so grab both fields (rcValidRegion is 0..240)
        rSrc.top *=2;
        rSrc.bottom *=2;
    }
    // Could watch the media type, however this is more reliable.
#ifdef DEBUG
    // Make sure the source fits into the destination
    {
        RECT rDest;
        hr = GetRectFromImage( pDestSurface, &rDest );
        if( SUCCEEDED( hr )) {
            ASSERT( rDest.bottom >= rSrc.bottom );
            ASSERT( rDest.right >= rSrc.right );
        }
    }
#endif

    RECT rDest = rSrc;


#ifdef DEBUG_BLTS
    // debugging to track down faulty BltFourCC blits
    hr = MyCopyUYVYSurf( pDestSurface, &rDest, pSourceSurface, &rSrc );
#else
    hr = pDestSurface->Blt(&rDest, pSourceSurface, &rSrc, DDBLT_WAIT, NULL);
#endif
    // retry on lost surface
    if ( DDERR_SURFACELOST == hr )
    {
        LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
        if( pDirectDraw && pDirectDraw->TestCooperativeLevel() == DD_OK ) {
            // otherwise the kernel dxg.sys is out of sync with DDraw
            ASSERT( pDestSurface->IsLost() == DDERR_SURFACELOST ||  pSourceSurface->IsLost() == DDERR_SURFACELOST );

            // check the destination.  If we can't restore it, then we don't want to even both with the source

            hr = pDestSurface->IsLost();
            if( hr == DDERR_SURFACELOST ) {
                // restore the DestSurface (passed to us, possibly a different DDrawObject)
                // We can't just restore the surface since it could be an implicit surface that is part of a flipping
                // chain, so we have to tell DDraw to restore everything on that thread

                LPDIRECTDRAW7 pDestDirectDraw = GetDDrawFromSurface( pDestSurface );
                if( pDestDirectDraw ) {
                    hr = pDestDirectDraw->RestoreAllSurfaces();
                    pDestDirectDraw->Release();
                }
                if( SUCCEEDED( hr )) {
                    hr = pDestSurface->IsLost();
                }
            }

            if( hr != DDERR_SURFACELOST ) {
                // valid destination, fix the source
                hr = pSourceSurface->IsLost();

                if( hr == DDERR_SURFACELOST ) {
                    hr = m_pOutputSurface->Restore();
                    if( FAILED( hr )) {
                        DbgLog((LOG_ERROR, 0,  TEXT("CallUpdateSurface Blt() restore source failed, hr = %d"), hr & 0xffff));
                    } else {
                        // kick the videoport (G400 seems to stop playing)

                        // the surfaces are disconnected from the video port when they are lost, so reconnect them
                        hr = StartVideoWithRetry();
                    }
                    if( SUCCEEDED( hr )) {
				        // recompute the source image pointer incase StartVideoWithRetry recreated the surfaces
				        pSourceSurface = m_pChain[dwSourceIndex].pDDSurf;
                    }
                }
                if( SUCCEEDED( hr ) ) {
                    hr = pDestSurface->Blt(&rDest,
                                        pSourceSurface, &rSrc,
                                        DDBLT_WAIT, NULL);
                }
            }
        } else {
#ifdef DEBUG
            // HRESULT coop= pDirectDraw ? pDirectDraw->TestCooperativeLevel() : E_FAIL;
            // DbgLog((LOG_ERROR, 0,  TEXT("TestCoopLevel failed, hr = %d"), coop & 0xffff));
#endif
        }
    } else {
        ASSERT( SUCCEEDED( hr ));
    }
    // filter DERR_SURFACELOST since in DOS boxes, we'll continually fail the blit
    if (DDERR_SURFACELOST != hr  && FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,  TEXT("CallUpdateSurface Blt() failed, hr = %d"), hr & 0xffff));
    }
    return hr;
}

HRESULT CVideoPortObj::GetMode( AMVP_MODE* pMode )
{
    *pMode = m_CurrentMode;
    return S_OK;
}

//==========================================================================
HRESULT CVideoPortObj::GetMediaType(int iPosition, CMediaType* pmt)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVideoPortObj::GetMediaType")));

    HRESULT hr = S_OK;

    if (iPosition == 0)
    {
        pmt->SetType(&MEDIATYPE_Video);
        pmt->SetSubtype(&MEDIASUBTYPE_VPVideo);
        pmt->SetFormatType(&FORMAT_None);
        pmt->SetSampleSize(1);
        pmt->SetTemporalCompression(FALSE);
    }
    else if (iPosition > 0)  {
        hr = VFW_S_NO_MORE_ITEMS;
    } else { // iPosition < 0
        hr = E_INVALIDARG;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\image2\wm\winctrl.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Video control interface base classes, December 1995

#include <streams.h>

#include "..\video\VMRenderer.h"
#include "vmrwinctrl.h"
#include "vmrwindow.h"


// The control interface methods require us to be connected

#define CheckConnected(filter,code)                     \
{                                                       \
    if (filter == NULL) {                               \
        ASSERT(!TEXT("Filter not set"));                \
    } else if (filter->NumInputPinsConnected() == 0) {  \
        return (code);                                  \
    }                                                   \
}

// This checks to see whether the window has a drain. An application can in
// most environments set the owner/parent of windows so that they appear in
// a compound document context (for example). In this case, the application
// would probably like to be told of any keyboard/mouse messages. Therefore
// we pass these messages on untranslated, returning TRUE if we're successful

BOOL WINAPI VMRPossiblyEatMessage(HWND hwndDrain, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (hwndDrain != NULL && !InSendMessage())
    {
        switch (uMsg)
        {
            case WM_CHAR:
            case WM_DEADCHAR:
            case WM_KEYDOWN:
            case WM_KEYUP:
            case WM_LBUTTONDBLCLK:
            case WM_LBUTTONDOWN:
            case WM_LBUTTONUP:
            case WM_MBUTTONDBLCLK:
            case WM_MBUTTONDOWN:
            case WM_MBUTTONUP:
            case WM_MOUSEACTIVATE:
            case WM_MOUSEMOVE:
            // If we pass this on we don't get any mouse clicks
            //case WM_NCHITTEST:
            case WM_NCLBUTTONDBLCLK:
            case WM_NCLBUTTONDOWN:
            case WM_NCLBUTTONUP:
            case WM_NCMBUTTONDBLCLK:
            case WM_NCMBUTTONDOWN:
            case WM_NCMBUTTONUP:
            case WM_NCMOUSEMOVE:
            case WM_NCRBUTTONDBLCLK:
            case WM_NCRBUTTONDOWN:
            case WM_NCRBUTTONUP:
            case WM_RBUTTONDBLCLK:
            case WM_RBUTTONDOWN:
            case WM_RBUTTONUP:
            case WM_SYSCHAR:
            case WM_SYSDEADCHAR:
            case WM_SYSKEYDOWN:
            case WM_SYSKEYUP:

                DbgLog((LOG_TRACE, 2, TEXT("Forwarding %x to drain")));
                PostMessage(hwndDrain, uMsg, wParam, lParam);

                return TRUE;
        }
    }
    return FALSE;
}


// This class implements the IVideoWindow control functions (dual interface)
// we support a large number of properties and methods designed to allow the
// client (whether it be an automation controller or a C/C++ application) to
// set and get a number of window related properties such as it's position.
// We also support some methods that duplicate the properties but provide a
// more direct and efficient mechanism as many values may be changed in one

CVMRBaseControlWindow::CVMRBaseControlWindow(
                        CVMRFilter *pFilter,         // Owning filter
                        CCritSec *pInterfaceLock,    // Locking object
                        TCHAR *pName,                // Object description
                        LPUNKNOWN pUnk,              // Normal COM ownership
                        HRESULT *phr) :              // OLE return code

    CBaseVideoWindow(pName,pUnk),
    m_pInterfaceLock(pInterfaceLock),
    m_hwndOwner(NULL),
    m_hwndDrain(NULL),
    m_bAutoShow(TRUE),
    m_pFilter(pFilter),
    m_bCursorHidden(FALSE)
{
    ASSERT(m_pFilter);
    ASSERT(m_pInterfaceLock);
    ASSERT(phr);
    m_BorderColour = VIDEO_COLOUR;
}


// Set the title caption on the base window, we don't do any field checking
// as we really don't care what title they intend to have. We can always get
// it back again later with GetWindowText. The only other complication is to
// do the necessary string conversions between ANSI and OLE Unicode strings

STDMETHODIMP CVMRBaseControlWindow::put_Caption(BSTR strCaption)
{
    AMTRACE((TEXT("put_Caption"), 1));
    CheckPointer(strCaption,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
#ifdef UNICODE
    SetWindowText(m_hwnd, strCaption);
#else
    CHAR Caption[CAPTION];

    WideCharToMultiByte(CP_ACP,0,strCaption,-1,Caption,CAPTION,NULL,NULL);
    SetWindowText(m_hwnd, Caption);
#endif
    return NOERROR;
}


// Get the current base window title caption, once again we do no real field
// checking. We allocate a string for the window title to be filled in with
// which ensures the interface doesn't fiddle around with getting memory. A
// BSTR is a normal C string with the length at position (-1), we use the
// WriteBSTR helper function to create the caption to try and avoid OLE32

STDMETHODIMP CVMRBaseControlWindow::get_Caption(BSTR *pstrCaption)
{
    AMTRACE((TEXT("get_Caption"), 1));
    CheckPointer(pstrCaption,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    WCHAR WideCaption[CAPTION];

#ifdef UNICODE
    GetWindowText(m_hwnd,WideCaption,CAPTION);
#else
    // Convert the ASCII caption to a UNICODE string

    TCHAR Caption[CAPTION];
    GetWindowText(m_hwnd,Caption,CAPTION);
    MultiByteToWideChar(CP_ACP,0,Caption,-1,WideCaption,CAPTION);
#endif
    return WriteBSTR(pstrCaption,WideCaption);
}


// Set the window style using GWL_EXSTYLE

STDMETHODIMP CVMRBaseControlWindow::put_WindowStyleEx(long WindowStyleEx)
{
    AMTRACE((TEXT("put_WindowStyleEx"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Should we be taking off WS_EX_TOPMOST

    if (GetWindowLong(m_hwnd,GWL_EXSTYLE) & WS_EX_TOPMOST) {
        if ((WindowStyleEx & WS_EX_TOPMOST) == 0) {
            SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) FALSE,(LPARAM) 0);
        }
    }

    // Likewise should we be adding WS_EX_TOPMOST

    if (WindowStyleEx & WS_EX_TOPMOST) {
        SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) TRUE,(LPARAM) 0);
        WindowStyleEx &= (~WS_EX_TOPMOST);
        if (WindowStyleEx == 0) return NOERROR;
    }
    return DoSetWindowStyle(WindowStyleEx,GWL_EXSTYLE);
}


// Gets the current GWL_EXSTYLE base window style

STDMETHODIMP CVMRBaseControlWindow::get_WindowStyleEx(long *pWindowStyleEx)
{
    AMTRACE((TEXT("get_WindowStyleEx"), 1));
    CheckPointer(pWindowStyleEx,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    return DoGetWindowStyle(pWindowStyleEx,GWL_EXSTYLE);
}


// Set the window style using GWL_STYLE

STDMETHODIMP CVMRBaseControlWindow::put_WindowStyle(long WindowStyle)
{
    AMTRACE((TEXT("put_WindowStyle"), 1));
    // These styles cannot be changed dynamically

    if ((WindowStyle & WS_DISABLED) ||
        (WindowStyle & WS_ICONIC) ||
        (WindowStyle & WS_MAXIMIZE) ||
        (WindowStyle & WS_MINIMIZE) ||
        (WindowStyle & WS_HSCROLL) ||
        (WindowStyle & WS_VSCROLL)) {

            return E_INVALIDARG;
    }

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    return DoSetWindowStyle(WindowStyle,GWL_STYLE);
}


// Get the current GWL_STYLE base window style

STDMETHODIMP CVMRBaseControlWindow::get_WindowStyle(long *pWindowStyle)
{
    AMTRACE((TEXT("get_WindowStyle"), 1));
    CheckPointer(pWindowStyle,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    return DoGetWindowStyle(pWindowStyle,GWL_STYLE);
}


// Change the base window style or the extended styles depending on whether
// WindowLong is GWL_STYLE or GWL_EXSTYLE. We must call SetWindowPos to have
// the window displayed in it's new style after the change which is a little
// tricky if the window is not currently visible as we realise it offscreen.
// In most cases the client will call get_WindowStyle before they call this
// and then AND and OR in extra bit settings according to the requirements

HRESULT CVMRBaseControlWindow::DoSetWindowStyle(long Style,long WindowLong)
{
    RECT WindowRect;

    // Get the window's visibility before setting the style
    BOOL bVisible = IsWindowVisible(m_hwnd);
    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    // Set the new style flags for the window
    SetWindowLong(m_hwnd,WindowLong,Style);
    UINT WindowFlags = SWP_SHOWWINDOW | SWP_FRAMECHANGED | SWP_NOACTIVATE;
    WindowFlags |= SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE;

    // Show the window again in the current position

    if (bVisible == TRUE) {

        SetWindowPos(m_hwnd,            // Base window handle
                     HWND_TOP,          // Just a place holder
                     0,0,0,0,           // Leave size and position
                     WindowFlags);      // Just draw it again

        return NOERROR;
    }

    // Move the window offscreen so the user doesn't see the changes

    MoveWindow((HWND) m_hwnd,                     // Base window handle
               GetSystemMetrics(SM_CXSCREEN),     // Current desktop width
               GetSystemMetrics(SM_CYSCREEN),     // Likewise it's height
               WIDTH(&WindowRect),                // Use the same width
               HEIGHT(&WindowRect),               // Keep height same to
               TRUE);                             // May as well repaint

    // Now show the previously hidden window

    SetWindowPos(m_hwnd,            // Base window handle
                 HWND_TOP,          // Just a place holder
                 0,0,0,0,           // Leave size and position
                 WindowFlags);      // Just draw it again

    EXECUTE_ASSERT(ShowWindow(m_hwnd,SW_HIDE));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    MoveWindow((HWND) m_hwnd,        // Base window handle
               WindowRect.left,      // Existing x coordinate
               WindowRect.top,       // Existing y coordinate
               WIDTH(&WindowRect),   // Use the same width
               HEIGHT(&WindowRect),  // Keep height same to
               TRUE);                // May as well repaint

    return NOERROR;
}


// Get the current base window style (either GWL_STYLE or GWL_EXSTYLE)

HRESULT CVMRBaseControlWindow::DoGetWindowStyle(long *pStyle,long WindowLong)
{
    *pStyle = GetWindowLong(m_hwnd,WindowLong);
    return NOERROR;
}


// Change the visibility of the base window, this takes the same parameters
// as the ShowWindow Win32 API does, so the client can have the window hidden
// or shown, minimised to an icon, or maximised to play in full screen mode
// We pass the request on to the base window to actually make the change

STDMETHODIMP CVMRBaseControlWindow::put_WindowState(long WindowState)
{
    AMTRACE((TEXT("put_WindowState"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    DoShowWindow(WindowState);
    return NOERROR;
}


// Get the current window state, this function returns a subset of the SW bit
// settings available in ShowWindow, if the window is visible then SW_SHOW is
// set, if it is hidden then the SW_HIDDEN is set, if it is either minimised
// or maximised then the SW_MINIMIZE or SW_MAXIMIZE is set respectively. The
// other SW bit settings are really set commands not readable output values

STDMETHODIMP CVMRBaseControlWindow::get_WindowState(long *pWindowState)
{
    AMTRACE((TEXT("get_WindowState"), 1));
    CheckPointer(pWindowState,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    ASSERT(pWindowState);
    *pWindowState = FALSE;

    // Is the window visible, a window is termed visible if it is somewhere on
    // the current desktop even if it is completely obscured by other windows
    // so the flag is a style for each window set with the WS_VISIBLE bit

    if (IsWindowVisible(m_hwnd) == TRUE) {

        // Is the base window iconic
        if (IsIconic(m_hwnd) == TRUE) {
            *pWindowState |= SW_MINIMIZE;
        }

        // Has the window been maximised
        else if (IsZoomed(m_hwnd) == TRUE) {
            *pWindowState |= SW_MAXIMIZE;
        }

        // Window is normal
        else {
            *pWindowState |= SW_SHOW;
        }

    } else {
        *pWindowState |= SW_HIDE;
    }
    return NOERROR;
}


// This makes sure that any palette we realise in the base window (through a
// media type or through the overlay interface) is done in the background and
// is therefore mapped to existing device entries rather than taking it over
// as it will do when we this window gets the keyboard focus. An application
// uses this to make sure it doesn't have it's palette removed by the window

STDMETHODIMP CVMRBaseControlWindow::put_BackgroundPalette(long BackgroundPalette)
{
    AMTRACE((TEXT("put_BackgroundPalette"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cWindowLock(&m_WindowLock);

    // Check this is a valid automation boolean type

    if (BackgroundPalette != OATRUE) {
        if (BackgroundPalette != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    // Make sure the window realises any palette it has again

    m_bBackground = (BackgroundPalette == OATRUE ? TRUE : FALSE);
    PostMessage(m_hwnd,m_RealizePalette,0,0);
    PaintWindow(FALSE);

    return NOERROR;
}


// This returns the current background realisation setting

STDMETHODIMP
CVMRBaseControlWindow::get_BackgroundPalette(long *pBackgroundPalette)
{
    AMTRACE((TEXT("get_BackgroundPalette"), 1));
    CheckPointer(pBackgroundPalette,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cWindowLock(&m_WindowLock);

    // Get the current background palette setting

    *pBackgroundPalette = (m_bBackground == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// Change the visibility of the base window

STDMETHODIMP CVMRBaseControlWindow::put_Visible(long Visible)
{
    AMTRACE((TEXT("put_Visible"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Check this is a valid automation boolean type

    if (Visible != OATRUE) {
        if (Visible != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    // Convert the boolean visibility into SW_SHOW and SW_HIDE

    INT Mode = (Visible == OATRUE ? SW_SHOWNORMAL : SW_HIDE);
    DoShowWindow(Mode);
    return NOERROR;
}


// Return OATRUE if the window is currently visible otherwise OAFALSE

STDMETHODIMP CVMRBaseControlWindow::get_Visible(long *pVisible)
{
    AMTRACE((TEXT("get_Visible"), 1));
    CheckPointer(pVisible,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // See if the base window has a WS_VISIBLE style - this will return TRUE
    // even if the window is completely obscured by other desktop windows, we
    // return FALSE if the window is not showing because of earlier calls

    BOOL Mode = IsWindowVisible(m_hwnd);
    *pVisible = (Mode == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// Change the left position of the base window. This keeps the window width
// and height properties the same so it effectively shunts the window left or
// right accordingly - there is the Width property to change that dimension

STDMETHODIMP CVMRBaseControlWindow::put_Left(long Left)
{
    AMTRACE((TEXT("put_Left"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Get the current window position in a RECT
    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    WindowRect.bottom = WindowRect.bottom - WindowRect.top;
    WindowRect.right = WindowRect.right - WindowRect.left;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            Left,                  // New left position
                            WindowRect.top,        // Leave top alone
                            WindowRect.right,      // The WIDTH (not right)
                            WindowRect.bottom,     // The HEIGHT (not bottom)
                            WindowFlags);          // Show window options

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window left position

STDMETHODIMP CVMRBaseControlWindow::get_Left(long *pLeft)
{
    AMTRACE((TEXT("get_Left"), 1));
    CheckPointer(pLeft,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pLeft = WindowRect.left;
    return NOERROR;
}


// Change the current width of the base window. This property complements the
// left position property so we must keep the left edge constant and expand or
// contract to the right, the alternative would be to change the left edge so
// keeping the right edge constant but this is maybe a little more intuitive

STDMETHODIMP CVMRBaseControlWindow::put_Width(long Width)
{
    AMTRACE((TEXT("put_Width"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    WindowRect.bottom = WindowRect.bottom - WindowRect.top;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    // This seems to have a bug in that calling SetWindowPos on a window with
    // just the width changing causes it to ignore the width that you pass in
    // and sets it to a mimimum value of 110 pixels wide (Windows NT 3.51)

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            WindowRect.left,       // Leave left alone
                            WindowRect.top,        // Leave top alone
                            Width,                 // New WIDTH dimension
                            WindowRect.bottom,     // The HEIGHT (not bottom)
                            WindowFlags);          // Show window options

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window width

STDMETHODIMP CVMRBaseControlWindow::get_Width(long *pWidth)
{
    AMTRACE((TEXT("get_Width"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pWidth = WindowRect.right - WindowRect.left;
    return NOERROR;
}


// This allows the client program to change the top position for the window in
// the same way that changing the left position does not affect the width of
// the image so changing the top position does not affect the window height

STDMETHODIMP CVMRBaseControlWindow::put_Top(long Top)
{
    AMTRACE((TEXT("put_Top"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Get the current window position in a RECT
    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    WindowRect.bottom = WindowRect.bottom - WindowRect.top;
    WindowRect.right = WindowRect.right - WindowRect.left;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            WindowRect.left,       // Leave left alone
                            Top,                   // New top position
                            WindowRect.right,      // The WIDTH (not right)
                            WindowRect.bottom,     // The HEIGHT (not bottom)
                            WindowFlags);          // Show window flags

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window top position

STDMETHODIMP CVMRBaseControlWindow::get_Top(long *pTop)
{
    AMTRACE((TEXT("get_Top"), 1));
    CheckPointer(pTop,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pTop = WindowRect.top;
    return NOERROR;
}


// Change the height of the window, this complements the top property so when
// we change this we must keep the top position for the base window, as said
// before we could keep the bottom and grow upwards although this is perhaps
// a little more intuitive since we already have a top position property

STDMETHODIMP CVMRBaseControlWindow::put_Height(long Height)
{
    AMTRACE((TEXT("put_Height"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    WindowRect.right = WindowRect.right - WindowRect.left;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            WindowRect.left,       // Leave left alone
                            WindowRect.top,        // Leave top alone
                            WindowRect.right,      // The WIDTH (not right)
                            Height,                // New height dimension
                            WindowFlags);          // Show window flags

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window height

STDMETHODIMP CVMRBaseControlWindow::get_Height(long *pHeight)
{
    AMTRACE((TEXT("get_Height"), 1));
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pHeight = WindowRect.bottom - WindowRect.top;
    return NOERROR;
}


// This can be called to change the owning window. Setting the owner is done
// through this function, however to make the window a true child window the
// style must also be set to WS_CHILD. After resetting the owner to NULL an
// application should also set the style to WS_OVERLAPPED | WS_CLIPCHILDREN.

// We cannot lock the object here because the SetParent causes an interthread
// SendMessage to the owner window. If they are in GetState we will sit here
// incomplete with the critical section locked therefore blocking out source
// filter threads from accessing us. Because the source thread can't enter us
// it can't get buffers or call EndOfStream so the GetState will not complete

STDMETHODIMP CVMRBaseControlWindow::put_Owner(OAHWND Owner)
{
    AMTRACE((TEXT("put_Owner"), 1));
    // Check we are connected otherwise reject the call

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    m_hwndOwner = (HWND) Owner;
    HWND hwndParent = m_hwndOwner;

    // Add or remove WS_CHILD as appropriate

    LONG Style = GetWindowLong(m_hwnd,GWL_STYLE);
    if (Owner == NULL) {
        Style &= (~WS_CHILD);
    } else {
        Style |= (WS_CHILD);
    }
    SetWindowLong(m_hwnd,GWL_STYLE,Style);

    // Don't call this with the filter locked

    SetParent(m_hwnd,hwndParent);

    PaintWindow(TRUE);
    NOTE1("Changed parent %lx",hwndParent);

    return NOERROR;
}


// This complements the put_Owner to get the current owning window property
// we always return NOERROR although the returned window handle may be NULL
// to indicate no owning window (the desktop window doesn't qualify as one)
// If an application sets the owner we call SetParent, however that returns
// NULL until the WS_CHILD bit is set on, so we store the owner internally

STDMETHODIMP CVMRBaseControlWindow::get_Owner(OAHWND *Owner)
{
    AMTRACE((TEXT("get_Owner"), 1));
    CheckPointer(Owner,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *Owner = (OAHWND) m_hwndOwner;
    return NOERROR;
}


// And renderer supporting IVideoWindow may have an HWND set who will get any
// keyboard and mouse messages we receive posted on to them. This is separate
// from setting an owning window. By separating the two, applications may get
// messages sent on even when they have set no owner (perhaps it's maximised)

STDMETHODIMP CVMRBaseControlWindow::put_MessageDrain(OAHWND Drain)
{
    AMTRACE((TEXT("put_MessageDrain"), 1));
    // Check we are connected otherwise reject the call

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    m_hwndDrain = (HWND) Drain;
    return NOERROR;
}


// Return the current message drain

STDMETHODIMP CVMRBaseControlWindow::get_MessageDrain(OAHWND *Drain)
{
    AMTRACE((TEXT("get_MessageDrain"), 1));
    CheckPointer(Drain,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *Drain = (OAHWND) m_hwndDrain;
    return NOERROR;
}


// This is called by the filter graph to inform us of a message we should know
// is being sent to our owning window. We have this because as a child window
// we do not get certain messages that are only sent to top level windows. We
// must see the palette changed/changing/query messages so that we know if we
// have the foreground palette or not. We pass the message on to our window
// using SendMessage - this will cause an interthread send message to occur

STDMETHODIMP
CVMRBaseControlWindow::NotifyOwnerMessage(OAHWND hwnd,    // Window handle
                                       long uMsg,    // Message ID
                                       LONG_PTR wParam,  // Parameters
                                       LONG_PTR lParam)  // for message
{
    AMTRACE((TEXT("NotifyOwnerMessage"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Only interested in these Windows messages

    switch (uMsg) {

        case WM_SYSCOLORCHANGE:
        case WM_PALETTECHANGED:
        case WM_PALETTEISCHANGING:
        case WM_QUERYNEWPALETTE:
        case WM_DEVMODECHANGE:
        case WM_DISPLAYCHANGE:
        case WM_ACTIVATEAPP:

            // If we do not have an owner then ignore

            if (m_hwndOwner == NULL) {
                return NOERROR;
            }
            SendMessage(m_hwnd,uMsg,(WPARAM)wParam,(LPARAM)lParam);
	    break;

	// do NOT fwd WM_MOVE. the parameters are the location of the parent
	// window, NOT what the renderer should be looking at.  But we need
	// to make sure the overlay is moved with the parent window, so we
	// do this.
	case WM_MOVE:
	    PostMessage(m_hwnd,WM_PAINT,0,0);
	    break;
    }
    return NOERROR;
}


// Allow an application to have us set the base window in the foreground. We
// have this because it is difficult for one thread to do do this to a window
// owned by another thread. We ask the base window class to do the real work

STDMETHODIMP CVMRBaseControlWindow::SetWindowForeground(long Focus)
{
    AMTRACE((TEXT("SetWindowForeground"), 1));
    // Check this is a valid automation boolean type

    if (Focus != OATRUE) {
        if (Focus != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    // We shouldn't lock as this sends a message

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bFocus = (Focus == OATRUE ? TRUE : FALSE);
    DoSetWindowForeground(bFocus);

    return NOERROR;
}


// This allows a client to set the complete window size and position in one
// atomic operation. The same affect can be had by changing each dimension
// in turn through their individual properties although some flashing will
// occur as each of them gets updated (they are better set at design time)

STDMETHODIMP
CVMRBaseControlWindow::SetWindowPosition(long Left,long Top,long Width,long Height)
{
    AMTRACE((TEXT("SetWindowPosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;

    // Set the new size and position
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    ASSERT(IsWindow(m_hwnd));
    bSuccess = SetWindowPos(m_hwnd,         // Window handle
                            HWND_TOP,       // Put it at the top
                            Left,           // Left position
                            Top,            // Top position
                            Width,          // Window width
                            Height,         // Window height
                            WindowFlags);   // Show window flags
    ASSERT(bSuccess);
#ifdef DEBUG
    DbgLog((LOG_TRACE, 1, TEXT("SWP failed error %d"), GetLastError(), 1));
#endif
    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// This complements the SetWindowPosition to return the current window place
// in device coordinates. As before the same information can be retrived by
// calling the property get functions individually but this is atomic and is
// therefore more suitable to a live environment rather than design time

STDMETHODIMP
CVMRBaseControlWindow::GetWindowPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetWindowPosition"), 1));
    // Should check the pointers are not NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    // Get the current window coordinates

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    // Convert the RECT into left,top,width and height values

    *pLeft = WindowRect.left;
    *pTop = WindowRect.top;
    *pWidth = WindowRect.right - WindowRect.left;
    *pHeight = WindowRect.bottom - WindowRect.top;

    return NOERROR;
}


// When a window is maximised or iconic calling GetWindowPosition will return
// the current window position (likewise for the properties). However if the
// restored size (ie the size we'll return to when normally shown) is needed
// then this should be used. When in a normal position (neither iconic nor
// maximised) then this returns the same coordinates as GetWindowPosition

STDMETHODIMP
CVMRBaseControlWindow::GetRestorePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetRestorePosition"), 1));
    // Should check the pointers are not NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Use GetWindowPlacement to find the restore position

    WINDOWPLACEMENT Place;
    Place.length = sizeof(WINDOWPLACEMENT);
    EXECUTE_ASSERT(GetWindowPlacement(m_hwnd,&Place));

    RECT WorkArea;

    // We must take into account any task bar present

    if (SystemParametersInfo(SPI_GETWORKAREA,0,&WorkArea,FALSE) == TRUE) {
        if (GetParent(m_hwnd) == NULL) {
            Place.rcNormalPosition.top += WorkArea.top;
            Place.rcNormalPosition.bottom += WorkArea.top;
            Place.rcNormalPosition.left += WorkArea.left;
            Place.rcNormalPosition.right += WorkArea.left;
        }
    }

    // Convert the RECT into left,top,width and height values

    *pLeft = Place.rcNormalPosition.left;
    *pTop = Place.rcNormalPosition.top;
    *pWidth = Place.rcNormalPosition.right - Place.rcNormalPosition.left;
    *pHeight = Place.rcNormalPosition.bottom - Place.rcNormalPosition.top;

    return NOERROR;
}


// Return the current border colour, if we are playing something to a subset
// of the base window display there is an outside area exposed. The default
// action is to paint this colour in the Windows background colour (defined
// as value COLOR_WINDOW) We reset to this default when we're disconnected

STDMETHODIMP CVMRBaseControlWindow::get_BorderColor(long *Color)
{
    AMTRACE((TEXT("get_BorderColor"), 1));
    CheckPointer(Color,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *Color = (long) m_BorderColour;
    return NOERROR;
}


// This can be called to set the current border colour

STDMETHODIMP CVMRBaseControlWindow::put_BorderColor(long Color)
{
    AMTRACE((TEXT("put_BorderColor"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Have the window repainted with the new border colour

    m_BorderColour = (COLORREF) Color;
    PaintWindow(TRUE);
    return NOERROR;
}


// Delegate fullscreen handling to plug in distributor

STDMETHODIMP CVMRBaseControlWindow::get_FullScreenMode(long *FullScreenMode)
{
    AMTRACE((TEXT("get_FullScreenMode"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CheckPointer(FullScreenMode,E_POINTER);
    return E_NOTIMPL;
}


// Delegate fullscreen handling to plug in distributor

STDMETHODIMP CVMRBaseControlWindow::put_FullScreenMode(long FullScreenMode)
{
    AMTRACE((TEXT("put_FullScreenMode"), 1));
    return E_NOTIMPL;
}


// This sets the auto show property, this property causes the base window to
// be displayed whenever we change state. This allows an application to have
// to do nothing to have the window appear but still allow them to change the
// default behaviour if for example they want to keep it hidden for longer

STDMETHODIMP CVMRBaseControlWindow::put_AutoShow(long AutoShow)
{
    AMTRACE((TEXT("put_AutoShow"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Check this is a valid automation boolean type

    if (AutoShow != OATRUE) {
        if (AutoShow != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    m_bAutoShow = (AutoShow == OATRUE ? TRUE : FALSE);
    return NOERROR;
}


// This can be called to get the current auto show flag. The flag is updated
// when we connect and disconnect and through this interface all of which are
// controlled and serialised by means of the main renderer critical section

STDMETHODIMP CVMRBaseControlWindow::get_AutoShow(long *AutoShow)
{
    AMTRACE((TEXT("get_AutoShow"), 1));
    CheckPointer(AutoShow,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *AutoShow = (m_bAutoShow == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// Return the minimum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a minimum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRBaseControlWindow::GetMinIdealImageSize(long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetMinIdealImageSize"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    FILTER_STATE State;

    // Must not be stopped for this to work correctly

    m_pFilter->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    RECT DefaultRect = GetDefaultRect();
    *pWidth = WIDTH(&DefaultRect);
    *pHeight = HEIGHT(&DefaultRect);
    return NOERROR;
}


// Return the maximum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a maximum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRBaseControlWindow::GetMaxIdealImageSize(long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetMaxIdealImageSize"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    FILTER_STATE State;

    // Must not be stopped for this to work correctly

    m_pFilter->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    RECT DefaultRect = GetDefaultRect();
    *pWidth = WIDTH(&DefaultRect);
    *pHeight = HEIGHT(&DefaultRect);
    return NOERROR;
}


// Allow an application to hide the cursor on our window

STDMETHODIMP
CVMRBaseControlWindow::HideCursor(long HideCursor)
{
    AMTRACE((TEXT("HideCursor"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Check this is a valid automation boolean type

    if (HideCursor != OATRUE) {
        if (HideCursor != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    m_bCursorHidden = (HideCursor == OATRUE ? TRUE : FALSE);
    return NOERROR;
}


// Returns whether we have the cursor hidden or not

STDMETHODIMP CVMRBaseControlWindow::IsCursorHidden(long *CursorHidden)
{
    AMTRACE((TEXT("IsCursorHidden"), 1));
    CheckPointer(CursorHidden,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *CursorHidden = (m_bCursorHidden == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// This class implements the IBasicVideo control functions (dual interface)
// we support a large number of properties and methods designed to allow the
// client (whether it be an automation controller or a C/C++ application) to
// set and get a number of video related properties such as the native video
// size. We support some methods that duplicate the properties but provide a
// more direct and efficient mechanism as many values may be changed in one

CVMRBaseControlVideo::CVMRBaseControlVideo(
                        CVMRFilter *pFilter,        // Owning filter
                        CCritSec *pInterfaceLock,    // Locking object
                        TCHAR *pName,                // Object description
                        LPUNKNOWN pUnk,              // Normal COM ownership
                        HRESULT *phr) :              // OLE return code

    CBaseBasicVideo(pName,pUnk),
    m_pFilter(pFilter),
    m_pInterfaceLock(pInterfaceLock)
{
    ASSERT(m_pFilter);
    ASSERT(m_pInterfaceLock);
    ASSERT(phr);
}

// Return an approximate average time per frame

STDMETHODIMP CVMRBaseControlVideo::get_AvgTimePerFrame(REFTIME *pAvgTimePerFrame)
{
    AMTRACE((TEXT("get_AvgTimePerFrame"), 1));
    CheckPointer(pAvgTimePerFrame,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    int n = m_pFilter->GetPinCount();
    for (int i = 0; i < n; i++) {

        CBasePin* pPin = m_pFilter->GetPin(i);
        if (pPin && pPin->IsConnected()) {

            AM_MEDIA_TYPE mt;

            if (S_OK == pPin->ConnectionMediaType(&mt)) {

                COARefTime AvgTime(((VIDEOINFOHEADER*)(mt.pbFormat))->AvgTimePerFrame);
                *pAvgTimePerFrame = (REFTIME)AvgTime;

                FreeMediaType(mt);

                return S_OK;
            }
        }
    }

    return E_FAIL;
}


// Return an approximate bit rate for the video

STDMETHODIMP CVMRBaseControlVideo::get_BitRate(long *pBitRate)
{
    AMTRACE((TEXT("get_BitRate"), 1));
    CheckPointer(pBitRate,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    int n = m_pFilter->GetPinCount();
    for (int i = 0; i < n; i++) {

        CBasePin* pPin = m_pFilter->GetPin(i);
        if (pPin && pPin->IsConnected()) {

            AM_MEDIA_TYPE mt;

            if (S_OK == pPin->ConnectionMediaType(&mt)) {

                *pBitRate =
                    ((VIDEOINFOHEADER*)(mt.pbFormat))->dwBitRate;
                FreeMediaType(mt);

                return S_OK;
            }
        }
    }
    return E_FAIL;
}


// Return an approximate bit error rate

STDMETHODIMP CVMRBaseControlVideo::get_BitErrorRate(long *pBitErrorRate)
{
    AMTRACE((TEXT("get_BitErrorRate"), 1));
    CheckPointer(pBitErrorRate,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    int n = m_pFilter->GetPinCount();
    for (int i = 0; i < n; i++) {

        CBasePin* pPin = m_pFilter->GetPin(i);
        if (pPin && pPin->IsConnected()) {

            AM_MEDIA_TYPE mt;

            if (S_OK == pPin->ConnectionMediaType(&mt)) {

                *pBitErrorRate =
                    ((VIDEOINFOHEADER*)(mt.pbFormat))->dwBitErrorRate;
                FreeMediaType(mt);

                return S_OK;
            }
        }
    }
    return E_FAIL;
}


// This returns the current video width

STDMETHODIMP CVMRBaseControlVideo::get_VideoWidth(long *pVideoWidth)
{
    AMTRACE((TEXT("get_VideoWidth"), 1));
    CheckPointer(pVideoWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();
    if (lpWLControl) {
        LONG cy;
        lpWLControl->GetNativeVideoSize(pVideoWidth, &cy, NULL, NULL);
    }
    return NOERROR;
}


// This returns the current video height

STDMETHODIMP CVMRBaseControlVideo::get_VideoHeight(long *pVideoHeight)
{
    AMTRACE((TEXT("get_VideoHeight"), 1));
    CheckPointer(pVideoHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();
    if (lpWLControl) {
        LONG cx;
        lpWLControl->GetNativeVideoSize(&cx, pVideoHeight, NULL, NULL);
    }
    return NOERROR;
}


// This returns the current palette the video is using as an array allocated
// by the user. To remain consistent we use PALETTEENTRY fields to return the
// colours in rather than RGBQUADs that multimedia decided to use. The memory
// is allocated by the user so we simple copy each in turn. We check that the
// number of entries requested and the start position offset are both valid
// If the number of entries evaluates to zero then we return an S_FALSE code

STDMETHODIMP CVMRBaseControlVideo::GetVideoPaletteEntries(long StartIndex,
                                                       long Entries,
                                                       long *pRetrieved,
                                                       long *pPalette)
{
    AMTRACE((TEXT("GetVideoPaletteEntries"), 1));
    CheckPointer(pRetrieved,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    *pRetrieved = 0;
    return VFW_E_NO_PALETTE_AVAILABLE;
}


// This returns the current video dimensions as a method rather than a number
// of individual property get calls. For the same reasons as said before we
// cannot access the renderer media type directly as the window object thread
// may be updating it since dynamic format changes may change these values

STDMETHODIMP CVMRBaseControlVideo::GetVideoSize(long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetVideoSize"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetNativeVideoSize(pWidth, pHeight, NULL, NULL);
    }

    return NOERROR;
}


// Set the source video rectangle as left,top,right and bottom coordinates
// rather than left,top,width and height as per OLE automation interfaces
// Then pass the rectangle on to the window object to set the source

STDMETHODIMP
CVMRBaseControlVideo::SetSourcePosition(long Left,long Top,long Width,long Height)
{
    AMTRACE((TEXT("SetSourcePosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    SourceRect.left = Left;
    SourceRect.top = Top;
    SourceRect.right = Left + Width;
    SourceRect.bottom = Top + Height;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the source rectangle in left,top,width and height rather than the
// left,top,right and bottom values that RECT uses (and which the window
// object returns through GetSourceRect) which requires a little work

STDMETHODIMP
CVMRBaseControlVideo::GetSourcePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetSourcePosition"), 1));
    // Should check the pointers are non NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT SourceRect;

    CAutoLock cInterfaceLock(m_pInterfaceLock);
    GetSourceRect(&SourceRect);

    *pLeft = SourceRect.left;
    *pTop = SourceRect.top;
    *pWidth = WIDTH(&SourceRect);
    *pHeight = HEIGHT(&SourceRect);

    return NOERROR;
}


// Set the video destination as left,top,right and bottom coordinates rather
// than the left,top,width and height uses as per OLE automation interfaces
// Then pass the rectangle on to the window object to set the destination

STDMETHODIMP
CVMRBaseControlVideo::SetDestinationPosition(long Left,long Top,long Width,long Height)
{
    AMTRACE((TEXT("SetDestinationPosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    DestinationRect.left = Left;
    DestinationRect.top = Top;
    DestinationRect.right = Left + Width;
    DestinationRect.bottom = Top + Height;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the destination rectangle in left,top,width and height rather than
// the left,top,right and bottom values that RECT uses (and which the window
// object returns through GetDestinationRect) which requires a little work

STDMETHODIMP
CVMRBaseControlVideo::GetDestinationPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetDestinationPosition"), 1));
    // Should check the pointers are not NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT DestinationRect;

    CAutoLock cInterfaceLock(m_pInterfaceLock);
    GetTargetRect(&DestinationRect);

    *pLeft = DestinationRect.left;
    *pTop = DestinationRect.top;
    *pWidth = WIDTH(&DestinationRect);
    *pHeight = HEIGHT(&DestinationRect);

    return NOERROR;
}


// Set the source left position, the source rectangle we get back from the
// window object is a true rectangle in left,top,right and bottom positions
// so all we have to do is to update the left position and pass it back. We
// must keep the current width constant when we're updating this property

STDMETHODIMP CVMRBaseControlVideo::put_SourceLeft(long SourceLeft)
{
    AMTRACE((TEXT("put_SourceLeft"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.right = SourceLeft + WIDTH(&SourceRect);
    SourceRect.left = SourceLeft;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current left source video position

STDMETHODIMP CVMRBaseControlVideo::get_SourceLeft(long *pSourceLeft)
{
    AMTRACE((TEXT("get_SourceLeft"), 1));
    CheckPointer(pSourceLeft,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceLeft = SourceRect.left;
    return NOERROR;
}


// Set the source width, we get the current source rectangle and then update
// the right position to be the left position (thereby keeping it constant)
// plus the new source width we are passed in (it expands to the right)

STDMETHODIMP CVMRBaseControlVideo::put_SourceWidth(long SourceWidth)
{
    AMTRACE((TEXT("put_SourceWidth"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.right = SourceRect.left + SourceWidth;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current source width

STDMETHODIMP CVMRBaseControlVideo::get_SourceWidth(long *pSourceWidth)
{
    AMTRACE((TEXT("get_SourceWidth"), 1));
    CheckPointer(pSourceWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceWidth = WIDTH(&SourceRect);
    return NOERROR;
}


// Set the source top position - changing this property does not affect the
// current source height. So changing this shunts the source rectangle up and
// down appropriately. Changing the height complements this functionality by
// keeping the top position constant and simply changing the source height

STDMETHODIMP CVMRBaseControlVideo::put_SourceTop(long SourceTop)
{
    AMTRACE((TEXT("put_SourceTop"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.bottom = SourceTop + HEIGHT(&SourceRect);
    SourceRect.top = SourceTop;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current top position

STDMETHODIMP CVMRBaseControlVideo::get_SourceTop(long *pSourceTop)
{
    AMTRACE((TEXT("get_SourceTop"), 1));
    CheckPointer(pSourceTop,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceTop = SourceRect.top;
    return NOERROR;
}


// Set the source height

STDMETHODIMP CVMRBaseControlVideo::put_SourceHeight(long SourceHeight)
{
    AMTRACE((TEXT("put_SourceHeight"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.bottom = SourceRect.top + SourceHeight;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current source height

STDMETHODIMP CVMRBaseControlVideo::get_SourceHeight(long *pSourceHeight)
{
    AMTRACE((TEXT("get_SourceHeight"), 1));
    CheckPointer(pSourceHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceHeight = HEIGHT(&SourceRect);
    return NOERROR;
}


// Set the target left position, the target rectangle we get back from the
// window object is a true rectangle in left,top,right and bottom positions
// so all we have to do is to update the left position and pass it back. We
// must keep the current width constant when we're updating this property

STDMETHODIMP CVMRBaseControlVideo::put_DestinationLeft(long DestinationLeft)
{
    AMTRACE((TEXT("put_DestinationLeft"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.right = DestinationLeft + WIDTH(&DestinationRect);
    DestinationRect.left = DestinationLeft;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the left position for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationLeft(long *pDestinationLeft)
{
    AMTRACE((TEXT("get_DestinationLeft"), 1));
    CheckPointer(pDestinationLeft,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationLeft = DestinationRect.left;
    return NOERROR;
}


// Set the destination width

STDMETHODIMP CVMRBaseControlVideo::put_DestinationWidth(long DestinationWidth)
{
    AMTRACE((TEXT("put_DestinationWidth"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.right = DestinationRect.left + DestinationWidth;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the width for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationWidth(long *pDestinationWidth)
{
    AMTRACE((TEXT("get_DestinationWidth"), 1));
    CheckPointer(pDestinationWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationWidth = WIDTH(&DestinationRect);
    return NOERROR;
}


// Set the target top position - changing this property does not affect the
// current target height. So changing this shunts the target rectangle up and
// down appropriately. Changing the height complements this functionality by
// keeping the top position constant and simply changing the target height

STDMETHODIMP CVMRBaseControlVideo::put_DestinationTop(long DestinationTop)
{
    AMTRACE((TEXT("put_DestinationTop"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.bottom = DestinationTop + HEIGHT(&DestinationRect);
    DestinationRect.top = DestinationTop;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the top position for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationTop(long *pDestinationTop)
{
    AMTRACE((TEXT("get_DestinationTop"), 1));
    CheckPointer(pDestinationTop,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationTop = DestinationRect.top;
    return NOERROR;
}


// Set the destination height

STDMETHODIMP CVMRBaseControlVideo::put_DestinationHeight(long DestinationHeight)
{
    AMTRACE((TEXT("put_DestinationHeight"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.bottom = DestinationRect.top + DestinationHeight;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the height for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationHeight(long *pDestinationHeight)
{
    AMTRACE((TEXT("get_DestinationHeight"), 1));
    CheckPointer(pDestinationHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationHeight = HEIGHT(&DestinationRect);
    return NOERROR;
}


// Reset the source rectangle to the full video dimensions

STDMETHODIMP CVMRBaseControlVideo::SetDefaultSourcePosition()
{
    AMTRACE((TEXT("SetDefaultSourcePosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    HRESULT hr = SetDefaultSourceRect();
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return S_OK if we're using the default source otherwise S_FALSE

STDMETHODIMP CVMRBaseControlVideo::IsUsingDefaultSource()
{
    AMTRACE((TEXT("IsUsingDefaultSource"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    return IsDefaultSourceRect();
}


// Reset the video renderer to use the entire playback area

STDMETHODIMP CVMRBaseControlVideo::SetDefaultDestinationPosition()
{
    AMTRACE((TEXT("SetDefaultDestinationPosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    HRESULT hr = SetDefaultTargetRect();
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return S_OK if we're using the default target otherwise S_FALSE

STDMETHODIMP CVMRBaseControlVideo::IsUsingDefaultDestination()
{
    AMTRACE((TEXT("IsUsingDefaultDestination"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    return IsDefaultTargetRect();
}


// Return a copy of the current image in the video renderer

STDMETHODIMP
CVMRBaseControlVideo::GetCurrentImage(long *pBufferSize,long *pVideoImage)
{
    AMTRACE((TEXT("GetCurrentImage"), 1));
    CheckPointer(pBufferSize,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    LONG cy;
    LONG cx;
    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();

    HRESULT hr = E_NOTIMPL;

    if (lpWLControl) {

        hr = lpWLControl->GetNativeVideoSize(&cx, &cy, NULL, NULL);

        if (pVideoImage == NULL) {
            *pBufferSize = sizeof(BITMAPINFOHEADER) + (cx * cy * 4);
        }
        else {

            LPBYTE lpDib;

            hr = lpWLControl->GetCurrentImage(&lpDib);

            if (hr == S_OK) {
                DWORD CopyLen = min((DWORD)*pBufferSize,
                                   sizeof(BITMAPINFOHEADER) + (cx * cy * 4));
                CopyMemory(pVideoImage, lpDib, CopyLen);
                CoTaskMemFree(lpDib);
            }
        }
    }

    return hr;
}


// Called when we change media types either during connection or dynamically
// We inform the filter graph and therefore the application that the video
// size may have changed, we don't bother looking to see if it really has as
// we leave that to the application - the dimensions are the event parameters

HRESULT CVMRBaseControlVideo::OnVideoSizeChange()
{
    AMTRACE((TEXT("OnVideoSizeChange"), 1));
    // Get the video format from the derived class

    LONG lWidth, lHeight;
    HRESULT hr  = GetVideoSize(&lWidth, &lHeight);
    if (NOERROR == hr) {

        WORD Width = (WORD)lWidth;
        WORD Height = (WORD)lHeight;

        return m_pFilter->NotifyEvent(EC_VIDEO_SIZE_CHANGED,
                                      MAKELPARAM(Width,Height), 0);
    }

    return hr;
}


// Set the video source rectangle. We must check the source rectangle against
// the actual video dimensions otherwise when we come to draw the pictures we
// get access violations as GDI tries to touch data outside of the image data
// Although we store the rectangle in left, top, right and bottom coordinates
// instead of left, top, width and height as OLE uses we do take into account
// that the rectangle is used up to, but not including, the right column and
// bottom row of pixels, see the Win32 documentation on RECT for more details

HRESULT CVMRBaseControlVideo::CheckSourceRect(RECT *pSourceRect)
{
    CheckPointer(pSourceRect,E_POINTER);
    LONG Width,Height;
    GetVideoSize(&Width,&Height);

    // Check the coordinates are greater than zero
    // and that the rectangle is valid (left<right, top<bottom)

    if ((pSourceRect->left >= pSourceRect->right) ||
       (pSourceRect->left < 0) ||
       (pSourceRect->top >= pSourceRect->bottom) ||
       (pSourceRect->top < 0)) {

        return E_INVALIDARG;
    }

    // Check the coordinates are less than the extents

    if ((pSourceRect->right > Width) ||
        (pSourceRect->bottom > Height)) {

        return E_INVALIDARG;
    }
    return NOERROR;
}


// Check the target rectangle has some valid coordinates, which amounts to
// little more than checking the destination rectangle isn't empty. Derived
// classes may call this when they have their SetTargetRect method called to
// check the rectangle validity, we do not update the rectangles passed in
// Although we store the rectangle in left, top, right and bottom coordinates
// instead of left, top, width and height as OLE uses we do take into account
// that the rectangle is used up to, but not including, the right column and
// bottom row of pixels, see the Win32 documentation on RECT for more details

HRESULT CVMRBaseControlVideo::CheckTargetRect(RECT *pTargetRect)
{
    // Check the pointer is valid

    if (pTargetRect == NULL) {
        return E_POINTER;
    }

    // These overflow the WIDTH and HEIGHT checks

    if (pTargetRect->left > pTargetRect->right ||
            pTargetRect->top > pTargetRect->bottom) {
                return E_INVALIDARG;
    }

    // Check the rectangle has valid coordinates

    if (WIDTH(pTargetRect) <= 0 || HEIGHT(pTargetRect) <= 0) {
        return E_INVALIDARG;
    }

    ASSERT(IsRectEmpty(pTargetRect) == FALSE);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\inftee\inftee.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <initguid.h>
#include <inftee.h>
#include <tchar.h>
#include <stdio.h>

//
//
// What this sample illustrates
//
// A pass through filter splits a data stream into many output channels
//
// Summary
//
// This is a sample ActiveMovie pass through filter. We have a single input
// pin and can have many output pins. We start with one output pin and each
// time we connect an output pin we spawn another, although we could keep
// doing this ad infinitum we have a top level maximum of INFTEE_MAX_PINS.
// Any data samples our input pin receives will be sent down each output
// pin in turn. Each output pin has a separate thread if necessary (see
// the output queue class in the SDK) to avoid delivery blocking our thread
//
// Demonstration instructions
//
// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any
// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to
// the filters in the graph and find the filter (box) titled "Video Renderer"
// Then click on the box and hit DELETE. After that go to the Graph menu and
// select "Insert Filters", from the dialog box find and select the "Infinite
// Tee Filter" and then dismiss the dialog. Back in the graph layout find the
// output pin of the filter that was connected to the input of the video
// renderer you just deleted, right click and select "Render". You should
// see it being connected to the input pin of the filter you just inserted
//
// The infinite tee filter will have one output pin connected and will have
// spawned another, right click on this and select Render. A new renderer
// will pop up fo the stream. Do this once or twice more and then click on
// the Pause and Run on the GRAPHEDT frame and you will see the video...
//      .. many times over in different windows
//
// Files
//
// inftee.cpp           Main implementation of the infinite tee
// inftee.def           What APIs the DLL will import and export
// inftee.h             Class definition of the infinite tee
// inftee.rc            Not much, just our version information
// inftee.reg           What goes in the registry to make us work
// makefile             How to build it...
//
//
// Base classes used
//
// CBaseInputPin        Basic IMemInputPin based input pin
// CBaseOutputPin       Used for basic connection stuff
// CBaseFilter          Well we need a filter don't we
// CCritSec             Controls access to output pin list
// COutputQueue         Delivers data on a separate thread
//
//

#define INFTEE_MAX_PINS 1000

// Using this pointer in constructor
#pragma warning(disable:4355)

// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_NULL,         // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Output",            // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }        // Pin information
};

const AMOVIESETUP_FILTER sudInfTee =
{
    &CLSID_InfTee,              // CLSID of filter
    L"Infinite Pin Tee Filter", // Filter's name
    MERIT_DO_NOT_USE,           // Filter merit
    2,                          // Number of pins
    psudPins                    // Pin information
};

#ifdef FILTER_DLL

CFactoryTemplate g_Templates [1] = {
    { L"Infinite Pin Tee"
    , &CLSID_InfTee
    , CTee::CreateInstance
    , NULL
    , &sudInfTee }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif


//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CTee::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CTee(NAME("Infinite Tee Filter"), pUnk, phr);
}


//
// Constructor
//
CTee::CTee(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_OutputPinsList(NAME("Tee Output Pins list")),
    m_lCanSeek(TRUE),
    m_pAllocator(NULL),
    m_NumOutputPins(0),
    m_NextOutputPinNumber(0),
    m_Input(NAME("Input Pin"), this, phr, L"Input"),
    CBaseFilter(NAME("Tee filter"), pUnk, this, CLSID_InfTee)
{
    ASSERT(phr);

    // Create a single output pin at this time
    InitOutputPinsList();

    CTeeOutputPin *pOutputPin = CreateNextOutputPin(this);

    if (pOutputPin != NULL )
    {
        m_NumOutputPins++;
        m_OutputPinsList.AddTail(pOutputPin);
    }
}


//
// Destructor
//
CTee::~CTee()
{
    InitOutputPinsList();
}


//
// GetPinCount
//
int CTee::GetPinCount()
{
    return (1 + m_NumOutputPins);
}


//
// GetPin
//
CBasePin *CTee::GetPin(int n)
{
    if (n < 0)
        return NULL ;

    // Pin zero is the one and only input pin
    if (n == 0)
        return &m_Input;

    // return the output pin at position(n - 1) (zero based)
    return GetPinNFromList(n - 1);
}


//
// InitOutputPinsList
//
void CTee::InitOutputPinsList()
{
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos)
    {
        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        ASSERT(pOutputPin->m_pOutputQueue == NULL);
        pOutputPin->Release();
    }
    m_NumOutputPins = 0;
    m_OutputPinsList.RemoveAll();

} // InitOutputPinsList


//
// CreateNextOutputPin
//
CTeeOutputPin *CTee::CreateNextOutputPin(CTee *pTee)
{
    WCHAR szbuf[20];             // Temporary scratch buffer
    m_NextOutputPinNumber++;     // Next number to use for pin
    HRESULT hr = NOERROR;

    wsprintfW(szbuf, L"Output%d", m_NextOutputPinNumber);

    CTeeOutputPin *pPin = new CTeeOutputPin(NAME("Tee Output"), pTee,
					    &hr, szbuf,
					    m_NextOutputPinNumber);

    if (FAILED(hr) || pPin == NULL) {
        delete pPin;
        return NULL;
    }

    pPin->AddRef();
    return pPin;

} // CreateNextOutputPin


//
// DeleteOutputPin
//
void CTee::DeleteOutputPin(CTeeOutputPin *pPin)
{
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos) {
        POSITION posold = pos;         // Remember this position
        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        if (pOutputPin == pPin) {
            // If this pin holds the seek interface release it
            if (pPin->m_bHoldsSeek) {
                InterlockedExchange(&m_lCanSeek, FALSE);
                pPin->m_bHoldsSeek = FALSE;
                pPin->m_pPosition->Release();
            }

            m_OutputPinsList.Remove(posold);
            ASSERT(pOutputPin->m_pOutputQueue == NULL);
            delete pPin;
            m_NumOutputPins--;
	    IncrementPinVersion();
            break;
        }
    }

} // DeleteOutputPin


//
// GetNumFreePins
//
int CTee::GetNumFreePins()
{
    int n = 0;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos) {
        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        if (pOutputPin->m_Connected == NULL)
            n++;
    }
    return n;

} // GetNumFreePins


//
// GetPinNFromList
//
CTeeOutputPin *CTee::GetPinNFromList(int n)
{
    // Validate the position being asked for
    if (n >= m_NumOutputPins)
        return NULL;

    // Get the head of the list
    POSITION pos = m_OutputPinsList.GetHeadPosition();

    n++;       // Make the number 1 based

    CTeeOutputPin *pOutputPin;
    while(n) {
        pOutputPin = m_OutputPinsList.GetNext(pos);
        n--;
    }
    return pOutputPin;

} // GetPinNFromList


//
// Stop
//
// Overriden to handle no input connections
//
STDMETHODIMP CTee::Stop()
{
    CBaseFilter::Stop();
    m_State = State_Stopped;
    return NOERROR;
}


//
// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CTee::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Pause();
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    return hr;
}


//
// Run
//
// Overriden to handle no input connections
//
STDMETHODIMP CTee::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Run(tStart);
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    return hr;
}

//
// CTeeInputPin constructor
//
CTeeInputPin::CTeeInputPin(TCHAR *pName,
                           CTee *pTee,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pTee, pTee, phr, pPinName),
    m_pTee(pTee),
    m_bInsideCheckMediaType(FALSE)
{
    ASSERT(pTee);
}


#ifdef DEBUG
//
// CTeeInputPin destructor
//
CTeeInputPin::~CTeeInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("CTeeInputPin destructor")));
    ASSERT(m_pTee->m_pAllocator == NULL);
}
#endif


#ifdef DEBUG

//
// DisplayMediaType -- (DEBUG ONLY)
//
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt)
{

    // Dump the GUID types and a short description

    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription));
    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("Media Type Description")));
    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt->Subtype())));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->cbFormat));

    // Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));


} // DisplayMediaType

#endif

//
// CheckMediaType
//
HRESULT CTeeInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // If we are already inside checkmedia type for this pin, return NOERROR
    // It is possble to hookup two of the tee filters and some other filter
    // like the video effects sample to get into this situation. If we don't
    // detect this situation, we will carry on looping till we blow the stack

    if (m_bInsideCheckMediaType == TRUE)
        return NOERROR;

    m_bInsideCheckMediaType = TRUE;
    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
    DisplayMediaType(TEXT("Input Pin Checking"), pmt);
#endif

    // The media types that we can support are entirely dependent on the
    // downstream connections. If we have downstream connections, we should
    // check with them - walk through the list calling each output pin

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
                    m_bInsideCheckMediaType = FALSE;
                    return VFW_E_TYPE_NOT_ACCEPTED;
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    // Either all the downstream pins have accepted or there are none.
    m_bInsideCheckMediaType = FALSE;
    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
HRESULT CTeeInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    ASSERT(m_Connected != NULL);
    return NOERROR;

} // SetMediaType


//
// BreakConnect
//
HRESULT CTeeInputPin::BreakConnect()
{
    // Release any allocator that we are holding
    if (m_pTee->m_pAllocator)
    {
        m_pTee->m_pAllocator->Release();
        m_pTee->m_pAllocator = NULL;
    }
    return NOERROR;

} // BreakConnect


//
// NotifyAllocator
//
STDMETHODIMP
CTeeInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    if (pAllocator == NULL)
        return E_FAIL;

    // Free the old allocator if any
    if (m_pTee->m_pAllocator)
        m_pTee->m_pAllocator->Release();

    // Store away the new allocator
    pAllocator->AddRef();
    m_pTee->m_pAllocator = pAllocator;

    // Notify the base class about the allocator
    return CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);

} // NotifyAllocator


//
// EndOfStream
//
HRESULT CTeeInputPin::EndOfStream()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverEndOfStream();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return(NOERROR);

} // EndOfStream


//
// BeginFlush
//
HRESULT CTeeInputPin::BeginFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverBeginFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::BeginFlush();

} // BeginFlush


//
// EndFlush
//
HRESULT CTeeInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverEndFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::EndFlush();

} // EndFlush

//
// NewSegment
//

HRESULT CTeeInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop,
                                 double dRate)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverNewSegment(tStart, tStop, dRate);
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::NewSegment(tStart, tStop, dRate);

} // NewSegment


//
// Receive
//
HRESULT CTeeInputPin::Receive(IMediaSample *pSample)
{
    CAutoLock lock_it(m_pLock);

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR)
        return hr;

    // Walk through the output pins list, delivering to each in turn

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->Deliver(pSample);
            if (hr != NOERROR)
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT CTeeInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    // Force any output pins to use our type

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            // Check with downstream pin
            if (pOutputPin->m_Connected != NULL) {
                if (m_mt != pOutputPin->m_mt)
                    m_pTee->ReconnectPin(pOutputPin, &m_mt);
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return S_OK;
}


//
// CTeeOutputPin constructor
//
CTeeOutputPin::CTeeOutputPin(TCHAR *pName,
                             CTee *pTee,
                             HRESULT *phr,
                             LPCWSTR pPinName,
                             int PinNumber) :
    CBaseOutputPin(pName, pTee, pTee, phr, pPinName) ,
    m_pOutputQueue(NULL),
    m_bHoldsSeek(FALSE),
    m_pPosition(NULL),
    m_pTee(pTee),
    m_cOurRef(0),
    m_bInsideCheckMediaType(FALSE)
{
    ASSERT(pTee);
}

#ifdef DEBUG
//
// CTeeOutputPin destructor
//
CTeeOutputPin::~CTeeOutputPin()
{
    ASSERT(m_pOutputQueue == NULL);
}
#endif


//
// NonDelegatingQueryInterface
//
// This function is overwritten to expose IMediaPosition and IMediaSelection
// Note that only one output stream can be allowed to expose this to avoid
// conflicts, the other pins will just return E_NOINTERFACE and therefore
// appear as non seekable streams. We have a LONG value that if exchanged to
// produce a TRUE means that we have the honor. If it exchanges to FALSE then
// someone is already in. If we do get it and error occurs then we reset it
// to TRUE so someone else can get it.
//
STDMETHODIMP
CTeeOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    ASSERT(ppv);
    *ppv = NULL;
    HRESULT hr = NOERROR;

    // See what interface the caller is interested in.
    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        if (m_pPosition) {
            if (m_bHoldsSeek == FALSE)
                return E_NOINTERFACE;
            return m_pPosition->QueryInterface(riid, ppv);
        }
    } else
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);

    CAutoLock lock_it(m_pLock);
    ASSERT(m_pPosition == NULL);
    IUnknown *pMediaPosition = NULL;

    // Try to create a seeking implementation
    if (InterlockedExchange(&m_pTee->m_lCanSeek, FALSE) == FALSE)
        return E_NOINTERFACE;

    // Create implementation of this dynamically as sometimes we may never
    // try and seek. The helper object implements IMediaPosition and also
    // the IMediaSelection control interface and simply takes the calls
    // normally from the downstream filter and passes them upstream


    hr = CreatePosPassThru(
                   GetOwner(),
                   FALSE,
                   (IPin *)&m_pTee->m_Input,
                   &pMediaPosition);

    if (pMediaPosition == NULL) {
        InterlockedExchange(&m_pTee->m_lCanSeek, TRUE);
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        InterlockedExchange(&m_pTee->m_lCanSeek, TRUE);
        pMediaPosition->Release ();
        return hr;
    }

    m_pPosition = pMediaPosition;
    m_bHoldsSeek = TRUE;
    return NonDelegatingQueryInterface(riid, ppv);

} // NonDelegatingQueryInterface


//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on our output pin. The base class CBasePin does not do any reference
// counting on the pin in RETAIL.
//
// Please refer to the comments for the NonDelegatingRelease method for more
// info on why we need to do this.
//
STDMETHODIMP_(ULONG) CTeeOutputPin::NonDelegatingAddRef()
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Update the debug only variable maintained by the base class
    m_cRef++;
    ASSERT(m_cRef > 0);
#endif

    // Now update our reference count
    m_cOurRef++;
    ASSERT(m_cOurRef > 0);
    return m_cOurRef;

} // NonDelegatingAddRef


//
// NonDelegatingRelease
//
// CTeeOutputPin overrides this class so that we can take the pin out of our
// output pins list and delete it when its reference count drops to 1 and there
// is atleast two free pins.
//
// Note that CreateNextOutputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
// Moreover, the pin that we are about to delete must be a free pin(or else
// the reference would not have dropped to 1, and we must have atleast one
// other free pin(as the filter always wants to have one more free pin)
//
// Also, since CBasePin::NonDelegatingAddRef passes the call to the owning
// filter, we will have to call Release on the owning filter as well.
//
// Also, note that we maintain our own reference count m_cOurRef as the m_cRef
// variable maintained by CBasePin is debug only.
//
STDMETHODIMP_(ULONG) CTeeOutputPin::NonDelegatingRelease()
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Update the debug only variable in CBasePin
    m_cRef--;
    ASSERT(m_cRef >= 0);
#endif

    // Now update our reference count
    m_cOurRef--;
    ASSERT(m_cOurRef >= 0);

    // if the reference count on the object has gone to one, remove
    // the pin from our output pins list and physically delete it
    // provided there are atealst two free pins in the list(including
    // this one)

    // Also, when the ref count drops to 0, it really means that our
    // filter that is holding one ref count has released it so we
    // should delete the pin as well.

    if (m_cOurRef <= 1) {
        int n = 2;                     // default forces pin deletion
        if (m_cOurRef == 1) {
            // Walk the list of pins, looking for count of free pins
            n = m_pTee->GetNumFreePins();
        }

        // If there are two free pins, delete this one.
        // NOTE: normall
        if (n >= 2 ) {
            m_cOurRef = 0;
#ifdef DEBUG
            m_cRef = 0;
#endif
            m_pTee->DeleteOutputPin(this);
            return(ULONG) 0;
        }
    }
    return(ULONG) m_cOurRef;

} // NonDelegatingRelease


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
HRESULT CTeeOutputPin::DecideBufferSize(IMemAllocator *pMemAllocator,
                                        ALLOCATOR_PROPERTIES * ppropInputRequest)
{
    return NOERROR;

} // DecideBufferSize


//
// DecideAllocator
//
HRESULT CTeeOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    ASSERT(m_pTee->m_pAllocator != NULL);
    *ppAlloc = NULL;

    // Tell the pin about our allocator, set by the input pin.
    HRESULT hr = NOERROR;
    hr = pPin->NotifyAllocator(m_pTee->m_pAllocator,TRUE);
    if (FAILED(hr))
        return hr;

    // Return the allocator
    *ppAlloc = m_pTee->m_pAllocator;
    m_pTee->m_pAllocator->AddRef();
    return NOERROR;

} // DecideAllocator


//
// CheckMediaType
//
HRESULT CTeeOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // If we are already inside checkmedia type for this pin, return NOERROR
    // It is possble to hookup two of the tee filters and some other filter
    // like the video effects sample to get into this situation. If we
    // do not detect this, we will loop till we blow the stack

    if (m_bInsideCheckMediaType == TRUE)
        return NOERROR;

    m_bInsideCheckMediaType = TRUE;
    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging purposes
    DisplayMediaType(TEXT("Output Pin Checking"), pmt);
#endif

    // The input needs to have been conneced first
    if (m_pTee->m_Input.m_Connected == NULL) {
        m_bInsideCheckMediaType = FALSE;
        return VFW_E_NOT_CONNECTED;
    }

    // Make sure that our input pin peer is happy with this
    hr = m_pTee->m_Input.m_Connected->QueryAccept(pmt);
    if (hr != NOERROR) {
        m_bInsideCheckMediaType = FALSE;
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // Check the format with the other outpin pins

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL && pOutputPin != this) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
                    m_bInsideCheckMediaType = FALSE;
                    return VFW_E_TYPE_NOT_ACCEPTED;
                }
            }
        }
        n--;
    }
    m_bInsideCheckMediaType = FALSE;
    return NOERROR;

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP CTeeOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    // Make sure that we are connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    // We will simply return the enumerator of our input pin's peer
    return m_pTee->m_Input.m_Connected->EnumMediaTypes(ppEnum);

} // EnumMediaTypes


//
// SetMediaType
//
HRESULT CTeeOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Display the format of the media for debugging purposes
    DisplayMediaType(TEXT("Output pin type agreed"), pmt);
#endif

    // Make sure that we have an input connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    // Make sure that the base class likes it
    HRESULT hr = NOERROR;
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT CTeeOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    if (m_mt != m_pTee->m_Input.m_mt)
    {
        hr = m_pTee->ReconnectPin(m_pTee->m_Input.m_Connected, &m_mt);
        if(FAILED(hr)) {
            return hr;
        }
    }


    // Since this pin has been connected up, create another output pin. We
    // will do this only if there are no unconnected pins on us. However
    // CompleteConnect will get called for the same pin during reconnection

    int n = m_pTee->GetNumFreePins();
    ASSERT(n <= 1);
    if (n == 1 || m_pTee->m_NumOutputPins == INFTEE_MAX_PINS)
        return NOERROR;

    // No unconnected pins left so spawn a new one

    CTeeOutputPin *pOutputPin = m_pTee->CreateNextOutputPin(m_pTee);
    if (pOutputPin != NULL )
    {
        m_pTee->m_NumOutputPins++;
        m_pTee->m_OutputPinsList.AddTail(pOutputPin);
	m_pTee->IncrementPinVersion();
    }

    // At this point we should be able to send some
    // notification that we have sprung a new pin

    return NOERROR;

} // CompleteConnect


//
// Active
//
// This is called when we start running or go paused. We create the
// output queue object to send data to our associated peer pin
//
HRESULT CTeeOutputPin::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the pin is connected
    if (m_Connected == NULL)
        return NOERROR;

    // Create the output queue if we have to
    if (m_pOutputQueue == NULL)
    {
        m_pOutputQueue = new COutputQueue(m_Connected, &hr, TRUE, FALSE);
        if (m_pOutputQueue == NULL)
            return E_OUTOFMEMORY;

        // Make sure that the constructor did not return any error
        if (FAILED(hr))
        {
            delete m_pOutputQueue;
            m_pOutputQueue = NULL;
            return hr;
        }
    }

    // Pass the call on to the base class
    CBaseOutputPin::Active();
    return NOERROR;

} // Active


//
// Inactive
//
// This is called when we stop streaming
// We delete the output queue at this time
//
HRESULT CTeeOutputPin::Inactive()
{
    CAutoLock lock_it(m_pLock);

    // Delete the output queus associated with the pin.
    if (m_pOutputQueue)
    {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    CBaseOutputPin::Inactive();
    return NOERROR;

} // Inactive


//
// Deliver
//
HRESULT CTeeOutputPin::Deliver(IMediaSample *pMediaSample)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    pMediaSample->AddRef();
    return m_pOutputQueue->Receive(pMediaSample);

} // Deliver


//
// DeliverEndOfStream
//
HRESULT CTeeOutputPin::DeliverEndOfStream()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EOS();
    return NOERROR;

} // DeliverEndOfStream


//
// DeliverBeginFlush
//
HRESULT CTeeOutputPin::DeliverBeginFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->BeginFlush();
    return NOERROR;

} // DeliverBeginFlush


//
// DeliverEndFlush
//
HRESULT CTeeOutputPin::DeliverEndFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EndFlush();
    return NOERROR;

} // DeliverEndFlish

//
// DeliverNewSegment
//
HRESULT CTeeOutputPin::DeliverNewSegment(REFERENCE_TIME tStart,
                                         REFERENCE_TIME tStop,
                                         double dRate)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

} // DeliverNewSegment


//
// Notify
//
STDMETHODIMP CTeeOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // We pass the message on, which means that we find the quality sink
    // for our input pin and send it there

    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    CTeeOutputPin *pFirstOutput = m_pTee->m_OutputPinsList.GetNext(pos);

    if (this == pFirstOutput) {
	if (m_pTee->m_Input.m_pQSink!=NULL) {
	    return m_pTee->m_Input.m_pQSink->Notify(m_pTee, q);
	} else {

	    // No sink set, so pass it upstream
	    HRESULT hr;
	    IQualityControl * pIQC;

	    hr = VFW_E_NOT_FOUND;
	    if (m_pTee->m_Input.m_Connected) {
		m_pTee->m_Input.m_Connected->QueryInterface(IID_IQualityControl,(void**)&pIQC);

		if (pIQC!=NULL) {
		    hr = pIQC->Notify(m_pTee, q);
		    pIQC->Release();
		}
	    }
	    return hr;
	}
    }

    // Quality management is too hard to do
    return NOERROR;

} // Notify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\inftee\inftee.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __INFTEE__
#define __INFTEE__

extern const AMOVIESETUP_FILTER sudInfTee;


class CTee;
class CTeeOutputPin;

// class for the Tee filter's Input pin

class CTeeInputPin : public CBaseInputPin
{
    friend class CTeeOutputPin;
    CTee *m_pTee;                  // Main filter object
    BOOL m_bInsideCheckMediaType;  // Re-entrancy control

public:

    // Constructor and destructor
    CTeeInputPin(TCHAR *pObjName,
                 CTee *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);

#ifdef DEBUG
    ~CTeeInputPin();
#endif

    // Used to check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

};


// Class for the Tee filter's Output pins.

class CTeeOutputPin : public CBaseOutputPin
{
    friend class CTeeInputPin;
    friend class CTee;

    CTee *m_pTee;                  // Main filter object pointer
    IUnknown    *m_pPosition;      // Pass seek calls upstream
    BOOL m_bHoldsSeek;             // Is this the one seekable stream
    COutputQueue *m_pOutputQueue;  // Streams data to the peer pin
    BOOL m_bInsideCheckMediaType;  // Re-entrancy control
    LONG m_cOurRef;                // We maintain reference counting

public:

    // Constructor and destructor

    CTeeOutputPin(TCHAR *pObjName,
                   CTee *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName,
                   INT PinNumber);

#ifdef DEBUG
    ~CTeeOutputPin();
#endif

    // Override to expose IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppvoid);

    // Override since the life time of pins and filters are not the same
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);

    // Negotiation to use our input pins allocator
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    HRESULT Active();
    HRESULT Inactive();

    // Overriden to create and destroy output pins
    HRESULT CompleteConnect(IPin *pReceivePin);

    // Overriden to pass data to the output queues
    HRESULT Deliver(IMediaSample *pMediaSample);
    HRESULT DeliverEndOfStream();
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);


    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);
};


// Class for the Tee filter

class CTee: public CCritSec, public CBaseFilter
{
    // Let the pins access our internal state
    friend class CTeeInputPin;
    friend class CTeeOutputPin;
    typedef CGenericList <CTeeOutputPin> COutputList;

    // Declare an input pin.
    CTeeInputPin m_Input;

    INT m_NumOutputPins;            // Current output pin count
    COutputList m_OutputPinsList;   // List of the output pins
    INT m_NextOutputPinNumber;      // Increases monotonically.
    LONG m_lCanSeek;                // Seekable output pin
    IMemAllocator *m_pAllocator;    // Allocator from our input pin

public:

    CTee(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CTee();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // Send EndOfStream if no input connection
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

protected:

    // The following manage the list of output pins

    void InitOutputPinsList();
    CTeeOutputPin *GetPinNFromList(int n);
    CTeeOutputPin *CreateNextOutputPin(CTee *pTee);
    void DeleteOutputPin(CTeeOutputPin *pPin);
    int GetNumFreePins();
};

#endif // __INFTEE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21dbase.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Base class code
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"


//
//  CCaptionChar: Caption char base class implementation (non-inline methods)
//

void CCaptionChar::SetChar(UINT16 wChar)
{
    if (wChar != m_wChar)
    {
        SetDirty(TRUE) ;
        m_wChar = wChar ;
    }
}

void CCaptionChar::SetColor(UINT8 uColor)
{
    if (uColor != GetColor())  // color changed
    {
        SetDirty(TRUE) ;
        m_uAttrib &= ~AM_L21_FGCOLOR_MASK ;           // clear old color
        m_uAttrib |= (uColor & AM_L21_FGCOLOR_MASK) ; // set new color
    }
}

void CCaptionChar::SetEffect(UINT8 uEffect)
{
    if (uEffect != GetEffect())
    {
        SetDirty(TRUE) ; 
        m_uAttrib &= ~AM_L21_FGEFFECT_MASK ;            // clear old effect bits
        m_uAttrib |= (uEffect & AM_L21_FGEFFECT_MASK) ; // set new effect value
    }
}

void CCaptionChar::SetItalicized(BOOL bState) 
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_ITALICS ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_ITALICS ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetUnderLined(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_UNDERLINE ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_UNDERLINE ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetFlashing(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_FLASHING ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_FLASHING ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetDirty(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_DIRTY ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_DIRTY ;
}

void CCaptionChar::SetMidRowCode(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_MRC ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_MRC ;
}



//
//  CCaptionLine: Base class implementation of a line of CC chars
//
CCaptionLine::CCaptionLine(void)
{
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;  // un-inited
    ClearLine() ;
}

CCaptionLine::CCaptionLine(const UINT uStartRow, const UINT uNumChars /* 0 */)
{
    m_uNumChars = (UINT8)uNumChars ;
    m_uStartRow = (UINT8)uStartRow ;
    ClearLine() ;
}

CCaptionLine& CCaptionLine::operator = (const CCaptionLine& cl)
{
    m_uNumChars = cl.m_uNumChars ;
    m_uStartRow = cl.m_uStartRow ;
    for (int i = 0 ; i < MAX_CAPTION_COLUMNS ; i++)
        cl.GetCaptionChar(i, m_aCapChar[i]) ;
    return *this ;
}

int CCaptionLine::IncNumChars(UINT uNumChars)
{
    m_uNumChars += (uNumChars & 0x3F) ;
    if (m_uNumChars > MAX_CAPTION_COLUMNS)
        m_uNumChars = MAX_CAPTION_COLUMNS ;
    return m_uNumChars ;
}

int CCaptionLine::DecNumChars(UINT uNumChars)
{
    if (uNumChars < m_uNumChars)
        m_uNumChars -= (UINT8)uNumChars ;   // & 0x3F ;
    else       // error ??? or just make it 0 ???
        m_uNumChars = 0 ;
    return m_uNumChars ;
}

void CCaptionLine::SetCaptionChar(UINT uCol, const CCaptionChar &cc)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return ;

    // A Hacky (?) Fix:
    // If this char is for the last (32nd) column then we set the "Dirty"
    // flag on for the char before it so that it gets redrawn causing any
    // prev char in last column to be erased while rendering.
    if ((UINT)MAX_CAPTION_COLUMNS - 1 == uCol)
        m_aCapChar[uCol-1].SetDirty(TRUE) ;  // to cause re-rendering
    m_aCapChar[uCol] = cc  ;
}

CCaptionChar* CCaptionLine::GetCaptionCharPtr(UINT uCol)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return NULL ;
    return &(m_aCapChar[uCol]) ;
}

void CCaptionLine::SetStartRow(UINT uRow)
{
    if (uRow > MAX_CAPTION_ROWS)  // error!! We use 1-based index for Row numbers
    {
        ASSERT(uRow > MAX_CAPTION_ROWS) ;
        return ;
    }
    m_uStartRow = uRow & 0xF ;
    ASSERT(m_uStartRow > 0 && uRow > 0) ;
}

void CCaptionLine::MoveCaptionChars(int iNum)
{
    ASSERT(iNum < MAX_CAPTION_COLUMNS) ;
    int  i ;
    for (i = min(m_uNumChars, MAX_CAPTION_COLUMNS-iNum) - 1 ; i >= 0 ; i--)
        m_aCapChar[i+iNum] = m_aCapChar[i] ;
    CCaptionChar  cc ;
    for (i = 0 ; i < iNum ; i++)
        m_aCapChar[i] = cc ;
    m_uNumChars = min(m_uNumChars+iNum, MAX_CAPTION_COLUMNS) ;
}

void CCaptionLine::ClearLine(void)
{
    CCaptionChar cc ;
    for (UINT u = 0 ; u < MAX_CAPTION_COLUMNS ; u++)
        m_aCapChar[u] = cc ;
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;   // newly added
}



//
//  CRowIndexMap: Mapping of row usage (row to line) class implementation
//
int CRowIndexMap::GetRowIndex(UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::GetRowIndex(%u)"), uRow)) ;

    uRow-- ;   // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u) for row index"), uRow)) ;
        ASSERT(FALSE) ;
        return -1 ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        return ( m_adwMap[1] & (0xF << uRow) ) >> uRow ;
    }
    else
    {
        uRow = uRow << 2 ;
        return ( m_adwMap[0] & (0xF << uRow) ) >> uRow ;
    }
#else   // trust me -- it works!!!
    return (m_adwMap[uRow / 8] & (0xF << (4 * (uRow % 8)))) >> (4 * (uRow % 8)) ;
#endif // #if 0
}

void CRowIndexMap::SetRowIndex(UINT uLine, UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::SetRowIndex(%u, %u)"), uLine, uRow)) ;

    uRow-- ;  // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS  ||
        uLine > MAX_CAPTION_LINES)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u)/line (%u) for saving"), uRow, uLine)) ;
        ASSERT(FALSE) ;
        return ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        m_adwMap[1] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[1] |= (uLine << uRow) ;
    }
    else
    {
        uRow = uRow << 2 ;
        m_adwMap[0] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[0] |= (uLine << uRow) ;
    }
#else   // trust me -- it works!!!
    m_adwMap[uRow / 8] &= ~(0xF   << (4 * (uRow % 8))) ;  // clear any existing bits there
    m_adwMap[uRow / 8] |=  (uLine << (4 * (uRow % 8))) ;  // put new line number in there
#endif // #if 0
}


//
//  CCaptionBuffer: The base caption buffer class implementation
//

CCaptionBuffer::CCaptionBuffer(UINT8 uStyle    /* = AM_L21_CCSTYLE_None */,
                               UINT8 uMaxLines /* = MAX_CAPTION_LINES */)
{
    ClearBuffer() ;
    m_uMaxLines = uMaxLines ;
    m_uCaptionStyle = uStyle ;
}

CCaptionBuffer::CCaptionBuffer(/* const */ CCaptionBuffer &cb)
{
    for (int i = 0 ; i < cb.GetNumLines() ; i++)
        m_aCapLine[i] = cb.GetCaptionLine(i) ;
    m_RowIndex  = cb.m_RowIndex ;
    m_uNumLines = cb.m_uNumLines ;
    m_uMaxLines = cb.m_uMaxLines ;
    m_uCurrCol  = cb.m_uCurrCol ;
    m_uCurrLine = cb.m_uCurrLine ;
    m_uCaptionStyle = cb.m_uCaptionStyle ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL ;  // cb.m_uDirtyState ;
}

void CCaptionBuffer::SetCurrCol(int uCurrCol)
{
    m_uCurrCol = uCurrCol & 0x3F ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
}

void CCaptionBuffer::SetCaptionLine(UINT uLine, const CCaptionLine& cl)
{
    if (uLine >= MAX_CAPTION_LINES)
        return ;
    m_aCapLine[uLine] = cl ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

void CCaptionBuffer::ClearCaptionLine(UINT uLine)
{
    m_aCapLine[uLine].ClearLine() ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

int CCaptionBuffer::IncCurrCol(UINT uNumChars)
{
    m_uCurrCol += (UINT8)uNumChars ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    
    return m_uCurrCol ;
}

int CCaptionBuffer::DecCurrCol(UINT uNumChars)
{
    if (m_uCurrCol < uNumChars)
        m_uCurrCol  = 0 ;
    else
        m_uCurrCol -= (UINT8)uNumChars ;
    
    return m_uCurrCol ;
}

void CCaptionBuffer::ClearBuffer(void)
{
    for (int i = 0 ; i < MAX_CAPTION_LINES ; i++)
    {
        m_aCapLine[i].ClearLine() ;
        SetStartRow(i, 0) ;
    }
    m_RowIndex.ClearRowIndex() ; ;
    m_uNumLines = 0 ;
    m_uMaxLines = MAX_CAPTION_LINES ;
    m_uCurrCol  = 0 ;
    m_uCurrLine = 0 ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL |   // draw everything
                    L21_CAPBUFFER_DIRTY ;       // buffer is dirty
}

void CCaptionBuffer::InitCaptionBuffer(void) 
{
    ClearBuffer() ;
}

int CCaptionBuffer::IncNumLines(int uLines)
{
    m_uNumLines += uLines & 0x7 ;
    // Roll-Up is supposed to allow 1 line more than the max for scrolling
    if (AM_L21_CCSTYLE_RollUp == m_uCaptionStyle)
    {
        if (m_uNumLines > m_uMaxLines+1)
            m_uNumLines = m_uMaxLines+1 ;
    }
    else  // non Roll-Up mode -- Pop-On or Paint-On
    {
        if (m_uNumLines > m_uMaxLines)  // What? Too many lines!!!
        {
            DbgLog((LOG_ERROR, 1, 
                TEXT("WARNING: How did %u lines get created with max of %u lines?"), 
                m_uNumLines, m_uMaxLines)) ;
            m_uNumLines = m_uMaxLines ;  // just to plug the hole!!!
        }
    }
    return m_uNumLines ;
}

int CCaptionBuffer::DecNumLines(int uLines)
{
    if (uLines > m_uNumLines)  // error!!
        return 0 ;
    m_uNumLines -= uLines & 0x7 ;
    return m_uNumLines ;
}

void CCaptionBuffer::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::RemoveLineFromBuffer(%u, %u)"), 
            uLine, bUpNextLine)) ;

    int iNumLines = GetNumLines() ;
    int iMaxLines = GetMaxLines() ;
    int iRow ;
    
    if (bUpNextLine)    // if next line should be move up (for Roll-up style)
    {
        // We go upto iNumLines-1 because iNumLines is the not-yet-included line
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            iRow = GetStartRow(i) ;     // get the row posn of line i
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            SetStartRow(i, iRow) ;  // put prev line i's row # as new line i's row #
        }
    
        // Clear the last line data and row index bits, ONLY IF it's already in
        iRow = GetStartRow(iNumLines-1) ;
        ClearCaptionLine(iNumLines-1) ;
        if (iNumLines <= iMaxLines)  // if the last line is already in
        {
            if (iRow > 0)  // if row # is valid, release it
                m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
            else           // otherwise something wrong
                ASSERT(FALSE) ; // so that we know
        }
        // Otherwise there is a not-yet-in line hanging, which doesn't have a 
        // row number given yet.  So no need to release that row.
    }
    else    // next line doesn't get moved up (for NON Roll-up style)
    {
        // Release the line-to-be-deleted's row by clearing the index bit
        if ((iRow = GetStartRow(uLine)) > 0)  // (check validity)
            m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
        else            // that would be weird
            ASSERT(FALSE) ; // so that we know

        // Here we stop at iNumLines-1, because we move all the existing lines to
        // make space for a new line that will start next.
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            // Update index bitmap to new row i's start row (+1 because index 
            // bitmap nibble values are 1-based).
            m_RowIndex.SetRowIndex(i+1, (UINT8)GetStartRow(i)) ;
        }
    
        // Clear the last line's data
        ClearCaptionLine(iNumLines-1) ;
    }
    
    // A line is out of the buffer -- so buffer is dirty
    SetBufferDirty(TRUE) ;
    
    // Clear whole DIB section so that no leftover shows up
    SetRedrawAll(TRUE) ;
    
    DecNumLines(1) ;  // now we have 1 line less
    
    // We have removed a line from the buffer; so the current line also
    // needs to be updated to point to the proper line in the caption buffer.
    if (m_uCurrLine == uLine)
        if (uLine == m_uNumLines-1)
            m_uCurrLine-- ;
        else
            ;  // do nothing -- old next line will become new curr line
        else if (m_uCurrLine > uLine)   // if a line above was removed
            m_uCurrLine-- ;             // then move line index up
        else    // a line was deleted below current line
            ;   // do nothing -- doesn't matter at all
        if (m_uCurrLine < 0)  // in case we went too far up
            m_uCurrLine = 0 ; // come down to the ground!!!
}

void CCaptionBuffer::SetStartRow(UINT uLine, UINT uRow)
{
    int iRow = GetStartRow(uLine) ;         // get the currently set row number
    if (iRow == (int)uRow)  // if nothing changed...
        return ;            // ...no point re-doing it
    if (iRow > 0)                           // if it was already set then...
        m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;   // ...clear the row index map bits
    m_aCapLine[uLine].SetStartRow(uRow) ;   // set new row value for the line
    // set row index bits only if specified row > 0; else it's just for clearing
    if (uRow > 0) {
        // use +1 for line # as row index map uses 1-based index for line #s
        m_RowIndex.SetRowIndex(uLine+1, (UINT8)uRow) ; // set index map bits for new row
    }
    else
        ASSERT(FALSE) ;
}

BOOL CCaptionBuffer::IsRedrawLine(UINT8 uLine)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to get line redraw info"), uLine)) ;
        return FALSE ;
    }
    return (m_uDirtyState & (0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine))) ; 
}

void CCaptionBuffer::SetBufferDirty(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_DIRTY ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_DIRTY ;
}

void CCaptionBuffer::SetRedrawAll(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_REDRAWALL ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_REDRAWALL ;
}

void CCaptionBuffer::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to set line redraw info"), uLine)) ;
        return ;
    }
    if (bState)
        m_uDirtyState |= (UINT8)(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
    else
        m_uDirtyState &= (UINT8)~(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21dbase.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21DBase.h: Line 21 Decoder Base class code
//

#ifndef _INC_L21DBASE_H
#define _INC_L21DBASE_H

// Just a few macro definitions
#define ABS(x) (((x) > 0) ? (x) : -(x))
#define LPBMIHEADER(bmi) &((bmi)->bmiHeader)
#define DWORDALIGN(n)  (((n) + 3) & ~0x03)
#define ISDWORDALIGNED(n)  (0 == ((n) & 0x03))
#define DWORDALIGNWIDTH(bmih) (((((bmih).biWidth * (bmih).biBitCount) + 31) & ~31) >> 3)
#define MAKECCCHAR(b1, b2)  ((b1) << 8 | (b2))

//
//  Caption character attribs set by PACs and/or mid-row codes
//
#define UINT8   unsigned char
#define UINT16  unsigned short int

#define AM_L21_FGCOLOR_WHITE             0x00
#define AM_L21_FGCOLOR_GREEN             0x01
#define AM_L21_FGCOLOR_BLUE              0x02
#define AM_L21_FGCOLOR_CYAN              0x03
#define AM_L21_FGCOLOR_RED               0x04
#define AM_L21_FGCOLOR_YELLOW            0x05
#define AM_L21_FGCOLOR_MAGENTA           0x06
#define AM_L21_FGCOLOR_MASK              0x07

#define AM_L21_FGEFFECT_ITALICS          0x08
#define AM_L21_FGEFFECT_UNDERLINE        0x10
#define AM_L21_FGEFFECT_FLASHING         0x20
#define AM_L21_FGEFFECT_MASK             0x38

#define AM_L21_ATTRIB_DIRTY              0x40
#define AM_L21_ATTRIB_MRC                0x80

//
// Caption width and height
//
#define CAPTION_OUTPUT_WIDTH  640  /* 320 */
#define CAPTION_OUTPUT_HEIGHT 480  /* 240 */


//
// Forward declarations
//
class CCaptionChar ;
class CCaptionLine ;
class CRowIndexMap ;
class CCaptionBuffer ;
class CPopOnCaption ;


//
//  The max's of rows and columns
//
const int MAX_CAPTION_COLUMNS = 32 ;  // max # of column / line
const int MAX_CAPTION_ROWS    = 15 ;  // number of rows available on screen
const int MAX_CAPTION_LINES   = 4 ;   // max # of caption text at a time
// for text mode, add MAX_TEXT_LINES = 15 ;


//
//  CCaptionChar: The caption char details
//
class CCaptionChar {
private:
    UINT16 m_wChar ;     // actual char
    UINT8  m_uAttrib ;   // CC char attrib bits -- FG color, effect, dirty, MRC etc.
    //
    // The layout of bits (LSB -> MSB) of CC char attribs --
    //    0 - 2: color (0 -> 6 for White -> Magenta)
    //    3 - 5: effects (3: Italics, 4: Underline, 5: Flash)
    //        6: dirty (is the CC char dirty, i.e, needs to written?)
    //        7: is it a mid-row code (carries attrib, shown as opaque space)?
    //
    
public:
    inline CCaptionChar(void) {
        m_wChar   = 0 ;
        m_uAttrib = 0 ;
    } ;
    
    inline UINT16 GetChar(void) const  { return m_wChar ; } ;
    inline CCaptionChar& operator = (const CCaptionChar& cc) {
        m_wChar   = cc.m_wChar ;
        m_uAttrib = cc.m_uAttrib ;
        return *this ;
    } ;
    inline BOOL  operator == (const CCaptionChar& cc) const {
        return (m_wChar   == cc.m_wChar  &&
                m_uAttrib == cc.m_uAttrib) ;
    } ;
    inline BOOL  operator != (const CCaptionChar& cc) const {
        if (*this == cc)  return FALSE ;
        else              return TRUE ;
    } ;
    inline BOOL  IsEqualAttrib(CCaptionChar cc) const {
        return (GetColor()  == cc.GetColor()  &&
                GetEffect() == cc.GetEffect()) ;
    } ;
    inline UINT8 GetColor(void) const      { return  m_uAttrib & AM_L21_FGCOLOR_MASK ; } ;
    inline UINT8 GetEffect(void) const     { return (m_uAttrib & AM_L21_FGEFFECT_MASK) >> 3 ; } ;
    inline BOOL  IsItalicized(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_ITALICS)) ; } ;
    inline BOOL  IsUnderLined(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_UNDERLINE)) ; } ;
    inline BOOL  IsFlashing(void) const    { return (0 != (m_uAttrib & AM_L21_FGEFFECT_FLASHING)) ; } ;
    inline BOOL  IsDirty(void) const       { return (0 != (m_uAttrib & AM_L21_ATTRIB_DIRTY)) ; } ;
    inline BOOL  IsMidRowCode(void) const  { return (0 != (m_uAttrib & AM_L21_ATTRIB_MRC)) ; } ;
    void  SetChar(UINT16 wChar) ;
    void  SetColor(UINT8 uColor) ;
    void  SetEffect(UINT8 uEffect) ;
    void  SetItalicized(BOOL bState) ;
    void  SetUnderLined(BOOL bState) ;
    void  SetFlashing(BOOL bState) ;
    void  SetDirty(BOOL bState) ;
    void  SetMidRowCode(BOOL bState) ;

} ;


//
//  CCaptionLine: The caption line details
//
class CCaptionLine {
protected:  // not private
    CCaptionChar m_aCapChar[MAX_CAPTION_COLUMNS] ;  // char details of line
    UINT8        m_uNumChars ;      // number of chars in the line
    UINT8        m_uStartRow ;      // start row of the line
    
public:
    CCaptionLine(void) ;
    CCaptionLine(const UINT uStartRow, const UINT uNumChars = 0) ;
    
    CCaptionLine& operator = (const CCaptionLine& cl) ;
    
    inline int   GetNumChars(void) const  { return m_uNumChars ; } ;
    inline void  SetNumChars(UINT uNumChars)  { m_uNumChars = uNumChars & 0x3F ; } ;
    int IncNumChars(UINT uNumChars) ;
    int DecNumChars(UINT uNumChars) ;
    inline void  GetCaptionChar(UINT uCol, CCaptionChar &cc) const {
        if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
            return ;
        cc = m_aCapChar[uCol] ;
    } ;
    void SetCaptionChar(UINT uCol, const CCaptionChar &cc) ;
    CCaptionChar* GetCaptionCharPtr(UINT uCol) ;
    inline int  GetStartRow(void)  { return m_uStartRow ; } ;
    void SetStartRow(UINT uRow) ;
    inline CCaptionChar* GetLineText(void) { return (CCaptionChar *) m_aCapChar ; }
    void MoveCaptionChars(int iNum) ;
    void ClearLine(void) ;

} ;

//
//  CRowIndexMap: Mapping of row usage (row to text line)
//
class CRowIndexMap {
private:
    DWORD         m_adwMap[2] ;  // bit map of row usage
    
public:
    inline CRowIndexMap(void)  { ClearRowIndex() ; }
    
    DWORD GetMap(int i) { 
        if (! (0 == i || 1 == i) )
            return 0 ;
        return m_adwMap[i] ; 
    } ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetRowIndex(UINT uLine, UINT8 uRow) ;
    inline void ClearRowIndex(void)  { m_adwMap[0] = m_adwMap[1] = 0 ; } ;
} ;


//
//  A set of flags and consts for caption buffer dirty state info
//
#define L21_CAPBUFFER_REDRAWALL     0x01
#define L21_CAPBUFFER_DIRTY         0x02
#define L21_CAPBUFFDIRTY_FLAGS      2


//
//  CCaptionBuffer: The caption buffer class details
//
class CCaptionBuffer {
protected:  // private
    CCaptionLine  m_aCapLine[MAX_CAPTION_LINES + 1] ;  // shall we always have an extra line? It's easier this way!!
    CRowIndexMap  m_RowIndex ;     // row index map bits
    UINT8         m_uNumLines ;    // # lines
    UINT8         m_uMaxLines ;    // max # lines (4 or less)
    UINT8         m_uCurrCol ;     // current column on the screen
    UINT8         m_uCurrLine ;    // max 4: maps row # to array index
    UINT8         m_uCaptionStyle ;// 0 = None, 1 = Pop-On, 2 = Paint-On, 3 = Roll-Up
    UINT8         m_uDirtyState ;  // caption buffer dirty state flags
    
public:
    CCaptionBuffer(UINT8 uStyle    = AM_L21_CCSTYLE_None, 
                   UINT8 uMaxLines = MAX_CAPTION_LINES) ;
    CCaptionBuffer(/* const */ CCaptionBuffer &cb) ;
    
    inline int  GetNumLines(void)  { return m_uNumLines ; } ;
    inline int  GetMaxLines(void)  { return m_uMaxLines ; } ;
    inline int  GetCurrRow(void)   { return m_aCapLine[m_uCurrLine].GetStartRow() ; } ;
    inline int  GetCurrCol(void)   { return m_uCurrCol ; } ;  // Why do we need it??
    inline int  GetCurrLine(void)  { return m_uCurrLine ; } ;
    inline int  GetRowIndex(UINT uRow)   { return m_RowIndex.GetRowIndex((UINT8)uRow) ; } ;
    inline int  GetStyle(void)     { return m_uCaptionStyle ; } ;
    
    inline void SetNumLines(int uNumLines)  { m_uNumLines = uNumLines & 0x7 ; } ;
    inline void SetMaxLines(int uMaxLines)  { 
        ASSERT(m_uMaxLines >= 0 && m_uMaxLines <= MAX_CAPTION_LINES) ;
        m_uMaxLines = uMaxLines & 0x7 ; 
    } ;
    inline void SetCurrRow(int uCurrRow)    {
        ASSERT(m_uCurrLine >= 0 && m_uCurrLine < m_uMaxLines) ;
        m_aCapLine[m_uCurrLine].SetStartRow(uCurrRow) ; 
    } ;
    void SetCurrCol(int uCurrCol) ;
    inline void SetCurrLine(int uLine)      { m_uCurrLine = uLine & 0x7 ; } ;
    inline void SetRowIndex(UINT uLine, UINT uRow)   { m_RowIndex.SetRowIndex(uLine, (UINT8)uRow) ; } ;
    inline void SetStyle(UINT8 uStyle)      { m_uCaptionStyle = uStyle ; } ;
    
    inline CCaptionLine& GetCaptionLine(UINT uLine)  {
        // uLine is assumed to have been verified in the caller
        return m_aCapLine[uLine] ;
    } ;
    void SetCaptionLine(UINT uLine, const CCaptionLine& cl) ;
    void ClearCaptionLine(UINT uLine) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    void ClearBuffer(void) ;
    void InitCaptionBuffer(void) ;
    int  IncNumLines(int uLines) ;
    int  DecNumLines(int uLines) ;
    CRowIndexMap& GetRowIndexMap(void)  { return m_RowIndex ; } ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    
    inline int  GetStartRow(UINT uLine) {
        return m_aCapLine[uLine].GetStartRow() ;
    } ;
    void SetStartRow(UINT uLine, UINT uRow) ;
    inline void GetCaptionChar(UINT uLine, UINT uCol, CCaptionChar& cc) {
        m_aCapLine[uLine].GetCaptionChar(uCol, cc) ;
    } ;
    inline void SetCaptionChar(UINT uLine, UINT uCol, const CCaptionChar& cc) {
        m_aCapLine[uLine].SetCaptionChar(uCol, cc) ;
    } ;
    inline CCaptionChar* GetCaptionCharPtr(UINT uLine, UINT uCol) {
        return m_aCapLine[uLine].GetCaptionCharPtr(uCol) ;
    } ;
    inline int IncNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].IncNumChars(uNumChars) ;
    } ;
    inline int DecNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].DecNumChars(uNumChars) ;
    } ;
    inline void MoveCaptionChars(int uLine, int iNum) {
        m_aCapLine[uLine].MoveCaptionChars(iNum) ;
    } ;
    
    inline BOOL IsBufferDirty(void)  { return m_uDirtyState & L21_CAPBUFFER_DIRTY ; } ;
    inline BOOL IsRedrawAll(void)    { return m_uDirtyState & L21_CAPBUFFER_REDRAWALL ; } ;

    BOOL IsRedrawLine(UINT8 uLine) ;
    void SetBufferDirty(BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
} ;

#endif // #ifndef _INC_L21DBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21dfilt.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Filter Interface
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif /* FILTER_DLL */

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"
#include "L21DFilt.h"

#include <mpconfig.h>   // IMixerPinConfig at connection


//
//  Setup Data
//
/* const */ AMOVIESETUP_MEDIATYPE sudLine21DecInType  = 
{ 
    &MEDIATYPE_AUXLine21Data,       // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_MEDIATYPE sudLine21DecOutType = 
{ 
    &MEDIATYPE_Video,               // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_PIN psudLine21DecPins[] = 
{ 
    { L"Input",                // strName
        FALSE,                   // bRendered
        FALSE,                   // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Output",               // strConnectsToPin
        1,                       // nTypes
        &sudLine21DecInType      // lpTypes
    },
    { L"Output",               // strName
        FALSE,                   // bRendered
        TRUE,                    // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Input",                // strConnectsToPin
        1,                       // nTypes
        &sudLine21DecOutType     // lpTypes
    } 
} ;

const AMOVIESETUP_FILTER sudLine21Dec = 
{ 
    &CLSID_Line21Decoder,         // clsID
    L"Line 21 Decoder",           // strName
    MERIT_NORMAL,                 // dwMerit
    2,                            // nPins
    psudLine21DecPins,            // lpPin
} ;

//  Nothing to say about the output pin

#ifdef FILTER_DLL

// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = 
{
    {   L"Line 21 Decoder",
        &CLSID_Line21Decoder,
        CLine21DecFilter::CreateInstance,
        NULL,
        &sudLine21Dec
    }
} ;

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
//  Exported entry points for registration and unregistration (in this case 
//  they only call through to default implmentations).
//
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE) ;
}

HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE) ;
}

#endif // FILTER_DLL



#ifndef UNALIGNED
#define UNALIGNED   // __unaligned
#endif // UNALIGNED


//
//  CLine21DecFilter class implementation
//

// static member init at file scope
CMessageWindow * CLine21DecFilter::m_pMsgWnd = NULL ;

//
//  Constructor
//
CLine21DecFilter::CLine21DecFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
: CTransformFilter(pName, pUnk, CLSID_Line21Decoder),

m_pbOutBuffer(NULL),
m_L21Dec(),
m_eSubTypeIDIn(AM_L21_CCSUBTYPEID_Invalid),
m_eGOP_CCType(GOP_CCTYPE_Unknown),
m_rtTimePerSample((LONGLONG) 166833), // 333667),
m_rtStart((LONGLONG) 0),
m_rtStop((LONGLONG) 0),
m_rtLastSample((LONGLONG) 0),
m_llMediaStart((LONGLONG) 0),
m_llMediaStop((LONGLONG) 0),
m_pviDefFmt(NULL),
m_dwDefFmtSize(0),
m_bMustOutput(FALSE),
m_bDiscontLast(FALSE),
m_uTimerID(0),
m_uTimerCount(0),
m_bTimerClearReqd(FALSE),
m_pPinDown(NULL),
m_bBlendingState(TRUE), // so that we read it once at least
m_dwBlendParam(1000)    // invalid by default -- valid value on setting to FALSE
{
    CAutoLock   Lock(&m_csFilter) ;
    
    DbgLog((LOG_TRACE, 1, 
        TEXT("CLine21DecFilter::CLine21DecFilter() -- Instantiating Line 21 Decoder filter"))) ;
    
    ASSERT(pName) ;
    ASSERT(phr) ;
    
    //
    // Create the message window and make sure that it has been created right; else error out
    //
    if (NULL == m_pMsgWnd)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Message handler window has to be created."))) ;
        m_pMsgWnd = new CMessageWindow ;
        if (NULL == m_pMsgWnd || NULL == m_pMsgWnd->GetHandle())
        {
            DbgLog((LOG_ERROR, 0, TEXT("Timer message handler window creation failed. Can't go ahead."))) ;
            ASSERT(phr) ;
            *phr = E_UNEXPECTED ; // what else to say!!
            return ;
        }
    }
    m_pMsgWnd->AddCount() ;

#ifdef PERF
#pragma message("Building for PERF measurements")
    m_idDelvWait  = MSR_REGISTER(TEXT("L21DPerf - Wait on Deliver")) ;
#endif // PERF
}


//
//  Destructor
//
CLine21DecFilter::~CLine21DecFilter()
{
    CAutoLock   Lock(&m_csFilter) ;
    
    DbgLog((LOG_TRACE, 1, 
        TEXT("CLine21DecFilter::~CLine21DecFilter() -- Destructing Line 21 Decoder filter"))) ;

    // In case the downstream pin interface wasn't released...
    if (m_pPinDown)
    {
        m_pPinDown->Release() ;
        m_pPinDown = NULL ;
    }
    
    // Release all the buffers allocated
    if (m_pviDefFmt)
    {
        delete m_pviDefFmt ;
        m_pviDefFmt = NULL ;
    }
    
    ASSERT(m_pMsgWnd) ;
    if (m_pMsgWnd && m_pMsgWnd->ReleaseCount() <= 0)  // -ve means bad!!!
    {
        delete m_pMsgWnd ;
        m_pMsgWnd = NULL ;
    }
    
    // Make sure we are not holding onto any DDraw surfaces (should be 
    // released during disconnect)
    DbgLog((LOG_TRACE, 1, TEXT("* Destroying the Line 21 Decoder filter *"))) ;
}


//
//  NonDelegatingQueryInterface
//
STDMETHODIMP CLine21DecFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL ;
    
    DbgLog((LOG_TRACE, 6, TEXT("somebody's querying my interface"))) ;
    if (IID_IAMLine21Decoder == riid)
    {
        return GetInterface((IAMLine21Decoder *) this, ppv) ;
    }
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv) ;
}


//
//  CreateInstance: Goes in the factory template table to create new instances
//
CUnknown * CLine21DecFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CLine21DecFilter(TEXT("Line 21 Decoder filter"), pUnk, phr) ;
}


STDMETHODIMP CLine21DecFilter::GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetDecoderLevel(0x%lx)"), lpLevel)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpLevel, sizeof(AM_LINE21_CCLEVEL)))
        return E_INVALIDARG ;
    
    *lpLevel = m_L21Dec.GetDecoderLevel() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetCurrentService(AM_LINE21_CCSERVICE *lpService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetCurrentService(0x%lx)"), lpService)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpService, sizeof(AM_LINE21_CCSERVICE)))
        return E_INVALIDARG ;
    
    *lpService = m_L21Dec.GetCurrentService() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetCurrentService(AM_LINE21_CCSERVICE Service)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetCurrentService(%lu)"), Service)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Service < AM_L21_CCSERVICE_None || Service > AM_L21_CCSERVICE_XDS)
        return E_INVALIDARG ;
    
    if (Service >= AM_L21_CCSERVICE_Text1)  // we don't have support for Text1/2 or XDS now.
        return E_NOTIMPL ;
    
    if (m_L21Dec.SetCurrentService(Service))  // if we must refresh output
        m_bMustOutput = TRUE ;                // then flag it here.

    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetServiceState(AM_LINE21_CCSTATE *lpState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetServiceState(0x%lx)"), lpState)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpState, sizeof(AM_LINE21_CCSTATE)))
        return E_INVALIDARG ;
    
    *lpState = m_L21Dec.GetServiceState() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetServiceState(AM_LINE21_CCSTATE State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetServiceState(%lu)"), State)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State < AM_L21_CCSTATE_Off || State > AM_L21_CCSTATE_On)
        return E_INVALIDARG ;
    
    if (m_L21Dec.SetServiceState(State))  // if we must refresh output
        m_bMustOutput = TRUE ;            // then flag it here.
    
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetOutputFormat(0x%lx)"), lpbmih)) ;
    // CAutoLock   Lock(&m_csFilter) ;
    return m_L21Dec.GetOutputFormat(lpbmih) ;
}

STDMETHODIMP CLine21DecFilter::SetOutputFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetOutputFormat(0x%lx)"), lpbmi)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    return E_NOTIMPL ;  // for now, until we do it properly

#if 0
    m_L21Dec.DeleteOutputDC() ;  // delete current DIB section
    
    HRESULT hr = m_L21Dec.SetOutputOutFormat(lpbmi) ;
    if (FAILED(hr))
        return hr ;
    
    // if the format details changed in any way, we should get the default
    // format data again (just to make sure).
    hr = GetDefaultFormatInfo() ;
    
    //
    // ONLY if we are running/paused, we need to create internal DIB section
    //
    if (m_State != State_Stopped)
    {
        if (! m_L21Dec.CreateOutputDC() )  // new DIBSection creation failed
        {
            DbgLog((LOG_ERROR, 0, TEXT("CreateOutputDC() failed!!!"))) ;
            return E_UNEXPECTED ;
        }
    }
    
    return hr ;
#endif // #if 0
}

STDMETHODIMP CLine21DecFilter::GetBackgroundColor(DWORD *pdwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetBackgroundColor(0x%lx)"), pdwPhysColor)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(pdwPhysColor, sizeof(DWORD)))
        return E_INVALIDARG ;
    
    m_L21Dec.GetBackgroundColor(pdwPhysColor) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetBackgroundColor(DWORD dwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetBackgroundColor(0x%lx)"), dwPhysColor)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (m_L21Dec.SetBackgroundColor(dwPhysColor))  // color key has really changed
    {
        // refill the output buffer only if we are not in stopped state
        if (State_Stopped != m_State)
            m_L21Dec.FillOutputBuffer() ;
    }
    
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetRedrawAlways(LPBOOL lpbOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetRedrawAlways(0x%lx)"), lpbOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpbOption, sizeof(BOOL)))
        return E_INVALIDARG ;
    *lpbOption = m_L21Dec.GetRedrawAlways() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetRedrawAlways(BOOL bOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetRedrawAlways(%lu)"), bOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    m_L21Dec.SetRedrawAlways(bOption) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetDrawBackgroundMode(0x%lx)"), lpMode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpMode, sizeof(AM_LINE21_DRAWBGMODE)))
        return E_INVALIDARG ;
    
    *lpMode = m_L21Dec.GetDrawBackgroundMode() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetDrawBackgroundMode(%lu)"), Mode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Mode < AM_L21_DRAWBGMODE_Opaque  || Mode > AM_L21_DRAWBGMODE_Transparent)
        return E_INVALIDARG ;
    m_L21Dec.SetDrawBackgroundMode(Mode) ;
    return NOERROR ;
}


//
//  VerifyGOPUDPacketData: Private helper method to verify GOP user data
//                         packet integrity.
//
BOOL CLine21DecFilter::VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    return (AM_L21_GOPUD_HDR_STARTCODE == GETGOPUD_L21STARTCODE(pGOPUDPacket->Header) &&  // valid start code
        AM_L21_GOPUD_HDR_INDICATOR == GETGOPUD_L21INDICATOR(pGOPUDPacket->Header) &&  // Line21 indicator
        AM_L21_GOPUD_HDR_RESERVED  == GETGOPUD_L21RESERVED(pGOPUDPacket->Header)  &&  // reserved bits
        GETGOPUD_NUMELEMENTS(pGOPUDPacket) > 0) ;                                     // +ve # elements
}


//
//  VerifyATSCUDPacketData: Private helper method to verify ATSC user data
//                          packet integrity.
//
BOOL CLine21DecFilter::VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    if (AM_L21_ATSCUD_HDR_STARTCODE  != GETATSCUD_STARTCODE(pATSCUDPacket->Header) ||  // invalid start code
        AM_L21_ATSCUD_HDR_IDENTIFIER != GETATSCUD_IDENTIFIER(pATSCUDPacket->Header))   // not ATSC Identifier
        return FALSE ;

    if (! ISATSCUD_TYPE_EIA(pATSCUDPacket) )   // not EIA-type CC
        return FALSE ;

    // Either EM or valid CC data is acceptable
    return (ISATSCUD_EM_DATA(pATSCUDPacket) ||             // EM data type  OR
            (ISATSCUD_CC_DATA(pATSCUDPacket)  &&           // CC data type  AND
             GETATSCUD_NUMELEMENTS(pATSCUDPacket) > 0)) ;  // +ve # CC elements
}


//
//  DetectGOPPacketDataType: Private helper method to detect if GOP user data
//                           packet is from a DVD disc, ATSC stream or others.
//
GOPPACKET_CCTYPE CLine21DecFilter::DetectGOPPacketDataType(BYTE *pGOPPacket)
{
    if (VerifyGOPUDPacketData((PAM_L21_GOPUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_DVD ;
    else if (VerifyATSCUDPacketData((PAM_L21_ATSCUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_ATSC ;
    else if (IsFillerPacket(pGOPPacket))
        return GOP_CCTYPE_None ;   // not a valid packet -- just ignore it
    else
        return GOP_CCTYPE_Unknown ; // it's some unknown format of CC packet
}


//
//  IsFillerPacket: Private helper method to check if the packet (at least header)
//                  contains only 0 bytes, which means it's a filler.
//
BOOL CLine21DecFilter::IsFillerPacket(BYTE *pGOPPacket)
{
    DWORD  dwStartCode = ((DWORD)(pGOPPacket[0]) << 24 | \
                          (DWORD)(pGOPPacket[1]) << 16 | \
                          (DWORD)(pGOPPacket[2]) <<  8 | \
                          (DWORD)(pGOPPacket[3])) ;

    // If first 4 bytes of packet is NOT the start code (0x1B2) then it's a filler
    return (AM_L21_GOPUD_HDR_STARTCODE != dwStartCode) ;
}


//
// The Timer Story:
//     We needed 2 timers -- one to fire every 33 mSec for completing scrolling and
//     another to fire after 3 Sec to time out CC in byte pair mode.  But we use
//     the "this" pointer (to the CLine21DecFilter object) as the uEventID in the
//     SetTimer() call so that we can access the filter object's properties in 
//     TimerProc (which is essential).
//     We can't create two different timers (with diff IDs) using the same event ID.
//     So we settled for one timer that fires every 30 mSec (close to 33 mSec). We
//     can set up the timer for 
//         (a) scrolling only (DVD) or (b) scrolling and CC erasing (TV).
//     We maintain a flag to differentiate between these two reasons. If we are in the
//     middle scrolling, we always do that. Otherwise if we opted for (a), we just exit
//     TimerProc(); in case (b), we just increment a counter, then see if it's >= 100 
//     as well as the last output sample we have sent down was a NON-clear one then we
//     create a sample to sent down and also turn off the timer.
//
void CALLBACK CLine21DecFilter::TimerProc(HWND hWnd, UINT uMsg, UINT_PTR uID, DWORD dwTime)
{
    DbgLog((LOG_TRACE, 1, TEXT("CLine21DecFilter::TimerProc(0x%p, 0x%lx, %lu, 0x%lx)"),
            (void*)hWnd, uMsg, uID, dwTime)) ;
    
    //
    // Verify that we are not handling some invalid messages
    //
    if (uMsg != WM_TIMER)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Who sent us this (%lu) message??"), uMsg)) ;
        return ;
    }
    
    // We specified "this" pointer as the ID to SetTimer() so that we get it here
    CLine21DecFilter *pL21Dec = (CLine21DecFilter *) uID ;
    
    CAutoLock  Lock2(&(pL21Dec->m_csFilter)) ;  // don't mess until we are done
    CAutoLock  Lock1(&(pL21Dec->m_csReceive)) ; // don't receive next sample until we are done
    
    if (0 == pL21Dec->m_uTimerID)  // timer has been killed in between
    {
        // that means we are still rolling; just skip the rest -- it's OK
        DbgLog((LOG_TRACE, 1, TEXT("INFO: Timer killed before TimerProc() kicked in"))) ;
        return ;
    }
 
    BOOL   bClearCC = FALSE ;  // assume we are not doing that here

    // First check if we are scrolling
    if (! pL21Dec->m_L21Dec.IsScrolling() )
    {
        DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): Not scrolling now"))) ;
        if (pL21Dec->m_bTimerClearReqd)  // timer is serving dual purpose
        {
            pL21Dec->m_uTimerCount++ ;
            if (pL21Dec->m_uTimerCount < 100)  // 100 means 3 Secs (with 30 mSec timer)
            {
                DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): Timer reqd to erase CC. But not yet time..."))) ;
                return ;
            }
            else  // time to erase old CC
            {
                if (pL21Dec->m_L21Dec.IsOutDIBClear())  // last sample sent down was clear. Turn off timer and get out
                {
                    DbgLog((LOG_TRACE, 1, TEXT("TimerProc(): Clear sample already sent out. Skip the rest."))) ;
                    pL21Dec->FreeTimer() ;
                    return ;
                }
                else  // clear old CC now
                {
                    DbgLog((LOG_TRACE, 1, TEXT("TimerProc(): Old CC needs to be cleared."))) ;
                    // pL21Dec->m_L21Dec.MakeClearSample() ;
                    pL21Dec->m_L21Dec.FlushInternalStates() ;
                    bClearCC = TRUE ;  // set a flag to test at the end of this function
                }
            }
        }
        else  // not scrolling and timer not for clearing old CC. Get out of here.
        {
            DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): Timer not reqd for erasing CC"))) ;
            return ;
        }
    }
    else  // we are scrolling!!!
    {
        DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): We are scrolling now. Deliver next sample."))) ;
        pL21Dec->m_uTimerCount = 0 ;  // non-clear sample is being sent now. Wait for 3 secs more
    }

    //
    // Looks like we got to send a sample down
    //
    DbgLog((LOG_TRACE, 1, TEXT("*** Preparing output sample in TimerProc() ***"))) ;
    HRESULT  hr ;
    IMediaSample  *pOut ;
    hr = pL21Dec->m_pOutput->GetDeliveryBuffer(&pOut, NULL, NULL, 
        pL21Dec->m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: GetDeliveryBuffer() on out pin failed (Error 0x%lx)"), hr)) ;
        return ;
    }
    pL21Dec->Transform(NULL, pOut) ;  // check if output buffer changed, use pIn=NULL
    
    // Copy the reqd scan lines from internal output DIBSection for next output sample
    pL21Dec->m_L21Dec.CopyOutputDIB() ;

    // Set time stamps etc. and increment the timestamps by their current difference
    REFERENCE_TIME  rtDiff = pL21Dec->m_rtStop - pL21Dec->m_rtStart ;
    pL21Dec->m_rtStart = pL21Dec->m_rtStop ;
    pL21Dec->m_rtStop = pL21Dec->m_rtStop + rtDiff ;
    hr = pOut->SetTime(&(pL21Dec->m_rtStart), &(pL21Dec->m_rtStop)) ;
    ASSERT(NOERROR == hr) ;
    pOut->SetSyncPoint(FALSE) ;
    pOut->SetDiscontinuity(pL21Dec->m_bSampleSkipped) ;
    pL21Dec->m_bSampleSkipped = FALSE ;
    
    // Now deliver the next output sample
    pL21Dec->SetBlendingState(TRUE) ;  // turn on blending first
    // Can't call MSR_xxx inside a static member function.
    // MSR_START(m_idDelvWait) ;  // delivering output sample
    hr = pL21Dec->m_pOutput->Deliver(pOut) ;
    // MSR_STOP(m_idDelvWait) ;   // done delivering output sample
    pOut->Release() ;
    DbgLog((LOG_TRACE, 1, TEXT("TimerProc(): Deliver() returned 0x%lx"), hr)) ;
    pL21Dec->m_rtLastSample = pL21Dec->m_rtStart ;  // remember this

    if (SUCCEEDED(hr))  // if out sample was delivered right
    {
        DbgLog((LOG_TRACE, 1, TEXT("*** Delivered %s output sample in TimerProc() (for time %s -> %s) ***"),
            bClearCC ? "clear" : "non-clear", 
            (LPCTSTR)CDisp(pL21Dec->m_rtStart), (LPCTSTR)CDisp(pL21Dec->m_rtStop))) ;
        if (bClearCC)    // if a clear sample was sent down,...
        {
            pL21Dec->FreeTimer() ; // ...we don't need a timer any more.
            pL21Dec->SetBlendingState(FALSE) ;  // turn off blending if clear sample delivered above
        }
    }
}


void CLine21DecFilter::SetupTimerIfReqd(BOOL bTimerClearReqd)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetupTimerIfReqd(%s)"),
            bTimerClearReqd ? "TRUE" : "FALSE")) ;
    // CAutoLock   Lock(&m_csFilter) ;

    // If we are running AND either we need CC ime-out or we are scrolling 
    if ( State_Running == m_State  &&
         ( bTimerClearReqd  ||
           m_L21Dec.IsScrolling()) )
    {
        // A callback to TimerProc (a static member fn) every 30 mSec.
        // The "this" pointer is passed in to identify decoder instance.
        // Receiving message window will call the TimerProc to do the work.
        m_uTimerID = SetTimer(m_pMsgWnd->GetHandle(), (DWORD_PTR)(LPVOID)this, 30, NULL /* TimerProc */) ;
        if (0 == m_uTimerID)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: SetTimer(0x%p, 0x%p, ...) failed (Error %ld)"), 
                (LPVOID)m_pMsgWnd->GetHandle(), (LPVOID)this, GetLastError())) ;
            ASSERT(FALSE) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("SetTimer(0x%lx, ..) created timer 0x%x (%s CC Timeout)"), 
                m_pMsgWnd->GetHandle(), m_uTimerID, bTimerClearReqd ? "Need" : "No")) ;
            m_bTimerClearReqd = bTimerClearReqd ;
            m_uTimerCount = 0 ;  // init timer count here
        }
    }
    else
        DbgLog((LOG_TRACE, 5, TEXT("Timer NOT started as we are not running/scrolling/NoCC-timeout"))) ;
}


void CLine21DecFilter::FreeTimer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::FreeTimer()"))) ;
    // CAutoLock   Lock(&m_csFilter) ;

    // If we have a valid timer then release it here
    if (m_uTimerID)
    {
        if (0 == KillTimer(m_pMsgWnd->GetHandle(), m_uTimerID))
        {
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: KillTimer(0x%lx, 0x%x) failed (Error %ld)"), 
                m_pMsgWnd->GetHandle(), m_uTimerID, GetLastError())) ;
            ASSERT(FALSE) ;  // just so that we know
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("TIMER (Id 0x%x) killed"), m_uTimerID)) ;
            m_uTimerID = 0 ;
            m_bTimerClearReqd = FALSE ;  // reset flag and...
            m_uTimerCount = 0 ;          // counter, just for safety
        }
    }
    else
        DbgLog((LOG_TRACE, 5, TEXT("Timer NOT set -- Timer ID=0x%x"), m_uTimerID)) ;
}


BOOL CLine21DecFilter::IsValidFormat(BYTE *pbFormat)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::IsValidFormat(0x%lx)"), pbFormat)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- can't do that as it may cause deadlock

    if (NULL == pbFormat)
        return FALSE ;

    BITMAPINFOHEADER *lpBMIH = HEADER(pbFormat) ;
    if (! ( 8 == lpBMIH->biBitCount || 16 == lpBMIH->biBitCount || 
           24 == lpBMIH->biBitCount || 32 == lpBMIH->biBitCount) )  // bad bitdepth
        return FALSE ;
    if ( !(BI_RGB == lpBMIH->biCompression || BI_BITFIELDS == lpBMIH->biCompression) ) // bad compression
        return FALSE ;
    if (DIBSIZE(*lpBMIH) != lpBMIH->biSizeImage) // invalid dimensions/size
        return FALSE ;

    return TRUE ;  // hopefully it's a valid video info header
}


void CLine21DecFilter::SetBlendingState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetBlendingState(%s)"), 
            bState ? "TRUE" : "FALSE")) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (m_bBlendingState == bState)  // nothing to change
        return ;

    if (NULL == m_pPinDown)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Downstream pin interface is not available"))) ;
        return ;
    }

    IMixerPinConfig  *pMPC ;
    HRESULT hr = m_pPinDown->QueryInterface(IID_IMixerPinConfig, (LPVOID *)&pMPC) ;
    if (FAILED(hr) || NULL == pMPC)
    {
        DbgLog((LOG_TRACE, 5, TEXT("IMixerPinConfig not available on pin %s"),
                (LPCTSTR) CDisp(m_pPinDown))) ;
        return ;
    }
    
    if (bState)  // turn it on -- CC needs to be mixed
    {
        DbgLog((LOG_TRACE, 5, TEXT("Calling SetBlendingParameter(%lu)"), m_dwBlendParam)) ;
        ASSERT( m_dwBlendParam <= 255) ;
        hr = pMPC->SetBlendingParameter(m_dwBlendParam) ;
        ASSERT(SUCCEEDED(hr)) ;
    }
    else         // turn it off -- CC need NOT be mixed
    {
        hr = pMPC->GetBlendingParameter(&m_dwBlendParam) ;
        ASSERT(SUCCEEDED(hr) && m_dwBlendParam <= 255) ;

        DbgLog((LOG_TRACE, 5, TEXT("Calling SetBlendingParameter(0)"))) ;
        hr = pMPC->SetBlendingParameter(0) ;
        ASSERT(SUCCEEDED(hr)) ;
    }
    m_bBlendingState = bState ;  // save last blending operation flag

    pMPC->Release() ;
}


HRESULT CLine21DecFilter::SendOutputSample(IMediaSample *pIn, 
                                           REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SendOutputSample(0x%lx, %s, %s)"), 
        pIn, prtStart ? (LPCTSTR)CDisp(*prtStart) : TEXT("NULL"), 
        prtStop ? (LPCTSTR)CDisp(*prtStop) : TEXT("NULL"))) ;
    
    HRESULT        hr ;
    
    // Get the new sample's bounding rect and compare it to the last one
    BOOL  bMTChangeOK = FALSE ;
    RECT  rectNew ;
    m_L21Dec.CalcOutputRect(&rectNew) ;
    if ( !ISRECTEQUAL(rectNew, m_rectLastOutput) )  // bounding rect changed
    {
        DbgLog((LOG_TRACE, 1, 
            TEXT("Bounding rect changed ((%ld, %ld, %ld, %ld) -> (%ld, %ld, %ld, %ld)). Change mediatype on output sample."),
            m_rectLastOutput.left, m_rectLastOutput.top, m_rectLastOutput.right, m_rectLastOutput.bottom,
            rectNew.left, rectNew.top, rectNew.right, rectNew.bottom)) ;
        VIDEOINFOHEADER *pVIH = (VIDEOINFOHEADER *) (m_mtOutput.Format()) ;
        ASSERT(pVIH) ;
        pVIH->rcSource = rectNew ;
        pVIH->rcTarget = rectNew ;
        if (m_pPinDown && S_OK == (hr = m_pPinDown->QueryAccept((AM_MEDIA_TYPE *) &m_mtOutput)))
        {
            DbgLog((LOG_TRACE, 1, TEXT("Mediatype OK to downstream pin. Rect:(L=%ld, T=%ld, R=%ld, B=%ld)"),
                    rectNew.left, rectNew.top, rectNew.right, rectNew.bottom)) ;  // log trace=3
            bMTChangeOK = TRUE ;
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("Mediatype NOT acceptable (Error 0x%lx) to downstream pin. Skipping rect spec-ing."), hr)) ;
            pVIH->rcSource = m_rectLastOutput ;  // restore old rect
            pVIH->rcTarget = m_rectLastOutput ;  // restore old rect
        }
    }
    
    // Turn on blending param, Deliver the sample, release mediasample i/f and set blending param
    SetBlendingState(TRUE) ;  // turn it on before delivering next sample

    // Get the output sample address before decoding
    IMediaSample  *pOut ;
    hr = m_pOutput->GetDeliveryBuffer(&pOut, NULL, NULL, 
                        m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: GetDeliveryBuffer() on out pin failed (Error 0x%lx)"), hr)) ;
        SetBlendingState(! m_L21Dec.IsOutDIBClear() ) ;  // restore blending state
        return NOERROR ;  // no point complaining -- probably the graph is stopping
    }
    Transform(pIn, pOut) ;  // check if output buffer address changed

    hr = pOut->SetTime(prtStart, prtStop) ;  // set the start & stop time on output sample
    ASSERT(SUCCEEDED(hr)) ;

    // Change the bounding rect ONLY IF the new rect was acceptable above
    if (bMTChangeOK)
    {
        hr = pOut->SetMediaType((AM_MEDIA_TYPE *) &m_mtOutput) ;
        ASSERT(SUCCEEDED(hr)) ;
        m_rectLastOutput = rectNew ; // save this for next round
    }

    // The time stamp and other settings now
    if (NULL == pIn)  // preparing out sample w/o valid in sample
    {
        // We assume that it must be a discontinuity as it's a forced output sample
        pOut->SetSyncPoint(TRUE) ;
        pOut->SetDiscontinuity(TRUE) ;
    }
    else  // input sample is valid 
    {
        LONGLONG  *pllMediaStart, *pllMediaStop ;
        if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
        {
            if (m_llMediaStop < m_llMediaStart + m_rtTimePerSample)
                m_llMediaStop = m_llMediaStart + m_rtTimePerSample ;
            pllMediaStart = (LONGLONG *)&m_llMediaStart ;
            pllMediaStop  = (LONGLONG *)&m_llMediaStop ;
        }
        else
        {
            pllMediaStart = pllMediaStop = NULL ;
        }
        hr = pOut->SetMediaTime(pllMediaStart, pllMediaStop) ;
        ASSERT(NOERROR == hr) ;
        
        pOut->SetSyncPoint(pIn->IsSyncPoint() == S_OK) ;
        pOut->SetDiscontinuity(m_bSampleSkipped ||S_OK == pIn->IsDiscontinuity()) ;
    }
    m_bSampleSkipped = FALSE ;
    
    // Copy output bitmap data to output buffer
    m_L21Dec.CopyOutputDIB() ;

    // Now deliver the output sample
    MSR_START(m_idDelvWait) ;  // delivering output sample
    hr = m_pOutput->Deliver(pOut) ;
    MSR_STOP(m_idDelvWait) ;   // done delivering output sample
    if (FAILED(hr))  // Deliver failed for some reason. Eat the error and just go ahead.
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Deliver() of output sample failed (Error 0x%lx)"), hr)) ;
        // Should we send an error notification to the graph?
    }
    pOut->Release() ;  // release the output sample

    SetBlendingState(! m_L21Dec.IsOutDIBClear() ) ;  // turn off/on based on output clear or not
    
    return NOERROR ;
}


// #define PACKET_DUMP
#ifdef PACKET_DUMP  // only for debug builds
//
// A helper function to dump the GOP Packets with Line21 data for internal debugging ONLY
//
void DumpPacket(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    AM_L21_GOPUD_ELEMENT Elem ;
    TCHAR                achBuffer[100] ;
    BOOL                 bDumped = TRUE ;
    int                  iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;
    
    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d (%2.2x)"), 
        iElems, pGOPUDPacket->Header.bTopField_Rsrvd_NumElems)) ;
    ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clean it
    for (int i = 0 ; i < iElems ; i++)
    {
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"), 
            (int)Elem.bMarker_Switch, (int)Elem.chFirst, (int)Elem.chSecond) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
            achBuffer[12 * (i % 6) + 10] = TEXT(' ') ;
        else
            achBuffer[12 * (i % 6) + 10] = TEXT('*') ; // indicates bad marker bit
        achBuffer[12 * (i % 6) + 11] = TEXT(' ') ;     // separator space
        bDumped = FALSE ;  // something not dumped yet
        
        if (0 == (i+1) % 6) // 6 elems per line
        {
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
            bDumped = TRUE ;
        }
    }  // end of for (i)
    
    // if there is something that's not been dumped yet, pad it with NULLs to the end
    // and then dump.
    if (!bDumped)
    {
        ZeroMemory(achBuffer + 12 * (i % 6), sizeof(TCHAR) * (100 - 12 * (i % 6))) ;
        DbgLog((LOG_TRACE, 0, achBuffer)) ;
    }
}


//
// A helper function to dump the ATSC Packets with Line21 data for internal debugging ONLY
//
void DumpATSCPacket(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    AM_L21_ATSCUD_ELEMENT Elem ;
    TCHAR                 achBuffer[100] ;
    BOOL                  bDumped = TRUE ;
    int                   iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;

    DbgLog((LOG_TRACE, 0, TEXT("Data Flags: %sEM, %sCC, %sAdditional"),
        ISATSCUD_EM_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_CC_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_ADDL_DATA(pATSCUDPacket) ? TEXT("") : TEXT("Not "))) ;
    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d"), iElems)) ;
    DbgLog((LOG_TRACE, 0, TEXT("EM Data: 0x%x"), GETATSCUD_EM_DATA(pATSCUDPacket))) ;

    if (ISATSCUD_CC_DATA(pATSCUDPacket))  // if CC data present then dump that
    {
        ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clear it
        for (int i = 0 ; i < iElems ; i++)
        {
            Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
            wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"),
                (int)Elem.bCCMarker_Valid_Type, (int)Elem.chFirst, (int)Elem.chSecond) ;
            if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
                achBuffer[12 * (i % 6) + 10] = ' ' ;
            else
                achBuffer[12 * (i % 6) + 10] = '*' ; // indicates bad marker bit
            achBuffer[12 * (i % 6) + 11] = ' ' ;     // separator space
            bDumped = FALSE ;  // something not dumped yet

            if (0 == (i+1) % 6) // 6 elems per line
            {
                DbgLog((LOG_TRACE, 0, achBuffer)) ;
                bDumped = TRUE ;
            }
        }  // end of for (i)

        // if there is something that's not been dumped yet, pad it with NULLs to the end
        // and then dump.
        if (!bDumped)
        {
            ZeroMemory(achBuffer + 12 * (i % 6), 100 - 12 * (i % 6)) ;
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
        }
    }

    DbgLog((LOG_TRACE, 0, TEXT("Marker bits: 0x%x"), GETATSCUD_MARKERBITS(pATSCUDPacket))) ;
}

#endif // PACKET_DUMP


HRESULT CLine21DecFilter::ProcessGOPPacket_DVD(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::ProcessGOPPacket_DVD(0x%lx)"), pIn)) ;

    HRESULT          hr ;
    REFERENCE_TIME  *prtStart, *prtStop ;
    LONGLONG        *pllMediaStart, *pllMediaStop ;
    LONGLONG         llMediaInterval ;
    BOOL             bCapUpdated ;         // has caption been updated?

    // Get the input data packet and verify that the contents are OK
    PAM_L21_GOPUD_PACKET  pGOPUDPacket ;
    hr = pIn->GetPointer((LPBYTE *)&pGOPUDPacket) ;
    ASSERT(hr == NOERROR) ;
    if (! VerifyGOPUDPacketData(pGOPUDPacket) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() != GETGOPUD_PACKETSIZE(pGOPUDPacket))
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("pIn->GetActualDataLength() [%d] and data size [%d] in packet mismatched"),
            pIn->GetActualDataLength(), GETGOPUD_PACKETSIZE(pGOPUDPacket))) ;
        return S_FALSE ;
    }
    
#ifdef PACKET_DUMP
    DumpPacket(pGOPUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_GOPUD_ELEMENT    Elem ;
    REFERENCE_TIME          rtInterval ;
    int     iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }
    
    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s)) discon(%d)"),
            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(rtTemp), (LPCTSTR)CDisp(m_rtStop),
            S_OK == pIn->IsDiscontinuity())) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;
        
        prtStart = (REFERENCE_TIME *)&m_rtStart ;
        prtStop  = (REFERENCE_TIME *)&m_rtStop ;
        rtInterval = (m_rtStop - m_rtStart) / iElems ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        prtStart = prtStop  = NULL ;
        rtInterval = 0 ;
    }
    
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 33msec/frame in the GOP for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        pllMediaStart   = (LONGLONG *)&m_llMediaStart ;
        pllMediaStop    = (LONGLONG *)&m_llMediaStop ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        pllMediaStart = pllMediaStop = NULL ;
        llMediaInterval = 0 ;
    }
    
    BOOL   bFoundGood = FALSE ;  // until a pair is decoded successfully
    BOOL   bReady ;
    BOOL   bTopFirst = ISGOPUD_TOPFIELDFIRST(pGOPUDPacket) ;
    DbgLog((LOG_TRACE, 5,
            TEXT("Got a Line21 packet with %d elements, %s field first"),
            iElems, bTopFirst ? "Top" : "Bottom")) ;
    for (int i = bTopFirst ? 0 : 1 ;  // if top field is not first,
         i < iElems ; i++)            // pick next field to start with
    {
        m_rtStop = m_rtStart + rtInterval ;  // m_rtTimePerSample ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
        {
            //
            // In the WB titles the bottom field's data has wrong marker 
            // bit set so that we don't try to decode them. But the titles
            // from Columbia/Tristar (and God knows who else) doesn't do
            // that causing us to look at every field's data which causes
            // CC to flash away with the arrival of the next EOC (14 2F),
            // because it's not recognized as the repeat of the last EOC
            // due to the (0, 0) pair with valid marker bit. So we knowingly
            // skip the alternate field's data to avoid this problem.
            //
            if ( (bTopFirst  && (i & 0x01))  ||     // top first & odd index
                 (!bTopFirst && 0 == (i & 0x01)) )  // bottom first & even index
            {
                DbgLog((LOG_TRACE, 5,
                    TEXT("(0x%x, 0x%x) decode skipped for element %d -- the 'other' field"),
                    Elem.chFirst, Elem.chSecond, i)) ;
                // Advance the time stamps anyway
                m_rtStart = m_rtStop ;
                m_llMediaStart = m_llMediaStop ;
                continue ;
            }

            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and try the next element.
            if (! m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond) )
            {
                // if we must output a sample because:
                // a) we haven't sent down any sample in this play session  or
                // b) we need to refresh the output because some component
                //    set this flag, e.g, 
                //    * SetServiceState(.._Off)  or 
                //    * we got a discontinuity sample
                //    * no valid packet came for last 3 secs
                // So we must deliver one output sample with current caption content.
                if (m_bMustOutput)
                {
                    DbgLog((LOG_TRACE, 1,
                        TEXT("(0x%x, 0x%x) decode failed, but allowing one output sample"),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else if (m_L21Dec.IsScrolling())
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("(0x%x, 0x%x) decode failed, but scrolling now; so..."),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                        Elem.chFirst, Elem.chSecond)) ;
                    
                    // We need to increment the time stamp though;
                    // stop time for this sample is start time for next sample
                    m_rtStart = m_rtStop ;
                    m_llMediaStart = m_llMediaStop ;
                    continue ;  // bad data; proceed to next pair...
                }
            }
            else
            {
                bFoundGood = TRUE ;    // got one good pair
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            
            // If we are in non-PopOn mode, update caption, if reqd.
            bCapUpdated = m_L21Dec.UpdateCaptionOutput() ;
            
            // Output a sample only if either
            // a) we must output (the flag is set)   or
            // b) we are in non-PopOn mode and need to update captions   or
            // c) we are in the middle of scrolling   or
            // d) we are in PopOn mode AND caption needs to/should be updated
            if (m_bMustOutput ||                      // (a)
                bCapUpdated   ||                      // (b)
                m_L21Dec.IsScrolling() ||             // (c)
                (bReady = m_L21Dec.IsOutputReady())) // (d)
            {
                DbgLog((LOG_TRACE, 3,
                    TEXT("Preparing output sample because Must=%s, CapUpdtd=%s, Ready=%s"),
                    m_bMustOutput ? "T" : "F", bCapUpdated ? "T" : "F", bReady ? "T" : "F")) ;
                
                // Now send the output sample down
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    // return hr ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, 
                        TEXT("Delivered an output sample (Time: Start=%s, Stop=%s)"),
                        (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    m_bMustOutput = FALSE;     // we have output just now
                }
                
                // The DVD titles don't turn off caption when there is no conversation.
                // So we keep track of when we delivered the last output sample, so that
                // in 3 seconds if we don't get the next valid input packet, we flush our
                // buffers and clear CC output by forced delivery of a clear sample.
                m_rtLastSample = m_rtStart ;  // remember this
                
            }  // end of if (should/must we output?)
        }
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid flag"),
                Elem.bMarker_Switch, Elem.chFirst, Elem.chSecond)) ;
        
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)
    
    //
    // Flush the current caption buffer contents and set the 
    // "must output on next chance" flag so that a clear sample is 
    // delivered next time around, if
    // a) we didn't find any good pair in this packet   AND 
    // b) the last sample we sent down wasn't a clear sample   AND
    // c) it has already been 3 seconds since we sent the last output sample
    //
    if ( ! bFoundGood   && 
         ! m_L21Dec.IsOutDIBClear()  &&
         (m_rtStart > m_rtLastSample + (LONGLONG)30000000))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Long gap after last sample. Clearing CC. (Good=%s, Clear=%s)"),
                bFoundGood ? "T" : "F", m_L21Dec.IsOutDIBClear() ? "T" : "F")) ;
        // m_L21Dec.MakeClearSample() ;
        m_L21Dec.FlushInternalStates() ;
        m_bMustOutput = TRUE ;
    }

    return S_OK ;
}


HRESULT CLine21DecFilter::ProcessGOPPacket_ATSC(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::ProcessGOPPacket_ATSC(0x%lx)"), pIn)) ;

    HRESULT          hr ;
    REFERENCE_TIME  *prtStart, *prtStop ;
    LONGLONG        *pllMediaStart, *pllMediaStop ;
    LONGLONG         llMediaInterval ;
    BOOL             bCapUpdated ;         // has caption been updated?

    // Get the input data packet and verify that the contents are OK
    PAM_L21_ATSCUD_PACKET pATSCUDPacket ;
    
    // Get the input data packet and verify that the contents are OK
    hr = pIn->GetPointer((LPBYTE *)&pATSCUDPacket) ;
    ASSERT(hr == NOERROR) ;
    if (! VerifyATSCUDPacketData(pATSCUDPacket) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("ATSC Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() < GETATSCUD_PACKETSIZE(pATSCUDPacket))
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("pIn->GetActualDataLength() [%d] is less than minm ATSC packet data size [%d]"),
            pIn->GetActualDataLength(), GETATSCUD_PACKETSIZE(pATSCUDPacket))) ;
        return S_FALSE ;
    }
    
#ifdef PACKET_DUMP
    DumpATSCPacket(pATSCUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_ATSCUD_ELEMENT    Elem ;
    REFERENCE_TIME           rtInterval ;
    int     iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }
    
    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the ATSC for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s)) discon(%d)"),
            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(rtTemp), (LPCTSTR)CDisp(m_rtStop),
            S_OK == pIn->IsDiscontinuity())) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;
        
        prtStart = (REFERENCE_TIME *)&m_rtStart ;
        prtStop  = (REFERENCE_TIME *)&m_rtStop ;
        rtInterval = (m_rtStop - m_rtStart) / iElems ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        prtStart = prtStop  = NULL ;
        rtInterval = 0 ;
    }
    
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 33msec/frame in the ATSC for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        pllMediaStart   = (LONGLONG *)&m_llMediaStart ;
        pllMediaStop    = (LONGLONG *)&m_llMediaStop ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        pllMediaStart = pllMediaStop = NULL ;
        llMediaInterval = 0 ;
    }
    
    BOOL   bFoundGood = FALSE ;  // until a pair is decoded successfully
    BOOL   bReady ;
    for (int i = 0 ; i < iElems ; i++)
    {
        m_rtStop = m_rtStart + rtInterval ;  // m_rtTimePerSample ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
        if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
        {
            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and try the next element.
            if (! m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond) )
            {
                // if we must output a sample because:
                // a) we haven't sent down any sample in this play session  or
                // b) we need to refresh the output because some component
                //    set this flag, e.g, 
                //    * SetServiceState(.._Off)  or 
                //    * we got a discontinuity sample
                //    * no valid packet came for last 3 secs
                // So we must deliver one output sample with current caption content.
                if (m_bMustOutput)
                {
                    DbgLog((LOG_TRACE, 1,
                        TEXT("(0x%x, 0x%x) decode failed, but allowing one output sample"),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else if (m_L21Dec.IsScrolling())
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("(0x%x, 0x%x) decode failed, but scrolling now; so..."),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                        Elem.chFirst, Elem.chSecond)) ;
                    
                    // We need to increment the time stamp though;
                    // stop time for this sample is start time for next sample
                    m_rtStart = m_rtStop ;
                    m_llMediaStart = m_llMediaStop ;
                    continue ;  // bad data; proceed to next pair...
                }
            }
            else
            {
                bFoundGood = TRUE ;    // got one good pair
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            
            // If we are in non-PopOn mode, update caption, if reqd.
            bCapUpdated = m_L21Dec.UpdateCaptionOutput() ;
            
            // Output a sample only if either
            // a) we must output (the flag is set)   or
            // b) we are in non-PopOn mode and need to update captions   or
            // c) we are in the middle of scrolling   or
            // d) we are in PopOn mode AND caption needs to/should be updated
            if (m_bMustOutput ||                      // (a)
                bCapUpdated   ||                      // (b)
                m_L21Dec.IsScrolling() ||             // (c)
                (bReady = m_L21Dec.IsOutputReady())) // (d)
            {
                DbgLog((LOG_TRACE, 3,
                    TEXT("Preparing output sample because Must=%s, CapUpdtd=%s, Ready=%s"),
                    m_bMustOutput ? "T" : "F", bCapUpdated ? "T" : "F", bReady ? "T" : "F")) ;
                
                // Now send the output sample down
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    // return hr ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, 
                        TEXT("Delivered an output sample (Time: Start=%s, Stop=%s)"),
                        (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    m_bMustOutput = FALSE;     // we have output just now
                }
                
                // The DVD titles don't turn off caption when there is no conversation.
                // So we keep track of when we delivered the last output sample, so that
                // in 3 seconds if we don't get the next valid input packet, we flush our
                // buffers and clear CC output by forced delivery of a clear sample.
                m_rtLastSample = m_rtStart ;  // remember this
                
            }  // end of if (should/must we output?)
        }
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid marker/type flag"),
                Elem.bCCMarker_Valid_Type, Elem.chFirst, Elem.chSecond)) ;
        
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)
    
    //
    // Flush the current caption buffer contents and set the 
    // "must output on next chance" flag so that a clear sample is 
    // delivered next time around, if
    // a) we didn't find any good pair in this packet   AND 
    // b) the last sample we sent down wasn't a clear sample   AND
    // c) it has already been 3 seconds since we sent the last output sample
    //
    if ( ! bFoundGood   && 
         ! m_L21Dec.IsOutDIBClear()  &&
         (m_rtStart > m_rtLastSample + (LONGLONG)30000000))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Long gap after last sample. Clearing CC. (Good=%s, Clear=%s)"),
                bFoundGood ? "T" : "F", m_L21Dec.IsOutDIBClear() ? "T" : "F")) ;
        // m_L21Dec.MakeClearSample() ;
        m_L21Dec.FlushInternalStates() ;
        m_bMustOutput = TRUE ;
    }

    return S_OK ;
}


//
//  Receive: It's the real place where the output samples are created by
//           decoding the byte pairs out of the input stream.
//
HRESULT CLine21DecFilter::Receive(IMediaSample * pIn)
{
    CAutoLock   lock(&m_csReceive);
    HRESULT     hr ;
    
    DbgLog((LOG_TRACE, 3, TEXT("CLine21DecFilter::Receive(0x%p)"), pIn)) ;

    //
    // First check if we must do anything at all
    //
    if (!m_bMustOutput  &&                                         // not a must output
        (AM_L21_CCSTATE_Off    == m_L21Dec.GetServiceState()  ||   // CC turned off
         AM_L21_CCSERVICE_None == m_L21Dec.GetCurrentService()))   // no CC selected
    {
        DbgLog((LOG_TRACE, 1, 
            TEXT("Captioning is off AND we don't HAVE TO output. Skipping everything."))) ;
        return NOERROR ;  // we are done with this sample
    }

    // Get the input format info; we'll use the same for output
    ASSERT(m_pOutput != NULL) ;
    
    //
    // The real decoding part is here
    //
    REFERENCE_TIME       *prtStart, *prtStop ;
    BYTE                 *pbInBytePair = NULL ;  // to shut up compiler
    LONG                  lInDataSize ;
    BOOL                  bCapUpdated ;         // has caption been updated?
    
    //
    // Process the sample based on filter's input format type
    //
    switch (m_eSubTypeIDIn)
    {
    case AM_L21_CCSUBTYPEID_BytePair:
        {
            hr = pIn->GetPointer(&pbInBytePair) ;      // Get the input byte pair
            lInDataSize = pIn->GetActualDataLength() ; // se how much data we got
            if (FAILED(hr)  ||  2 != lInDataSize)  // bad data -- complain and just skip it
            {
                DbgLog((LOG_ERROR, 0, TEXT("%d bytes of data sent as Line21 data (hr = 0x%lx)"), 
                    lInDataSize, hr)) ;
                break ;
            }
            
            //
            // m_rtTimePerSample is set to 166833 for DVD GOP packet case.
            // We don't use this member's value here.  If we need in future,
            // we have to set some suitable value here.
            //
            
            if (NOERROR == (hr = pIn->GetTime(&m_rtStart, &m_rtStop)))
            {
                prtStart = (REFERENCE_TIME *)&m_rtStart ;
                prtStop  = (REFERENCE_TIME *)&m_rtStop ;
            }
            else
            {
                DbgLog((LOG_TRACE, 0, TEXT("WARNING: GetTime() failed (Error 0x%lx)"), hr)) ;
                prtStart = prtStop  = NULL ;
            }

            //
            // We are here with some data; so don't need a timer for now
            //
            FreeTimer() ;

            hr = pIn->IsDiscontinuity() ;
            if (S_OK == hr)  // got a discontinuity; flush everything, refresh output
            {
                // If we got a discontinuity in the last sample, we flushed and all.
                // We can skip this one safely.
                if (m_bDiscontLast)
                {
                    DbgLog((LOG_TRACE, 1, TEXT("Got a discontinuity sample after another. Skipping everything."))) ;
                    break ;
                }

                // Flush the internal buffers (caption and output DIB section)
                DbgLog((LOG_TRACE, 0, TEXT("Got a discontinuity sample. Flushing all data..."))) ;
                m_L21Dec.FlushInternalStates() ;
                
                // Send the clear sample down as output
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    return hr ;
                }
                m_rtLastSample = m_rtStart ;  // remember this
                m_bDiscontLast = TRUE ;       // remember we handled a discontinuity
                DbgLog((LOG_TRACE, 1, TEXT("Sent a clear sample for discont."))) ;
                break ;
            }
            DbgLog((LOG_TRACE, 3, TEXT("Got sample with bytes 0x%x, 0x%x (Time: %s -> %s)"),
                    pbInBytePair[0], pbInBytePair[1],
                    (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ; // log trace=?
            m_bDiscontLast = FALSE ;       // remember we got a normal sample
            
            // Now decode into the received output sample buffer; if fails, we don't
            // need to do the rest, mostly.
            if (! m_L21Dec.DecodeBytePair(pbInBytePair[0], pbInBytePair[1]) )
            {
                // if we must output a sample such as:
                // a) if we haven't sent down any sample in this play session
                // b) if some component set this flag (e.g, SetServiceState(.._Off)
                //    and as a result we need to refresh the output
                // we need to deliver one output sample with current caption content.
                if (m_bMustOutput)
                {
                    DbgLog((LOG_TRACE, 1,
                        TEXT("(0x%x, 0x%x) decode failed, but allowing one output sample"),
                        pbInBytePair[0], pbInBytePair[1])) ;
                }
                else if (m_L21Dec.IsScrolling())
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("(0x%x, 0x%x) decode failed, but scrolling now; so..."),
                        pbInBytePair[0], pbInBytePair[1])) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, TEXT("(0x%x, 0x%x) decode failed"),
                        pbInBytePair[0], pbInBytePair[1])) ;

                    //
                    // Flush the current caption buffer contents and set the 
                    // "must output on next chance" flag so that a clear sample is 
                    // delivered by the code below, if
                    // a) the last sample we sent down wasn't a clear sample   AND
                    // b) it has already been 6 seconds since we sent the last output sample
                    //
                    if ( ! m_L21Dec.IsOutDIBClear()  &&
                         (m_rtStart > m_rtLastSample + (LONGLONG)60000000))
                    {
                        DbgLog((LOG_TRACE, 0, 
                            TEXT("Long gap after last sample. Clearing CC. (Clear=%s)"),
                            m_L21Dec.IsOutDIBClear() ? "T" : "F")) ;
                        // m_L21Dec.MakeClearSample() ;  --- I would rather flush everything
                        m_L21Dec.FlushInternalStates() ;
                        m_bMustOutput = TRUE ;  // will be delivered below...
                    }
                    // else         // it was just bad data; ignore it and ...
                    //     break ;  // ...proceed to next pair
                }
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                        pbInBytePair[0], pbInBytePair[1])) ;
                m_rtLastSample = m_rtStart ;  // remember last valid byte pair time
            }
            
            // Update caption output for non-PopOn mode, if reqd.
            bCapUpdated = m_L21Dec.UpdateCaptionOutput() ;
            
            // Output a sample only if either
            // a) we must output (the flag is set)   or
            // b) we are in non-PopOn mode and need to update captions   or
            // c) we are in the middle of scrolling   or
            // d) we are in PopOn mode AND caption needs to/should be updated
            if (m_bMustOutput ||            // (a)
                bCapUpdated ||              // (b)
                m_L21Dec.IsScrolling() ||   // (c)
                m_L21Dec.IsOutputReady())  // (d)
            {
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    // return hr ;
                }
                else
                {
                    m_bMustOutput = FALSE ;  // we have successfully output a sample
                    m_rtLastSample = m_rtStart ;  // remember this
                    DbgLog((LOG_TRACE, 3, TEXT("Output sample delivered for (0x%x, 0x%x)"),
                            pbInBytePair[0], pbInBytePair[1])) ;
                }
            }  // end if (must/should we output?)
            
            //
            // If we are scrolling, we may need a timer to later tell us it's 
            // time to produce and deliver more output samples, even though there
            // is no input data coming in.
            //
            SetupTimerIfReqd(TRUE) ;  //  CC time-out reqd
            
            break ;
        }
        
        case AM_L21_CCSUBTYPEID_VBIRawData:
            DbgLog((LOG_TRACE, 1, TEXT("Raw byte pair case has not been implemented yet"))) ;
            break ;
            
        case AM_L21_CCSUBTYPEID_GOPPacket:
            {
                //
                // We are here with some data; so don't need a timer for now
                //
                FreeTimer() ;

                // First check if this is a discontinuity sample. If so just clear everything
                hr = pIn->IsDiscontinuity() ;
                if (S_OK == hr)  // got a discontinuity; flush everything, refresh output
                {
                    // If we got a discontinuity in the last sample, we flushed and all.
                    // We can skip this one safely.
                    if (m_bDiscontLast)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("Got a discontinuity sample after another. Skipping everything."))) ;
                        break ;
                    }

                    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
                    {
                        if (m_rtStop < m_rtStart + m_rtTimePerSample)
                            m_rtStop = m_rtStart + m_rtTimePerSample ;
                        DbgLog((LOG_TRACE, 0, TEXT("Received a **discontinuity** : Start=%s, Stop=%s"),
                            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    }
                    else  // cook up something reasonable
                    {
                        m_rtStart = (REFERENCE_TIME) 0 ;
                        m_rtStop = m_rtStart + m_rtTimePerSample ;
                        DbgLog((LOG_TRACE, 1, TEXT("Cooked up **discontinuity** time as Start=%s, Stop=%s"),
                            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    }
                    prtStart = (REFERENCE_TIME *)&m_rtStart ;
                    prtStop  = (REFERENCE_TIME *)&m_rtStop ;
                    
                    // Flush the internal buffers (caption and output DIB section)
                    m_L21Dec.FlushInternalStates() ;
                    
                    // Now send the clear sample down
                    hr = SendOutputSample(pIn, prtStart, prtStop) ;
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending clear output sample failed (Error 0x%lx)"), hr)) ;
                        // return hr ;
                    }
                    else
                    {
                        DbgLog((LOG_TRACE, 0, TEXT("Clear output sample delivered for discont."))) ;
                        m_bMustOutput = FALSE ;  // we have just delivered an output sample
                        m_bDiscontLast = TRUE ;  // we handled a disocntinuity sample
                        m_rtLastSample = m_rtStart ;  // remember this
                    }
                    
                    m_rtStart = m_rtStop ;
                    m_llMediaStart = m_llMediaStop ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got a normal CC data sample"))) ;
                    m_bDiscontLast = FALSE ;  // got a normal sample
                }
                
                //
                // Even if it's a discontinuity sample it may have some data too (??).
                // Handle as necessary.  No harm in checking!!!
                //

                BYTE *pbGOPPacket ;
                hr = pIn->GetPointer((LPBYTE *)&pbGOPPacket) ;
                ASSERT(hr == NOERROR) ;
                GOPPACKET_CCTYPE  eGOP_CCType = DetectGOPPacketDataType(pbGOPPacket) ;
                if (GOP_CCTYPE_None != eGOP_CCType  && // NOT filler CC packet  AND...
                    m_eGOP_CCType   != eGOP_CCType)    // change of CC type
                {
                    DbgLog((LOG_TRACE, 3, TEXT("GOPPacket CC type changed from %d to %d"), 
                            m_eGOP_CCType, eGOP_CCType)) ;

                    // Flush internal caption buffers and output sample buffer
                    m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
                    m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
                    m_bMustOutput  = TRUE ;          // we must output a sample NOW

                    m_eGOP_CCType = eGOP_CCType ;    // switch to new CC type
                }

                switch (m_eGOP_CCType)
                {
                case GOP_CCTYPE_DVD:
                    hr = ProcessGOPPacket_DVD(pIn) ;
                    break ;

                case GOP_CCTYPE_ATSC:
                    hr = ProcessGOPPacket_ATSC(pIn) ;
                    break ;

                default:
                    DbgLog((LOG_TRACE, 3, TEXT("Unknown GOP packet data type (%d)"), m_eGOP_CCType)) ;
                    break ;
                }  // end of switch (.._CCType)

                //
                // If we are scrolling, we may need a timer to later tell us it's 
                // time to produce and deliver more output samples, even though there
                // is no input data coming in.
                //
                SetupTimerIfReqd(FALSE) ;  // CC time-out NOT reqd as (invalid) data keeps coming
                
                break ;
        }  // end of case ..._GOPPacket

        default:  // it's a bad data format type (how could we get into it?)
            DbgLog((LOG_ERROR, 0, TEXT("We are in a totally unexpected format type"))) ;
            return E_FAIL ;  // or E_UNEXPECTED ; ???
    }
    
    //
    // Decoding for this sample is done
    //
    
    return NOERROR ;
}


//
//  Transform: It's mainly a place holder because we HAVE to override it.
//             The actual work is done in Receive() itself. Here we detect
//             if the buffer addres provided by downstream filter's allocator
//             has changed or not; if yes, we have to re-write entire text.
//
HRESULT CLine21DecFilter::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    DbgLog((LOG_TRACE, 3, TEXT("CLine21DecFilter::Transform(0x%p, 0x%p)"), 
            pIn, pOut)) ;
    
    UNREFERENCED_PARAMETER(pIn) ;
    
    HRESULT   hr ;
    LPBITMAPINFO       lpbiNew ;
    BITMAPINFOHEADER   biCurr ;
    
    // Check if there has been any dynamic format change; if so, adjust output
    // width, height, bitdepth accordingly.
    AM_MEDIA_TYPE  *pmt ;
    hr = pOut->GetMediaType(&pmt) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (S_OK == hr)  // i.e, format has changed
    {
        hr = pOut->SetMediaType(NULL) ; // just to tell OverlayMixer, I am not changing again
        ASSERT(SUCCEEDED(hr)) ;
        m_mtOutput = *pmt ;
        lpbiNew = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->pbFormat))) ;
        m_L21Dec.GetOutputFormat(&biCurr) ;
        if (0 != memcmp(lpbiNew, &biCurr, sizeof(BITMAPINFOHEADER)))
        {
            // output format has been changed -- update our internel values now
            DbgLog((LOG_TRACE, 2, TEXT("Output format has been dynamically changed"))) ;
            m_L21Dec.DeleteOutputDC() ;  // delete current DIB section first
            m_L21Dec.SetOutputOutFormat(lpbiNew) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
            
            //
            // We must be running/paused; so we need to create internal DIB section
            //
            ASSERT(m_State != State_Stopped) ;
            if (m_State != State_Stopped)
            {
                if (! m_L21Dec.CreateOutputDC() )  // new DIBSection creation failed
                {
                    DbgLog((LOG_ERROR, 0, TEXT("CreateOutputDC() failed!!!"))) ;
                    return E_UNEXPECTED ;
                }
            }
            
            //
            // If key color has changed, we need to use the new color from now
            //
#pragma message("Most probably the following call is redundant (and risky)")
            DbgLog((LOG_TRACE, 0, TEXT("Should have called GetColorKey() in dyna format change"))) ;
            // GetActualColorKey() ;
        }
        
        m_pOutput->CurrentMediaType() = *pmt ;
        DeleteMediaType(pmt) ;
    }
    
    // Check if the out put buffer has changed; if so, store new buffer address
    LPBYTE      pbOutBuffer ;
    pOut->GetPointer(&pbOutBuffer) ;
    if (m_pbOutBuffer != pbOutBuffer)   // different output buffer this time
    {
        m_pbOutBuffer = pbOutBuffer ;
        m_L21Dec.SetOutputBuffer(pbOutBuffer) ;
    }
    
    return S_OK ;
}


//
//  BeginFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter::BeginFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::BeginFlush()"))) ;

    CAutoLock   Lock(&m_csFilter) ;
    
    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverBeginFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: DeliverBeginFlush() on out pin failed (Error 0x%lx)"), hr)) ;
    }
    
    return hr ;
}


//
//  EndFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter::EndFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::EndFlush()"))) ;
    
    CAutoLock   Lock(&m_csFilter) ;
    
    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverEndFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: DeliverEndFlush() on out pin failed (Error 0x%lx)"), hr)) ;
    }
    
    return hr ;
}


//
//  EndOfStream: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter::EndOfStream(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::EndOfStream()"))) ;
    CAutoLock   Lock(&m_csFilter) ;
    
    HRESULT     hr = NOERROR ;
    
    //
    //  Make sure we are not in the middle of a scrolling. If so,
    //  force a few NULLs (specially in byte pair format) to make 
    //  the scrolling complete.
    //
    //  m_L21Dec.CompleteScrolling() ;  // It doesn't do anything now
    
    // Now send EOS downstream
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverEndOfStream() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: DeliverEndOfStream() on out pin failed (Error 0x%lx)"), hr)) ;
    }
    
    return hr ;
}


HRESULT CLine21DecFilter::GetDefaultFormatInfo(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetDefaultFormatInfo()"))) ;
    //
    // We can't take the lock in this method, because it is called in Transform()
    // which is called from Receive() causing us to take m_csReceive and then
    // m_csFilter which is opposite of what Stop, Pause etc. methods do thereby
    // causing a potential for deadlock.
    //

    // build a VIDEOINFO struct with default internal BITMAPINFO
    DWORD   dwSize ;
    m_L21Dec.GetDefaultFormatInfo(NULL, &dwSize) ;
    
    if (m_dwDefFmtSize != dwSize + SIZE_PREHEADER)
    {
        if (m_pviDefFmt)
        {
            delete m_pviDefFmt ;
            m_pviDefFmt = NULL ;
            m_dwDefFmtSize = 0 ;
        }
        m_pviDefFmt = (VIDEOINFO *) new BYTE[dwSize + SIZE_PREHEADER] ;
        if (NULL == m_pviDefFmt)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Out of memory for format block VIDEOINFO struct"))) ;
            return E_OUTOFMEMORY ;
        }
        m_dwDefFmtSize = dwSize + SIZE_PREHEADER;  // total size of default format data
    }
    
    // We want to get BITMAPINFO part of VIDEOINFO struct from our GDI class
    m_L21Dec.GetDefaultFormatInfo((LPBITMAPINFO) &(m_pviDefFmt->bmiHeader), &dwSize) ; // get default data
    
    // Set the other fields
    LARGE_INTEGER  li ;
    li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
    RECT   rc ;
    rc.left = rc.top = 0 ;
    rc.right = HEADER(m_pviDefFmt)->biWidth ;
    rc.bottom = abs(HEADER(m_pviDefFmt)->biHeight) ;  // just make sure rect fields are +ve
    m_pviDefFmt->rcSource = rc ;
    m_pviDefFmt->rcTarget = rc ;
    m_pviDefFmt->dwBitRate = MulDiv(HEADER(m_pviDefFmt)->biSizeImage, 
        80000000, li.LowPart) ;
    m_pviDefFmt->dwBitErrorRate = 0 ;
    m_pviDefFmt->AvgTimePerFrame = (LONGLONG) 333667L ; // => 29.97 fps
    
    return NOERROR ;
}


//
//  CheckInputType: Check if you can support the input data type
//
HRESULT CLine21DecFilter::CheckInputType(const CMediaType* pmtIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::CheckInputType(0x%lx)"), pmtIn)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock
    
    if (NULL == pmtIn)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }
    
    //  We only support MEDIATYPE_AUXLine21Data and 
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    GUID    SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  && 
        ISSUBTYPEVALID(m_eSubTypeIDIn)) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Rejecting invalid Line 21 Data subtype"))) ;
        return E_INVALIDARG ;
    }
    
    // Check that this is a valid format type
    if (FORMAT_VideoInfo == *pmtIn->FormatType())
    {
        ASSERT(m_pOutput != NULL) ;

        //
        // Make sure the given input format is valid. If not, reject it and use our
        // own default format data.
        //
        if (! IsValidFormat(pmtIn->Format()) )
        {
            DbgLog((LOG_TRACE, 0, TEXT("Invalid format data given -- using our own format data."))) ;
            if (NULL == m_pviDefFmt)
            {
                HRESULT  hr = GetDefaultFormatInfo() ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                    return hr ;
                }
            }
            // We should fix the input mediatype too (with the default VideoInfo data).
            m_pInput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
            m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
            m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
        }
        else  // seems to be valid format spec.
        {
            //
            // Get the specified input format info; we'll use the same for output
            //
            if (pmtIn->FormatLength() > 0) // only if there is some format data
            {
                m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
                m_pOutput->CurrentMediaType().SetFormat(pmtIn->Format(), pmtIn->FormatLength()) ;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: FORMAT_VideoInfo and no format block specified."))) ;
// #if 0  // for now
                return E_INVALIDARG ;
// #endif // #if 0
            }
        }
    }
    else if (GUID_NULL   == *pmtIn->FormatType() ||  // wild card
             FORMAT_None == *pmtIn->FormatType())    // no format
    {
        //
        // input pin didn't get a format type info; use our own
        //
        DbgLog((LOG_TRACE, 3, TEXT("No format type specified -- using our own format type."))) ;
        if (NULL == m_pviDefFmt)
        {
            HRESULT  hr = GetDefaultFormatInfo() ;
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                return hr ;
            }
        }
        m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
    }
    else  // something weird that we don't like
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting invalid format type"))) ;
        // tell what input type too??
        return E_INVALIDARG ;
    }
    
    // some more level 3 debug log here???
    
    // We should branch based on what format type we got, because ..GOPPacket
    // type needs to be unwrapped and parsed whereas the ..BytePair format
    // is to be directly parsed.
    
    // do we have a case for -- return VFW_E_TYPE_NOT_ACCEPTED ???
    
    return NOERROR ;
}


//
//  CheckTransform: check if this input to this output transform is supported
//
HRESULT CLine21DecFilter::CheckTransform(const CMediaType* pmtIn,
                                         const CMediaType* pmtOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::CheckTransform(0x%lx, 0x%lx)"), 
            pmtIn, pmtOut)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock
    
    if (NULL == pmtIn || NULL == pmtOut)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }
    
    //  We only support MEDIATYPE_AUXLine21Data and 
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    //  Check that input is a valid subtype type
    //  and format is VideoInfo or None
    GUID SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  &&   // line21 data type and...
           ISSUBTYPEVALID(m_eSubTypeIDIn)  &&              // valid subtype (bytepair/GOPPacket) and...
           (FORMAT_VideoInfo == *pmtIn->FormatType() ||    // format VideoInfo  or
            FORMAT_None      == *pmtIn->FormatType() ||    // format None (KS wild card)  or
            GUID_NULL        == *pmtIn->FormatType())) )   // GUID Null (DShow wild card)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: input type not Line21 / subtype / formattype invalid"))) ;
        return E_INVALIDARG ;
    }
    
    // and we only accept video as output
    if (MEDIATYPE_Video != *pmtOut->Type())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output type is not VIDEO"))) ;
        return E_INVALIDARG ;
    }
    
    // check output is VIDEOINFO type
    if (FORMAT_VideoInfo != *pmtOut->FormatType())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output format type is not VIDEOINFO"))) ;
        return E_INVALIDARG ;
    }

    //
    //  Verify that the output size specified by the input and output mediatype
    //  are acceptable.
    //
    if ( !IsValidFormat(pmtOut->Format()) ||              // invalid output format data  OR
         !m_L21Dec.IsSizeOK(HEADER(pmtOut->Format()))  || // output size is NOT acceptable  OR
         (FORMAT_VideoInfo == *pmtIn->FormatType() &&     // valid input format type and...
          IsValidFormat(pmtIn->Format()) &&               // valid input format data and...
          !m_L21Dec.IsSizeOK(HEADER(pmtIn->Format()))) )  // output size is NOT acceptable   
    {
        DbgLog((LOG_TRACE, 1, TEXT("Rejecting: Input/output-specified output size is unacceptable"))) ;
        return E_INVALIDARG ;
    }

#if 0
    
#define rcS1 ((VIDEOINFO *)(pmtOut->Format()))->rcSource
#define rcT1 ((VIDEOINFO *)(pmtOut->Format()))->rcTarget
    
    DbgLog((LOG_TRACE, 3,
        TEXT("Input Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtIn->Format())->biWidth,
        HEADER(pmtIn->Format())->biHeight,
        HEADER(pmtIn->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("Output Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtOut->Format())->biWidth,
        HEADER(pmtOut->Format())->biHeight,
        HEADER(pmtOut->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
        rcS1.left, rcS1.top, rcS1.right, rcS1.bottom)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
        rcT1.left, rcT1.top, rcT1.right, rcT1.bottom)) ;
    
    DWORD     dwErr ;
    
    // If we've been given rectangles, use What???
    if (!IsRectEmpty(&rcS1) || !IsRectEmpty(&rcT1))
    {
        DbgLog((LOG_TRACE, 4, TEXT("Either source or dest rect is empty"))) ;
        dwErr = 0 ;  // what to do here??
    }
    else
    {
        DbgLog((LOG_TRACE, 4, TEXT("Source or dest rects are not empty")));
        dwErr = 0 ;  // what to do here??
    }
    
    if (dwErr != 0)  // or what to check against??
    {
        DbgLog((LOG_ERROR, 1, TEXT("decoder rejected this transform"))) ;
        return E_FAIL ;
    }
    
#endif // #if 0
    
    return NOERROR ;
}


//
//  CompleteConnect: Overridden to know when a connection is made to this filter
//
HRESULT CLine21DecFilter::CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::CompleteConnect(%s, 0x%lx)"), 
        dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pReceivePin)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LPBITMAPINFO    lpbmi ;
    HRESULT         hr ;
    
    if (PINDIR_OUTPUT == dir)
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D output pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

         //
        // This version of the line21 decoder should NOT work with the VMR
        //
        IVMRVideoStreamControl  *pVMRSC ;
        hr = pReceivePin->QueryInterface(IID_IVMRVideoStreamControl, (LPVOID *) &pVMRSC) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin supports IVMR* interface"))) ;
            pVMRSC->Release() ;
            return E_FAIL ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin does NOT support IVMR* interface"))) ;
        }

       //
        // Now get the the output pin's mediatype and use that for our
        // output size etc.
        //
        const CMediaType  *pmt = &(m_pOutput->CurrentMediaType()) ;
        ASSERT(MEDIATYPE_Video == *pmt->Type()  &&  
            FORMAT_VideoInfo == *pmt->FormatType()) ;
        m_mtOutput = *pmt ;  // this is our output mediatype for now
        if (pmt->FormatLength() > 0)  // only if there is some format data
        {
            lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->Format()))) ;
            ASSERT(lpbmi) ;
            
            // Set the output format info coming from downstream
            m_L21Dec.SetOutputOutFormat(lpbmi) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
            
            //
            // We are definitely not running/paused. So no need to delete/
            // create output DIB section here at all.
            //
            
            //
            // If are being connected to the OverlayMixer, we need to tell it 
            // that we are a transparent stream that covers the whole output
            // window.
            //
            IMixerPinConfig  *pMPC ;
            hr = pReceivePin->QueryInterface(IID_IMixerPinConfig, (LPVOID *)&pMPC) ;
            if (SUCCEEDED(hr) && pMPC)
            {
                DbgLog((LOG_TRACE, 3, TEXT("Receiving pin supports IMixerPinConfig"))) ;
                hr = pMPC->SetStreamTransparent(TRUE) ;
                ASSERT(SUCCEEDED(hr) || E_NOTIMPL == hr) ;  // as Kapil says
                hr = pMPC->SetRelativePosition(0, 0, 10000, 10000) ; // full window
                ASSERT(SUCCEEDED(hr) || E_NOTIMPL == hr) ;  // as Kapil says
                hr = pMPC->SetAspectRatioMode(AM_ARMODE_STRETCHED_AS_PRIMARY) ; // aspect ratio same as primary
                ASSERT(SUCCEEDED(hr) || hr == E_INVALIDARG) ;  // as Kapil says
                pMPC->Release() ;  // done; let it go.
            }
            else
            {
                DbgLog((LOG_TRACE, 3, TEXT("Downstream pin doesn't support IMixerPinConfig"))) ;
            }
        }
        
        return NOERROR ;
    }
    
    ASSERT(PINDIR_INPUT == dir) ;
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D input pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

        // const CMediaType  *pmt = &(m_pInput->CurrentMediaType()) ;
        AM_MEDIA_TYPE mt ;
        hr = pReceivePin->ConnectionMediaType(&mt) ;
        if (SUCCEEDED(hr))  // ONLY if upstream filter provides mediatype used in the connection
        {
            // If format type (and format data) has been specified then save it as 
            // input-side output format
            if (FORMAT_VideoInfo == mt.formattype  &&
                mt.cbFormat > 0)
            {
                lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(mt.pbFormat))) ;
                ASSERT(lpbmi) ;
            
                // Store whatever output format info is specified by upstream filter
                m_L21Dec.SetOutputInFormat(lpbmi) ;
                GetDefaultFormatInfo() ;  // to pick any change in format data
            
                //
                // We are definitely not running/paused. So no need to delete/
                // create output DIB section here at all.
                //
            }

            FreeMediaType(mt) ;
        }  // end of if ()
    }
    
    //
    //  We MUST clear the caption data buffers and any exisiting internal state
    //  now.  This is most important in this cases where the filter has been
    //  used to decode some Line 21 data, disconnected from the source and then 
    //  reconnected again to play another stream of data.
    //
    m_L21Dec.InitState() ;
    m_L21Dec.InitColorNLastChar() ;     // reset color and last char info
    
    return NOERROR ;
}


//
//  BreakConnect: Overridden to know when a connection is broken to our pin
//
HRESULT CLine21DecFilter::BreakConnect(PIN_DIRECTION dir)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::BreakConnect(%s)"), 
            dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (PINDIR_OUTPUT == dir)
    {
        // If not connected yet, just return (but indicate with S_FALSE)
        if (! m_pOutput->IsConnected() )
            return S_FALSE ;
        
        m_L21Dec.SetOutputOutFormat(NULL) ;  // no output format from downstream
        GetDefaultFormatInfo() ;  // to pick any change in format data
        m_pbOutBuffer = NULL ;               // locally cached pointer
        m_L21Dec.SetOutputBuffer(NULL) ;     // output buffer not available now

        //
        // NOTE 1: We are definitely not running/paused. So no need to delete/
        // create output DIB section here.
        //
        
        //
        // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
        // base class code for CTransformOutputPin::BreakConnect() already
        // does that.
        //
        return NOERROR ;
    }
    
    ASSERT(PINDIR_INPUT == dir) ;
    
    // If not connected yet, just return (but indicate with S_FALSE)
    if (! m_pInput->IsConnected() )
        return S_FALSE ;
    
    m_L21Dec.SetOutputInFormat(NULL) ;  // no output format from upstream
    GetDefaultFormatInfo() ;  // to pick any change in format data
    
    //
    // NOTE 1: We are definitely not running/paused. So no need to delete/
    // create output DIB section here.
    //
    
    //
    // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
    // base class code for CTransformOutputPin::BreakConnect() already
    // does that.
    //
    return NOERROR ;
}

//
//  SetMediaType: overriden to know when the media type is actually set
//
HRESULT CLine21DecFilter::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetMediaType(%s, 0x%lx)"), 
            direction == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pmt)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    LPTSTR alpszFormatIDs[] = { TEXT("Invalid"), TEXT("BytePair"),
								TEXT("GOPPacket"), TEXT("VBIRawData") } ;
    
    if (PINDIR_OUTPUT == direction)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Output type: %d x %d x %d"),
            HEADER(m_pOutput->CurrentMediaType().Format())->biWidth,
            HEADER(m_pOutput->CurrentMediaType().Format())->biHeight,
            HEADER(m_pOutput->CurrentMediaType().Format())->biBitCount)) ;
        return NOERROR ;
    }
    
    ASSERT(PINDIR_INPUT == direction) ;
    DbgLog((LOG_TRACE, 3, TEXT("Input type: <%s>"),
        alpszFormatIDs[MapGUIDToID(m_pInput->CurrentMediaType().Subtype())])) ;
    
    if (m_pOutput && m_pOutput->IsConnected()) 
    {
        DbgLog((LOG_TRACE, 2, TEXT("*** Changing IN when OUT already connected"))) ;
        DbgLog((LOG_TRACE, 2, TEXT("Reconnecting the output pin..."))) ;
        return m_pGraph->Reconnect(m_pOutput) ;
    }
    
    return NOERROR ;
}


#if 0  // Quality Management is deferred for now as OvMixer always says (Flood, 1000)

//
//  AlterQuality: overriden to handle quality messages and not pass them upstream
//
HRESULT CLine21DecFilter::AlterQuality(Quality q)
{
    DbgLog((LOG_TRACE, 0, TEXT("QM: CLine21DecFilter::AlterQuality(%s, %ld)"), 
            Flood == q.Type ? TEXT("Flood") : TEXT("Famine"), q.Proportion)) ; // log trace=5

    if (1000 == q.Proportion)
    {
        DbgLog((LOG_TRACE, 0, TEXT("QM: Quality is just right.  Don't change anything."))) ; 
        return S_OK ;
    }

    if (Flood == q.Type)    // Flood: too much output
    {
        if (q.Proportion > 500 && q.Proportion <= 900)
        {
            m_iSkipSamples += 1 ;
        }
        else if (q.Proportion > 300 && q.Proportion <= 500)
        {
            m_iSkipSamples += 2 ;
        }
        else if (q.Proportion <= 300)
        {
            m_iSkipSamples += 3 ;
        }
        m_iSkipSamples = min(m_iSkipSamples, 10) ;  // at least 1 in 10 is shown
    }
    else                    // Famine: send more output
    {
        if (q.Proportion > 1200)  // could take 20% more
        {
            m_iSkipSamples-- ;
            if (m_iSkipSamples < 0)
                m_iSkipSamples = 0 ;
        }
    }

    DbgLog((LOG_TRACE, 0, TEXT("QM: Adjusted rate is %d samples are skipped."), m_iSkipSamples)) ; 
    return S_OK ;
}
#endif // #if 0 -- end of commented out AlterQuality() implementation


// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.
//
//  GetMediaType: Get our preferred media type (in order)
//
HRESULT CLine21DecFilter::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetMediaType(%d, 0x%lx)"), 
            iPosition, pmt)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LARGE_INTEGER       li ;
    CMediaType          cmt ;
    LPBITMAPINFOHEADER  lpbi ;
    
    if (NULL == pmt)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Media type is NULL, Sorry!!"))) ;
        return E_INVALIDARG ;
    }
    
    // Output choices depend on the input connected
    if (! m_pInput->CurrentMediaType().IsValid() )
    {
        DbgLog((LOG_TRACE, 3, TEXT("No input type set yet, Sorry!!"))) ;
        return E_FAIL ;
    }
    
    if (iPosition < 0)
    {
        return E_INVALIDARG ;
    }
    
    // Find the format info specified in the input VideoInfo struct
    cmt = m_pInput->CurrentMediaType() ;
    BITMAPINFOHEADER bih ;
    BOOL  bOutKnown = (S_OK == m_L21Dec.GetOutputOutFormat(&bih)) ;
    if (! bOutKnown )
        GetOutputFormat(&bih) ;
    
    BOOL bInKnown = NULL != cmt.Format() && IsValidFormat(cmt.Format()) ; // just to be sure
    VIDEOINFOHEADER vih ;
    if (bInKnown)
        CopyMemory(&vih, (VIDEOINFOHEADER *)(cmt.Format()), sizeof(VIDEOINFOHEADER)) ;
    
    // Offer the decoder's default output format (Video) first
    switch (iPosition)
    {
    case 0:  // RGB 8bpp
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 0: 8 bit RGB"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_PALETTE);
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 8 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            
            // Get some palette data from system/our own (for non-8 bpp)
            m_L21Dec.GetPaletteForFormat(lpbi) ;  // this sets biClrUsed member
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB8) ;
            
            break ;
        }
        
    case 1:  // RGB 16bpp (555)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 1: 16 bit RGB 555"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 16 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB555) ;
            break ;
        }
        
    case 2:  // 16bpp (565)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 2: 16 bit RGB 565"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_MASKS);
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 16 ;
            lpbi->biCompression = BI_BITFIELDS ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            // Set the masks too
            DWORD   *pdw = (DWORD *)(lpbi + 1) ;
            pdw[iRED]    = bits565[iRED] ;
            pdw[iGREEN]  = bits565[iGREEN] ;
            pdw[iBLUE]   = bits565[iBLUE] ;
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB565) ;
            break ;
        }
        
    case 3:   // RGB 24bpp
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 3: 24 bit RGB"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 24 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB24) ;
            break ;
        }
        
    case 4:  // 32bpp
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 4: 32 bit RGB"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_MASKS);
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 32 ;
            lpbi->biCompression = BI_BITFIELDS ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            // Set the masks too
            DWORD   *pdw = (DWORD *)(lpbi + 1) ;
            pdw[iRED]    = bits888[iRED] ;
            pdw[iGREEN]  = bits888[iGREEN] ;
            pdw[iBLUE]   = bits888[iBLUE] ;
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB32) ;
            break ;
        }
        
    default:
        return VFW_S_NO_MORE_ITEMS ;
        
    }  // end of switch (iPosition)
    
    // Now set the output formattype and sample size
    cmt.SetSampleSize(lpbi->biSizeImage) ;
    cmt.SetFormatType(&FORMAT_VideoInfo) ;
    
    // The fields of VIDEOINFOHEADER needs to be filled now
    if (! bInKnown ) // if the upstream filter didn't specify anything
    {
        RECT  Rect ;
        Rect.left = 0 ;
        Rect.top = 0 ;
        Rect.right = lpbi->biWidth ;
        Rect.bottom = abs(lpbi->biHeight) ;  // biHeight could be -ve, but rect fields are +ve
        
        // We set some default values for time/frame, src and target rects etc. etc.
        li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->AvgTimePerFrame = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcSource = Rect ;
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcTarget = Rect ;
    }
    else
        li.QuadPart = vih.AvgTimePerFrame ;
    
    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitRate =
        MulDiv(lpbi->biSizeImage, 80000000, li.LowPart) ;
    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitErrorRate = 0L ;
    
    // Set temporal compression and copy the prepared data now
    cmt.SetTemporalCompression(FALSE) ;
    *pmt = cmt ;
    
    return NOERROR ;
}


//
//  DecideBufferSize: Called from CBaseOutputPin to prepare the allocator's
//                    count of buffers and sizes.  It makes sense only when
//                    the input is connected.
//
HRESULT CLine21DecFilter::DecideBufferSize(IMemAllocator * pAllocator,
                                           ALLOCATOR_PROPERTIES *pProperties)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::DecideBufferSize(0x%lx, 0x%lx)"), 
            pAllocator, pProperties)) ;
    CAutoLock   Lock(&m_csFilter) ;

    // Is the input pin connected
    if (! m_pInput->IsConnected()) 
    {
        return E_UNEXPECTED ;
    }
    
    ASSERT(m_pOutput->CurrentMediaType().IsValid()) ;
    ASSERT(pAllocator) ;
    ASSERT(pProperties) ;
    
    // set the size of buffers based on the expected output bitmap size, and
    // the count of buffers to 1.
    pProperties->cBuffers = 1 ;
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize() ;
    
    ASSERT(pProperties->cbBuffer) ;
    
    ALLOCATOR_PROPERTIES Actual ;
    HRESULT hr = pAllocator->SetProperties(pProperties, &Actual) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Error in SetProperties()"))) ;
        return hr ;
    }
    
    if (Actual.cbBuffer < pProperties->cbBuffer  ||
        Actual.cBuffers  < pProperties->cBuffers)
    {
        // can't use this allocator
        DbgLog((LOG_ERROR, 0, TEXT("Can't use allocator (only %d buffer of size %d given)"),
            Actual.cBuffers, Actual.cbBuffer)) ;
        return E_INVALIDARG ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("    %d buffers of %ld bytes each"), 
        pProperties->cBuffers, pProperties->cbBuffer)) ;
    
    ASSERT(Actual.cbAlign == 1) ;
    ASSERT(Actual.cbPrefix == 0) ;
    
    return S_OK ;
}

// We're stopping the stream -- release output DC to reduce memory footprint etc.
STDMETHODIMP CLine21DecFilter::Stop(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::Stop()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State_Running == m_State  ||
        State_Paused  == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are stopping -- release output DC etc."))) ;
        m_L21Dec.DeleteOutputDC() ;       // release internal DIBSection now
        m_L21Dec.SetOutputBuffer(NULL) ;  // no output buffer anymore
        m_pbOutBuffer = NULL ;            // must be same as mL21Dec's m_pbOutBuffer
        
        // Release the prev downstream pin's interface now
        if (m_pPinDown)
        {
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }
    }
    
    HRESULT hr = CTransformFilter::Stop() ;
    
    FreeTimer() ; // To be sure, we don't need a timer in case one is hanging around
    return hr ;
}

// We're starting/stopping to stream -- based on that acquire or release output DC
// to reduce memory footprint etc.
STDMETHODIMP CLine21DecFilter::Pause(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::Pause()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State_Stopped == m_State)
    {
        //  Try to make sure we have at least 2 buffers
        IMemAllocator *pAlloc;
        if (SUCCEEDED(m_pInput->GetAllocator(&pAlloc))) {
            ALLOCATOR_PROPERTIES props;
            ALLOCATOR_PROPERTIES propsActual;
            pAlloc->GetProperties(&props);
            if (props.cBuffers < 4) {
                props.cBuffers = 4;
                props.cbBuffer = 200;
                props.cbAlign = max(props.cbAlign, 1);
                props.cbPrefix = 0;
                HRESULT hr = pAlloc->SetProperties(&props, &propsActual);
                DbgLog((LOG_TRACE, 2, TEXT("Setproperties returned %8.8X"), hr));
            }
            pAlloc->Release();
        }
        
        DbgLog((LOG_TRACE, 1, TEXT("We are running -- get output DC etc."))) ;
        if (! m_L21Dec.CreateOutputDC() )
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: CLine21DecFilter::Pause() failed"))) ;
            return E_FAIL ;  // should at least fail to avoid faulting later
        }
        
        //
        // Get actual key color and store it for future use.
        //
        GetActualColorKey() ;
        
        m_L21Dec.FillOutputBuffer() ;  // just to clear any existing junk
        
        // We are starting a new play session; we do an exception to allow
        // the first output sample to be sent down even though the byte pair
        // wasn't valid for decoding.
        m_bMustOutput  = TRUE ;   // we are pausing again for this new play session
        m_bDiscontLast = FALSE ;  // no discontinuity from prev session remembered
        m_eGOP_CCType  = GOP_CCTYPE_Unknown ;  // reset GOP packet CC type
        
        SetRect(&m_rectLastOutput, 0, 0, 0, 0) ;  // start with no rect
        
        // If we somehow didn't release the prev downstream pin's interface, do that now
        if (m_pPinDown)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: downstream pin interface wasn't released properly"))) ;
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }

        // Get the downstream pin's interface so that we can set rects on it later on
        m_pOutput->ConnectedTo(&m_pPinDown) ;
        if (NULL == m_pPinDown)
            DbgLog((LOG_TRACE, 3, TEXT("Running w/o connecting our output pin!!!"))) ;
        else
            DbgLog((LOG_TRACE, 5, TEXT("L21D Output pin connected to %s"), (LPCTSTR)CDisp(m_pPinDown))) ;

#if 0  // No QM for now
        // Reset the sample skipping count for QM handling
        ResetSkipSamples() ;
#endif // #if 0
    }
    else if (State_Running == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are pausing from running"))) ;
        //
        // We are not sending output samples down anymore. So we don't need a
        // timer for now.
        //
        FreeTimer() ;
    }
    
    return CTransformFilter::Pause() ;
}

//
// we don't send any data during PAUSE, so to avoid hanging renderers, we
// need to return VFW_S_CANT_CUE when paused
//
HRESULT CLine21DecFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetState()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));
    
    *State = m_State;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE;
    else
        return S_OK;
}


void CLine21DecFilter::GetActualColorKey(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetActualColorKey()"))) ;
    // Can't take the filter lock as it can cause deadlock.

    //
    // Does the pin connected to our output support IMixerPinConfig?
    // If so, get the color key info and set the relative position;
    // otherwise, it may be the Video Renderer and such -- use default
    // color key based on current bitdepth.
    //
    DWORD   dwPhysColor = -1 ;
    IPin   *pPin ;
    HRESULT hr ;
    hr = m_pOutput->ConnectedTo(&pPin) ;
    if (SUCCEEDED(hr) && pPin)
    {
        IMixerPinConfig  *pMPC ;
        hr = pPin->QueryInterface(IID_IMixerPinConfig, (LPVOID *)&pMPC) ;
        if (SUCCEEDED(hr) && pMPC)
        {
            // Temporary addition to track down any color key value change
            DWORD  dwOldPhysColor ;
            m_L21Dec.GetBackgroundColor(&dwOldPhysColor) ;
            DbgLog((LOG_TRACE, 3, TEXT("Downstream pin supports IMixerPinConfig"))) ;
            hr = pMPC->GetColorKey(NULL, &dwPhysColor) ;
            DbgLog((LOG_TRACE, 1, TEXT("GetActualColorKey() gave 0x%lx (old is 0x%lx)"),
                    dwPhysColor, dwOldPhysColor)) ;
            // Kapil says that we can ignore this error as it's a bad error case and
            // the OverlayMixer will take care of it by stopping this stream anyway.
            if (FAILED(hr))
                DbgLog((LOG_TRACE, 1, TEXT("IMixerPinConfig::GetColorKey() failed (Error 0x%lx)."), hr)) ;
            pMPC->Release() ;  // done; let it go.
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("Downstream pin doesn't support IMixerPinConfig"))) ;
        }
        
        pPin->Release() ;  // done with the pin
    }
    
    m_L21Dec.SetBackgroundColor(dwPhysColor) ;
}


AM_LINE21_CCSUBTYPEID CLine21DecFilter::MapGUIDToID(const GUID *pFormatIn) 
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::MapGUIDToID(0x%lx)"), pFormatIn)) ;

    if (MEDIASUBTYPE_Line21_BytePair        == *pFormatIn)
        return AM_L21_CCSUBTYPEID_BytePair ;
    else if (MEDIASUBTYPE_Line21_GOPPacket  == *pFormatIn)
        return AM_L21_CCSUBTYPEID_GOPPacket ;
    // else if (MEDIASUBTYPE_Line21_VBIRawData == *pFormatIn)
    //     return AM_L21_CCSUBTYPEID_VBIRawData ;
    else
        return AM_L21_CCSUBTYPEID_Invalid ;
}



//
// CMessageWindow class implementation
//

LPCTSTR  gpszClassName = TEXT("L21DecMsgWnd") ;

CMessageWindow::CMessageWindow()
{
    DbgLog((LOG_TRACE, 5, TEXT("CMessageWindow::CMessageWindow() -- Instantiating message window"))) ;

    m_hWnd   = NULL ;
    m_iCount = 0 ;
    
    //
    // Register message window class, only if it's not already registered
    //
    WNDCLASS   wc ;
    if (! GetClassInfo(GetModuleHandle(NULL), gpszClassName, &wc))
    {
        ZeroMemory(&wc, sizeof(wc)) ;
        wc.lpfnWndProc   = MsgWndProc ;
        wc.hInstance     = GetModuleHandle(NULL) ;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1) ;
        wc.lpszClassName = gpszClassName ;
        if (0 == RegisterClass(&wc)) // Oops, just leave; we'll catch later...
        {
            DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: RegisterClass() for app class failed (Error %ld)"), 
                GetLastError())) ;
            return ;
        }
    }
    
    m_hWnd = CreateWindowEx(WS_EX_TOOLWINDOW, gpszClassName, TEXT(""), 
        WS_ICONIC, 0, 0, 1, 1, NULL, NULL, 
        GetModuleHandle(NULL), NULL);
    if (NULL == m_hWnd)  // Oops, just leave; we'll catch later...
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("ERROR: CreateWindowEx() failed (Error %ld)"), 
            GetLastError())) ;
        return ;
    }
    
    ShowWindow(m_hWnd, SW_HIDE) ;
}

CMessageWindow::~CMessageWindow()
{
    DbgLog((LOG_TRACE, 5, TEXT("CMessageWindow::~CMessageWindow() -- Destructing message window"))) ;

    DWORD_PTR dwRes ;
    if (0 == SendMessageTimeout(m_hWnd, WM_CLOSE, 0, 0, SMTO_NORMAL, 1000, &dwRes))  // 1 sec wait
    {
        ASSERT(0 == dwRes) ;  // just to be informedd
        DWORD dwErr = GetLastError() ;
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: SendMessageTimeOut() failed (Result=%lu, Error=%lu). Try again..."), 
            dwRes, dwErr)) ;
    }
    else
        DbgLog((LOG_ERROR, 5, TEXT("SendMessageTimeOut() closed window"))) ;
    
#if 0
    if (! UnregisterClass(gpszClassName, GetModuleHandle(NULL)))  // if failed for some reason
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: UnregisterClass(L21DecMsgWnd) failed (Error %ld)"), GetLastError())) ;
        ASSERT(FALSE) ;  // just so that we know
    }
#endif // #if 0
}

LRESULT CALLBACK CMessageWindow::MsgWndProc(HWND hWnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_TIMER:
        DbgLog((LOG_TRACE, 3, TEXT("MsgWndProc(, uMsg = WM_TIMER, wParam = 0x%0x, )"),
            wParam)) ;
        ((CLine21DecFilter *) wParam)->TimerProc(hWnd, uMsg, wParam, 0 /* dwTime */) ;
        return 0 ;
    }
    DbgLog((LOG_TRACE, 5, TEXT("MsgWndProc(, uMsg = 0x%x, wParam = 0x%0x, )"),
        uMsg, wParam)) ;
    return DefWindowProc(hWnd, uMsg, wParam, lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21dgdi.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21DGDI.h: Line 21 Decoder GDI-related base class code
//

#ifndef _INC_L21DGDI_H
#define _INC_L21DGDI_H


//
// Forward declarations
//
class CGDIWork ;


//
// We start with 8x12 pixel chars by default
//
#ifndef __DEFAULTCHARSIZE_DEFINED
#define __DEFAULTCHARSIZE_DEFINED
#define DEFAULT_CHAR_WIDTH    8
#define DEFAULT_CHAR_HEIGHT   12
#endif // __DEFAULTCHARSIZE_DEFINED

// #define TEST

//
//  CGDIWork: class for GDI details to print caption text to output bitmap
//
class CGDIWork {
public:
    CGDIWork(void) ;
    ~CGDIWork(void) ;
    BOOL InitFont(void) ;
    void InitColorNLastChar(void) ;
    DWORD GetPaletteForFormat(LPBITMAPINFOHEADER lpbmih) ;
    inline void SetOutputBuffer(LPBYTE lpbOut) {
        m_bNewOutBuffer = m_lpbOutBuffer != lpbOut ; // Changed?
        m_lpbOutBuffer = lpbOut ;
    } ;
    void SetColorFiller(void) ;
    void FillOutputBuffer(void) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) ;
    inline void GetBackgroundColor(DWORD *pdwPhysColor) { *pdwPhysColor = m_dwPhysColor ; } ;
    BOOL SetBackgroundColor(DWORD dwPhysColor) ;
    inline BOOL GetBackgroundOpaque(void)         { return m_bOpaque ; } ;
    inline void SetBackgroundOpaque(BOOL bOpaque) { m_bOpaque = bOpaque ; } ;
    
    inline UINT GetCharHeight(void)  { return m_uCharHeight ; } ;
    inline int  GetScrollStep(void)  { return m_iScrollStep ; } ;
    BOOL CreateOutputDC(void) ;
    BOOL DeleteOutputDC(void) ;
    void DrawLeadingSpace(int iLine, int iCol) ;
    void WriteChar(int iLine, int iCol, CCaptionChar& cc) ;
    inline BOOL IsNewIntBuffer(void)   { return m_bNewIntBuffer ; } ;
    inline BOOL IsNewOutBuffer(void)   { return m_bNewOutBuffer ; } ;
    inline BOOL IsBitmapDirty(void)    { return m_bBitmapDirty ; } ;
    void ClearInternalBuffer(void) ;
    inline void ClearNewIntBufferFlag(void) { m_bNewIntBuffer = FALSE ; } ;
    inline void ClearNewOutBufferFlag(void) { m_bNewOutBuffer = FALSE ; } ;
    inline void ClearBitmapDirtyFlag(void) { m_bBitmapDirty = FALSE ; } ;
    void CopyLine(int iSrcLine, int iSrcOffset, 
                  int iDestLine, int iDestOffset, 
                  UINT uNumScanLines = 0xFF) ;
    inline BOOL IsTTFont(void)  { return m_bUseTTFont ; } ;
    inline BOOL IsOutDIBClear(void)  { return m_bOutDIBClear ; } ;
    BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) ;
    inline BOOL IsOutputInverted(void) { return m_bOutputInverted ; } ;
    void GetOutputLines(int iDestLine, RECT *prectLine) ;
    
private:   // private data
    CCritSec        m_csL21DGDI ;     // to serialize actions on internal DIB secn
    
#ifdef TEST
    HDC             m_hDCTest ;       // a DC on the desktop just for testing
#endif // TEST
    HDC             m_hDCInt ;        // an HDC for output (attached to a DIBSection)
    BOOL            m_bDCInited ;     // DC is ready for real output (DIB section created)
    
    LPBYTE          m_lpbOutBuffer ;  // output sample buffer pointer
    LPBYTE          m_lpbIntBuffer ;  // memory buffer of output DIBSection
    HBITMAP         m_hBmpInt ;       // bitmap for output DIBSection
    HBITMAP         m_hBmpIntOrig ;   // original bitmap for output DIBSection
    LPBITMAPINFO    m_lpBMIOut ;      // BITMAPINFO for output from downstream filter
    LPBITMAPINFO    m_lpBMIIn ;       // BITMAPINFO for output from upstream filter
    UINT            m_uBMIOutSize ;   // bytes for BMI data from downstream
    UINT            m_uBMIInSize ;    // bytes for BMI data from upstream
    LONG            m_lWidth ;        // currently set output width
    LONG            m_lHeight ;       // currently set output height
    int             m_iBorderPercent ;// current border percent (10 or 20)
    DWORD           m_dwPhysColor ;   // bkgrnd physical color for output bitmap
    BYTE            m_abColorFiller[12] ; // filler to be applied for fast color keying
    BOOL            m_bOpaque ;       // should caption background be opaque?
    
    BOOL            m_bBitmapDirty ;  // new output content has been written on DIBSection
    BOOL            m_bNewIntBuffer ; // new DIB section created
    BOOL            m_bNewOutBuffer ; // new output sample buffer
    BOOL            m_bOutputInverted ; // output right side up for -ve height
    BOOL            m_bUseTTFont ;    // TT font (Lucida Console) available; use that
    HFONT           m_hFontDef ;      // default font (white, normal) to use
    HFONT           m_hFontSpl ;      // font with any specialty (italics, underline etc.)
    HFONT           m_hFontOrig ;     // original font that came with the DC
    LOGFONT         m_lfChar ;        // LOGFONT struct for quick font create
    BOOL            m_bUseSplFont ;   // Is special font being used now?
    BOOL            m_bFontSizeOK ;   // are font sizes OK? Otherwise we don't draw
    
    UINT            m_uCharWidth ;    // width of each caption char in pixels
    UINT            m_uCharHeight ;   // height of each caption char in pixels
    int             m_iScrollStep ;   // # scanlines to scroll by in each step
    UINT            m_uIntBmpWidth ;  // width of internal output bitmap in pixels
    UINT            m_uIntBmpHeight ; // height of internal output bitmap in pixels
    UINT            m_uHorzOffset ;   // pixels to be left from the left
    UINT            m_uVertOffset ;   // pixels to be left from the top
    UINT            m_uBytesPerPixel ;// bytes for each pixel of output (based on bpp)
    UINT            m_uBytesPerSrcScanLine ; // bytes for each source scan line's data
    UINT            m_uBytesPerDestScanLine ;// bytes for each destn scan line's data
    
    CCaptionChar    m_ccLast ;        // last caption char and attribs printed
    COLORREF        m_acrFGColors[7] ;// 7 colors from white to magenta
    UINT            m_uColorIndex ;   // index of currently used color
    
    BOOL            m_bOutDIBClear ;  // Is output DIB secn clean?

#ifdef PERF
    int             m_idClearIntBuff ;
    int             m_idClearOutBuff ;
#endif // PERF

private:   // private helper methods
    bool InitBMIData(void) ;
    static int CALLBACK EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM,
        int iFontType, LPARAM lParam) ;
    void CheckTTFont(void) ;
    void ChangeFont(BOOL bItalics, BOOL bUnderline) ;
    void ChangeFontSize(UINT uCharWidth, UINT uCharHeight) ;
    void ChangeColor(int iColor) ;
    BOOL SetOutputSize(LONG lWidth, LONG lHeight) ;
    BOOL SetCharNBmpSize(void) ;
    void SetNumBytesValues(void) ;
    void SetDefaultKeyColor(LPBITMAPINFOHEADER lpbmih) ;
    DWORD GetOwnPalette(int iNumEntries, PALETTEENTRY *ppe) ;
    BOOL CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight, int *piCharWidth, int *piCharHeight) ;
} ;

#endif _INC_L21DGDI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21dfilt.h ===
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// ActiveMovie Line 21 Decoder filter
//

extern const AMOVIESETUP_FILTER sudLine21Dec ;

#ifndef _INC_L21DFILT_H
#define _INC_L21DFILT_H

#pragma pack(push, 1)

//
//  DVD Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From DVD specifications...
#define AM_L21_GOPUD_HDR_STARTCODE      0x000001B2
#define AM_L21_GOPUD_HDR_INDICATOR      0x4343
#define AM_L21_GOPUD_HDR_RESERVED       0x01F8
#define AM_L21_GOPUD_HDR_TOPFIELD_FLAG  0x1
#define AM_L21_GOPUD_ELEM_MARKERBITS    0x7F
#define AM_L21_GOPUD_ELEM_VALIDFLAG     0x1
// There can be max 63 frames/fields' worth data per packet as there are 
// 6 bits to represent this number in the packet.
#define AM_L21_GOPUD_ELEMENT_MAX        63

typedef struct _AM_L21_GOPUD_ELEMENT {
    BYTE        bMarker_Switch ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_GOPUD_ELEMENT, *PAM_L21_GOPUD_ELEMENT ;

typedef struct _AM_L21_GOPUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Indicator[2] ;
    BYTE        abL21Reserved[2] ;
    BYTE        bTopField_Rsrvd_NumElems ;
} AM_L21_GOPUD_HEADER, *PAM_L21_GOPUD_HEADER ;

typedef struct _AM_L21_GOPUD_PACKET {
    AM_L21_GOPUD_HEADER   Header ;
    AM_L21_GOPUD_ELEMENT  aElements[AM_L21_GOPUD_ELEMENT_MAX] ;
} AM_L21_GOPUD_PACKET, *PAM_L21_GOPUD_PACKET ;

#define GETGOPUD_NUMELEMENTS(pGOPUDPacket) ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x3F)
#define GETGOPUD_PACKETSIZE(pGOPUDPacket)  (LONG)(sizeof(AM_L21_GOPUD_HEADER) + GETGOPUD_NUMELEMENTS(pGOPUDPacket) * sizeof(AM_L21_GOPUD_ELEMENT))
#define GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ((pGOPUDPacket)->aElements[i])
#define GETGOPUD_ELEM_MARKERBITS(Elem)     ((((Elem).bMarker_Switch & 0xFE) >> 1) & 0x7F)
#define GETGOPUD_ELEM_SWITCHBITS(Elem)     ((Elem).bMarker_Switch & 0x01)

#define GETGOPUD_L21STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
    (DWORD)((Header).abL21StartCode[1]) << 16 | \
    (DWORD)((Header).abL21StartCode[2]) <<  8 | \
(DWORD)((Header).abL21StartCode[3]) )
#define GETGOPUD_L21INDICATOR(Header)             \
    ( (DWORD)((Header).abL21Indicator[0]) << 8 |  \
(DWORD)((Header).abL21Indicator[1]) )
#define GETGOPUD_L21RESERVED(Header)              \
    ( (DWORD)((Header).abL21Reserved[0]) << 8  |  \
(DWORD)((Header).abL21Reserved[1]) )

#define GOPUD_HEADERLENGTH   (4+2+2+1)
#define GETGOPUD_ELEMENT(pGOPUDPkt, i)  (pGOPUDPkt + GOPUD_HEADERLENGTH + sizeof(AM_L21_GOPUD_ELEMENT) * i)
#define ISGOPUD_TOPFIELDFIRST(pGOPUDPacket)  ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x80)


//
//  ATSC Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From ATSC Standards for Coding 25/50Hz Video (A/63) specifications...
#define AM_L21_ATSCUD_HDR_STARTCODE      0x000001B2
#define AM_L21_ATSCUD_HDR_IDENTIFIER     0x47413934
#define AM_L21_ATSCUD_HDR_TYPECODE_EIA   0x03
#define AM_L21_ATSCUD_HDR_EM_DATA_FLAG   0x80
#define AM_L21_ATSCUD_HDR_CC_DATA_FLAG   0x40
#define AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG 0x20
#define AM_L21_ATSCUD_HDR_CC_COUNT_MASK  0x1F
#define AM_L21_ATSCUD_HDR_NEXTBITS_ON    0x01
#define AM_L21_ATSCUD_ELEM_MARKERBITS    0xF8
#define AM_L21_ATSCUD_ELEM_VALID_FLAG    0x04
#define AM_L21_ATSCUD_ELEM_TYPE_FLAG     0x03
#define AM_L21_ATSCUD_MARKERBITS         0xFF
#define AM_L21_ATSCUD_HDR_NEXTBITS_FLAG  0x00000100
// There can be max 31 frames/fields' worth data per packet as there are 
// 5 bits to represent this number in the packet.
#define AM_L21_ATSCUD_ELEMENT_MAX        31

typedef struct _AM_L21_ATSCUD_ELEMENT {
    BYTE        bCCMarker_Valid_Type ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_ATSCUD_ELEMENT, *PAM_L21_ATSCUD_ELEMENT ;

typedef struct _AM_L21_ATSCUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Identifier[4] ;
    BYTE        bL21UDTypeCode ;
    BYTE        bL21DataFlags_Count ;
    BYTE        bL21EMData ;
} AM_L21_ATSCUD_HEADER, *PAM_L21_ATSCUD_HEADER ;

typedef struct _AM_L21_ATSCUD_PACKET {
    AM_L21_ATSCUD_HEADER   Header ;
    AM_L21_ATSCUD_ELEMENT  aElements[AM_L21_ATSCUD_ELEMENT_MAX] ;
    BYTE                   bMarkerBits ;
} AM_L21_ATSCUD_PACKET, *PAM_L21_ATSCUD_PACKET ;

#define GETATSCUD_NUMELEMENTS(pATSCUDPacket) ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_COUNT_MASK)
#define GETATSCUD_PACKETSIZE(pATSCUDPacket)  (LONG)(sizeof(AM_L21_ATSCUD_HEADER) + \
                                              GETATSCUD_NUMELEMENTS(pATSCUDPacket) * sizeof(AM_L21_ATSCUD_ELEMENT) + \
                                              sizeof(BYTE))
#define GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ((pATSCUDPacket)->aElements[i])
#define GETATSCUD_ELEM_MARKERBITS(Elem)     (((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS) >> 3)

#define GETATSCUD_STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
      (DWORD)((Header).abL21StartCode[1]) << 16 | \
      (DWORD)((Header).abL21StartCode[2]) <<  8 | \
      (DWORD)((Header).abL21StartCode[3]) )
#define GETATSCUD_IDENTIFIER(Header)             \
    ( (DWORD)((Header).abL21Identifier[0]) << 24 | \
      (DWORD)((Header).abL21Identifier[1]) << 16 | \
      (DWORD)((Header).abL21Identifier[2]) <<  8 | \
      (DWORD)((Header).abL21Identifier[3]) )
#define GETATSCUD_TYPECODE(Header)    (DWORD)((Header).bL21UDTypeCode)
#define ISATSCUD_TYPE_EIA(pATSCUDPacket)  (AM_L21_ATSCUD_HDR_TYPECODE_EIA == \
                                     ((pATSCUDPacket)->Header.bL21UDTypeCode & 0xFF))
#define ISATSCUD_EM_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_EM_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_EM_DATA_FLAG))
#define ISATSCUD_CC_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_CC_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_DATA_FLAG))
#define ISATSCUD_ADDL_DATA(pATSCUDPacket) (AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG))
#define GETATSCUD_EM_DATA(pATSCUDPacket)  ((pATSCUDPacket)->Header.bL21EMData)
#define ISATSCUD_ELEM_MARKERBITS_VALID(Elem)     (AM_L21_ATSCUD_ELEM_MARKERBITS == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS))
#define ISATSCUD_ELEM_CCVALID(Elem)  (AM_L21_ATSCUD_ELEM_VALID_FLAG == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_VALID_FLAG))
#define GETATSCUD_ELEM_CCTYPE(Elem)    (DWORD)((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_TYPE_FLAG))
#define GETATSCUD_MARKERBITS(pATSCUDPacket) (DWORD)((pATSCUDPacket)->bMarkerBits)
#define ISATSCUD_MARKER_BITSVALID(pATSCUDPacket) (AM_L21_ATSCUD_MARKERBITS == \
                                       ((pATSCUDPacket)->bMarkerBits & AM_L21_ATSCUD_MARKERBITS))

// Header = StartCode + Id + TypeCode + (EM_CC_Addl_Data + CCCount) + EM_Data
#define ATSCUD_HEADERLENGTH   (4+4+1+1+1)
#define GETATSCUD_ELEMENT(pATSCUDPkt, i)  ((BYTE)(pATSCUDPkt) + ATSCUD_HEADERLENGTH + \
                                            sizeof(AM_L21_ATSCUD_ELEMENT) * i)


// CC type in GOP packet
typedef enum {
    GOP_CCTYPE_Unknown = 0,  // Invalid
    GOP_CCTYPE_None,         // all 0 -- filler packet
    GOP_CCTYPE_DVD,          // DVD CC packets
    GOP_CCTYPE_ATSC,         // ATSC CC packets
} GOPPACKET_CCTYPE ;


// Some more flag, struct and macro definitions...
#define AM_L21_INFO_FIELDBASED          0x0001
#define AM_L21_INFO_TOPFIELDFIRST       0x0003
#define AM_L21_INFO_BOTTOMFIELDFIRST    0x0005

typedef struct _AM_LINE21INFO {
    DWORD       dwFieldFlags ;
    UINT        uWidth ;
    UINT        uHeight ;
    UINT        uBitDepth ;
    DWORD       dwAvgMSecPerSample ;
} AM_LINE21INFO, *PAM_LINE21INFO ;


//
//  Message Window class (for handling WM_TIMER messages) definition
//
class CMessageWindow 
{
public:
    CMessageWindow() ;
    ~CMessageWindow() ;
    
    HWND GetHandle() {
        return m_hWnd ;
    } ;
    int  AddCount() {
        m_iCount++ ;
        return m_iCount ;
    } ;
    int  ReleaseCount() {
        if (GetHandle() == NULL)  // something wrong -- get out of here
            return 0 ;

        m_iCount-- ; 
        ASSERT(m_iCount >= 0) ;
        if (m_iCount < 0)  // paranoia!!!
            m_iCount = 0 ;
        return m_iCount ;
    } ;
    
private:
    HWND       m_hWnd ;
    int        m_iCount ;
    
    static LRESULT CALLBACK MsgWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) ;
} ;


#define ISRECTEQUAL(r1, r2) (r1.top == r2.top && r1.left == r2.left && r1.right == r2.right && r1.bottom == r2.bottom)


//
//  Line 21 Decoder class definition
//
class CLine21DecFilter : public CTransformFilter,
                         // public ISpecifyPropertyPages, -- WILL DO LATER
                         public IAMLine21Decoder
{
    friend class CMessageWindow ;
    
private:
    static CMessageWindow  *m_pMsgWnd ; // hidden window to process WM_TIMER messages
    
public:
    
    //
    //  Constructor and destructor
    //
    CLine21DecFilter(TCHAR *, LPUNKNOWN, HRESULT *) ;
    ~CLine21DecFilter() ;
    
    //
    //   Standard COM stuff
    //
    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
    static void InitClass(BOOL, const CLSID *) ;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;
    DECLARE_IUNKNOWN ;
    
    //
    //   CTranformFilter overrides
    //
    // I must override it
    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut) ;
    
    // Real stuff is in here...
    HRESULT Receive(IMediaSample * pIn) ;
    
    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn) ;
    
    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn,
                           const CMediaType* mtOut) ;
    
    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
							 ALLOCATOR_PROPERTIES *pProperties) ;
    
    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt) ;
    
    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) ;
    
    HRESULT EndOfStream(void) ;
    HRESULT BeginFlush(void) ;
    HRESULT EndFlush(void) ;
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State) ;
    
    // overridden to know when we're starting/stopping the decoding
    STDMETHODIMP Stop(void) ;
    STDMETHODIMP Pause(void) ;
    
    // overridden to know when connections are completed, so that we can get 
    // the media type (actualy format) info for caching
    HRESULT CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin) ;
    
    // Override to know when we disconnect from in/output side to not use
    // any specified output format any more.
    HRESULT BreakConnect(PIN_DIRECTION dir) ;

#if 0 // no QM for now
    // We also override this one as we handle the quality management messages
    HRESULT AlterQuality(Quality q) ;
#endif // #if 0

    //
    // ISpecifyPropertyPages method
    //
    // STDMETHODIMP GetPages(CAUUID *pPages) ;
    
    //
    // IAMLine21Decoder interface methods
    //
    STDMETHODIMP GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel) ;
    STDMETHODIMP GetCurrentService(AM_LINE21_CCSERVICE *lpService) ;
    STDMETHODIMP SetCurrentService(AM_LINE21_CCSERVICE Service) ;
    STDMETHODIMP GetServiceState(AM_LINE21_CCSTATE *lpState) ;
    STDMETHODIMP SetServiceState(AM_LINE21_CCSTATE State) ;
    STDMETHODIMP GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    STDMETHODIMP SetOutputFormat(LPBITMAPINFO lpbmi) ;
    STDMETHODIMP GetBackgroundColor(DWORD *pdwPhysColor) ;
    STDMETHODIMP SetBackgroundColor(DWORD dwPhysColor) ;
    STDMETHODIMP GetRedrawAlways(LPBOOL lpbOption) ;
    STDMETHODIMP SetRedrawAlways(BOOL bOption) ;
    STDMETHODIMP GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode) ;
    STDMETHODIMP SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) ;
    
private:   // data
    
    // Pointer to output buffer (cacheing for efficiency)
    LPBYTE              m_pbOutBuffer ;
    
    // Line21 Data Decoder class that takes 2 bytes and converts to a bitmap
    CLine21DataDecoder  m_L21Dec ;

    // What input format type is being used (better to use an integer flag)
    AM_LINE21_CCSUBTYPEID  m_eSubTypeIDIn ;
    
    GOPPACKET_CCTYPE       m_eGOP_CCType ;  // if GOPPackets used, what type data (DVD/ATSC/...)

    REFERENCE_TIME  m_rtTimePerSample ;  // (in 100 nSec) interval per byte pair from a packet (for GOP packet type)
    REFERENCE_TIME  m_rtStart ;          // start time for an output sample
    REFERENCE_TIME  m_rtStop ;           // stop time for an out output sample
    REFERENCE_TIME  m_rtLastSample ;     // start time of last delivered sample
    LONGLONG        m_llMediaStart ;     // media time start (rarely used, but...)
    REFERENCE_TIME  m_llMediaStop ;      // media time stop (rarely used, but...)
    
    // flag to detect if we must send an output sample
    BOOL        m_bMustOutput ;

    // flag to remember if the last input sample was a discontiuity sample
    BOOL        m_bDiscontLast ;
    
    // If the upstream filter doesn't specify any format type, use one from
    // our internal defaults
    VIDEOINFO  *m_pviDefFmt ;
    DWORD       m_dwDefFmtSize ;
    
    // Keep a copy of last output sample's bounding rect
    RECT        m_rectLastOutput ;
    IPin       *m_pPinDown ;    // downstream pin connected to our output
    
    CMediaType  m_mtOutput ; // current output mediatype (cached)
    //
    // For timer arrangement to complete any scrolling in roll-up mode
    // or to clear old CC (only in byte pair mode as DVD doesn't need it),
    // if input data flow stops in the middle.
    //
    UINT_PTR     m_uTimerID ;    // timer id
    UINT         m_uTimerCount ; // count of how many times TimerProc() was entered;
                                 // used for timing out CC in byte pair mode.
    BOOL         m_bTimerClearReqd ;  // timer reqd for clearing old CC

    //
    // Data for Blending Param operation on the OverlayMixer's in pin
    //
    DWORD        m_dwBlendParam ;    // blend param from Get..() call
    BOOL         m_bBlendingState ;  // CC blending state last set

#if 0 // no QM for now
    // number of samples to skip between every output CC sample for QM handling
    int          m_iSkipSamples ;
#endif // #if 0

#ifdef PERF
    int          m_idDelvWait ;
#endif // PERF
    
private:   // functions
    void    GetActualColorKey(void) ;
    AM_LINE21_CCSUBTYPEID MapGUIDToID(const GUID *pFormatIn) ;
    BOOL    VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket) ;
    BOOL    VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket) ;
    BOOL    IsFillerPacket(BYTE *pGOPPacket) ;
    DWORD   GetOwnPalette(int iNumEntries, PALETTEENTRY *ppe) ;
    HRESULT GetDefaultFormatInfo(void) ;
    BOOL    IsValidFormat(BYTE *pbFormat) ;
    HRESULT SendOutputSample(IMediaSample *pIn, 
                    REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop) ;
    void    SetBlendingState(BOOL bState) ;
    void    SetupTimerIfReqd(BOOL bTimerClearReqd) ;
    void    FreeTimer(void) ;
    static void CALLBACK TimerProc(HWND hWnd, UINT uMsg, UINT_PTR uID, DWORD dwTime) ;

    GOPPACKET_CCTYPE DetectGOPPacketDataType(BYTE *pGOPPacket) ;
    HRESULT ProcessGOPPacket_DVD(IMediaSample *pIn) ;
    HRESULT ProcessGOPPacket_ATSC(IMediaSample *pIn) ;

#if 0 // no QM for now
    inline int  GetSkipSamples(void)   { return m_iSkipSamples ; }
    inline void ResetSkipSamples(void) { m_iSkipSamples = 0 ; } ;
#endif // #if 0
} ;

#pragma pack(pop)

#endif // _INC_L21DFILT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21dgdi.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: GDI-related base class code
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"


//
//  CGDIWork: class for GDI details to print caption text to output bitmap
//
CGDIWork::CGDIWork(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("CGDIWork::CGDIWork()"))) ;
    
#ifdef PERF
    m_idClearIntBuff = MSR_REGISTER(TEXT("L21DPerf - Int Buff Clear")) ;
    m_idClearOutBuff = MSR_REGISTER(TEXT("L21DPerf - Out Buff Clear")) ;
#endif // PERF

#ifdef TEST
    m_hDCTest = CreateDC("Display",NULL, NULL, NULL) ;       // a DC on the desktop just for testing
    ASSERT(m_hDCTest) ;
#endif // TEST
    
    // Init some of the members
    m_hDCInt = CreateCompatibleDC(NULL) ;
    ASSERT(m_hDCInt) ;
    m_bDCInited    = FALSE ;  // DC is not init-ed yet
    m_hBmpInt      = NULL ;
    m_lpbIntBuffer = NULL ;
    m_hBmpIntOrig  = NULL ;
    m_lpbOutBuffer = NULL ;
    m_bOutputInverted = FALSE ; // by default +ve output height
    m_hFontOrig    = NULL ;
    m_hFontDef     = NULL ;
    m_hFontSpl     = NULL ;
    
    // Create an initial input BITMAPINFO struct to start with
    InitBMIData() ;
    m_lpBMIOut = NULL ;
    m_uBMIOutSize = 0 ;
    
    // Init the width and height based on prelim size so that we can compare 
    // any size changes later
    if (m_lpBMIIn)  // InitBMIData() succeeded as it should
    {
        m_lWidth  = m_lpBMIIn->bmiHeader.biWidth ;
        m_lHeight = m_lpBMIIn->bmiHeader.biHeight ;
    }
    else  // InitBMIData() failed -- bad case!!!
    {
        m_lWidth  = 320 ;
        m_lHeight = 240 ;
    }
    
    // set the default color key for output background color
    SetDefaultKeyColor(&(m_lpBMIIn->bmiHeader)) ;
    
    SetColorFiller() ; // fill color filler array with above color key
    m_bOutDIBClear = FALSE ;  // output DIB secn is cleared by ClearInternalBuffer()
    m_bBitmapDirty = FALSE ;  // bitmap isn't dirty to start with
    
    // check if Lucida Console is available (the callback sets the m_bUseTTFont flag)
    CheckTTFont() ;

    //
    // We are not supposed to use the 10% of the border on the top/bottom and left/right.
    // But leaving 10% on each side for a 320x240 image when we are using a non-TT font,
    // like "Terminal", leaves very little room for showing captions. So I leave only 5% 
    // on each side with non-TT font.
    // By doing this I am violating the spec, but it's a necessary evil.
    // When TT font (Lucida Console) is available, we leave 10% border on every side.
    //
    if ( IsTTFont() )
        m_iBorderPercent = 20 ;
    else
        m_iBorderPercent = 10 ;
    
    InitFont() ;   // init the log font struct, create and select default font
    
    m_bFontSizeOK = SetCharNBmpSize() ;   // get the char width and height for default font
    
    // We are using a black background color
    SetBkColor(m_hDCInt, RGB(  0, 0,   0)) ;
    SetBkMode(m_hDCInt, TRANSPARENT) ;
    
    // Init the COLORREF array of 7 FG colors
    m_acrFGColors[0] = RGB(255, 255, 255) ;   // white
    m_acrFGColors[1] = RGB(  0, 255,   0) ;   // green
    m_acrFGColors[2] = RGB(  0,   0, 255) ;   // blue
    m_acrFGColors[3] = RGB(  0, 255, 255) ;   // cyan
    m_acrFGColors[4] = RGB(255,   0,   0) ;   // red
    m_acrFGColors[5] = RGB(255, 255,   0) ;   // yellow
    m_acrFGColors[6] = RGB(128,   0, 128) ;   // (dull) magenta
    // m_acrFGColors[6] = RGB(255,   0, 255) ;   // magenta
    
    InitColorNLastChar() ;  // init with a text color and last CC char printed
    
    // For now assume a non-opaque background
    m_bOpaque = TRUE ;
}

CGDIWork::~CGDIWork(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("CGDIWork::~CGDIWork()"))) ;
    
    // Delete the DIBSection associated with this DC
    DeleteOutputDC() ;
    
    // Unselect and delete the selected font
    if (m_bUseSplFont)   // if special font is in use now
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;
        DeleteObject(m_hFontSpl) ;
        m_hFontSpl = NULL ;
        m_bUseSplFont = FALSE ;
    }
    else    // default font in use now
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;
    }
    DeleteObject(m_hFontDef) ;  // delete the default font in any case
    m_hFontDef = NULL ;
    
    // Now delete the DC
    DeleteDC(m_hDCInt) ;
    m_hDCInt = NULL ;
    
    // release BMI data pointer
    if (m_lpBMIOut)
        delete m_lpBMIOut ;
    m_uBMIOutSize = 0 ;
    if (m_lpBMIIn)
        delete m_lpBMIIn ;
    m_uBMIInSize = 0 ;
    
#ifdef TEST
    DeleteDC(m_hDCTest) ;  // a DC on the desktop just for testing
    DbgLog((LOG_ERROR, 1, TEXT("Test DC is being released"))) ;
#endif // TEST
}


int CALLBACK CGDIWork::EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM, 
                                    int iFontType, LPARAM lParam)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::EnumFontProc(0x%lx, 0x%lx, %d, %ld)"), 
            lpELFE, lpNTM, iFontType, lParam)) ;

    // Just verify that we got a valid TT font
    if ( !(lpELFE->elfLogFont.lfCharSet & 0xFFFFFF00) &&
        !(lpELFE->elfLogFont.lfPitchAndFamily & 0xFFFFFF00) &&
        !(iFontType & 0xFFFF0000) )
    {
        ASSERT(lpELFE->elfLogFont.lfPitchAndFamily & (FIXED_PITCH | FF_MODERN)) ;
        ((CGDIWork *) (LPVOID) lParam)->m_lfChar = lpELFE->elfLogFont ;
        ((CGDIWork *) (LPVOID) lParam)->m_bUseTTFont = TRUE ;
        return 1 ;
    }
    
    ASSERT(FALSE) ;  // Weird!!! We should know about it.
    return 0 ;
}


void CGDIWork::CheckTTFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::CheckTTFont()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    m_bUseTTFont = FALSE ;  // assume not available
    ZeroMemory(&m_lfChar, sizeof(LOGFONT)) ;
    lstrcpy(m_lfChar.lfFaceName, TEXT("Lucida Console")) ;
    m_lfChar.lfCharSet = ANSI_CHARSET ;
    m_lfChar.lfPitchAndFamily = 0 ;
    EnumFontFamiliesEx(m_hDCInt, &m_lfChar, (FONTENUMPROC) EnumFontProc, (LPARAM)(LPVOID)this, 0) ;
}


void CGDIWork::InitColorNLastChar(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::InitColorNLastChar()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // Last caption char init
    m_ccLast.SetChar(0) ;
    m_ccLast.SetEffect(0) ;
    m_ccLast.SetColor(AM_L21_FGCOLOR_WHITE) ;
    
    // Use white as default text color
    m_uColorIndex = AM_L21_FGCOLOR_WHITE ;
    if (CLR_INVALID == SetTextColor(m_hDCInt, m_acrFGColors[m_uColorIndex]))
        ASSERT(FALSE) ;
}


void CGDIWork::SetDefaultKeyColor(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetDefaultKeyColor(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    switch (lpbmih->biBitCount)
    {
    case 8:   
        m_dwPhysColor = 253 ;   // hard coded for magenta
        break ;
        
    case 16:
        if (BI_BITFIELDS == lpbmih->biCompression)  // 565
            m_dwPhysColor = (0x1F << 11) | (0 << 9 ) | (0x1F) ; // magenta by default
        else                                        // 555
            m_dwPhysColor = (0x1F << 10) | (0 << 8 ) | (0x1F) ; // magenta by default
        break ;
        
    case 24:
        m_dwPhysColor = RGB(0xFF, 0, 0xFF) ; // magenta by default
        break ;
        
    case 32:
        m_dwPhysColor = RGB(0xFF, 0, 0xFF) ; // magenta by default
        break ;
        
    default:
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: UFOs have finally landed here!!"))) ;
        break ;
    }
}


#define SETPALETTECOLOR(pe, r, g, b)  pe.peRed = r ; pe.peGreen = g ; pe.peBlue = b ; pe.peFlags = 0 ;

DWORD CGDIWork::GetOwnPalette(int iNumEntries, PALETTEENTRY *ppe)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetOwnPalette(%d, 0x%lx)"), 
            iNumEntries, ppe)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    ASSERT(iPALETTE_COLORS == iNumEntries) ;
    ASSERT(! IsBadWritePtr(ppe, sizeof(PALETTEENTRY) * iNumEntries)) ;
    
    ZeroMemory(ppe, sizeof(PALETTEENTRY) * iNumEntries) ;  // clear all first
    SETPALETTECOLOR(ppe[0]  ,   0,   0,   0) ;  // black
    SETPALETTECOLOR(ppe[1]  , 128,   0,   0) ;  // brown
    SETPALETTECOLOR(ppe[2]  ,   0, 128,   0) ;  // green
    SETPALETTECOLOR(ppe[3]  , 128, 128,   0) ;  // some mix
    SETPALETTECOLOR(ppe[4]  ,   0,   0, 128) ;  // blue
    SETPALETTECOLOR(ppe[5]  , 128,   0, 128) ;  // dull magenta
    SETPALETTECOLOR(ppe[6]  ,   0, 128, 128) ;  // dull cyan
    SETPALETTECOLOR(ppe[7]  , 192, 192, 192) ;  // gray
    SETPALETTECOLOR(ppe[8]  , 192, 220, 192) ;  // greenish gray
    SETPALETTECOLOR(ppe[9]  , 166, 202, 240) ;  // very lt blue
    SETPALETTECOLOR(ppe[246], 255, 251, 240) ;  // dull white
    SETPALETTECOLOR(ppe[247], 160, 160, 164) ;  // lt gray
    SETPALETTECOLOR(ppe[248], 128, 128, 128) ;  // dark gray
    SETPALETTECOLOR(ppe[249], 255,   0,   0) ;  // red
    SETPALETTECOLOR(ppe[250],   0, 255,   0) ;  // lt green
    SETPALETTECOLOR(ppe[251], 255, 255,   0) ;  // yellow
    SETPALETTECOLOR(ppe[252],   0,   0, 255) ;  // lt blue
    SETPALETTECOLOR(ppe[253], 255,   0, 255) ;  // magenta/pink
    SETPALETTECOLOR(ppe[254],   0, 255, 255) ;  // cyan
    SETPALETTECOLOR(ppe[255], 255, 255, 255) ;  // white
    
    return iNumEntries ;
}


DWORD CGDIWork::GetPaletteForFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetOwnPalette(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    // Now set the palette data too; we pick the system palette colors
    HDC hDC = GetDC(NULL) ;
    if (NULL == hDC)
    {
        ASSERT(!TEXT("GetDC(NULL) failed")) ;
        return 0 ;  // no color in palette
    }

    lpbmih->biClrUsed = GetSystemPaletteEntries(hDC, 0, iPALETTE_COLORS, 
                                        (PALETTEENTRY *)(lpbmih + 1)) ;
    lpbmih->biClrImportant = 0 ;
    ReleaseDC(NULL, hDC) ;
            
    //
    // At least on NT, GetSystemPaletteEntries() call returns 0 if the display
    // is in non-palettized mode.  In such a case, I need to hack up my own 
    // palette so that we can still support 8bpp output.
    //
    if (0 == lpbmih->biClrUsed)  // GetSystemPaletteEntries() failed
    {
        DbgLog((LOG_TRACE, 2, 
                TEXT("Couldn't get system palette (non-palette mode?) -- using own palette"))) ;
        lpbmih->biClrUsed = GetOwnPalette(iPALETTE_COLORS, (PALETTEENTRY *)(lpbmih + 1)) ;
    }

    return lpbmih->biClrUsed ;  // number of palette entries
}


bool CGDIWork::InitBMIData(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::InitBMIData()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    HDC  hDCTemp = GetDC(NULL) ;
    if (NULL == hDCTemp)
    {
        ASSERT(!TEXT("GetDC(NULL) failed")) ;
        return false ;
    }
    WORD wPlanes   = (WORD)GetDeviceCaps(hDCTemp, PLANES) ;
    WORD wBitCount = (WORD)GetDeviceCaps(hDCTemp, BITSPIXEL) ;
    ReleaseDC(NULL, hDCTemp) ;

    m_uBMIInSize = sizeof(BITMAPINFOHEADER) ;  // at least

    // Increase BITMAPINFO struct size based of bpp value
    if (8 == wBitCount)        // palettized mode
        m_uBMIInSize += 256 * sizeof(RGBQUAD) ;  // for palette entries
    else // if (32 == wBitCount)  // we'll use BIT_BITFIELDS
        m_uBMIInSize += 3 * sizeof(RGBQUAD) ;    // for bitmasks

    m_lpBMIIn = (LPBITMAPINFO) new BYTE[m_uBMIInSize] ;
    if (NULL == m_lpBMIIn)
    {
        ASSERT(!TEXT("Out of memory for BMIIn buffer")) ;
        return false ;
    }
    m_lpBMIIn->bmiHeader.biSize = sizeof(BITMAPINFOHEADER) ;
    m_lpBMIIn->bmiHeader.biWidth = CAPTION_OUTPUT_WIDTH ;
    m_lpBMIIn->bmiHeader.biHeight = CAPTION_OUTPUT_HEIGHT ;
    m_lpBMIIn->bmiHeader.biPlanes   = wPlanes ;
    m_lpBMIIn->bmiHeader.biBitCount = wBitCount ;
    // We should detect the 16bpp - 565 mode too; but how??
    if (32 == m_lpBMIIn->bmiHeader.biBitCount)
        m_lpBMIIn->bmiHeader.biCompression = BI_BITFIELDS ;
    else
        m_lpBMIIn->bmiHeader.biCompression = BI_RGB ;
    m_lpBMIIn->bmiHeader.biSizeImage = DIBSIZE(m_lpBMIIn->bmiHeader) ;
    m_lpBMIIn->bmiHeader.biXPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biYPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biClrUsed = 0 ;
    m_lpBMIIn->bmiHeader.biClrImportant = 0 ;
    
    //
    // If we are in bitfield mode, set the bmiColors values too.
    // If we are in palettized mode, pickthe system palette.
    //
    switch (m_lpBMIIn->bmiHeader.biBitCount)
    {
    case 8:
        GetPaletteForFormat((LPBITMAPINFOHEADER) m_lpBMIIn) ;
        break ;

    case 16:  // just clear it off
    case 24:  //  .. ditto ..
    case 32:  // set the masks
        {
            DWORD  *pdw = (DWORD *) m_lpBMIIn->bmiColors ;
            if (m_lpBMIIn->bmiHeader.biCompression == BI_BITFIELDS)
            {
                pdw[iRED]   = bits888[iRED] ;
                pdw[iGREEN] = bits888[iGREEN] ;
                pdw[iBLUE]  = bits888[iBLUE] ;
            }
            else              // BI_RGB
            {
                pdw[iRED]   = 
                pdw[iGREEN] = 
                pdw[iBLUE]  = 0 ;
            }
        }
        break ;

    default:  // don't care
        ASSERT(!TEXT("Bad biBitCount!!")) ;
        break ;
    }

    return true ;
}


BOOL CGDIWork::InitFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::InitFont()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    ASSERT(lpbmih) ;
    int   iWidth, iHeight ;
    if (! CharSizeFromOutputSize(lpbmih->biWidth, lpbmih->biHeight, &iWidth, &iHeight) )
    {
        DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: CGDIWork::CharSizeFromOutputSize() failed for %ld x %ld output"), 
                lpbmih->biWidth, lpbmih->biHeight)) ;
        return FALSE ;
    }

    // Init a LOGFONT struct in m_lfChar
    if (m_bUseTTFont)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Got Lucida Console TT Font (%d x %d)."), iWidth, iHeight)) ;
        m_lfChar.lfHeight = -iHeight ;  // -Y means I want "Y only"
        m_lfChar.lfWidth  = -iWidth ;   // -X means I want "X only"

        // m_lfChar.lfFaceName is "Lucida Console"
    }
    else  // no Lucida Console; use 8x12 Terminal font
    {
        DbgLog((LOG_TRACE, 1, 
                TEXT("Did NOT get Lucida Console TT Font. Will use Terminal %d x %d"), 
                iWidth, iHeight)) ;
        m_lfChar.lfHeight = iHeight ;
        m_lfChar.lfWidth  = iWidth ;
        m_lfChar.lfCharSet = OEM_CHARSET ;  // or ANSI???
        m_lfChar.lfPitchAndFamily = FIXED_PITCH | FF_MODERN ;
        lstrcpy(m_lfChar.lfFaceName, TEXT("Terminal")) ;
    }
    m_lfChar.lfEscapement = 0 ;
    m_lfChar.lfOrientation = 0 ;
    m_lfChar.lfWeight = FW_NORMAL ;
    m_lfChar.lfItalic = FALSE ;
    m_lfChar.lfUnderline = FALSE ;
    m_lfChar.lfStrikeOut = FALSE ;
    // m_lfChar.lfCharSet set in CheckTTFont() or above
    m_lfChar.lfOutPrecision = OUT_STRING_PRECIS ;
    m_lfChar.lfClipPrecision = CLIP_STROKE_PRECIS ;
    m_lfChar.lfQuality = DRAFT_QUALITY ;
    // m_lfChar.lfPitchAndFamily set in CheckTTFont() or above
    
    // Create and init the font handles using the above LOGFONT data
    if (m_hFontOrig && m_hFontDef)  // if we are re-initing font stuff
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;  // unselect the default font
        DeleteObject(m_hFontDef) ;             // delete the default font
        // m_hFontDef = NULL ;
        if (m_hFontSpl)  // if we have the special font for italics/UL
        {
            DeleteObject(m_hFontSpl) ;         // delete it
            m_hFontSpl = NULL ;
            m_bUseSplFont = FALSE ;            // no special font now
        }
    }
    
    // Anyway create the default font now and select it in internal DC
    m_hFontDef    = CreateFontIndirect(&m_lfChar) ;
    m_hFontSpl    = NULL ;
    m_bUseSplFont = FALSE ;
    m_hFontOrig   = (HFONT) SelectObject(m_hDCInt, m_hFontDef) ;

    return TRUE ;  // success
}


void CGDIWork::SetNumBytesValues(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetNumBytesValues()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // If we have a output format specified by the downstream filter then use that ONLY
    if (m_lpBMIOut)
    {
        m_uBytesPerPixel = m_lpBMIOut->bmiHeader.biBitCount >> 3 ;
        m_uBytesPerSrcScanLine = m_uIntBmpWidth * m_uBytesPerPixel ;
        m_uBytesPerDestScanLine = m_lpBMIOut->bmiHeader.biWidth * m_uBytesPerPixel ;
        return ;
    }
    
    // If no output format has been defined by the downstream filter, use upstream's
    if (m_lpBMIIn)
    {
        m_uBytesPerPixel = m_lpBMIIn->bmiHeader.biBitCount >> 3 ;
        m_uBytesPerSrcScanLine = m_uIntBmpWidth * m_uBytesPerPixel ;
        m_uBytesPerDestScanLine = m_lpBMIIn->bmiHeader.biWidth * m_uBytesPerPixel ;
    }
    else  // somehow output BMI not specified yet
    {
        DbgLog((LOG_ERROR, 1, TEXT("How did we not have a m_lpBMIIn defined until now?"))) ;
        m_uBytesPerPixel = 0 ;
        m_uBytesPerSrcScanLine = 0 ;
        m_uBytesPerDestScanLine = 0 ;
    }
}


BOOL CGDIWork::SetCharNBmpSize(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetCharNBmpSize()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    if (NULL == m_hDCInt)  // HDC not yet created -- very unlikely!!
        return FALSE ;
    
    // Get the char width and height now
    TEXTMETRIC  tm ;
    GetTextMetrics(m_hDCInt, &tm) ;
    m_uCharWidth = tm.tmAveCharWidth ;
    m_uCharHeight = tm.tmHeight ;  // + tm.tmInternalLeading + tm.tmExternalLeading ;
    DbgLog((LOG_TRACE, 1, TEXT("    *** Chars are %d x %d pixels"), m_uCharWidth, m_uCharHeight)) ;
    
    // We need to scroll the scan lines by as many lines as necessary to complete
    // scrolling within 12 steps max, approx. 0.4 seconds which is the EIA-608
    // standard requirement.
    m_iScrollStep = (int)((m_uCharHeight + DEFAULT_CHAR_HEIGHT - 1) / DEFAULT_CHAR_HEIGHT) ;
    
    // Internal bitmap width and height based on char sizes
    m_uIntBmpWidth  = m_uCharWidth * (MAX_CAPTION_COLUMNS + 2) ; // +2 for leading and trailing space
    m_uIntBmpHeight = m_uCharHeight * MAX_CAPTION_LINES ;        // max 4 lines of caption shown
    
    // Leave a band along the border acc. to the spec.
    LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    BOOL bOK = (m_uIntBmpWidth - MAX_CAPTION_COLUMNS / 2 - 1 <=             // minus to handle rounding
                   (UINT)(lpbmih->biWidth * (100 - m_iBorderPercent) / 100))  &&
               (m_uCharHeight * MAX_CAPTION_ROWS - MAX_CAPTION_ROWS / 2 <=  // minus to handle rounding
                   (UINT)(ABS(lpbmih->biHeight) * (100 - m_iBorderPercent) / 100)) ;
    ASSERT(bOK) ;
    if (! bOK )  // too big font for the output window
    {
        return FALSE ;
    }

    m_uIntBmpWidth = DWORDALIGN(m_uIntBmpWidth) ;  // make sure to DWORD align it

    // We want to store the following values just for speedy usage later
    //
    // horizontally we want to be in the middle
    m_uHorzOffset = (lpbmih->biWidth - m_uIntBmpWidth) / 2 ;
    // vertically we want to leave 10% of the height or leave
    // just enough space to accomodate all the caption lines
    m_uVertOffset = min( ABS(lpbmih->biHeight) * m_iBorderPercent / 200,  // border % is for 2 sides
                         (ABS(lpbmih->biHeight) - (long)(m_uCharHeight * MAX_CAPTION_ROWS)) / 2 ) ;
    
    // Now set the number bytes per pixel/line etc
    SetNumBytesValues() ;
    
    return TRUE ;
}


BOOL CGDIWork::SetBackgroundColor(DWORD dwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetBackgroundColor(0x%lx)"), dwPhysColor)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    BOOL  bChanged = m_dwPhysColor != dwPhysColor ;
    
    if ((DWORD) -1 == dwPhysColor)  // not from OverlayMixer
    {
        // use default for the current output format
        LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
        SetDefaultKeyColor(lpbmih) ;
    }
    else  // as specified by Mixer/VR
    {
        m_dwPhysColor = dwPhysColor ;
    }
    
    // Earlier we used to check if the physical key color has changed and if so
    // only then we updated the color filler array.  Now we just go ahead and 
    // rebuild the color filler (fix for Memphis bug #72274).
    SetColorFiller() ;  // update the color filler
    
    // Rather than returning whether physical key color changed, it's better to
    // fill the background unconditionally
    return TRUE ;
}


void CGDIWork::SetColorFiller(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetColorFiller()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    int                 i ;
    
    switch (lpbmih->biBitCount)
    {
    case 8:
        for (i = 0 ; i < 12 ; i++)
            m_abColorFiller[i] = (BYTE)(m_dwPhysColor & 0xFF) ;
        break ;
        
    case 16:
        for (i = 0 ; i < 12 ; i += 2)
            *((WORD *)&m_abColorFiller[i]) = (WORD)(m_dwPhysColor & 0xFFFF) ;
        break ;
        
    case 24:
        for (i = 0 ; i < 4 ; i++)
        {
            m_abColorFiller[i * 3]     = (BYTE) (m_dwPhysColor & 0xFF) ;
            m_abColorFiller[i * 3 + 1] = (BYTE)((m_dwPhysColor & 0xFF00) >> 8) ;
            m_abColorFiller[i * 3 + 2] = (BYTE)((m_dwPhysColor & 0xFF0000) >> 16) ;
        }
        break ;
        
    case 32:
        for (i = 0 ; i < 12 ; i += 4)
            *((DWORD *)&m_abColorFiller[i]) = m_dwPhysColor ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 0, TEXT("It's just plain impossible!!!"))) ;
        break ;
    }
}


void CGDIWork::FillOutputBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::FillOutputBuffer()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // If an output format is specified by downstream filter, use it;  
    // otherwise use upstream's
    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    
    // If an output buffer is available then only fill it up; else we'll fault
    if (NULL == m_lpbOutBuffer)  // it happens the first time, it's OK.
    {
        DbgLog((LOG_ERROR, 5, TEXT("Why are we trying to fill a NULL buffer??"))) ;
        return ;
    }
    
    MSR_START(m_idClearOutBuff) ;  // start clearing out buffer
    ULONG   ulTotal = m_uBytesPerPixel * lpbmih->biWidth * ABS(lpbmih->biHeight) ;
    if (IsBadWritePtr(m_lpbOutBuffer, ulTotal))  // somehow we can't write to the buffer
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad output buffer. Skip filling it up."))) ;
        return ;
    }
    
    ULONG   ulFillerMax = ulTotal - (ulTotal % 12) ;
    ULONG   ul ;
    for (ul = 0 ; ul < ulFillerMax ; ul += 12)
        CopyMemory(m_lpbOutBuffer + ul, m_abColorFiller, 12) ;
    for (ul = 0 ; ul < ulTotal % 12 ; ul++)
        m_lpbOutBuffer[ulFillerMax + ul] = m_abColorFiller[ul] ;
    MSR_STOP(m_idClearOutBuff) ;   // done clearing out buffer
    
    // Mark the output buffer as new so that the whole content of internal 
    // buffer is copied over
    m_bNewOutBuffer = TRUE ;
}


//
// This method is required only to generate the default format block in case
// the upstream filter doesn't specify FORMAT_VideoInfo type.
//
HRESULT CGDIWork::GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetDefaultFormatInfo(0x%lx, 0x%lx)"),
            lpbmi, pdwSize)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (NULL == pdwSize || IsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        return E_INVALIDARG ;
    }
    
    LPBITMAPINFO lpbmiCurr = (m_lpBMIOut ? m_lpBMIOut : m_lpBMIIn) ;
    UINT dwCurrSize = (m_lpBMIOut ? m_uBMIOutSize : m_uBMIInSize) ;
    ASSERT(dwCurrSize) ;  // just a check
    
    if (NULL == lpbmi)      // wants just the format data size
    {
        *pdwSize = dwCurrSize ;
        return NOERROR ;
    }
    
    if (IsBadWritePtr(lpbmi, *pdwSize))  // not enough space in out-param
        return E_INVALIDARG ;
    
    *pdwSize = min(*pdwSize, dwCurrSize) ;  // minm of actual and given
    CopyMemory(lpbmi, lpbmiCurr, *pdwSize) ;
    
    return NOERROR ;   // success
}


HRESULT CGDIWork::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetOutputFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))  // not enough space in out-param
        return E_INVALIDARG ;
    
    ZeroMemory(lpbmih, sizeof(BITMAPINFOHEADER)) ;  // just to keep it clear
    
    LPBITMAPINFOHEADER lpbmihCurr = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    if (NULL == lpbmihCurr)  // no output format specified by downstream
        return S_FALSE ;
    
    CopyMemory(lpbmih, lpbmihCurr, sizeof(BITMAPINFOHEADER)) ;
    
    return S_OK ;   // success
}


HRESULT CGDIWork::GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetOutputOutFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetOutputOutFormat(): Bad in param"))) ;
        return E_INVALIDARG ;
    }
    if (m_lpBMIOut)
    {
        CopyMemory(lpbmih, m_lpBMIOut, sizeof(BITMAPINFOHEADER)) ;
        return S_OK ;
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("GetOutputOutFormat(): No output format specified by downstream filter"))) ;
        return S_FALSE ;
    }
}


BOOL CGDIWork::IsSizeOK(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::IsSizeOK(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    return ((IsTTFont() && ISDWORDALIGNED(lpbmih->biWidth))  ||  // TT font and DWORD-aligned width  or
            (!IsTTFont() &&                                      // non-TT font and ...
             ((320 == ABS(lpbmih->biWidth) && 240 == ABS(lpbmih->biHeight)) ||   // 320x240 output or
              (640 == ABS(lpbmih->biWidth) && 480 == ABS(lpbmih->biHeight))))) ; // 640x480 output
}


HRESULT CGDIWork::SetOutputOutFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetOutputOutFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // 
    // NULL param means output format not available from downstream filter
    //
    if (NULL == lpbmi)
    {
        if (m_lpBMIOut)
            delete m_lpBMIOut ;
        m_lpBMIOut = NULL ;
        m_uBMIOutSize = 0 ;
        
        // In this case, go back to the default output format specified by 
        // upstream filter
        if (m_lpBMIIn)
        {
            SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
            SetNumBytesValues() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("How did we not have a default output format?"))) ;
        }
        return NOERROR ;
    }
    
    // Just paranoid...
    if (IsBadReadPtr(lpbmi, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Invalid output format (out) data pointer"))) ;
        return E_INVALIDARG ;
    }

    // Make sure we can handle this output size
    if (! IsSizeOK(&lpbmi->bmiHeader) )
        return E_INVALIDARG ;

    // Danny included the beginning of the VIDEOINFOHEADER struct and I don't want it!!!
    UINT uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) - SIZE_PREHEADER ;
    if (NULL == m_lpBMIOut)  // If we didn't have one before then allocate space for one
    {
        m_lpBMIOut = (LPBITMAPINFO) new BYTE [uSize] ;
        if (NULL == m_lpBMIOut)
        {
            DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from downstream"))) ;
            return E_OUTOFMEMORY ;
        }
        m_uBMIOutSize = uSize ;  // new size
    }
    else  // we have an existing out format, but ...
    {
        // ... check if new data is bigger than the current space we have
        if (m_uBMIOutSize < uSize)
        {
            delete m_lpBMIOut ;
            m_lpBMIOut = (LPBITMAPINFO) new BYTE[uSize] ;
            if (NULL == m_lpBMIOut)
            {
                DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from downstream"))) ;
                m_uBMIOutSize = 0 ;
                return FALSE ;
            }
            m_uBMIOutSize = uSize ;
        }
    }
    
    // Make sure the output size specified by the format is such that
    // each scanline is DWORD aligned
    lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
    lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;
    
    // Now copy the specified format data
    CopyMemory(m_lpBMIOut, lpbmi, uSize) ;
    
    // Check if the output size is changing and update all the related vars
    SetOutputSize(m_lpBMIOut->bmiHeader.biWidth, m_lpBMIOut->bmiHeader.biHeight) ;
    SetNumBytesValues() ;
    
    return NOERROR ;
}


HRESULT CGDIWork::SetOutputInFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetOutputInFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // 
    // NULL param means no output format from upstream filter
    //
    if (NULL == lpbmi)
    {
#if 0
        if (m_lpBMIOut)
        {
            //
            // BTW this can happen when the graph is torn down at the end of
            // playback.  We can ignore this error in that case.
            //
            DbgLog((LOG_ERROR, 3, TEXT("Can't delete Output format from upstream w/o downstream specifying it"))) ;
            return E_INVALIDARG ;
        }
#endif // #if 0
        if (m_lpBMIIn)
            delete m_lpBMIIn ;
        // m_lpBMIIn = NULL ;
        // m_uBMIInSize = 0 ;
        
        //
        // Initialize the default output format from upstream filter
        //
        InitBMIData() ;
        
        // return NOERROR ;
    }
    else  // non-NULL format specified
    {
        UINT uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) ;
        if (IsBadReadPtr(lpbmi, uSize))  // just paranoid...
        {
            DbgLog((LOG_ERROR, 0, TEXT("Not enough output format (in) data pointer"))) ;
            ASSERT(FALSE) ;
            return E_INVALIDARG ;
        }

        // Make sure we can handle this output size
        if (! IsSizeOK(&lpbmi->bmiHeader) )
            return E_INVALIDARG ;

        if (NULL == m_lpBMIIn)  // If we didn't have one before then allocate space for one
        {
            m_lpBMIIn = (LPBITMAPINFO) new BYTE [uSize] ;
            if (NULL == m_lpBMIIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from upstream"))) ;
                return E_OUTOFMEMORY ;
            }
        }
        else  // we have an existing out format, but ...
        {
            // ... check if new data is bigger than the current space we have
            if (m_uBMIInSize < uSize)
            {
                delete m_lpBMIIn ;
                m_lpBMIIn = (LPBITMAPINFO) new BYTE[uSize] ;
                if (NULL == m_lpBMIIn)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from upstream"))) ;
                    m_uBMIInSize = 0 ;
                    return FALSE ;
                }
                m_uBMIInSize = uSize ;
            }
        }
        
        // Make sure the output size specified by the format is such that
        // each scanline is DWORD aligned
        lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
        lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;
        
        // Now copy the specified format data
        CopyMemory(m_lpBMIIn, lpbmi, uSize) ;
    }  // end of else of if (lpbmi)
    
    // If we don't have a output format specified by downstream then we'll
    // use this output format and resize the output accordingly
    if (NULL == m_lpBMIOut)
    {
        // Check if output size is changing and update all the related vars
        SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
        SetNumBytesValues() ;
        
        // Create color filler based on input-side format spec.
        SetColorFiller() ;
    }
    
    return NOERROR ;
}


void CGDIWork::ClearInternalBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ClearInternalBuffer()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    //
    // There is a window of opportunity while doing Stop(), that the internal DIB section
    // has been deleted, but CTransformFilter::Stop() hasn't yet been called. So the
    // filter may keep on trying to do its job, like clearing the internal buffer, and
    // fault!!!
    //
    if (!m_bDCInited) {     // DIB secn not yet created/already deleted
        DbgLog((LOG_TRACE, 5, TEXT("Internal DIBsection has been deleted; skipped erasing it."))) ;
        return ;            // just quietly leave....
    }
    MSR_START(m_idClearIntBuff) ;  // start clearing internal buffer
    
    // We add m_uCharHeight because of the extra 1 line of space that we 
    // acquire to scroll
    ULONG   ulTotal = m_uIntBmpWidth * m_uBytesPerPixel * (m_uIntBmpHeight + m_uCharHeight) ;
    ULONG   ulFillerMax = ulTotal - (ulTotal % 12) ;
    ULONG   ul ;
    for (ul = 0 ; ul < ulFillerMax ; ul += 12)
        CopyMemory(m_lpbIntBuffer + ul, m_abColorFiller, 12) ;
    for (ul = 0 ; ul < ulTotal % 12 ; ul++)
        m_lpbIntBuffer[ulFillerMax + ul] = m_abColorFiller[ul] ;
    
    MSR_STOP(m_idClearIntBuff) ;   // done clearing internal buffer
    m_bBitmapDirty = TRUE ;  // bitmap has changed (needs to be redrawn to reflect that)
    m_bOutDIBClear = TRUE ;  // bitmap is spotless now!!!
}


void CGDIWork::ChangeFont(BOOL bItalics, BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ChangeFont(%u, %u)"), bItalics, bUnderline)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (NULL == m_hDCInt)
    {
        DbgLog((LOG_ERROR, 2, TEXT("WARNING: ChangeFont() called w/o valid output DC"))) ;
        return ;
    }
    
    // If current font is non-default, un-select & release it
    if (m_bUseSplFont)
    {
        SelectObject(m_hDCInt, m_hFontDef) ;
        DeleteObject(m_hFontSpl) ;
        m_hFontSpl = NULL ;
        m_bUseSplFont = FALSE ;
    }
    
    m_lfChar.lfItalic    = (BYTE)bItalics ;
    m_lfChar.lfUnderline = (BYTE)bUnderline ;
    
    // If special font is reqd, create font & select it
    if (bItalics || bUnderline)
    {
        m_hFontSpl = CreateFontIndirect(&m_lfChar) ;
        SelectFont(m_hDCInt, m_hFontSpl) ;
        m_bUseSplFont = TRUE ;
    }
    // Otherwise m_hFontDef is already selected in m_hDCCurr.
    // So don't do anything more.
}


BOOL CGDIWork::CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight, 
                                      int *piCharWidth, int *piCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::CharSizeFromOutputSize(%ld, %ld, 0x%lx, 0x%lx)"), 
            lOutWidth, lOutHeight, piCharWidth, piCharHeight)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    // We only care about the absolute value here
    lOutWidth  = ABS(lOutWidth) ;
    lOutHeight = ABS(lOutHeight) ;

    if ( IsTTFont() )  // TT font
    {
        if (! ISDWORDALIGNED(lOutWidth) )  // must have DWORD-aligned width
            return FALSE ;

        *piCharWidth   = (int)(lOutWidth * (100 - m_iBorderPercent) / 100) ;  // 80-90% of width
        *piCharWidth  += MAX_CAPTION_COLUMNS / 2 + 1 ;  // max_col / 2 for rounding
        *piCharWidth  /= (MAX_CAPTION_COLUMNS + 2) ;    // space per column
        *piCharHeight  = (int)(lOutHeight * (100 - m_iBorderPercent) / 100) ; // 80-90% of width
        *piCharHeight += (MAX_CAPTION_ROWS / 2) ;       // max_row / 2 for rounding
        *piCharHeight /= MAX_CAPTION_ROWS ;             // space per row
        return TRUE ;  // acceptable
    }
    else  // non-TT font (Terminal) -- only 320x240 or 640x480
    {
        if (640 == lOutWidth  &&  480 == lOutHeight)
        {
            *piCharWidth  = 16 ;
            *piCharHeight = 24 ;
            return TRUE ;  // acceptable
        }
        else if (320 == lOutWidth  &&  240 == lOutHeight)
        {
            *piCharWidth  = 8 ;
            *piCharHeight = 12 ;
            return TRUE ;  // acceptable
        }
        else
            return FALSE ;  // can't handle size for non-TT font
    }
}


void CGDIWork::ChangeFontSize(UINT uCharWidth, UINT uCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ChangeFontSize(%u, %u)"), uCharWidth, uCharHeight)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (NULL == m_hDCInt)
    {
        DbgLog((LOG_ERROR, 2, TEXT("WARNING: ChangeFontSize() called w/o valid output DC"))) ;
        return ;
    }
    
    if ((UINT) ABS(m_lfChar.lfWidth)  == uCharWidth  &&   // same width
        (UINT) ABS(m_lfChar.lfHeight) == uCharHeight)     // same height
        return ;                              // don't change anything
    
    // If current font is non-default, un-select & release it
    if (m_bUseSplFont)
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;
        DeleteObject(m_hFontSpl) ;
        m_hFontSpl = NULL ;
        m_bUseSplFont = FALSE ;
    }
    else
    {
        // delete the default font
        SelectObject(m_hDCInt, m_hFontOrig) ;
        DeleteObject(m_hFontDef) ;
        m_hFontDef = NULL ;
    }
    
    // Change font size in the LOGFONT structure for future fonts
    // Always use -ve height so that we are bound to get that height chars
    if (m_bUseTTFont)
    {
        m_lfChar.lfWidth = uCharWidth ;  // can we ignore this??
        if ((m_lfChar.lfWidth = uCharWidth) > 0)    // if +ve Width,
            m_lfChar.lfWidth = -m_lfChar.lfWidth ;  // change sign to make it -ve
        m_lfChar.lfHeight = uCharHeight ;
        if ((m_lfChar.lfHeight = uCharHeight) > 0)    // if +ve height,
            m_lfChar.lfHeight = -m_lfChar.lfHeight ;  // change sign to make it -ve
        lstrcpy(m_lfChar.lfFaceName, TEXT("Lucida Console")) ;
    }
    else  // no Lucida Console; use 8x12 Terminal font
    {
        m_lfChar.lfHeight = uCharHeight ;
        m_lfChar.lfWidth  = uCharWidth ;
        m_lfChar.lfCharSet = OEM_CHARSET ;
        m_lfChar.lfPitchAndFamily = FIXED_PITCH | FF_MODERN ;
        lstrcpy(m_lfChar.lfFaceName, TEXT("Terminal")) ;
    }
    
    // Create font & select only default font in the DC
    m_hFontDef = CreateFontIndirect(&m_lfChar) ;
    SelectFont(m_hDCInt, m_hFontDef) ;
    
    // Now update the char size, output bitmap size, bytes/pixel etc. too
    m_bFontSizeOK = SetCharNBmpSize() ;
}


BOOL CGDIWork::SetOutputSize(LONG lWidth, LONG lHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetOutputSize(%ld, %ld)"), lWidth, lHeight)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // If a output format is specified by downstream filter, use it; else use upstream's
    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    
    // Now we want to use the ABS()-ed values for calculating the char sizes
    lWidth = ABS(lWidth) ;
    lHeight = ABS(lHeight) ;
    
    if (lpbmih)
    {
        // Check if current output bitmap size is the same or not.
        // This also includes height changing from +ve to -ve and vice-versa
        if (lWidth  == m_lWidth  &&  
            lHeight == m_lHeight)
            return FALSE ;    // same size; nothing changed
        
        // Store the width and height now so that we can compare any size 
        // change and/or -ve/+ve height thing later.
        m_lWidth  = lWidth ;
        m_lHeight = lHeight ;
    }
    
    // Create new DIB section with new sizes (leaving borders)
    int   iCharWidth ;
    int   iCharHeight ;
    if (! CharSizeFromOutputSize(lWidth, lHeight, &iCharWidth, &iCharHeight) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: CharSizeFromOutputSize() failed for %ld x %ld output"),
                lWidth, lHeight)) ;
        return FALSE ;  // failure
    }
    ChangeFontSize(iCharWidth, iCharHeight) ;
    
    return TRUE ;
}


void CGDIWork::ChangeColor(int iColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ChangeColor(%d)"), iColor)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    SetTextColor(m_hDCInt, m_acrFGColors[iColor]) ;
    m_uColorIndex = iColor ;
}


BOOL CGDIWork::CreateOutputDC(void)
{
    DbgLog((LOG_TRACE, 3, TEXT("CGDIWork::CreateOutputDC()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // Shouldn't we do a DeleteOutputDC() here??
#pragma message("We should delete the old DIBSection before creating the new")
    // DeleteOutputDC() ; -- to use DeleteOutputDC() move the Lock defn down; else deadlock!!!
    
    // If a output format is specified by downstream filter, use it; else use upstream's
    LPBITMAPINFO lpbmih = (m_lpBMIOut ? m_lpBMIOut : m_lpBMIIn) ;
    ASSERT(lpbmih->bmiHeader.biSize) ;  // just checking!!!
    
    // Save the width and height values before changing it to the internal DIB size
    // to be created.
    LONG    lWidth = lpbmih->bmiHeader.biWidth ;
    LONG    lHeight = lpbmih->bmiHeader.biHeight ;
    
    //
    //  Hack:  This is a kind of hack that I am changing the out BMI for creating
    //         the DIBSection and changing it back.  But I think it's better than
    //         creating a new lpBMI and copying over the whole lpBMIOut data etc.
    //
    lpbmih->bmiHeader.biWidth  = m_uIntBmpWidth ;
    // Add a char height for extra line to scroll
    // -ve height for top-down DIB
    lpbmih->bmiHeader.biHeight = (DWORD)(-((int)(m_uIntBmpHeight + m_uCharHeight))) ;
    lpbmih->bmiHeader.biSizeImage = DIBSIZE(lpbmih->bmiHeader) ;
    
    m_hBmpInt = CreateDIBSection(m_hDCInt, lpbmih, DIB_RGB_COLORS, 
        (LPVOID *)&m_lpbIntBuffer, NULL, 0) ;
    if (NULL == m_hBmpInt)
    {
        DbgLog((LOG_ERROR, 0, TEXT("Failed to create DIB section for output bitmap (Error %ld)"), GetLastError())) ;
        
        // Restore the width and height values, otherwise later we won't know what hit us!!!
        lpbmih->bmiHeader.biWidth  = lWidth ;
        lpbmih->bmiHeader.biHeight = lHeight ;
        lpbmih->bmiHeader.biSizeImage = DIBSIZE(lpbmih->bmiHeader) ;
        
        return FALSE ;
    }
    
    ClearInternalBuffer() ;  // get rid of any random stuff remaining there
    m_hBmpIntOrig = (HBITMAP) SelectObject(m_hDCInt, m_hBmpInt) ;  // select DIBSection in our internal DC
    
    // Set back the saved width and height values, and size image too
    lpbmih->bmiHeader.biWidth  = lWidth ;
    lpbmih->bmiHeader.biHeight = lHeight ;
    lpbmih->bmiHeader.biSizeImage = DIBSIZE(lpbmih->bmiHeader) ;
    
    m_bDCInited = TRUE ;      // now it's all set
    m_bNewIntBuffer = TRUE ;  // new DIB section created
    
    // If given height is -ve then we set "output inverted" flag
    m_bOutputInverted = (lpbmih->bmiHeader.biHeight < 0) ;
    
    return TRUE ;
}


BOOL CGDIWork::DeleteOutputDC(void)
{
    DbgLog((LOG_TRACE, 3, TEXT("CGDIWork::DeleteOutputDC()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    if (! m_bDCInited)
        return TRUE ;
    
    // Release the DIBSection etc.
    if (m_hBmpInt)
    {
        SelectObject(m_hDCInt, m_hBmpIntOrig) ;   // first take out of our DC
        DeleteObject(m_hBmpInt) ;                 // then delete teh DIBSection
        m_hBmpInt = NULL ;                        // we don't have the bitmap anymore
        m_hBmpIntOrig = NULL ;                    // orig bitmap is now selected
    }
    
    m_lpbIntBuffer = NULL ;
    m_bDCInited = FALSE ;
    
    return TRUE ;   // success!!
}


void CGDIWork::DrawLeadingSpace(int iLine, int iCol)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::DrawLeadingSpace(%d, %d)"), iLine, iCol)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (! m_bOpaque )  // doesn't matter for transparent background
        return ;
    
    // opaque the leading space's position and also the next char's
    RECT    Rect ;
    Rect.left = iCol * m_uCharWidth ;
    Rect.top = iLine * m_uCharHeight ;
    Rect.right = Rect.left + 2 * m_uCharWidth ;
    Rect.bottom = Rect.top + m_uCharHeight ;
    UINT16   chSpace = MAKECCCHAR(0, ' ') ;
    
    ChangeFont(FALSE, FALSE) ; // no UL or italics
    if (! ExtTextOutW(m_hDCInt, iCol * m_uCharWidth, iLine * m_uCharHeight,
                ETO_OPAQUE, &Rect, &chSpace, 1, NULL /* lpDX */) )
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: ExtTextOutW() failed drawing leading space!!!"))) ;

    m_bOutDIBClear = FALSE ;    // we have put the leading space at least

    // Now get back to prev font (underline and italics)
    ChangeFont(m_ccLast.IsItalicized(), m_ccLast.IsUnderLined()) ;
}

void CGDIWork::WriteChar(int iLine, int iCol, CCaptionChar& cc)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::WriteChar(%d, %d, %u)"), iLine, iCol, cc.GetChar())) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    UINT16  wActual ;
    UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;
    RECT    Rect ;
    UINT    uColor = cc.GetColor() ;
    UINT    uEffect = cc.GetEffect() ;
    
    // Make sure the internal DIB section is still valid
    if (! m_bDCInited )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Internal output DIB section is not valid anymore"))) ;
        return ;
    }
    
    // Make sure we have good size font first
    if (! m_bFontSizeOK )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Font size is not right for current output window"))) ;
        return ;
    }
    
    if (cc.IsMidRowCode())  // if it's a mid row code
        wActual = MAKECCCHAR(0, ' ') ;   // use space
    else                    // otherwise
        wActual = cc.GetChar() ; // use the char itself
    if (0 == wActual)   // this one is supposed to be skipped -- I am not sure
    {
        DbgLog((LOG_TRACE, 1, TEXT("Should we skip NULL char at (%d, %d)??"), iLine, iCol)) ;
        // return ;
    }
    
    if (uColor != m_ccLast.GetColor())
        ChangeColor(uColor) ;
    if (uEffect != m_ccLast.GetEffect())
        ChangeFont(cc.IsItalicized(), cc.IsUnderLined()) ;
    if (m_bOpaque)  // opaque the next char's position
    {
        Rect.left = (iCol+1) * m_uCharWidth ;
        Rect.top = iLine * m_uCharHeight ;
        Rect.right = Rect.left + m_uCharWidth ;
        Rect.bottom = Rect.top + m_uCharHeight ;
    }
    if (! ExtTextOutW(m_hDCInt, iCol * m_uCharWidth, iLine * m_uCharHeight,
                    m_bOpaque ? ETO_OPAQUE : 0, 
                    m_bOpaque ? &Rect : NULL,
                    &wActual, 1, NULL /* lpDX */) )
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: ExtTextOutW() failed drawing caption char!!!"))) ;

    if (0 != wActual)  // if this char is non-null
        m_bOutDIBClear = FALSE ;    // we have put one char at least

#ifdef TEST
    BitBlt(m_hDCTest, 0, 0, 600, 120, m_hDCInt, 0, 0, SRCCOPY) ; // 300 x 65
#endif // TEST
    
    m_ccLast = cc ;
    
    m_bBitmapDirty = TRUE ;
}


void CGDIWork::CopyLine(int iSrcLine, int iSrcOffset,
                        int iDestLine, int iDestOffset, UINT uNumScanLines)
                        // uNumScanLines param has a default value of 0xff.
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::CopyLine(%d, %d, %d, %d, %u)"),
            iSrcLine, iSrcOffset, iDestLine, iDestOffset, uNumScanLines)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    LPBYTE  lpSrc ;
    LPBYTE  lpDest ;
    int     iDestInc ;
    
    // Make sure the internal DIB section is still valid
    if (! m_bDCInited )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Internal output DIB section is not valid anymore"))) ;
        return ;
    }
    
    // Make sure we have good size font
    if (! m_bFontSizeOK )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Font size is not right for current output window"))) ;
        return ;
    }
    
    ASSERT(m_lpbOutBuffer) ;  // so that we catch it in debug builds
    if (NULL == m_lpbOutBuffer)
    {
        DbgLog((LOG_ERROR, 0, TEXT("How could we be drawing lines when output buffer is NOT given?"))) ;
        return ;
    }
    
    int  iLineStart ;
    lpSrc = m_lpbIntBuffer +
            (iSrcLine * m_uCharHeight * m_uBytesPerSrcScanLine +
            (iSrcLine == 0 ? // skip scroll lines only for 1st line
            iSrcOffset * m_uBytesPerSrcScanLine : 0)) ;
    if (IsOutputInverted())   // OverlayMixer case
    {
        iLineStart = ((iDestLine - 1) * m_uCharHeight + m_uVertOffset) ;
        lpDest = m_lpbOutBuffer +                        // buffer start
                 (iLineStart + iDestOffset) * m_uBytesPerDestScanLine +  // # scanlines
                 m_uHorzOffset * m_uBytesPerPixel ;      // leading pixels on the scanline 
        iDestInc = m_uBytesPerDestScanLine ;
    }
    else                     // Video Renderer case
    {
        iLineStart = (MAX_CAPTION_ROWS - iDestLine + 1) * m_uCharHeight - iDestOffset + m_uVertOffset ;
        lpDest = m_lpbOutBuffer +                        // buffer start
                 iLineStart * m_uBytesPerDestScanLine +  // # scanlines * pixels/scanline
                 m_uHorzOffset * m_uBytesPerPixel ;      // leading pixels on the scanline
        iDestInc = -((int) m_uBytesPerDestScanLine) ;
    }
    
    // We don't want to copy more than a text line's height of
    // scan lines.  But we can copy less if we are asked to.
    UINT uMax = min(uNumScanLines, m_uCharHeight) ;
    for (UINT u = iSrcOffset ; u < uMax ; u++)
    {
        // Before we copy the bits, lets just make sure the buffer isn't bad
        if (IsBadWritePtr(lpDest, m_uBytesPerSrcScanLine))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Bad output buffer. Skip copying the text line."))) ;
            ASSERT(!"Bad output buffer") ;
            break ;
        }
    
        CopyMemory(lpDest, lpSrc, m_uBytesPerSrcScanLine) ;
        lpSrc  += m_uBytesPerSrcScanLine ;
        lpDest += iDestInc ;
    }
}


void CGDIWork::GetOutputLines(int iDestLine, RECT *prectLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetOutputLines(%d, 0x%lx)"), iDestLine, prectLine)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    if (IsBadWritePtr(prectLine, sizeof(*prectLine)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: prectOut is a bad pointer!!!"))) ;
        return ;
    }

    SetRect(prectLine, 0 /*m_uHorzOffset */, 0,   // to stop BPC's CC wobbling
        m_uHorzOffset + m_uCharWidth * (MAX_CAPTION_COLUMNS+2), 0) ;
    int  iLineStart ;
    if (IsOutputInverted())   // OverlayMixer case
    {
        iLineStart = ((iDestLine - 1) * m_uCharHeight + m_uVertOffset) ;
        prectLine->top    = iLineStart ;
        prectLine->bottom = iLineStart + m_uCharHeight ;
    }
    else                     // Video Renderer case
    {
        // I am not sure about the rect top/bottom thing here.
        prectLine->top    = (iDestLine - 1) * m_uCharHeight + m_uVertOffset ;
        prectLine->bottom = prectLine->top + m_uCharHeight ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21decod.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21Decod.h: Line 21 Decoder engine base class code
//

#ifndef _INC_L21DECOD_H
#define _INC_L21DECOD_H


//
//  Forward declarations
//
class CLine21DataDecoder ;


//
//  Input data type ID (rather than GUID) for internal functioning
//
typedef enum _AM_LINE21_CCSUBTYPEID {
    AM_L21_CCSUBTYPEID_Invalid = 0,
    AM_L21_CCSUBTYPEID_BytePair,
    AM_L21_CCSUBTYPEID_GOPPacket,
    AM_L21_CCSUBTYPEID_VBIRawData
} AM_LINE21_CCSUBTYPEID, *PAM_LINE21_CCSUBTYPEID ;

//
//  A set of values indicating what type of control code was received
//
#define L21_CONTROLCODE_INVALID     0
#define L21_CONTROLCODE_PAC         1
#define L21_CONTROLCODE_MIDROW      2
#define L21_CONTROLCODE_MISCCONTROL 3


//
//  CLine21DataDecoder: class for decoding from byte pair and output to bitmap
//
class CLine21DataDecoder {
public:  // public methods for CLine21Filter to call
    CLine21DataDecoder::CLine21DataDecoder(
                            AM_LINE21_CCSTYLE eStyle = AM_L21_CCSTYLE_None,
                            AM_LINE21_CCSTATE eState = AM_L21_CCSTATE_Off,
                            AM_LINE21_CCSERVICE eService = AM_L21_CCSERVICE_None) ;
    ~CLine21DataDecoder(void) ;
    
    void InitState(void) ;
    BOOL InitCaptionBuffer(void) ;  // all buffers
    BOOL InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle) ; // only needed buffer(s)
    BOOL DecodeBytePair(BYTE chFirst, BYTE chSecond) ;
    BOOL UpdateCaptionOutput(void) ;
    inline BOOL IsOutputReady(void)  { return m_GDIWork.IsBitmapDirty() ; } ;
    void CopyOutputDIB(void) ;
    void CompleteScrolling(void) ;
    inline AM_LINE21_CCSTYLE GetCaptionStyle()   { return m_eCCStyle ; } ;
    AM_LINE21_CCSTYLE SetCaptionStyle(AM_LINE21_CCSTYLE eStyle) ;
    inline BOOL IsScrolling(void)   { return m_bScrolling ; } ;
    void FlushInternalStates(void) ;
    inline BOOL IsOutDIBClear(void) {
        return m_GDIWork.IsOutDIBClear() ;
    } ;
    inline BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) {
        return m_GDIWork.IsSizeOK(lpbmih) ;
    } ;

    // methods to allow the filter to do get/set using the 
    // IAMLine21Decoder interface
    inline AM_LINE21_CCLEVEL GetDecoderLevel(void)    { return m_eLevel ; } ;
    inline AM_LINE21_CCSERVICE GetCurrentService(void)  { return m_eUserService ; } ;
    BOOL SetCurrentService(AM_LINE21_CCSERVICE Service) ; 
    inline AM_LINE21_CCSTATE GetServiceState(void)    { return m_eState ; } ;
    BOOL SetServiceState(AM_LINE21_CCSTATE eState) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.GetDefaultFormatInfo(lpbmi, pdwSize) ;
    } ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.GetOutputFormat(lpbmih) ;
    } ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.GetOutputOutFormat(lpbmih) ;
    } ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.SetOutputOutFormat(lpbmi) ;
    } ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.SetOutputInFormat(lpbmi) ;
    } ;
    inline void GetBackgroundColor(DWORD *pdwPhysColor) { 
        m_GDIWork.GetBackgroundColor(pdwPhysColor) ;
    } ;
    inline BOOL SetBackgroundColor(DWORD dwPhysColor) {
        return m_GDIWork.SetBackgroundColor(dwPhysColor) ;
    } ;
    inline BOOL GetRedrawAlways() { return m_bRedrawAlways ; } ;
    inline void SetRedrawAlways(BOOL Option) { m_bRedrawAlways = !!Option ; } ;
    inline AM_LINE21_DRAWBGMODE GetDrawBackgroundMode(void) { 
        return (m_GDIWork.GetBackgroundOpaque() ?
                AM_L21_DRAWBGMODE_Opaque : AM_L21_DRAWBGMODE_Transparent) ;
    } ;
    inline void SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) { 
        m_GDIWork.SetBackgroundOpaque(AM_L21_DRAWBGMODE_Opaque == Mode) ;
    } ;
    
    // methods to pass values between the CLine21DecFilter class and CGDIWork class
    BOOL CreateOutputDC(void)  {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.CreateOutputDC() ;
    } ;
    void DeleteOutputDC(void)  { 
        CAutoLock  Lock(&m_csL21Dec) ;
        m_GDIWork.DeleteOutputDC() ;
    } ;
    
    // some general methods to communicate with the container class
    inline void SetOutputBuffer(LPBYTE lpbOut) {
        m_GDIWork.SetOutputBuffer(lpbOut) ;
    } ;
    inline void FillOutputBuffer(void) {
        m_GDIWork.FillOutputBuffer() ;
    } ;
    inline void InitColorNLastChar(void) {
        m_GDIWork.InitColorNLastChar() ;
    } ;
    void CalcOutputRect(RECT *prectOut) ;
    inline DWORD GetPaletteForFormat(LPBITMAPINFOHEADER lpbmih) {
        return m_GDIWork.GetPaletteForFormat(lpbmih) ;
    } ;
    
private:   // private helper methods
    //
    //  The following methods are for implementing the actual decoding
    //  algorithm.
    //
    BOOL IsMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsPAC(BYTE chFirst, BYTE chSecond) ;
    BOOL IsMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    UINT CheckControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL ValidParity(BYTE ch) ;
    BOOL IsStandardChar(BYTE ch)  { return (ch >= 0x20 && ch <= 0x7F) ; } ;
    BOOL ProcessControlCode(UINT uCodeType, BYTE chFirst, BYTE chSecond) ;
    BOOL DecodePAC(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL LineFromRow(UINT uCurrRow) ;
    BOOL ProcessPrintableChar(BYTE ch) ;
    BOOL ProcessSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRCL(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleBS(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleDER(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRU(BYTE chFirst, BYTE chSecond, int iLines) ;
    BOOL HandleFON(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRDC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRTD(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEDM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleCR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleENM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEOC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTO(BYTE chFirst, BYTE chSecond, int iCols) ;
    
    void SetNewLinePosition(int iLines, UINT uCurrRow) ;
    BOOL PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode = FALSE) ; // put char in buffer (& MRC too)
    BOOL IsEmptyLine(int iLine) ;   // Is the line empty (no non-Xparent chars)?
    BOOL RemoveCharsInBuffer(int iNumChars) ;  // removes n chars to the right of current col
    BOOL PrintTextToBitmap(void) ;  // creates bitmap image of the caption text
    void UpdateBoundingRect(RECT *prectOut, RECT *prectLine) ;
    
    //
    //  The following methods are defined to bring uniformity in coding of
    //  the algorithm irrespective of any caption style being used.
    //
    CCaptionBuffer * GetDispBuffer(void) ;    // display buffer: mainly for Pop-On style
    void ClearBuffer(void) ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    void GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc) ;
    CCaptionChar * GetCaptionCharPtr(UINT8 uLine, UINT8 uCol) ;
    void SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                        const CCaptionChar& cc) ;
    int  GetMaxLines(void) ;
    void SetMaxLines(UINT uLines) ;
    int  GetNumLines(void) ;
    void SetNumLines(UINT uLines) ;
    int  GetNumCols(int iLines) ;
    int  GetRow(UINT uLine) ;
    int  GetCurrLine(void) ;
    int  GetCurrCol(void) ;
    void SetCurrLine(UINT8 uLine) ;
    void SetCurrCol(UINT8 uCol) ;
    int  GetStartRow(UINT8 uLine) ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetStartRow(UINT8 uLine, UINT8 uRow) ;
    void SetRowIndex(UINT8 uLine, UINT8 uRow) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    int  IncNumChars(UINT uLine, UINT uNumChars) ;
    int  DecNumChars(UINT uLine, UINT uNumChars) ;
    int  IncNumLines(UINT uLines) ;
    int  DecNumLines(UINT uLines) ;
    void MoveCaptionChars(int uLine, int iNum) ;
    
    BOOL IsCapBufferDirty(void) ;
    BOOL IsRedrawLine(UINT8 uLine) ;
    BOOL IsRedrawAll(void) ;
    void SetCapBufferDirty(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    
    void SetScrollState(BOOL bState) ;
    int  IncScrollStartLine(int iCharHeight) ;
    void SkipScrolling(void) ;   // CR came while scrolling; skip current one
    void MoveCaptionLinesUp(void) ;  // remove top line, move other lines up
    void RelocateRollUp(UINT uBaseRow) ; // move roll-up caption to given base row

    //
    //  Common buffers used for all CC modes
    //
    CCaptionBuffer * GetCaptionBuffer(void) ;
    CCaptionBuffer * GetDisplayBuffer(void) ;
    inline int  GetBufferIndex(void)  { return m_iBuffIndex ; } ;
    inline void SetBufferIndex(int iIndex) ;
    inline void SwapBuffers(void)  { m_iBuffIndex = 1 - m_iBuffIndex ; } ;
    
private:  // private data
    CCritSec            m_csL21Dec ;   // to serialize operations on line21 decoder object

    CCaptionBuffer *    m_pCurrBuff ;
    
    // Actual caption buffer with text and attribs/positions/banks etc
    CCaptionBuffer      m_aCCData[2] ;
    int                 m_iBuffIndex ; // index for current CC data buffer
    
    CGDIWork            m_GDIWork ;    // GDI details class as a member

    UINT                m_uFieldNum ;  // Field number: 1 or 2 (top/bottom)
    
    // What style caption is being displayed now and was used last
    AM_LINE21_CCSTYLE   m_eCCStyle ;
    AM_LINE21_CCSTYLE   m_eLastCCStyle ;
    
    // Is Line 21 decoding On/Off
    AM_LINE21_CCSTATE   m_eState ;
    
    // Which service is currently being viewed by the user
    AM_LINE21_CCSERVICE m_eUserService ;  // one of C1/C2/T1/T2/XDS
    
    // Decoder is standard or enhanced
    AM_LINE21_CCLEVEL   m_eLevel ;
    
    //
    //  Some internal states during decoding
    //
    AM_LINE21_CCSERVICE m_eDataService ; // service indicated by received bytes
    UINT                m_uCurrFGEffect ;  // FG effect of current position
    UINT                m_uCurrFGColor ;   // FG color of current position
    
    BOOL                m_bExpectRepeat ;  // should we expect a repeat of last pair?
    BYTE                m_chLastByte1 ;    // the 1st second byte processed
    BYTE                m_chLastByte2 ;    // the 2nd second byte processed
    
    BOOL                m_bScrolling ;     // are we in the middle of scrolling up?
    int                 m_iScrollStartLine ; // current scan line to be scrolled off
    
    BOOL                m_bRedrawAlways ;  // client wants a total redraw per sample
    
#ifdef PERF
    int          m_idTxt2Bmp ;
    int          m_idBmp2Out ;
    int          m_idScroll ;
#endif // PERF
} ;


//
//  Some misc. constant definitions
//
#define INVALID_CHANNEL     -1

//
//  Some macros to hide some gory details
//
#define ISSUBTYPEVALID(ID) (AM_L21_CCSUBTYPEID_BytePair   == ID || \
                            AM_L21_CCSUBTYPEID_GOPPacket  == ID || \
                            AM_L21_CCSUBTYPEID_VBIRawData == ID)

#endif _INC_L21DECOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec\l21decod.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Decoder Logic part
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"


//
//  CLine21DataDecoder class constructor: mainly init of members
//
CLine21DataDecoder::CLine21DataDecoder(AM_LINE21_CCSTYLE eStyle     /* = AM_L21_CCSTYLE_None */,
                                       AM_LINE21_CCSTATE eState     /* = AM_L21_CCSTATE_Off  */,
                                       AM_LINE21_CCSERVICE eService /* = AM_L21_CCSERVICE_None */)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CLine21DataDecoder()"))) ;
    
#ifdef PERF
    m_idTxt2Bmp = MSR_REGISTER(TEXT("L21DPerf - Text to CC bmp")) ;
    m_idBmp2Out = MSR_REGISTER(TEXT("L21DPerf - Bmp to Output")) ;
    m_idScroll  = MSR_REGISTER(TEXT("L21DPerf - Line Scroll")) ;
#endif // PERF

    InitState() ;
    
    // We separately set some of the passed in values
    SetCaptionStyle(eStyle) ;
}


CLine21DataDecoder::~CLine21DataDecoder(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::~CLine21DataDecoder()"))) ;
    
    // make sure the internal bitmap etc has been released and
    // allocated memory or other resources are not left un-released.
}

//
// Decoder state initializer; will be used also in filter's CompleteConnect()
//
void CLine21DataDecoder::InitState(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitState()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_pCurrBuff = NULL ;
    
    m_uFieldNum = 1 ;   // field 1 by default
    
    InitCaptionBuffer() ;  // Init the CC data buffers and index

    SetCaptionStyle(AM_L21_CCSTYLE_None) ;
    m_eLastCCStyle = AM_L21_CCSTYLE_None ;
    m_eState = AM_L21_CCSTATE_On ;   // should be _Off by default or eState
    m_eLevel = AM_L21_CCLEVEL_TC2 ;
    m_eUserService = AM_L21_CCSERVICE_Caption1 ;   // _None by default or eService
    
    m_eDataService = AM_L21_CCSERVICE_None ;
    
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    m_uCurrFGEffect = 0 ;
    
    m_bExpectRepeat = FALSE ;
    m_chLastByte1 = 0 ;
    m_chLastByte2 = 0 ;
    
    m_bScrolling = FALSE ;
    m_iScrollStartLine = 0 ;
    
    m_bRedrawAlways = FALSE ;  // someone has to be too picky/weird to do it!!
    // m_bCapBufferDirty = FALSE ;
    
    //
    // We should also reset the font stuff for the CGDIWork class,
    // recalculate the char width and height, internal bmp width & height
    // etc.
    //
    m_GDIWork.InitFont() ;
}


void CLine21DataDecoder::FlushInternalStates(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::FlushInternalStates()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    InitCaptionBuffer(m_eCCStyle) ;    // clear caption buffer
    SetRedrawAll(TRUE) ;      // redraw (no) caption on next Receive()
    SetScrollState(FALSE) ;   // turn off scrolling, just to be sure
    SetCaptionStyle(AM_L21_CCSTYLE_None) ;
    m_eLastCCStyle = AM_L21_CCSTYLE_None ;
    
    m_GDIWork.ClearInternalBuffer() ;  // clear internal DIB section
    m_GDIWork.InitColorNLastChar() ;   // reset color etc.
    m_GDIWork.InitFont() ;             // get back to standard font
}


BOOL CLine21DataDecoder::SetServiceState(AM_LINE21_CCSTATE eState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetServiceState(%lu)"), eState)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eState == m_eState)  // no change of state
        return FALSE ;       // no refresh to be forced
    
    m_eState = eState ;  // save the state for future decoding
    
    //
    // When service is turned off, we must clear the caption buffer(s) and
    // the internal DIB section so that old captions are not shown anymore.
    //
    if (AM_L21_CCSTATE_Off == m_eState)
    {
        FlushInternalStates() ;
        return TRUE ;       // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


BOOL CLine21DataDecoder::SetCurrentService(AM_LINE21_CCSERVICE eService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCurrentService(%lu)"), eService)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eService == m_eUserService)  // no change of service
        return FALSE ;               // no refresh to be forced
    
    m_eUserService = eService ;   // save the service the user wants
    
    //
    // When service "none" is selected (kind of "turn it off"), we must clear the 
    // caption buffer(s) and the internal DIB section so that old captions are 
    // not shown anymore.
    //
    if (AM_L21_CCSERVICE_None == m_eUserService)
    {
        FlushInternalStates() ;
        return TRUE ;       // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


//
//  Actual caption byte pair decoding algorithm
//
BOOL CLine21DataDecoder::DecodeBytePair(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeBytePair(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (AM_L21_CCSTATE_Off == m_eState)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Line21 data decoding turned off"))) ;
        return FALSE ;  // we actually didn't decode / generate anything
    }
    
    UINT uCodeType = CheckControlCode(chFirst, chSecond) ;
    if (L21_CONTROLCODE_INVALID != uCodeType)
    {
        // It's a control code (PAC / Mid row code / misc control code)
        return ProcessControlCode(uCodeType, chFirst, chSecond) ;
    }
    else if (IsSpecialChar(chFirst, chSecond))
    {
        // It's a special char represented by the second char
        return ProcessSpecialChar(chFirst, chSecond) ;
    }
    else
    {
        // If the 1st byte is in [0, F] then ignore 1st byte and print 2nd byte
        // as just a printable char
        BOOL  bResult = FALSE ;
        if (! ((chFirst &0x7F) >= 0x0 && (chFirst & 0x7F) <= 0xF) )
        {
            if (! ProcessPrintableChar(chFirst) )
                return FALSE ;
            bResult = TRUE ;
        }
        // If one of the two bytes decode right, we take it as a success
        bResult |= ProcessPrintableChar(chSecond) ;
        m_bExpectRepeat = FALSE ;  // turn it off now
        return bResult ;
    }
}


BOOL CLine21DataDecoder::UpdateCaptionOutput(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::UpdateCaptionOutput()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_eCCStyle != AM_L21_CCSTYLE_PopOn  &&  // Pop On style draws only on EOC
        IsCapBufferDirty())                     // otherwise draw when dirty
    {
        PrintTextToBitmap() ;  // check return value? Naah!!
        return TRUE ;          // caption updated
    }
    return FALSE ;  // no caption update
}


BOOL CLine21DataDecoder::IsPAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsPAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with control code list
    if ((0x10 <= chFirst  && 0x17 >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    if ((0x18 <= chFirst  && 0x1F >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::IsMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // first match with TO1 -> TO3 codes
    if ((0x21 <= chSecond && 0x23 >= chSecond)  &&
        (0x17 == chFirst  ||  0x1F == chFirst))
        return TRUE ;
    
    // Now match with the other misc control code
    if ((0x14 == chFirst  ||  0x15 == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x1C == chFirst  ||  0x1D == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;

    return FALSE ;
}


BOOL CLine21DataDecoder::IsMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // Now match with the mid row code list
    if ((0x11 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x19 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


UINT CLine21DataDecoder::CheckControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::CheckControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (IsPAC(chFirst, chSecond))
        return L21_CONTROLCODE_PAC ;
    
    if (IsMidRowCode(chFirst, chSecond))
        return L21_CONTROLCODE_MIDROW ;
    
    if (IsMiscControlCode(chFirst, chSecond))
        return L21_CONTROLCODE_MISCCONTROL ;
    
    DbgLog((LOG_TRACE, 3, TEXT("Not a control code"))) ;
    return L21_CONTROLCODE_INVALID ;
}


BOOL CLine21DataDecoder::IsSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Strip the parity bit before determining the service channel
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with special char list
    if (0x11 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    if (0x19 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::ValidParity(BYTE ch)
{
#if 1
    ch ^= ch >> 4 ;
    ch ^= ch >> 2 ;
    return (0 != (0x01 & (ch ^ (ch >> 1)))) ;
#else
    return TRUE ;
#endif
}


void CLine21DataDecoder::RelocateRollUp(UINT uBaseRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::RelocateRollUp(%u)"), uBaseRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
        return ;
    
    int  iMaxLines = GetMaxLines() ;
    int  iNumLines = GetNumLines() ;
    int  iMax ;
    if (m_bScrolling)  // during scrolling go for last but 1 line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d during scrolling"), uBaseRow)) ;
        if (iNumLines > iMaxLines)
        {
            DbgLog((LOG_TRACE, 3, TEXT("%d lines while max is %d"), iNumLines, iMaxLines)) ;
            iNumLines-- ;  // we don't set the row for the "not-yet-in" line
        }
        iMax = min(iNumLines, iMaxLines) ;
    }
    else               // otherwise go for the last line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d (not scrolling)"), uBaseRow)) ;
        iMax = min(iNumLines, iMaxLines) ;
    }
    for (int i = 0 ; i < iMax ; i++)
    {
        SetStartRow((UINT8)i, (UINT8)(uBaseRow - (iMax - 1 - i))) ;
    }
}


BOOL CLine21DataDecoder::LineFromRow(UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::LineFromRow(%u)"), uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iLines ;
    
    // If we are in Roll-up mode then we shouldn't try to go through 
    // all the hassle of creating a new line etc. -- it's just a PAC 
    // to specify starting position and/or color; so just do that.
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // If the indentation PAC places cursor on an existing row
        
        int   iIndex ;
        iIndex = GetRowIndex((UINT8)uCurrRow) ;
        if (-1 == iIndex)    // some error encountered
            return FALSE ;   // fail decoding
        
        if (0 == iIndex)  // landed in a new row
        {
            iLines = GetNumLines() ;
            SetNewLinePosition(iLines, uCurrRow) ;
            SetRedrawLine((UINT8)iLines, TRUE) ;  // initially set line to be redrawn
        }
        else  // landed in an existing row
        {
            SetCurrLine(iIndex-1) ;  // -1 because row index map is 1-based (it has to be),
            // but the caption line index etc are all 0-based.
        }
        
        // We have to put the cursor at the 1st column
        SetCurrCol(0) ;   // no matter which line it is, go to 1st col (i.e, 0)
    }
    else  // in Roll-up mode
    {
        // If necessary, move entire caption so that the specified row 
        // becomes the new base row.
        iLines = GetNumLines() ;
        if (1 == iLines)  // if this is for the first line
        {
            SetStartRow(0, (UINT8)uCurrRow) ;  // also set the base row to start with
        }
        else              // otherwise just move captions to the specified row
        {
            RelocateRollUp(uCurrRow) ;
            if (GetStartRow(iLines-1) == (int)uCurrRow)  // last line is at current row
                SetScrollState(FALSE) ;             // we should not scroll
            SetCapBufferDirty(TRUE) ; // caption buffer is dirty in a sense
            SetRedrawAll(TRUE) ;      // must be redrawn to show new position
        }
        
        DbgLog((LOG_TRACE, 1, TEXT("Base row for %d lines moved to %d"), iLines, uCurrRow)) ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodePAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodePAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int         iGroup ;
    UINT        uDiff ;
    UINT        uCurrRow ;
    UINT        uCurrCol ;
    UINT        uCol ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodePAC(): No CC style defined yet. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodePAC(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Turn off parity checking here
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now locate which of the two groups does 2nd byte belong, if at all!!
    if (chSecond >= 0x40 && chSecond <= 0x5F)
    {
        iGroup = 0 ;
        uDiff = chSecond - 0x40 ;
    }
    else if (chSecond >= 0x60 && chSecond <= 0x7F)
    {
        iGroup = 1 ;
        uDiff = chSecond - 0x60 ;
    }
    else   // invalid 2nd byte for PAC
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte for PAC"))) ;
        return FALSE ;
    }
    
    // Valid 2nd byte; now decide based on the 1st byte
    static UINT8 auPACtoRowMap[0x10] = {
        11,  1,  3, 12, 14,  5,  7,  9, 11,  1,  3, 12, 14,  5,  7,  9  // row
     // 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F  // PAC byte 1
    } ;
    
    if (chFirst >= 0x10  &&  chFirst <= 0x1F)
    {
        // the row number is 1 more if the 2nd byte is in the 60-7F group
        uCurrRow = auPACtoRowMap[chFirst - 0x10] + iGroup  ;
        
        // Now see what happens with the new row specified, if any, in the PAC
        LineFromRow(uCurrRow) ;
    }
    else
    {
        DbgLog((LOG_TRACE, 2, TEXT("Invalid mid-row code in 1st byte"))) ;
        return FALSE ;
    }
    
    // some final decisions...
    m_uCurrFGEffect = 0 ;  // clear all effects as a result of PAC processing
    if (uDiff <= 0x0D)  // color (and underline) spec
        m_uCurrFGColor = uDiff >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
    else if (uDiff <= 0x0F)  // 0E, 0F == italics (and underline) spec
    {
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;  // 0
    }
    else  // 10 -> 1F == indent (and underline) spec (no other way)
    {
        // 50 (70) => 0, 52 (72) => 4 etc.
        // last bit of 2nd char determines underline or not
        uCurrCol = ((uDiff - 0x10) & 0xFE) << 1 ;
        if (uCurrCol >= MAX_CAPTION_COLUMNS)
            uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
        
            /*
            int  iCurrLine = GetCurrLine() ;
            if (0 == GetNumCols(iCurrLine)) // if it's a tab indent on clean line
            {
            SetStartCol(iCurrLine, uCurrCol) ; // set start column as spec-ed
            SetCurrCol(0) ;             // and current col to 0
            }
            else if ((uCol = GetStartCol(iCurrLine)) > uCurrCol)  // existing line
            {
            // insert null spaces before currently existing chars as filler
            // (that adjusts the number of chars value too)
            MoveCaptionChars(iCurrLine, uCol - uCurrCol) ;
            SetStartCol(iCurrLine, uCurrCol) ;
            SetCurrCol(0) ;
            }
            else
            SetCurrCol(uCurrCol) ;
        */
        SetCurrCol((UINT8)uCurrCol) ;
        
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    }
    
    // at last check underline bit
    if (uDiff & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    
    return TRUE ;   // done at last!!!
}


BOOL CLine21DataDecoder::DecodeMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BYTE        uValue ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodeMidRowCode(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
    
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodeMidRowCode(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (chSecond < 0x20  ||  chSecond > 0x2F)
    {
        DbgLog((LOG_TRACE, 2, TEXT("Invalid mid-row code in 2nd byte"))) ;
        return FALSE ;
    }
    uValue = chSecond - 0x20 ;
    if (uValue & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    if (chSecond < 0x2E)   // only color specs
    {
        m_uCurrFGColor = uValue >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_ITALICS ;  // color turns off italics
    }
    else   // 2nd byte is 0x2E or 0x2F, i.e, italics specified
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
    
    // finally, mid-row code introduces a blank space
    PutCharInBuffer(0x20, TRUE) ;  // mark it as MRC too
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodeMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BOOL        bResult ;
    
    switch (chFirst)
    {
        // case 0x15:
        // case 0x1D:
        //     m_uField = 2 ;   // the data is coming in Field 2
        
    case 0x14:      // misc control code -- channel 1
    case 0x1C:      // ditto -- channel 2
        switch (chSecond)
        {
        case 0x20:   // RCL: Resume Caption Loading
            bResult = HandleRCL(chFirst, chSecond) ;
            break ;
            
        case 0x21:   // BS:  Backspace
            bResult = HandleBS(chFirst, chSecond) ;
            break ;
            
        case 0x22:   // AOF: reserved
        case 0x23:   // AOF: reserved
            DbgLog((LOG_ERROR, 2, TEXT("AOF/AON as Misc ctrl code"))) ;
            return TRUE ;  // just ignore it
            
        case 0x24:   // DER: Delete to End of Row
            bResult = HandleDER(chFirst, chSecond) ;
            break ;
            
        case 0x25:   // RU2: Roll-Up Captions - 2 rows
        case 0x26:   // RU3: Roll-Up Captions - 3 rows
        case 0x27:   // RU4: Roll-Up Captions - 4 rows
            bResult = HandleRU(chFirst, chSecond, 2 + chSecond - 0x25) ;
            break ;
            
        case 0x28:   // FON: Flash On
            bResult = HandleFON(chFirst, chSecond) ;
            break ;
            
        case 0x29:   // RDC: Resume Direct Captioning
            bResult = HandleRDC(chFirst, chSecond) ;
            break ;
            
        case 0x2A:   // TR:  Text Restart
            bResult = HandleTR(chFirst, chSecond) ;
            break ;
            
        case 0x2B:   // RTD: Resume Text Display
            bResult = HandleRTD(chFirst, chSecond) ;
            break ;
            
        case 0x2C:   // EDM: Erase Displayed Memory
            bResult = HandleEDM(chFirst, chSecond) ;
            break ;
            
        case 0x2D:   // CR:  Carriage Return
            bResult = HandleCR(chFirst, chSecond) ;
            break ;
            
        case 0x2E:   // ENM: Erase Non-displayed Memory
            bResult = HandleENM(chFirst, chSecond) ;
            break ;
            
        case 0x2F:   // EOC: End of Caption (flip memories)
            bResult = HandleEOC(chFirst, chSecond) ;
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                chSecond, chFirst)) ;
            return FALSE ;
        }  // end of switch (chSecond)
        break ;
        
        case 0x17:      // misc control code -- channel 1
        case 0x1F:      // ditto -- channel 2
            switch (chSecond)
            {
            case 0x21:   // TO1: Tab Offset 1 column
            case 0x22:   // TO2: Tab Offset 2 columns
            case 0x23:   // TO3: Tab Offset 3 columns
                bResult = HandleTO(chFirst, chSecond, 1 + chSecond - 0x21) ;
                break ;
                
            default:
                DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                    chSecond, chFirst)) ;
                return FALSE ;
            }  // end of switch (chSecond)
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 1st byte for Misc ctrl code"))) ;
            return FALSE ;
    }  // end of switch (chFirst)
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
        DbgLog((LOG_TRACE, 2, TEXT("No CC style defined yet."))) ;
    else
        DbgLog((LOG_TRACE, 3, TEXT("CC style defined now (%d)."), m_eCCStyle)) ;
    
    return bResult ;  // return result of handling above
}


BOOL CLine21DataDecoder::ProcessSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Table of special char Unicode values for Truetype font (Lucida Console)
    static UINT16 awSplCharTT[] = {
     0x00ae,    0x00b0,    0x00bd,    0x00bf,    0x2122,    0x00a2,    0x00a3,    0x266b,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x00e0,    0x0000,    0x00e8,    0x00e2,    0x00ea,    0x00ee,    0x00f4,    0x00fb } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    // Table of special char for non-Truetype font (Terminal) [alternate chars]
    static UINT16 awSplCharNonTT[] = {
     0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x0041,    0x0000,    0x0045,    0x0041,    0x0045,    0x0049,    0x004f,    0x0055 } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("ProcessSpecialChar(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
                
    if (m_eDataService != m_eUserService)
    {           
        DbgLog((LOG_TRACE, 1, TEXT("Special char for diff channel (%d)"), (int)m_eDataService)) ;
        return TRUE ;  // ??
    }
                
    // Check if it's a repeat of the last special. If so ignore it; else print it.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the spl char; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
                    
        // Otherwise we got a different spl char pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this spl char pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
                
    //  This pair of bytes may be valid. So we need to remember them to check
    //  against the next such pair for a repeat (of spl chars).
    //  BTW, we store the bytes only after the parity bit is stripped.
    m_chLastByte1 = chFirst & 0x7F ;
    m_chLastByte2 = chSecond & 0x7F ;
                
    ASSERT((chSecond & 0x7F) >= 0x30  &&  (chSecond & 0x7F) <= 0x3F) ;
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Bad parity for character <%d>"), chSecond)) ;
        ProcessPrintableChar(0x7F) ;  // put special char solid block (7F)
    }
    else
    {
        if (m_GDIWork.IsTTFont())
            PutCharInBuffer(awSplCharTT[(chSecond & 0x7F) - 0x30]) ;
        else
            PutCharInBuffer(awSplCharNonTT[(chSecond & 0x7F) - 0x30]) ;
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::ProcessControlCode(UINT uCodeType,
                                            BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
            TEXT("CLine21DataDecoder::ProcessControlCode(%u, 0x%x, 0x%x)"), 
            uCodeType, chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // Make sure that the pair has valid parity bits
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair -- ignoring pair"), chSecond)) ;
        return FALSE ;
    }
    
    BOOL  bSuccess = TRUE ;
    if (! ValidParity(chFirst) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair"), chFirst)) ;
        if (m_bExpectRepeat)  // if 2nd transmission of control code
        {
            if ((chSecond & 0x7F) == m_chLastByte2)  // we got the same 2nd byte
            {
                // most likely it's the retransmission garbled up -- ignore them
            }
            else   // different 2nd byte; just print it.
                bSuccess = ProcessPrintableChar((chSecond & 0x7F)) ;
            
            // Turn it off -- either 2nd byte matched => retransmit of control code
            //                or printed 2nd byte as a printable char
            m_bExpectRepeat = FALSE ;
        }
        else  // if 1st transmission of control code
        {
            bSuccess = ProcessPrintableChar(0x7F) && 
                ProcessPrintableChar((chSecond & 0x7F)) ;
        }
        return bSuccess ;
    }
    
    // Check if it's a repeat of the last control code. If so ignore it; else
    // set it so.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the control code; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
        
        // Otherwise we got a different control code pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this control code pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
    
    //  Looks like this pair of bytes is going to be valid and at least has
    //  valid (odd) parity bits set.  So we need to remember them to check
    //  against the next such pair for a repeat (of control codes).
    //  BTW, we store the bytes only after the parity bit is stripped.
    
    chFirst = chFirst & 0x7F ;
    chSecond = chSecond & 0x7F ;
    
    m_chLastByte1 = chFirst ;
    m_chLastByte2 = chSecond ;
    
    switch (uCodeType)
    {
    case L21_CONTROLCODE_PAC:
        return DecodePAC(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MIDROW:
        return DecodeMidRowCode(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MISCCONTROL:
        return DecodeMiscControlCode(chFirst, chSecond) ;
        
    default:
        DbgLog((LOG_TRACE, 1, TEXT("Invalid code type (%u)"), uCodeType)) ;
        return FALSE ;  // not a control code
    }
}


BOOL CLine21DataDecoder::ProcessPrintableChar(BYTE ch)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessPrintableChar(%x)"), ch)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Printable char (?) for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("ProcessPrintableChar(): No CC style defined yet. Skipping..."))) ;
        return FALSE ;
    }
    
    if (! IsStandardChar(ch & 0x7F) )
    {
        DbgLog((LOG_TRACE, 2, TEXT("Not a printable char."))) ;
        return FALSE ;
    }
    
    if (! ValidParity(ch) )  // if a printable char doesn't have valid parity
    {
        DbgLog((LOG_TRACE, 1, TEXT("Bad parity for (probably) printable char <%d>"), ch)) ;
        ch = 0x7F ;            // then replace it with 7Fh.
    }
    
    //
    // There is more twist to it than you think!!! Some special chars
    // are inside the standard char range.
    //
    BOOL  bResult = FALSE ;
    switch (ch & 0x7F)  // we only look at the parity-less bits
    {
        case 0x2A:  // lower-case a with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00e1) ;
            else   // no TT font -- use 'A' as alternate char
                bResult = PutCharInBuffer(0x0041) ;
            break ;

        case 0x5C:  // lower-case e with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00e9) ;
            else   // no TT font -- use 'E' as alternate char
                bResult = PutCharInBuffer(0x0045) ;
            break ;

        case 0x5E:  // lower-case i with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00ed) ;
            else   // no TT font -- use 'I' as alternate char
                bResult = PutCharInBuffer(0x0049) ;
            break ;

        case 0x5F:  // lower-case o with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00f3) ;
            else   // no TT font -- use 'O' as alternate char
                bResult = PutCharInBuffer(0x004f) ;
            break ;

        case 0x60:  // lower-case u with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00fa) ;
            else   // no TT font -- use 'U' as alternate char
                bResult = PutCharInBuffer(0x0055) ;
            break ;

        case 0x7B:  // lower-case c with cedilla
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00e7) ;
            else   // no TT font -- use 'C' as alternate char
                bResult = PutCharInBuffer(0x0043) ;
            break ;

        case 0x7C:  // division sign
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00f7) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        case 0x7D:  // upper-case N with tilde
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00d1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7E:  // lower-case n with tilde
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00f1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7F:  // solid block
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x2588) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        default:
            bResult = PutCharInBuffer(MAKECCCHAR(0, ch & 0x7F)) ;
            break ;
    }
    return bResult ;
}


BOOL CLine21DataDecoder::PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode /* = FALSE */)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::PutCharInBuffer(0x%x, %u)"), wChar, bMidRowCode)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Make sure we have got a PAC or MidRow code specifying our row posn
    // thereby creating a line in which the in param char is going to be put.
    if (0 == GetNumLines())
        return FALSE ;
    
    int          i ;
    CCaptionChar cc ;
    
    cc.SetChar(wChar) ;
    cc.SetColor((UINT8)m_uCurrFGColor) ;
    //
    // If this char is a mid-row code (which is shown as blank in CC) then don't
    // set the underline (mainly) or italicized/flashing attrib for it, because 
    // a space should not (or need not) be shown with such attribs.  We skip the 
    // effect bits altogether for such chars.
    //
    if (bMidRowCode)
        cc.SetEffect(0) ;
    else
        cc.SetEffect((UINT8)m_uCurrFGEffect) ;
    cc.SetMidRowCode(bMidRowCode) ;
    
    i = GetCurrLine() ;
    int  iCurrCol = GetCurrCol() ;
    SetCaptionChar((UINT8)i, (UINT8)iCurrCol, cc) ;
    //
    // If we are overwriting existing chars, the # chars doesn't increase...
    //
    int  iNumCols = GetNumCols(i) ;
    if (iCurrCol >= iNumCols)  // increment # chars by the differenece
        IncNumChars(i, iCurrCol-iNumCols+1) ;
    IncCurrCol(1) ;  // ...but current column goes up anyway.
    
    SetCapBufferDirty(TRUE) ;  // some new caption char added -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRCL(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRCL(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to PopOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn  == m_eCCStyle)    // if already in pop-on mode...
        return TRUE ;                           // ... just ignore
    
    // decodes subsequent chars for pop-on into the non-displayed buffer, 
    // but doesn't affect currently displayed caption
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ; // gets CapBuffer address based on index
    
    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleBS(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleBS(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Backspace for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Backspace for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Backspace for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    UINT  uCurrCol = GetCurrCol() ;
    if (0 == uCurrCol)   // no place to back up anymore
        return TRUE ;
    
    int  iLine = GetCurrLine() ;
    int  n ;
    if (MAX_CAPTION_COLUMNS - 1 == uCurrCol) // at last col
    {
        n = 2 ;  // erase 2 chars (?)
    }
    else   // in the middle of a row
    {
        n = 1 ;
    }
    SetCurrCol(uCurrCol - n) ;
    RemoveCharsInBuffer(n) ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleDER(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleDER(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // delete as many as you can
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRU(BYTE chFirst, BYTE chSecond, int iLines)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRU(%u, %u, %d)"), 
            chFirst, chSecond, iLines)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to RU%d of non-selected service. Skipping..."), iLines)) ;
        return TRUE ;  // ??
    }

    int iNumLines ;
    int iBaseRow ;
    
    // Check if the current style is Roll-up
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // Now set up for roll-up captioning
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_RollUp) ;
        iNumLines = IncNumLines(1) ;    // create the 1st line
        iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        SetCurrCol(0) ;                 // start at beginning of line
    }
    else  // already in Roll-up mode; don't clear buffer, re-use current base row etc.
    {
        // if the current roll-up window height is more than the one
        // newly specified then remove the extra lines from the top
        iNumLines = GetNumLines() ;
        for (int i = 0 ; i < iNumLines - iLines ; i++)
            MoveCaptionLinesUp() ;
        
        //
        // If we remove even one line from the top, we must not be scrolling
        // anymore, for now.
        //
        if (iNumLines > iLines)
            SetScrollState(FALSE) ;
        
        if (iNumLines > 0)  // if we have lines from prev roll-up sesion
        {
            // save the prev base row value as it's the default base row next
            iNumLines = min(iNumLines, iLines) ;
            iBaseRow = GetStartRow(iNumLines-1) ;
        }
        else  // we were in Roll-up mode, but a EDM came just before the RUx
        {
            // Almost starting from scratch
            iNumLines = IncNumLines(1) ;    // create the 1st line
            iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        }

        // Don't change the current column location.
    }
    
    // Set the new values to start with
    SetMaxLines(iLines) ;
    SetCurrLine(iNumLines-1) ;
    SetStartRow((UINT8)(iNumLines-1), (UINT8)iBaseRow) ;
    SetRedrawLine(iNumLines-1, TRUE) ;  // by default new line is to be redrawn
    
    SetRedrawAll(TRUE) ;      // redraw the whole caption
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleFON(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleFON(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("FlashOn for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("FlashOn for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("FlashOn for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    m_uCurrFGEffect |= AM_L21_FGEFFECT_FLASHING ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRDC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRDC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to PaintOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PaintOn == m_eCCStyle)   // if already in paint-on mode...
        return TRUE ;                           // ... just ignore
    
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PaintOn) ;

    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


//
// I am not sure what the Text Restart command is supposed to do. But it "sounds
// like" something to do with the text1/2 channels which we don't support now.
//
BOOL CLine21DataDecoder::HandleTR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRTD(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRTD(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEDM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEDM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an EDM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Erase DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    CCaptionBuffer *pDispBuff ;

    // next redraw will show blank caption for non-PopOn style ONLY
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_RollUp:
        SetScrollState(FALSE) ;  // not scrolling now at least
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PaintOn:
        // when display memory is cleared, the attribs should be cleared too
        m_uCurrFGEffect = 0 ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PopOn:
        pDispBuff = GetDisplayBuffer() ;
        ASSERT(pDispBuff) ;
        if (pDispBuff)
            pDispBuff->ClearBuffer() ;
        pDispBuff->SetRedrawAll(TRUE) ;

        break ;
    }
    
    //
    // To clear the screen content we should clear internal DIB section which
    // will in turn cause a (clear) sample to be output erasing currently
    // displayed CC.
    //
    m_GDIWork.ClearInternalBuffer() ;

    return TRUE ;
}


void CLine21DataDecoder::SetNewLinePosition(int iLines, UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetNewLinePosition(%d, %u)"), 
            iLines, uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iMaxLines = GetMaxLines() ;
    
    // Check if scroll up is needed or not
    if (iLines >= iMaxLines)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Too many lines. Locate and remove one blank line."))) ;
        
        if (AM_L21_CCSTYLE_RollUp == m_eCCStyle)  // if in roll-up mode
        {
            // We shouldn't be here at all. Anyway, complain and remove the top line.
            DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: How do we have too many lines in roll-up mode (%d vs. max %d)?"),
                iLines, iMaxLines)) ;
            ASSERT(FALSE) ;  // so that we don't miss it
            RemoveLineFromBuffer(0, TRUE) ; // move line #2 onwards up
            iLines-- ;
        }
        else  // non Roll-up mode
        {
            // See if there is a blank line. If so, remove it to make space
            for (int i = 0 ; i < iLines ; i++)
            {
                if (GetNumCols(i) == 0)
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Found line #%d (1-based) blank -- removed."), i+1)) ;
                    RemoveLineFromBuffer((UINT8)i, FALSE) ; // just remove line; don't move up following lines
                    iLines-- ;
                    break ;    // got one line -- enough.
                }
            }
            
            // HACK HACK: This should never happen, but....
            // If the number of lines is still too many, just overwrite the 
            // last line (Is that good?? Oh well...)
            if ((iLines = GetNumLines()) >= iMaxLines)  // too many lines
            {
                DbgLog((LOG_ERROR, 1, TEXT("ERROR: Too many lines. Removing last line by force."))) ;
                RemoveLineFromBuffer(iLines-1, FALSE) ; // just remove the line
                iLines-- ;  // one less line
                SetCurrCol(0) ;  // we start at the beginning on the line
            }
        }
    }
    
    // Now we have to add a new line and set it up
    IncNumLines(1) ;
    SetCurrLine((UINT8)iLines) ;
    SetStartRow((UINT8)iLines, (UINT8)uCurrRow) ;
}


BOOL CLine21DataDecoder::HandleCR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleCR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Carriage Return for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Carriage Return for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Is it only allowed in roll-up style?  I think so based on the docs.
    
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_PaintOn:
        DbgLog((LOG_ERROR, 1, TEXT("INVALID: CR in Pop-on/Paint-on mode!!!"))) ;
        break ;  // or return FALSE ; ???
        
    case AM_L21_CCSTYLE_RollUp:  // This is the real one
        {
            int iRow ;
            int iLines = GetNumLines() ;
            if (0 == iLines)  // no CC line yet -- this is 1st line's data
            {
                iRow = MAX_CAPTION_ROWS ;  // base line's default row position
				SetStartRow((UINT8)iLines, (UINT8)iRow) ;
            }
            else if (1 == iLines)  // there is only 1 line so far
            {
                if (0 == GetNumCols(0))  // blank 1st line
                {
                    RemoveLineFromBuffer(0, TRUE) ; // remove blank 1st line
                    iLines = 0 ;                    // no line left
                }
            }
            else  // there are multiple lines already
            {
                // iRow = GetStartRow(iLines-1) + 1 ;  // +1 to go under last line
                if (m_bScrolling)
                {
                    SkipScrolling() ;
                    iLines = GetNumLines() ;  // we might have scrolled top line off
                }
            }
            if (iLines > 0)  // only if we already have a non-blank line
                SetScrollState(TRUE) ;  // ready to scroll
            IncNumLines(1) ;
            //
            // Number of lines is 1 more than iLines now. So iLines actually
            // points to the last line as a 0-based index.
            //
            SetCurrLine((UINT8)iLines) ;
            SetRedrawLine((UINT8)iLines, TRUE) ;  // new line always to be redrawn
            SetCurrCol(0) ;
            DbgLog((LOG_TRACE, 1, TEXT("New line at row %d after %d lines"), iRow, iLines)) ;
            
            // Make sure to give up all the display attributes and chars 
            // for new row
            // RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // should we or let it be cleared by a DER?
            m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
            m_uCurrFGEffect = 0 ;  // no effect until a PAC/MRC comes
            
            break ;
        }
        
    default:  // Weird!! How did we come here?
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: CR came for unknown mode"))) ;
        break ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleENM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleENM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an ENM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in non-display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Erase non-DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    // Meant only for Pop-on style back back -- clear non-displayed buffer; 
    // display not affected until EOC
    m_aCCData[1 - GetBufferIndex()].ClearBuffer() ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEOC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEOC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to PopOn mode of non-selected channel. skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)  // already in pop-on; flip buffers
    {
        PrintTextToBitmap() ;  // print text to bitmap
        SwapBuffers() ;        // switch 0, 1
        //
        // Also need to update m_pCurrBuff so that we point to
        // the correct one after the above swap.
        // (m_pCurrBuff is set in SetCaptionStyle()).
        //
    }
    else   // change to pop-on style
    {
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ;
    }

    // Update current buffer pointer based on style and buffer index
    m_pCurrBuff = GetCaptionBuffer() ;
    ASSERT(m_pCurrBuff) ;
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(TRUE) ;  // we should redraw the whole caption now
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleTO(BYTE chFirst, BYTE chSecond, int iCols)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTO(%u, %u, %d)"),
            chFirst, chSecond, iCols)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for same data and user channel"), iCols)) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x17 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
        return TRUE ;  // ??
    }
    
    UINT8  uCurrCol  = (UINT8)GetCurrCol() ;
    uCurrCol += (UINT8)iCols ;
    if (uCurrCol >= MAX_CAPTION_COLUMNS)
        uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    SetCurrCol(uCurrCol) ;
    
    return TRUE ;
}


//
// It checks as well as *updates* the number of chars in a line of caption
//
BOOL CLine21DataDecoder::IsEmptyLine(int iLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IsEmptyLine(%ld)"), iLine)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    CCaptionChar*   pcc ;
    int  iNumChars = GetNumCols(iLine) ;
    BOOL bResult = TRUE ;
    int  i ;
    for (i = iNumChars - 1 ; i >= 0 ; i--) // going backwards (-1 due to 0-based index)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)i) ;
        ASSERT(pcc) ;
        if (pcc  &&  pcc->GetChar() != 0)  // got one
        {
            bResult = FALSE ;
            break ;  // enough
        }
    }

    if ( !bResult ) // only if there is some chars left on this line
        DecNumChars(iLine, iNumChars - (i + 1)) ;  // reduce # chars by the diff

    return bResult ;
}


BOOL CLine21DataDecoder::RemoveCharsInBuffer(int iNumChars)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::RemoveCharsInBuffer(%d)"), iNumChars)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int          i, j, k, n ;
    CCaptionChar cc ;
    
    // Just to be sure, check a few things first
    if (GetNumLines() == 0 ||   // no line to delete from
        (n = GetNumCols(GetCurrLine())) == 0)      // no char on current line to delete
        return TRUE ;           // we are done!!
    
    // Prepare the replacement caption char
    cc.SetChar(0) ;  // 0 is transparent space
    cc.SetColor(AM_L21_FGCOLOR_WHITE) ;
    cc.SetEffect(0) ;
    cc.SetDirty(TRUE) ;
    
    // Find the location to clear
    i = GetCurrLine() ;
    j = GetCurrCol() ;
    
    // Check that we are not trying to delete too many chars.
    // Remember: current col + # chars to delete <= MAX.
    if (iNumChars + j > MAX_CAPTION_COLUMNS)  // try it and see!!!
        iNumChars = MAX_CAPTION_COLUMNS - j ;
    
    // Clear the necessary chars
    for (k = 0 ; k < iNumChars ; k++)
    {
        if (j + k < n)          // if a char before the last char is removed, ...
            DecNumChars(i, 1) ; // ... reduce # chars by 1
        SetCaptionChar((UINT8)i, (UINT8)(j+k), cc) ;
    }
    
    if (0 == GetNumCols(i) ||  // # chars left on this line is 0  OR
        IsEmptyLine(i))        // no non-transparent chars on this line
        RemoveLineFromBuffer((UINT8)i, FALSE) ; // delete the line from buffer
    else                     // something left -- so redraw line
        SetRedrawAll(TRUE) ; // I really hate to do it, but I couldn't find a better way
    
    SetCapBufferDirty(TRUE) ;  // some caption char(s) removed
    
    return TRUE ;
}


BOOL CLine21DataDecoder::PrintTextToBitmap(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::PrintTextToBitmap()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int           i, j ;
    int           r, c ;
    CCaptionChar *pcc ;
    BOOL          bRedrawAll = FALSE ;
    BOOL          bRedrawLine ;
    BOOL          bXparentSpace ;
    UINT16        wChar ;
    
// #define DUMP_BUFFER
#ifdef DUMP_BUFFER
    CHAR    achTestBuffer[MAX_CAPTION_COLUMNS+5] ;
    int     iTest = 0 ;
    DbgLog((LOG_TRACE, 0, TEXT("Caption Buffer Content:"))) ;
#endif // DUMP_BUFFER

    MSR_START(m_idTxt2Bmp) ;

    // We need to print all the CC chars to internal output buffer if
    // - a CC command came that needs a total output refresh  or
    // - we have a totally new internal output buffer
    bRedrawAll = (IsRedrawAll() || m_GDIWork.IsNewIntBuffer()) ;
    if (bRedrawAll)
        m_GDIWork.ClearInternalBuffer() ;
    
    // Draw the chars for all cols of all rows that is dirty
    r = GetNumLines() ;
    for (i = 0 ; i < r ; i++)
    {
        c = GetNumCols(i) ;
        if (0 == c)     // if there is no char on a line, skip drawing it
            continue ;  // try next caption line
        
        // Redraw line if 
        // 1) redraw all flag is set   Or
        // 2) redraw line flag is set
        bRedrawLine = bRedrawAll || IsRedrawLine((UINT8)i) ;
        
        // First skip all the leading transparent spaces and then draw
        // the leading space.
        for (j = 0 ; j < c ; j++)
        {
            pcc = GetCaptionCharPtr((UINT8)i, (UINT8)j) ;
            if (pcc  &&  0 != pcc->GetChar())
            {
                // Add a leading blank space for each caption line, if either
                // a) the whole line is being redrawn   OR
                // b) the non-transparent space char is dirty so that
                //    the char will be drawn on top of the next space.
                if (bRedrawLine || pcc->IsDirty())
                    m_GDIWork.DrawLeadingSpace(i, j) ;
                break ;
            }
#ifdef DUMP_BUFFER
            // ` (back quote) => transparent space for debug output
            achTestBuffer[iTest] = '`' ;
            iTest++ ;
#endif // DUMP_BUFFER
        }
        
        bXparentSpace = FALSE ;  // new line => no transparent char issue
        
        // Now print the dirty chars for the current line of caption
        for ( ; j < c ; j++)
        {
            pcc = GetCaptionCharPtr((UINT8)i, (UINT8)j) ;
            if (NULL == pcc)
            {
                ASSERT(!TEXT("Got bad pointer to CC char")) ;
                continue ;  // proceed to the next char
            }
            wChar = pcc->GetChar() ;
#ifdef DUMP_BUFFER
            // ` (back quote) => transparent space for debug output
            achTestBuffer[iTest] = wChar == 0 ? '`' : (char) (wChar & 0x7F) ;  // dump higher byte
            iTest++ ;
#endif // DUMP_BUFFER
            
            // We draw a char only if we have to, i.e,
            // 1) all the caption chars on the line has to be drawn fresh
            //    Or
            // 2) if a char has changed
            // This saves a lot of time doing ExtTextOut()s.
            if (bRedrawLine || pcc->IsDirty())
            {
                if (0 == wChar)  // got transparent space; set flag, don't draw
                    bXparentSpace = TRUE ;
                else  // not transparent space
                {
                    if (bXparentSpace)  // leading blank after transparent space
                    {
                        m_GDIWork.DrawLeadingSpace(i, j) ; // to draw 1 col behind, don't add 1 to j
                        bXparentSpace = FALSE ;  // it's done
                    }
                    m_GDIWork.WriteChar(i, j+1, *pcc) ;  // column needs to change for each char
                }
                pcc->SetDirty(FALSE) ;   // char no more dirty
            }
        }  // end of for (j)
        
        // Whether the line needed to be redrawn or not, let's clear it now
        SetRedrawLine((UINT8)i, FALSE) ;
        
#ifdef DUMP_BUFFER
        achTestBuffer[iTest] = 0 ;
        DbgLog((LOG_TRACE, 0, TEXT("    <%s>"), achTestBuffer)) ;
        iTest = 0 ;  // for next line
#endif // DUMP_BUFFER
        
    }  // end of for (i)
    
    MSR_STOP(m_idTxt2Bmp) ;

    // If the above steps were done because the caption buffer was 
    // dirty, then now we can mark the caption buffer as 
    // "no-more-dirty" as it has been output in the bitmap form and 
    // has been "redrawn all".
    SetCapBufferDirty(FALSE) ;
    SetRedrawAll(FALSE) ;
    m_GDIWork.ClearNewIntBufferFlag() ;
    
    return TRUE ;
}


void CLine21DataDecoder::SkipScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SkipScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int iLines = GetNumLines() ;
    SetScrollState(FALSE) ;    // we are no more scrolling
    
    if (iLines > GetMaxLines())  // too many line; remove top line
    {
        // remove the first text line and move subsequent lines up by one
        DbgLog((LOG_TRACE, 1, TEXT("Top line is being scrolled out"))) ;
        MoveCaptionLinesUp() ;
    }
    else   // otherwise move the line(s) up by a row and bring in new line
    {
        iLines-- ;   // last but one line is at base row
        UINT uBaseRow = GetStartRow(iLines-1) ;
        DbgLog((LOG_TRACE, 1, TEXT("Scrolling all lines up by 1 row"))) ;
        // The following call moves all the line up by including the not-yet-in 
        // line at the base row
        RelocateRollUp(uBaseRow) ;  // move all lines one row higher
    }
}


int CLine21DataDecoder::IncScrollStartLine(int iCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IncScrollStartLine(%d)"), 
            iCharHeight)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0 == m_iScrollStartLine)  // starting to scroll
        MSR_START(m_idScroll) ;

    m_iScrollStartLine += m_GDIWork.GetScrollStep() ;
    if (m_iScrollStartLine > iCharHeight)
    {
        // Scrolling one line is done -- do the standard end of scroll stuff
        DbgLog((LOG_TRACE, 3, TEXT("One full line has been scrolled up"))) ;
        SkipScrolling() ;
        MSR_STOP(m_idScroll) ;  // scrolling ended
    }
    
    return m_iScrollStartLine ;
}


void CLine21DataDecoder::SetScrollState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetScrollState(%s)"), 
            bState ? "TRUE" : "FALSE")) ;

    if (bState)                      // if turning ON scrolling
    {
        if (!m_bScrolling)           // change scroll line only if NOT scrolling now
            m_iScrollStartLine = 0 ; // start from first line
    }
    else                             // turning if OFF
        m_iScrollStartLine = 0 ;     // back to the start line

    m_bScrolling = bState ;          // set the spec-ed scrolling state
}


void CLine21DataDecoder::MoveCaptionLinesUp(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::MoveCaptionLinesUp()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    RemoveLineFromBuffer(0, TRUE) ; // remove the top line from buffer
    SetCapBufferDirty(TRUE) ;       // a line of text removed -- buffer dirty
}


void CLine21DataDecoder::CompleteScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CompleteScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // For now we are doing a really cheapo solution, but it may work.
    if (m_bScrolling)
        SkipScrolling() ;
}


void CLine21DataDecoder::UpdateBoundingRect(RECT *prectOut, RECT *prectLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::UpdateBoundingRect()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    prectOut->top    = min(prectOut->top,    prectLine->top) ;
    prectOut->left   = min(prectOut->left,   prectLine->left) ;
    prectOut->bottom = max(prectOut->bottom, prectLine->bottom) ;
    prectOut->right  = max(prectOut->right,  prectLine->right) ;
}


void CLine21DataDecoder::CalcOutputRect(RECT *prectOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CalcOutputRect()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We don't check if it's necessary to re-calc the bounding rect. Will
    // checking save time?

    CCaptionBuffer   *pDispBuff = GetDisplayBuffer() ;  // this is mainly for Pop-On captioning
    if (NULL == pDispBuff)
    {
        DbgLog((LOG_TRACE, 2, TEXT("No style specified yet. Set bounding rect to (0, 0, 0, 0)."))) ;
        SetRect(prectOut, 0, 0, 0, 0) ;          // indicates whole bitmap
        return ;
    }
    int  iNumLines = pDispBuff->GetNumLines() ;
    int  iMaxLines = pDispBuff->GetMaxLines() ;
    int  iMax = min(iNumLines, iMaxLines) ;
    if (iNumLines > 0)  // there is some content to output -- specify correct spot
    {
        RECT  rectLine ;
        SetRect(prectOut, 10000, 10000, 0, 0) ;  // init top & left to large, bottom & right to low
        for (int i = 0 ; i < iMax ; i++)
        {
            m_GDIWork.GetOutputLines(pDispBuff->GetStartRow(i), &rectLine) ;
            UpdateBoundingRect(prectOut, &rectLine) ;
        }
   }
    else                // nothing to output -- specify whole bitmap
        SetRect(prectOut, 0, 0, 0, 0) ;          // indicates whole bitmap
}


void CLine21DataDecoder::CopyOutputDIB(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CopyOutputDIB()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    //
    // Don't copy DIB scanlines unless at least one of the following 
    // is true:
    // a) downstream filter wants a total redraw
    // b) Roll-up style and scrolling
    // c) new DIB section created (old bitmap gone)
    // d) new output sample buffer (last copy is lost)
    // e) new data has been written on output DIB (copy new data)
    //
    if (! (m_bRedrawAlways ||
           (AM_L21_CCSTYLE_RollUp == m_eCCStyle && m_bScrolling) ||  
           m_GDIWork.IsNewIntBuffer() ||
           m_GDIWork.IsNewOutBuffer() ||
           m_GDIWork.IsBitmapDirty()) )
        return ;
    
    // Clear the entire output buffer now
    m_GDIWork.FillOutputBuffer() ;
    
    // Copy by scanlines representing each text line's data
    CCaptionBuffer   *pDispBuff = GetDisplayBuffer() ;  // this is mainly for Pop-On captioning
    if (NULL == pDispBuff)
    {
        DbgLog((LOG_TRACE, 2, TEXT("No style specified yet. Just reseting flags."))) ;
        m_GDIWork.ClearBitmapDirtyFlag() ;   // we are outputting current bitmap anyway
        m_GDIWork.ClearNewIntBufferFlag() ;  // new buffer is cleared and output
        m_GDIWork.ClearNewOutBufferFlag() ;  // current bitmap will be on this out buffer
        return ;
    }
    int  iNumLines = pDispBuff->GetNumLines() ;
    int  iMaxLines = pDispBuff->GetMaxLines() ;
    int  iMax = min(iNumLines, iMaxLines) ;
    if (iNumLines > 0)  // there is some content to output -- specify correct spot
    {
        MSR_START(m_idBmp2Out) ;  // start copying DIB secn data to output buffer

        if (m_bScrolling)   // during scrolling
        {
            if (iNumLines > iMaxLines)  // scrolling a line out
            {
                // Show the bottom scan lines of the top (outgoing) line
                DbgLog((LOG_TRACE, 2, 
                    TEXT("Scrolling: Total %d lines > %d lines max (line 0)"), 
                    iNumLines, iMaxLines)) ;
                m_GDIWork.CopyLine(0, m_iScrollStartLine, pDispBuff->GetStartRow(0), 0) ;
            }
            else   // just scrolling the line up to accomodate the new line
            {
                // Put the bottom line a few scanlines above to simulate scrolling up
                DbgLog((LOG_TRACE, 2,
                    TEXT("Scrolling: Total %d lines <= %d lines max (line 0)"), 
                    iNumLines, iMaxLines)) ;
                m_GDIWork.CopyLine(0, 0, pDispBuff->GetStartRow(0), -m_iScrollStartLine) ;
                iMax-- ;   // don't draw last line (partial line)
            }
        
            // Now show the middle (if any) lines in total
            int iCharHeight = m_GDIWork.GetCharHeight() ;
            for (int i = 1 ; i < iMax ; i++)
            {
                // We put each full line in its predecessor's row with some dest offset
                // to make it come down to its own row.  
                // I wish I could draw that diagram here about how scanlines get copied 
                // from internal DIB section to the output buffer.
                DbgLog((LOG_TRACE, 1, TEXT("Scrolling: Drawing line %d..."), i)) ;
                m_GDIWork.CopyLine(i, 0, pDispBuff->GetStartRow(i-1), 
                    iCharHeight-m_iScrollStartLine) ;
            }
        
            // Last show only the top scan lines of the new (not yet included) line
            DbgLog((LOG_TRACE, 1, TEXT("Scrolling: drawing last line %d"), iNumLines)) ;
            m_GDIWork.CopyLine(iNumLines-1, 0,
                pDispBuff->GetStartRow(iNumLines-2), // -2 as new line shows up
                // in the above line's space
                iCharHeight-m_iScrollStartLine, 
                m_iScrollStartLine) ;
        
            // Move to one scan line down for new output sample
            IncScrollStartLine(iCharHeight) ;  // it's MUCH harder than just ++-ing
        }
        else   // we are not scrolling
        {
            DbgLog((LOG_TRACE, 2,
                TEXT("NOT Scrolling: Total %d lines, %d lines max"), 
                iNumLines, iMaxLines)) ;
            for (int i = 0 ; i < iMax ; i++)
            {
                DbgLog((LOG_TRACE, 1, TEXT("NOT Scrolling: Drawing line %d..."), i)) ;
                m_GDIWork.CopyLine(i, 0, pDispBuff->GetStartRow(i), 0) ;
                // UpdateBoundingRect() ;
            }
        }
        MSR_STOP(m_idBmp2Out) ;  // done copying DIB secn data to output buffer
    }
    else                // nothing to output -- specify whole bitmap
    {
        DbgLog((LOG_TRACE, 3, TEXT("No caption data in buffer."))) ;
    }
    
    // Reset the new internal/external buffer and bitmap dirty flag
    m_GDIWork.ClearBitmapDirtyFlag() ;
    m_GDIWork.ClearNewIntBufferFlag() ;
    m_GDIWork.ClearNewOutBufferFlag() ;
}


//
// Clear both buffers
//
BOOL CLine21DataDecoder::InitCaptionBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(void)"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_aCCData[0].InitCaptionBuffer() ;  // clear buffer 0
    m_aCCData[1].InitCaptionBuffer() ;  // clear buffer 1
    SetBufferIndex(0) ;                 // reset CC buffer index
    
    return TRUE ;
}


//
// Clear buffer(s) based on the given style
//
BOOL CLine21DataDecoder::InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(%d)"), (int)eCCStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_aCCData[0].InitCaptionBuffer() ;
        m_aCCData[1].InitCaptionBuffer() ;
        SetBufferIndex(0) ;   // reset CC buffer index
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        m_aCCData[GetBufferIndex()].InitCaptionBuffer() ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("InitCaptionBuffer(): Wrong Style (%d)!!"), eCCStyle)) ;
        return FALSE ;
    }

    return TRUE ;
}

//
// Caption style determines the buffer pointers to hold the caption chars.
// We make m_pCurrBuff point to the approp. buffer based on the new style.
// NOTE: The only other place where m_pCurrBuff may be changed is in 
// CLine21DataDecoder::HandleEOC() which flips the buffers back & front. So
// we also need to change m_pCurrBuff there too.
//
AM_LINE21_CCSTYLE CLine21DataDecoder::SetCaptionStyle(AM_LINE21_CCSTYLE eStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCaptionStyle(%d)"), eStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_pCurrBuff = &m_aCCData[1 - GetBufferIndex()] ;
        // Set CC style on both the buffers
        m_aCCData[0].SetStyle(eStyle) ;
        m_aCCData[1].SetStyle(eStyle) ;
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
        InitCaptionBuffer() ;
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;

    case AM_L21_CCSTYLE_PaintOn:
        if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)   // if switching from PopOn to PaintOn...
            InitCaptionBuffer(eStyle) ;           // ...clear display buffer
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;
        
    case AM_L21_CCSTYLE_None:  // This is done in init etc.
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("SetCaptionStyle(): Invalid Style!!"))) ;
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        return AM_L21_CCSTYLE_None ;
    }
    AM_LINE21_CCSTYLE  eOldStyle = m_eCCStyle ;
    m_eCCStyle = eStyle ;
    
    //
    // When CC style changes, some internal states also need to cleared
    //
    m_uCurrFGEffect = 0 ;
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    SetScrollState(FALSE) ;  // not scrolling now
    
    return eOldStyle ;
}

CCaptionBuffer * CLine21DataDecoder::GetDisplayBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::GetDisplayBuffer()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        return &m_aCCData[GetBufferIndex()] ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("GetDisplayBuffer(): Wrong Style!!"))) ;
        return NULL ;
    }
}

CCaptionBuffer * CLine21DataDecoder::GetCaptionBuffer(void)
{
    return &m_aCCData[1 - GetBufferIndex()] ;
}


void CLine21DataDecoder::SetBufferIndex(int iIndex)
{
    if (! (0 == iIndex  ||  1 == iIndex) )  // error!!
        return ;
    m_iBuffIndex = iIndex & 0x01 ;
}


void CLine21DataDecoder::ClearBuffer(void)
{
    if (m_pCurrBuff)
        m_pCurrBuff->ClearBuffer() ;
}

void CLine21DataDecoder::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->RemoveLineFromBuffer(uLine, bUpNextLine) ;
}

void CLine21DataDecoder::GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->GetCaptionChar(uLine, uCol, cc) ;
}

void CLine21DataDecoder::SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                                        const CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCaptionChar(uLine, uCol, cc) ;
}

CCaptionChar* CLine21DataDecoder::GetCaptionCharPtr(UINT8 uLine, UINT8 uCol)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCaptionCharPtr(uLine, uCol) ;
    
    //
    //  Otherwise it's a very bad thing!!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL inside GetCaptionCharPtr()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return NULL ;  // may be we should trap this and not fault
}

int  CLine21DataDecoder::GetMaxLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetMaxLines() ;
    return 0 ;  // that's best!!!
}

void CLine21DataDecoder::SetMaxLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetMaxLines(uLines) ;
}

int  CLine21DataDecoder::GetNumLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetNumLines() ;
    return 0 ;
}

void CLine21DataDecoder::SetNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetNumLines(uLines) ;
}

int  CLine21DataDecoder::GetNumCols(int iLine)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;   // should we??
    }
    
    if (iLine >= GetNumLines())
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) ( > Total (%d)"), iLine, GetNumLines())) ;
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(iLine).GetNumChars() ;
}


int  CLine21DataDecoder::GetCurrLine(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrLine() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

int  CLine21DataDecoder::GetCurrCol(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrCol() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

void CLine21DataDecoder::SetCurrLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrLine(uLine) ;
}

void CLine21DataDecoder::SetCurrCol(UINT8 uCol)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrCol(uCol) ;
}

int  CLine21DataDecoder::GetStartRow(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetStartRow(uLine & 0x7) ;
    
    //
    // This is very very bad!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL in GetStartRow()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return 0 ;
}

void CLine21DataDecoder::SetStartRow(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetStartRow(uLine & 0x7, uRow) ;
}

int  CLine21DataDecoder::GetRowIndex(UINT8 uRow)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetRowIndex(uRow) ;
    else
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
}

void CLine21DataDecoder::SetRowIndex(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRowIndex(uLine, uRow) ;
}

int CLine21DataDecoder::IncCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ; // is that OK?
}

int CLine21DataDecoder::DecCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ;  // is that OK?
}

int CLine21DataDecoder::IncNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(uLine).IncNumChars(uNumChars) ;
}

int CLine21DataDecoder::DecNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    return m_pCurrBuff->GetCaptionLine(uLine).DecNumChars(uNumChars) ;
}

int CLine21DataDecoder::IncNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncNumLines(uLines) ;
    return 0 ;
}

int CLine21DataDecoder::DecNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecNumLines(uLines) ;
    return 0 ;
}

void CLine21DataDecoder::MoveCaptionChars(int iLine, int iNum)
{
    if (m_pCurrBuff)
        m_pCurrBuff->MoveCaptionChars(iLine, iNum) ;
}

BOOL CLine21DataDecoder::IsCapBufferDirty(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsBufferDirty() ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawLine(uLine) ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawAll(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawAll() ;
    return FALSE ;
}

void CLine21DataDecoder::SetCapBufferDirty(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetBufferDirty(bState) ;
}

void CLine21DataDecoder::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawLine(uLine, bState) ;
}

void CLine21DataDecoder::SetRedrawAll(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(bState) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21dbase.cpp ===
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.

//
// DirectShow Line 21 Decoder 2 Filter: Base class code
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"


//
//  CCaptionChar: Caption char base class implementation (non-inline methods)
//

void CCaptionChar::SetChar(UINT16 wChar)
{
    if (wChar != m_wChar)
    {
        SetDirty(TRUE) ;
        m_wChar = wChar ;
    }
}

void CCaptionChar::SetColor(UINT8 uColor)
{
    if (uColor != GetColor())  // color changed
    {
        SetDirty(TRUE) ;
        m_uAttrib &= ~AM_L21_FGCOLOR_MASK ;           // clear old color
        m_uAttrib |= (uColor & AM_L21_FGCOLOR_MASK) ; // set new color
    }
}

void CCaptionChar::SetEffect(UINT8 uEffect)
{
    if (uEffect != GetEffect())
    {
        SetDirty(TRUE) ; 
        m_uAttrib &= ~AM_L21_FGEFFECT_MASK ;            // clear old effect bits
        m_uAttrib |= (uEffect & AM_L21_FGEFFECT_MASK) ; // set new effect value
    }
}

void CCaptionChar::SetItalicized(BOOL bState) 
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_ITALICS ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_ITALICS ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetUnderLined(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_UNDERLINE ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_UNDERLINE ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetFlashing(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_FLASHING ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_FLASHING ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetDirty(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_DIRTY ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_DIRTY ;
}

void CCaptionChar::SetMidRowCode(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_MRC ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_MRC ;
}



//
//  CCaptionLine: Base class implementation of a line of CC chars
//
CCaptionLine::CCaptionLine(void)
{
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;  // un-inited
    ClearLine() ;
}

CCaptionLine::CCaptionLine(const UINT uStartRow, const UINT uNumChars /* 0 */)
{
    m_uNumChars = (UINT8)uNumChars ;
    m_uStartRow = (UINT8)uStartRow ;
    ClearLine() ;
}

CCaptionLine& CCaptionLine::operator = (const CCaptionLine& cl)
{
    m_uNumChars = cl.m_uNumChars ;
    m_uStartRow = cl.m_uStartRow ;
    for (int i = 0 ; i < MAX_CAPTION_COLUMNS ; i++)
        cl.GetCaptionChar(i, m_aCapChar[i]) ;
    return *this ;
}

int CCaptionLine::IncNumChars(UINT uNumChars)
{
    m_uNumChars += (uNumChars & 0x3F) ;
    if (m_uNumChars > MAX_CAPTION_COLUMNS)
        m_uNumChars = MAX_CAPTION_COLUMNS ;
    return m_uNumChars ;
}

int CCaptionLine::DecNumChars(UINT uNumChars)
{
    if (uNumChars < m_uNumChars)
        m_uNumChars -= (UINT8)uNumChars ;   // & 0x3F ;
    else       // error ??? or just make it 0 ???
        m_uNumChars = 0 ;
    return m_uNumChars ;
}

void CCaptionLine::SetCaptionChar(UINT uCol, const CCaptionChar &cc)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return ;

    // A Hacky (?) Fix:
    // If this char is for the last (32nd) column then we set the "Dirty"
    // flag on for the char before it so that it gets redrawn causing any
    // prev char in last column to be erased while rendering.
    if ((UINT)MAX_CAPTION_COLUMNS - 1 == uCol)
        m_aCapChar[uCol-1].SetDirty(TRUE) ;  // to cause re-rendering
    m_aCapChar[uCol] = cc  ;
}

CCaptionChar* CCaptionLine::GetCaptionCharPtr(UINT uCol)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return NULL ;
    return &(m_aCapChar[uCol]) ;
}

void CCaptionLine::SetStartRow(UINT uRow)
{
    if (uRow > MAX_CAPTION_ROWS)  // error!! We use 1-based index for Row numbers
    {
        ASSERT(uRow > MAX_CAPTION_ROWS) ;
        return ;
    }
    m_uStartRow = uRow & 0xF ;
    ASSERT(m_uStartRow > 0 && uRow > 0) ;
}

void CCaptionLine::MoveCaptionChars(int iNum)
{
    ASSERT(iNum < MAX_CAPTION_COLUMNS) ;
    int  i ;
    for (i = min(m_uNumChars, MAX_CAPTION_COLUMNS-iNum) - 1 ; i >= 0 ; i--)
        m_aCapChar[i+iNum] = m_aCapChar[i] ;
    CCaptionChar  cc ;
    for (i = 0 ; i < iNum ; i++)
        m_aCapChar[i] = cc ;
    m_uNumChars = min(m_uNumChars+iNum, MAX_CAPTION_COLUMNS) ;
}

void CCaptionLine::ClearLine(void)
{
    CCaptionChar cc ;
    for (UINT u = 0 ; u < MAX_CAPTION_COLUMNS ; u++)
        m_aCapChar[u] = cc ;
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;   // newly added
}



//
//  CRowIndexMap: Mapping of row usage (row to line) class implementation
//
int CRowIndexMap::GetRowIndex(UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::GetRowIndex(%u)"), uRow)) ;

    uRow-- ;   // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u) for row index"), uRow)) ;
        ASSERT(FALSE) ;
        return -1 ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        return ( m_adwMap[1] & (0xF << uRow) ) >> uRow ;
    }
    else
    {
        uRow = uRow << 2 ;
        return ( m_adwMap[0] & (0xF << uRow) ) >> uRow ;
    }
#else   // trust me -- it works!!!
    return (m_adwMap[uRow / 8] & (0xF << (4 * (uRow % 8)))) >> (4 * (uRow % 8)) ;
#endif // #if 0
}

void CRowIndexMap::SetRowIndex(UINT uLine, UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::SetRowIndex(%u, %u)"), uLine, uRow)) ;

    uRow-- ;  // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS  ||
        uLine > MAX_CAPTION_LINES)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u)/line (%u) for saving"), uRow, uLine)) ;
        ASSERT(FALSE) ;
        return ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        m_adwMap[1] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[1] |= (uLine << uRow) ;
    }
    else
    {
        uRow = uRow << 2 ;
        m_adwMap[0] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[0] |= (uLine << uRow) ;
    }
#else   // trust me -- it works!!!
    m_adwMap[uRow / 8] &= ~(0xF   << (4 * (uRow % 8))) ;  // clear any existing bits there
    m_adwMap[uRow / 8] |=  (uLine << (4 * (uRow % 8))) ;  // put new line number in there
#endif // #if 0
}


//
//  CCaptionBuffer: The base caption buffer class implementation
//

CCaptionBuffer::CCaptionBuffer(UINT8 uStyle    /* = AM_L21_CCSTYLE_None */,
                               UINT8 uMaxLines /* = MAX_CAPTION_LINES */)
{
    ClearBuffer() ;
    m_uMaxLines = uMaxLines ;
    m_uCaptionStyle = uStyle ;
}

CCaptionBuffer::CCaptionBuffer(/* const */ CCaptionBuffer &cb)
{
    for (int i = 0 ; i < cb.GetNumLines() ; i++)
        m_aCapLine[i] = cb.GetCaptionLine(i) ;
    m_RowIndex  = cb.m_RowIndex ;
    m_uNumLines = cb.m_uNumLines ;
    m_uMaxLines = cb.m_uMaxLines ;
    m_uCurrCol  = cb.m_uCurrCol ;
    m_uCurrLine = cb.m_uCurrLine ;
    m_uCaptionStyle = cb.m_uCaptionStyle ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL ;  // cb.m_uDirtyState ;
}

void CCaptionBuffer::SetCurrCol(int uCurrCol)
{
    m_uCurrCol = uCurrCol & 0x3F ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
}

void CCaptionBuffer::SetCaptionLine(UINT uLine, const CCaptionLine& cl)
{
    if (uLine >= MAX_CAPTION_LINES)
        return ;
    m_aCapLine[uLine] = cl ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

void CCaptionBuffer::ClearCaptionLine(UINT uLine)
{
    m_aCapLine[uLine].ClearLine() ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

int CCaptionBuffer::IncCurrCol(UINT uNumChars)
{
    m_uCurrCol += (UINT8)uNumChars ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    
    return m_uCurrCol ;
}

int CCaptionBuffer::DecCurrCol(UINT uNumChars)
{
    if (m_uCurrCol < uNumChars)
        m_uCurrCol  = 0 ;
    else
        m_uCurrCol -= (UINT8)uNumChars ;
    
    return m_uCurrCol ;
}

void CCaptionBuffer::ClearBuffer(void)
{
    for (int i = 0 ; i < MAX_CAPTION_LINES ; i++)
    {
        m_aCapLine[i].ClearLine() ;
        SetStartRow(i, 0) ;
    }
    m_RowIndex.ClearRowIndex() ; ;
    m_uNumLines = 0 ;
    m_uMaxLines = MAX_CAPTION_LINES ;
    m_uCurrCol  = 0 ;
    m_uCurrLine = 0 ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL |   // draw everything
                    L21_CAPBUFFER_DIRTY ;       // buffer is dirty
}

void CCaptionBuffer::InitCaptionBuffer(void) 
{
    ClearBuffer() ;
}

int CCaptionBuffer::IncNumLines(int uLines)
{
    m_uNumLines += uLines & 0x7 ;
    // Roll-Up is supposed to allow 1 line more than the max for scrolling
    if (AM_L21_CCSTYLE_RollUp == m_uCaptionStyle)
    {
        if (m_uNumLines > m_uMaxLines+1)
            m_uNumLines = m_uMaxLines+1 ;
    }
    else  // non Roll-Up mode -- Pop-On or Paint-On
    {
        if (m_uNumLines > m_uMaxLines)  // What? Too many lines!!!
        {
            DbgLog((LOG_ERROR, 1, 
                TEXT("WARNING: How did %u lines get created with max of %u lines?"), 
                m_uNumLines, m_uMaxLines)) ;
            m_uNumLines = m_uMaxLines ;  // just to plug the hole!!!
        }
    }
    return m_uNumLines ;
}

int CCaptionBuffer::DecNumLines(int uLines)
{
    if (uLines > m_uNumLines)  // error!!
        return 0 ;
    m_uNumLines -= uLines & 0x7 ;
    return m_uNumLines ;
}

void CCaptionBuffer::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::RemoveLineFromBuffer(%u, %u)"), 
            uLine, bUpNextLine)) ;

    int iNumLines = GetNumLines() ;
    int iMaxLines = GetMaxLines() ;
    int iRow ;
    
    if (bUpNextLine)    // if next line should be move up (for Roll-up style)
    {
        // We go upto iNumLines-1 because iNumLines is the not-yet-included line
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            iRow = GetStartRow(i) ;     // get the row posn of line i
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            SetStartRow(i, iRow) ;  // put prev line i's row # as new line i's row #
        }
    
        // Clear the last line data and row index bits, ONLY IF it's already in
        iRow = GetStartRow(iNumLines-1) ;
        ClearCaptionLine(iNumLines-1) ;
        if (iNumLines <= iMaxLines)  // if the last line is already in
        {
            if (iRow > 0)  // if row # is valid, release it
                m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
            else           // otherwise something wrong
                ASSERT(FALSE) ; // so that we know
        }
        // Otherwise there is a not-yet-in line hanging, which doesn't have a 
        // row number given yet.  So no need to release that row.
    }
    else    // next line doesn't get moved up (for NON Roll-up style)
    {
        // Release the line-to-be-deleted's row by clearing the index bit
        if ((iRow = GetStartRow(uLine)) > 0)  // (check validity)
            m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
        else            // that would be weird
            ASSERT(FALSE) ; // so that we know

        // Here we stop at iNumLines-1, because we move all the existing lines to
        // make space for a new line that will start next.
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            // Update index bitmap to new row i's start row (+1 because index 
            // bitmap nibble values are 1-based).
            m_RowIndex.SetRowIndex(i+1, (UINT8)GetStartRow(i)) ;
        }
    
        // Clear the last line's data
        ClearCaptionLine(iNumLines-1) ;
    }
    
    // A line is out of the buffer -- so buffer is dirty
    SetBufferDirty(TRUE) ;
    
    // Clear whole DIB section so that no leftover shows up
    SetRedrawAll(TRUE) ;
    
    DecNumLines(1) ;  // now we have 1 line less
    
    // We have removed a line from the buffer; so the current line also
    // needs to be updated to point to the proper line in the caption buffer.
    if (m_uCurrLine == uLine)
        if (uLine == m_uNumLines-1)
            m_uCurrLine-- ;
        else
            ;  // do nothing -- old next line will become new curr line
        else if (m_uCurrLine > uLine)   // if a line above was removed
            m_uCurrLine-- ;             // then move line index up
        else    // a line was deleted below current line
            ;   // do nothing -- doesn't matter at all
        if (m_uCurrLine < 0)  // in case we went too far up
            m_uCurrLine = 0 ; // come down to the ground!!!
}

void CCaptionBuffer::SetStartRow(UINT uLine, UINT uRow)
{
    int iRow = GetStartRow(uLine) ;         // get the currently set row number
    if (iRow == (int)uRow)  // if nothing changed...
        return ;            // ...no point re-doing it
    if (iRow > 0)                           // if it was already set then...
        m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;   // ...clear the row index map bits
    m_aCapLine[uLine].SetStartRow(uRow) ;   // set new row value for the line
    // set row index bits only if specified row > 0; else it's just for clearing
    if (uRow > 0) {
        // use +1 for line # as row index map uses 1-based index for line #s
        m_RowIndex.SetRowIndex(uLine+1, (UINT8)uRow) ; // set index map bits for new row
    }
    else
        ASSERT(FALSE) ;
}

BOOL CCaptionBuffer::IsRedrawLine(UINT8 uLine)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to get line redraw info"), uLine)) ;
        return FALSE ;
    }
    return (m_uDirtyState & (0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine))) ; 
}

void CCaptionBuffer::SetBufferDirty(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_DIRTY ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_DIRTY ;
}

void CCaptionBuffer::SetRedrawAll(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_REDRAWALL ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_REDRAWALL ;
}

void CCaptionBuffer::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to set line redraw info"), uLine)) ;
        return ;
    }
    if (bState)
        m_uDirtyState |= (UINT8)(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
    else
        m_uDirtyState &= (UINT8)~(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21ddraw.h ===
// Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.
//
//  L21DDraw.h: Line 21 Decoder drawing-related base class code
//

#ifndef _INC_L21DDRAW_H
#define _INC_L21DDRAW_H


//
// We start with 16x24 pixel chars by default
//
#ifndef __DEFAULTCHARSIZE_DEFINED
#define __DEFAULTCHARSIZE_DEFINED
#define DEFAULT_CHAR_WIDTH    16
#define DEFAULT_CHAR_HEIGHT   24
#endif // __DEFAULTCHARSIZE_DEFINED

//
// Font cache holds 3 lines of 40 chars per line (total 120 chars, using 112)
//
#ifndef __FONTCACHE_DEFINED
#define __FONTCACHE_DEFINED
#define FONTCACHELINELENGTH  40
#define FONTCACHENUMLINES     3
#endif // __FONTCACHE_DEFINED


//
// We use a 4 pixel inter-char space to avoid getting into the over/underhang
// problems with Italic chars
//
#ifndef __INTERCHAR_SPACE
#define __INTERCHAR_SPACE
#define INTERCHAR_SPACE   4
#endif // __INTERCHAR_SPACE

//
// A 2 pixel extra inter-char space is used to avoid getting into the over/underhang
// problems with Italic chars
//
#ifndef __INTERCHAR_SPACE_EXTRA
#define __INTERCHAR_SPACE_EXTRA
#define INTERCHAR_SPACE_EXTRA   2
#endif // __INTERCHAR_SPACE_EXTRA


//
//  CLine21DecDraw: class for drawing details to output caption text to bitmap
//
class CLine21DecDraw {
public:
    CLine21DecDraw(void) ;
    ~CLine21DecDraw(void) ;
    bool InitFont(void) ;
    void InitColorNLastChar(void) ;
    void InitCharSet(void) ;
    void MapCharToRect(UINT16 wChar, RECT *pRect) ;
    // LPDIRECTDRAWSURFACE7 GetDDrawSurface(void)  { return m_lpDDSOutput ; } ;
    bool SetDDrawSurface(LPDIRECTDRAWSURFACE7 lpDDS) ;
    IUnknown* GetDDrawObject(void)  { return m_pDDrawObjUnk ; } ;
    inline void SetDDrawObject(IUnknown *pDDrawObjUnk)    { m_pDDrawObjUnk = pDDrawObjUnk ; } ;
    void FillOutputBuffer(void) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) ;
    inline void GetBackgroundColor(DWORD *pdwBGColor) { *pdwBGColor = m_dwBackground ; } ;
    BOOL SetBackgroundColor(DWORD dwBGColor) ;
    inline BOOL GetBackgroundOpaque(void)         { return m_bOpaque ; } ;
    inline void SetBackgroundOpaque(BOOL bOpaque) { m_bOpaque = bOpaque ; } ;

    inline UINT GetCharHeight(void)  { return m_iCharHeight ; } ;
    inline int  GetScrollStep(void)  { return m_iScrollStep ; } ;
    void DrawLeadingTrailingSpace(int iLine, int iCol, int iSrcCrop, int iDestOffset) ;
    void WriteChar(int iLine, int iCol, CCaptionChar& cc, int iSrcCrop, int iDestOffset) ;
    void WriteBlankCharRepeat(int iLine, int iCol, int iRepeat, int iSrcCrop,
                              int iDestOffset) ;
    inline BOOL IsNewOutBuffer(void)   { return m_bNewOutBuffer ; } ;
    inline void SetNewOutBuffer(BOOL bState)  { m_bNewOutBuffer = bState ; }
    inline BOOL IsOutDIBClear(void)  { return m_bOutputClear ; } ;
    BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) ;
    void GetOutputLines(int iDestLine, RECT *prectLine) ;
    inline BOOL IsTTFont(void)  { return m_bUseTTFont ; } ;

private:   // private methods
    bool CreateScratchFontCache(LPDIRECTDRAWSURFACE7* lplpDDSFontCache) ;
    bool CreateFontCache(LPDIRECTDRAWSURFACE7 *lplpDDSFontCache,
                         DWORD dwTextColor, DWORD dwBGColor, DWORD dwOpacity,
                         BOOL bItalic, BOOL bUnderline) ;
    HFONT CreateCCFont(int iFontWidth, int iFontHeight, BOOL bItalic, BOOL bUnderline) ;
    HRESULT DDrawARGBSurfaceInit(LPDIRECTDRAWSURFACE7* lplpDDSFontCache,
                                 BOOL bUseSysMem, BOOL bTexture, DWORD cx, DWORD cy) ;

private:   // private data
    CCritSec        m_csL21DDraw ;    // to serialize actions on this class

    UINT16          m_lpwCharSet[121] ; // 120(+1) spaces for 112 chars of CC-ing

    LPBITMAPINFO    m_lpBMIOut ;      // BITMAPINFO for output from downstream filter
    LPBITMAPINFO    m_lpBMIIn ;       // BITMAPINFO for output from upstream filter
    UINT            m_uBMIOutSize ;   // bytes for BMI data from downstream
    UINT            m_uBMIInSize ;    // bytes for BMI data from upstream
    LONG            m_lWidth ;        // currently set output width
    LONG            m_lHeight ;       // currently set output height
    int             m_iBorderPercent ;// current border percent (10 or 20)
    int             m_iHorzOffset ;   // horizontal offset of CC area
    int             m_iVertOffset ;   // vertical offset of CC area
    BOOL            m_bOpaque ;       // should caption background be opaque?

    BOOL            m_bOutputClear ;  // is output buffer clear?
    BOOL            m_bNewOutBuffer ; // has output buffer changed?

    LOGFONT         m_lfChar ;        // LOGFONT struct for quick font create
    BOOL            m_bUseTTFont ;    // are TT fonts available?

    int             m_iCharWidth ;    // width of each caption char in pixels
    int             m_iCharHeight ;   // height of each caption char in pixels
    int             m_iScrollStep ;   // # scanlines to scroll by in each step
    int             m_iPixelOffset ;  // pixel offset within a char rect (Italics vs. not)

    CCaptionChar    m_ccLast ;        // last caption char and attribs printed
    COLORREF        m_acrFGColors[7] ;// 7 colors from white to magenta
    BYTE            m_idxFGColors[7] ;// same 7 colors but in palette index form
    UINT            m_uColorIndex ;   // index of currently used color
    DWORD           m_dwBackground ;  // background color with alpha bits
    DWORD           m_dwTextColor ;   // last used CC text color
    BOOL            m_bFontItalic ;   // is Italic font being used?
    BOOL            m_bFontUnderline ; // is Italic font being used?

    //
    //  Details to work with the new VMR
    //
    IUnknown       *m_pDDrawObjUnk ;   // pointer to DDraw object for DDraw surface
    LPDIRECTDRAWSURFACE7 m_lpDDSOutput ;  // current out buffer/surface pointer
    LPDIRECTDRAWSURFACE7 m_lpDDSNormalFontCache ;  // normal font cache -- indicates caching status too
    LPDIRECTDRAWSURFACE7 m_lpDDSItalicFontCache ;  // Italic font cache
    LPDIRECTDRAWSURFACE7 m_lpDDSSpecialFontCache ; // other special (U, I+U, colored) font cache
    LPDIRECTDRAWSURFACE7 m_lpDDSScratch ; // a scratch font cache in system memory
    LPDIRECTDRAWSURFACE7 m_lpBltList ; // current list to Blt() from
    bool            m_bUpdateFontCache ; // font cache re-build flag

#ifdef PERF
    int             m_idClearOutBuff ;
#endif // PERF

private:   // private helper methods
    bool InitBMIData(void) ;
    static int CALLBACK EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM,
                                     int iFontType, LPARAM lParam) ;
    void CheckTTFont(void) ;
    void ChangeFont(DWORD dwTextColor, BOOL bItalic, BOOL bUnderline) ;
    void SetFontCacheAlpha(LPDIRECTDRAWSURFACE7 lpDDSFontCacheSrc, LPDIRECTDRAWSURFACE7 lpDDSFontCacheDest, BYTE bClr) ;
    int CalcScrollStepFromCharHeight(void) {
        // We need to scroll the CC by as many lines at a time as necessary to
        // complete scrolling within 12 steps max, approx. 0.4 seconds which is
        // the EIA-608 standard requirement.
#define MAX_SCROLL_STEP  12
        return (int)((m_iCharHeight + MAX_SCROLL_STEP - 1) / MAX_SCROLL_STEP) ;
    }
    void GetSrcNDestRects(int iLine, int iCol, UINT16 wChar, int iSrcCrop,
                          int iDestOffset, RECT *prectSrc, RECT *prectDest) ;
    bool CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight,
                                int *piCharWidth, int *piCharHeight) ;
    bool SetOutputSize(LONG lWidth, LONG lHeight) ;
    void SetFontUpdate(bool bState)  { m_bUpdateFontCache = bState ; }
    bool IsFontReady(void) { return !m_bUpdateFontCache ; }
    DWORD GetAlphaFromBGColor(int iBitDepth) ;
    DWORD GetColorBitsFromBGColor(int iBitDepth) ;
} ;

#endif _INC_L21DDRAW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21decod.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Decoder Logic part
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"


//
//  CLine21DataDecoder class constructor: mainly init of members
//
CLine21DataDecoder::CLine21DataDecoder(AM_LINE21_CCSTYLE eStyle     /* = AM_L21_CCSTYLE_None */,
                                       AM_LINE21_CCSTATE eState     /* = AM_L21_CCSTATE_Off  */,
                                       AM_LINE21_CCSERVICE eService /* = AM_L21_CCSERVICE_None */)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CLine21DataDecoder()"))) ;
    
#ifdef PERF
    m_idTxt2Bmp = MSR_REGISTER(TEXT("L21DPerf - Text to CC bmp")) ;
    m_idBmp2Out = MSR_REGISTER(TEXT("L21DPerf - Bmp to Output")) ;
    m_idScroll  = MSR_REGISTER(TEXT("L21DPerf - Line Scroll")) ;
#endif // PERF

    InitState() ;
    
    // We separately set some of the passed in values
    SetCaptionStyle(eStyle) ;
}


CLine21DataDecoder::~CLine21DataDecoder(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::~CLine21DataDecoder()"))) ;
    
    // make sure the internal bitmap etc has been released and
    // allocated memory or other resources are not left un-released.
}

//
// Decoder state initializer; will be used also in filter's CompleteConnect()
//
void CLine21DataDecoder::InitState(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitState()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_pCurrBuff = NULL ;
    
    m_uFieldNum = 1 ;   // field 1 by default
    
    m_bRedrawAlways = FALSE ;  // someone has to be too picky/weird to do it!!
    m_eLevel = AM_L21_CCLEVEL_TC2 ;   // we are TC2 compliant
    m_eUserService = AM_L21_CCSERVICE_Caption1 ;   // CC is the default service
    m_eState = AM_L21_CCSTATE_On ;  // State is "On" by default

    FlushInternalStates() ;
}


void CLine21DataDecoder::FlushInternalStates(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::FlushInternalStates()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    InitCaptionBuffer() ;     // clear caption buffer
    SetRedrawAll(TRUE) ;      // redraw (no) caption on next Receive()
    SetScrollState(FALSE) ;   // turn off scrolling, just to be sure
    SetCaptionStyle(AM_L21_CCSTYLE_None) ;  // also sets m_pCurrBuff = NULL
    m_eLastCCStyle = AM_L21_CCSTYLE_None ;
    m_eDataService = AM_L21_CCSERVICE_None ;
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    m_uCurrFGEffect = 0 ;
    m_bExpectRepeat = FALSE ;
    m_chLastByte1 = 0 ;
    m_chLastByte2 = 0 ;

    m_L21DDraw.InitColorNLastChar() ;   // reset color etc.
}


BOOL CLine21DataDecoder::SetServiceState(AM_LINE21_CCSTATE eState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetServiceState(%lu)"), eState)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eState == m_eState)  // no change of state
        return FALSE ;       // no refresh to be forced
    
    m_eState = eState ;  // save the state for future decoding
    
    //
    // When service is turned off, we must clear the caption buffer(s) and
    // the internal DIB section so that old captions are not shown anymore.
    //
    if (AM_L21_CCSTATE_Off == m_eState)
    {
        FlushInternalStates() ;
		FillOutputBuffer() ; // just to clear any existing junk
        return TRUE ;        // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


BOOL CLine21DataDecoder::SetCurrentService(AM_LINE21_CCSERVICE eService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCurrentService(%lu)"), eService)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eService == m_eUserService)  // no change of service
        return FALSE ;               // no refresh to be forced
    
    m_eUserService = eService ;   // save the service the user wants
    
    //
    // When service "none" is selected (kind of "turn it off"), we must clear the 
    // caption buffer(s) and the internal DIB section so that old captions are 
    // not shown anymore.
    //
    if (AM_L21_CCSERVICE_None == m_eUserService)
    {
        FlushInternalStates() ;
		FillOutputBuffer() ; // just to clear any existing junk
        return TRUE ;        // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


//
//  Actual caption byte pair decoding algorithm
//
BOOL CLine21DataDecoder::DecodeBytePair(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeBytePair(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (AM_L21_CCSTATE_Off == m_eState)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Line21 data decoding turned off"))) ;
        return FALSE ;  // we actually didn't decode / generate anything
    }
    
    UINT uCodeType = CheckControlCode(chFirst, chSecond) ;
    if (L21_CONTROLCODE_INVALID != uCodeType)
    {
        // It's a control code (PAC / Mid row code / misc control code)
        return ProcessControlCode(uCodeType, chFirst, chSecond) ;
    }
    else if (IsSpecialChar(chFirst, chSecond))
    {
        // It's a special char represented by the second char
        return ProcessSpecialChar(chFirst, chSecond) ;
    }
    else
    {
        // If the 1st byte is in [0, F] then ignore 1st byte and print 2nd byte
        // as just a printable char
        BOOL  bResult = FALSE ;
        if (! ((chFirst &0x7F) >= 0x0 && (chFirst & 0x7F) <= 0xF) )
        {
            if (! ProcessPrintableChar(chFirst) )
                return FALSE ;
            bResult = TRUE ;
        }
        // If one of the two bytes decode right, we take it as a success
        bResult |= ProcessPrintableChar(chSecond) ;
        m_bExpectRepeat = FALSE ;  // turn it off now
        return bResult ;
    }
}


BOOL CLine21DataDecoder::UpdateCaptionOutput(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::UpdateCaptionOutput()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_L21DDraw.IsNewOutBuffer() ||            // if output buffer changed  OR
        (m_eCCStyle != AM_L21_CCSTYLE_PopOn  &&   // non-PopOn style (PopOn draws on EOC) AND
         IsCapBufferDirty()) ||                   // draw when dirty
        IsScrolling())                            // we are scrolling
    {
        OutputCCBuffer() ;     // output CC data from internal buffer to DDraw surface
        return TRUE ;          // caption updated
    }
    return FALSE ;  // no caption update
}


BOOL CLine21DataDecoder::IsPAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsPAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with control code list
    if ((0x10 <= chFirst  && 0x17 >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    if ((0x18 <= chFirst  && 0x1F >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::IsMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // first match with TO1 -> TO3 codes
    if ((0x21 <= chSecond && 0x23 >= chSecond)  &&
        (0x17 == chFirst  ||  0x1F == chFirst))
        return TRUE ;
    
    // Now match with the other misc control code
    if ((0x14 == chFirst  ||  0x15 == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x1C == chFirst  ||  0x1D == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;

    return FALSE ;
}


BOOL CLine21DataDecoder::IsMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // Now match with the mid row code list
    if ((0x11 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x19 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


UINT CLine21DataDecoder::CheckControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::CheckControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (IsPAC(chFirst, chSecond))
        return L21_CONTROLCODE_PAC ;
    
    if (IsMidRowCode(chFirst, chSecond))
        return L21_CONTROLCODE_MIDROW ;
    
    if (IsMiscControlCode(chFirst, chSecond))
        return L21_CONTROLCODE_MISCCONTROL ;
    
    DbgLog((LOG_TRACE, 3, TEXT("Not a control code"))) ;
    return L21_CONTROLCODE_INVALID ;
}


BOOL CLine21DataDecoder::IsSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Strip the parity bit before determining the service channel
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with special char list
    if (0x11 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    if (0x19 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::ValidParity(BYTE ch)
{
#if 1
    ch ^= ch >> 4 ;
    ch ^= ch >> 2 ;
    return (0 != (0x01 & (ch ^ (ch >> 1)))) ;
#else
    return TRUE ;
#endif
}


void CLine21DataDecoder::RelocateRollUp(UINT uBaseRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::RelocateRollUp(%u)"), uBaseRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
        return ;
    
    int  iMaxLines = GetMaxLines() ;
    int  iNumLines = GetNumLines() ;
    int  iMax ;
    if (m_bScrolling)  // during scrolling go for last but 1 line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d during scrolling"), uBaseRow)) ;
        if (iNumLines > iMaxLines)
        {
            DbgLog((LOG_TRACE, 3, TEXT("%d lines while max is %d"), iNumLines, iMaxLines)) ;
            iNumLines-- ;  // we don't set the row for the "not-yet-in" line
        }
        iMax = min(iNumLines, iMaxLines) ;
    }
    else               // otherwise go for the last line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d (not scrolling)"), uBaseRow)) ;
        iMax = min(iNumLines, iMaxLines) ;
    }
    for (int i = 0 ; i < iMax ; i++)
    {
        SetStartRow((UINT8)i, (UINT8)(uBaseRow - (iMax - 1 - i))) ;
        DbgLog((LOG_TRACE, 5, TEXT("RelocateRollUp(): Line %d @ row %d"), i, (int)(uBaseRow - (iMax - 1 - i)) )) ;
    }
}


BOOL CLine21DataDecoder::LineFromRow(UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::LineFromRow(%u)"), uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iLines ;
    
    // If we are in Roll-up mode then we shouldn't try to go through 
    // all the hassle of creating a new line etc. -- it's just a PAC 
    // to specify starting position and/or color; so just do that.
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // If the indentation PAC places cursor on an existing row
        
        int   iIndex ;
        iIndex = GetRowIndex((UINT8)uCurrRow) ;
        if (-1 == iIndex)    // some error encountered
            return FALSE ;   // fail decoding
        
        if (0 == iIndex)  // landed in a new row
        {
            iLines = GetNumLines() ;
            SetNewLinePosition(iLines, uCurrRow) ;
            SetRedrawLine((UINT8)iLines, TRUE) ;  // initially set line to be redrawn
        }
        else  // landed in an existing row
        {
            SetCurrLine(iIndex-1) ;  // -1 because row index map is 1-based (it has to be),
            // but the caption line index etc are all 0-based.
        }
        
        // We have to put the cursor at the 1st column
        SetCurrCol(0) ;   // no matter which line it is, go to 1st col (i.e, 0)
    }
    else  // in Roll-up mode
    {
        // If necessary, move entire caption so that the specified row 
        // becomes the new base row.
        iLines = GetNumLines() ;
        if ((int) uCurrRow < iLines)
        {
            ASSERT((int) uCurrRow < iLines) ;
            uCurrRow = (UINT) iLines ;
        }
        if (1 == iLines)  // if this is for the first line
        {
            SetStartRow(0, (UINT8)uCurrRow) ;  // also set the base row to start with
            DbgLog((LOG_TRACE, 5, TEXT("LineFromRow(): Line 0 @ row %u"), uCurrRow)) ;
        }
        else              // otherwise just move captions to the specified row
        {
            RelocateRollUp(uCurrRow) ;
            if (GetStartRow(iLines-1) == (int)uCurrRow)  // last line is at current row
                SetScrollState(FALSE) ;             // we should not scroll
            SetCapBufferDirty(TRUE) ; // caption buffer is dirty in a sense
            SetRedrawAll(TRUE) ;      // must be redrawn to show new position
        }
        
        DbgLog((LOG_TRACE, 3, TEXT("Base row for %d lines moved to %d"), iLines, uCurrRow)) ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodePAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodePAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int         iGroup ;
    UINT        uDiff ;
    UINT        uCurrRow ;
    UINT        uCurrCol ;
    UINT        uCol ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodePAC(): No CC style defined yet. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodePAC(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Turn off parity checking here
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now locate which of the two groups does 2nd byte belong, if at all!!
    if (chSecond >= 0x40 && chSecond <= 0x5F)
    {
        iGroup = 0 ;
        uDiff = chSecond - 0x40 ;
    }
    else if (chSecond >= 0x60 && chSecond <= 0x7F)
    {
        iGroup = 1 ;
        uDiff = chSecond - 0x60 ;
    }
    else   // invalid 2nd byte for PAC
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte for PAC"))) ;
        return FALSE ;
    }
    
    // Valid 2nd byte; now decide based on the 1st byte
    static UINT8 auPACtoRowMap[0x10] = {
        11,  1,  3, 12, 14,  5,  7,  9, 11,  1,  3, 12, 14,  5,  7,  9  // row
     // 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F  // PAC byte 1
    } ;
    
    if (chFirst >= 0x10  &&  chFirst <= 0x1F)
    {
        // the row number is 1 more if the 2nd byte is in the 60-7F group
        uCurrRow = auPACtoRowMap[chFirst - 0x10] + iGroup  ;
        
        // Now see what happens with the new row specified, if any, in the PAC
        LineFromRow(uCurrRow) ;
    }
    else
    {
        DbgLog((LOG_TRACE, 2, TEXT("Invalid mid-row code in 1st byte"))) ;
        return FALSE ;
    }
    
    // some final decisions...
    m_uCurrFGEffect = 0 ;  // clear all effects as a result of PAC processing
    if (uDiff <= 0x0D)  // color (and underline) spec
        m_uCurrFGColor = uDiff >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
    else if (uDiff <= 0x0F)  // 0E, 0F == italics (and underline) spec
    {
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;  // 0
    }
    else  // 10 -> 1F == indent (and underline) spec (no other way)
    {
        // 50 (70) => 0, 52 (72) => 4 etc.
        // last bit of 2nd char determines underline or not
        uCurrCol = ((uDiff - 0x10) & 0xFE) << 1 ;
        if (uCurrCol >= MAX_CAPTION_COLUMNS)
            uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
        
            /*
            int  iCurrLine = GetCurrLine() ;
            if (0 == GetNumCols(iCurrLine)) // if it's a tab indent on clean line
            {
            SetStartCol(iCurrLine, uCurrCol) ; // set start column as spec-ed
            SetCurrCol(0) ;             // and current col to 0
            }
            else if ((uCol = GetStartCol(iCurrLine)) > uCurrCol)  // existing line
            {
            // insert null spaces before currently existing chars as filler
            // (that adjusts the number of chars value too)
            MoveCaptionChars(iCurrLine, uCol - uCurrCol) ;
            SetStartCol(iCurrLine, uCurrCol) ;
            SetCurrCol(0) ;
            }
            else
            SetCurrCol(uCurrCol) ;
        */
        SetCurrCol((UINT8)uCurrCol) ;
        
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    }
    
    // at last check underline bit
    if (uDiff & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    
    return TRUE ;   // done at last!!!
}


BOOL CLine21DataDecoder::DecodeMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BYTE        uValue ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodeMidRowCode(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
    
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodeMidRowCode(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (chSecond < 0x20  ||  chSecond > 0x2F)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Invalid mid-row code in 2nd byte"))) ;
        return FALSE ;
    }
    uValue = chSecond - 0x20 ;
    if (uValue & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    if (chSecond < 0x2E)   // only color specs
    {
        m_uCurrFGColor = uValue >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_ITALICS ;  // color turns off italics
    }
    else   // 2nd byte is 0x2E or 0x2F, i.e, italics specified
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
    
    // finally, mid-row code introduces a blank space
    PutCharInBuffer(0x20, TRUE) ;  // mark it as MRC too
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodeMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BOOL        bResult ;
    
    switch (chFirst)
    {
        // case 0x15:
        // case 0x1D:
        //     m_uField = 2 ;   // the data is coming in Field 2
        
    case 0x14:      // misc control code -- channel 1
    case 0x1C:      // ditto -- channel 2
        switch (chSecond)
        {
        case 0x20:   // RCL: Resume Caption Loading
            bResult = HandleRCL(chFirst, chSecond) ;
            break ;
            
        case 0x21:   // BS:  Backspace
            bResult = HandleBS(chFirst, chSecond) ;
            break ;
            
        case 0x22:   // AOF: reserved
        case 0x23:   // AOF: reserved
            DbgLog((LOG_ERROR, 2, TEXT("AOF/AON as Misc ctrl code"))) ;
            return TRUE ;  // just ignore it
            
        case 0x24:   // DER: Delete to End of Row
            bResult = HandleDER(chFirst, chSecond) ;
            break ;
            
        case 0x25:   // RU2: Roll-Up Captions - 2 rows
        case 0x26:   // RU3: Roll-Up Captions - 3 rows
        case 0x27:   // RU4: Roll-Up Captions - 4 rows
            bResult = HandleRU(chFirst, chSecond, 2 + chSecond - 0x25) ;
            break ;
            
        case 0x28:   // FON: Flash On
            bResult = HandleFON(chFirst, chSecond) ;
            break ;
            
        case 0x29:   // RDC: Resume Direct Captioning
            bResult = HandleRDC(chFirst, chSecond) ;
            break ;
            
        case 0x2A:   // TR:  Text Restart
            bResult = HandleTR(chFirst, chSecond) ;
            break ;
            
        case 0x2B:   // RTD: Resume Text Display
            bResult = HandleRTD(chFirst, chSecond) ;
            break ;
            
        case 0x2C:   // EDM: Erase Displayed Memory
            bResult = HandleEDM(chFirst, chSecond) ;
            break ;
            
        case 0x2D:   // CR:  Carriage Return
            bResult = HandleCR(chFirst, chSecond) ;
            break ;
            
        case 0x2E:   // ENM: Erase Non-displayed Memory
            bResult = HandleENM(chFirst, chSecond) ;
            break ;
            
        case 0x2F:   // EOC: End of Caption (flip memories)
            bResult = HandleEOC(chFirst, chSecond) ;
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                chSecond, chFirst)) ;
            return FALSE ;
        }  // end of switch (chSecond)
        break ;
        
        case 0x17:      // misc control code -- channel 1
        case 0x1F:      // ditto -- channel 2
            switch (chSecond)
            {
            case 0x21:   // TO1: Tab Offset 1 column
            case 0x22:   // TO2: Tab Offset 2 columns
            case 0x23:   // TO3: Tab Offset 3 columns
                bResult = HandleTO(chFirst, chSecond, 1 + chSecond - 0x21) ;
                break ;
                
            default:
                DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                    chSecond, chFirst)) ;
                return FALSE ;
            }  // end of switch (chSecond)
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 1st byte for Misc ctrl code"))) ;
            return FALSE ;
    }  // end of switch (chFirst)
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
        DbgLog((LOG_TRACE, 2, TEXT("No CC style defined yet."))) ;
    else
        DbgLog((LOG_TRACE, 3, TEXT("CC style defined now (%d)."), m_eCCStyle)) ;
    
    return bResult ;  // return result of handling above
}


BOOL CLine21DataDecoder::ProcessSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Table of special char Unicode values for Truetype font (Lucida Console)
    static UINT16 awSplCharTT[] = {
     0x00ae,    0x00b0,    0x00bd,    0x00bf,    0x2122,    0x00a2,    0x00a3,    0x266b,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x00e0,    0x0000,    0x00e8,    0x00e2,    0x00ea,    0x00ee,    0x00f4,    0x00fb } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    // Table of special char for non-Truetype font (Terminal) [alternate chars]
    static UINT16 awSplCharNonTT[] = {
     0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x0041,    0x0000,    0x0045,    0x0041,    0x0045,    0x0049,    0x004f,    0x0055 } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("ProcessSpecialChar(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
                
    if (m_eDataService != m_eUserService)
    {           
        DbgLog((LOG_TRACE, 3, TEXT("Special char for diff channel (%d)"), (int)m_eDataService)) ;
        return TRUE ;  // ??
    }
                
    // Check if it's a repeat of the last special. If so ignore it; else print it.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the spl char; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
                    
        // Otherwise we got a different spl char pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this spl char pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
                
    //  This pair of bytes may be valid. So we need to remember them to check
    //  against the next such pair for a repeat (of spl chars).
    //  BTW, we store the bytes only after the parity bit is stripped.
    m_chLastByte1 = chFirst & 0x7F ;
    m_chLastByte2 = chSecond & 0x7F ;
                
    ASSERT((chSecond & 0x7F) >= 0x30  &&  (chSecond & 0x7F) <= 0x3F) ;
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 3, TEXT("Bad parity for character <%d>"), chSecond)) ;
        ProcessPrintableChar(0x7F) ;  // put special char solid block (7F)
    }
    else
    {
        if (m_L21DDraw.IsTTFont())
            PutCharInBuffer(awSplCharTT[(chSecond & 0x7F) - 0x30]) ;
        else
            PutCharInBuffer(awSplCharNonTT[(chSecond & 0x7F) - 0x30]) ;
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::ProcessControlCode(UINT uCodeType,
                                            BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
            TEXT("CLine21DataDecoder::ProcessControlCode(%u, 0x%x, 0x%x)"), 
            uCodeType, chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // Make sure that the pair has valid parity bits
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair -- ignoring pair"), chSecond)) ;
        return FALSE ;
    }
    
    BOOL  bSuccess = TRUE ;
    if (! ValidParity(chFirst) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair"), chFirst)) ;
        if (m_bExpectRepeat)  // if 2nd transmission of control code
        {
            if ((chSecond & 0x7F) == m_chLastByte2)  // we got the same 2nd byte
            {
                // most likely it's the retransmission garbled up -- ignore them
            }
            else   // different 2nd byte; just print it.
                bSuccess = ProcessPrintableChar((chSecond & 0x7F)) ;
            
            // Turn it off -- either 2nd byte matched => retransmit of control code
            //                or printed 2nd byte as a printable char
            m_bExpectRepeat = FALSE ;
        }
        else  // if 1st transmission of control code
        {
            bSuccess = ProcessPrintableChar(0x7F) && 
                ProcessPrintableChar((chSecond & 0x7F)) ;
        }
        return bSuccess ;
    }
    
    // Check if it's a repeat of the last control code. If so ignore it; else
    // set it so.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the control code; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
        
        // Otherwise we got a different control code pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this control code pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
    
    //  Looks like this pair of bytes is going to be valid and at least has
    //  valid (odd) parity bits set.  So we need to remember them to check
    //  against the next such pair for a repeat (of control codes).
    //  BTW, we store the bytes only after the parity bit is stripped.
    
    chFirst = chFirst & 0x7F ;
    chSecond = chSecond & 0x7F ;
    
    m_chLastByte1 = chFirst ;
    m_chLastByte2 = chSecond ;
    
    switch (uCodeType)
    {
    case L21_CONTROLCODE_PAC:
        return DecodePAC(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MIDROW:
        return DecodeMidRowCode(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MISCCONTROL:
        return DecodeMiscControlCode(chFirst, chSecond) ;
        
    default:
        DbgLog((LOG_TRACE, 1, TEXT("Invalid code type (%u)"), uCodeType)) ;
        return FALSE ;  // not a control code
    }
}


BOOL CLine21DataDecoder::ProcessPrintableChar(BYTE ch)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessPrintableChar(%x)"), ch)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Printable char (?) for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("ProcessPrintableChar(): No CC style defined yet. Skipping..."))) ;
        return FALSE ;
    }
    
    if (! IsStandardChar(ch & 0x7F) )
    {
        DbgLog((LOG_TRACE, 3, TEXT("Not a printable char."))) ;
        return FALSE ;
    }
    
    if (! ValidParity(ch) )  // if a printable char doesn't have valid parity
    {
        DbgLog((LOG_TRACE, 1, TEXT("Bad parity for (probably) printable char <%d>"), ch)) ;
        ch = 0x7F ;            // then replace it with 7Fh.
    }
    
    //
    // There is more twist to it than you think!!! Some special chars
    // are inside the standard char range.
    //
    BOOL  bResult = FALSE ;
    switch (ch & 0x7F)  // we only look at the parity-less bits
    {
        case 0x2A:  // lower-case a with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00e1) ;
            else   // no TT font -- use 'A' as alternate char
                bResult = PutCharInBuffer(0x0041) ;
            break ;

        case 0x5C:  // lower-case e with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00e9) ;
            else   // no TT font -- use 'E' as alternate char
                bResult = PutCharInBuffer(0x0045) ;
            break ;

        case 0x5E:  // lower-case i with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00ed) ;
            else   // no TT font -- use 'I' as alternate char
                bResult = PutCharInBuffer(0x0049) ;
            break ;

        case 0x5F:  // lower-case o with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00f3) ;
            else   // no TT font -- use 'O' as alternate char
                bResult = PutCharInBuffer(0x004f) ;
            break ;

        case 0x60:  // lower-case u with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00fa) ;
            else   // no TT font -- use 'U' as alternate char
                bResult = PutCharInBuffer(0x0055) ;
            break ;

        case 0x7B:  // lower-case c with cedilla
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00e7) ;
            else   // no TT font -- use 'C' as alternate char
                bResult = PutCharInBuffer(0x0043) ;
            break ;

        case 0x7C:  // division sign
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00f7) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        case 0x7D:  // upper-case N with tilde
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00d1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7E:  // lower-case n with tilde
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00f1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7F:  // solid block
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x2588) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        default:
            bResult = PutCharInBuffer(MAKECCCHAR(0, ch & 0x7F)) ;
            break ;
    }
    return bResult ;
}


BOOL CLine21DataDecoder::PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode /* = FALSE */)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::PutCharInBuffer(0x%x, %u)"), wChar, bMidRowCode)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Make sure we have got a PAC or MidRow code specifying our row posn
    // thereby creating a line in which the in param char is going to be put.
    if (0 == GetNumLines())
        return FALSE ;
    
    int          i ;
    CCaptionChar cc ;
    
    cc.SetChar(wChar) ;
    cc.SetColor((UINT8)m_uCurrFGColor) ;
    //
    // If this char is a mid-row code (which is shown as blank in CC) then don't
    // set the underline (mainly) or italicized/flashing attrib for it, because 
    // a space should not (or need not) be shown with such attribs.  We skip the 
    // effect bits altogether for such chars.
    //
    if (bMidRowCode)
        cc.SetEffect(0) ;
    else
        cc.SetEffect((UINT8)m_uCurrFGEffect) ;
    cc.SetMidRowCode(bMidRowCode) ;
    
    i = GetCurrLine() ;
    int  iCurrCol = GetCurrCol() ;
    SetCaptionChar((UINT8)i, (UINT8)iCurrCol, cc) ;
    //
    // If we are overwriting existing chars, the # chars doesn't increase...
    //
    int  iNumCols = GetNumCols(i) ;
    if (iCurrCol >= iNumCols)  // increment # chars by the differenece
        IncNumChars(i, iCurrCol-iNumCols+1) ;
    IncCurrCol(1) ;  // ...but current column goes up anyway.
    
    SetCapBufferDirty(TRUE) ;  // some new caption char added -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRCL(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRCL(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to PopOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn  == m_eCCStyle)    // if already in pop-on mode...
        return TRUE ;                           // ... just ignore
    
    // decodes subsequent chars for pop-on into the non-displayed buffer, 
    // but doesn't affect currently displayed caption
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ; // gets CapBuffer address based on index
    
    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleBS(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleBS(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Backspace for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Backspace for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Backspace for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    UINT  uCurrCol = GetCurrCol() ;
    if (0 == uCurrCol)   // no place to back up anymore
        return TRUE ;
    
    int  iLine = GetCurrLine() ;
    int  n ;
    if (MAX_CAPTION_COLUMNS - 1 == uCurrCol) // at last col
    {
        n = 2 ;  // erase 2 chars (?)
    }
    else   // in the middle of a row
    {
        n = 1 ;
    }
    SetCurrCol(uCurrCol - n) ;
    RemoveCharsInBuffer(n) ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleDER(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleDER(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // delete as many as you can
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRU(BYTE chFirst, BYTE chSecond, int iLines)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRU(%u, %u, %d)"),
            chFirst, chSecond, iLines)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to RU%d of non-selected service. Skipping..."), iLines)) ;
        return TRUE ;  // ??
    }

    int iNumLines = 0 ;
    int iBaseRow  = 0 ;
    
    // Check if the current style is Roll-up
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // Now set up for roll-up captioning
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_RollUp) ;
        iNumLines = IncNumLines(1) ;    // create the 1st line
        DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): Increasing lines by 1 to %d"), iLines, iNumLines)) ;
        iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        SetCurrCol(0) ;                 // start at beginning of line
    }
    else  // already in Roll-up mode; don't clear buffer, re-use current base row etc.
    {
        // if the current roll-up window height is more than the one
        // newly specified then remove the extra lines from the top
        iNumLines = GetNumLines() ;
        for (int i = 0 ; i < iNumLines - iLines ; i++)
            MoveCaptionLinesUp() ;
        
        //
        // If we remove even one line from the top, we must not be scrolling
        // anymore, for now.
        //
        if (iNumLines > iLines)
		{
			DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,): %d lines reduced to %d"), iNumLines, iLines)) ;
            SetScrollState(FALSE) ;
			iNumLines = iLines ;
		}
        
        if (iNumLines > 0)  // if we have lines from prev roll-up session
        {
            // save the prev base row value as it's the default base row next
			DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): %d lines"), iLines, iNumLines)) ;
            iNumLines = min(iNumLines, iLines) ;
            iBaseRow = GetStartRow(iNumLines-1) ;
            if (0 == iBaseRow)  // a weird case -- we must patch to continue
            {
			    DbgLog((LOG_TRACE, 3, TEXT("HandleRU(,,%d): iBaseRow = 0.  Patch now!!!"), iLines)) ;

                // Detect the first line with non-zero row number
                int  i ;
                for (i = iNumLines ; i > 0 && 0 == iBaseRow ; i--)
                {
                    iBaseRow = GetStartRow(i-1) ;
                }
                if (0 == iBaseRow)  // still, probably it's only one (new) line
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Base row for %d lines forced set to 15"), iNumLines)) ;
                    iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
                }

                // In case we don't have room for everyone, move the current lines up
                // and adjust the base row value. This will fix any bad row numbers.
                if (iBaseRow + (iLines - iNumLines) > MAX_CAPTION_ROWS)
                {
                    iBaseRow = MAX_CAPTION_ROWS - (iLines - iNumLines) ;
                    RelocateRollUp(iBaseRow) ;
                }
            }  // end of if (0 == iBaseRow)
			DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): base row = %d"), iLines, iBaseRow)) ;
        }
        else  // we were in Roll-up mode, but a EDM came just before the RUx
        {
            // Almost starting from scratch
            iNumLines = IncNumLines(1) ;    // create the 1st line
            DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): Increasing lines from 0 to %d"), iLines, iNumLines)) ;
            iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        }

        // Don't change the current column location.
    }
    
    // Set the new values to start with
    SetMaxLines(iLines) ;
    SetCurrLine(iNumLines-1) ;  // or iLines-1??
    SetStartRow((UINT8)(iNumLines-1), (UINT8)iBaseRow) ;
    DbgLog((LOG_TRACE, 5, TEXT("HandleRU(): Line %d @ row %d"), iNumLines-1, iBaseRow)) ;
    SetRedrawLine(iNumLines-1, TRUE) ;  // by default new line is to be redrawn
    
    SetRedrawAll(TRUE) ;      // redraw the whole caption
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleFON(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleFON(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("FlashOn for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("FlashOn for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("FlashOn for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    m_uCurrFGEffect |= AM_L21_FGEFFECT_FLASHING ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRDC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRDC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to PaintOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PaintOn == m_eCCStyle)   // if already in paint-on mode...
        return TRUE ;                           // ... just ignore
    
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PaintOn) ;

    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


//
// I am not sure what the Text Restart command is supposed to do. But it "sounds
// like" something to do with the text1/2 channels which we don't support now.
//
BOOL CLine21DataDecoder::HandleTR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRTD(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRTD(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEDM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEDM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an EDM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Erase DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    CCaptionBuffer *pDispBuff ;

    // next redraw will show blank caption for non-PopOn style ONLY
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_RollUp:
        SetScrollState(FALSE) ;  // not scrolling now at least
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PaintOn:
        // when display memory is cleared, the attribs should be cleared too
        m_uCurrFGEffect = 0 ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PopOn:
        pDispBuff = GetDisplayBuffer() ;
        ASSERT(pDispBuff) ;
        if (pDispBuff)
            pDispBuff->ClearBuffer() ;
        pDispBuff->SetRedrawAll(TRUE) ;
        break ;
    }
    
    //
    // To clear the screen content we should clear internal DIB section which
    // will in turn cause a (clear) sample to be output erasing currently
    // displayed CC.
    //
    m_L21DDraw.FillOutputBuffer() ;

    return TRUE ;
}


void CLine21DataDecoder::SetNewLinePosition(int iLines, UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetNewLinePosition(%d, %u)"), 
            iLines, uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iMaxLines = GetMaxLines() ;
    
    // Check if scroll up is needed or not
    if (iLines >= iMaxLines)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Too many lines. Locate and remove one blank line."))) ;
        
        if (AM_L21_CCSTYLE_RollUp == m_eCCStyle)  // if in roll-up mode
        {
            // We shouldn't be here at all. Anyway, complain and remove the top line.
            DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: How do we have too many lines in roll-up mode (%d vs. max %d)?"),
                iLines, iMaxLines)) ;
            ASSERT(FALSE) ;  // so that we don't miss it
            RemoveLineFromBuffer(0, TRUE) ; // move line #2 onwards up
            iLines-- ;
        }
        else  // non Roll-up mode
        {
            // See if there is a blank line. If so, remove it to make space
            for (int i = 0 ; i < iLines ; i++)
            {
                if (GetNumCols(i) == 0)
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Found line #%d (1-based) blank -- removed."), i+1)) ;
                    RemoveLineFromBuffer((UINT8)i, FALSE) ; // just remove line; don't move up following lines
                    iLines-- ;
                    break ;    // got one line -- enough.
                }
            }
            
            // HACK HACK: This should never happen, but....
            // If the number of lines is still too many, just overwrite the 
            // last line (Is that good?? Oh well...)
            if ((iLines = GetNumLines()) >= iMaxLines)  // too many lines
            {
                DbgLog((LOG_ERROR, 1, TEXT("ERROR: Too many lines. Removing last line by force."))) ;
                RemoveLineFromBuffer(iLines-1, FALSE) ; // just remove the line
                iLines-- ;  // one less line
                SetCurrCol(0) ;  // we start at the beginning on the line
            }
        }
    }
    
    // Now we have to add a new line and set it up
    int iNum = IncNumLines(1) ;
    DbgLog((LOG_TRACE, 5, TEXT("SetNewLinePosition(): Increasing lines by 1 to %d"), iNum)) ;
    SetCurrLine((UINT8)iLines) ;
    SetStartRow((UINT8)iLines, (UINT8)uCurrRow) ;
    DbgLog((LOG_TRACE, 5, TEXT("SetNewLinePosition(): Line %d @ row %u"), iLines, uCurrRow)) ;
}


BOOL CLine21DataDecoder::HandleCR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleCR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Is it only allowed in roll-up style?  I think so based on the docs.
    
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_PaintOn:
        DbgLog((LOG_ERROR, 1, TEXT("INVALID: CR in Pop-on/Paint-on mode!!!"))) ;
        break ;  // or return FALSE ; ???
        
    case AM_L21_CCSTYLE_RollUp:  // This is the real one
        {
            int iRow ;
            int iLines = GetNumLines() ;
            if (0 == iLines)  // no CC line yet -- this is 1st line's data
            {
                iRow = MAX_CAPTION_ROWS ;  // base line's default row position
				SetStartRow((UINT8)iLines, (UINT8)iRow) ;
                DbgLog((LOG_TRACE, 5, TEXT("HandleCR(): Line %d @ row %d"), iLines, iRow)) ;
            }
            else if (1 == iLines)  // there is only 1 line so far
            {
                if (0 == GetNumCols(0))  // blank 1st line
                {
                    RemoveLineFromBuffer(0, TRUE) ; // remove blank 1st line
                    iLines = 0 ;                    // no line left

                    DbgLog((LOG_TRACE, 5, TEXT("Only blank line removed. Base line set to 15."))) ;
                    // HACK HACK
                    iRow = MAX_CAPTION_ROWS ;  // base line's default row position
				    SetStartRow((UINT8)iLines, (UINT8)iRow) ;
                }
            }
            else  // there are multiple lines already
            {
                // iRow = GetStartRow(iLines-1) + 1 ;  // +1 to go under last line
                if (m_bScrolling)
                {
                    SkipScrolling() ;
                    iLines = GetNumLines() ;  // we might have scrolled top line off
                }
            }
            if (iLines > 0)  // only if we already have a non-blank line
                SetScrollState(TRUE) ;  // ready to scroll
            iLines = IncNumLines(1) ;
            DbgLog((LOG_TRACE, 5, TEXT("HandleCR(): Increasing lines by 1 to %d"), iLines)) ;

            //
            // Number of lines is 1 more than iLines now. So iLines actually
            // points to the last line as a 0-based index.
            //
            SetCurrLine((UINT8)iLines-1) ;
            SetRedrawLine((UINT8)iLines-1, TRUE) ;  // new line always to be redrawn
            SetCurrCol(0) ;
            
            // Make sure to give up all the display attributes and chars 
            // for new row
            // RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // should we or let it be cleared by a DER?
            m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
            m_uCurrFGEffect = 0 ;  // no effect until a PAC/MRC comes
            
            break ;
        }
        
    default:  // Weird!! How did we come here?
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: CR came for unknown mode"))) ;
        break ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleENM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleENM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an ENM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in non-display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Erase non-DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    // Meant only for Pop-on style back back -- clear non-displayed buffer; 
    // display not affected until EOC
    m_aCCData[1 - GetBufferIndex()].ClearBuffer() ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEOC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEOC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to PopOn mode of non-selected channel. skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)  // already in pop-on; flip buffers
    {
        OutputCCBuffer() ;   // output CC data from internal buffer to DDraw surface
        SwapBuffers() ;      // switch 0, 1
        //
        // Also need to update m_pCurrBuff so that we point to
        // the correct one after the above swap.
        // (m_pCurrBuff is set in SetCaptionStyle()).
        //
    }
    else   // change to pop-on style
    {
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ;
    }

    // Update current buffer pointer based on style and buffer index
    m_pCurrBuff = GetCaptionBuffer() ;
    ASSERT(m_pCurrBuff) ;
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(TRUE) ;  // we should redraw the whole caption now
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleTO(BYTE chFirst, BYTE chSecond, int iCols)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTO(%u, %u, %d)"),
            chFirst, chSecond, iCols)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for same data and user channel"), iCols)) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x17 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
        return TRUE ;  // ??
    }
    
    UINT8  uCurrCol  = (UINT8)GetCurrCol() ;
    uCurrCol += (UINT8)iCols ;
    if (uCurrCol >= MAX_CAPTION_COLUMNS)
        uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    SetCurrCol(uCurrCol) ;
    
    return TRUE ;
}


//
// It checks as well as *updates* the number of chars in a line of caption
//
BOOL CLine21DataDecoder::IsEmptyLine(int iLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IsEmptyLine(%ld)"), iLine)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    CCaptionChar*   pcc ;
    int  iNumChars = GetNumCols(iLine) ;
    BOOL bResult = TRUE ;
    int  i ;
    for (i = iNumChars - 1 ; i >= 0 ; i--) // going backwards (-1 due to 0-based index)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)i) ;
        ASSERT(pcc) ;
        if (pcc  &&  pcc->GetChar() != 0)  // got one
        {
            bResult = FALSE ;
            break ;  // enough
        }
    }

    if ( !bResult ) // only if there is some chars left on this line
        DecNumChars(iLine, iNumChars - (i + 1)) ;  // reduce # chars by the diff

    return bResult ;
}


BOOL CLine21DataDecoder::RemoveCharsInBuffer(int iNumChars)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::RemoveCharsInBuffer(%d)"), iNumChars)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int          i, j, k, n ;
    CCaptionChar cc ;
    
    // Just to be sure, check a few things first
    if (GetNumLines() == 0 ||   // no line to delete from
        (n = GetNumCols(GetCurrLine())) == 0)      // no char on current line to delete
        return TRUE ;           // we are done!!
    
    // Prepare the replacement caption char
    cc.SetChar(0) ;  // 0 is transparent space
    cc.SetColor(AM_L21_FGCOLOR_WHITE) ;
    cc.SetEffect(0) ;
    cc.SetDirty(TRUE) ;
    
    // Find the location to clear
    i = GetCurrLine() ;
    j = GetCurrCol() ;
    
    // Check that we are not trying to delete too many chars.
    // Remember: current col + # chars to delete <= MAX.
    if (iNumChars + j > MAX_CAPTION_COLUMNS)  // try it and see!!!
        iNumChars = MAX_CAPTION_COLUMNS - j ;
    
    // Clear the necessary chars
    for (k = 0 ; k < iNumChars ; k++)
    {
        if (j + k < n)          // if a char before the last char is removed, ...
            DecNumChars(i, 1) ; // ... reduce # chars by 1
        SetCaptionChar((UINT8)i, (UINT8)(j+k), cc) ;
    }
    
    if (0 == GetNumCols(i) ||  // # chars left on this line is 0  OR
        IsEmptyLine(i))        // no non-transparent chars on this line
        RemoveLineFromBuffer((UINT8)i, FALSE) ; // delete the line from buffer
    else                     // something left -- so redraw line
        SetRedrawAll(TRUE) ; // I really hate to do it, but I couldn't find a better way
    
    SetCapBufferDirty(TRUE) ;  // some caption char(s) removed
    
    return TRUE ;
}

void CLine21DataDecoder::SkipScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SkipScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int iLines = GetNumLines() ;
    SetScrollState(FALSE) ;    // we are no more scrolling
    
    if (iLines > GetMaxLines())  // too many line; remove top line
    {
        // remove the first text line and move subsequent lines up by one
        DbgLog((LOG_TRACE, 3, TEXT("Top line is being scrolled out"))) ;
        MoveCaptionLinesUp() ;
    }
    else   // otherwise move the line(s) up by a row and bring in new line
    {
        iLines-- ;   // last but one line is at base row
        UINT uBaseRow = GetStartRow(iLines-1) ;
        DbgLog((LOG_TRACE, 3, TEXT("Scrolling all lines up by 1 row"))) ;
        // The following call moves all the line up by including the not-yet-in 
        // line at the base row
        RelocateRollUp(uBaseRow) ;  // move all lines one row higher
    }
}


int CLine21DataDecoder::IncScrollStartLine(int iCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IncScrollStartLine(%d)"), 
            iCharHeight)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0 == m_iScrollStartLine)  // starting to scroll
        MSR_START(m_idScroll) ;

    m_iScrollStartLine += m_L21DDraw.GetScrollStep() ;
    if (m_iScrollStartLine >= iCharHeight)
    {
        // Scrolling one line is done -- do the standard end of scroll stuff
        SkipScrolling() ;
        MSR_STOP(m_idScroll) ;  // scrolling ended
    }
    
    return m_iScrollStartLine ;
}


void CLine21DataDecoder::SetScrollState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetScrollState(%s)"), 
            bState ? TEXT("TRUE") : TEXT("FALSE"))) ;

    if (bState)                      // if turning ON scrolling
    {
        if (!m_bScrolling)           // change scroll line only if NOT scrolling now
            m_iScrollStartLine = 0 ; // start from first line
    }
    else                             // turning if OFF
        m_iScrollStartLine = 0 ;     // back to the start line

    m_bScrolling = bState ;          // set the spec-ed scrolling state
}


void CLine21DataDecoder::MoveCaptionLinesUp(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::MoveCaptionLinesUp()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    RemoveLineFromBuffer(0, TRUE) ; // remove the top line from buffer
    SetCapBufferDirty(TRUE) ;       // a line of text removed -- buffer dirty
}


void CLine21DataDecoder::CompleteScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CompleteScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // For now we are doing a really cheapo solution, but it may work.
    if (m_bScrolling)
        SkipScrolling() ;
}


bool CLine21DataDecoder::OutputCCLine(int iLine, int iDestRow, 
                                      int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::OutputCCLine(%d,%d,%d,%d)"), 
            iLine, iDestRow, iSrcCrop, iDestOffset)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int           c ;
    int           j ;
    CCaptionChar *pcc ;
    BOOL          bRedrawAll ;
    BOOL          bRedrawLine ;
    BOOL          bXparentSpace ;
    UINT16        wChar ;

#ifdef DUMP_BUFFER
    TCHAR    achTestBuffer[MAX_CAPTION_COLUMNS+5] ;
    int     iTest = 0 ;
#endif // DUMP_BUFFER

    c = GetNumCols(iLine) ;
    if (0 == c)        // if there is no char on a line, skip drawing it
        return true ;  // line drawing didn't fail

    bRedrawAll = IsRedrawAll() || m_L21DDraw.IsNewOutBuffer() ;

    // Redraw line if 
    // 1) redraw all flag is set   Or
    // 2) redraw line flag is set
    bRedrawLine = bRedrawAll || IsScrolling() || IsRedrawLine((UINT8)iLine) ;

    // First skip all the leading transparent spaces and then draw
    // the leading space.
    for (j = 0 ; j < c ; j++)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)j) ;
        if (pcc  &&  0 != pcc->GetChar())
        {
            // Add a leading blank space for each caption line, if either
            // a) the whole line is being redrawn   OR
            // b) the non-transparent space char is dirty so that
            //    the char will be drawn on top of the next space.
            if (bRedrawLine || pcc->IsDirty())
                m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, j, iSrcCrop, iDestOffset) ;
            break ;
        }
#ifdef DUMP_BUFFER
        // ` (back quote) => transparent space for debug output
        achTestBuffer[iTest] = TEXT('`') ;
        iTest++ ;
#endif // DUMP_BUFFER
    }
    
    bXparentSpace = FALSE ;  // new line => no transparent char issue
    
    // Now print the dirty chars for the current line of caption
    for ( ; j < c ; j++)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)j) ;
        if (NULL == pcc)
        {
            ASSERT(!TEXT("Got bad pointer to CC char")) ;
            continue ;  // proceed to the next char
        }
        wChar = pcc->GetChar() ;
#ifdef DUMP_BUFFER
        // ` (back quote) => transparent space for debug output
        achTestBuffer[iTest] = wChar == 0 ? TEXT('`') : (TCHAR)(wChar & 0x7F) ;  // dump higher byte
        iTest++ ;
#endif // DUMP_BUFFER
        
        // We draw a char only if we have to, i.e,
        // 1) all the caption chars on the line has to be drawn fresh
        //    Or
        // 2) if a char has changed
        // This saves a lot of time doing ExtTextOut()s.
        if (bRedrawLine || pcc->IsDirty())
        {
            if (0 == wChar)  // got transparent space; set flag, don't draw
                bXparentSpace = TRUE ;
            else  // not transparent space
            {
                if (bXparentSpace)  // leading blank after transparent space
                {
                    // To draw 1 col behind, don't add 1 to j
                    m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, j, iSrcCrop, iDestOffset) ;
                    bXparentSpace = FALSE ;  // it's done
                }
                m_L21DDraw.WriteChar(iDestRow, j+1, *pcc, iSrcCrop, iDestOffset) ;  // add 1 to j for CC chars
            }
            pcc->SetDirty(FALSE) ;   // char no more dirty
        }
    }  // end of for (j) loop

    // Draw a trailing blank space at line end
    m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, c+1, iSrcCrop, iDestOffset) ;

    // Whether the line needed to be redrawn or not, let's clear it now
    SetRedrawLine((UINT8)iLine, FALSE) ;
    
#ifdef DUMP_BUFFER
    achTestBuffer[iTest] = 0 ;
    DbgLog((LOG_TRACE, 0, TEXT("    <%s>"), achTestBuffer)) ;
    // iTest = 0 ;  // for next line
#endif // DUMP_BUFFER
        
    return true ;  // success
}


bool CLine21DataDecoder::OutputBlankCCLine(int iLine, int iDestRow, 
                                           int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::OutputBlankCCLine(%d,%d,%d,%d)"), 
            iLine, iDestRow, iSrcCrop, iDestOffset)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int c = GetNumCols(iLine) ;  // find out (prev) line's length
    if (0 == c)
        return true ;

    // First skip all the leading transparent spaces and then draw
    // the leading space.
    CCaptionChar *pcc ;
    for (int j = 0 ; j < c ; j++)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)j) ;
        if (pcc  &&  0 != pcc->GetChar())
        {
            // Add a leading blank space for each caption line
            m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, j, iSrcCrop, iDestOffset) ;
            break ;
        }
    }

    m_L21DDraw.WriteBlankCharRepeat(iDestRow, j+1, c-j, iSrcCrop, iDestOffset) ;

    m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, c+1, iSrcCrop, iDestOffset) ;

    return true ;  // success
}


bool CLine21DataDecoder::OutputCCBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::OutputCCBuffer()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Output the CC data, based on the associated attributes, from the internal
    // buffer to the output buffer.
    int    i ;
    int    iNumLines ;
    int    iMaxLines ;
    int    iMax ;
    BOOL   bRedrawAll ;
    BOOL   bDrawNormal = FALSE ;   // draw whole CC normally (no scrolling)?

#ifdef DUMP_BUFFER
    DbgLog((LOG_TRACE, 0, TEXT("Caption Buffer Content:"))) ;
#endif // DUMP_BUFFER

    MSR_START(m_idTxt2Bmp) ;

    // We need to print all the CC chars to internal output buffer if
    // - a CC command came that needs a total output refresh  or
    // - we are scrolling  or
    // - we have a totally new internal output buffer
    bRedrawAll = IsRedrawAll() || IsScrolling() || m_L21DDraw.IsNewOutBuffer() ;
    if (bRedrawAll)
        m_L21DDraw.FillOutputBuffer() ;
    
    // Draw the chars for all cols of all rows that is dirty
    iNumLines = GetNumLines() ;
    iMaxLines = GetMaxLines() ;
    iMax = min(iNumLines, iMaxLines) ;
    DbgLog((LOG_TRACE, 5, TEXT("Will draw %d lines of total %d lines CC"), iMax, iNumLines)) ;

    if (IsScrolling())  // we are scrolling in roll-up mode
    {
        // Now fill out the bottom most row in the background color.
        // Use the last-but-one line's length to fill up.
        OutputBlankCCLine(iNumLines-2, GetStartRow((UINT8)(iNumLines-2)), 0, 0) ;

        // Output (probably) bottom part of the top line
        // Output Src = <bottom of the top line> to Dest w/o offset
        if (iNumLines > iMaxLines)  // we are scrolling out the top line
        {
            OutputCCLine(0, GetStartRow((UINT8)0), 
                         m_iScrollStartLine,   // +ve value means crop top part of Src
                         0) ;                  // no offset on the Dest side
        }
        else   // we are just scrolling a full line up
        {
            OutputCCLine(0, GetStartRow((UINT8)0), 
                         0,                     // no cropping of top part of Src
                         -m_iScrollStartLine) ; // offset on the Dest side to move up
        }

        // The lines in the middle (iNumLines - 1 points to the last line)
        for (i = 1 ; i < iNumLines - 1 ; i++)  // or iMax - 1 ???
        {
            if (0 == GetStartRow((UINT8)i))
            {
                DbgLog((LOG_TRACE, 5, TEXT("Skipping line %d at row %d"), i, GetStartRow((UINT8)i))) ;
                ASSERT(GetStartRow((UINT8)i)) ;
                continue ;
            }

            // Output Src = <whole line> to Dest = <scroll offset>
            OutputCCLine(i, GetStartRow((UINT8)i), 
                         0,    // no Src cropping -- take the whole char(s)
                         -m_iScrollStartLine) ;  // offset for Dest (up from normal)
        }  // end of for (i)

#if 0
        // Now fill out the bottom most part in the background color.
        // Use the previous line's length to fill up.
        OutputBlankCCLine(iNumLines-2, GetStartRow((UINT8)(iNumLines-2)),
                     -m_iScrollStartLine,   // -ve value means crop bottom part of Src
                     m_L21DDraw.GetCharHeight() - m_iScrollStartLine) ;  // offset for Dest (down from base row top)
#endif // #if 0

        // Output the top part of the bottom-most line
        // Output Src = <top of the bottom line> to Dest w/o offset
        OutputCCLine(iNumLines - 1, GetStartRow((UINT8)(iNumLines-2)),
                     -((int)m_L21DDraw.GetCharHeight() - m_iScrollStartLine), // -ve value means crop bottom part of Src
                     m_L21DDraw.GetCharHeight() - m_iScrollStartLine) ;  // offset for Dest (down from base row top)

        // Move to one scan line down for next output sample.
        // NOTE: It's MUCH harder than just ++-ing
        if (IncScrollStartLine(m_L21DDraw.GetCharHeight()) == 0)  // just completed scrolling
        {
            // Needed to fix Whistler bug 379387 -- force top scan lines out
            iNumLines = GetNumLines() ;        // get the latest number of lines
            iMax = min(iNumLines, iMaxLines) ; // update it now

            bDrawNormal = TRUE ;               // we'll redraw the current lines
            m_L21DDraw.FillOutputBuffer() ;    // it's scrolling, and a total redraw
            SetRedrawAll(TRUE) ;               // it's a good idea to redraw all now
        }
    }
    else   // no scrolling -- whatever mode we are in
    {
        bDrawNormal = TRUE ;
    }

    if (bDrawNormal)  // we need to draw all parts of all the lines
    {
        for (i = 0 ; i < iMax ; i++)
        {
            OutputCCLine(i, GetStartRow((UINT8)i), 0, 0) ;  // no cropping, no dest change
        }  // end of for (i)
    }
    
    MSR_STOP(m_idTxt2Bmp) ;

    // If the above steps were done because the caption buffer was 
    // dirty, then now we can mark the caption buffer as 
    // "no-more-dirty" as it has been output in the bitmap form and 
    // has been "redrawn all".
    SetCapBufferDirty(FALSE) ;
    SetRedrawAll(FALSE) ;
    m_L21DDraw.SetNewOutBuffer(FALSE) ;
    
    return true ;  // most probably we drew something
}


//
// Clear both buffers
//
BOOL CLine21DataDecoder::InitCaptionBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(void)"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_aCCData[0].InitCaptionBuffer() ;  // clear buffer 0
    m_aCCData[1].InitCaptionBuffer() ;  // clear buffer 1
    SetBufferIndex(0) ;                 // reset CC buffer index
    
    return TRUE ;
}


//
// Clear buffer(s) based on the given style
//
BOOL CLine21DataDecoder::InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(%d)"), (int)eCCStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_aCCData[0].InitCaptionBuffer() ;
        m_aCCData[1].InitCaptionBuffer() ;
        SetBufferIndex(0) ;   // reset CC buffer index
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        m_aCCData[GetBufferIndex()].InitCaptionBuffer() ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("InitCaptionBuffer(): Wrong Style (%d)!!"), eCCStyle)) ;
        return FALSE ;
    }

    return TRUE ;
}

//
// Caption style determines the buffer pointers to hold the caption chars.
// We make m_pCurrBuff point to the approp. buffer based on the new style.
// NOTE: The only other place where m_pCurrBuff may be changed is in 
// CLine21DataDecoder::HandleEOC() which flips the buffers back & front. So
// we also need to change m_pCurrBuff there too.
//
AM_LINE21_CCSTYLE CLine21DataDecoder::SetCaptionStyle(AM_LINE21_CCSTYLE eStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCaptionStyle(%d)"), eStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_pCurrBuff = &m_aCCData[1 - GetBufferIndex()] ;
        // Set CC style on both the buffers
        m_aCCData[0].SetStyle(eStyle) ;
        m_aCCData[1].SetStyle(eStyle) ;
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
        InitCaptionBuffer() ;
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;

    case AM_L21_CCSTYLE_PaintOn:
        if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)   // if switching from PopOn to PaintOn...
            InitCaptionBuffer(eStyle) ;           // ...clear display buffer
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;
        
    case AM_L21_CCSTYLE_None:  // This is done in init etc.
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("SetCaptionStyle(): Invalid Style!!"))) ;
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        return AM_L21_CCSTYLE_None ;
    }
    AM_LINE21_CCSTYLE  eOldStyle = m_eCCStyle ;
    m_eCCStyle = eStyle ;
    
    //
    // When CC style changes, some internal states also need to cleared
    //
    m_uCurrFGEffect = 0 ;
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    SetScrollState(FALSE) ;  // not scrolling now
    
    return eOldStyle ;
}

CCaptionBuffer * CLine21DataDecoder::GetDisplayBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::GetDisplayBuffer()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        return &m_aCCData[GetBufferIndex()] ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("GetDisplayBuffer(): Wrong Style!!"))) ;
        return NULL ;
    }
}

CCaptionBuffer * CLine21DataDecoder::GetCaptionBuffer(void)
{
    return &m_aCCData[1 - GetBufferIndex()] ;
}


void CLine21DataDecoder::SetBufferIndex(int iIndex)
{
    if (! (0 == iIndex  ||  1 == iIndex) )  // error!!
        return ;
    m_iBuffIndex = iIndex & 0x01 ;
}


void CLine21DataDecoder::ClearBuffer(void)
{
    if (m_pCurrBuff)
        m_pCurrBuff->ClearBuffer() ;
}

void CLine21DataDecoder::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->RemoveLineFromBuffer(uLine, bUpNextLine) ;
}

void CLine21DataDecoder::GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->GetCaptionChar(uLine, uCol, cc) ;
}

void CLine21DataDecoder::SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                                        const CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCaptionChar(uLine, uCol, cc) ;
}

CCaptionChar* CLine21DataDecoder::GetCaptionCharPtr(UINT8 uLine, UINT8 uCol)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCaptionCharPtr(uLine, uCol) ;
    
    //
    //  Otherwise it's a very bad thing!!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL inside GetCaptionCharPtr()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return NULL ;  // may be we should trap this and not fault
}

int  CLine21DataDecoder::GetMaxLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetMaxLines() ;
    return 0 ;  // that's best!!!
}

void CLine21DataDecoder::SetMaxLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetMaxLines(uLines) ;
}

int  CLine21DataDecoder::GetNumLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetNumLines() ;
    return 0 ;
}

void CLine21DataDecoder::SetNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetNumLines(uLines) ;
}

int  CLine21DataDecoder::GetNumCols(int iLine)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;   // should we??
    }
    
    if (iLine >= GetNumLines())
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) ( > Total (%d)"), iLine, GetNumLines())) ;
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(iLine).GetNumChars() ;
}


int  CLine21DataDecoder::GetCurrLine(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrLine() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

int  CLine21DataDecoder::GetCurrCol(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrCol() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

void CLine21DataDecoder::SetCurrLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrLine(uLine) ;
}

void CLine21DataDecoder::SetCurrCol(UINT8 uCol)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrCol(uCol) ;
}

int  CLine21DataDecoder::GetStartRow(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetStartRow(uLine & 0x7) ;
    
	ASSERT(m_pCurrBuff) ;

    //
    // This is very very bad!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL in GetStartRow()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return 0 ;
}

void CLine21DataDecoder::SetStartRow(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetStartRow(uLine & 0x7, uRow) ;
}

int  CLine21DataDecoder::GetRowIndex(UINT8 uRow)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetRowIndex(uRow) ;
    else
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
}

void CLine21DataDecoder::SetRowIndex(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRowIndex(uLine, uRow) ;
}

int CLine21DataDecoder::IncCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ; // is that OK?
}

int CLine21DataDecoder::DecCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ;  // is that OK?
}

int CLine21DataDecoder::IncNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(uLine).IncNumChars(uNumChars) ;
}

int CLine21DataDecoder::DecNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    return m_pCurrBuff->GetCaptionLine(uLine).DecNumChars(uNumChars) ;
}

int CLine21DataDecoder::IncNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncNumLines(uLines) ;
    return 0 ;
}

int CLine21DataDecoder::DecNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecNumLines(uLines) ;
    return 0 ;
}

void CLine21DataDecoder::MoveCaptionChars(int iLine, int iNum)
{
    if (m_pCurrBuff)
        m_pCurrBuff->MoveCaptionChars(iLine, iNum) ;
}

BOOL CLine21DataDecoder::IsCapBufferDirty(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsBufferDirty() ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawLine(uLine) ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawAll(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawAll() ;
    return FALSE ;
}

void CLine21DataDecoder::SetCapBufferDirty(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetBufferDirty(bState) ;
}

void CLine21DataDecoder::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawLine(uLine, bState) ;
}

void CLine21DataDecoder::SetRedrawAll(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(bState) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21dbase.h ===
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.

//
// L21DBase.h: Line 21 Decoder 2 Base class code
//

#ifndef _INC_L21DBASE_H
#define _INC_L21DBASE_H

// Just a few macro definitions
#define ABS(x) (((x) > 0) ? (x) : -(x))
#define LPBMIHEADER(bmi) &((bmi)->bmiHeader)
#define DWORDALIGN(n)  (((n) + 3) & ~0x03)
#define ISDWORDALIGNED(n)  (0 == ((n) & 0x03))
#define DWORDALIGNWIDTH(bmih) (((((bmih).biWidth * (bmih).biBitCount) + 31) & ~31) >> 3)
#define MAKECCCHAR(b1, b2)  ((b1) << 8 | (b2))

//
//  Caption character attribs set by PACs and/or mid-row codes
//
#define UINT8   unsigned char
#define UINT16  unsigned short int

#define AM_L21_FGCOLOR_WHITE             0x00
#define AM_L21_FGCOLOR_GREEN             0x01
#define AM_L21_FGCOLOR_BLUE              0x02
#define AM_L21_FGCOLOR_CYAN              0x03
#define AM_L21_FGCOLOR_RED               0x04
#define AM_L21_FGCOLOR_YELLOW            0x05
#define AM_L21_FGCOLOR_MAGENTA           0x06
#define AM_L21_FGCOLOR_MASK              0x07

#define AM_L21_FGEFFECT_ITALICS          0x08
#define AM_L21_FGEFFECT_UNDERLINE        0x10
#define AM_L21_FGEFFECT_FLASHING         0x20
#define AM_L21_FGEFFECT_MASK             0x38

#define AM_L21_ATTRIB_DIRTY              0x40
#define AM_L21_ATTRIB_MRC                0x80

//
// Caption width and height
//
#define CAPTION_OUTPUT_WIDTH  640  /* 320 */
#define CAPTION_OUTPUT_HEIGHT 480  /* 240 */


//
// Forward declarations
//
class CCaptionChar ;
class CCaptionLine ;
class CRowIndexMap ;
class CCaptionBuffer ;
class CPopOnCaption ;


//
//  The max's of rows and columns
//
const int MAX_CAPTION_COLUMNS = 32 ;  // max # of column / line
const int MAX_CAPTION_ROWS    = 15 ;  // number of rows available on screen
const int MAX_CAPTION_LINES   = 4 ;   // max # of caption text at a time
// for text mode, add MAX_TEXT_LINES = 15 ;


//
//  CCaptionChar: The caption char details
//
class CCaptionChar {
private:
    UINT16 m_wChar ;     // actual char
    UINT8  m_uAttrib ;   // CC char attrib bits -- FG color, effect, dirty, MRC etc.
    //
    // The layout of bits (LSB -> MSB) of CC char attribs --
    //    0 - 2: color (0 -> 6 for White -> Magenta)
    //    3 - 5: effects (3: Italics, 4: Underline, 5: Flash)
    //        6: dirty (is the CC char dirty, i.e, needs to written?)
    //        7: is it a mid-row code (carries attrib, shown as opaque space)?
    //
    
public:
    inline CCaptionChar(void) {
        m_wChar   = 0 ;
        m_uAttrib = 0 ;
    } ;
    
    inline UINT16 GetChar(void) const  { return m_wChar ; } ;
    inline CCaptionChar& operator = (const CCaptionChar& cc) {
        m_wChar   = cc.m_wChar ;
        m_uAttrib = cc.m_uAttrib ;
        return *this ;
    } ;
    inline BOOL  operator == (const CCaptionChar& cc) const {
        return (m_wChar   == cc.m_wChar  &&
                m_uAttrib == cc.m_uAttrib) ;
    } ;
    inline BOOL  operator != (const CCaptionChar& cc) const {
        if (*this == cc)  return FALSE ;
        else              return TRUE ;
    } ;
    inline BOOL  IsEqualAttrib(CCaptionChar cc) const {
        return (GetColor()  == cc.GetColor()  &&
                GetEffect() == cc.GetEffect()) ;
    } ;
    inline UINT8 GetColor(void) const      { return  m_uAttrib & AM_L21_FGCOLOR_MASK ; } ;
    inline UINT8 GetEffect(void) const     { return (m_uAttrib & AM_L21_FGEFFECT_MASK) >> 3 ; } ;
    inline BOOL  IsItalicized(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_ITALICS)) ; } ;
    inline BOOL  IsUnderLined(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_UNDERLINE)) ; } ;
    inline BOOL  IsFlashing(void) const    { return (0 != (m_uAttrib & AM_L21_FGEFFECT_FLASHING)) ; } ;
    inline BOOL  IsDirty(void) const       { return (0 != (m_uAttrib & AM_L21_ATTRIB_DIRTY)) ; } ;
    inline BOOL  IsMidRowCode(void) const  { return (0 != (m_uAttrib & AM_L21_ATTRIB_MRC)) ; } ;
    void  SetChar(UINT16 wChar) ;
    void  SetColor(UINT8 uColor) ;
    void  SetEffect(UINT8 uEffect) ;
    void  SetItalicized(BOOL bState) ;
    void  SetUnderLined(BOOL bState) ;
    void  SetFlashing(BOOL bState) ;
    void  SetDirty(BOOL bState) ;
    void  SetMidRowCode(BOOL bState) ;

} ;


//
//  CCaptionLine: The caption line details
//
class CCaptionLine {
protected:  // not private
    CCaptionChar m_aCapChar[MAX_CAPTION_COLUMNS] ;  // char details of line
    UINT8        m_uNumChars ;      // number of chars in the line
    UINT8        m_uStartRow ;      // start row of the line
    
public:
    CCaptionLine(void) ;
    CCaptionLine(const UINT uStartRow, const UINT uNumChars = 0) ;
    
    CCaptionLine& operator = (const CCaptionLine& cl) ;
    
    inline int   GetNumChars(void) const  { return m_uNumChars ; } ;
    inline void  SetNumChars(UINT uNumChars)  { m_uNumChars = uNumChars & 0x3F ; } ;
    int IncNumChars(UINT uNumChars) ;
    int DecNumChars(UINT uNumChars) ;
    inline void  GetCaptionChar(UINT uCol, CCaptionChar &cc) const {
        if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
            return ;
        cc = m_aCapChar[uCol] ;
    } ;
    void SetCaptionChar(UINT uCol, const CCaptionChar &cc) ;
    CCaptionChar* GetCaptionCharPtr(UINT uCol) ;
    inline int  GetStartRow(void)  { return m_uStartRow ; } ;
    void SetStartRow(UINT uRow) ;
    inline CCaptionChar* GetLineText(void) { return (CCaptionChar *) m_aCapChar ; }
    void MoveCaptionChars(int iNum) ;
    void ClearLine(void) ;

} ;

//
//  CRowIndexMap: Mapping of row usage (row to text line)
//
class CRowIndexMap {
private:
    DWORD         m_adwMap[2] ;  // bit map of row usage
    
public:
    inline CRowIndexMap(void)  { ClearRowIndex() ; }
    
    DWORD GetMap(int i) { 
        if (! (0 == i || 1 == i) )
            return 0 ;
        return m_adwMap[i] ; 
    } ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetRowIndex(UINT uLine, UINT8 uRow) ;
    inline void ClearRowIndex(void)  { m_adwMap[0] = m_adwMap[1] = 0 ; } ;
} ;


//
//  A set of flags and consts for caption buffer dirty state info
//
#define L21_CAPBUFFER_REDRAWALL     0x01
#define L21_CAPBUFFER_DIRTY         0x02
#define L21_CAPBUFFDIRTY_FLAGS      2


//
//  CCaptionBuffer: The caption buffer class details
//
class CCaptionBuffer {
protected:  // private
    CCaptionLine  m_aCapLine[MAX_CAPTION_LINES + 1] ;  // shall we always have an extra line? It's easier this way!!
    CRowIndexMap  m_RowIndex ;     // row index map bits
    UINT8         m_uNumLines ;    // # lines
    UINT8         m_uMaxLines ;    // max # lines (4 or less)
    UINT8         m_uCurrCol ;     // current column on the screen
    UINT8         m_uCurrLine ;    // max 4: maps row # to array index
    UINT8         m_uCaptionStyle ;// 0 = None, 1 = Pop-On, 2 = Paint-On, 3 = Roll-Up
    UINT8         m_uDirtyState ;  // caption buffer dirty state flags
    
public:
    CCaptionBuffer(UINT8 uStyle    = AM_L21_CCSTYLE_None, 
                   UINT8 uMaxLines = MAX_CAPTION_LINES) ;
    CCaptionBuffer(/* const */ CCaptionBuffer &cb) ;
    
    inline int  GetNumLines(void)  { return m_uNumLines ; } ;
    inline int  GetMaxLines(void)  { return m_uMaxLines ; } ;
    inline int  GetCurrRow(void)   { return m_aCapLine[m_uCurrLine].GetStartRow() ; } ;
    inline int  GetCurrCol(void)   { return m_uCurrCol ; } ;  // Why do we need it??
    inline int  GetCurrLine(void)  { return m_uCurrLine ; } ;
    inline int  GetRowIndex(UINT uRow)   { return m_RowIndex.GetRowIndex((UINT8)uRow) ; } ;
    inline int  GetStyle(void)     { return m_uCaptionStyle ; } ;
    
    inline void SetNumLines(int uNumLines)  { m_uNumLines = uNumLines & 0x7 ; } ;
    inline void SetMaxLines(int uMaxLines)  { 
        ASSERT(m_uMaxLines >= 0 && m_uMaxLines <= MAX_CAPTION_LINES) ;
        m_uMaxLines = uMaxLines & 0x7 ; 
    } ;
    inline void SetCurrRow(int uCurrRow)    {
        ASSERT(m_uCurrLine >= 0 && m_uCurrLine < m_uMaxLines) ;
        m_aCapLine[m_uCurrLine].SetStartRow(uCurrRow) ; 
    } ;
    void SetCurrCol(int uCurrCol) ;
    inline void SetCurrLine(int uLine)      { m_uCurrLine = uLine & 0x7 ; } ;
    inline void SetRowIndex(UINT uLine, UINT uRow)   { m_RowIndex.SetRowIndex(uLine, (UINT8)uRow) ; } ;
    inline void SetStyle(UINT8 uStyle)      { m_uCaptionStyle = uStyle ; } ;
    
    inline CCaptionLine& GetCaptionLine(UINT uLine)  {
        // uLine is assumed to have been verified in the caller
        return m_aCapLine[uLine] ;
    } ;
    void SetCaptionLine(UINT uLine, const CCaptionLine& cl) ;
    void ClearCaptionLine(UINT uLine) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    void ClearBuffer(void) ;
    void InitCaptionBuffer(void) ;
    int  IncNumLines(int uLines) ;
    int  DecNumLines(int uLines) ;
    CRowIndexMap& GetRowIndexMap(void)  { return m_RowIndex ; } ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    
    inline int  GetStartRow(UINT uLine) {
        return m_aCapLine[uLine].GetStartRow() ;
    } ;
    void SetStartRow(UINT uLine, UINT uRow) ;
    inline void GetCaptionChar(UINT uLine, UINT uCol, CCaptionChar& cc) {
        m_aCapLine[uLine].GetCaptionChar(uCol, cc) ;
    } ;
    inline void SetCaptionChar(UINT uLine, UINT uCol, const CCaptionChar& cc) {
        m_aCapLine[uLine].SetCaptionChar(uCol, cc) ;
    } ;
    inline CCaptionChar* GetCaptionCharPtr(UINT uLine, UINT uCol) {
        return m_aCapLine[uLine].GetCaptionCharPtr(uCol) ;
    } ;
    inline int IncNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].IncNumChars(uNumChars) ;
    } ;
    inline int DecNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].DecNumChars(uNumChars) ;
    } ;
    inline void MoveCaptionChars(int uLine, int iNum) {
        m_aCapLine[uLine].MoveCaptionChars(iNum) ;
    } ;
    
    inline BOOL IsBufferDirty(void)  { return m_uDirtyState & L21_CAPBUFFER_DIRTY ; } ;
    inline BOOL IsRedrawAll(void)    { return m_uDirtyState & L21_CAPBUFFER_REDRAWALL ; } ;

    BOOL IsRedrawLine(UINT8 uLine) ;
    void SetBufferDirty(BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
} ;

#endif // #ifndef _INC_L21DBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21dfilt.cpp ===
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.

//
// DirectShow Line 21 Decoder Filter 2: Filter Interface
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif /* FILTER_DLL */

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"
#include "L21DFilt.h"


//
//  Setup Data
//
/* const */ AMOVIESETUP_MEDIATYPE sudLine21Dec2InType  =
{
    &MEDIATYPE_AUXLine21Data,       // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_MEDIATYPE sudLine21Dec2OutType =
{
    &MEDIATYPE_Video,               // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_PIN psudLine21Dec2Pins[] =
{
    { L"Input",                // strName
        FALSE,                   // bRendered
        FALSE,                   // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Output",               // strConnectsToPin
        1,                       // nTypes
        &sudLine21Dec2InType     // lpTypes
    },
    { L"Output",               // strName
        FALSE,                   // bRendered
        TRUE,                    // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Input",                // strConnectsToPin
        1,                       // nTypes
        &sudLine21Dec2OutType    // lpTypes
    }
} ;

const AMOVIESETUP_FILTER sudLine21Dec2 =
{
    &CLSID_Line21Decoder2,        // clsID
    L"Line 21 Decoder 2",         // strName
    MERIT_NORMAL + 2,             // dwMerit
    2,                            // nPins
    psudLine21Dec2Pins,           // lpPin
} ;

//  Nothing to say about the output pin

#ifdef FILTER_DLL

// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] =
{
    {   L"Line 21 Decoder 2",
        &CLSID_Line21Decoder2,
        CLine21DecFilter2::CreateInstance,
        NULL,
        &sudLine21Dec2
    }
} ;

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
//  Exported entry points for registration and unregistration (in this case
//  they only call through to default implmentations).
//
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE) ;
}

HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE) ;
}

#endif // FILTER_DLL



#ifndef UNALIGNED
#define UNALIGNED   // __unaligned
#endif // UNALIGNED


//
//  CLine21DecFilter2 class implementation
//

#pragma warning(disable:4355)

//
//  Constructor
//
CLine21DecFilter2::CLine21DecFilter2(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
: CTransformFilter(pName, pUnk, CLSID_Line21Decoder2),

m_L21Dec(),
m_eSubTypeIDIn(AM_L21_CCSUBTYPEID_Invalid),
m_eGOP_CCType(GOP_CCTYPE_Unknown),
m_rtTimePerInSample(166833),   // 333667),
m_rtTimePerOutSample(333667),
m_rtStart((LONGLONG) 0),
m_rtStop((LONGLONG) 0),
m_bNoTimeStamp(TRUE),
m_rtLastOutStop((LONGLONG) 0),
m_llMediaStart((LONGLONG) 0),
m_llMediaStop((LONGLONG) 0),
m_pviDefFmt(NULL),
m_dwDefFmtSize(0),
m_bMustOutput(TRUE),
m_bDiscontLast(FALSE),
m_bEndOfStream(FALSE),   // not true until EoS() is called
m_pPinDown(NULL),
m_bBlendingState(TRUE),  // we set it to FALSE in Pause()
m_OutputThread(this),
m_InSampleQueue()
{
    CAutoLock   Lock(&m_csFilter) ;

    DbgLog((LOG_TRACE, 3,
        TEXT("CLine21DecFilter2::CLine21DecFilter2() -- Instantiating Line 21 Decoder 2 filter"))) ;

    ASSERT(pName) ;
    ASSERT(phr) ;

#ifdef PERF
#pragma message("Building for PERF measurements")
    m_idDelvWait  = MSR_REGISTER(TEXT("L21D2Perf - Wait on Deliver")) ;
#endif // PERF
}


//
//  Destructor
//
CLine21DecFilter2::~CLine21DecFilter2()
{
    CAutoLock   Lock(&m_csFilter) ;

    DbgLog((LOG_TRACE, 3,
        TEXT("CLine21DecFilter2::~CLine21DecFilter2() -- Destructing Line 21 Decoder 2 filter"))) ;

    // In case the downstream pin interface wasn't released...
    if (m_pPinDown)
    {
        m_pPinDown->Release() ;
        m_pPinDown = NULL ;
    }

    // Release all the buffers allocated
    if (m_pviDefFmt)
    {
        delete m_pviDefFmt ;
        m_pviDefFmt = NULL ;
    }

    // Make sure we are not holding onto any DDraw surfaces (should be
    // released during disconnect)
    DbgLog((LOG_TRACE, 5, TEXT("* Destroying the Line 21 Decoder 2 filter *"))) ;
}


//
//  NonDelegatingQueryInterface
//
STDMETHODIMP CLine21DecFilter2::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL ;

    DbgLog((LOG_TRACE, 6, TEXT("Lin21DecFilter2: Somebody's querying my interface"))) ;
    if (IID_IAMLine21Decoder == riid)
    {
        return GetInterface((IAMLine21Decoder *) this, ppv) ;
    }
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv) ;
}


//
//  CreateInstance: Goes in the factory template table to create new instances
//
CUnknown * CLine21DecFilter2::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CLine21DecFilter2(TEXT("Line 21 Decoder 2 filter"), pUnk, phr) ;
}


STDMETHODIMP CLine21DecFilter2::GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetDecoderLevel(0x%lx)"), lpLevel)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpLevel, sizeof(AM_LINE21_CCLEVEL)))
        return E_INVALIDARG ;

    *lpLevel = m_L21Dec.GetDecoderLevel() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetCurrentService(AM_LINE21_CCSERVICE *lpService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetCurrentService(0x%lx)"), lpService)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpService, sizeof(AM_LINE21_CCSERVICE)))
        return E_INVALIDARG ;

    *lpService = m_L21Dec.GetCurrentService() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetCurrentService(AM_LINE21_CCSERVICE Service)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetCurrentService(%lu)"), Service)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Service < AM_L21_CCSERVICE_None || Service > AM_L21_CCSERVICE_XDS)
        return E_INVALIDARG ;

    if (Service >= AM_L21_CCSERVICE_Text1)  // we don't have support for Text1/2 or XDS now.
        return E_NOTIMPL ;

    if (m_L21Dec.SetCurrentService(Service))  // if we must refresh output
    {
        m_bMustOutput = TRUE ;                // then flag it here.
    }

    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetServiceState(AM_LINE21_CCSTATE *lpState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetServiceState(0x%lx)"), lpState)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpState, sizeof(AM_LINE21_CCSTATE)))
        return E_INVALIDARG ;

    *lpState = m_L21Dec.GetServiceState() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetServiceState(AM_LINE21_CCSTATE State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetServiceState(%lu)"), State)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State < AM_L21_CCSTATE_Off || State > AM_L21_CCSTATE_On)
        return E_INVALIDARG ;

    if (m_L21Dec.SetServiceState(State))   // if we must refresh output
    {
        m_bMustOutput = TRUE ;             // then flag it here.
    }

    return NOERROR ;
}



STDMETHODIMP CLine21DecFilter2::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetOutputFormat(0x%lx)"), lpbmih)) ;
    // CAutoLock   Lock(&m_csFilter) ;
    return m_L21Dec.GetOutputFormat(lpbmih) ;
}



STDMETHODIMP CLine21DecFilter2::SetOutputFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetOutputFormat(0x%lx)"), lpbmi)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    return E_NOTIMPL ;  // for now, until we do it properly
}

STDMETHODIMP CLine21DecFilter2::GetBackgroundColor(DWORD *pdwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetBackgroundColor(0x%lx)"), pdwPhysColor)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(pdwPhysColor, sizeof(DWORD)))
        return E_INVALIDARG ;

    m_L21Dec.GetBackgroundColor(pdwPhysColor) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetBackgroundColor(DWORD dwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetBackgroundColor(0x%lx)"), dwPhysColor)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (m_L21Dec.SetBackgroundColor(dwPhysColor))  // color key has really changed
    {
        // refill the output buffer only if we are not in stopped state
        if (State_Stopped != m_State)
            m_L21Dec.FillOutputBuffer() ;
    }

    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetRedrawAlways(LPBOOL lpbOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetRedrawAlways(0x%lx)"), lpbOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpbOption, sizeof(BOOL)))
        return E_INVALIDARG ;
    *lpbOption = m_L21Dec.GetRedrawAlways() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetRedrawAlways(BOOL bOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetRedrawAlways(%lu)"), bOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    m_L21Dec.SetRedrawAlways(bOption) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetDrawBackgroundMode(0x%lx)"), lpMode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpMode, sizeof(AM_LINE21_DRAWBGMODE)))
        return E_INVALIDARG ;

    *lpMode = m_L21Dec.GetDrawBackgroundMode() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetDrawBackgroundMode(%lu)"), Mode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Mode < AM_L21_DRAWBGMODE_Opaque  || Mode > AM_L21_DRAWBGMODE_Transparent)
        return E_INVALIDARG ;
    m_L21Dec.SetDrawBackgroundMode(Mode) ;
    return NOERROR ;
}


//
//  VerifyGOPUDPacketData: Private helper method to verify GOP user data
//                         packet integrity.
//
BOOL CLine21DecFilter2::VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    return (AM_L21_GOPUD_HDR_STARTCODE == GETGOPUD_L21STARTCODE(pGOPUDPacket->Header) &&  // valid start code
        AM_L21_GOPUD_HDR_INDICATOR == GETGOPUD_L21INDICATOR(pGOPUDPacket->Header) &&  // Line21 indicator
        AM_L21_GOPUD_HDR_RESERVED  == GETGOPUD_L21RESERVED(pGOPUDPacket->Header)  &&  // reserved bits
        GETGOPUD_NUMELEMENTS(pGOPUDPacket) > 0) ;                                     // +ve # elements
}


//
//  VerifyATSCUDPacketData: Private helper method to verify ATSC user data
//                          packet integrity.
//
BOOL CLine21DecFilter2::VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    if (AM_L21_ATSCUD_HDR_STARTCODE  != GETATSCUD_STARTCODE(pATSCUDPacket->Header) ||  // invalid start code
        AM_L21_ATSCUD_HDR_IDENTIFIER != GETATSCUD_IDENTIFIER(pATSCUDPacket->Header))   // not ATSC Identifier
        return FALSE ;

    if (! ISATSCUD_TYPE_EIA(pATSCUDPacket) )   // not EIA-type CC
        return FALSE ;

    // Either EM or valid CC data is acceptable
    return (ISATSCUD_EM_DATA(pATSCUDPacket) ||             // EM data type  OR
            (ISATSCUD_CC_DATA(pATSCUDPacket)  &&           // CC data type  AND
             GETATSCUD_NUMELEMENTS(pATSCUDPacket) > 0)) ;  // +ve # CC elements
}


//
//  IsFillerPacket: Private helper method to check if the packet (at least header)
//                  contains only 0 bytes, which means it's a filler.
//
BOOL CLine21DecFilter2::IsFillerPacket(BYTE *pGOPPacket)
{
    DWORD  dwStartCode = ((DWORD)(pGOPPacket[0]) << 24 | \
                          (DWORD)(pGOPPacket[1]) << 16 | \
                          (DWORD)(pGOPPacket[2]) <<  8 | \
                          (DWORD)(pGOPPacket[3])) ;

    // If first 4 bytes of packet is NOT the start code (0x1B2) then it's a filler
    return (AM_L21_GOPUD_HDR_STARTCODE != dwStartCode) ;
}


//
//  DetectGOPPacketDataType: Private helper method to detect if GOP user data
//                           packet is from a DVD disc, ATSC stream or others.
//
GOPPACKET_CCTYPE CLine21DecFilter2::DetectGOPPacketDataType(BYTE *pGOPPacket)
{
    if (VerifyGOPUDPacketData((PAM_L21_GOPUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_DVD ;
    else if (VerifyATSCUDPacketData((PAM_L21_ATSCUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_ATSC ;
    else if (IsFillerPacket(pGOPPacket))
        return GOP_CCTYPE_None ;   // not a valid packet -- just ignore it
    else
        return GOP_CCTYPE_Unknown ; // it's some unknown format of CC packet
}


HRESULT CLine21DecFilter2::GetOutputBuffer(IMediaSample **ppOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetOutputBuffer()"))) ;

    HRESULT  hr ;

    // Get delivery buffer from downstream filter (VMR)
    DWORD dwFlags = 0 ;  // AM_GBF_NOTASYNCPOINT ;
    if (m_bSampleSkipped)
        dwFlags |= AM_GBF_PREVFRAMESKIPPED ;

    dwFlags |= AM_GBF_NODDSURFACELOCK;

    DbgLog((LOG_TRACE, 5, TEXT(">>>> Going to call GetDeliveryBuffer()..."))) ;
    hr = m_pOutput->GetDeliveryBuffer(ppOut, NULL, NULL, dwFlags) ;
    DbgLog((LOG_TRACE, 5, TEXT("<<<< Back from call to GetDeliveryBuffer()"))) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: GetDeliveryBuffer() failed (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    // Check if the output sample uses DDraw surface from the same DDraw object
    IVMRSurface*  pVMRSurf ;
    hr = (*ppOut)->QueryInterface(IID_IVMRSurface, (LPVOID*)&pVMRSurf) ;
    if (SUCCEEDED(hr))
    {
        LPDIRECTDRAWSURFACE7  pDDSurf ;
        hr = pVMRSurf->GetSurface(&pDDSurf) ;
        if (SUCCEEDED(hr))
        {
            m_L21Dec.SetDDrawSurface(pDDSurf) ;
            pDDSurf->Release() ;
        }
        else  // ERROR: couldn't get the DirectDraw surface
        {
            DbgLog((LOG_TRACE, 1,
                TEXT("WARNING: IVMRSurface::GetSurface() failed (Error 0x%lx)"), hr)) ;
        }
        pVMRSurf->Release() ;
    }

    return hr ;
}


// We use a 2 milliseconds (20000 in DShow time) time delta
#define L21D2_SAMPLE_TIME_DELTA   20000

//
// Checks if any output sample needs to be sent, and if so, prepares and sends one down
//
HRESULT CLine21DecFilter2::SendOutputSampleIfNeeded()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SendOutputSampleIfNeeded()"))) ;

    HRESULT  hr ;
    REFERENCE_TIME  rtStreamAdjusted ;

    {
    CAutoLock  lock(&m_csFilter) ;

    if (NULL == m_pPinDown)  // output pin is NOT connected -- skip everything
        return S_OK ;

    // Get the current stream time, and based on that process queued samples
    CRefTime  rtStreamTime ;
    hr = StreamTime(rtStreamTime) ;
    if (SUCCEEDED(hr))
    {
        rtStreamAdjusted = (REFERENCE_TIME) rtStreamTime - L21D2_SAMPLE_TIME_DELTA ;

        // There is a possibility of a race condition between different filters when
        // the graph switches to the Running state.  This filter may have gone into
        // Running state (with a tStart value of ~10mSec), and starts sending output
        // samples.  But the clock provider, especially if it's an upstream filter 
        // (Demux, SBE etc.) may not have gone into the Running state yet, and will
        // provide a clock time below the tStart value, resulting in a stream time,
        // which is negative at the beginning.  When the clock provider filter
        // switches to Running state, it gets the tStart value and bumps up its clock
        // to that value at least, resulting in a stream time of zero or higher (but
        // that may hold flat for a little while -- until the actual clock value 
        // reaches the tStart level).  After that, the clock will work fine and the 
        // stream time values will be reliable.  For the above scenario, we need to
        // specially handle the case of negative stream time by bumping it upto 
        // zero, and also processing any input sample we get during this period.
        if (rtStreamAdjusted < 0)
            rtStreamAdjusted = 0 ;
    }
    else  // no clock for the graph!!!
    {
        rtStreamAdjusted = 0 ;  // just init it to something
        DbgLog((LOG_TRACE, 1, 
            TEXT("StreamTime() failed (Error 0x%lx), which means no clock. We'll proceed anyway."), hr)) ;
    }

    // Compare the start time stamp of the next sample in the queue against the 
    // current stream time.  If the sample's time stamp is before the stream time
    // (minus a small delta -- 2 msecs?) then remove the sample from the queue
    // and process it.  Otherwise we just send the same output sample w/o any
    // timestamp so that the VMR can mix it as it sees fit.
    int   iCount = 0 ;
    IMediaSample  *pSample ;
    REFERENCE_TIME  rtStart, rtEnd ;
    while (pSample = m_InSampleQueue.PeekItem())  // peek at the first sample, if any
    {
        hr = pSample->GetTime(&rtStart, &rtEnd) ;
        if (S_OK == hr)  // media sample has time stamp set
        {
            if (rtStreamAdjusted > 0  &&     // valid stream time  AND
                rtStart > rtStreamAdjusted)  // not time yet -- no more processing
            {
                DbgLog((LOG_TRACE, 5, TEXT("Media sample timestamp for future"))) ;
                break ;
            }
            // Otherwise go ahead with processing the sample(s)...
        }
        else  // if there is no time stamp set, we can go ahead and process it
            DbgLog((LOG_TRACE, 5, 
                TEXT("Media sample #%d doesn't have any timestamp set. Process it..."))) ;

        // Now actually remove the media sample from the list for processing
        pSample = m_InSampleQueue.RemoveItem() ;
        if (pSample)
        {
            hr = ProcessSample(pSample) ;
            pSample->Release() ;    // sample processed; must release now
            iCount++ ;
        }
    }
    DbgLog((LOG_TRACE, 5, TEXT("### Processed %d samples in this round"), iCount)) ;

    // First check if we need to send any output samples
    m_L21Dec.UpdateCaptionOutput() ;
    if (!m_bMustOutput  &&           // we are not in "Must Show" mode
        m_L21Dec.IsOutDIBClear() )   // no CC to show
    {
        DbgLog((LOG_TRACE, 5, TEXT("Clear CC -- no sample being sent."))) ;
        SetBlendingState(FALSE) ;
        m_rtLastOutStop += m_rtTimePerOutSample ;  // advance time anyway
        return S_OK ;
    }

    //
    // We need to send a sample down
    //
    SetBlendingState(TRUE) ;  // turn on blending first

    }  // Filter lock scope ends here

    if (m_bNoTimeStamp)
    {
        hr = SendOutputSample(NULL, NULL, NULL) ;
        if (SUCCEEDED(hr))  // if out sample was delivered right
        {
            DbgLog((LOG_TRACE, 5, TEXT("+++ Delivered sample w/o timestamp up to time %s +++"),
                    (LPCTSTR)CDisp(rtStreamAdjusted, CDISP_DEC))) ;
        }
    }
    else
    {
        REFERENCE_TIME  rtStart ;
        REFERENCE_TIME  rtStop  ;
        if (m_rtStart > m_rtLastOutStop)
        {
            DbgLog((LOG_TRACE, 5, 
                TEXT("++++ Starting timestamp low from %s [new sample's: %s]"),
                (LPCTSTR)CDisp(m_rtLastOutStop, CDISP_DEC), (LPCTSTR)CDisp(m_rtStart, CDISP_DEC))) ;
            rtStart = m_rtLastOutStop ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5,
                TEXT("**** Starting timestamp from current sample's (%s) [last: %s]"),
                (LPCTSTR)CDisp(m_rtStart, CDISP_DEC), (LPCTSTR)CDisp(m_rtLastOutStop, CDISP_DEC))) ;
            rtStart = m_rtStart  ;
        }
        rtStop = m_rtStart + m_rtTimePerOutSample ; // rtStart + ...??

        hr = SendOutputSample(NULL, &rtStart, &rtStop) ;
        if (SUCCEEDED(hr))  // if out sample was delivered right
        {
            DbgLog((LOG_TRACE, 5, TEXT("*** Delivered output sample in output thread (for time %s -> %s) ***"),
                (LPCTSTR)CDisp(rtStart, CDISP_DEC), (LPCTSTR)CDisp(rtStop, CDISP_DEC))) ;
        }
    }
    SetBlendingState(! m_L21Dec.IsOutDIBClear() ) ;

    return hr ;
}


BOOL CLine21DecFilter2::IsValidFormat(BYTE *pbFormat)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::IsValidFormat(0x%lx)"), pbFormat)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- can't do that as it may cause deadlock

    if (NULL == pbFormat)
        return FALSE ;

    BITMAPINFOHEADER *lpBMIH = HEADER(pbFormat) ;
    if (! ( 8 == lpBMIH->biBitCount || 16 == lpBMIH->biBitCount ||
           24 == lpBMIH->biBitCount || 32 == lpBMIH->biBitCount) )  // bad bitdepth
        return FALSE ;
    if ( !(BI_RGB == lpBMIH->biCompression ||
           BI_BITFIELDS == lpBMIH->biCompression ||
           '44IA' == lpBMIH->biCompression) ) // bad compression
        return FALSE ;
    if (DIBSIZE(*lpBMIH) != lpBMIH->biSizeImage) // invalid dimensions/size
        return FALSE ;

    return TRUE ;  // hopefully it's a valid video info header
}


void CLine21DecFilter2::SetBlendingState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetBlendingState(%s)"),
            bState ? TEXT("TRUE") : TEXT("FALSE"))) ;
    // CAutoLock   Lock(&m_csFilter) ;

    // if (m_bBlendingState == bState)  // nothing to change
    //     return ;

    if (NULL == m_pPinDown)
    {
        DbgLog((LOG_ERROR, 3, TEXT("WARNING: Downstream pin not available -- not connected??"))) ;
        return ;
    }

    IVMRVideoStreamControl  *pVMRVSC ;
    HRESULT hr = m_pPinDown->QueryInterface(IID_IVMRVideoStreamControl, (LPVOID *) &pVMRVSC) ;
    if (FAILED(hr) || NULL == pVMRVSC)
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: IVMRVideoStreamControl not available on pin %s"),
                (LPCTSTR) CDisp(m_pPinDown))) ;
        ASSERT(pVMRVSC) ;
        return ;
    }

    hr = pVMRVSC->SetStreamActiveState(bState) ;
    if (SUCCEEDED(hr))
    {
        m_bBlendingState = bState ;  // save last blending operation flag
    }
    else  // VMR probably has stopped
    {
        DbgLog((LOG_TRACE, 3, TEXT("IVMRVideoStreamControl::SetStreamActiveState() failed (Error 0x%lx)"), hr)) ;
    }

    pVMRVSC->Release() ;
}


HRESULT CLine21DecFilter2::SendOutputSample(IMediaSample *pIn,
                                            REFERENCE_TIME *prtStart,
                                            REFERENCE_TIME *prtStop)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SendOutputSample(0x%lx, %s, %s)"),
        pIn, prtStart ? (LPCTSTR)CDisp(*prtStart, CDISP_DEC) : TEXT("NULL"),
        prtStop ? (LPCTSTR)CDisp(*prtStop, CDISP_DEC) : TEXT("NULL"))) ;

    // if (NULL == m_pPinDown)  // output pin is NOT connected -- skip everything
    //     return S_OK ;

    // First get the output sample
    HRESULT        hr ;
    IMediaSample  *pOut ;
    hr = GetOutputBuffer(&pOut) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: GetOutputBuffer() failed (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    // Now we take the lock
    CAutoLock  Lock(&m_csFilter) ;

    // If EoS has been called while we were getting the delivery buffer (above),
    // we must not deliver the next sample -- just release the acquired buffer.
    if (m_bEndOfStream)
    {
        DbgLog((LOG_TRACE, 3, TEXT("EndOfStream already called. Not delivering next sample"))) ;
        pOut->Release() ;
        return S_OK ;
    }

    Transform(pIn, pOut) ;  // check if output buffer address changed

    if (m_L21Dec.IsOutDIBClear())
        hr = pOut->SetTime(NULL, NULL) ;         // render clear samples right away
    else
        hr = pOut->SetTime(NULL, NULL) ;         // render clear samples right away
    ASSERT(SUCCEEDED(hr)) ;

    // If a new DDraw surface has been given in GetOutputBuffer() just above, we
    // need to re-render the whole CC content on the new surface (should be rare).
    // Output CC data from internal buffer to the DDraw surface
    if (m_L21Dec.IsNewOutBuffer())
        m_L21Dec.UpdateCaptionOutput() ;

    hr = pOut->SetMediaTime(NULL, NULL) ;
    ASSERT(NOERROR == hr) ;

    // The time stamp and other settings now
    if (NULL == pIn)  // preparing out sample w/o valid in sample
    {
        // We assume that it must be a discontinuity as it's a forced output sample
        pOut->SetSyncPoint(m_bDiscontLast) ;
        pOut->SetDiscontinuity(m_bDiscontLast) ;
    }
    else  // input sample is valid
    {
        pOut->SetSyncPoint(pIn->IsSyncPoint() == S_OK) ;
        pOut->SetDiscontinuity(m_bSampleSkipped || S_OK == pIn->IsDiscontinuity()) ;
    }
    m_bSampleSkipped = FALSE ;

    // Now deliver the output sample
    MSR_START(m_idDelvWait) ;  // delivering output sample
    hr = m_pOutput->Deliver(pOut) ;
    MSR_STOP(m_idDelvWait) ;   // done delivering output sample
    if (FAILED(hr))  // Deliver failed for some reason. Eat the error and just go ahead.
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Deliver() of output sample failed (Error 0x%lx)"), hr)) ;
    }
    else
    {
        DbgLog((LOG_TRACE, 5, TEXT("Delivered %sClear output sample for time (%s, %s)"),
            m_L21Dec.IsOutDIBClear() ? TEXT("") : TEXT("NON-"),
            prtStart ? (LPCTSTR)CDisp(*prtStart, CDISP_DEC) : TEXT("NULL"),
            prtStop  ? (LPCTSTR)CDisp(*prtStop, CDISP_DEC)  : TEXT("NULL"))) ;
        m_bMustOutput = FALSE ;  // we just delivered an output sample
    }
    pOut->Release() ;  // release the output sample

    if (prtStop)  // if we had a valid time stamp
        m_rtLastOutStop = *prtStop ;  // remember the stop of this sample
    else          // invalid / no timestamp
        m_rtLastOutStop += m_rtTimePerOutSample ;  // just advance it

    return S_OK ;
}


// #define PACKET_DUMP
#ifdef PACKET_DUMP  // only for debug builds
//
// A helper function to dump the GOP Packets with Line21 data for internal debugging ONLY
//
void DumpPacket(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    AM_L21_GOPUD_ELEMENT Elem ;
    TCHAR                achBuffer[100] ;
    BOOL                 bDumped = TRUE ;
    int                  iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;

    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d (%2.2x)"),
        iElems, pGOPUDPacket->Header.bTopField_Rsrvd_NumElems)) ;
    ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clear it
    for (int i = 0 ; i < iElems ; i++)
    {
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"),
            (int)Elem.bMarker_Switch, (int)Elem.chFirst, (int)Elem.chSecond) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
            achBuffer[12 * (i % 6) + 10] = ' ' ;
        else
            achBuffer[12 * (i % 6) + 10] = '*' ; // indicates bad marker bit
        achBuffer[12 * (i % 6) + 11] = ' ' ;     // separator space
        bDumped = FALSE ;  // something not dumped yet

        if (0 == (i+1) % 6) // 6 elems per line
        {
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
            bDumped = TRUE ;
        }
    }  // end of for (i)

    // if there is something that's not been dumped yet, pad it with NULLs to the end
    // and then dump.
    if (!bDumped)
    {
        ZeroMemory(achBuffer + 12 * (i % 6), 100 - 12 * (i % 6)) ;
        DbgLog((LOG_TRACE, 0, achBuffer)) ;
    }
}


//
// A helper function to dump the ATSC Packets with Line21 data for internal debugging ONLY
//
void DumpATSCPacket(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    AM_L21_ATSCUD_ELEMENT Elem ;
    TCHAR                 achBuffer[100] ;
    BOOL                  bDumped = TRUE ;
    int                   iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;

    DbgLog((LOG_TRACE, 0, TEXT("Data Flags: %sEM, %sCC, %sAdditional"),
        ISATSCUD_EM_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_CC_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_ADDL_DATA(pATSCUDPacket) ? TEXT("") : TEXT("Not "))) ;
    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d"), iElems)) ;
    DbgLog((LOG_TRACE, 0, TEXT("EM Data: 0x%x"), GETATSCUD_EM_DATA(pATSCUDPacket))) ;

    if (ISATSCUD_CC_DATA(pATSCUDPacket))  // if CC data present then dump that
    {
        ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clear it
        for (int i = 0 ; i < iElems ; i++)
        {
            Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
            wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"),
                (int)Elem.bCCMarker_Valid_Type, (int)Elem.chFirst, (int)Elem.chSecond) ;
            if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
                achBuffer[12 * (i % 6) + 10] = ' ' ;
            else
                achBuffer[12 * (i % 6) + 10] = '*' ; // indicates bad marker bit
            achBuffer[12 * (i % 6) + 11] = ' ' ;     // separator space
            bDumped = FALSE ;  // something not dumped yet

            if (0 == (i+1) % 6) // 6 elems per line
            {
                DbgLog((LOG_TRACE, 0, achBuffer)) ;
                bDumped = TRUE ;
            }
        }  // end of for (i)

        // if there is something that's not been dumped yet, pad it with NULLs to the end
        // and then dump.
        if (!bDumped)
        {
            ZeroMemory(achBuffer + 12 * (i % 6), 100 - 12 * (i % 6)) ;
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
        }
    }

    DbgLog((LOG_TRACE, 0, TEXT("Marker bits: 0x%x"), GETATSCUD_MARKERBITS(pATSCUDPacket))) ;
}

#endif // PACKET_DUMP


HRESULT CLine21DecFilter2::ProcessGOPPacket_DVD(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::ProcessGOPPacket_DVD(0x%lx)"), pIn)) ;

    // Get the input data packet and verify that the contents are OK
    HRESULT  hr ;
    PAM_L21_GOPUD_PACKET  pGOPUDPacket ;
    hr = pIn->GetPointer((LPBYTE *)&pGOPUDPacket) ;
    if (! VerifyGOPUDPacketData(pGOPUDPacket) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() != GETGOPUD_PACKETSIZE(pGOPUDPacket))
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("pIn->GetActualDataLength() [%d] and data size [%d] in packet mismatched"),
            pIn->GetActualDataLength(), GETGOPUD_PACKETSIZE(pGOPUDPacket))) ;
        return S_FALSE ;
    }

#ifdef PACKET_DUMP
    DumpPacket(pGOPUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_GOPUD_ELEMENT    Elem ;
    REFERENCE_TIME          rtInterval ;
    int     iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }

    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerInSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s)) discon(%d)"),
            (LPCTSTR)CDisp(m_rtStart, CDISP_DEC), (LPCTSTR)CDisp(rtTemp, CDISP_DEC), (LPCTSTR)CDisp(m_rtStop, CDISP_DEC),
            S_OK == pIn->IsDiscontinuity())) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;

        rtInterval = (m_rtStop - m_rtStart) / iElems ;
        m_bNoTimeStamp = FALSE ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        rtInterval = 0 ;
        m_bNoTimeStamp = TRUE ;
    }

    LONGLONG   llMediaInterval ;
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerInSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        llMediaInterval = 0 ;
    }

    BOOL   bTopFirst = ISGOPUD_TOPFIELDFIRST(pGOPUDPacket) ;
    DbgLog((LOG_TRACE, 5,
            TEXT("Got a Line21 packet with %d elements, %s field first"),
            iElems, bTopFirst ? TEXT("Top") : TEXT("Bottom"))) ;
    for (int i = bTopFirst ? 0 : 1 ;  // if top field is not first,
         i < iElems ; i++)            // pick next field to start with
    {
        m_rtStop = m_rtStart + rtInterval ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
        {
            //
            // In the WB titles the bottom field's data has wrong marker
            // bit set so that we don't try to decode them. But the titles
            // from Columbia/Tristar (and God knows who else) doesn't do
            // that causing us to look at every field's data which causes
            // CC to flash away with the arrival of the next EOC (14 2F),
            // because it's not recognized as the repeat of the last EOC
            // due to the (0, 0) pair with valid marker bit. So we knowingly
            // skip the alternate field's data to avoid this problem.
            //
            if ( (bTopFirst  && (i & 0x01))  ||     // top first & odd index
                 (!bTopFirst && 0 == (i & 0x01)) )  // bottom first & even index
            {
                DbgLog((LOG_TRACE, 5,
                    TEXT("(0x%x, 0x%x) decode skipped for element %d -- the 'other' field"),
                    Elem.chFirst, Elem.chSecond, i)) ;
                // Advance the time stamps anyway
                m_rtStart = m_rtStop ;
                m_llMediaStart = m_llMediaStop ;
                continue ;
            }

            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and go to the next element.
            if (m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond))
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
        }  // end of check for good markerbit and valid flag
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid flag"),
                Elem.bMarker_Switch, Elem.chFirst, Elem.chSecond)) ;

        // We need to increment the time stamp though;
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)

    return S_OK ;
}


HRESULT CLine21DecFilter2::ProcessGOPPacket_ATSC(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::ProcessGOPPacket_ATSC(0x%lx)"), pIn)) ;

    // Get the input data packet and verify that the contents are OK
    HRESULT  hr ;
    PAM_L21_ATSCUD_PACKET  pATSCUDPacket ;
    hr = pIn->GetPointer((LPBYTE *) &pATSCUDPacket) ;
    ASSERT(hr == NOERROR) ;
    if (! VerifyATSCUDPacketData(pATSCUDPacket) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("ATSC Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() < GETATSCUD_PACKETSIZE(pATSCUDPacket))
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("pIn->GetActualDataLength() [%d] is less than minm ATSC_UD data size [%d]"),
            pIn->GetActualDataLength(), GETATSCUD_PACKETSIZE(pATSCUDPacket))) ;
        return S_FALSE ;
    }

#ifdef PACKET_DUMP
    DumpATSCPacket(pATSCUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_ATSCUD_ELEMENT    Elem ;
    REFERENCE_TIME           rtInterval ;
    int     iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }

    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerInSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s))"),
                (LPCTSTR)CDisp(m_rtStart, CDISP_DEC), (LPCTSTR)CDisp(rtTemp, CDISP_DEC),
                (LPCTSTR)CDisp(m_rtStop, CDISP_DEC))) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;

        rtInterval = (m_rtStop - m_rtStart) / iElems ;
        m_bNoTimeStamp = FALSE ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        rtInterval = 0 ;
        m_bNoTimeStamp = TRUE ;
    }

    LONGLONG   llMediaInterval ;
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerInSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        llMediaInterval = 0 ;
    }

    for (int i = 0 ; i < iElems ; i++)
    {
        m_rtStop = m_rtStart + rtInterval ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
        if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
        {
            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and go to the next element.
            if (m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond))
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
        }  // end of check for good markerbit and valid flag
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid marker/type flag"),
                Elem.bCCMarker_Valid_Type, Elem.chFirst, Elem.chSecond)) ;

        // We need to increment the time stamp though;
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)

    return S_OK ;
}


//
//  Receive: It's the real place where the output samples are created by
//           decoding the byte pairs out of the input stream.
//
HRESULT CLine21DecFilter2::Receive(IMediaSample * pIn)
{
    CAutoLock   lock(&m_csReceive);
    HRESULT     hr ;

    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Receive(0x%p)"), pIn)) ;

    //
    // First check if we must do anything at all
    //
    if (!m_bMustOutput  &&                                         // not a must output
        (AM_L21_CCSTATE_Off    == m_L21Dec.GetServiceState()  ||   // CC turned off
         AM_L21_CCSERVICE_None == m_L21Dec.GetCurrentService()))   // no CC selected
    {
        DbgLog((LOG_TRACE, 3,
            TEXT("Captioning is off AND we don't HAVE TO output. Skipping everything."))) ;
        return NOERROR ;  // we are done with this sample
    }

    // Get the input format info; we'll use the same for output
    ASSERT(m_pOutput != NULL) ;

    //
    // First check if it's a discontinuity sample.  If so, just flush everything
    // and send an output sample down.
    //
    hr = pIn->IsDiscontinuity() ;
    if (S_OK == hr)  // got a discontinuity; flush everything, refresh output
    {
        // If we got a discontinuity in the last sample, we flushed and all.
        // We can skip this one safely.
        if ( ! m_bDiscontLast )  // new discontinuity sample => do flush etc.
        {
            // Flush the internal buffers (caption and output DIB section)
            DbgLog((LOG_TRACE, 1, TEXT("-->> Got a discontinuity sample. Flushing all data..."))) ;  // 1
            m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
            m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
            m_InSampleQueue.ClearQueue() ;   // remove all queued up samples
            m_bMustOutput  = TRUE ;          // we must output a sample NOW
            m_bDiscontLast = TRUE ;          // remember we handled a discontinuity
        }
        else  // another discontinuity => ignore it
        {
            DbgLog((LOG_TRACE, 1, TEXT("--> Got a discontinuity sample after another. Ignore it."))) ;
        }
    }  // end of if (discontinuity sample)
    else
    {
#ifdef DEBUG
        if (AM_L21_CCSUBTYPEID_BytePair == m_eSubTypeIDIn)  // only for ATV bytepair CC
        {
            BYTE  *pbInBytePair ;
            hr = pIn->GetPointer(&pbInBytePair) ;      // Get the input byte pair
            REFERENCE_TIME  rtStart, rtStop ;
            hr = pIn->GetTime(&rtStart, &rtStop) ;
            DbgLog((LOG_TRACE, 5, TEXT("Got normal sample (0x%x, 0x%x) for time: %s -> %s"),
                pbInBytePair[0], pbInBytePair[1],
                S_OK == hr ? (LPCTSTR)CDisp(rtStart, CDISP_DEC) : TEXT("**Bad**"), 
                S_OK == hr ? (LPCTSTR)CDisp(rtStop,  CDISP_DEC) : TEXT("**Bad**"))) ;
        }
#endif // DEBUG

        m_bDiscontLast = FALSE ;       // remember we got a normal sample

        // Add it to the sample queue -- will have to wait, if queue is full
        if (! m_InSampleQueue.AddItem(pIn) )
        {
            DbgLog((LOG_TRACE, 1, TEXT("WARNING: Adding an input sample failed!!!"))) ;
            m_bDiscontLast = TRUE ;  // we dropped a sample; so discontinuity is ON
            // Because we are setting the above flag, we'll happen to ignore the next
            // discontinuity sample, if it came right away.  So we must do the same
            // things now.  Also it makes sense as this is a bad state, where flushing
            // the output is not a bad idea.
            m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
            m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
        }
    }

    //
    // If we must output a sample, we'll do it now.  This may be either because
    // * we haven't sent down any sample in this play session
    // * it's the discontinuity sample
    // * CC state/service choice has been changed by the user via IAMLine21Decoder
    // * some "unknown" reason (??)
    //
    if (m_bMustOutput)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Signal for sending an output sample, because we must..."))) ;
        m_OutputThread.SignalForOutput() ;
    }

    return S_OK ;  // we are done
}


HRESULT CLine21DecFilter2::ProcessSample(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::ProcessSample(%p)"), pIn)) ;

    ASSERT(pIn) ;

    HRESULT          hr ;
    // REFERENCE_TIME  *prtStart = NULL, *prtStop = NULL ;

    //
    // Process the sample based on filter's input format type
    //
    switch (m_eSubTypeIDIn)
    {
    case AM_L21_CCSUBTYPEID_BytePair:
        {
            //
            // Determine if the sample is for Field1 or Field2.  We need to process
            // the field1 data and reject the field2 data.
            //
            IMediaSample2  *pSample2 ;
            AM_SAMPLE2_PROPERTIES   Sample2Prop ;
            hr = pIn->QueryInterface(IID_IMediaSample2, (LPVOID *) &pSample2) ;
            if (SUCCEEDED(hr))
            {
                hr = pSample2->GetProperties(sizeof(Sample2Prop), (BYTE *) &Sample2Prop) ;
                pSample2->Release() ;
                DbgLog((LOG_TRACE, 5, TEXT("Line21: Input sample for field%lu"),
                        Sample2Prop.dwTypeSpecificFlags)) ;
                if (Sample2Prop.dwTypeSpecificFlags)  // field2 data
                {
                    break ;  // don't process it
                }
            }

            // Now we are ready to process the bytepair sample
            BYTE  *pbInBytePair ;
            LONG   lInDataSize ;
            hr = pIn->GetPointer(&pbInBytePair) ;      // Get the input byte pair
            lInDataSize = pIn->GetActualDataLength() ; // se how much data we got
            if (FAILED(hr)  ||  2 != lInDataSize)  // bad data -- complain and just skip it
            {
                DbgLog((LOG_ERROR, 1, TEXT("%d bytes of data sent as Line21 data (hr = 0x%lx)"),
                    lInDataSize, hr)) ;
                ASSERT(NOERROR == hr) ;
                ASSERT(2 == lInDataSize) ;
                break ;
            }

            REFERENCE_TIME  rtStart, rtStop ;
            if (NOERROR == (hr = pIn->GetTime(&rtStart, &rtStop)))
            {
                m_rtStart = rtStart ;
                m_rtStop  = rtStop ;
                // In case the end timestamp on the incoming media sample is too
                // far off or too close, we fix it here to something practical.
                if (m_rtStop != m_rtStart + m_rtTimePerOutSample)
                    m_rtStop = m_rtStart + m_rtTimePerOutSample ;
                m_bNoTimeStamp = FALSE ;
            }
            else
            {
                DbgLog((LOG_TRACE, 3, TEXT("GetTime() call failed (Error 0x%lx)"), hr)) ;
                m_bNoTimeStamp = TRUE ;
            }

            // Now decode into the received output sample buffer
            if (m_L21Dec.DecodeBytePair(pbInBytePair[0], pbInBytePair[1]))
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                        pbInBytePair[0], pbInBytePair[1])) ;
            }

            break ;
        }  // end of case ..._BytePair

        case AM_L21_CCSUBTYPEID_GOPPacket:
        {
            BYTE *pbGOPPacket ;
            hr = pIn->GetPointer((LPBYTE *)&pbGOPPacket) ;
            ASSERT(hr == NOERROR) ;
            GOPPACKET_CCTYPE  eGOP_CCType = DetectGOPPacketDataType(pbGOPPacket) ;
            if (GOP_CCTYPE_None != eGOP_CCType  && // NOT filler CC packet  AND...
                m_eGOP_CCType   != eGOP_CCType)    // change of CC type
            {
                DbgLog((LOG_TRACE, 3, TEXT("GOPPacket CC type changed from %d to %d"),
                        m_eGOP_CCType, eGOP_CCType)) ;

                // Flush internal caption buffers and output sample buffer
                m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
                m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
                m_bMustOutput  = TRUE ;          // we must output a sample NOW
                // SHOULD WE SIGNAL TO SEND AN OUTPUT SAMPLE or IS IT OK ANYWAY?

                m_eGOP_CCType = eGOP_CCType ;    // switch to new CC type
            }

            switch (m_eGOP_CCType)
            {
            case GOP_CCTYPE_DVD:
                hr = ProcessGOPPacket_DVD(pIn) ;
                break ;

            case GOP_CCTYPE_ATSC:
                hr = ProcessGOPPacket_ATSC(pIn) ;
                break ;

            default:
                DbgLog((LOG_TRACE, 3, TEXT("Unknown GOP packet data type (%d)"), m_eGOP_CCType)) ;
                break ;
            }  // end of switch (.._CCType)

            break ;
        }  // end of case ..._GOPPacket

        default:  // it's a bad data format type (how could we get into it?)
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: We are in a totally unexpected format type"))) ;
            ASSERT(! TEXT("Bad connection subtype used")) ;
            return E_FAIL ;  // or E_UNEXPECTED ; ???
    }

    return NOERROR ;
}


//
//  Transform: It's mainly a place holder because we HAVE to override it.
//             The actual work is done in Receive() itself. Here we detect
//             if the buffer addres provided by downstream filter's allocator
//             has changed or not; if yes, we have to re-write entire text.
//
HRESULT CLine21DecFilter2::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    DbgLog((LOG_TRACE, 3, TEXT("CLine21DecFilter2::Transform(0x%p, 0x%p)"),
            pIn, pOut)) ;

    UNREFERENCED_PARAMETER(pIn) ;

    HRESULT   hr ;
    LPBITMAPINFO       lpbiNew ;
    BITMAPINFOHEADER   biCurr ;

    // Check if there has been any dynamic format change; if so, make adjustments
    // accordingly.
    AM_MEDIA_TYPE  *pmt ;
    hr = pOut->GetMediaType(&pmt) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (S_OK == hr)  // i.e, format has changed
    {
        hr = pOut->SetMediaType(NULL) ; // just to tell OverlayMixer, I am not changing again
        ASSERT(SUCCEEDED(hr)) ;
        // m_mtOutput = *pmt ;
        lpbiNew = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->pbFormat))) ;
        m_L21Dec.GetOutputFormat(&biCurr) ;
        if (0 != memcmp(lpbiNew, &biCurr, sizeof(BITMAPINFOHEADER)))
        {
            // output format has been changed -- update our internel values now
            DbgLog((LOG_TRACE, 2, TEXT("Output format has been dynamically changed"))) ;
            m_L21Dec.SetOutputOutFormat(lpbiNew) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
        }

        m_pOutput->CurrentMediaType() = *pmt ;
        DeleteMediaType(pmt) ;
    }

    return S_OK ;
}


//
//  BeginFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter2::BeginFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::BeginFlush()"))) ;

    CAutoLock   Lock(&m_csFilter) ;

    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverBeginFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DeliverBeginFlush() on out pin failed (Error 0x%lx)"), hr)) ;

        m_InSampleQueue.ClearQueue() ;   // clear queued up samples on flush
        m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
        m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
        SetBlendingState(FALSE) ;        // turn off blending through VMR
    }

    return hr ;
}


//
//  EndFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter2::EndFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::EndFlush()"))) ;

    CAutoLock   Lock(&m_csFilter) ;

    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverEndFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DeliverEndFlush() on out pin failed (Error 0x%lx)"), hr)) ;
    }

    return hr ;
}


//
//  EndOfStream: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter2::EndOfStream(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::EndOfStream()"))) ;

    // First let's do some housekeeping on our side
    // SetBlendingState(FALSE) ; // turn off CC stream
    m_OutputThread.Close() ;  // stop the output thread
    m_InSampleQueue.Close() ; // flush in-samples and close queue

    CAutoLock   Lock(&m_csFilter) ;
    HRESULT     hr = NOERROR ;

    if (NULL != m_pOutput)
    {
        SetBlendingState(FALSE) ; // turn off CC stream

        // Now deliver the EoS downstream
        hr = m_pOutput->DeliverEndOfStream() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DeliverEndOfStream() on out pin failed (Error 0x%lx)"), hr)) ;
        else
            m_bEndOfStream = TRUE ;  // must not send down any more samples
    }

    return hr ;
}


HRESULT CLine21DecFilter2::GetDefaultFormatInfo(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetDefaultFormatInfo()"))) ;
    //
    // We can't take the lock in this method, because it is called in Transform()
    // which is called from Receive() causing us to take m_csReceive and then
    // m_csFilter which is opposite of what Stop, Pause etc. methods do thereby
    // causing a potential for deadlock.
    //

    // build a VIDEOINFO struct with default internal BITMAPINFO
    DWORD   dwSize ;
    m_L21Dec.GetDefaultFormatInfo(NULL, &dwSize) ;

    if (m_dwDefFmtSize != dwSize + SIZE_PREHEADER)
    {
        if (m_pviDefFmt)
        {
            delete m_pviDefFmt ;
            m_pviDefFmt = NULL ;
            m_dwDefFmtSize = 0 ;
        }
        m_pviDefFmt = (VIDEOINFO *) new BYTE[dwSize + SIZE_PREHEADER] ;
        if (NULL == m_pviDefFmt)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Out of memory for format block VIDEOINFO struct"))) ;
            return E_OUTOFMEMORY ;
        }
        m_dwDefFmtSize = dwSize + SIZE_PREHEADER;  // total size of default format data
    }

    // We want to get BITMAPINFO part of VIDEOINFO struct from our GDI class
    m_L21Dec.GetDefaultFormatInfo((LPBITMAPINFO) &(m_pviDefFmt->bmiHeader), &dwSize) ; // get default data

    // Set the other fields
    LARGE_INTEGER  li ;
    li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
    RECT   rc ;
    rc.left = rc.top = 0 ;
    rc.right = HEADER(m_pviDefFmt)->biWidth ;
    rc.bottom = abs(HEADER(m_pviDefFmt)->biHeight) ;  // just make sure rect fields are +ve
    m_pviDefFmt->rcSource = rc ;
    m_pviDefFmt->rcTarget = rc ;
    m_pviDefFmt->dwBitRate = MulDiv(HEADER(m_pviDefFmt)->biSizeImage,
        80000000, li.LowPart) ;
    m_pviDefFmt->dwBitErrorRate = 0 ;
    m_pviDefFmt->AvgTimePerFrame = (LONGLONG) 333667L ; // => 29.97 fps

    return NOERROR ;
}


//
//  CheckInputType: Check if you can support the input data type
//
HRESULT CLine21DecFilter2::CheckInputType(const CMediaType* pmtIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::CheckInputType(0x%lx)"), pmtIn)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock

    if (NULL == pmtIn)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }

    //  We only support MEDIATYPE_AUXLine21Data and
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    GUID    SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  &&
        ISSUBTYPEVALID(m_eSubTypeIDIn)) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Rejecting invalid Line 21 Data subtype"))) ;
        return E_INVALIDARG ;
    }

    // Check that this is a valid format type
    if (FORMAT_VideoInfo == *pmtIn->FormatType())
    {
        ASSERT(m_pOutput != NULL) ;

        //
        // Make sure the given input format is valid. If not, reject it and use our
        // own default format data.
        //
        if (! IsValidFormat(pmtIn->Format()) )
        {
            DbgLog((LOG_TRACE, 1, TEXT("Invalid format data given -- using our own format data."))) ;
            if (NULL == m_pviDefFmt)
            {
                HRESULT  hr = GetDefaultFormatInfo() ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                    return hr ;
                }
            }
            // We should fix the input mediatype too (with the default VideoInfo data).
            m_pInput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
            m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
            m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
        }
        else  // seems to be valid format spec.
        {
            //
            // Get the specified input format info; we'll use the same for output
            //
            if (pmtIn->FormatLength() > 0) // only if there is some format data
            {
                m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
                m_pOutput->CurrentMediaType().SetFormat(pmtIn->Format(), pmtIn->FormatLength()) ;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: FORMAT_VideoInfo and no format block specified."))) ;
                return E_INVALIDARG ;
            }
        }
    }
    else if (GUID_NULL   == *pmtIn->FormatType() ||  // wild card
             FORMAT_None == *pmtIn->FormatType())    // no format
    {
        //
        // input pin didn't get a format type info; use our own
        //
        DbgLog((LOG_TRACE, 3, TEXT("No format type specified -- using our own format type."))) ;
        if (NULL == m_pviDefFmt)
        {
            HRESULT  hr = GetDefaultFormatInfo() ;
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                return hr ;
            }
        }
        m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
    }
    else  // something weird that we don't like
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting invalid format type"))) ;
        // tell what input type too??
        return E_INVALIDARG ;
    }

    // some more level 3 debug log here???

    // We should branch based on what format type we got, because ..GOPPacket
    // type needs to be unwrapped and parsed whereas the ..BytePair format
    // is to be directly parsed.

    // do we have a case for -- return VFW_E_TYPE_NOT_ACCEPTED ???

    return NOERROR ;
}


//
//  CheckTransform: check if this input to this output transform is supported
//
HRESULT CLine21DecFilter2::CheckTransform(const CMediaType* pmtIn,
                                         const CMediaType* pmtOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::CheckTransform(0x%lx, 0x%lx)"),
            pmtIn, pmtOut)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock

    if (NULL == pmtIn || NULL == pmtOut)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }

    //  We only support MEDIATYPE_AUXLine21Data and
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    //  Check that input is a valid subtype type
    //  and format is VideoInfo or None
    GUID SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  &&   // line21 data type and...
           ISSUBTYPEVALID(m_eSubTypeIDIn)  &&              // valid subtype (bytepair/GOPPacket) and...
           (FORMAT_VideoInfo == *pmtIn->FormatType() ||    // format VideoInfo  or
            FORMAT_None      == *pmtIn->FormatType() ||    // format None (KS wild card)  or
            GUID_NULL        == *pmtIn->FormatType())) )   // GUID Null (DShow wild card)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: input type not Line21 / subtype / formattype invalid"))) ;
        return E_INVALIDARG ;
    }

    // and we only accept video as output
    if (MEDIATYPE_Video != *pmtOut->Type())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output type is not VIDEO"))) ;
        return E_INVALIDARG ;
    }

    // check output is VIDEOINFO type
    if (FORMAT_VideoInfo != *pmtOut->FormatType())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output format type is not VIDEOINFO"))) ;
        return E_INVALIDARG ;
    }

    //
    //  Verify that the output size specified by the input and output mediatype
    //  are acceptable.
    //
    if ( !IsValidFormat(pmtOut->Format())  ||             // invalid output format data  OR
         // !m_L21Dec.IsSizeOK(HEADER(pmtOut->Format()))  || // output size is NOT acceptable  OR
         (FORMAT_VideoInfo == *pmtIn->FormatType() &&     // valid input format type and...
          !IsValidFormat(pmtIn->Format()) // &&               // valid input format data and...
          // !m_L21Dec.IsSizeOK(HEADER(pmtIn->Format()))) )  // output size is NOT acceptable
         ) )  // just closing parentheses
    {
        DbgLog((LOG_TRACE, 1, TEXT("Rejecting: Input/output-specified output size is unacceptable"))) ;
        return E_INVALIDARG ;
    }

#if 0

#define rcS1 ((VIDEOINFO *)(pmtOut->Format()))->rcSource
#define rcT1 ((VIDEOINFO *)(pmtOut->Format()))->rcTarget

    DbgLog((LOG_TRACE, 3,
        TEXT("Input Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtIn->Format())->biWidth,
        HEADER(pmtIn->Format())->biHeight,
        HEADER(pmtIn->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("Output Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtOut->Format())->biWidth,
        HEADER(pmtOut->Format())->biHeight,
        HEADER(pmtOut->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
        rcS1.left, rcS1.top, rcS1.right, rcS1.bottom)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
        rcT1.left, rcT1.top, rcT1.right, rcT1.bottom)) ;

    DWORD     dwErr ;

    // If we've been given rectangles, use What???
    if (!IsRectEmpty(&rcS1) || !IsRectEmpty(&rcT1))
    {
        DbgLog((LOG_TRACE, 4, TEXT("Either source or dest rect is empty"))) ;
        dwErr = 0 ;  // what to do here??
    }
    else
    {
        DbgLog((LOG_TRACE, 4, TEXT("Source or dest rects are not empty")));
        dwErr = 0 ;  // what to do here??
    }

    if (dwErr != 0)  // or what to check against??
    {
        DbgLog((LOG_ERROR, 1, TEXT("decoder rejected this transform"))) ;
        return E_FAIL ;
    }

#endif // #if 0

    return NOERROR ;
}


//
//  CompleteConnect: Overridden to know when a connection is made to this filter
//
HRESULT CLine21DecFilter2::CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::CompleteConnect(%s, 0x%lx)"),
        dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pReceivePin)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LPBITMAPINFO lpbmi ;
    HRESULT      hr ;

    if (PINDIR_OUTPUT == dir)
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D output pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

        //
        // This version of the line21 decoder is only supposed to work with the VMR
        //
        IVMRVideoStreamControl  *pVMRSC ;
        hr = pReceivePin->QueryInterface(IID_IVMRVideoStreamControl, (LPVOID *) &pVMRSC) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin supports IVMR* interface"))) ;
            pVMRSC->Release() ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin does NOT support IVMR* interface"))) ;
            return E_FAIL ;
        }

        //
        // Now get the the output pin's mediatype and use that for our
        // output size etc.
        //
        const CMediaType  *pmt = &(m_pOutput->CurrentMediaType()) ;
        ASSERT(MEDIATYPE_Video == *pmt->Type()  &&
            FORMAT_VideoInfo == *pmt->FormatType()) ;
        // m_mtOutput = *pmt ;  // this is our output mediatype for now
        if (pmt->FormatLength() > 0)  // only if there is some format data
        {
            lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->Format()))) ;
            ASSERT(lpbmi) ;

            // Set the output format info coming from downstream
            m_L21Dec.SetOutputOutFormat(lpbmi) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
        }

        return NOERROR ;
    }

    ASSERT(PINDIR_INPUT == dir) ;
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D input pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

        // const CMediaType  *pmt = &(m_pInput->CurrentMediaType()) ;
        AM_MEDIA_TYPE mt ;
        hr = pReceivePin->ConnectionMediaType(&mt) ;
        if (SUCCEEDED(hr))  // ONLY if upstream filter provides mediatype used in the connection
        {
            // If format type (and format data) has been specified then save it as
            // input-side output format
            if (FORMAT_VideoInfo == mt.formattype  &&
                mt.cbFormat > 0)
            {
                lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(mt.pbFormat))) ;
                ASSERT(lpbmi) ;

                // Store whatever output format info is specified by upstream filter
                m_L21Dec.SetOutputInFormat(lpbmi) ;
                GetDefaultFormatInfo() ;  // to pick any change in format data
            }

            FreeMediaType(mt) ;
        }  // end of if ()
    }

    //
    //  We MUST clear the caption data buffers and any exisiting internal state
    //  now.  This is most important in the cases where the filter has been
    //  used to decode some Line 21 data, disconnected from the source and then
    //  reconnected again to play another stream of data.
    //
    m_L21Dec.FlushInternalStates() ;   // reset internal state

    return NOERROR ;
}


//
//  BreakConnect: Overridden to know when a connection is broken to our pin
//
HRESULT CLine21DecFilter2::BreakConnect(PIN_DIRECTION dir)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::BreakConnect(%s)"),
            dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (PINDIR_OUTPUT == dir)
    {
        // If not connected yet, just return (but indicate with S_FALSE)
        if (! m_pOutput->IsConnected() )
            return S_FALSE ;

        m_L21Dec.SetOutputOutFormat(NULL) ;  // no output format from downstream
        GetDefaultFormatInfo() ;  // to pick any change in format data
        m_L21Dec.SetDDrawSurface(NULL) ;  // DDraw output surface not available now

        //
        // NOTE 1: We are definitely not running/paused. So no need to delete/
        // create output DIB section here.
        //

        //
        // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
        // base class code for CTransformOutputPin::BreakConnect() already
        // does that.
        //
        return NOERROR ;
    }

    ASSERT(PINDIR_INPUT == dir) ;

    // If not connected yet, just return (but indicate with S_FALSE)
    if (! m_pInput->IsConnected() )
        return S_FALSE ;

    // m_L21Dec.SetOutputInFormat(NULL) ;  // no output format from upstream
    GetDefaultFormatInfo() ;  // to pick any change in format data

    //
    // NOTE 1: We are definitely not running/paused. So no need to delete/
    // create output DIB section here.
    //

    //
    // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
    // base class code for CTransformOutputPin::BreakConnect() already
    // does that.
    //
    return NOERROR ;
}

//
//  SetMediaType: overriden to know when the media type is actually set
//
HRESULT CLine21DecFilter2::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetMediaType(%s, 0x%lx)"),
            direction == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pmt)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    LPTSTR alpszFormatIDs[] = { TEXT("Invalid"), TEXT("BytePair"),
								TEXT("GOPPacket"), TEXT("VBIRawData") } ;

    if (PINDIR_OUTPUT == direction)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Output type: %d x %d x %d"),
            HEADER(m_pOutput->CurrentMediaType().Format())->biWidth,
            HEADER(m_pOutput->CurrentMediaType().Format())->biHeight,
            HEADER(m_pOutput->CurrentMediaType().Format())->biBitCount)) ;
        return NOERROR ;
    }

    ASSERT(PINDIR_INPUT == direction) ;
    DbgLog((LOG_TRACE, 3, TEXT("Input type: <%s>"),
        alpszFormatIDs[MapGUIDToID(m_pInput->CurrentMediaType().Subtype())])) ;

    if (m_pOutput && m_pOutput->IsConnected())
    {
        DbgLog((LOG_TRACE, 2, TEXT("*** Changing IN when OUT already connected"))) ;
        DbgLog((LOG_TRACE, 2, TEXT("Reconnecting the output pin..."))) ;
        return m_pGraph->Reconnect(m_pOutput) ;
    }

    return NOERROR ;
}


#if 0  // Quality Management is deferred for now as OvMixer always says (Flood, 1000)

//
//  AlterQuality: overriden to handle quality messages and not pass them upstream
//
HRESULT CLine21DecFilter2::AlterQuality(Quality q)
{
    DbgLog((LOG_TRACE, 5, TEXT("QM: CLine21DecFilter2::AlterQuality(%s, %ld)"),
            Flood == q.Type ? TEXT("Flood") : TEXT("Famine"), q.Proportion)) ; // log trace=5

    if (1000 == q.Proportion)
    {
        DbgLog((LOG_TRACE, 5, TEXT("QM: Quality is just right.  Don't change anything."))) ;
        return S_OK ;
    }

    if (Flood == q.Type)    // Flood: too much output
    {
        if (q.Proportion > 500 && q.Proportion <= 900)
        {
            m_iSkipSamples += 1 ;
        }
        else if (q.Proportion > 300 && q.Proportion <= 500)
        {
            m_iSkipSamples += 2 ;
        }
        else if (q.Proportion <= 300)
        {
            m_iSkipSamples += 3 ;
        }
        m_iSkipSamples = min(m_iSkipSamples, 10) ;  // at least 1 in 10 is shown
    }
    else                    // Famine: send more output
    {
        if (q.Proportion > 1200)  // could take 20% more
        {
            m_iSkipSamples-- ;
            if (m_iSkipSamples < 0)
                m_iSkipSamples = 0 ;
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("QM: Adjusted rate is %d samples are skipped."), m_iSkipSamples)) ;
    return S_OK ;
}
#endif // #if 0 -- end of commented out AlterQuality() implementation


// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.
//
//  GetMediaType: Get our preferred media type (in order)
//
HRESULT CLine21DecFilter2::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetMediaType(%d, 0x%lx)"),
            iPosition, pmt)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LARGE_INTEGER       li ;
    CMediaType          cmt ;
    LPBITMAPINFOHEADER  lpbi ;

    if (NULL == pmt)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Media type is NULL, Sorry!!"))) ;
        return E_INVALIDARG ;
    }

    // Output choices depend on the input connected
    if (! m_pInput->CurrentMediaType().IsValid() )
    {
        DbgLog((LOG_TRACE, 3, TEXT("No input type set yet, Sorry!!"))) ;
        return E_FAIL ;
    }

    if (iPosition < 0)
    {
        return E_INVALIDARG ;
    }

    // Find the format info specified in the input VideoInfo struct
    cmt = m_pInput->CurrentMediaType() ;
    BITMAPINFOHEADER bih ;
    BOOL  bOutKnown = (S_OK == m_L21Dec.GetOutputOutFormat(&bih)) ;
    if (! bOutKnown )
    {
        HRESULT hr = m_L21Dec.GetOutputFormat(&bih) ;
        if (FAILED(hr))      // really weird!!!
            return E_FAIL ;  // we don't want to continue in such a case
    }

    BOOL bInKnown = NULL != cmt.Format() && IsValidFormat(cmt.Format()) ; // just to be sure
    VIDEOINFOHEADER vih ;
    if (bInKnown)
        CopyMemory(&vih, (VIDEOINFOHEADER *)(cmt.Format()), sizeof(VIDEOINFOHEADER)) ;

    // Offer the decoder's default output format (Video) first
    switch (iPosition)
    {
    case 0: // AI44
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 0: 8 bit AI44)"))) ;

            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + (3*sizeof(DWORD)));

            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 8 ;
            lpbi->biCompression = '44IA' ; // AI44 byte swapped
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes

            DWORD* pdw = (DWORD *)((LPBYTE)lpbi + lpbi->biSize);
            pdw[iRED]   = 0;
            pdw[iGREEN] = 0;
            pdw[iBLUE]  = 0;

            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_AI44) ;
            break;
        }

    case 1:  // ARGB4444
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 0: 16 bit ARGB(4444)"))) ;

            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + (3*sizeof(DWORD)));

            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 16 ;
            lpbi->biCompression = BI_BITFIELDS ; // use bitfields for RGB565
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes

            DWORD* pdw = (DWORD *)((LPBYTE)lpbi + lpbi->biSize);
            pdw[iRED]   = 0x0F00;
            pdw[iGREEN] = 0x00F0;
            pdw[iBLUE]  = 0x000F;

            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_ARGB4444) ;

            break ;
        }

    case 2:  // ARGB32
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 1: ARGB32 for VMR"))) ;

            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 32 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes

            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_ARGB32) ;
            break ;
        }

    default:
        return VFW_S_NO_MORE_ITEMS ;

    }  // end of switch (iPosition)

    // Now set the output formattype and sample size
    cmt.SetSampleSize(lpbi->biSizeImage) ;
    cmt.SetFormatType(&FORMAT_VideoInfo) ;

    // The fields of VIDEOINFOHEADER needs to be filled now
    if (! bInKnown ) // if the upstream filter didn't specify anything
    {
        RECT  Rect ;
        Rect.left = 0 ;
        Rect.top = 0 ;
        Rect.right = lpbi->biWidth ;
        Rect.bottom = abs(lpbi->biHeight) ;  // biHeight could be -ve, but rect fields are +ve

        // We set some default values for time/frame, src and target rects etc. etc.
        li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->AvgTimePerFrame = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcSource = Rect ;
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcTarget = Rect ;
    }
    else
        li.QuadPart = vih.AvgTimePerFrame ;

    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitRate =
        MulDiv(lpbi->biSizeImage, 80000000, li.LowPart) ;
    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitErrorRate = 0L ;

    // Set temporal compression and copy the prepared data now
    cmt.SetTemporalCompression(FALSE) ;
    *pmt = cmt ;

    return NOERROR ;
}


//
//  DecideBufferSize: Called from CBaseOutputPin to prepare the allocator's
//                    count of buffers and sizes.  It makes sense only when
//                    the input is connected.
//
HRESULT CLine21DecFilter2::DecideBufferSize(IMemAllocator * pAllocator,
                                           ALLOCATOR_PROPERTIES *pProperties)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::DecideBufferSize(0x%lx, 0x%lx)"),
            pAllocator, pProperties)) ;
    CAutoLock   Lock(&m_csFilter) ;

    // Is the input pin connected
    if (! m_pInput->IsConnected())
    {
        return E_UNEXPECTED ;
    }

    ASSERT(m_pOutput->CurrentMediaType().IsValid()) ;
    ASSERT(pAllocator) ;
    ASSERT(pProperties) ;

    // set the size of buffers based on the expected output bitmap size, and
    // the count of buffers to 1.
    pProperties->cBuffers = 1 ;
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize() ;

    ASSERT(pProperties->cbBuffer) ;

    ALLOCATOR_PROPERTIES Actual ;
    HRESULT hr = pAllocator->SetProperties(pProperties, &Actual) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Error (0x%lx) in SetProperties()"), hr)) ;
        return hr ;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer  ||
        Actual.cBuffers  < pProperties->cBuffers)
    {
        // can't use this allocator
        DbgLog((LOG_ERROR, 0, TEXT("Can't use allocator (only %d buffer of size %d given)"),
            Actual.cBuffers, Actual.cbBuffer)) ;
        return E_INVALIDARG ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("    %d buffers of %ld bytes each"),
        pProperties->cBuffers, pProperties->cbBuffer)) ;

    ASSERT(Actual.cbAlign == 1) ;
    ASSERT(Actual.cbPrefix == 0) ;

    return S_OK ;
}

// We're stopping the stream -- stop output thread, release cached data and pointers
STDMETHODIMP CLine21DecFilter2::Stop(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Stop()"))) ;

    // First stop the output thread and clear the input sample queue
    m_OutputThread.Close() ;
    m_InSampleQueue.Close() ;

    CAutoLock   Lock1(&m_csFilter) ;   // first take the filter lock
    CAutoLock   Lock2(&m_csReceive) ;  // take receive lock to block Receive()
    if (State_Running == m_State  ||
        State_Paused  == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are stopping"))) ;

        // After stop, we should clear out all states -- CC data and DDRaw surface both
        m_L21Dec.SetDDrawSurface(NULL) ;  // DDraw output surface may not be available
        m_L21Dec.FlushInternalStates() ;  // ... and clear CC internal state

        SetBlendingState(FALSE) ;  // we are done with blending for now

        // Release the downstream pin's interface now
        if (m_pPinDown)
        {
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }
    }

    HRESULT hr = CTransformFilter::Stop() ;

    return hr ;
}

// We're starting/stopping to stream -- based on that acquire or release output DC
// to reduce memory footprint etc.
STDMETHODIMP CLine21DecFilter2::Pause(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Pause()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State_Stopped == m_State)
    {
        //  Try to make sure we have at least 2 buffers
        IMemAllocator *pAlloc;
        if (SUCCEEDED(m_pInput->GetAllocator(&pAlloc))) {
            ALLOCATOR_PROPERTIES props;
            ALLOCATOR_PROPERTIES propsActual;
            pAlloc->GetProperties(&props);
            if (props.cBuffers < 4) {
                props.cBuffers = 4;
                props.cbBuffer = 200;
                props.cbAlign = max(props.cbAlign, 1);
                props.cbPrefix = 0;
                HRESULT hr = pAlloc->SetProperties(&props, &propsActual);
                DbgLog((LOG_TRACE, 2, TEXT("Setproperties returned %8.8X"), hr));
            }
            pAlloc->Release();
        }

        // We are starting a new play session; we do an exception to allow
        // the first output sample to be sent down even if the first sample
        // isn't valid for decoding.
        m_bMustOutput = TRUE ;   // we are pausing again for this new play session
        m_bDiscontLast = FALSE ; // no discontinuity from prev session remembered
        m_rtLastOutStop = (LONGLONG) 0 ;  // reset the last sample sent time
        m_eGOP_CCType = GOP_CCTYPE_Unknown ;  // reset GOP packet CC type

        // If we somehow didn't release the prev downstream pin's interface, do that now
        if (m_pPinDown)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: downstream pin interface wasn't released properly"))) ;
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }

        // Get the downstream pin's interface so that we can set rects on it later on
        m_pOutput->ConnectedTo(&m_pPinDown) ;
        if (NULL == m_pPinDown)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Running w/o connecting our output pin!!!"))) ;
            // ASSERT(m_pPinDown) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("L21D Output pin connected to %s"), (LPCTSTR)CDisp(m_pPinDown))) ;
            SetBlendingState(FALSE) ;  // keep it off until we get data
        }

        if (! m_InSampleQueue.Create() )
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: Failed creating input sample queue (events)"))) ;
            return E_FAIL ;
        }

        m_bEndOfStream = FALSE ;  // we are starting to run

#if 0  // No QM for now
        // Reset the sample skipping count for QM handling
        ResetSkipSamples() ;
#endif // #if 0
    }
    else if (State_Running == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are pausing from running"))) ;  // 1
    }

    return CTransformFilter::Pause() ;
}


STDMETHODIMP CLine21DecFilter2::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Run()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    // if (m_pPinDown)  // the output pin is connected; otherwise don't output!!!
    {
        // Start the output thread now
        if (!m_OutputThread.Create())
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: Failed creating output thread"))) ;
            return E_FAIL ;
        }
    }

    // return CBaseFilter::Run(tStart) ;
    return CTransformFilter::Run(tStart) ;
}


//
// we don't send any data during PAUSE, so to avoid hanging renderers, we
// need to return VFW_S_CANT_CUE when paused
//
HRESULT CLine21DecFilter2::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetState()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    UNREFERENCED_PARAMETER(dwMSecs) ;
    CheckPointer(State, E_POINTER) ;
    ValidateReadWritePtr(State, sizeof(FILTER_STATE)) ;

    *State = m_State ;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE ;
    else
        return S_OK ;
}


AM_LINE21_CCSUBTYPEID CLine21DecFilter2::MapGUIDToID(const GUID *pFormatIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::MapGUIDToID(0x%lx)"), pFormatIn)) ;

    if (MEDIASUBTYPE_Line21_BytePair        == *pFormatIn)
        return AM_L21_CCSUBTYPEID_BytePair ;
    else if (MEDIASUBTYPE_Line21_GOPPacket  == *pFormatIn)
        return AM_L21_CCSUBTYPEID_GOPPacket ;
    // else if (MEDIASUBTYPE_Line21_VBIRawData == *pFormatIn)
    //     return AM_L21_CCSUBTYPEID_VBIRawData ;
    else
        return AM_L21_CCSUBTYPEID_Invalid ;
}


//
// CLine21OutputThread: Line21 output thread class implementation
//
CLine21OutputThread::CLine21OutputThread(CLine21DecFilter2 *pL21DFilter) :
m_pL21DFilter(pL21DFilter),
m_hThread(NULL),
m_hEventEnd(NULL),
m_hEventMustOutput(NULL)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::CLine21OutputThread()"))) ;
}


CLine21OutputThread::~CLine21OutputThread()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::~CLine21OutputThread()"))) ;

    Close() ;
    m_pL21DFilter = NULL ;
}


BOOL CLine21OutputThread::Create()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::Create()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    HRESULT hr = NOERROR;

    if (NULL == m_hThread)
    {
        m_hEventEnd = CreateEvent(NULL, TRUE, FALSE, NULL) ;
        m_hEventMustOutput = CreateEvent(NULL, TRUE, FALSE, NULL) ;
        if (m_hEventEnd != NULL  &&  m_hEventMustOutput != NULL)
        {
            DWORD  dwThreadId ;
            m_hThread = ::CreateThread
                ( NULL
                , 0
                , reinterpret_cast<LPTHREAD_START_ROUTINE>(InitialThreadProc)
                , reinterpret_cast<LPVOID>(this)
                , 0
                , &dwThreadId
                ) ;
            if (NULL == m_hThread)
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DbgLog((LOG_ERROR, 0, TEXT("Couldn't create a thread"))) ;

                CloseHandle(m_hEventEnd), m_hEventEnd = NULL ;
                return FALSE ;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError()) ;
            DbgLog((LOG_ERROR, 0, TEXT("Couldn't create an event"))) ;
            if (m_hEventMustOutput)
            {
                CloseHandle(m_hEventMustOutput) ;
                m_hEventMustOutput = NULL ;
            }
            if (m_hEventEnd)
            {
                CloseHandle(m_hEventEnd) ;
                m_hEventEnd = NULL ;
            }
            return FALSE ;
        }
    }

    return TRUE ;
}


void CLine21OutputThread::Close()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::Close()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    //
    // Check if a thread was created
    //
    if (m_hThread)
    {
        ASSERT(m_hEventEnd != NULL) ;

        //  Tell the thread to exit
        if (SetEvent(m_hEventEnd))
        {
            //
            // Synchronize with thread termination.
            //
            DbgLog((LOG_TRACE, 5, TEXT("Wait for thread to terminate..."))) ;

            HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0) ;
            if (hThread)
            {
                WaitForSingleObject(hThread, INFINITE) ;
                CloseHandle(hThread) ;
            }
            CloseHandle(m_hEventEnd), m_hEventEnd = NULL ;
            CloseHandle(m_hEventMustOutput), m_hEventMustOutput = NULL ;
        }
        else
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: Couldn't signal end event (0x%lx)"), GetLastError())) ;
    }
}


void CLine21OutputThread::SignalForOutput()
{
    CAutoLock lock(&m_AccessLock) ;

    if (m_hThread)
    {
        ASSERT(m_hEventMustOutput != NULL) ;

        SetEvent(m_hEventMustOutput) ;
    }
}


DWORD WINAPI CLine21OutputThread::InitialThreadProc(CLine21OutputThread * pThread)
{
    return pThread->OutputThreadProc() ;
}


DWORD CLine21OutputThread::OutputThreadProc()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::OutputThreadProc()"))) ;

    HANDLE aEventHandles[2] = {m_hEventEnd, m_hEventMustOutput} ;

    while (TRUE)
    {
        // We are going to wait for a short period of time (the delay is to
        // ensure that we don't get blocked too early and thereby delay the 
        // processing of samples or make them in bunches).  Even though we are 
        // going to try start preparing the next frame quite early, we'll be 
        // throttled by the VMR in the GetDeliveryBuffer() call, which will make
        // the interval between successive outputs from us ~33 mSecs apart,
        // which is ideal.
        DWORD dw = WaitForMultipleObjects(NUMELMS(aEventHandles), aEventHandles,
                                FALSE, 10) ;  // wait for "some" time (33 before)
        switch (dw)
        {
        case WAIT_OBJECT_0:
            DbgLog((LOG_TRACE, 1, TEXT("End event has been signaled"))) ;
            ResetEvent(m_hEventEnd) ;
            return 1 ;

        case WAIT_OBJECT_0 + 1:
            DbgLog((LOG_TRACE, 1, TEXT("Must output event has been signaled"))) ;
            ResetEvent(m_hEventMustOutput) ;
            break ;

        case WAIT_TIMEOUT:
            DbgLog((LOG_TRACE, 5, TEXT("Wait is over. Should we deliver a sample?"))) ;
            break ;

        default:
            DbgLog((LOG_ERROR, 1, TEXT("Something wrong has happened during wait (dw = 0x%lx)"), dw)) ;
            return 1 ;
        }

        // We "may have to" send an output sample now
        HRESULT hr = m_pL21DFilter->SendOutputSampleIfNeeded() ;

    }  // end of while () loop

    return 1 ; // shouldn't get here
}



//
// CLine21InSampleQueue: Line21 Input Sample Queue class implementation
//
CLine21InSampleQueue::CLine21InSampleQueue() :
m_hEventEnd(NULL),
m_hEventSample(NULL),
m_iCount(0),
m_List(NAME("Line21 In-sample List"), Max_Input_Sample)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::CLine21InSampleQueue()"))) ;
}


CLine21InSampleQueue::~CLine21InSampleQueue()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::~CLine21InSampleQueue()"))) ;
    Close() ;
}


BOOL CLine21InSampleQueue::Create()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::Create()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    ASSERT(NULL == m_hEventEnd  &&  NULL == m_hEventSample) ;
    m_hEventEnd    = CreateEvent(NULL, TRUE, FALSE, NULL) ; // not signalled
    if (NULL == m_hEventEnd)
    {
        ASSERT(m_hEventEnd) ;
        return FALSE ;
    }
    m_hEventSample = CreateEvent(NULL, TRUE, TRUE, NULL) ;  // SIGNALLED => OK to add
    if (NULL == m_hEventSample)
    {
        ASSERT(m_hEventSample) ;
        CloseHandle(m_hEventEnd) ;  // else we leak a handle
        return FALSE ;
    }
    m_iCount = 0 ;
    return TRUE ;
}


void CLine21InSampleQueue::Close()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::Close()"))) ;

    // First signal the end event, so that any waiting thread is unblocked
    if (m_hEventEnd)
        SetEvent(m_hEventEnd) ;

    // Now take the lock and proceed to clear out...
    CAutoLock lock(&m_AccessLock) ;

    // First release all queued up media samples
    IMediaSample  *pSample ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        pSample = m_List.RemoveHead() ;
        if (pSample)
            pSample->Release() ;
    }
    m_iCount = 0 ;

    // Close event handles now
    if (m_hEventEnd)
    {
        CloseHandle(m_hEventEnd) ;
        m_hEventEnd = NULL ;
    }
    if (m_hEventSample)
    {
        CloseHandle(m_hEventSample) ;
        m_hEventSample = NULL ;
    }
}


BOOL CLine21InSampleQueue::AddItem(IMediaSample *pSample)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::AddItem()"))) ;  // LOG_TRACE = 0

    m_AccessLock.Lock() ;  // we'll do selective locking

    // If there are too many samples in queue => wait for some processing
    if (m_iCount >= Max_Input_Sample)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Queue full.  Waiting for free slot..."))) ;
        HANDLE aEventHandles[2] = {m_hEventEnd, m_hEventSample} ;
        m_AccessLock.Unlock() ;  // don't keep the lock as that would block others
        DWORD dw = WaitForMultipleObjects(NUMELMS(aEventHandles), aEventHandles,
                                FALSE, INFINITE) ;
        m_AccessLock.Lock() ;    // re-acquire lock before proceeding

        switch (dw)
        {
        case WAIT_OBJECT_0:
            DbgLog((LOG_TRACE, 1, TEXT("End event has been signaled"))) ;
            // ResetEvent(m_hEventEnd) ;  -- we should never reset the end event
            m_AccessLock.Unlock() ;  // unlock before leaving
            return FALSE ;

        case WAIT_OBJECT_0 + 1:
            DbgLog((LOG_TRACE, 5, TEXT("Sample queue event has been signaled"))) ;
            ASSERT(m_iCount < Max_Input_Sample) ;
            // ResetEvent(m_hEventSample) ; -- shouldn't reset here
            break ;

        case WAIT_TIMEOUT:
            // We should never come here, but...
            m_AccessLock.Unlock() ;  // unlock before leaving
            return FALSE ;

        default:
            DbgLog((LOG_ERROR, 0, TEXT("Something wrong has happened during wait (dw = 0x%lx)"), dw)) ;
            ResetEvent(m_hEventSample) ;  // next RemoveItem() will set it again
            m_AccessLock.Unlock() ;  // unlock before leaving
            return FALSE ;
        }
    }  // end of if (m_iCount >= ...)

    // Now add new media sample to queue
    DbgLog((LOG_TRACE, 1, TEXT("Adding new sample to queue after %d"), m_iCount)) ;  // LOG_TRACE = 5
    if (m_List.AddTail(pSample))
    {
        pSample->AddRef() ;  // we must hold onto the sample until we process it
        m_iCount++ ;
        if (m_iCount >= Max_Input_Sample)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Input sample queue is full"))) ;
            ResetEvent(m_hEventSample) ;  // next RemoveItem() will set it again
        }

        m_AccessLock.Unlock() ;  // release before leaving function
        return TRUE ;
    }
    m_AccessLock.Unlock() ;  // release before leaving function
    ASSERT(!"Couldn't add media sample to queue") ;
    return FALSE ;
}


IMediaSample* CLine21InSampleQueue::PeekItem()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::PeekItem()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    IMediaSample *pSample = m_List.GetHead() ;
    if (pSample)
    {
        DbgLog((LOG_TRACE, 5, TEXT("There are %d samples left in the queue"), m_iCount)) ;
    }
    return pSample ;
}


IMediaSample* CLine21InSampleQueue::RemoveItem()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::RemoveItem()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    IMediaSample *pSample = m_List.RemoveHead() ;
    if (pSample)
    {
        m_iCount-- ;
        ASSERT(m_iCount < Max_Input_Sample) ;
        DbgLog((LOG_TRACE, 5, TEXT("Got a sample from queue -- %d left"), m_iCount)) ;
        SetEvent(m_hEventSample) ;  // Can add samples again
    }
    return pSample ;
}


void CLine21InSampleQueue::ClearQueue()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::ClearQueue()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    // First release all queued up media samples
    IMediaSample  *pSample ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        pSample = m_List.RemoveHead() ;
        if (pSample)
            pSample->Release() ;
    }
    m_iCount = 0 ;

    SetEvent(m_hEventSample) ;  // ready to take samples again
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21dfilt.h ===
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
// DirectShow Line 21 Decoder 2 filter
//

// forward declaration
class CLine21DecFilter2 ;
class CLine21OutputThread ;

extern const AMOVIESETUP_FILTER sudLine21Dec2 ;

#ifndef _INC_L21DFILT_H
#define _INC_L21DFILT_H

#pragma pack(push, 1)

//
//  DVD Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From DVD specifications...
#define AM_L21_GOPUD_HDR_STARTCODE      0x000001B2
#define AM_L21_GOPUD_HDR_INDICATOR      0x4343
#define AM_L21_GOPUD_HDR_RESERVED       0x01F8
#define AM_L21_GOPUD_HDR_TOPFIELD_FLAG  0x1
#define AM_L21_GOPUD_ELEM_MARKERBITS    0x7F
#define AM_L21_GOPUD_ELEM_VALIDFLAG     0x1
// There can be max 63 frames/fields' worth data per packet as there are 
// 6 bits to represent this number in the packet.
#define AM_L21_GOPUD_ELEMENT_MAX        63

typedef struct _AM_L21_GOPUD_ELEMENT {
    BYTE        bMarker_Switch ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_GOPUD_ELEMENT, *PAM_L21_GOPUD_ELEMENT ;

typedef struct _AM_L21_GOPUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Indicator[2] ;
    BYTE        abL21Reserved[2] ;
    BYTE        bTopField_Rsrvd_NumElems ;
} AM_L21_GOPUD_HEADER, *PAM_L21_GOPUD_HEADER ;

typedef struct _AM_L21_GOPUD_PACKET {
    AM_L21_GOPUD_HEADER   Header ;
    AM_L21_GOPUD_ELEMENT  aElements[AM_L21_GOPUD_ELEMENT_MAX] ;
} AM_L21_GOPUD_PACKET, *PAM_L21_GOPUD_PACKET ;

#define GETGOPUD_NUMELEMENTS(pGOPUDPacket) ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x3F)
#define GETGOPUD_PACKETSIZE(pGOPUDPacket)  (LONG)(sizeof(AM_L21_GOPUD_HEADER) + GETGOPUD_NUMELEMENTS(pGOPUDPacket) * sizeof(AM_L21_GOPUD_ELEMENT))
#define GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ((pGOPUDPacket)->aElements[i])
#define GETGOPUD_ELEM_MARKERBITS(Elem)     ((((Elem).bMarker_Switch & 0xFE) >> 1) & 0x7F)
#define GETGOPUD_ELEM_SWITCHBITS(Elem)     ((Elem).bMarker_Switch & 0x01)

#define GETGOPUD_L21STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
      (DWORD)((Header).abL21StartCode[1]) << 16 | \
      (DWORD)((Header).abL21StartCode[2]) <<  8 | \
      (DWORD)((Header).abL21StartCode[3]) )
#define GETGOPUD_L21INDICATOR(Header)             \
    ( (DWORD)((Header).abL21Indicator[0]) << 8 |  \
      (DWORD)((Header).abL21Indicator[1]) )
#define GETGOPUD_L21RESERVED(Header)              \
    ( (DWORD)((Header).abL21Reserved[0]) << 8  |  \
      (DWORD)((Header).abL21Reserved[1]) )

#define GOPUD_HEADERLENGTH   (4+2+2+1)
#define GETGOPUD_ELEMENT(pGOPUDPkt, i)  (pGOPUDPkt + GOPUD_HEADERLENGTH + sizeof(AM_L21_GOPUD_ELEMENT) * i)
#define ISGOPUD_TOPFIELDFIRST(pGOPUDPacket)  ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x80)


//
//  ATSC Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From ATSC Standards for Coding 25/50Hz Video (A/63) specifications...
#define AM_L21_ATSCUD_HDR_STARTCODE      0x000001B2
#define AM_L21_ATSCUD_HDR_IDENTIFIER     0x47413934
#define AM_L21_ATSCUD_HDR_TYPECODE_EIA   0x03
#define AM_L21_ATSCUD_HDR_EM_DATA_FLAG   0x80
#define AM_L21_ATSCUD_HDR_CC_DATA_FLAG   0x40
#define AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG 0x20
#define AM_L21_ATSCUD_HDR_CC_COUNT_MASK  0x1F
#define AM_L21_ATSCUD_HDR_NEXTBITS_ON    0x01
#define AM_L21_ATSCUD_ELEM_MARKERBITS    0xF8
#define AM_L21_ATSCUD_ELEM_VALID_FLAG    0x04
#define AM_L21_ATSCUD_ELEM_TYPE_FLAG     0x03
#define AM_L21_ATSCUD_MARKERBITS         0xFF
#define AM_L21_ATSCUD_HDR_NEXTBITS_FLAG  0x00000100
// There can be max 31 frames/fields' worth data per packet as there are 
// 5 bits to represent this number in the packet.
#define AM_L21_ATSCUD_ELEMENT_MAX        31

typedef struct _AM_L21_ATSCUD_ELEMENT {
    BYTE        bCCMarker_Valid_Type ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_ATSCUD_ELEMENT, *PAM_L21_ATSCUD_ELEMENT ;

typedef struct _AM_L21_ATSCUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Identifier[4] ;
    BYTE        bL21UDTypeCode ;
    BYTE        bL21DataFlags_Count ;
    BYTE        bL21EMData ;
} AM_L21_ATSCUD_HEADER, *PAM_L21_ATSCUD_HEADER ;

typedef struct _AM_L21_ATSCUD_PACKET {
    AM_L21_ATSCUD_HEADER   Header ;
    AM_L21_ATSCUD_ELEMENT  aElements[AM_L21_ATSCUD_ELEMENT_MAX] ;
    BYTE                   bMarkerBits ;
} AM_L21_ATSCUD_PACKET, *PAM_L21_ATSCUD_PACKET ;

#define GETATSCUD_NUMELEMENTS(pATSCUDPacket) ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_COUNT_MASK)
#define GETATSCUD_PACKETSIZE(pATSCUDPacket)  (LONG)(sizeof(AM_L21_ATSCUD_HEADER) + \
                                              GETATSCUD_NUMELEMENTS(pATSCUDPacket) * sizeof(AM_L21_ATSCUD_ELEMENT) + \
                                              sizeof(BYTE))
#define GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ((pATSCUDPacket)->aElements[i])
#define GETATSCUD_ELEM_MARKERBITS(Elem)     (((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS) >> 3)

#define GETATSCUD_STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
      (DWORD)((Header).abL21StartCode[1]) << 16 | \
      (DWORD)((Header).abL21StartCode[2]) <<  8 | \
      (DWORD)((Header).abL21StartCode[3]) )
#define GETATSCUD_IDENTIFIER(Header)             \
    ( (DWORD)((Header).abL21Identifier[0]) << 24 | \
      (DWORD)((Header).abL21Identifier[1]) << 16 | \
      (DWORD)((Header).abL21Identifier[2]) <<  8 | \
      (DWORD)((Header).abL21Identifier[3]) )
#define GETATSCUD_TYPECODE(Header)    (DWORD)((Header).bL21UDTypeCode)
#define ISATSCUD_TYPE_EIA(pATSCUDPacket)  (AM_L21_ATSCUD_HDR_TYPECODE_EIA == \
                                     ((pATSCUDPacket)->Header.bL21UDTypeCode & 0xFF))
#define ISATSCUD_EM_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_EM_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_EM_DATA_FLAG))
#define ISATSCUD_CC_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_CC_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_DATA_FLAG))
#define ISATSCUD_ADDL_DATA(pATSCUDPacket) (AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG))
#define GETATSCUD_EM_DATA(pATSCUDPacket)  ((pATSCUDPacket)->Header.bL21EMData)
#define ISATSCUD_ELEM_MARKERBITS_VALID(Elem)     (AM_L21_ATSCUD_ELEM_MARKERBITS == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS))
#define ISATSCUD_ELEM_CCVALID(Elem)  (AM_L21_ATSCUD_ELEM_VALID_FLAG == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_VALID_FLAG))
#define GETATSCUD_ELEM_CCTYPE(Elem)    (DWORD)((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_TYPE_FLAG))
#define GETATSCUD_MARKERBITS(pATSCUDPacket) (DWORD)((pATSCUDPacket)->bMarkerBits)
#define ISATSCUD_MARKER_BITSVALID(pATSCUDPacket) (AM_L21_ATSCUD_MARKERBITS == \
                                       ((pATSCUDPacket)->bMarkerBits & AM_L21_ATSCUD_MARKERBITS))

// Header = StartCode + Id + TypeCode + (EM_CC_Addl_Data + CCCount) + EM_Data
#define ATSCUD_HEADERLENGTH   (4+4+1+1+1)
#define GETATSCUD_ELEMENT(pATSCUDPkt, i)  ((BYTE)(pATSCUDPkt) + ATSCUD_HEADERLENGTH + \
                                            sizeof(AM_L21_ATSCUD_ELEMENT) * i)


// CC type in GOP packet
typedef enum {
    GOP_CCTYPE_Unknown = 0,  // Invalid
    GOP_CCTYPE_None,         // all 0 -- filler packet
    GOP_CCTYPE_DVD,          // DVD CC packets
    GOP_CCTYPE_ATSC,         // ATSC CC packets
} GOPPACKET_CCTYPE ;


// Some more flag, struct and macro definitions...
#define AM_L21_INFO_FIELDBASED          0x0001
#define AM_L21_INFO_TOPFIELDFIRST       0x0003
#define AM_L21_INFO_BOTTOMFIELDFIRST    0x0005

typedef struct _AM_LINE21INFO {
    DWORD       dwFieldFlags ;
    UINT        uWidth ;
    UINT        uHeight ;
    UINT        uBitDepth ;
    DWORD       dwAvgMSecPerSample ;
} AM_LINE21INFO, *PAM_LINE21INFO ;


#define ISRECTEQUAL(r1, r2) ((r1).top == (r2).top     && \
                             (r1).left == (r2).left   && \
                             (r1).right == (r2).right && \
                             (r1).bottom == (r2).bottom)


//
// CLine21OutputThread: Line21 output thread class definition
//
class CLine21OutputThread {
public:
    CLine21OutputThread(CLine21DecFilter2 *pL21DFilter) ;
    ~CLine21OutputThread() ;
    BOOL Create() ;
    void Close() ;
    void SignalForOutput() ;
    static DWORD WINAPI InitialThreadProc(CLine21OutputThread * pThread) ;

private:
    // Data:
    CCritSec m_AccessLock ;
    HANDLE   m_hThread ;
    HANDLE   m_hEventEnd ;
    HANDLE   m_hEventMustOutput ;
    CLine21DecFilter2 *m_pL21DFilter ;

    // Methods:
    // Actual thread proc -- called by InitialThreadProc()
    DWORD OutputThreadProc() ;
} ;


//
// CLine21InSampleQueue: Line21 Input Sample Queue class definition
//
const int Max_Input_Sample = 10 ;

class CLine21InSampleQueue {
public:
    CLine21InSampleQueue() ;
    ~CLine21InSampleQueue() ;
    BOOL Create() ;
    void Close() ;
    BOOL AddItem(IMediaSample *pSample) ;
    IMediaSample* RemoveItem() ;
    IMediaSample* PeekItem() ;
    void ClearQueue() ;

private:
    // Data:
    CCritSec m_AccessLock ;
    HANDLE   m_hEventEnd ;
    HANDLE   m_hEventSample ;
    int      m_iCount ;
    CGenericList<IMediaSample>  m_List ;
} ;


//
//  Line 21 Decoder class definition
//
class CLine21DecFilter2 : public CTransformFilter,
                          // public ISpecifyPropertyPages, -- WILL DO LATER
                          public IAMLine21Decoder
{
public:
    
    //
    //  Constructor and destructor
    //
    CLine21DecFilter2(TCHAR *, LPUNKNOWN, HRESULT *) ;
    ~CLine21DecFilter2() ;
    
    //
    //   Standard COM stuff
    //
    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
    // static void InitClass(BOOL, const CLSID *) ;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;
    DECLARE_IUNKNOWN ;
    
    // Checks if an output sample needs to be send, and if so, sends one down
    HRESULT SendOutputSampleIfNeeded() ;

    //
    //   CTranformFilter overrides
    //
    // I must override it
    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut) ;
    
    // Real stuff is in here...
    HRESULT Receive(IMediaSample * pIn) ;
    
    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn) ;
    
    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn,
                           const CMediaType* mtOut) ;
    
    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
							 ALLOCATOR_PROPERTIES *pProperties) ;
    
    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt) ;
    
    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) ;
    
    HRESULT EndOfStream(void) ;
    HRESULT BeginFlush(void) ;
    HRESULT EndFlush(void) ;
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State) ;
    
    // overridden to know when we're starting/stopping the decoding
    STDMETHODIMP Stop(void) ;
    STDMETHODIMP Pause(void) ;
    STDMETHODIMP Run(REFERENCE_TIME tStart) ;
    
    // overridden to know when connections are completed, so that we can get 
    // the media type (actualy format) info for caching
    HRESULT CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin) ;
    
    // Override to know when we disconnect from in/output side to not use
    // any specified output format any more.
    HRESULT BreakConnect(PIN_DIRECTION dir) ;

#if 0 // no QM for now
    // We also override this one as we handle the quality management messages
    HRESULT AlterQuality(Quality q) ;
#endif // #if 0

    //
    // ISpecifyPropertyPages method
    //
    // STDMETHODIMP GetPages(CAUUID *pPages) ;
    
    //
    // IAMLine21Decoder interface methods
    //
    STDMETHODIMP GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel) ;
    STDMETHODIMP GetCurrentService(AM_LINE21_CCSERVICE *lpService) ;
    STDMETHODIMP SetCurrentService(AM_LINE21_CCSERVICE Service) ;
    STDMETHODIMP GetServiceState(AM_LINE21_CCSTATE *lpState) ;
    STDMETHODIMP SetServiceState(AM_LINE21_CCSTATE State) ;
    STDMETHODIMP GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    STDMETHODIMP SetOutputFormat(LPBITMAPINFO lpbmi) ;
    STDMETHODIMP GetBackgroundColor(DWORD *pdwPhysColor) ;
    STDMETHODIMP SetBackgroundColor(DWORD dwPhysColor) ;
    STDMETHODIMP GetRedrawAlways(LPBOOL lpbOption) ;
    STDMETHODIMP SetRedrawAlways(BOOL bOption) ;
    STDMETHODIMP GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode) ;
    STDMETHODIMP SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) ;
    
private:   // data
    
    // Line21 Data Decoder class that takes 2 bytes and converts to a bitmap
    CLine21DataDecoder  m_L21Dec ;

    // The thread on which we'll output samples as needed
    CLine21OutputThread m_OutputThread ;

    // The input sample queue object
    CLine21InSampleQueue m_InSampleQueue ;

    // What input format type is being used (better to use an integer flag)
    AM_LINE21_CCSUBTYPEID  m_eSubTypeIDIn ;

    GOPPACKET_CCTYPE       m_eGOP_CCType ;  // if GOPPackets used, what type data (DVD/ATSC/...)
    
    REFERENCE_TIME  m_rtTimePerInSample ;   // (in 100 nSec) interval per byte pair from an in-packet (for GOP packet type)
    REFERENCE_TIME  m_rtTimePerOutSample ;  // (in 100 nSec) interval per output sample (~33 mSec)
    REFERENCE_TIME  m_rtStart ;          // start time for an output sample
    REFERENCE_TIME  m_rtStop ;           // stop time for an out output sample
    REFERENCE_TIME  m_rtLastOutStop ;    // stop time of last output sample
    LONGLONG        m_llMediaStart ;     // media time start (rarely used, but...)
    REFERENCE_TIME  m_llMediaStop ;      // media time stop (rarely used, but...)

    // CC input samples w/o valid timestamps are output for "NOW"
    BOOL            m_bNoTimeStamp ;  // no timestamp for this sample

    // flag to detect if we must send an output sample
    BOOL            m_bMustOutput ;

    // flag to remember if the last input sample was a discontiuity sample
    BOOL            m_bDiscontLast ;

    BOOL            m_bEndOfStream ;  // has EoS been sent/called?

    // If the upstream filter doesn't specify any format type, use one from
    // our internal defaults
    VIDEOINFO      *m_pviDefFmt ;
    DWORD           m_dwDefFmtSize ;
    
    IPin           *m_pPinDown ;    // downstream pin connected to our output
    
    BOOL            m_bBlendingState ;   // latest CC blending state

#if 0 // no QM for now
    // number of samples to skip between every output CC sample for QM handling
    int          m_iSkipSamples ;
#endif // #if 0

#ifdef PERF
    int          m_idDelvWait ;
#endif // PERF
    
private:   // functions
    AM_LINE21_CCSUBTYPEID MapGUIDToID(const GUID *pFormatIn) ;
    BOOL    VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket) ;
    BOOL    VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket) ;
    BOOL    IsFillerPacket(BYTE *pGOPPacket) ;
    HRESULT GetDefaultFormatInfo(void) ;
    BOOL    IsValidFormat(BYTE *pbFormat) ;
    HRESULT SendOutputSample(IMediaSample *pIn, 
                    REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop) ;
    void    SetBlendingState(BOOL bState) ;
    // bool    CanChangeMediaType(RECT *prectSrc, RECT *prectDest) ;
    HRESULT GetOutputBuffer(IMediaSample **ppOut) ;
    GOPPACKET_CCTYPE DetectGOPPacketDataType(BYTE *pGOPPacket) ;
    HRESULT ProcessGOPPacket_DVD(IMediaSample *pIn) ;
    HRESULT ProcessGOPPacket_ATSC(IMediaSample *pIn) ;
    HRESULT ProcessSample(IMediaSample *pIn) ;

#if 0 // no QM for now
    inline int  GetSkipSamples(void)   { return m_iSkipSamples ; }
    inline void ResetSkipSamples(void) { m_iSkipSamples = 0 ; } ;
#endif // #if 0
} ;

#pragma pack(pop)

#endif // _INC_L21DFILT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\inc\devtype.h ===
// devtype.h : definitions for vidsvr.odl
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
#ifdef __cplusplus
# define odlhelp(x)
# define odlhelp2(x, y)
#else
# define odlhelp(x) [ helpstring(x)]
# define odlhelp2(x, y) [ x, y ]
#endif
// these device type elements are built into the ODL and are used to construct
// the DeviceType property

#ifdef __MKTYPLIB__

#include <dssenum.h>

        // these are the string resource id numbers in the vidsvr
        // for the progid strings
        typedef enum BpcVidsvrProgIds {
            BPC_IDS_VIDSVR_PROGID = 2100,
            BPC_IDS_COABPCDETAILS_PROGID = 2101,
        } BpcVidsvrProgIds;


        typedef enum {
            // 0 - 0x4000 are reserved for FILTER_STATE values from dshow sdk axcore.idl definitions
            BPC_STATE_APM_QUERY_SUSPEND  = 0x4000,  // vidsvr has received a query suspend
            BPC_STATE_APM_SUSPEND_FAILED = 0x4001,  // vidsvr has received a query suspend
            BPC_STATE_APM_RESUME         = 0x4002,  // received apm resume no user present
            BPC_STATE_APM_RESUME_USER    = 0x4003,  // received apm resume user present
            BPC_STATE_SHUTDOWN           = 0x4004,  // vidsvr has received a system shutdown notification
            BPC_STATE_REINIT_REQUEST     = 0x4005,  // vidsvr has received a reinitialization request from a client
                                                    // all clients should release any outstanding video 
                                                    // objects (devices, enumerators, etc.) except for the actual 
                                                    // video control itself and call vidocx reinit method 
                                                    // to allow reinit to occur.
            BPC_STATE_REINIT_STARTED     = 0x4006,  // all clients have agreed to reinit
            BPC_STATE_REINIT_COMPLETE    = 0x4007,  // reinitialization has completed, all clients may resume
                                                    // normal activity.  note: new devices may now exist
            BPC_STATE_UNKNOWN             = 0xffffffff,
        } BPCSTATETYPE;

        typedef enum statustype {
//          STATUS_POWER        = 0x01,
            STATUS_PLAY         = 0x02,
//          STATUS_THISPLAY     = 0x04,
            STATUS_PAUSED       = 0x08,
//          STATUS_AUDIO        = 0x10,
//          STATUS_VIDEO        = 0x20,
//          STATUS_RECORDING    = 0x40,
            STATUS_ACTIVE       = 0x80, // set when we're input or output
        } STATUSTYPE;

#if 0
// reserved for future use
        typedef enum ircommands {
            IR_PLAY = 1,
            IR_STOP = 2,
            IR_PAUSE = 3,
            IR_UNPAUSE = 4,
            IR_RECORD = 5,
            IR_REWIND = 6,
            IR_FASTFORWARD = 7,
            IR_SETCHANNEL = 8,
            IR_TOGGLEPOWER = 9,
            IR_POWERON = 10,
            IR_POWEROFF = 11
        } IRCOMMANDS;

    // these values must match those in quartzsrc\ui\controls\litevid\dispids.h
    typedef odlhelp2 (
        uuid(05589fa4-c356-11ce-bf01-00aa0055595a),
        helpstring("Event Notification Flags")
    ) enum
    {
        odlhelp("No Event Notification") eventNone              = 0x00,
        odlhelp("State Changes (default)") eventStateChange     = 0x01,
        odlhelp("Position Changes") eventPositionChange         = 0x02,
        odlhelp("Timer events") eventTimer                      = 0x04,
        odlhelp("Keyboard Events") eventKeyboard                = 0x08,
        odlhelp("Mouse Clicks") eventMouseClick                 = 0x10,
        odlhelp("Mouse Moves") eventMouseMove                   = 0x20
    } EventNotificationFlags;
#endif

    typedef odlhelp2 (
        uuid(05589faa-c356-11ce-bf01-00aa0055595a),
        helpstring("Movie Window Settings")
   ) enum
    {
        odlhelp("Default Size") movieDefaultSize,
        odlhelp("Half Size") movieHalfSize,
        odlhelp("Double Size") movieDoubleSize,
        odlhelp("Maximum Size") movieMaximizeSize,
        odlhelp("Full Screen") movieFullScreen,
        odlhelp("User Defined (enforce Aspect Ratio)") moviePermitResizeWithAspect,
        odlhelp("User Defined (ignore Aspect Ratio)") moviePermitResizeNoRestrict
    } MovieWindowSetting;


    typedef odlhelp2(
        uuid(05589fab-c356-11ce-bf01-00aa0055595a),
        helpstring("State of Movie Clip")
    ) enum
    {
        // These values MUST be the same as the State_ constants in quartz\sdk\include\strmif.h
        odlhelp("Movie is stopped") stateStopped,
        odlhelp("Movie is paused") statePaused,
        odlhelp("Movie is running") stateRunning
    } State;


    typedef odlhelp2(
        uuid(05589fac-c356-11ce-bf01-00aa0055595a),
        helpstring("Display Mode")
    ) enum
    {
        odlhelp("Time") modeTime,
        odlhelp("Frames") modeFrames
    } DisplayMode;
#endif
// mktyplib won't allow an enum to define disp ids
// vid ids
#define dispidPower      1008
#define dispidStartTime  1002
#define dispidStopTime   1003
#define dispidVideoOn    1004
#define dispidClosedCaption     1005
#define dispidDebug             1006
#define dispidEventNotification 1007
#define dispidDeviceCount       1001
#define dispidDisplayMode       1025
#define dispidInput     1020
#define dispidOutput    1021
#define dispidColorKey  1012
#define dispidFileName  1013
#define dispidPriority  1014
#define dispidUserName  1015
#define dispidLogin     1016
#define dispidVolume    1017
#define dispidBalance   1018
#define dispidImageSourceHeight  1019
#define dispidImageSourceWidth   1010
#define dispidMovieWindowSetting 1011
#define dispidCurrentState       1022
#define dispidCurrentPosition    1023
#define dispidDuration           1024
#define dispidPrerollTime        1009
#define dispidRate               1026
#define dispidLocaleID           1027
#define dispidRun                1028
#define dispidPause              1029
#define dispidStop               1030
#define dispidClose              1031
#define dispidOpen               1032
#define dispidDevices            1033
#define dispidControlling        1034
#define dispidTune               1035
#define dispidTSDevCount         1036
#define dispidLogout             1037
#define dispidAutoScan           1038
#define dispidAudioPinNames      1039
#define dispidAuxConfig          1040
#define dispidMinMaxChannel      1041
#define dispidReInit             1042
#define dispidMute               1043
#define dispidAudioPin           1044

    // Vid events
#define eventidGotControl     1001
#define eventidLostControl    1002
#define eventidDeviceMessage  1003
#define eventidStateChange    1004
#define eventidPositionChange 1005
#define eventidErrorMessage   1006

    //DeviceBase methods&props
#define dispidName         1001
#define dispidIsInput      1002
#define dispidIsOutput     1003
#define dispidHasChannel   1004
#define dispidHasFilename  1005
#define dispidDeviceType   1006
#define dispidStatus       1007
#define dispidProdName     1008
#define dispidDevFileName  1009
#define dispidChannel      1010
#define dispidSendMessage  1011
#define dispidCommand      1012
#define dispidChannelAvailable  1013
#define dispidCommandAvailable  1014
#define dispidDevImageSourceWidth   1015
#define dispidDevImageSourceHeight  1016
#define dispidDevCurrentPosition    1017
#define dispidDevDuration           1018
#define dispidDevPrerollTime        1019
#define dispidDevRate               1020
#define dispidDevCountryCode        1021
#define dispidDevVideoFrequency     1022
#define dispidDevAudioFrequency     1023
#define dispidDevDefaultVideoType   1024
#define dispidDevDefaultAudioType   1025
#define dispidDevVideoSubchannel    1026
#define dispidDevAudioSubchannel    1027
#define dispidDevTuningSpace        1028
#define dispidStatusString      1030
#define dispidDevVolume         1031
#define dispidDevBalance        1032
#define dispidActivate          1033
#define dispidDeActivate        1034
#define dispidDevPower          1035
#define dispidDevRun            1036
#define dispidDevStop           1037
#define dispidDevPause          1038
#define dispidDevRefresh        1039
#define dispidHasCA             1040
#define dispidDevVideoOn        1041
#define dispidDevCurrentState   1042
#define dispidDevOverScan       1043
#define dispidDevClosedCaption  1044
#define dispidDevMinMaxChannel  1045
#define dispidDevHasMinMaxChannel  1046

//
#define dispidItem              1500
#define dispidCount             1501
#define dispidHWnd              1502
#define dispidLCID              1503
#define dispidNotify            1504
#define dispidDevControlling    1505
#define dispidDevColorKey       1506
#define dispidDevPriority       1507
#define dispidDevInput          1508
#define dispidDevOutput         1509
#define dispidDevTune           1510
#define dispidDevTSDevCount     1511
#define dispidDevOpen           1512
#define dispidDevLogin          1513
#define dispidDevLogout         1514
#define dispidDevAutoScan       1515
#define dispidDevAudioPinNames  1516
#define dispidDevAuxConfig      1517
#define dispidDevReInit         1518
#define dispidDevMute           1519
#define dispidDevAudioPin       1520

// NOTE:  !!!! these must match the odl for the caserver(caserver.odl)
// don't change these without considering the impact on existing code
// normally you should not delete, rename, or reuse any of these.  you should
// add new ones and stop using the old ones while leaving them in place marked
// as obsolete.

// These symbols are #defined because mktyplib doesn't understand
// enum.  if we convert completely to midl then we could  change all
// of these to enums which would be more type safe for authors
// of provider specific dll's


// IBPCDetails interface
#define OABPCDETID_Channel        (1401)
#define OABPCDETID_StartTime      (1402)
#define OABPCDETID_Duration       (1403)
#define OABPCDETID_ItemID         (1404)
#define OABPCDETID_StorageId      (1405)
#define OABPCDETID_Title          (1406)
#define OABPCDETID_Rating         (1407)
#define OABPCDETID_Year           (1408)
#define OABPCDETID_Description    (1409)
#define OABPCDETID_ViewCost       (1410)
#define OABPCDETID_TapeCost       (1411)
#define OABPCDETID_Action         (1412)
#define OABPCDETID_Status         (1413)
#define OABPCDETID_Reason         (1414)
#define OABPCDETID_ReasonDesc     (1415)
#define OABPCDETID_ProviderBuffer (1416)
#define OABPCDETID_Expiry         (1417)
#define OABPCDETID_Location       (1418)
#define OABPCDETID_UserId         (1419)

// CAServer Interface
#define CASERVERID_ResetProviderSystem (1301)
#define CASERVERID_BuyItem             (1302)
#define CASERVERID_CancelItem          (1303)
#define CASERVERID_ItemDetails         (1304)
#define CASERVERID_ProviderEPGMask     (1305)
#define CASERVERID_DisplayConfigDialog (1306)
#define CASERVERID_UserName            (1307)
#define CASERVERID_UserArea            (1308)
#define CASERVERID_ProviderRating      (1309)
#define CASERVERID_ProviderStatus      (1310)
#define CASERVERID_ShowBox             (1311)
#define CASERVERID_HistoryItems        (1312)
#define CASERVERID_EmailMessages       (1313)
#define CASERVERID_ErrorMessages       (1314)
#define CASERVERID_HandleCardChaining  (1315)

// CAEvent Interface
// message event
#define CAEVENTID_CardMissing         (1201)
#define CAEVENTID_CardReady           (1202)
#define CAEVENTID_CardInvalid         (1203)
#define CAEVENTID_WrongCard           (1204)
#define CAEVENTID_BlackedOut          (1205)
#define CAEVENTID_RatingExceeded      (1206)
#define CAEVENTID_CostExceeded        (1207)
#define CAEVENTID_NotReady            (1208)
#define CAEVENTID_PasswordCleared     (1209)
#define CAEVENTID_SignalLost          (1210)
#define CAEVENTID_IntegrityFault      (1211)
#define CAEVENTID_OSDRequest          (1212)
// notifications
#define CAEVENTID_NewEmail            (1213)
#define CAEVENTID_NewCard             (1214)
#define CAEVENTID_ColdStart           (1215)
#define CAEVENTID_Ready               (1216)
#define CAEVENTID_CannotPurchase      (1217)
#define CAEVENTID_NoSubscriber        (1218)
#define CAEVENTID_CAFault             (1219)
#define CAEVENTID_CAFail              (1220)
#define CAEVENTID_CASuccess           (1221)
#define CAEVENTID_Retry               (1222)
#define CAEVENTID_Fail                (1223)
#define CAEVENTID_TuningChanged       (1224)
#define CAEVENTID_MessagesUpdated     (1233)
#define CAEVENTID_HistoryUpdated      (1234)
// special
#define CAEVENTID_TapingControlChanged (1225)
#define CAEVENTID_EPGGuideChanged     (1226)
#define CAEVENTID_HandlePurchaseOffer (1227)
#define CAEVENTID_RevokeEvent         (1228)
#define CAEVENTID_BillingCallStart    (1229)
#define CAEVENTID_BillingCallEnd      (1230)
#define CAEVENTID_CopyCard            (1231)
#define CAEVENTID_EPGFilterChanged    (1232)
#define CAEVENTID_CallbackFailed      (1235)

#define MSGID_Attributes              (1800)
#define MSGID_Message                 (1801)

#define EMSGID_MsgId                  (2000)
#define EMSGID_UserId                 (2001)
#define EMSGID_Received               (2002)
#define EMSGID_Expires                (2003)
#define EMSGID_Title                  (2004)
#define EMSGID_Message                (2005)
#define EMSGID_Read                   (2006)

#define SUSPEND_DeviceRelease         (2100)

#define VCTL_VBITune                  (2200)
#define VCTL_VBIStatus                (2201)



//all the collection interfaces

#define COLLECTID_Item     (0)
#define COLLECTID_Count    (1)
#define COLLECTID_Remove   (2)
#define COLLECTID_MarkRead (3)

// this is a standard system defined dispatch id
// however, due to the turmoil involved in midl vs. mktyplib
// and vc 4.1's poor support for OLE i can't include
// oaidl.h where this is defined and get a clean compile
// therefore i'm redefining it here.  this should be removed
// someday(hopefully vc4.2, maybe vc 5.0)
#ifndef DISPID_NEWENUM
#define DISPID_NEWENUM   (-4)
#endif

// end of file - devtype.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21ddraw.cpp ===
// Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

//
// DirectShow Line 21 Decoder 2 Filter: drawing-related base class code
//

#include <streams.h>
#include <windowsx.h>

#include <initguid.h>

#ifdef FILTER_DLL
DEFINE_GUID(IID_IDirectDraw7,
            0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b);
#endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"


//
//  CLine21DecDraw: class for drawing details to output caption text to bitmap
//
CLine21DecDraw::CLine21DecDraw(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::CLine21DecDraw()"))) ;

    // Init some of the members
    m_pDDrawObjUnk          = NULL ;
    m_lpDDSOutput           = NULL ;
    m_lpDDSNormalFontCache  = NULL ;
    m_lpDDSItalicFontCache  = NULL ;
    m_lpDDSSpecialFontCache = NULL ;
    m_lpDDSScratch          = NULL ;
    m_lpBMIOut              = NULL ;
    m_uBMIOutSize           = 0 ;
    m_lpBMIIn               = NULL ;
    m_uBMIInSize            = 0 ;
    m_lpBltList             = NULL ;
    m_iPixelOffset          = 0 ;

    // Create an initial input BITMAPINFO struct to start with
    InitBMIData() ;

    // Init the width and height based on prelim size so that we can compare
    // any size changes later
    if (m_lpBMIIn)  // InitBMIData() succeeded as it should
    {
        m_lWidth  = m_lpBMIIn->bmiHeader.biWidth ;
        m_lHeight = m_lpBMIIn->bmiHeader.biHeight ;
    }
    else  // InitBMIData() failed!!!
    {
        m_lWidth  = 640 ;
        m_lHeight = 480 ;
    }

    // check if Lucida Console is available (the callback sets the m_bUseTTFont flag)
    CheckTTFont() ;  // m_bUseTTFont is set inside this function

    //
    // We are not supposed to use the 10% of the border on the top/bottom and left/right.
    // But leaving 10% on each side for a 320x240 image when we are using a non-TT font,
    // like "Terminal", leaves very little room for showing captions. So I leave only 5%
    // on each side with non-TT font.
    // By doing this I am violating the spec, but it's a necessary evil.
    // When TT font (Lucida Console) is available, we leave 10% border on every side.
    //
    if ( IsTTFont() )
        m_iBorderPercent = 20 ;
    else
        m_iBorderPercent = 10 ;

    // Set the border amounts based on output size and font type (TT or not)
    m_iHorzOffset = m_lWidth  * m_iBorderPercent / 200 ;  // default
    m_iVertOffset = m_lHeight * m_iBorderPercent / 200 ;  // default

    // Use char size appropriate for the output bitmap size
    if (! CharSizeFromOutputSize(m_lWidth, m_lHeight, &m_iCharWidth, &m_iCharHeight) )
    {
        DbgLog((LOG_TRACE, 1,
            TEXT("CharSizeFromOutputSize(%ld,%ld,,) failed. Using default char size."),
            m_lWidth, m_lHeight)) ;
        ASSERT(!TEXT("Char size selection failed")) ;
        // Use dafult char size
        m_iCharWidth   = DEFAULT_CHAR_WIDTH ;
        m_iCharHeight  = DEFAULT_CHAR_HEIGHT ;
    }

    ASSERT(m_iCharWidth  * (MAX_CAPTION_COLUMNS + 2) <= m_lWidth) ;
    ASSERT(m_iCharHeight * MAX_CAPTION_ROWS <= m_lHeight) ;

    m_iScrollStep  = CalcScrollStepFromCharHeight() ;

    // Flags to know if output should be turn on/off and/or sent down
    m_bOutputClear   = TRUE ;  // output buffer is clear on start
    m_bNewOutBuffer  = TRUE ;  // output buffer is new to start with

    //
    // Init the COLORREF array of 7 foreground colors as just RGB values
    //
    m_acrFGColors[0] = RGB(0xFF, 0xFF, 0xFF) ;   // white
    m_acrFGColors[1] = RGB( 0x0, 0xFF,  0x0) ;   // green
    m_acrFGColors[2] = RGB( 0x0,  0x0, 0xFF) ;   // blue
    m_acrFGColors[3] = RGB( 0x0, 0xFF, 0xFF) ;   // cyan
    m_acrFGColors[4] = RGB(0xFF,  0x0,  0x0) ;   // red
    m_acrFGColors[5] = RGB(0xFF, 0xFF,  0x0) ;   // yellow
    m_acrFGColors[6] = RGB(0xFF,  0x0, 0xFF) ;   // magenta

    m_idxFGColors[0] = 0x0F;    // white
    m_idxFGColors[1] = 0x0A;    // green
    m_idxFGColors[2] = 0x0C;    // blue
    m_idxFGColors[3] = 0x0E;    // cyan
    m_idxFGColors[4] = 0x09;    // red
    m_idxFGColors[5] = 0x0B;    // yellow
    m_idxFGColors[6] = 0x0D;    // magenta

    // Init text color (FG, BG, opacity), last CC char printed etc.
    InitColorNLastChar() ;

    // Init the list of caption chars
    InitCharSet() ;

    // Font cache needs to be built before any output
    SetFontUpdate(true) ;
}


CLine21DecDraw::~CLine21DecDraw(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::~CLine21DecDraw()"))) ;

    // Delete the cached fonts
    if (m_lpDDSNormalFontCache)
    {
        m_lpDDSNormalFontCache->Release() ;
        m_lpDDSNormalFontCache = NULL ;
    }
    if (m_lpDDSItalicFontCache )
    {
        m_lpDDSItalicFontCache->Release() ;
        m_lpDDSItalicFontCache  = NULL ;
    }
    if (m_lpDDSSpecialFontCache)
    {
        m_lpDDSSpecialFontCache->Release() ;
        m_lpDDSSpecialFontCache = NULL ;
    }
    if (m_lpDDSScratch)
    {
        m_lpDDSScratch->Release() ;
        m_lpDDSScratch = NULL ;
    }

    // release BMI data pointer
    if (m_lpBMIOut)
        delete m_lpBMIOut ;
    m_uBMIOutSize = 0 ;
    if (m_lpBMIIn)
        delete m_lpBMIIn ;
    m_uBMIInSize = 0 ;
}


int CALLBACK CLine21DecDraw::EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM,
                                    int iFontType, LPARAM lParam)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::EnumFontProc(0x%lx, 0x%lx, %d, %ld)"),
            lpELFE, lpNTM, iFontType, lParam)) ;

    // Just verify that we got a valid TT font
    if ( !(lpELFE->elfLogFont.lfCharSet & 0xFFFFFF00) &&
        !(lpELFE->elfLogFont.lfPitchAndFamily & 0xFFFFFF00) &&
        !(iFontType & 0xFFFF0000) )
    {
        ASSERT(lpELFE->elfLogFont.lfPitchAndFamily & (FIXED_PITCH | FF_MODERN)) ;
        ((CLine21DecDraw *) (LPVOID) lParam)->m_lfChar = lpELFE->elfLogFont ;
        ((CLine21DecDraw *) (LPVOID) lParam)->m_bUseTTFont = TRUE ;
        return 1 ;
    }

    ASSERT(FALSE) ;  // Weird!!! We should know about it.
    return 0 ;
}


void CLine21DecDraw::CheckTTFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::CheckTTFont()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    m_bUseTTFont = FALSE ;  // assume not available
    ZeroMemory(&m_lfChar, sizeof(LOGFONT)) ;
    lstrcpy(m_lfChar.lfFaceName, TEXT("Lucida Console")) ;
    m_lfChar.lfCharSet = ANSI_CHARSET ;
    m_lfChar.lfPitchAndFamily = 0 ;
    HDC hDC = CreateDC(TEXT("Display"),NULL, NULL, NULL) ;  // a temp DC on the desktop
    if (NULL == hDC)
    {
        DbgLog((LOG_TRACE, 1, TEXT("ERROR: Couldn't create DC for font enum"))) ;
        ASSERT(hDC) ;
        return ;
    }
    EnumFontFamiliesEx(hDC, &m_lfChar, (FONTENUMPROC) EnumFontProc, (LPARAM)(LPVOID)this, 0) ;
    DeleteDC(hDC) ;  // done with temp DC
}


void CLine21DecDraw::InitColorNLastChar(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitColorNLastChar()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // Last caption char init
    m_ccLast.SetChar(0) ;
    m_ccLast.SetEffect(0) ;
    m_ccLast.SetColor(AM_L21_FGCOLOR_WHITE) ;

    // By default we use white text on a black opaque background
    m_uColorIndex = AM_L21_FGCOLOR_WHITE ;

    // For now assume an opaque background
    m_bOpaque = TRUE ;
    m_dwBackground = 0x80000000 ;  // 0xFF000000

    // We go back to white chars with normal style
    ChangeFont(AM_L21_FGCOLOR_WHITE, FALSE, FALSE) ;
}


void CLine21DecDraw::InitCharSet(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitCharSet()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // First init with the worst case chars -- last 8 spaces blanked out
    //                                  1         2         3         4         5         6         7         8         9        10        11        12
    //                       01 23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
    TCHAR *lpszChars = TEXT(" !\"#$%&'()A+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[E]IOUabcdefghijklmnopqrstuvwxyzC NN         A EAEIOU        ") ;
    for (int i = 0 ; i < 120 ; i++)
    {
        m_lpwCharSet[i] = MAKECCCHAR(0, lpszChars[i]) ;
    }
    m_lpwCharSet[120] = MAKECCCHAR(0, 0) ;

    // Change a few special chars embedded in the standard char range
    m_lpwCharSet[ 10] = 0x00e1 ;  // 'a' with an acute accent
    m_lpwCharSet[ 60] = 0x00e9 ;  // 'e' with an acute accent
    m_lpwCharSet[ 62] = 0x00ed ;  // 'i' with an acute accent
    m_lpwCharSet[ 63] = 0x00f3 ;  // 'o' with an acute accent
    m_lpwCharSet[ 64] = 0x00fa ;  // 'u' with an acute accent
    m_lpwCharSet[ 91] = 0x00e7 ;  // 'c' with cedilla
    m_lpwCharSet[ 92] = 0x00f7 ;  // division sign
    m_lpwCharSet[ 93] = 0x00d1 ;  // 'N' with tilde
    m_lpwCharSet[ 94] = 0x00f1 ;  // 'n' with tilde
    m_lpwCharSet[ 95] = 0x2588 ;  // solid block

    // Then fill in the range of real special chars
    m_lpwCharSet[ 96] = 0x00ae ;  // 30h
    m_lpwCharSet[ 97] = 0x00b0 ;  // 31h
    m_lpwCharSet[ 98] = 0x00bd ;  // 32h
    m_lpwCharSet[ 99] = 0x00bf ;  // 33h
    m_lpwCharSet[100] = 0x2122 ;  // 34h
    m_lpwCharSet[101] = 0x00a2 ;  // 35h
    m_lpwCharSet[102] = 0x00a3 ;  // 36h
    m_lpwCharSet[103] = 0x266b ;  // 37h
    m_lpwCharSet[104] = 0x00e0 ;  // 38h
    m_lpwCharSet[105] = 0x0000 ;  // 39h
    m_lpwCharSet[106] = 0x00e8 ;  // 3ah
    m_lpwCharSet[107] = 0x00e2 ;  // 3bh
    m_lpwCharSet[108] = 0x00ea ;  // 3ch
    m_lpwCharSet[109] = 0x00ee ;  // 3dh
    m_lpwCharSet[110] = 0x00f4 ;  // 3eh
    m_lpwCharSet[111] = 0x00fb ;  // 3fh
}


bool CLine21DecDraw::InitBMIData(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitBMIData()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    HDC  hDCTemp = GetDC(NULL) ;
    if (NULL == hDCTemp)
    {
        ASSERT(!TEXT("GetDC(NULL) failed")) ;
        return false ;
    }
    WORD wPlanes   = (WORD)GetDeviceCaps(hDCTemp, PLANES) ;
    WORD wBitCount = (WORD)GetDeviceCaps(hDCTemp, BITSPIXEL) ;
    ReleaseDC(NULL, hDCTemp) ;

    wPlanes   = 1 ;
    wBitCount = wBitCount ;

    m_uBMIInSize = sizeof(BITMAPINFOHEADER) ;  // at least

    // Increase BITMAPINFO struct size based of bpp value
    if (8 == wBitCount)        // palettized mode
        m_uBMIInSize += 256 * sizeof(RGBQUAD) ;  // for palette entries
    else
        m_uBMIInSize += 3 * sizeof(RGBQUAD) ;    // space for bitmasks, if needed

    m_lpBMIIn = (LPBITMAPINFO) new BYTE[m_uBMIInSize] ;
    if (NULL == m_lpBMIIn)
    {
        ASSERT(!TEXT("Out of memory for BMIIn buffer")) ;
        return false ;
    }
    m_lpBMIIn->bmiHeader.biSize     = sizeof(BITMAPINFOHEADER) ;
    m_lpBMIIn->bmiHeader.biWidth    = CAPTION_OUTPUT_WIDTH ;
    m_lpBMIIn->bmiHeader.biHeight   = CAPTION_OUTPUT_HEIGHT ;
    m_lpBMIIn->bmiHeader.biPlanes   = wPlanes ;
    m_lpBMIIn->bmiHeader.biBitCount = wBitCount ;
    if (16 == m_lpBMIIn->bmiHeader.biBitCount)  // assume 565
        m_lpBMIIn->bmiHeader.biCompression = BI_BITFIELDS ;
    else
        m_lpBMIIn->bmiHeader.biCompression = BI_RGB ;
    m_lpBMIIn->bmiHeader.biSizeImage = DIBSIZE(m_lpBMIIn->bmiHeader) ;
    m_lpBMIIn->bmiHeader.biXPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biYPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biClrUsed = 0 ;
    m_lpBMIIn->bmiHeader.biClrImportant = 0 ;

    //
    // If we are in bitfield mode, set the bmiColors values too.
    // If we are in palettized mode, pickthe system palette.
    //
    DWORD  *pdw = (DWORD *) m_lpBMIIn->bmiColors ;
    switch (m_lpBMIIn->bmiHeader.biBitCount)
    {
    case 8:
        // GetPaletteForFormat((LPBITMAPINFOHEADER) m_lpBMIIn) ;
        ASSERT(8 != m_lpBMIIn->bmiHeader.biBitCount) ;
        return false ;
        // break ;

    case 16:    // by deafult 565
        if (m_lpBMIIn->bmiHeader.biCompression == BI_BITFIELDS) // 565
        {
            pdw[iRED]   = bits565[iRED] ;
            pdw[iGREEN] = bits565[iGREEN] ;
            pdw[iBLUE]  = bits565[iBLUE] ;
        }
        else    // BI_RGB: 555
        {
            pdw[iRED]   = bits555[iRED] ;
            pdw[iGREEN] = bits555[iGREEN] ;
            pdw[iBLUE]  = bits555[iBLUE] ;
        }
        break ;

    case 24:  //  clear all...
        pdw[iRED]   =
        pdw[iGREEN] =
        pdw[iBLUE]  = 0 ;
        break ;

    case 32:  // set the masks
        if (m_lpBMIIn->bmiHeader.biCompression == BI_BITFIELDS)
        {
            pdw[iRED]   = bits888[iRED] ;
            pdw[iGREEN] = bits888[iGREEN] ;
            pdw[iBLUE]  = bits888[iBLUE] ;
        }
        else              // BI_RGB
        {
            pdw[iRED]   =
            pdw[iGREEN] =
            pdw[iBLUE]  = 0 ;
        }
        break ;

    default:  // don't care
        ASSERT(!TEXT("Bad biBitCount!!")) ;
        break ;
    }

    return true ;
}


BOOL CLine21DecDraw::SetBackgroundColor(DWORD dwBGColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetBackgroundColor(0x%lx)"), dwBGColor)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    BOOL  bResult = TRUE ;
    if (m_dwBackground != dwBGColor)
    {
        m_dwBackground = dwBGColor ;
        SetFontUpdate(true) ;  // need to rebuild font caches for new BG color
    }

    return true ;   // bResult ;
}


// Create normal, italic and special (color, U or I+U) font caches
bool CLine21DecDraw::InitFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitFont()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // Create a normal font to find out the char size etc.
    HFONT hFont = CreateCCFont(0, m_iCharHeight, FALSE, FALSE) ;
    if (NULL == hFont)  // font creation failed
    {
        return false ;
    }

    //
    // The following magic is necessary to get GDI to rasterize
    // the font with anti-aliasing switched on when we later use
    // the font in a DDraw Surface.  The doc's say that this is only
    // necessary in Win9X - but Win2K seems to require it too.
    //
    SIZE size ;
    LPCTSTR  lpszStr = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ") ;
    HDC hdcWin = GetDC(NULL) ;
    HFONT hFontOld = (HFONT)SelectObject(hdcWin, hFont) ;  // select new font
    GetTextExtentPoint32(hdcWin, lpszStr, lstrlen(lpszStr), &size) ;
    size.cx /= lstrlen(lpszStr) ;  // get per char width

    // Restore font to original and delete font now
    hFont = (HFONT)SelectObject(hdcWin, hFontOld) ;
    DeleteObject(hFont) ;

    //
    // Make sure that the font doesn't get too big.
    //
    if (size.cx * FONTCACHELINELENGTH > 1024) {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Text size (%d) is too big. Can't create font."), size.cx)) ;
        ReleaseDC(NULL, hdcWin) ;  // release new DC created here
        return false ;
    }

    // Set the char size
    m_iCharWidth  = size.cx ;  // iMaxWidth ;
    m_iCharHeight = size.cy ;

    // Also re-calc scroll step value now
    m_iScrollStep = CalcScrollStepFromCharHeight() ;

    // Calculate the horizontal offset and vertical offset of the CC area within
    // the output DDraw surface
    int iCCRectWidth  = m_iCharWidth * (MAX_CAPTION_COLUMNS + 2) ; // +2 for leading and trailing space
    iCCRectWidth  = DWORDALIGN(iCCRectWidth) ;  // make sure to DWORD align it
    m_iHorzOffset = min((long)(m_lHeight * m_iBorderPercent / 200),  // border % is for 2 sides
                        (m_lWidth - iCCRectWidth) / 2) ;
    // iCCRectHeight = m_iCharHeight * MAX_CAPTION_LINES ;        // max 4 lines of caption shown
    // Vertically we want to leave 10% of the height or leave just enough space
    // to accomodate all the caption lines
    m_iVertOffset = min((long)(m_lHeight * m_iBorderPercent / 200),  // border % is for 2 sides
                        (m_lHeight - (long)(m_iCharHeight * MAX_CAPTION_ROWS)) / 2) ;

    // Create white color normal and italic font caches now
    bool  bResult = true ;
    DWORD dwTextColor = m_uColorIndex ;
    DWORD  dwBGColor  = 0xFF000000 ; // m_dwBackground ;
    DWORD dwOpacity   = m_bOpaque ? OPAQUE : 0 ;
    if (m_lpDDSScratch)
    {
        m_lpDDSScratch->Release() ;
        m_lpDDSScratch = NULL ;
    }
    if (m_lpDDSNormalFontCache)
    {
        m_lpDDSNormalFontCache->Release() ;
        m_lpDDSNormalFontCache = NULL ;
    }
    if (m_lpDDSItalicFontCache)
    {
        m_lpDDSItalicFontCache->Release() ;
        m_lpDDSItalicFontCache = NULL ;
    }

    bResult &= CreateScratchFontCache(&m_lpDDSScratch) ;
    bResult &= CreateFontCache(&m_lpDDSNormalFontCache, dwTextColor, dwBGColor, dwOpacity, FALSE, FALSE) ;
    bResult &= CreateFontCache(&m_lpDDSItalicFontCache, dwTextColor, dwBGColor, dwOpacity, TRUE, FALSE) ;
    // We don't create any special font cache, because we don't what will be
    // required.  So we just reset it here.
    if (m_lpDDSSpecialFontCache)
    {
        m_lpDDSSpecialFontCache->Release() ;
        m_lpDDSSpecialFontCache = NULL ;
    }

    //
    // We set the current font cache to the normal font cache by default
    //
    m_lpBltList = m_lpDDSNormalFontCache ;

    //
    // Now release the resources acquired locally
    //
    ReleaseDC(NULL, hdcWin) ;  // release the locally created DC
    // DeleteObject(hFont) ;      // delete font

    // If we successfully (re-)inited the font cache, reset the flag
    if (bResult)
    {
        SetFontUpdate(false) ;
    }

    return bResult ;  // return status
}


HFONT CLine21DecDraw::CreateCCFont(int iFontWidth, int iFontHeight, BOOL bItalic, BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::CreateCCFont(%d, %d, %s, %s)"),
            iFontWidth, iFontHeight, bItalic ? TEXT("T") : TEXT("F"), bUnderline ? TEXT("T") : TEXT("F"))) ;

    //
    // Initialize LOGFONT structure to create an "anti-aliased" Lucida Console font
    //
    LOGFONT lfChar ;
    ZeroMemory(&lfChar, sizeof(lfChar)) ;

    // Init a LOGFONT struct in m_lfChar
    if (IsTTFont())
    {
        DbgLog((LOG_TRACE, 5, TEXT("Got Lucida Console TT Font"))) ;
        lstrcpy(lfChar.lfFaceName, TEXT("Lucida Console")) ;
        if (0 == iFontWidth)
        {
            lfChar.lfHeight     = -iFontHeight ;
        }
        else
        {
            lfChar.lfHeight     = iFontHeight ;
            lfChar.lfWidth      = iFontWidth ;
        }

        // m_lfChar.lfCharSet set in CheckTTFont()
        // m_lfChar.lfPitchAndFamily set in CheckTTFont()
        lfChar.lfCharSet        = m_lfChar.lfCharSet ;
        lfChar.lfPitchAndFamily = m_lfChar.lfPitchAndFamily ;
    }
    else  // no Lucida Console; use 8x12 Terminal font
    {
        DbgLog((LOG_TRACE, 1, 
                TEXT("Did NOT get Lucida Console TT Font. Will use Terminal"))) ;
        lfChar.lfHeight = iFontHeight ;
        lfChar.lfWidth  = iFontWidth ;
        lfChar.lfCharSet = ANSI_CHARSET ;
        lfChar.lfPitchAndFamily = FIXED_PITCH | FF_MODERN ;
        lstrcpy(lfChar.lfFaceName, TEXT("Terminal")) ;
    }

    lfChar.lfWeight         = FW_NORMAL ;
    lfChar.lfItalic         = bItalic ? TRUE : FALSE ;
    lfChar.lfUnderline      = bUnderline ? TRUE : FALSE ;
    lfChar.lfOutPrecision   = OUT_STRING_PRECIS ;
    lfChar.lfClipPrecision  = CLIP_STROKE_PRECIS ;
    lfChar.lfQuality        = ANTIALIASED_QUALITY ;

    HFONT hFont = CreateFontIndirect(&lfChar) ;
    if ( !hFont )
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("WARNING: CreateFontIndirect('Lucida Console') failed (Error %ld)"),
            GetLastError())) ;
        return NULL ;
    }

    return hFont ;
}


bool CLine21DecDraw::CreateScratchFontCache(LPDIRECTDRAWSURFACE7* lplpDDSFontCache)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::CreateScratchFontCache(0x%lx)"), lplpDDSFontCache)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // Create the DDraw ARGB32/ARGB4444 surface in "system" memory to be used as
    // a scratch font cache, where the chars will be drawn; then the alpha value
    // will be set and the resulting bits will be written into the final
    // destination font cache.  This will speed up font cache creation a lot, as
    // it avoid the read-modify-write cycle on VRAM font caches.
    //
    HRESULT hr = DDrawARGBSurfaceInit(lplpDDSFontCache, TRUE /* use SysMem */, FALSE /* Texture */,
                        FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE),
                        FONTCACHENUMLINES  * m_iCharHeight) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("DDrawARGBSurfaceInit() failed for scratch (Error 0x%lx)"), hr)) ;
        return false ;
    }

    // Clear the scratch surface before drawing the chars on it
    DDBLTFX ddFX ;
    ZeroMemory(&ddFX, sizeof(ddFX)) ;
    ddFX.dwSize = sizeof(ddFX) ;
    ddFX.dwFillColor =  0x00000000 ;
    hr = (*lplpDDSFontCache)->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &ddFX) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Blt() to clear scratch font cache failed (Error 0x%lx)"), hr)) ;
        return false ;
    }

    return true ;
}


bool CLine21DecDraw::CreateFontCache(LPDIRECTDRAWSURFACE7* lplpDDSFontCache,
                                     DWORD dwTextColor, DWORD dwBGColor,
                                     DWORD dwOpacity, BOOL bItalic,
                                     BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::CreateFontCache(0x%lx, 0x%lx, 0x%lx, 0x%lx, %s, %s)"),
            lplpDDSFontCache, dwTextColor, dwBGColor, dwOpacity,
            bItalic ? TEXT("T") : TEXT("F"), bUnderline ? TEXT("T") : TEXT("F"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    HRESULT   hr ;

    //
    // First make sure the scratch font cache exists; otherwise try to create it.
    //
    if (NULL == m_lpDDSScratch)
    {
        bool bResult = CreateScratchFontCache(&m_lpDDSScratch) ;
        if (! bResult )
        {
            return false ;
        }
    }

    //
    // Delete the old font cache
    //
    if (*lplpDDSFontCache)
    {
        (*lplpDDSFontCache)->Release() ;
        *lplpDDSFontCache = NULL ;
    }

    //
    // Create the DDraw ARGB32/ARGB4444 surface in "video" memory to be used as
    // font cache
    //
    hr = DDrawARGBSurfaceInit(lplpDDSFontCache, FALSE /* use VRAM */, TRUE /* Texture */,
                        FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE),
                        FONTCACHENUMLINES  * m_iCharHeight) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("DDrawARGBSurfaceInit() failed (Error 0x%lx)"), hr)) ;
        return false ;
    }

    // Get the DC for the scratch font cache (DDraw surface)
    HDC hdcDest ;
    m_lpDDSScratch->GetDC(&hdcDest) ;

    // Create a normal font to find out the char size etc.
    HFONT  hFont ;
    if (bItalic)
    {
        hFont = CreateCCFont(m_iCharWidth - INTERCHAR_SPACE_EXTRA, m_iCharHeight,
                             bItalic, bUnderline) ;
        SetTextCharacterExtra(hdcDest, INTERCHAR_SPACE + INTERCHAR_SPACE_EXTRA) ;  // add 6 inter-char spaces
    }
    else
    {
        hFont = CreateCCFont(0, m_iCharHeight, bItalic, bUnderline) ;
        SetTextCharacterExtra(hdcDest, INTERCHAR_SPACE) ;  // add 4 inter-char spaces
    }
    if (NULL == hFont)  // font creation failed
    {
        return false ;
    }

    //
    // Select the font into the DDraw surface and draw the characters
    //
    hFont = (HFONT)SelectObject(hdcDest, hFont) ;
    SetTextColor(hdcDest, m_acrFGColors[dwTextColor]) ;
    SetBkColor(hdcDest, dwBGColor) ;
    SetBkMode(hdcDest, dwOpacity) ;

    int iRow ;
    for (iRow = 0 ; iRow < FONTCACHENUMLINES ; iRow++)
    {
        ExtTextOutW(hdcDest, 0, iRow * m_iCharHeight, ETO_OPAQUE, NULL,
                    m_lpwCharSet + iRow * FONTCACHELINELENGTH, FONTCACHELINELENGTH,
                    NULL) ;
    }

    // Restore original font in DC and let go of them
    hFont = (HFONT)SelectObject(hdcDest, hFont) ;
    m_lpDDSScratch->ReleaseDC(hdcDest) ;
    DeleteObject(hFont) ;

    // Read each pixel data, set the alpha value, and then write to the VRAM font cache
    SetFontCacheAlpha(m_lpDDSScratch, *lplpDDSFontCache, m_idxFGColors[dwTextColor]) ;

    return true ;  // success
}


// We return a 32bit alpha value, which gets trimmed to 16bit by the caller, if needed
DWORD
CLine21DecDraw::GetAlphaFromBGColor(int iBitDepth)
{
    DWORD  dwAlpha = 0 ;

    switch (iBitDepth)
    {
    case 8:
        dwAlpha = 0x80;
        break ;

    case 16:
        dwAlpha = (m_dwBackground & 0xF0000000) >> 16 ;
        break ;

    case 32:
        dwAlpha = (m_dwBackground & 0xFF000000) ;
        break ;

    default:
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: GetAlphaFromBGColor(%d) called"), iBitDepth)) ;
        break ;
    }

    return dwAlpha ;
}


// We return a 32bit color value, which gets trimmed to 16bit by the caller, if needed
DWORD
CLine21DecDraw::GetColorBitsFromBGColor(int iBitDepth)
{
    DWORD  dwColorBits = 0 ;

    switch (iBitDepth)
    {
    case 16:
        dwColorBits = ((m_dwBackground & 0x00F00000) >> 12) |
                      ((m_dwBackground & 0x0000F000) >>  8) |
                      ((m_dwBackground & 0x000000F0) >>  4) ;
        break ;

    case 32:
        dwColorBits = (m_dwBackground & 0x00FFFFFF) ;
        break ;

    default:
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: GetColorBitsFromBGColor(%d) called"), iBitDepth)) ;
        break ;
    }

    return dwColorBits ;
}


void
CLine21DecDraw::SetFontCacheAlpha(LPDIRECTDRAWSURFACE7 lpDDSFontCacheSrc,
                                  LPDIRECTDRAWSURFACE7 lpDDSFontCacheDest,
                                  BYTE bFGClr
                                  )
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::SetFontCacheAlpha(0x%lx, 0x%lx)"), lpDDSFontCacheSrc, lpDDSFontCacheDest)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // We set the alpha values by hand here.  This is done on every pixel of the
    // font cache, but it happens only when the cache is created.
    // It gets us better font smoothing too.
    //
    HRESULT hr ;
    DDSURFACEDESC2 sdSrc, sdDest ;
    ZeroMemory(&sdSrc, sizeof(sdSrc)) ;
    sdSrc.dwSize = sizeof(sdSrc) ;
    hr = lpDDSFontCacheSrc->Lock(NULL, &sdSrc, DDLOCK_WAIT, NULL) ;
    if (DD_OK != hr)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Source font cache surface Lock() failed (Error 0x%lx)"), hr)) ;
        ASSERT(DD_OK == hr) ;
        return ;
    }
    ZeroMemory(&sdDest, sizeof(sdDest)) ;
    sdDest.dwSize = sizeof(sdDest) ;
    hr = lpDDSFontCacheDest->Lock(NULL, &sdDest, DDLOCK_WAIT, NULL) ;
    if (DD_OK != hr)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Dest font cache surface Lock() failed (Error 0x%lx)"), hr)) ;
        ASSERT(DD_OK == hr) ;
        lpDDSFontCacheSrc->Unlock(NULL) ;
        return ;
    }

    // Now we set the alpha based on the bitdepth at which we are outputting

    switch (sdDest.ddpfPixelFormat.dwRGBBitCount)
    {
    case 8:
        {
            DbgLog((LOG_TRACE, 5, TEXT("CC is being output at AI44"))) ;
            LPDWORD lpwSrc  = (LPDWORD) sdSrc.lpSurface ;
            LPBYTE lpwDest  = (LPBYTE) sdDest.lpSurface ;
            LPBYTE lpb ;
            BYTE   wPel ;
            BYTE   bAlpha     = (BYTE) GetAlphaFromBGColor(8) ;

            for (int iRow = 0 ; iRow < FONTCACHENUMLINES * m_iCharHeight ; iRow++)
            {
                LPDWORD lpwS = lpwSrc ;
                LPBYTE lpwD = lpwDest ;

                for (int iCol = 0 ;
                     iCol < FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE) ;
                     iCol++)
                {
                    BYTE bPel = (BYTE)(*lpwS & 0xF0);
                    if (bPel)
                    {
                        bPel |= bFGClr;
                    }
                    else
                    {
                        bPel  = bAlpha ;  // | dwColorBits ;  // turn on alpha partially
                    }

                    *lpwD++ = bPel ;
                    lpwS++ ;
                }
                lpwSrc  += (sdSrc.lPitch / sizeof(DWORD)) ;
                lpwDest += sdDest.lPitch;
            }

            break;
        }

    case 16:
        {
            DbgLog((LOG_TRACE, 5, TEXT("CC is being output at ARGB4444"))) ;
            LPWORD lpwSrc  = (LPWORD) sdSrc.lpSurface ;
            LPWORD lpwDest = (LPWORD) sdDest.lpSurface ;
            WORD   wRed, wGreen, wBlue ;
            LPBYTE lpb ;
            WORD   wPel ;
            WORD   wAlpha     = (WORD) GetAlphaFromBGColor(16) ;
            WORD   wColorBits = (WORD) GetColorBitsFromBGColor(16) ;

            for (int iRow = 0 ; iRow < FONTCACHENUMLINES * m_iCharHeight ; iRow++)
            {
                LPWORD lpwS = lpwSrc ;
                LPWORD lpwD = lpwDest ;

                for (int iCol = 0 ;
                     iCol < FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE) ;
                     iCol++)
                {
                    wRed = 0, wGreen = 0, wBlue = 0 ; // , wAlpha = 0 ;
                    lpb = (LPBYTE)lpwS ;
                    wPel = MAKEWORD(lpb[0], lpb[1]) ;
                    if (wPel)
                    {
                        wRed   = (wPel & 0xF000) >> 4 ;
                        wGreen = (wPel & 0x0780) >> 3 ;
                        wBlue  = (wPel & 0x001E) >> 1 ;
                        // wAlpha = 0xF000 ;  // turn on alpha fully
                        wPel   = 0xF000 | wRed | wGreen | wBlue ;
                    }
                    else
                    {
                        wPel   = wAlpha ;  // | wColorBits ;
                    }

                    *lpwD++ = wPel ;
                    lpwS++ ;
                }
                lpwSrc  += (sdSrc.lPitch / sizeof(WORD)) ;
                lpwDest += (sdDest.lPitch / sizeof(WORD)) ;
            }
            break ;
        }

    case 32:
        {
            DbgLog((LOG_TRACE, 5, TEXT("CC is being output at ARGB32"))) ;
            LPDWORD lpdwSrc = (LPDWORD) sdSrc.lpSurface ;
            LPDWORD lpdwDst = (LPDWORD) sdDest.lpSurface ;
            DWORD   dwAlpha = GetAlphaFromBGColor(32) ;
            DWORD   dwColorBits = GetColorBitsFromBGColor(32) ;
            for (int iRow = 0 ; iRow < FONTCACHENUMLINES * m_iCharHeight ; iRow++)
            {
                LPDWORD lpdw  = lpdwDst ;
                LPDWORD lpdwS = lpdwSrc ;

                for (int iCol = 0 ;
                     iCol < FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE) ;
                     iCol++)
                {
                    DWORD dwPel = *lpdwS ;
                    if (dwPel)
                    {
                        dwPel |= 0xFF000000 ;  // turn on alpha fully
                    }
                    else
                    {
                        dwPel  = dwAlpha ;  // | dwColorBits ;  // turn on alpha partially
                    }

                    *lpdw++ = dwPel ;
                    lpdwS++;
                }
                lpdwSrc += (sdSrc.lPitch / sizeof(DWORD)) ;
                lpdwDst += (sdDest.lPitch / sizeof(DWORD)) ;
            }
            break ;
        }

    default:
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Bad display bitdepth (%d) mode"), sdDest.ddpfPixelFormat.dwRGBBitCount)) ;

        break ;
    }  // end of switch ()

    // Done with everything
    lpDDSFontCacheSrc->Unlock(NULL) ;
    lpDDSFontCacheDest->Unlock(NULL) ;
}


HRESULT
CLine21DecDraw::DDrawARGBSurfaceInit(LPDIRECTDRAWSURFACE7* lplpDDSFontCache,
                                     BOOL bUseSysMem, BOOL bTexture,
                                     DWORD cx, DWORD cy)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::DDrawARGBSurfaceInit(0x%lx, %s, %lu, %lu)"),
            lplpDDSFontCache, (TRUE == bUseSysMem) ? TEXT("T") : TEXT("F"),
            (TRUE == bTexture) ? TEXT("T") : TEXT("F"), cx, cy)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // Just to be sure that the cached DDraw object is valid...
    if (NULL == m_pDDrawObjUnk)

    {
        DbgLog((LOG_TRACE, 1,
            TEXT("DDrawARGBSurfaceInit(): m_pDDrawObjUnk is not yet set. Skipping the rest."))) ;
        ASSERT(m_pDDrawObjUnk) ;
        return E_UNEXPECTED ;
    }

    DDSURFACEDESC2 ddsd ;
    HRESULT hRet ;

    *lplpDDSFontCache = NULL ;

    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;

    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;

    // Set the DDPIXELFORMAT part
    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT) ;
    ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB ;

    if (bTexture  ||  !bUseSysMem)  // for VRAM surface
    {
        if (8 != lpbmih->biBitCount) {
            ddsd.ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS ;
        }
    }

    ddsd.ddpfPixelFormat.dwRGBBitCount = lpbmih->biBitCount ;
    if (8 == lpbmih->biBitCount) {

        if (bUseSysMem) {
            // scratch surface RGB32
            ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
            ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000 ;
            ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00 ;
            ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FF ;
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x00000000 ;  // to be sure
        }
        else {
            // VRAM surface -- AI44
            ddsd.ddpfPixelFormat.dwFourCC = '44IA';
        }
    }
    else if (16 == lpbmih->biBitCount)
    {
        if (bUseSysMem) // scratch surface -- RGB565
        {
            ddsd.ddpfPixelFormat.dwRBitMask = 0xF800 ;
            ddsd.ddpfPixelFormat.dwGBitMask = 0x07E0 ;
            ddsd.ddpfPixelFormat.dwBBitMask = 0x001F ;
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x0000 ;
        }
        else            // VRAM surface -- ARGB4444
        {
            ddsd.ddpfPixelFormat.dwRBitMask = 0x0F00 ;
            ddsd.ddpfPixelFormat.dwGBitMask = 0x00F0 ;
            ddsd.ddpfPixelFormat.dwBBitMask = 0x000F ;
            if (bTexture)
                ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xF000 ;
            else
                ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x0000 ;  // to be sure
        }
    }
    else
    {
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000 ;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00 ;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FF ;
        if (bTexture)
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF000000 ;
        else
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x00000000 ;  // to be sure
    }

    // Create the Caps bits
    DWORD  dwCaps = 0 ;
    if (bUseSysMem)
    {
        dwCaps |= DDSCAPS_SYSTEMMEMORY ;
    }
    else
    {
        dwCaps |= DDSCAPS_VIDEOMEMORY ;
    }
    if (bTexture)
    {
        dwCaps |= DDSCAPS_TEXTURE ;
    }
    else
    {
        dwCaps |= DDSCAPS_OFFSCREENPLAIN ;
    }
    ddsd.ddsCaps.dwCaps = dwCaps ;

    // Now flags and other fields...
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_PIXELFORMAT ;
    ddsd.dwBackBufferCount = 0 ;

    if (bTexture)
    {
        for (ddsd.dwWidth  = 1 ; cx > ddsd.dwWidth  ; ddsd.dwWidth  <<= 1)
            ;
        for (ddsd.dwHeight = 1 ; cy > ddsd.dwHeight ; ddsd.dwHeight <<= 1)
            ;
    }
    else
    {
        ddsd.dwWidth  = cx ;
        ddsd.dwHeight = cy ;
    }

    // Create the surface with these settings
    LPDIRECTDRAW7  lpDDObj ;
    hRet = m_pDDrawObjUnk->QueryInterface(IID_IDirectDraw7, (LPVOID *) &lpDDObj) ;
    if (SUCCEEDED(hRet))
    {
        hRet = lpDDObj->CreateSurface(&ddsd, lplpDDSFontCache, NULL) ;
        lpDDObj->Release() ;  // done with the interface
    }

    return hRet ;
}


bool CLine21DecDraw::CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight,
                                            int *piCharWidth, int *piCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::CharSizeFromOutputSize(%ld, %ld, 0x%lx, 0x%lx)"),
            lOutWidth, lOutHeight, piCharWidth, piCharHeight)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // We only care about the absolute value here
    lOutWidth  = ABS(lOutWidth) ;
    lOutHeight = ABS(lOutHeight) ;

    if ( IsTTFont() )  // TT font
    {
        if (! ISDWORDALIGNED(lOutWidth) )  // must have DWORD-aligned width
            return false ;

        *piCharWidth   = (int)(lOutWidth * (100 - m_iBorderPercent) / 100) ;  // 80-90% of width
        *piCharWidth  += MAX_CAPTION_COLUMNS / 2 + 1 ;  // max_col / 2 for rounding
        *piCharWidth  /= (MAX_CAPTION_COLUMNS + 2) ;    // space per column
        *piCharHeight  = (int)(lOutHeight * (100 - m_iBorderPercent) / 100) ; // 80-90% of width
        *piCharHeight += (MAX_CAPTION_ROWS / 2) ;       // max_row / 2 for rounding
        *piCharHeight /= MAX_CAPTION_ROWS ;             // space per row
        return true ;  // acceptable
    }
    else  // non-TT font (Terminal) -- only 320x240 or 640x480
    {
        if (640 == lOutWidth  &&  480 == lOutHeight)
        {
            *piCharWidth  = 16 ;
            *piCharHeight = 24 ;
            return true ;  // acceptable
        }
        else if (320 == lOutWidth  &&  240 == lOutHeight)
        {
            *piCharWidth  = 8 ;
            *piCharHeight = 12 ;
            return true ;  // acceptable
        }
        else
            return false ;  // can't handle size for non-TT font
    }
}


bool CLine21DecDraw::SetOutputSize(LONG lWidth, LONG lHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetOutputSize(%ld, %ld)"), lWidth, lHeight)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // If a output format is specified by downstream filter, use it; else use upstream's
    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;

    // Now we want to use the ABS()-ed values for calculating the char sizes
    lWidth  = ABS(lWidth) ;
    lHeight = ABS(lHeight) ;

    if (lpbmih)
    {
        // Check if current output bitmap size is the same or not.
        // This also includes height changing from +ve to -ve and vice-versa
        if (lWidth  == m_lWidth  &&
            lHeight == m_lHeight)
            return false ;    // same size; nothing changed

        // Store the width and height now so that we can compare any size
        // change and/or -ve/+ve height thing later.
        // m_lWidth  = lWidth ;
        // m_lHeight = lHeight ;
    }

    // Create new DIB section with new sizes (leaving borders)
    int   iCharWidth ;
    int   iCharHeight ;
    if (! CharSizeFromOutputSize(lWidth, lHeight, &iCharWidth, &iCharHeight) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: CharSizeFromOutputSize() failed for %ld x %ld output"),
                lWidth, lHeight)) ;
        ASSERT(!TEXT("CharSizeFromOutputSize() failed")) ;
        return false ;  // failure
    }

    // Store the image and char width and height now so that we can compare any
    // size change and/or -ve/+ve height thing later.
    m_lWidth      = lWidth ;
    m_lHeight     = lHeight ;
    m_iCharWidth  = iCharWidth ;
    m_iCharHeight = iCharHeight ;
    m_iScrollStep  = CalcScrollStepFromCharHeight() ;

    // Re-calculate the horizonal and vertical offsets too
    m_iHorzOffset = m_lWidth  * m_iBorderPercent / 200 ;
    m_iVertOffset = m_lHeight * m_iBorderPercent / 200 ;

    // The font caches need to be rebuilt for new sizes (and DDraw object/surface)
    SetFontUpdate(true) ;

    return true ;
}


HRESULT CLine21DecDraw::SetOutputOutFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetOutputOutFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // NULL param means output format not available from downstream filter
    //
    if (NULL == lpbmi)
    {
        if (m_lpBMIOut)
            delete m_lpBMIOut ;
        m_lpBMIOut = NULL ;
        m_uBMIOutSize = 0 ;

        // In this case, go back to the default output format specified by
        // upstream filter
        if (m_lpBMIIn)
        {
            SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("How did we not have a default output format?"))) ;
        }
        return NOERROR ;
    }

    // Just paranoid...
    if (IsBadReadPtr(lpbmi, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Invalid output format (out) data pointer"))) ;
        return E_INVALIDARG ;
    }

    // Make sure we can handle this output size
    if (! IsSizeOK(&lpbmi->bmiHeader) )
        return E_INVALIDARG ;

    // The beginning of the VIDEOINFOHEADER struct and we don't want it
    UINT uSize = 0;
    switch (((LPBITMAPINFOHEADER)lpbmi)->biCompression) {
    case BI_RGB:
    case BI_BITFIELDS:
        uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) - SIZE_PREHEADER ;
        break;

    default: // AI44 case
        uSize = ((LPBITMAPINFOHEADER)lpbmi)->biSize;
        break;
    }

    if (NULL == m_lpBMIOut)  // If we didn't have one before then allocate space for one
    {
        m_lpBMIOut = (LPBITMAPINFO) new BYTE [uSize] ;
        if (NULL == m_lpBMIOut)
        {
            DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from downstream"))) ;
            return E_OUTOFMEMORY ;
        }
        m_uBMIOutSize = uSize ;  // new size
    }
    else  // we have an existing out format, but ...
    {
        // ... check if new data is bigger than the current space we have
        if (m_uBMIOutSize < uSize)
        {
            delete m_lpBMIOut ;
            m_lpBMIOut = (LPBITMAPINFO) new BYTE[uSize] ;
            if (NULL == m_lpBMIOut)
            {
                DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from downstream"))) ;
                m_uBMIOutSize = 0 ;
                return E_OUTOFMEMORY ;
            }
            m_uBMIOutSize = uSize ;
        }
    }

    // Make sure the output size specified by the format is such that
    // each scanline is DWORD aligned
    lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
    lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;

    // Now copy the specified format data
    CopyMemory(m_lpBMIOut, lpbmi, uSize) ;

    // Check if the output size is changing and update all the related vars
    SetOutputSize(m_lpBMIOut->bmiHeader.biWidth, m_lpBMIOut->bmiHeader.biHeight) ;

    return NOERROR ;
}


HRESULT CLine21DecDraw::SetOutputInFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetOutputInFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // NULL param means no output format from upstream filter
    //
    if (NULL == lpbmi)
    {
#if 0
        if (m_lpBMIOut)
        {
            //
            // BTW this can happen when the graph is torn down at the end of
            // playback.  We can ignore this error in that case.
            //
            DbgLog((LOG_ERROR, 3, TEXT("Can't delete Output format from upstream w/o downstream specifying it"))) ;
            return E_INVALIDARG ;
        }
#endif // #if 0
        if (m_lpBMIIn)
            delete m_lpBMIIn ;
        m_lpBMIIn = NULL ;
        m_uBMIInSize = 0 ;

        //
        // Initialize the default output format from upstream filter
        //
        InitBMIData() ;

        // return NOERROR ;
    }
    else  // non-NULL format specified
    {
        // The beginning of the VIDEOINFOHEADER struct and we don't want it
        UINT uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) - SIZE_PREHEADER ;
        if (IsBadReadPtr(lpbmi, uSize))  // just paranoid...
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Not enough output format (in) data pointer"))) ;
            ASSERT(FALSE) ;
            return E_INVALIDARG ;
        }

        // Make sure we can handle this output size
        if (! IsSizeOK(&lpbmi->bmiHeader) )
            return E_INVALIDARG ;

        if (NULL == m_lpBMIIn)  // If we didn't have one before then allocate space for one
        {
            m_lpBMIIn = (LPBITMAPINFO) new BYTE [uSize] ;
            if (NULL == m_lpBMIIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from upstream"))) ;
                return E_OUTOFMEMORY ;
            }
        }
        else  // we have an existing out format, but ...
        {
            // ... check if new data is bigger than the current space we have
            if (m_uBMIInSize < uSize)
            {
                delete m_lpBMIIn ;
                m_lpBMIIn = (LPBITMAPINFO) new BYTE[uSize] ;
                if (NULL == m_lpBMIIn)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from upstream"))) ;
                    m_uBMIInSize = 0 ;
                    return E_OUTOFMEMORY ;
                }
                m_uBMIInSize = uSize ;
            }
        }

        // Make sure the output size specified by the format is such that
        // each scanline is DWORD aligned
        lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
        lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;

        // Now copy the specified format data
        CopyMemory(m_lpBMIIn, lpbmi, uSize) ;
    }  // end of else of if (lpbmi)

    // If we don't have a output format specified by downstream then we'll
    // use this output format and resize the output accordingly
    if (NULL == m_lpBMIOut)
    {
        // Check if output size is changing and update all the related vars
        SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
    }

    return NOERROR ;
}


void CLine21DecDraw::FillOutputBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::FillOutputBuffer()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // First check if the output DDraw surface is valid (it's NOT valid during
    // start-up, when the style, service etc. get set).  We should skip the rest
    // of the code as it's not necessary at that stage anyway.
    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    DDBLTFX ddFX ;
    ZeroMemory(&ddFX, sizeof(ddFX)) ;
    ddFX.dwSize = sizeof(ddFX) ;
    ddFX.dwFillColor =  0x00000000 ;

    HRESULT  hr = m_lpDDSOutput->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &ddFX) ;
    if (SUCCEEDED(hr))
    {
        m_bOutputClear = TRUE ;    // output buffer is totally clear
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("WARNING: CC output clearing failed (Blt() Error 0x%lx)"), hr)) ;
    }
}


//
// This method is required only to generate the default format block in case
// the upstream filter doesn't specify FORMAT_VideoInfo type.
//
HRESULT CLine21DecDraw::GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetDefaultFormatInfo(0x%lx, 0x%lx)"),
            lpbmi, pdwSize)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == pdwSize || IsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        return E_INVALIDARG ;
    }

    LPBITMAPINFO lpbmiCurr = (m_lpBMIOut ? m_lpBMIOut : m_lpBMIIn) ;
    UINT dwCurrSize = (m_lpBMIOut ? m_uBMIOutSize : m_uBMIInSize) ;
    ASSERT(dwCurrSize) ;  // just a check

    if (NULL == lpbmi)      // wants just the format data size
    {
        *pdwSize = dwCurrSize ;
        return NOERROR ;
    }

    if (IsBadWritePtr(lpbmi, *pdwSize))  // not enough space in out-param
        return E_INVALIDARG ;

    *pdwSize = min(*pdwSize, dwCurrSize) ;  // minm of actual and given
    CopyMemory(lpbmi, lpbmiCurr, *pdwSize) ;

    return NOERROR ;   // success
}


HRESULT CLine21DecDraw::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetOutputFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))  // not enough space in out-param
        return E_INVALIDARG ;

    ZeroMemory(lpbmih, sizeof(BITMAPINFOHEADER)) ;  // just to keep it clear

    LPBITMAPINFOHEADER lpbmihCurr = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    if (NULL == lpbmihCurr)  // no output format specified by downstream
        return S_FALSE ;

    CopyMemory(lpbmih, lpbmihCurr, sizeof(BITMAPINFOHEADER)) ;

    return S_OK ;   // success
}


HRESULT CLine21DecDraw::GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetOutputOutFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetOutputOutFormat(): Bad in param"))) ;
        return E_INVALIDARG ;
    }
    if (m_lpBMIOut)
    {
        CopyMemory(lpbmih, m_lpBMIOut, sizeof(BITMAPINFOHEADER)) ;
        return S_OK ;
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("GetOutputOutFormat(): No output format specified by downstream filter"))) ;
        return S_FALSE ;
    }
}


BOOL CLine21DecDraw::IsSizeOK(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::IsSizeOK(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    return ((IsTTFont() && ISDWORDALIGNED(lpbmih->biWidth))  ||  // TT font and DWORD-aligned width  or
            (!IsTTFont() &&                                      // non-TT font and ...
             ((320 == ABS(lpbmih->biWidth) && 240 == ABS(lpbmih->biHeight)) ||   // 320x240 output or
              (640 == ABS(lpbmih->biWidth) && 480 == ABS(lpbmih->biHeight))))) ; // 640x480 output
}


bool CLine21DecDraw::SetDDrawSurface(LPDIRECTDRAWSURFACE7 lpDDSurf)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetDDrawSurface(0x%lx)"), lpDDSurf)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // The passed in DDraw surface pointer may be NULL when the pin connection
    // is broken.  In that case, we skip almost everything else.
    if (NULL == lpDDSurf)
    {
        // Save the new DDraw surface pointer
        m_bNewOutBuffer = m_lpDDSOutput != lpDDSurf ;  // has it changed?
        m_lpDDSOutput = NULL ;  // no DDraw surface to cache
        SetDDrawObject(NULL) ;  // ... and no DDraw object either

        return true ;  // it's OK
    }

    bool  bResult = true ;

    // First check if the DDraw objects are the same
    IUnknown  *pDDObj ;
    HRESULT hr = lpDDSurf->GetDDInterface((LPVOID*)&pDDObj) ;
    if (SUCCEEDED(hr)  &&  pDDObj)
    {
        // If the DDraw object changed (probably window shifted to different
        // monitor or display res changed etc), we need to re-do a whole
        // bunch of stuff now.
        if (GetDDrawObject()  &&
            IsEqualObject(pDDObj, GetDDrawObject()))
        {
            DbgLog((LOG_TRACE, 5, TEXT("Same DDraw object is being used."))) ;
        }
        else  // new DDraw object
        {
            DbgLog((LOG_TRACE, 3, TEXT("DDraw object has changed. Pass it down..."))) ;
            SetDDrawObject(pDDObj) ;

            // Need to re-init the font caches for the new DDraw object and surface
            SetFontUpdate(true) ;
        }

        // Now let go of all the interfaces
        pDDObj->Release() ;
    }

    // Save the new DDraw surface pointer
    m_bNewOutBuffer = m_lpDDSOutput != lpDDSurf ;  // has it changed?
    m_lpDDSOutput = lpDDSurf ;

    // In case the font cache needs to be updated, do it now.
    if (! IsFontReady() )
    {
        bResult = InitFont() ;
        ASSERT(bResult  &&  TEXT("SetDDrawSurface(): InitFont() failed.")) ;
    }

    return bResult ;
}


void CLine21DecDraw::ChangeFont(DWORD dwTextColor, BOOL bItalic, BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::ChangeFont(%lu, %s, %s)"),
        dwTextColor, bItalic ? TEXT("T") : TEXT("F"), bUnderline ? TEXT("T") : TEXT("F"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // If the current font style & color and the new font style & color happen
    // to be the same, just ignore this one and return.
    //
    if (m_bFontItalic == bItalic  &&  m_bFontUnderline == bUnderline  &&
        m_dwTextColor == dwTextColor)
        return ;  // don't have to do anything at all

    //
    // For Italic chars we Blt the char rect from 2 pixels to the right,
    // but for normal chars we don't do that.
    //
    if (bItalic)
        m_iPixelOffset = 1 ;
    else
        m_iPixelOffset = 0 ;

    // Update the current font color and style info -- will revert on problem
    m_dwTextColor    = dwTextColor ;
    m_bFontItalic    = bItalic ;
    m_bFontUnderline = bUnderline ;

    //
    // If the text color is white and the font style is not underlined, we'll
    // just point to the normal or Italic font cache as appropriate.
    //
    if (!bUnderline  &&  AM_L21_FGCOLOR_WHITE == dwTextColor)
    {
        if (bItalic) // need Italic style
        {
            m_lpBltList = m_lpDDSItalicFontCache ;
        }
        else        // need normal style
        {
            m_lpBltList = m_lpDDSNormalFontCache ;
        }
        return ;
    }

    //
    // Looks like we need a non-white text color and/or underlined style.  For
    // that we have to create the special font cache and point to that.
    //
    if (m_lpDDSSpecialFontCache)
    {
        m_lpDDSSpecialFontCache->Release() ;
        m_lpDDSSpecialFontCache = NULL ;
    }
    DWORD  dwBGColor  = 0xFF000000 ; // m_dwBackground ;
    DWORD  dwOpacity = m_bOpaque ? OPAQUE : 0 ;
    bool   bResult = true ;
    if (NULL == m_lpDDSScratch)  // if no scratch surface, create it now
    {
        ASSERT(!TEXT("No scratch font cache!!")) ;
        bResult &= CreateScratchFontCache(&m_lpDDSScratch) ;
        ASSERT(bResult) ;
    }

    bResult &= CreateFontCache(&m_lpDDSSpecialFontCache, dwTextColor, dwBGColor,
                               dwOpacity, bItalic, bUnderline) ;
    if (bResult)
    {
        m_lpBltList = m_lpDDSSpecialFontCache ;
    }
    else  // if we can't create any special font, we fallback to normal white
    {
        DbgLog((LOG_TRACE, 1,
                TEXT("Failed creating special font (ColorId=%d, , , %s, %s). Using normal font."),
                dwTextColor, bItalic ? TEXT("I") : TEXT("non-I"),
                bUnderline ? TEXT("U") : TEXT("non-U"))) ;
        m_lpBltList = m_lpDDSNormalFontCache ;

        // Due to some problem, we are still using the white normal font
        m_dwTextColor    = AM_L21_FGCOLOR_WHITE ;
        m_bFontItalic    = FALSE ;
        m_bFontUnderline = FALSE ;
    }
}


void CLine21DecDraw::GetSrcNDestRects(int iLine, int iCol, UINT16 wChar,
                                      int iSrcCrop, int iDestOffset,
                                      RECT *prectSrc, RECT *prectDest)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetSrcNDestRects(%d,%d,,,,,)"),
            iLine, iCol)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // if (m_bOpaque)  // opaque the next char's position
    {
        prectDest->left   = (iCol+1) * m_iCharWidth + m_iHorzOffset ;
        prectDest->right  = prectDest->left + m_iCharWidth ;
        // Row numbers are from 1 to 15.  The rect top should start from top of
        // a row's rect.  That's why we subtract 1 from the row number below.
        prectDest->top    = (iLine-1) * m_iCharHeight + m_iVertOffset + iDestOffset ; // fix dest top
        prectDest->bottom = prectDest->top + m_iCharHeight - ABS(iSrcCrop) ;      // fix dest size
    }

    MapCharToRect(wChar, prectSrc) ;

    // Adjust Src rect: +ve iSrcCrop => skip the top part; -ve iSrcCrop => skip the bottom
    if (iSrcCrop < 0)        // crop out bottom part of Src rect
    {
        prectSrc->bottom += iSrcCrop ;  // adding a -ve reduces the bottom
    }
    else  if (iSrcCrop > 0)  // crop out top part of Src rect
    {
        prectSrc->top += iSrcCrop ;     // adding a +ve skips the top
    }
    // Otherwise no rect adjustment is needed
}


void CLine21DecDraw::DrawLeadingTrailingSpace(int iLine, int iCol, int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::DrawLeadingTrailingSpace(%d, %d, %d, %d)"),
            iLine, iCol, iSrcCrop, iDestOffset)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    if (! m_bOpaque )  // doesn't matter for transparent background
        return ;

    UINT16  wActual ;
    UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;

    wActual = MAKECCCHAR(0, ' ') ;   // use space

    // Leading space is drawn using a blank space with normal style
    ChangeFont(AM_L21_FGCOLOR_WHITE, FALSE, FALSE) ;

    // Get appropriate source and destination rectangles
    RECT    RectSrc ;
    RECT    RectDest ;
    GetSrcNDestRects(iLine, iCol, wActual, iSrcCrop, iDestOffset, &RectSrc, &RectDest) ;

    // Now Blt the src rect to the dest rect for the required char
    HRESULT hr = m_lpDDSOutput->Blt(&RectDest, m_lpBltList, &RectSrc, DDBLT_WAIT, NULL) ;
    if (SUCCEEDED(hr))
    {
        m_bOutputClear   = FALSE ; // output buffer is cleared by ClearOutputBuffer()
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("WARNING: CC lead/trail space output failed (Blt() Error 0x%lx)"), hr)) ;
    }

    // Now restore prev font (color, italics, underline)
    ChangeFont(m_ccLast.GetColor(), m_ccLast.IsItalicized(), m_ccLast.IsUnderLined()) ;
}


void CLine21DecDraw::WriteChar(int iLine, int iCol, CCaptionChar& cc, int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::WriteChar(%d, %d, char=0x%x, %d, %d)"),
            iLine, iCol, cc.GetChar(), iSrcCrop, iDestOffset)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    UINT16  wActual ;
    UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;
    UINT    uColor = cc.GetColor() ;
    UINT    uEffect = cc.GetEffect() ;

    // Do we need some status checks tp make sure that we should output CC chars?

    if (cc.IsMidRowCode())  // if it's a mid row code
        wActual = MAKECCCHAR(0, ' ') ;   // use space
    else                    // otherwise
        wActual = cc.GetChar() ; // use the char itself
    if (0 == wActual)   // this one is supposed to be skipped -- I am not sure
    {
        DbgLog((LOG_TRACE, 3, TEXT("Should we skip NULL char at (%d, %d)??"), iLine, iCol)) ;
        // return ;
    }

    // In case the color or style has changed, we have to change the pointer to
    // the font cache, and may have to even build a new one (for non-white colors)
    if (uColor != m_ccLast.GetColor()  ||  uEffect != m_ccLast.GetEffect())
        ChangeFont(uColor, cc.IsItalicized(), cc.IsUnderLined()) ;

    // Get appropriate source and destination rectangles
    RECT    RectSrc ;
    RECT    RectDest ;
    GetSrcNDestRects(iLine, iCol, wActual, iSrcCrop, iDestOffset, &RectSrc, &RectDest) ;

    // Now Blt the src rect to the dest rect for the required char
    HRESULT hr = m_lpDDSOutput->Blt(&RectDest, m_lpBltList, &RectSrc, DDBLT_WAIT, NULL) ;
    if (SUCCEEDED(hr))
    {
        if (0 != wActual)  // if this char is non-null
        {
            m_bOutputClear   = FALSE ; // output buffer is cleared by ClearOutputBuffer()
        }
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: CC char output failed (Blt() Error 0x%lx)"), hr)) ;
    }

    m_ccLast = cc ;
}


void CLine21DecDraw::WriteBlankCharRepeat(int iLine, int iCol, int iRepeat,
                                          int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::WriteBlankCharRepeat(%d,%d,%d,%d,%d)"),
            iLine, iCol, iRepeat, iSrcCrop, iDestOffset)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    if (! m_bOpaque )  // doesn't matter for transparent background
        return ;

    UINT16  wActual = MAKECCCHAR(0, ' ') ;   // use space;
    // UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;

    // Leading space is drawn using a blank space with normal style
    // ChangeFont(AM_L21_FGCOLOR_WHITE, FALSE, FALSE) ;

    // Get appropriate source and destination rectangles
    RECT    RectSrc ;
    RECT    RectDest ;
    GetSrcNDestRects(iLine, iCol, wActual, iSrcCrop, iDestOffset, &RectSrc, &RectDest) ;
    RectDest.right = RectDest.left + m_iCharWidth * iRepeat ; // stretch Dest rect

    // Now Blt the src rect to the dest rect for the required char
    HRESULT  hr ;
    hr = m_lpDDSOutput->Blt(&RectDest, m_lpBltList, &RectSrc, DDBLT_WAIT, NULL) ;
    if (SUCCEEDED(hr))
    {
        m_bOutputClear = FALSE ; // output buffer is cleared by ClearOutputBuffer()
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("WARNING: CC line filler output failed (Blt() Error 0x%lx)"), hr)) ;
        // ASSERT(SUCCEEDED(hr)) ;
    }

    // Now restore prev font (color, italics, underline)
    // ChangeFont(m_ccLast.GetColor(), m_ccLast.IsItalicized(), m_ccLast.IsUnderLined()) ;
}


// Special Chars like TM, R, musical note etc. etc.
// 0x00ae,    0x00b0,    0x00bd,    0x00bf,    0x2122,    0x00a2,    0x00a3,    0x266b,
//    30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
// 0x00e0,    0x0000,    0x00e8,    0x00e2,    0x00ea,    0x00ee,    0x00f4,    0x00fb
//    38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh

void CLine21DecDraw::MapCharToRect(UINT16 wChar, RECT *pRect)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::MapCharToRect(%d, %lx)"), (int)wChar, pRect)) ;

    int  iLine ;
    int  iCol ;
    int  iIndex = 0 ;

    if (wChar >= MAKECCCHAR(0, 0x20)  &&  wChar <= MAKECCCHAR(0, 0x29))
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else if (wChar >= MAKECCCHAR(0, 0x2B)  &&  wChar <= MAKECCCHAR(0, 0x5B))
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else if (wChar == MAKECCCHAR(0, 0x5D))  // ']' char (standing alone!!)
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else if (wChar >= MAKECCCHAR(0, 0x61)  &&  wChar <= MAKECCCHAR(0, 0x7A))
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else  // special chars that have random values
    {
        switch (wChar)
        {
        case 0x00e1:  // m_lpwCharSet[ 10]: 'a' with acute accent
            iIndex = 10 ;
            break ;

        case 0x00e9:  // m_lpwCharSet[ 60]: 'e' with acute accent
            iIndex = 60 ;
            break ;

        case 0x00ed:  // m_lpwCharSet[ 62]: 'i' with an acute accent
            iIndex = 62 ;
            break ;

        case 0x00f3:  // m_lpwCharSet[ 63]: 'o' with an acute accent
            iIndex = 63 ;
            break ;

        case 0x00fa:  // m_lpwCharSet[ 64]: 'u' with an acute accent
            iIndex = 64 ;
            break ;

        case 0x00e7:  // m_lpwCharSet[ 91]: 'c' with cedilla
            iIndex = 91 ;
            break ;

        case 0x00f7:  // m_lpwCharSet[ 92]: division sign
            iIndex = 92 ;
            break ;

        case 0x00d1:  // m_lpwCharSet[ 93]: 'N' with tilde
            iIndex = 93 ;
            break ;

        case 0x00f1:  // m_lpwCharSet[ 94]: 'n' with tilde
            iIndex = 94 ;
            break ;

        case 0x2588:  // m_lpwCharSet[ 95]: solid block
            iIndex = 95 ;
            break ;

        case 0x00ae:  // m_lpwCharSet[ 96]: 30h -- registered mark symbol
            iIndex = 96 ;
            break ;

        case 0x00b0:  // m_lpwCharSet[ 97]: 31h -- degree sign
            iIndex = 97 ;
            break ;

        case 0x00bd:  // m_lpwCharSet[ 98]: 32h -- '1/2'
            iIndex = 98 ;
            break ;

        case 0x00bf:  // m_lpwCharSet[ 99]: 33h -- inverse query
            iIndex = 99 ;
            break ;

        case 0x2122:  // m_lpwCharSet[100]: 34h -- trademark symbol
            iIndex = 100 ;
            break ;

        case 0x00a2:  // m_lpwCharSet[101]: 35h -- cents sign
            iIndex = 101 ;
            break ;

        case 0x00a3:  // m_lpwCharSet[102]: 36h -- Pounds Sterling sign
            iIndex = 102 ;
            break ;

        case 0x266b:  // m_lpwCharSet[103]: 37h -- music note
            iIndex = 103 ;
            break ;

        case 0x00e0:  // m_lpwCharSet[104]: 38h -- 'a' with grave accent
            iIndex = 104 ;
            break ;

        case 0x0000:  // m_lpwCharSet[105]: 39h -- transparent space
            iIndex = 105 ;
            break ;

        case 0x00e8:  // m_lpwCharSet[106]: 3ah -- 'e' with grave accent
            iIndex = 106 ;
            break ;

        case 0x00e2:  // m_lpwCharSet[107]: 3bh -- 'a' with circumflex
            iIndex = 107 ;
            break ;

        case 0x00ea:  // m_lpwCharSet[108]: 3ch -- 'e' with circumflex
            iIndex = 108 ;
            break ;

        case 0x00ee:  // m_lpwCharSet[109]: 3dh -- 'i' with circumflex
            iIndex = 109 ;
            break ;

        case 0x00f4:  // m_lpwCharSet[110]: 3eh -- 'o' with circumflex
            iIndex = 110 ;
            break ;

        case 0x00fb:  // m_lpwCharSet[111]: 3fh -- 'u' with circumflex
            iIndex = 111 ;
            break ;

        default:
            iIndex = 0 ;
            DbgLog((LOG_TRACE, 1, TEXT("WARNING: Unknown char (%d) received and ignored"), (int)wChar)) ;
            break ;
        }  // end of switch (wChar)
    }  // end of else of if (wChar...)

    // Now convert iIndex to (iLine, iCol) pair
    iLine = iIndex / FONTCACHELINELENGTH ;  // line of cache based on array index
    iCol  = iIndex % FONTCACHELINELENGTH ;  // actual col of a particular line of cache

    // Create source rect based on line and col values
    // HACK: There is a little bit of hack to work around the over/underhang
    // problem we were having for the Italic chars -- we skip one column of
    // pixels from the left (based on our observation) to avoid the overhang
    // occurance.
    pRect->left   = iCol * (m_iCharWidth + INTERCHAR_SPACE) + m_iPixelOffset ;
    pRect->top    = iLine * m_iCharHeight ;
    pRect->right  = pRect->left + m_iCharWidth ;
    pRect->bottom = pRect->top + m_iCharHeight ;
}


void CLine21DecDraw::GetOutputLines(int iDestLine, RECT *prectLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetOutputLines(%d, 0x%lx)"), iDestLine, prectLine)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (IsBadWritePtr(prectLine, sizeof(*prectLine)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: prectOut is a bad pointer!!!"))) ;
        return ;
    }

    SetRect(prectLine, 0 /* m_iHorzOffset */, 0,   // to stop BPC's CC wobbling
        m_iHorzOffset + m_iCharWidth * (MAX_CAPTION_COLUMNS+2), 0) ;

    // Output is inverted in Windows bitmap sense
    int  iLineStart ;
    iLineStart = (iDestLine - 1) * m_iCharHeight + m_iVertOffset ;
    prectLine->top    = iLineStart ;
    prectLine->bottom = iLineStart + m_iCharHeight ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\lin21dec2\l21decod.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21Decod.h: Line 21 Decoder engine base class code
//

#ifndef _INC_L21DECOD_H
#define _INC_L21DECOD_H


//
//  Forward declarations
//
class CLine21DataDecoder ;


//
//  Input data type ID (rather than GUID) for internal functioning
//
typedef enum _AM_LINE21_CCSUBTYPEID {
    AM_L21_CCSUBTYPEID_Invalid = 0,
    AM_L21_CCSUBTYPEID_BytePair,
    AM_L21_CCSUBTYPEID_GOPPacket,
    AM_L21_CCSUBTYPEID_VBIRawData
} AM_LINE21_CCSUBTYPEID, *PAM_LINE21_CCSUBTYPEID ;

//
//  A set of values indicating what type of control code was received
//
#define L21_CONTROLCODE_INVALID     0
#define L21_CONTROLCODE_PAC         1
#define L21_CONTROLCODE_MIDROW      2
#define L21_CONTROLCODE_MISCCONTROL 3


//
//  CLine21DataDecoder: class for decoding from byte pair and output to bitmap
//
class CLine21DataDecoder {
public:  // public methods for CLine21Filter to call
    CLine21DataDecoder::CLine21DataDecoder(
                            AM_LINE21_CCSTYLE eStyle = AM_L21_CCSTYLE_None,
                            AM_LINE21_CCSTATE eState = AM_L21_CCSTATE_Off,
                            AM_LINE21_CCSERVICE eService = AM_L21_CCSERVICE_None) ;
    ~CLine21DataDecoder(void) ;

    void InitState(void) ;
    BOOL InitCaptionBuffer(void) ;  // all buffers
    BOOL InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle) ; // only needed buffer(s)
    BOOL DecodeBytePair(BYTE chFirst, BYTE chSecond) ;
    BOOL UpdateCaptionOutput(void) ;
    bool OutputCCLine(int iLine, int iDestRow, int iSrcCrop, int iDestOffset) ;
    bool OutputCCBuffer(void) ;
    bool OutputBlankCCLine(int iLine, int iDestRow, int iSrcCrop, int iDestOffset) ;
    void CompleteScrolling(void) ;
    inline AM_LINE21_CCSTYLE GetCaptionStyle()   { return m_eCCStyle ; } ;
    AM_LINE21_CCSTYLE SetCaptionStyle(AM_LINE21_CCSTYLE eStyle) ;
    inline BOOL IsScrolling(void)   { return m_bScrolling ; } ;
    void FlushInternalStates(void) ;
    inline BOOL IsOutDIBClear(void) {
       return m_L21DDraw.IsOutDIBClear() ;
    } ;
    inline BOOL IsNewOutBuffer(void) {
       return m_L21DDraw.IsNewOutBuffer() ;
    }
    
    // inline BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) {
    //     return m_L21DDraw.IsSizeOK(lpbmih) ;
    // } ;

    // methods to allow the filter to do get/set using the 
    // IAMLine21Decoder interface
    inline AM_LINE21_CCLEVEL GetDecoderLevel(void)    { return m_eLevel ; } ;
    inline AM_LINE21_CCSERVICE GetCurrentService(void)  { return m_eUserService ; } ;
    BOOL SetCurrentService(AM_LINE21_CCSERVICE Service) ; 
    inline AM_LINE21_CCSTATE GetServiceState(void)    { return m_eState ; } ;
    BOOL SetServiceState(AM_LINE21_CCSTATE eState) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.GetDefaultFormatInfo(lpbmi, pdwSize) ;
    } ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.GetOutputFormat(lpbmih) ;
    } ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.GetOutputOutFormat(lpbmih) ;
    } ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.SetOutputOutFormat(lpbmi) ;
    } ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.SetOutputInFormat(lpbmi) ;
    } ;
    inline void GetBackgroundColor(DWORD *pdwBGColor) { 
        m_L21DDraw.GetBackgroundColor(pdwBGColor) ;
    } ;
    inline BOOL SetBackgroundColor(DWORD dwBGColor) {
        return m_L21DDraw.SetBackgroundColor(dwBGColor) ;
    } ;

    inline BOOL GetRedrawAlways() { return m_bRedrawAlways ; } ;
    inline void SetRedrawAlways(BOOL Option) { m_bRedrawAlways = !!Option ; } ;

    inline AM_LINE21_DRAWBGMODE GetDrawBackgroundMode(void) { 
        return (m_L21DDraw.GetBackgroundOpaque() ?
                AM_L21_DRAWBGMODE_Opaque : AM_L21_DRAWBGMODE_Transparent) ;
    } ;
    inline void SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) { 
        m_L21DDraw.SetBackgroundOpaque(AM_L21_DRAWBGMODE_Opaque == Mode) ;
    } ;
    
    // methods to pass values between the CLine21DecFilter class and CGDIWork class
    // some general methods to communicate with the container class
    IUnknown* GetDDrawObject(void){
        return m_L21DDraw.GetDDrawObject() ;
    } ;
    bool SetDDrawSurface(LPDIRECTDRAWSURFACE7 lpDDS) {
        return m_L21DDraw.SetDDrawSurface(lpDDS) ;
    } ;
    inline void FillOutputBuffer(void) {
        m_L21DDraw.FillOutputBuffer() ;
    } ;
    inline void InitColorNLastChar(void) {
        m_L21DDraw.InitColorNLastChar() ;
    } ;
    
private:   // private helper methods
    //
    //  The following methods are for implementing the actual decoding
    //  algorithm.
    //
    BOOL IsMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsPAC(BYTE chFirst, BYTE chSecond) ;
    BOOL IsMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    UINT CheckControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL ValidParity(BYTE ch) ;
    BOOL IsStandardChar(BYTE ch)  { return (ch >= 0x20 && ch <= 0x7F) ; } ;
    BOOL ProcessControlCode(UINT uCodeType, BYTE chFirst, BYTE chSecond) ;
    BOOL DecodePAC(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL LineFromRow(UINT uCurrRow) ;
    BOOL ProcessPrintableChar(BYTE ch) ;
    BOOL ProcessSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRCL(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleBS(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleDER(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRU(BYTE chFirst, BYTE chSecond, int iLines) ;
    BOOL HandleFON(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRDC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRTD(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEDM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleCR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleENM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEOC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTO(BYTE chFirst, BYTE chSecond, int iCols) ;
    
    void SetNewLinePosition(int iLines, UINT uCurrRow) ;
    BOOL PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode = FALSE) ; // put char in buffer (& MRC too)
    BOOL IsEmptyLine(int iLine) ;   // Is the line empty (no non-Xparent chars)?
    BOOL RemoveCharsInBuffer(int iNumChars) ;  // removes n chars to the right of current col
    
    //
    //  The following methods are defined to bring uniformity in coding of
    //  the algorithm irrespective of any caption style being used.
    //
    CCaptionBuffer * GetDispBuffer(void) ;    // display buffer: mainly for Pop-On style
    void ClearBuffer(void) ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    void GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc) ;
    CCaptionChar * GetCaptionCharPtr(UINT8 uLine, UINT8 uCol) ;
    void SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                        const CCaptionChar& cc) ;
    int  GetMaxLines(void) ;
    void SetMaxLines(UINT uLines) ;
    int  GetNumLines(void) ;
    void SetNumLines(UINT uLines) ;
    int  GetNumCols(int iLines) ;
    int  GetRow(UINT uLine) ;
    int  GetCurrLine(void) ;
    int  GetCurrCol(void) ;
    void SetCurrLine(UINT8 uLine) ;
    void SetCurrCol(UINT8 uCol) ;
    int  GetStartRow(UINT8 uLine) ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetStartRow(UINT8 uLine, UINT8 uRow) ;
    void SetRowIndex(UINT8 uLine, UINT8 uRow) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    int  IncNumChars(UINT uLine, UINT uNumChars) ;
    int  DecNumChars(UINT uLine, UINT uNumChars) ;
    int  IncNumLines(UINT uLines) ;
    int  DecNumLines(UINT uLines) ;
    void MoveCaptionChars(int uLine, int iNum) ;
    
    BOOL IsCapBufferDirty(void) ;
    BOOL IsRedrawLine(UINT8 uLine) ;
    BOOL IsRedrawAll(void) ;
    void SetCapBufferDirty(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    
    void SetScrollState(BOOL bState) ;
    int  IncScrollStartLine(int iCharHeight) ;
    void SkipScrolling(void) ;   // CR came while scrolling; skip current one
    void MoveCaptionLinesUp(void) ;  // remove top line, move other lines up
    void RelocateRollUp(UINT uBaseRow) ; // move roll-up caption to given base row

    //
    //  Common buffers used for all CC modes
    //
    CCaptionBuffer * GetCaptionBuffer(void) ;
    CCaptionBuffer * GetDisplayBuffer(void) ;
    inline int  GetBufferIndex(void)  { return m_iBuffIndex ; } ;
    inline void SetBufferIndex(int iIndex) ;
    inline void SwapBuffers(void)  { m_iBuffIndex = 1 - m_iBuffIndex ; } ;
    
private:  // private data
    CCritSec            m_csL21Dec ;   // to serialize operations on line21 decoder object

    CCaptionBuffer *    m_pCurrBuff ;
    
    // Actual caption buffer with text and attribs/positions/banks etc
    CCaptionBuffer      m_aCCData[2] ;
    int                 m_iBuffIndex ; // index for current CC data buffer
    
    CLine21DecDraw      m_L21DDraw ;   // Drawing details class as a member

    UINT                m_uFieldNum ;  // Field number: 1 or 2 (top/bottom)
    
    // What style caption is being displayed now and was used last
    AM_LINE21_CCSTYLE   m_eCCStyle ;
    AM_LINE21_CCSTYLE   m_eLastCCStyle ;
    
    // Is Line 21 decoding On/Off
    AM_LINE21_CCSTATE   m_eState ;
    
    // Which service is currently being viewed by the user
    AM_LINE21_CCSERVICE m_eUserService ;  // one of C1/C2/T1/T2/XDS
    
    // Decoder is standard or enhanced
    AM_LINE21_CCLEVEL   m_eLevel ;
    
    //
    //  Some internal states during decoding
    //
    AM_LINE21_CCSERVICE m_eDataService ; // service indicated by received bytes
    UINT                m_uCurrFGEffect ;  // FG effect of current position
    UINT                m_uCurrFGColor ;   // FG color of current position
    
    BOOL                m_bExpectRepeat ;  // should we expect a repeat of last pair?
    BYTE                m_chLastByte1 ;    // the 1st second byte processed
    BYTE                m_chLastByte2 ;    // the 2nd second byte processed
    
    BOOL                m_bScrolling ;     // are we in the middle of scrolling up?
    int                 m_iScrollStartLine ; // current scan line to be scrolled off
    
    BOOL                m_bRedrawAlways ;  // client wants a total redraw per sample

#ifdef PERF
    int          m_idTxt2Bmp ;
    int          m_idBmp2Out ;
    int          m_idScroll ;
#endif // PERF
} ;


//
//  Some misc. constant definitions
//
#define INVALID_CHANNEL     -1

//
//  Some macros to hide some gory details
//
#define ISSUBTYPEVALID(ID) (AM_L21_CCSUBTYPEID_BytePair   == ID || \
                            AM_L21_CCSUBTYPEID_GOPPacket  == ID || \
                            AM_L21_CCSUBTYPEID_VBIRawData == ID)

#endif _INC_L21DECOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\inc\dssenum.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef DSSENUM_H
#define DSSENUM_H
// DSSENUM.H

// STOCKBPCEVENT enumeration has been removed.  The allowable values
//  of events fired to the CA Server are those defined as constants
//  in the "CAEvent Interface" section of CAODL.H.

// Upper edge purchase actions

    typedef enum PURCHASEACTION {
        PAGETDETAILS,
        PAPURCHASETOVIEW,
        PAPURCHASETOTAPE,
        PACANCELVIEW,
        PACANCELTAPE,
        PAPREVIEW,
        PAGETEXTENDEDINFO
    } PURCHASEACTION;

// note that the bit mapping used here allows, for DSS, the direct conversion
// of lower edge status into upper edge status.
    typedef enum PURCHASESTATUS {
        PSVIEWTAKEN = 0,
        PSVIEWCANCELLED,
        PSVIEWREPORTED,
        PSPREVIEWTAKEN,

        PSVIEWAUTHORIZED,
        PSVIEWPURCHASED,
        PSTAPEPURCHASED,
        PSTAPEAUTHORIZED,

        PSTAPETAKEN,
        PSTAPECANCELLED,
        PSTAPEREPORTED,
        PSVIEWAVAILABLE,

        PSTAPEAVAILABLE,
        PSREVIEWAVAILABLE
    } PURCHASESTATUS;

// Reason values returned in BPCDetails when purchase actions are
//  attempted.
    typedef enum PURCHASEREASON {
        PRSUCCESS = 0,
        PRNOCALLBACK,
        PRNOSUBSCRIBER,
        PRRATING,
        PRSPENDING,
        PRCREDIT,
        PRWRONGCARD,
        PRCARDFULL,
        PRBLOCKED,
        PRBLACKOUT,
        PRTOOLATE,
        PRREDUNDANT,
        PRPPVFAILURE,
        PRBADDATA,
        PRCONTENTION,
		PRNOCARD,
		PRNOPIP
    } PURCHASEREASON;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\inc\ovmixpos2.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __OVMIXPOS2__
#define __OVMIXPOS2__

#include <ovmixpos.h>

// {4EC741E2-BFAE-11d2-8856-0000F80883E3}
DEFINE_GUID(IID_IAMOverlayMixerPosition2, 
0x4ec741e2, 0xbfae, 0x11d2, 0x88, 0x56, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_INTERFACE_(IAMOverlayMixerPosition2, IAMOverlayMixerPosition)
{
    
    STDMETHOD (GetOverlayRects)(THIS_ 
        OUT RECT *src, OUT RECT* dest					      
        ) PURE;

    STDMETHOD (GetVideoPortRects)(THIS_ 
        OUT RECT *src, OUT RECT* dest					      
        ) PURE;

    STDMETHOD (GetBasicVideoRects)(THIS_ 
        OUT RECT *src, OUT RECT* dest					      
        ) PURE;

};


#ifdef __cplusplus
}
#endif


#endif // #define
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\inc\mpconfig3.h ===
//==========================================================================;
//
//  Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __IMPConfig3__
#define __IMPConfig3__

#include <mpconfig.h>

// {CC2E5332-CCF8-11d2-8853-0000F80883E3}
DEFINE_GUID(IID_IMixerPinConfig3, 
0xcc2e5332, 0xccf8, 0x11d2, 0x88, 0x53, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

// {ED7DA472-C083-11d2-8856-0000F80883E3}
DEFINE_GUID(IID_IEnumPinConfig, 
0xed7da472, 0xc083, 0x11d2, 0x88, 0x56, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_INTERFACE_(IMixerPinConfig3, IMixerPinConfig2)
{
    
    STDMETHOD (GetRenderTransport)(THIS_ 
        OUT AM_RENDER_TRANSPORT *pamRenderTransport					      
        ) PURE;
};

DECLARE_INTERFACE_(IEnumPinConfig, IUnknown)
{
    
    STDMETHOD (Next)(THIS_ 
        OUT IMixerPinConfig3 **pPinConfig					      
        ) PURE;
};


#ifdef __cplusplus
}
#endif


#endif // #define __IMPConfig__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ocx\resource.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VRCtl.rc
//
#define IDS_PROJNAME                    100
#define IDR_VIDEORENDERCTL              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ocx\stdafx.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "stdafx.h"
#ifdef FILTER_DLL


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\inc\vpinfo.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __VP_INFO__
#define __VP_INFO__

// enum to specify, where we are going to do the cropping
typedef enum _AMVP_CROP_STATE
{	
    AMVP_NO_CROP,
    AMVP_CROP_AT_VIDEOPORT,
    AMVP_CROP_AT_OVERLAY
} AMVP_CROP_STATE;

// enum to specify, whether the videoport is in a stopped or running state
typedef enum _AMVP_STATE
{	
    AMVP_VIDEO_STOPPED,
    AMVP_VIDEO_RUNNING
} AMVP_STATE;

typedef enum _AM_TRANSFORM
{
    AM_SHRINK,
    AM_STRETCH
} AM_TRANSFORM;

typedef enum _AM_RENDER_TRANSPORT
{
    AM_OFFSCREEN,
    AM_OVERLAY,
    AM_GDI,
    AM_VIDEOPORT,
    AM_IOVERLAY,
    AM_VIDEOACCELERATOR
} AM_RENDER_TRANSPORT;

typedef struct _DRECT
{
    double left;
    double top;
    double right;
    double bottom;
} DRECT, *LPDRECT;

#ifndef DDVPCAPS_VBIANDVIDEOINDEPENDENT
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l	// Indicates that the VBI and video  can  be controlled by an independent processes.
#endif


// {E37786D2-B5B0-11d2-8854-0000F80883E3}
DEFINE_GUID(IID_IVPInfo,
0xe37786d2, 0xb5b0, 0x11d2, 0x88, 0x54, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

DECLARE_INTERFACE_(IVPInfo, IUnknown)
{
    STDMETHOD (GetRectangles)(THIS_
               RECT *prcSource, RECT *prcDest
               ) PURE;
    STDMETHOD (GetCropState)(THIS_
	       AMVP_CROP_STATE* pCropState
	       ) PURE;
    STDMETHOD (GetPixelsPerSecond)(THIS_
	       DWORD* pPixelPerSec
	       ) PURE;
    STDMETHOD (GetVPDataInfo)(THIS_
               AMVPDATAINFO* pVPDataInfo
               ) PURE;
    STDMETHOD (GetVPInfo)(THIS_
               DDVIDEOPORTINFO* pVPInfo
               ) PURE;
    STDMETHOD (GetVPBandwidth)(THIS_
               DDVIDEOPORTBANDWIDTH* pVPBandwidth
               ) PURE;
    STDMETHOD (GetVPCaps)(THIS_
               DDVIDEOPORTCAPS* pVPCaps
               ) PURE;
    STDMETHOD (GetVPInputFormat)(THIS_
               LPDDPIXELFORMAT* pVPFormat
               ) PURE;
    STDMETHOD (GetVPOutputFormat)(THIS_
               LPDDPIXELFORMAT* pVPFormat
               ) PURE;
};


#if defined(CCHDEVICENAME)
#define AMCCHDEVICENAME CCHDEVICENAME
#else
#define AMCCHDEVICENAME 32
#endif
#define AMCCHDEVICEDESCRIPTION  256

#define AMDDRAWMONITORINFO_PRIMARY_MONITOR          0x0001
typedef struct {
    GUID*       lpGUID; // is NULL if the default DDraw device
    GUID        GUID;   // otherwise points to this GUID
} AMDDRAWGUID;


typedef struct {
    AMDDRAWGUID guid;
    RECT        rcMonitor;
    HMONITOR    hMon;
    DWORD       dwFlags;
    char        szDevice[AMCCHDEVICENAME];
    char        szDescription[AMCCHDEVICEDESCRIPTION];
    DDCAPS      ddHWCaps;
} AMDDRAWMONITORINFO;

// {c5265dba-3de3-4919-940b-5ac661c82ef4}
DEFINE_GUID(IID_IAMSpecifyDDrawConnectionDevice,
0xc5265dba, 0x3de3,0x4919, 0x94, 0x0b, 0x5a, 0xc6, 0x61, 0xc8, 0x2e, 0xf4);

DECLARE_INTERFACE_(IAMSpecifyDDrawConnectionDevice, IUnknown)
{
    // Use this method on a Multi-Monitor system to specify to the overlay
    // mixer filter which Direct Draw driver should be used when connecting
    // to an upstream decoder filter.
    //
    STDMETHOD (SetDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method to determine the direct draw object that will be used when
    // connecting the overlay mixer filter to an upstream decoder filter.
    //
    STDMETHOD (GetDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to specify to the
    // overlay mixer filter the default Direct Draw device to use when
    // connecting to an upstream filter.  The default direct draw device
    // can be overriden for a particular connection by SetDDrawGUID method
    // described above.
    //
    STDMETHOD (SetDefaultDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to determine which
    // is the default direct draw device the overlay mixer filter
    // will  use when connecting to an upstream filter.
    //
    STDMETHOD (GetDefaultDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;


    // Use this method to get a list of Direct Draw device GUIDs and thier
    // associated monitor information that the overlay mixer can use when
    // connecting to an upstream decoder filter.
    //
    // The method allocates and returns an array of AMDDRAWMONITORINFO
    // structures, the caller of function is responsible for freeing this
    // memory when it is no longer needed via CoTaskMemFree.
    //
    STDMETHOD (GetDDrawGUIDs)(THIS_
        /* [out] */ LPDWORD lpdwNumDevices,
        /* [out] */ AMDDRAWMONITORINFO** lplpInfo
        ) PURE;
};


typedef struct {
    long    lHeight;       // in pels
    long    lWidth;        // in pels
    long    lBitsPerPel;   // Usually 16 but could be 12 for the YV12 format
    long    lAspectX;      // X aspect ratio
    long    lAspectY;      // Y aspect ratio
    long    lStride;       // stride in bytes
    DWORD   dwFourCC;      // YUV type code ie. 'YUY2', 'YV12' etc
    DWORD   dwFlags;       // Flag used to further describe the image
    DWORD   dwImageSize;   // Size of the bImage array in bytes, which follows this
                           // data structure

//  BYTE    bImage[dwImageSize];

} YUV_IMAGE;

#define DM_BOTTOMUP_IMAGE   0x00001
#define DM_TOPDOWN_IMAGE    0x00002
#define DM_FIELD_IMAGE      0x00004
#define DM_FRAME_IMAGE      0x00008


DECLARE_INTERFACE_(IDDrawNonExclModeVideo , IDDrawExclModeVideo )
{
    //
    // Call this function to capture the current image being displayed
    // by the overlay mixer.  It is not always possible to capture the
    // current frame, for example MoComp may be in use.  Applications
    // should always call IsImageCaptureSupported (see below) before
    // calling this function.
    //
    STDMETHOD (GetCurrentImage)(THIS_
        /* [out] */ YUV_IMAGE** lplpImage
        ) PURE;

    STDMETHOD (IsImageCaptureSupported)(THIS_
        ) PURE;

    //
    // On a multi-monitor system, applications call this function when they
    // detect that the playback rectangle has moved to a different monitor.
    // This call has no effect on a single monitor system.
    //
    STDMETHOD (ChangeMonitor)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // When an application receives a WM_DISPLAYCHANGE message it should
    // call this function to allow the OVMixer to recreate DDraw surfaces
    // suitable for the new display mode.  The application itself must re-create
    // the new DDraw object and primary surface passed in the call.
    //
    STDMETHOD (DisplayModeChanged)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // Applications should continually check that the primary surface passed
    // to the OVMixer does not become "lost", ie. the user entered a Dos box or
    // pressed Alt-Ctrl-Del.  When "surface loss" is detected the application should
    // call this function so that the OVMixer can restore the surfaces used for
    // video playback.
    //
    STDMETHOD (RestoreSurfaces)(THIS_
        ) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ocx\rnderctl.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// RnderCtl.h : Declaration of the CVideoRenderCtl

#ifndef __RNDERCTL_H__
#define __RNDERCTL_H__

#include "resource.h"       // main symbols

// private mixer notifications, one message with ids
#define WM_MIXERNOTIFY WM_USER + 0x203
#define MIXER_NOTID_INVALIDATERECT 1
#define MIXER_NOTID_DATACHANGE 2
#define MIXER_NOTID_STATUSCHANGE 3

#ifndef FILTER_DLL
HRESULT CoCreateInstanceInternal(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
        DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

class CVideoRenderCtlStub : public CUnknown
{
public:
    DECLARE_IUNKNOWN
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    CVideoRenderCtlStub(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr);
    ~CVideoRenderCtlStub();
    STDMETHOD(NonDelegatingQueryInterface)(REFIID riid, void ** ppv);

private:
    IUnknown *m_punkVRCtl;
};

#endif

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl
class ATL_NO_VTABLE CVideoRenderCtl : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CVideoRenderCtl, &CLSID_VideoRenderCtl>,
        public CComControl<CVideoRenderCtl>,
        public IDispatchImpl<IVideoRenderCtl, &IID_IVideoRenderCtl, &LIBID_VRCTLLib>,
        public IProvideClassInfo2Impl<&CLSID_VideoRenderCtl, NULL, &LIBID_VRCTLLib>,
        public IPersistStreamInitImpl<CVideoRenderCtl>,
        public IPersistStorageImpl<CVideoRenderCtl>,
        public IQuickActivateImpl<CVideoRenderCtl>,
        public IOleControlImpl<CVideoRenderCtl>,
        public IOleObjectImpl<CVideoRenderCtl>,
        public IOleInPlaceActiveObjectImpl<CVideoRenderCtl>,
        public IViewObjectExImpl<CVideoRenderCtl>,
        public IOleInPlaceObjectWindowlessImpl<CVideoRenderCtl>,
        public IDataObjectImpl<CVideoRenderCtl>,
        public IConnectionPointContainerImpl<CVideoRenderCtl>,
        public ISpecifyPropertyPagesImpl<CVideoRenderCtl>,
        public IMixerOCXNotify
{
public:
    CVideoRenderCtl();
    ~CVideoRenderCtl();

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_REGISTRY_RESOURCEID(IDR_VIDEORENDERCTL)

    BEGIN_COM_MAP(CVideoRenderCtl)
	COM_INTERFACE_ENTRY(IVideoRenderCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
	COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
	COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY_IMPL(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        // private interface that the Renderer will query info on
        COM_INTERFACE_ENTRY(IMixerOCXNotify)
        // aggregated Video Renderer's interfaces
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IBaseFilter, m_punkVideoRenderer)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMediaSeeking, m_punkVideoRenderer)
    END_COM_MAP()

    CContainedWindow m_pwndMsgWindow;

    BEGIN_PROPERTY_MAP(CVideoRenderCtl)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()


    BEGIN_CONNECTION_POINT_MAP(CVideoRenderCtl)
    END_CONNECTION_POINT_MAP()


    BEGIN_MSG_MAP(CVideoRenderCtl)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    ALT_MSG_MAP(1)
        MESSAGE_HANDLER(WM_MIXERNOTIFY,   OnMixerNotify)
    END_MSG_MAP()

public:
// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

//IMixerOCXNotify

    // invalidates the rect
    STDMETHOD(OnInvalidateRect)(LPCRECT lpcRect);

    // informs that a status change has occured, new status bits provided in ulStatusFlags
    STDMETHOD(OnStatusChange)(ULONG ulStatusFlags);

    // informs that data parameters, whose id is present in ilDataFlags has changed
    STDMETHOD(OnDataChange)(ULONG ulDataFlags);

// IOleObject
    STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, 
            void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */,
            LOGPALETTE** /* ppColorSet */);

// IOleInPlaceObject
    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);

    // internal window message handlers
    LRESULT OnMixerNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

// ATL helper over-rides
    HRESULT OnDraw(ATL_DRAWINFO& di);
    HRESULT FinalConstruct();
    void FinalRelease();

private:
// helpers
    HRESULT GetContainerWnd(HWND *phwnd);
    HRESULT ValidateThreadOrNotify(DWORD dwMixerNotifyId, void *pvData);


// members
    IUnknown *m_punkVideoRenderer;
    IMixerOCX *m_pIMixerOCX;
    POINT m_ptTopLeftSC; // top - left cordinates of the control in screen cordinates


};

#endif //__RNDERCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ocx\vrctl.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// VRCtl.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#ifdef FILTER_DLL
#include "initguid.h"
#endif

#include "VRCtl.h"

#include "VRCtl_i.c"

#ifndef FILTER_DLL
#include <streams.h>
#endif 

#include "RnderCtl.h"



#ifdef FILTER_DLL

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_VideoRenderCtl, CVideoRenderCtl)
END_OBJECT_MAP()

CComModule _Module;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}

#else

HRESULT CoCreateInstanceInternal(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
        DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv)
{

    HRESULT hr;
    IClassFactory *pCF;

    *ppv=NULL;

    hr = _Module.GetClassObject(rclsid, IID_IClassFactory, (void **)&pCF);
    if (FAILED(hr))
        return hr;

    hr=pCF->CreateInstance(pUnkOuter, riid, ppv);
    pCF->Release();
    return hr;
}

CUnknown *CVideoRenderCtlStub::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return (CUnknown *) new CVideoRenderCtlStub(NAME("Windowless Renderer Control Stub"), pUnk, phr);
    
} 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ocx\rnderctl.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
// RnderCtl.cpp : Implementation of CVideoRenderCtl
#include "stdafx.h"
#include "vrctl.h"
#ifndef FILTER_DLL
#include <streams.h>
#endif
#include "RnderCtl.h"
#ifdef FILTER_DLL
#include "mixerocx_i.c"
#endif

#ifdef FILTER_DLL
const CLSID CLSID_OverlayMixer = {0xcd8743a1,0x3736,0x11d0,{0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b}};

#else


/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtlStub::CVideoRenderCtlStub
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtlStub::CVideoRenderCtlStub(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr) :
        CUnknown(pName, pUnk, phr),
        m_punkVRCtl(NULL)
{
    HRESULT hr;
    IUnknown *pUnkOuter = GetOwner();

    ++m_cRef;
    // create the control object
    hr = CoCreateInstanceInternal(CLSID_VideoRenderCtl, pUnkOuter, CLSCTX_INPROC_SERVER,
	    IID_IUnknown, (void**)&m_punkVRCtl);
    --m_cRef;

    if (FAILED(hr))
        *phr = hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtlStub::~CVideoRenderCtlStub
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtlStub::~CVideoRenderCtlStub()
{
    if (m_punkVRCtl)
    {
        m_punkVRCtl->Release();
        m_punkVRCtl = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtlStub::~NonDelegatingQueryInterface
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtlStub::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown)
    {
        GetInterface((LPUNKNOWN) (PNDUNKNOWN) this, ppv);
        hr = NOERROR;
    }
    else if (m_punkVRCtl)
    {
        hr = m_punkVRCtl->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;


#if 0
    else if (m_punkVRCtl)
    {
        switch(riid)
        {
        case IID_IVideoRenderCtl:
        case IID_IDispatch:
        case IID_IViewObjectEx:
        case IID_IViewObject2:
        case IID_IViewObject:
        case IID_IOleInPlaceObjectWindowless:
        case IID_IOleInPlaceObject:
        case IID_IOleWindow:
        case IID_IOleInPlaceActiveObject:
        case IID_IOleControl:
        case IID_IOleObject:
        case IID_IQuickActivate:
        case IID_IPersistStorage:
        case IID_IPersistStreamInit:
        case IID_ISpecifyPropertyPages:
        case IID_IDataObject:
        case IID_IProvideClassInfo:
        case IID_IProvideClassInfo2:
        case IID_IConnectionPointContainer:
        case IID_IMixerOCXNotify:
        case IID_IBaseFilter:
            hr = m_punkVRCtl->QueryInterface(riid, ppv);
        default:
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }

    }
    return hr;
#endif
}

#endif

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::CVideoRenderCtl
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtl::CVideoRenderCtl() :
    m_pwndMsgWindow(_T("STATIC"), this, 1),
    m_punkVideoRenderer(NULL),
    m_pIMixerOCX(NULL)
{
    m_ptTopLeftSC.x = 0;
    m_ptTopLeftSC.y = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::~CVideoRenderCtl
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtl::~CVideoRenderCtl()
{
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::FinalConstruct( )
{
    HRESULT hr;
    hr =CoCreateInstance(CLSID_OverlayMixer,
           GetControllingUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown,
           (void **)&m_punkVideoRenderer);
    if (SUCCEEDED(hr))
    {
        hr = m_punkVideoRenderer->QueryInterface(IID_IMixerOCX,
            (void **)&m_pIMixerOCX);
        if (SUCCEEDED(hr))
        {
            // its an interface from the aggregated object so release now
            m_pIMixerOCX->Release();
            RECT rc;
            memset(&rc, 0, sizeof(RECT));
            m_pwndMsgWindow.Create(NULL, rc, _T("VRCtlWindow"), 0);
            IMixerOCXNotify *pIMixerOCXNotify = NULL;
            hr = ControlQueryInterface(IID_IMixerOCXNotify, (void **) &pIMixerOCXNotify);
            if (SUCCEEDED(hr))
            {
                pIMixerOCXNotify->Release();
                hr = m_pIMixerOCX->Advise(pIMixerOCXNotify); // advise will addref
                if (SUCCEEDED(hr))
                    pIMixerOCXNotify->Release();
            }

        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////
void CVideoRenderCtl::FinalRelease()
{
    if (m_pIMixerOCX) {
        (GetControllingUnknown())->AddRef();
        m_pIMixerOCX->UnAdvise();
        m_pIMixerOCX = NULL;
    }

    if (m_punkVideoRenderer) {
        m_punkVideoRenderer->Release();
        m_punkVideoRenderer = NULL;
    }

    // make sure there aren't any of our private message lying around in the
    // queue o.w. we will leak
    MSG Message;
    while (PeekMessage(&Message,m_pwndMsgWindow.m_hWnd,WM_MIXERNOTIFY,WM_MIXERNOTIFY,PM_REMOVE))
    {
        if (Message.lParam)
            delete ((void *) Message.lParam);
    }

    if (m_pwndMsgWindow.m_hWnd)
    {
        ::SendMessage(m_pwndMsgWindow.m_hWnd, WM_CLOSE, 0, 0);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnDraw
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::OnDraw(ATL_DRAWINFO& di)
{
    HRESULT hr = S_OK;
    if (m_pIMixerOCX)
        hr=m_pIMixerOCX->OnDraw(di.hdcDraw, (LPRECT) di.prcBounds);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::SetColorScheme
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::SetColorScheme(LOGPALETTE* pLogpal)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::GetExtent
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    HRESULT hr;
    if (dwDrawAspect != DVASPECT_CONTENT)
	    return E_FAIL;
    if (psizel == NULL)
	    return E_POINTER;

    hr = E_NOINTERFACE;
    if (m_pIMixerOCX)
    {
        DWORD dwVideoWidth = 0;
        DWORD dwVideoHeight = 0;
        hr = m_pIMixerOCX->GetVideoSize(&dwVideoWidth, &dwVideoHeight);
        if (SUCCEEDED(hr))
        {
            SIZEL sizl;
            sizl.cx = dwVideoWidth;
            sizl.cy = dwVideoHeight;
            AtlPixelToHiMetric(&sizl, psizel);
        }
    }
    if (FAILED(hr))
        hr = IOleObjectImpl<CVideoRenderCtl>::GetExtent(dwDrawAspect, psizel);
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::GetColorSet
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::GetColorSet(DWORD dwDrawAspect, LONG lindex,
        void* pvAspect, DVTARGETDEVICE* ptd, HDC hicTargetDev, LOGPALETTE** ppColorSet)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::SetObjectRects
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
    HRESULT hr;
    hr = IOleInPlaceObjectWindowlessImpl<CVideoRenderCtl>::SetObjectRects(prcPos, prcClip);
    if (SUCCEEDED(hr))
    {
        if (m_pIMixerOCX)
        {
            RECT rc = *prcPos;
            RECT rcClip = *prcClip;

            if(m_hWndCD)   // make Rect relative to our window if we have one
            {
                OffsetRect(&rcClip, -rc.left, -rc.top);
                OffsetRect(&rc, -rc.left, -rc.top);
                m_ptTopLeftSC.x = 0;
                m_ptTopLeftSC.y = 0;
                ::ClientToScreen(m_hWndCD, &m_ptTopLeftSC);
            }
            else
            {
                m_ptTopLeftSC.x = rc.left;
                m_ptTopLeftSC.y = rc.top;
                HWND hwnd;
                hr = GetContainerWnd(&hwnd);
                if (SUCCEEDED(hr))
                    ::ClientToScreen(hwnd, &m_ptTopLeftSC);
            }

            hr = m_pIMixerOCX->SetDrawRegion(&m_ptTopLeftSC, &rc, &rcClip);
        }
    }
    return hr;

}

//IMixerOCXNotify
/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnInvalidateRect
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::OnInvalidateRect(LPCRECT lpcRect)
{
    if (ValidateThreadOrNotify(MIXER_NOTID_INVALIDATERECT, (void *)lpcRect) == S_FALSE)
        return S_OK;

    HRESULT hr = E_FAIL;
    if(m_bWndLess && m_spInPlaceSite && m_bInPlaceActive)  // Windowless
    {

// This optimization is not working right now, at the minimum Chrome should be
// returning an Error on GetDC if it doesn't support the call..
#ifdef OPTIMIZE
        HDC hdc=NULL;
        if (SUCCEEDED(hr = m_spInPlaceSite->GetDC( NULL, 0, &hdc )))
        {
            if (m_pIMixerOCX)
                hr=m_pIMixerOCX->OnDraw(hdc, &m_rcPos);
            m_spInPlaceSite->ReleaseDC( hdc );
        }
#else
        hr = m_spInPlaceSite->InvalidateRect(lpcRect, FALSE);
#endif
    }
    else if ( m_hWndCD )
    {
        hr = ::InvalidateRect(m_hWndCD, lpcRect, FALSE);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnStatusChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::OnStatusChange(ULONG ulStatusFlags)
{
    if (ValidateThreadOrNotify(MIXER_NOTID_STATUSCHANGE, (void *)&ulStatusFlags) == S_FALSE)
        return S_OK;
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnDataChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::OnDataChange(ULONG ulDataFlags)
{
    if (ValidateThreadOrNotify(MIXER_NOTID_DATACHANGE, (void *)&ulDataFlags) == S_FALSE)
        return S_OK;
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::GetContainerWnd
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::GetContainerWnd(HWND *phwnd)
{
    HRESULT hr;
    if (phwnd == NULL)
        return E_INVALIDARG;

    *phwnd = NULL;
    hr = E_FAIL;

    if(m_bWndLess && m_spInPlaceSite)
    {
        hr = m_spInPlaceSite->GetWindow(phwnd);
    }
    else if (m_hWndCD)
    {
        *phwnd = ::GetParent(m_hWndCD);
        if (*phwnd)
            hr = S_OK;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnMixerNotify
//
/////////////////////////////////////////////////////////////////////////////
LRESULT CVideoRenderCtl::OnMixerNotify(UINT nMsg, WPARAM wParam,
        LPARAM lParam, BOOL& fHandled)
{
    switch (wParam)
    {
    case MIXER_NOTID_INVALIDATERECT:
        OnInvalidateRect((LPRECT) lParam);
        break;
    case MIXER_NOTID_DATACHANGE:
        OnDataChange(*((ULONG *)lParam));
        break;
    case MIXER_NOTID_STATUSCHANGE:
        OnStatusChange(*((ULONG *)lParam));
        break;
    }
    if (lParam)
        delete (void *)lParam;

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnMixerNotify
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::ValidateThreadOrNotify(DWORD dwMixerNotifyId, void *pvData)
{
    HRESULT hr = S_OK;
    if (GetWindowThreadProcessId(m_pwndMsgWindow.m_hWnd, NULL) != GetCurrentThreadId())
    {
        void *pv = NULL;
        switch(dwMixerNotifyId)
        {
        case MIXER_NOTID_INVALIDATERECT:
            if (pvData)
            {
                pv = new RECT;
                if( pv ) {
                    memcpy(pv, pvData, sizeof(RECT));
                }
            }
            break;
        case MIXER_NOTID_DATACHANGE:
        case MIXER_NOTID_STATUSCHANGE:
            if (pvData)
            {
                pv = new ULONG;
                if( pv ) {
                    memcpy(pv, pvData, sizeof(ULONG));
                }
            }
            break;
        }
        ::PostMessage(m_pwndMsgWindow.m_hWnd, WM_MIXERNOTIFY, dwMixerNotifyId, (LPARAM) pv);

        hr = S_FALSE;
    }
    return hr;
}


//
// turn off warning about function being DLL export
//

#pragma warning( disable : 4273 )
typedef HRESULT (__stdcall* LPFNOCPF)(
    HWND hwndOwner,
    UINT x, UINT y,
    LPCOLESTR lpszCaption,
    ULONG cObjects,
    LPUNKNOWN FAR* ppUnk,
    ULONG cPages,
    LPCLSID pPageClsID,
    LCID lcid,
    DWORD dwReserved,
    LPVOID pvReserved
    );

extern "C"
HRESULT __stdcall
xxxOleCreatePropertyFrame(
    HWND hwndOwner,
    UINT x, UINT y,
    LPCOLESTR lpszCaption,
    ULONG cObjects,
    LPUNKNOWN FAR* ppUnk,
    ULONG cPages,
    LPCLSID pPageClsID,
    LCID lcid,
    DWORD dwReserved,
    LPVOID pvReserved
    )
{
    HRESULT hr = E_NOTIMPL;
    HINSTANCE hInst = LoadLibrary(TEXT("OLEAUT32.DLL"));

    if (hInst)
    {
        LPFNOCPF lpfn = (LPFNOCPF)GetProcAddress(hInst, "OleCreatePropertyFrame");

        if (lpfn)
        {
            hr = (*lpfn)(hwndOwner, x, y, lpszCaption,
                         cObjects, ppUnk, cPages, pPageClsID, lcid,
                         dwReserved, pvReserved);
        }

        FreeLibrary(hInst);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ocx\stdafx.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__888D5477_CABB_11D1_8505_00A0C91F9CA0__INCLUDED_)
#define AFX_STDAFX_H__888D5477_CABB_11D1_8505_00A0C91F9CA0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

// ATL warnings....
#pragma warning (disable:4100 4610 4510 4244 4505 4701)

// ATL Win64 warnings
#pragma warning (disable:4189)


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <strmif.h>

#include <control.h>
#include <mixerocx.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__888D5477_CABB_11D1_8505_00A0C91F9CA0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\ddmmi.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmm.cpp
 *  Content:    Routines for using DirectDraw on a multimonitor system
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


HMONITOR DeviceFromWindow(HWND hwnd, LPSTR szDevice, RECT*prc);

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\bpcsusp.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//// bpcsuspend.h - header file for interface that allows external apps
//       to request that the bpc video server release all of its devices and
//       shutdown its directshow graph.  

// USAGE:
// in order to request that the bpc subsystem release its devices
// create an instance of the CBPCSuspend class
// to check if this succeeded use the IsBPCSuspended member function.  if IsBPCSuspended returns false 
// then that means that there are active bpc video clients and you must treat this as you would a
// device busy or device open type of failure.
// when you are done with the devices destroy the CBPCSuspend class and this will notify vidsvr
// that it can resume using the devices and return to background data capturing
//
// NOTE: you must compile vidsvr.odl and include the resulting .h before including this file
// 
// CLSID_BPCSuspend comes from the header file generated from compiling vidsvr.odl
// IBPCSuspended comes from the header file generated from compiling vidsvr.odl

// theory of operation:
// by using GetActiveObject instead of CoCreateInstance we don't force vidsvr to be loaded just to find
// out that it wasn't running in the first place.
// by returning an object that must be released to free the devices so that vidsvr can continue background
// data capture we utilize COM to manage this resource.  this means that if the external app that requested
// the devices crashes or leaks then the suspension object will be automatically released and 
// vidsvr can resume using the devices without requiring a system reboot or some other unfriendly intervention.

#if !defined(_MSBPCVideo_H_) && !defined(__msbpcvid_h__)
#error you must include the .h generated from compiling vidsvr.odl before including this file
#endif

#ifndef BPCSUSP_H
#define BPCSUSP_H
#pragma once

#include <oleauto.h>

#ifdef _CPPUNWIND
#pragma message("bpcsusp.h using exceptions")
#define BPCTRY try {
#ifdef _DEBUG
#define BPCCATCH } catch(...) { OutputDebugString("CBPCSuspend exception\r\n");}
#else
#define BPCCATCH } catch(...) {}
#endif
#define BPCNOTHROW throw()    
#else
#define BPCTRY
#define BPCCATCH
#define BPCNOTHROW
#endif

class CBPCSuspend {
    IDispatch* m_pSuspended;
    bool m_fBPCExists;
public:
   inline CBPCSuspend() BPCNOTHROW : m_pSuspended(NULL), m_fBPCExists(false) {
   BPCTRY
#ifdef _DEBUG
        OutputDebugString("CBPCSuspend()::CBPCSuspend()\r\n");
        TCHAR msgtemp[256];
#endif
        IUnknown *pUnkSuspendor = NULL;
        DWORD dwReserved;
        HRESULT hr = GetActiveObject(CLSID_BPCSuspend, &dwReserved, &pUnkSuspendor);
        if (SUCCEEDED(hr)) {
            IBPCSuspend *pSuspendor = NULL;
            hr = pUnkSuspendor->QueryInterface(IID_IBPCSuspend, reinterpret_cast<void **>(&pSuspendor));
            pUnkSuspendor->Release();
            if (SUCCEEDED(hr)) {

#ifdef _DEBUG
                OutputDebugString("CBPCSuspend()::CBPCSuspend() BPC exists\r\n");
#endif
                m_fBPCExists = true;
                hr = pSuspendor->DeviceRelease(0L, &m_pSuspended);
                if (FAILED(hr)) {
#ifdef _DEBUG
                    wsprintf(msgtemp, "CBPCSuspend()::CBPCSuspend() Suspendor->DeviceRelease() rc = %lx\r\n", hr);
                    OutputDebugString(msgtemp);
#endif
                    ASSERT(!m_pSuspended);
                }
#ifdef _DEBUG
                else {
                    wsprintf(msgtemp, "CBPCSuspend()::CBPCSuspend() BPC video server suspended\r\n");
                    OutputDebugString(msgtemp);
                }
#endif
                pSuspendor->Release();
            }


        } else {
#ifdef _DEBUG
            wsprintf(msgtemp, "CBPCSuspend()::CBPCSuspend() GetActiveObject() rc = %lx\r\n", hr);
            OutputDebugString(msgtemp);
#endif
        }
   BPCCATCH
   }
   inline ~CBPCSuspend() BPCNOTHROW {
       BPCTRY 
           if (m_fBPCExists && m_pSuspended) {
               m_pSuspended->Release();
                m_pSuspended = NULL;
           }
       BPCCATCH
   }
   inline bool IsBPCSuspended() BPCNOTHROW {
       // if m_fBPCExists but we weren't able to retrieve a suspension object then
       // there are active video clients and you must treat this as a device busy/failed to open type error
       if (m_fBPCExists && !m_pSuspended) {
           return false;
       }
       return true;
   }
};

#endif
// end of file - bpcsusp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\bpcwrap.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// 
//  bpcwrap.h
//
//  Wrapper for the hacky BPC resource management APIs for freeing a video 
//  port that is currently being used by the BPC's vidsvr.
//


//
//  Property set defines for notifying owner.
//
// {7B390654-9F74-11d1-AA80-00C04FC31D60}
DEFINE_GUID(AMPROPSETID_NotifyOwner, 
            0x7b390654, 0x9f74, 0x11d1, 0xaa, 0x80, 0x0, 0xc0, 0x4f, 0xc3, 0x1d, 0x60);

typedef enum _AMPROPERTY_NOTIFYOWNER {
    AMPROPERTY_OvMixerOwner = 0x01  //use AMOVMIXEROWNER
} AMPROPERTY_NOTIFYOWNER;

typedef enum _AMOVMIXEROWNER {
    AM_OvMixerOwner_Unknown = 0x01,
    AM_OvMixerOwner_BPC = 0x02
} AMOVMIXEROWNER;




class COMFilter;
class CBPCSuspend;

class CBPCWrap {
public:
    CBPCWrap(COMFilter *pFilt);
    ~CBPCWrap();
    HRESULT         TurnBPCOff();
    HRESULT         TurnBPCOn();

private:
    AMOVMIXEROWNER  GetOwner();
    CBPCSuspend *   m_pBPCSus;
    COMFilter *     m_pFilt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\bpcwrap.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// 
//  bpcwrap.cpp
//
//  Wrapper for the hacky BPC resource management APIs for freeing a video 
//  port that is currently being used by the BPC's vidsvr.
//

#include <streams.h>
//below files required for ovmixer.h
#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
//above files required for ovmixer.h
#include "macvis.h"
#include "ovmixer.h"

#include <initguid.h>
#include "ocidl.h"
#include "msbpcvid.h"
#include "assert.h"
#ifndef ASSERT
#define ASSERT assert
#endif
#include "bpcsusp.h"

CBPCWrap::CBPCWrap(COMFilter *pFilt) 
{
    m_pBPCSus = NULL;
    m_pFilt = pFilt;
}

CBPCWrap::~CBPCWrap() 
{
    if (m_pBPCSus != NULL) // this should cause BPC's OvMixer to reallocate the VP
        delete m_pBPCSus;
}

AMOVMIXEROWNER  CBPCWrap::GetOwner() 
{
    AMOVMIXEROWNER  owner=AM_OvMixerOwner_Unknown;

    //this IKsPin implementation has no knowledge of its owner (the mixer filter),
    //so we have to query for the property from here.

    // first get IPin for the primary pin
    IPin *pPin = (IPin *)(m_pFilt->GetPin(0));
    ASSERT(pPin);

    // now get IKsPropertySet
    IKsPropertySet *pKsPropSet=NULL;
    pPin->QueryInterface(IID_IKsPropertySet, (void**)&pKsPropSet);
    ASSERT(pKsPropSet);

    // finally get the owner
    DWORD cbRet;
    HRESULT hr;
    hr = pKsPropSet->Get(AMPROPSETID_NotifyOwner, AMPROPERTY_OvMixerOwner, NULL, 0, &owner, sizeof(owner), &cbRet);
    ASSERT(SUCCEEDED(hr) && cbRet==sizeof(owner));

    pKsPropSet->Release();

    return owner;
}


HRESULT CBPCWrap::TurnBPCOff()
{
    if (GetOwner()==AM_OvMixerOwner_BPC) {
        // we shouldn't suspend BPC if this instance of OvMixer is 
        // in the BPC graph.
        return S_OK;  
    }

    m_pBPCSus = new CBPCSuspend(); // this should cause BPC's OvMixer to free the VP
    
    if (m_pBPCSus == NULL) {
        return E_UNEXPECTED;
    } else {
        return S_OK;
    }
}

HRESULT CBPCWrap::TurnBPCOn()
{
    if (m_pBPCSus != NULL) // this should cause BPC's OvMixer to reallocate the VP
        delete m_pBPCSus;
    m_pBPCSus = NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\ddmm.cpp ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmm.cpp
 *  Content:    Routines for using DirectDraw on a multimonitor system
 *
 ***************************************************************************/

//#define WIN32_LEAN_AND_MEAN
//#define WINVER 0x0400
//#define _WIN32_WINDOWS 0x0400
#include <streams.h>
#include <ddraw.h>
#include <ddmm.h>
#include <mmsystem.h>   // Needed for definition of timeGetTime
#include <limits.h>     // Standard data type limit definitions
#include <ddmmi.h>
#include <atlconv.h>
#include <dciddi.h>
#include <dvdmedia.h>
#include <amstream.h>

#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>

#include <macvis.h>   // for Macrovision support
#include <ovmixer.h>
#include <initguid.h>
#include <malloc.h>

#define COMPILE_MULTIMON_STUBS
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx

extern HINSTANCE LoadTheDDrawLibrary();
extern "C" const TCHAR chRegistryKey[];
const TCHAR szDDrawGUID[] = TEXT("DDraw Connection Device GUID");

const char szDisplay[] = "DISPLAY";
const char szDesc[] = "Primary Display Driver";


/******************************Public*Routine******************************\
* DeviceFromWindow
*
* find the direct draw device that should be used for a given window
*
* the return code is a "unique id" for the device, it should be used
* to determine when your window moves from one device to another.
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
HMONITOR
DeviceFromWindow(
    HWND hwnd,
    LPSTR szDevice,
    RECT *prc
    )
{
    HMONITOR hMonitor;

    if (GetSystemMetrics(SM_CMONITORS) <= 1)
    {
        if (prc)
            SetRect(prc, 0, 0,
                    GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));

        if (szDevice)
            lstrcpyA(szDevice, szDisplay);

        return MonitorFromWindow(HWND_DESKTOP, MONITOR_DEFAULTTOPRIMARY);
    }

    //
    // The docs say that MonitorFromWindow will always return a Monitor.
    //

    hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    if (prc != NULL || szDevice != NULL)
    {
        MONITORINFOEX mi;
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(hMonitor, &mi);
        if (prc)
            *prc = mi.rcMonitor;

        USES_CONVERSION;
        if (szDevice)
            lstrcpyA(szDevice, T2A(mi.szDevice));
    }

    return hMonitor;
}


/*****************************Private*Routine******************************\
* GetCurrentMonitor
*
* find the current monitor
*
* History:
* Fri 08/20/1999 - StEstrop - Created
*
\**************************************************************************/
HMONITOR
COMFilter::GetCurrentMonitor(
    BOOL fUpdate
    )
{
    CAutoLock l(&m_csFilter);
    DbgLog((LOG_TRACE, 3, TEXT("Establishing current monitor = %hs"),
            m_lpCurrentMonitor->szDevice));

    if (fUpdate && GetOutputPin()) {

        RECT        rcMon;
        char        achMonitor[CCHDEVICENAME];   // device name of current monitor

        ASSERT(sizeof(achMonitor) == sizeof(m_lpCurrentMonitor->szDevice));
        HMONITOR hMon = DeviceFromWindow(GetWindow(), achMonitor, &rcMon);

        AMDDRAWMONITORINFO* p = m_lpDDrawInfo;
        for (; p < &m_lpDDrawInfo[m_dwDDrawInfoArrayLen]; p++) {

            if (hMon == p->hMon) {
                m_lpCurrentMonitor = p;
                break;
            }
        }

        DbgLog((LOG_TRACE, 3, TEXT("New monitor = %hs"),
                m_lpCurrentMonitor->szDevice));
    }


    return m_lpCurrentMonitor->hMon;
}


/******************************Public*Routine******************************\
* IsWindowOnWrongMonitor
*
* Has the window moved at least partially onto a monitor other than the
* monitor we have a DDraw object for?  ID will be the hmonitor of the
* monitor it is on, or 0 if it spans
*
* History:
* Thu 06/17/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
COMFilter::IsWindowOnWrongMonitor(
    HMONITOR *pID
    )
{
    AMTRACE((TEXT("COMFilter::IsWindowOnWrongMonitor")));


    *pID = m_lpCurrentMonitor->hMon;

    //
    // There is only 1 monitor.
    //

    RECT rc;
    HWND hwnd = GetWindow();

    if ( ! hwnd )
        return FALSE;

    if (GetSystemMetrics(SM_CMONITORS) > 1 && !IsIconic(hwnd)) {

        //
        // If the window is on the same monitor as last time, this is the quickest
        // way to find out.  This is called every frame, remember
        //
        GetWindowRect(hwnd, &rc);
        LPRECT lprcMonitor = &m_lpCurrentMonitor->rcMonitor;

        if (rc.left < lprcMonitor->left || rc.right > lprcMonitor->right ||
            rc.top < lprcMonitor->top || rc.bottom > lprcMonitor->bottom) {

            //
            // Find out for real. This is called every frame, but only when we are
            // partially off our main monitor, so that's not so bad.
            //
            *pID = DeviceFromWindow(hwnd, NULL, NULL);
        }
    }

    return  (m_lpCurrentMonitor->hMon != *pID);
}


/*****************************Private*Routine******************************\
* GetAMDDrawMonitorInfo
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
GetAMDDrawMonitorInfo(
    const GUID* lpGUID,
    LPCSTR lpDriverDesc,
    LPCSTR lpDriverName,
    LPDIRECTDRAWCREATE lpfnDDrawCreate,
    AMDDRAWMONITORINFO* lpmi,
    HMONITOR hm
    )
{
    MONITORINFOEX miInfoEx;
    HDC hdcDisplay;
    miInfoEx.cbSize = sizeof(miInfoEx);

    lstrcpynA(lpmi->szDevice, lpDriverName, AMCCHDEVICENAME);
    lstrcpynA(lpmi->szDescription, lpDriverDesc, AMCCHDEVICEDESCRIPTION);

    if (lpGUID == NULL) {
        lpmi->hMon = DeviceFromWindow((HWND)NULL, NULL, NULL);
        lpmi->dwFlags = MONITORINFOF_PRIMARY;
        lpmi->guid.lpGUID = NULL;

        SetRect(&lpmi->rcMonitor, 0, 0,
                GetSystemMetrics(SM_CXSCREEN),
                GetSystemMetrics(SM_CYSCREEN));

        lpmi->guid.GUID = GUID_NULL;
    }
    else if (GetMonitorInfo(hm, &miInfoEx)) {
        lpmi->dwFlags = miInfoEx.dwFlags;
        lpmi->rcMonitor = miInfoEx.rcMonitor;
        lpmi->hMon = hm;
        lpmi->guid.lpGUID = &lpmi->guid.GUID;
        lpmi->guid.GUID = *lpGUID;
    }
    else return FALSE;


    INITDDSTRUCT(lpmi->ddHWCaps);
    LPDIRECTDRAW lpDD;

    HRESULT hr = CreateDirectDrawObject(lpmi->guid, &lpDD, lpfnDDrawCreate);
    if (SUCCEEDED(hr)) {

        IDirectDraw4* lpDD4;
        hr = lpDD->QueryInterface(IID_IDirectDraw4, (LPVOID*)&lpDD4);

        if (SUCCEEDED(hr)) {
            lpDD4->GetCaps(&lpmi->ddHWCaps, NULL);
            lpDD4->Release();
        }
        else {
            lpDD->GetCaps(&lpmi->ddHWCaps, NULL);
        }

        lpDD->Release();
    }
    else return FALSE;

    return TRUE;
}

/*****************************Private*Routine******************************\
* DDEnumCallbackEx
*
*
*
* History:
* Fri 08/13/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL WINAPI
DDEnumCallbackEx(
    GUID *lpGUID,
    LPSTR lpDriverDesc,
    LPSTR lpDriverName,
    LPVOID lpContext,
    HMONITOR  hm
    )
{
    DDRAWINFO* lpDDInfo = (DDRAWINFO*)lpContext;

    switch (lpDDInfo->dwAction) {

    case ACTION_COUNT_GUID:
        lpDDInfo->dwUser++;
        return TRUE;

    case ACTION_FILL_GUID:
        if (GetAMDDrawMonitorInfo(lpGUID, lpDriverDesc,
                                  lpDriverName,
                                  lpDDInfo->lpfnDDrawCreate,
                                  &lpDDInfo->pmi[lpDDInfo->dwUser],
                                  hm)) {
            lpDDInfo->dwUser++;
        }
        return TRUE;
    }

    return FALSE;
}


/*****************************Private*Routine******************************\
* MatchGUID
*
*
*
* History:
* Wed 08/18/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMFilter::MatchGUID(
    const GUID* lpGUID,
    LPDWORD lpdwMatchID
    )
{
    for (DWORD i = 0; i < m_dwDDrawInfoArrayLen; i++) {

        const GUID* lpMonGUID = m_lpDDrawInfo[i].guid.lpGUID;

        if ((lpMonGUID == NULL && lpGUID == NULL) ||
            (lpMonGUID && lpGUID && IsEqualGUID(*lpGUID, *lpMonGUID))) {

            *lpdwMatchID = i;
            return S_OK;
        }
    }

    return S_FALSE;
}


/******************************Public*Routine******************************\
* SetDDrawGUID
*
* Set the DDraw device GUID used when connecting the primary PIN to the
* upstream decoder.
*
* History:
* Fri 08/13/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::SetDDrawGUID(
    const AMDDRAWGUID *lpGUID
    )
{
    // Check that we aren't already using a DDraw device
    if (m_pDirectDraw) {
        return VFW_E_ALREADY_CONNECTED;
    }

    if (!lpGUID) {
        return E_POINTER;
    }

    if (lpGUID->lpGUID) {
        if (!IsEqualGUID(lpGUID->GUID, *lpGUID->lpGUID)) {
            return E_INVALIDARG;
        }
    }

    CAutoLock l(&m_csFilter);
    DWORD dwMatchID;

    HRESULT hr = MatchGUID(lpGUID->lpGUID, &dwMatchID);
    if (hr == S_FALSE) {
        return E_INVALIDARG;
    }

    m_lpCurrentMonitor = &m_lpDDrawInfo[dwMatchID];

    if (lpGUID->lpGUID) {
        m_ConnectionGUID.lpGUID = &m_ConnectionGUID.GUID;
        m_ConnectionGUID.GUID = lpGUID->GUID;
    }
    else {
        m_ConnectionGUID.lpGUID = NULL;
        m_ConnectionGUID.GUID = GUID_NULL;
    }

    return S_OK;
}

/******************************Public*Routine******************************\
* GetDDrawGUID
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetDDrawGUID(
    AMDDRAWGUID* lpGUID
    )
{
    if (!lpGUID) {
        return E_POINTER;
    }

    // copy GUID and return S_OK;
    *lpGUID = m_ConnectionGUID;

    return S_OK;
}

/*****************************Private*Routine******************************\
* SetRegistryString
*
*
*
* History:
* Wed 08/18/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
SetRegistryString(
    HKEY hk,
    const TCHAR* pKey,
    const TCHAR* szString
    )
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(hk, chRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, 0L, REG_SZ,
                             (LPBYTE)szString,
                             sizeof(TCHAR) * lstrlen(szString));
        RegCloseKey(hKey);
    }

    if (lRet == ERROR_SUCCESS) {
        return S_OK;
    }

    return AmHresultFromWin32(lRet);
}


/*****************************Private*Routine******************************\
* GetRegistryString
*
*
*
* History:
* Wed 08/18/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
GetRegistryString(
    HKEY hk,
    const TCHAR* pKey,
    TCHAR* szString,
    PLONG lpLength
    )
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(hk, chRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        lRet = RegQueryValueEx(hKey, pKey, 0L, &dwType,
                               (LPBYTE)szString, (LPDWORD)lpLength);
        RegCloseKey(hKey);
    }

    if (lRet == ERROR_SUCCESS) {
        return S_OK;
    }

    return AmHresultFromWin32(lRet);
}


/******************************Public*Routine******************************\
* SetDefaultDDrawGUID
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::SetDefaultDDrawGUID(
    const AMDDRAWGUID* lpGUID
    )
{
    if (!lpGUID) {
        return E_POINTER;
    }

    if (lpGUID->lpGUID) {
        if (!IsEqualGUID(lpGUID->GUID, *lpGUID->lpGUID)) {
            return E_INVALIDARG;
        }
    }

    // match the supplied GUID with those DDraw devices available
    DWORD dwMatchID;
    HRESULT hr = MatchGUID(lpGUID->lpGUID, &dwMatchID);

    // if match not found return E_INVALIDARG
    if (hr == S_FALSE) {
        return E_INVALIDARG;
    }

    // if the caller is trying to make the default device the NULL
    // DDraw device, just delete the registry key.
    if (lpGUID->lpGUID == NULL) {

        HKEY hKey;
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 chRegistryKey, 0,
                                 KEY_SET_VALUE, &hKey);

        if (lRet == ERROR_SUCCESS) {
            lRet = RegDeleteValue(hKey, szDDrawGUID);

            if (lRet == ERROR_FILE_NOT_FOUND)
                lRet = 0;

            RegCloseKey(hKey);
        }

        if (lRet == 0)
            return S_OK;

        return AmHresultFromWin32(lRet);
    }

    // convert GUID into string
    LPOLESTR lpsz;
    hr = StringFromCLSID(lpGUID->GUID, &lpsz);
    if (FAILED(hr)) {
        return hr;
    }

    // write the string into the registry
    USES_CONVERSION;
    hr = SetRegistryString(HKEY_LOCAL_MACHINE, szDDrawGUID, OLE2T(lpsz));

    CoTaskMemFree(lpsz);

    return hr;
}

/******************************Public*Routine******************************\
* GetDefaultDDrawGUID
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetDefaultDDrawGUID(
    AMDDRAWGUID* lpGUID
    )
{
    if (!lpGUID) {
        return E_POINTER;
    }

    // read string from the registry
    TCHAR   szGUID[64];
    LONG    lLen = 64;
    HRESULT hr = GetRegistryString(HKEY_LOCAL_MACHINE, szDDrawGUID,
                                   szGUID, &lLen);

    // if string not in registry return the default (NULL) DDraw device
    if (FAILED(hr)) {
        lpGUID->lpGUID = NULL;
        return S_OK;
    }

    // convert string into GUID and return
    lpGUID->lpGUID = &lpGUID->GUID;

    USES_CONVERSION;
    hr = IIDFromString(T2OLE(szGUID), lpGUID->lpGUID);

    return hr;
}


/******************************Public*Routine******************************\
* GetDDrawGUIDs
*
* Allocates and returns an array of AMDDRAWMONITORINFO structures, one for
* for each direct draw device attached to a display monitor.
*
* The caller is responsible for freeing the allocated memory by calling
* CoTaskMemFree when it is finished with the array.
*
* The functions returns the size of the array via the lpdw variable.
*
* History:
* Fri 08/13/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetDDrawGUIDs(
    LPDWORD lpdw,
    AMDDRAWMONITORINFO** lplpInfo
    )
{
    if (!lpdw || !lplpInfo) {
        return E_POINTER;
    }

    DDRAWINFO DDrawInfo;
    DDrawInfo.dwAction = ACTION_COUNT_GUID;

    if (m_lpfnDDrawEnumEx) {
        DDrawInfo.dwUser = 0;
        (*m_lpfnDDrawEnumEx)(DDEnumCallbackEx, (LPVOID)&DDrawInfo,
                             DDENUM_ATTACHEDSECONDARYDEVICES);
    }
    else {
        DDrawInfo.dwUser = 1;
    }

    // allocate memory
    *lpdw = DDrawInfo.dwUser;
    *lplpInfo = DDrawInfo.pmi = (AMDDRAWMONITORINFO*)CoTaskMemAlloc(
            DDrawInfo.dwUser * sizeof(AMDDRAWMONITORINFO));
    if (*lplpInfo == NULL) {
        return E_OUTOFMEMORY;
    }

    // fill in memory with device info
    if (m_lpfnDDrawEnumEx) {

        DDrawInfo.dwAction = ACTION_FILL_GUID;
        DDrawInfo.dwUser = 0;
        DDrawInfo.lpfnDDrawCreate = m_lpfnDDrawCreate;

        (*m_lpfnDDrawEnumEx)(DDEnumCallbackEx, (LPVOID)&DDrawInfo,
                             DDENUM_ATTACHEDSECONDARYDEVICES);
    }
    else {
        GetAMDDrawMonitorInfo(NULL, szDesc, szDisplay,
                              m_lpfnDDrawCreate, DDrawInfo.pmi,
                              MonitorFromWindow(HWND_DESKTOP,
                                                MONITOR_DEFAULTTONEAREST));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\decimate.cpp ===
/******************************Module*Header*******************************\
* Module Name: decimate.cpp
*
* Support code for the IDecimateVideoImage and IAMVideoDecimationProperties
*
*
* Created: Thu 07/08/1999
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 1999 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>         // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <dvdmedia.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include <macvis.h>
#include <ovmixer.h>


#if 0
#undef DBGLOG
#define DBGLOG(_x_) OutputDebugStringA( _x_ )
#else
#undef DBGLOG
#define DBGLOG(_x_)
#endif

/*****************************Private*Routine******************************\
* GetVideoDecimation
*
* Try to get the IDecimateVideoImage interface from our peer filter.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::GetVideoDecimation(
    IDecimateVideoImage** lplpDVI
    )
{
    AMTRACE((TEXT("COMInputPin::GetVideoDecimation")));

    *lplpDVI = NULL;

    if (m_Connected == NULL || !IsConnected()) {
        return E_FAIL;
    }

    PIN_INFO PinInfo;
    HRESULT hr = m_Connected->QueryPinInfo(&PinInfo);
    if (FAILED(hr)) {
        return hr;
    }

    hr = PinInfo.pFilter->QueryInterface(IID_IDecimateVideoImage,
                                         (LPVOID*)lplpDVI);
    PinInfo.pFilter->Release();

    return hr;
}

/*****************************Private*Routine******************************\
* QueryDecimationOnPeer
*
* Check to see if the decoder connected to our input pin is happy
* to decimate to the requested size.  The decoder will return,
* S_OK if it can, S_FALSE if it can't decimate to the requested size
* and would like us to continue using the current decimation size and
* E_FAIL if it can't decimate at all or wants to stop decimating.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::QueryDecimationOnPeer(
    long lWidth,
    long lHeight
    )
{
    AMTRACE((TEXT("COMInputPin::QueryDecimationOnPeer")));

    IDecimateVideoImage* lpDVI;
    HRESULT hr = GetVideoDecimation(&lpDVI);

    if (SUCCEEDED(hr)) {

        hr = lpDVI->SetDecimationImageSize(lWidth, lHeight);
        lpDVI->Release();
    }
    return hr;
}

/*****************************Private*Routine******************************\
* ResetDecimationIfSet()
*
* Resets the decimation to the original size, but only if actually set
* in the first place.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::ResetDecimationIfSet()
{
    AMTRACE((TEXT("COMInputPin::ResetDecimationIfSet")));

    if (m_bDecimating) {

        IDecimateVideoImage* lpDVI;
        HRESULT hr = GetVideoDecimation(&lpDVI);

        if (SUCCEEDED(hr)) {
            hr = lpDVI->ResetDecimationImageSize();
            lpDVI->Release();
            m_bDecimating = FALSE;
            m_lWidth = 0L;
            m_lHeight = 0L;
        }
        else return hr;
    }

    return S_OK;
}

/*****************************Private*Routine******************************\
* IsDecimationNeeded
*
* Decimation is needed if the current minimum scale factor (either vertical
* or horizontal) is less than 1000.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
IsDecimationNeeded(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("::IsDecimationNeeded")));
    return ScaleFactor < 1000;
}


/*****************************Private*Routine******************************\
* GetCurrentScaleFactor
*
* Determines the x axis scale factor and the y axis scale factor.
* The minimum of these two values is the limiting scale factor.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
GetCurrentScaleFactor(
    LPWININFO pWinInfo,
    DWORD* lpxScaleFactor,
    DWORD* lpyScaleFactor
    )
{
    AMTRACE((TEXT("::GetCurrentScaleFactor")));

    DWORD dwSrcWidth = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);

    DWORD dwDstWidth = WIDTH(&pWinInfo->DestRect);
    DWORD dwDstHeight = HEIGHT(&pWinInfo->DestRect);

    DWORD xScaleFactor = MulDiv(dwDstWidth, 1000, dwSrcWidth);
    DWORD yScaleFactor = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    if (lpxScaleFactor) *lpxScaleFactor = xScaleFactor;
    if (lpyScaleFactor) *lpyScaleFactor = yScaleFactor;

    return min(xScaleFactor, yScaleFactor);
}


/*****************************Private*Routine******************************\
* Running
*
* Returns TRUE if the filter graph is in the "running" state.
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
COMInputPin::Running()
{
    return (m_pFilter->m_State == State_Running && CheckStreaming() == S_OK);
}


/*****************************Private*Routine******************************\
* TryDecoderDecimation
*
*
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::TryDecoderDecimation(
    LPWININFO pWinInfo
    )
{
    AMTRACE((TEXT("COMInputPin::TryDecoderDecimation")));


    ASSERT(Running());


    //
    // We only decimate on the primary pin
    //

    if (m_dwPinId != 0) {

        DBGLOG(("Can only decimate the primary pin\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate the primary pin")));
        return E_FAIL;
    }

    //
    // Can only decimate when using default relative position
    //

    if (m_rRelPos.left != 0 || m_rRelPos.top != 0 ||
        m_rRelPos.right != MAX_REL_NUM || m_rRelPos.bottom != MAX_REL_NUM) {

        DBGLOG(("Can only decimate default relative position\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default relative position")));

        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Must also be using the default source rectangle
    //

    if (WIDTH(&pWinInfo->SrcRect) != m_lSrcWidth ||
        HEIGHT(&pWinInfo->SrcRect) != m_lSrcHeight) {

        DBGLOG(("Can only decimate default source rectangle\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default source rectangle")));

        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Now try asking the upstream decoder if it wants to decimate to
    // the specified image size
    //

    LONG lWidth = WIDTH(&pWinInfo->DestRect);
    LONG lHeight = HEIGHT(&pWinInfo->DestRect);
    HRESULT hr = QueryDecimationOnPeer(lWidth, lHeight);
    if (SUCCEEDED(hr)) {
        m_bDecimating = TRUE;
        m_lWidth = lWidth;
        m_lHeight = lHeight;
    }
    else {
        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Adjust the source rect passed to UpdateOverlay to
    // reflect the image size
    //

    pWinInfo->SrcRect.right = lWidth;
    pWinInfo->SrcRect.bottom = lHeight;

    return S_OK;
}

/*****************************Private*Routine******************************\
* GetOverlayStretchCaps
*
* Returns the stretching capabilities of the VGA overlay scaler
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
COMInputPin::GetOverlayStretchCaps()
{
    AMTRACE((TEXT("COMInputPin::GetOverlayStretchCaps")));

    LPDDCAPS pDirectCaps = NULL;
    pDirectCaps = m_pFilter->GetHardwareCaps();
    if ( pDirectCaps )
        return pDirectCaps->dwMinOverlayStretch;
    return 1000;
}




/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
* Determines if the current scale factor is outside the valid scale
* factors for the VGA overlay scaler.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
COMInputPin::BeyondOverlayCaps(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("COMInputPin::BeyondOverlayCaps")));

    return ScaleFactor < GetOverlayStretchCaps();
}



/*****************************Private*Routine******************************\
* CropSourceRect
*
* Crops the video image by adjusting the source rectangle until the ratio
* between the source and target rectangles is within the specified minimum
* scale factor (dwMinZoomFactor)
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::CropSourceRect(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("COMInputPin::CropSourceRect")));

#if defined(DEBUG)
    if (GetProfileIntA("OVMixer", "NoCrop", 0))
        return S_FALSE;
#endif

    AM_ASPECT_RATIO_MODE amAdjustedARMode = AM_ARMODE_STRETCHED;
    HRESULT hr = GetAdjustedModeAndAspectRatio(&amAdjustedARMode, NULL, NULL);
    ASSERT(SUCCEEDED(hr));

    DWORD dCurZoomFactorX;
    DWORD dCurZoomFactorY;
    GetCurrentScaleFactor(pWinInfo, &dCurZoomFactorX, &dCurZoomFactorY);

    LONG srcWidth = WIDTH(&pWinInfo->SrcRect);
    LONG srcHeight = HEIGHT(&pWinInfo->SrcRect);

    if (amAdjustedARMode == AM_ARMODE_STRETCHED) {

        //
        // if we don't need to maintain the aspect ratio, we clip only as
        // little as possible, so we can maximize the viewing area
        //
        if (dCurZoomFactorX < dwMinZoomFactorX) {

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dCurZoomFactorX, 1000);
        }

        if (dCurZoomFactorY < dwMinZoomFactorY) {

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dCurZoomFactorY, 1000);
        }
    }
    else {

        //
        // in this mode we need to maintain the aspect-ratio. So the clipping
        // in x and y has be to done by reducing the width and height of the
        // source rect by the same factor
        //
        if (dCurZoomFactorX < dwMinZoomFactorX ||
            dCurZoomFactorY < dwMinZoomFactorY) {

            DWORD dwFactor;
            DWORD dwFactorX = MulDiv(dCurZoomFactorX, 1000, dwMinZoomFactorX);
            dwFactor = min(1000, dwFactorX);

            DWORD dwFactorY = MulDiv(dCurZoomFactorY, 1000, dwMinZoomFactorY);
            dwFactor = min(dwFactor, dwFactorY);

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dwFactor, 1000);

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dwFactor, 1000);
        }
    }

    return S_OK;
}


/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Non Video Port case
*
* This is where we enforce the chosen decimation strategy.
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
void
COMInputPin::ApplyDecimation(
    LPWININFO pWinInfo
    )
{
    AMTRACE((TEXT("COMInputPin::ApplyDecimation")));

    DWORD dwMinStretch = GetOverlayStretchCaps();

    if (Running()) {

        DWORD dwScaleFactor = ::GetCurrentScaleFactor(pWinInfo);
        if (IsDecimationNeeded(dwScaleFactor)) {

            DECIMATION_USAGE dwUsage;
            GetDecimationUsage(&dwUsage);

            switch (dwUsage) {
            case DECIMATION_USE_OVERLAY_ONLY:
            case DECIMATION_LEGACY:
                ResetDecimationIfSet();
                if (BeyondOverlayCaps(dwScaleFactor)) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_DECODER_ONLY:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_VIDEOPORT_ONLY:
                ASSERT(FALSE);

                DBGLOG(("This mode makes no sense when not using Video Ports"));
                DBGLOG(("Falling thru to the new default case"));

            case DECIMATION_DEFAULT:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    if (BeyondOverlayCaps(dwScaleFactor)) {
                        CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                    }
                }
                break;
            }
        }
        else {
            ResetDecimationIfSet();
        }
    }

    //
    // If the filter graph is not running we should not ask the decoder
    // to do anymore decimation as the decoder will not be
    // sending anymore frames to us.  So, we should adjust pWinInfo to take
    // into account the decimation that has already been applied and then
    // perform any necessary cropping.
    //

    else {

        if (m_bDecimating) {
            pWinInfo->SrcRect.right = m_lWidth;
            pWinInfo->SrcRect.bottom = m_lHeight;
        }

        DWORD dwScaleFactor = ::GetCurrentScaleFactor(pWinInfo);
        if (BeyondOverlayCaps(dwScaleFactor)) {
            CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
        }
    }
}



/******************************Public*Routine******************************\
* GetMinZoomFactors
*
* Gets the minimum X and Y zoom factors for the given overlay and video port
* connection.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
void
CAMVideoPort::GetMinZoomFactors(
    LPWININFO pWinInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating,
    LPDWORD lpMinX,
    LPDWORD lpMinY
    )
{
    AMTRACE((TEXT("CAMVideoPort::GetMinZoomFactors")));
    DWORD dwMinBandWidthZoomFactorX = 0;
    LPDDCAPS pDirectCaps = m_pIVPControl->GetHardwareCaps();

    //
    // if type is DDVPBCAPS_DESTINATION, contraint is terms of min-zoom-factor
    //

    if (m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION) {

        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_DESTINATION")));
        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX < m_sBandwidth.dwOverlay)
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
    }
    else {

        //
        // if type is DDVPBCAPS_SOURCE, contraint is that the width of
        // the src-rect of the overlay must not be bigger than
        // m_lImageWidth*(value specified in m_sBandwidth)
        //

        ASSERT(m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE);
        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_SOURCE")));

        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));

        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX > m_sBandwidth.dwOverlay) {
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
        }

        ASSERT(dwMinBandWidthZoomFactorX <= 1000);
        ASSERT(dwMinBandWidthZoomFactorX > 0);

        //
        // since this bandwidth structure was computed by passing m_lImageWidth
        // as a paramter, the constraint is WIDTH(SrcRect of the overlay) <=
        // m_lImageWidth*dMinBandWidthZoomFactorX.
        // Another way of specifying this is terms of min-zoom-factor,
        // taking the current dest rect into account
        //

        DbgLog((LOG_TRACE, 1,
                TEXT("Mucking about with dwMinBandWidthZoomFactorX")));

        if (dwMinBandWidthZoomFactorX < 1000) {
            int iDstWidth = WIDTH(&pWinInfo->DestRect);
            dwMinBandWidthZoomFactorX = MulABC_DivDE(iDstWidth, 1000, 1000,
                                                     m_lImageWidth,
                                                     dwMinBandWidthZoomFactorX);
        }
        else {
            dwMinBandWidthZoomFactorX = 0;
        }
        DbgLog((LOG_TRACE, 1,
                TEXT("NEW dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
    }

    //
    // Calculate the minimum zoom factors first
    // minimum zoom factor in X depends upon the driver's capabilities to
    // stretch the overlay as well as the bandwidth restrictions.
    //

    *lpMinX = pDirectCaps->dwMinOverlayStretch;
    DbgLog((LOG_TRACE, 1, TEXT("dwMinOverlayStretch=%d"), *lpMinX));

    if (*lpMinX < dwMinBandWidthZoomFactorX) {
        *lpMinX = dwMinBandWidthZoomFactorX;
    }
    DbgLog((LOG_TRACE, 1, TEXT("dwMinZoomFactorX=%d"), *lpMinX));

    //
    // minimum zoom factor in Y depends only upon the driver's capabilities
    //
    *lpMinY = pDirectCaps->dwMinOverlayStretch;
}



/*****************************Private*Routine******************************\
* CheckVideoPortAlignment
*
* Checks that the specified pre-scale width is matches the alignment criteria
* set by the video port.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::CheckVideoPortAlignment(
    DWORD dwWidth
    )
{
    AMTRACE((TEXT("CAMVideoPort::CheckVideoPortAlignment")));
    if ((m_vpCaps.dwFlags & DDVPD_ALIGN) &&
         m_vpCaps.dwAlignVideoPortPrescaleWidth > 1) {

        if (dwWidth & (m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)) {

            return FALSE;
        }
    }

    return TRUE;
}

#if defined(DEBUG)
/*****************************Private*Routine******************************\
* CheckVideoPortScaler
*
* Checks that the video port scaler can actual scale the video image to the
* requested capture size.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::CheckVideoPortScaler(
    DECIMATE_MODE DecimationMode,
    DWORD ImageSize,
    DWORD PreScaleSize,
    ULONG ulDeciStep
    )
{
    AMTRACE((TEXT("CAMVideoPort::CheckVideoPortScaler")));
    BOOL fScalerOK = TRUE;

    if (ImageSize != PreScaleSize) {
        switch (DecimationMode) {
        case DECIMATE_ARB:
            break;

        case DECIMATE_INC:
            if (((ulDeciStep * PreScaleSize) % ImageSize) != 0) {

                DbgLog((LOG_ERROR, 1,
                        TEXT("Can't capture at this size")));

                DbgLog((LOG_ERROR, 1,
                        TEXT("%d is not a fraction of %d over %d"),
                        PreScaleSize, ImageSize, ulDeciStep));

                fScalerOK = FALSE;
            }
            break;

        case DECIMATE_BIN:
            {
                DWORD bin = 1;
                while ((ImageSize / bin) > PreScaleSize) {
                    bin *= 2;
                }

                if ((ImageSize % bin) != 0) {

                    DbgLog((LOG_ERROR, 1,
                            TEXT("Can't capture at this size")));

                    DbgLog((LOG_ERROR, 1,
                            TEXT("%d is not a fraction of %d over 2^n"),
                            PreScaleSize, ImageSize));

                    fScalerOK = FALSE;
                }
            }
            break;

        case DECIMATE_NONE:
            DbgLog((LOG_ERROR, 1,
                    TEXT("Can't capture at this width because the ")
                    TEXT("VideoPort can't scale in this direction")));
            fScalerOK = FALSE;
            break;
        }
    }

    return fScalerOK;
}
#endif

/*****************************Private*Routine******************************\
* AdjustSourceSizeForCapture
*
* Only gets called if we are capturing.
*
* First, we must make sure that the video comming over the video port is
* the correct size.  We do this by checking that m_lImageWidth is equal to
* m_cxCapture and that m_lImageHeight is equal to m_cyCapture.
*
* If they differ, then we pre-scale the video to the correct size.  This is
* the only pre-scaling that is performed.  This is normaly only performed
* once when the graph is first run.  The source rectangle is adjusted
* to accomodate the possibly changed video source size.
*
* Second, we determine the current shrink factor and if it is beyond the
* capabilities of the VGA scaler we CROP the source rectangle (maintaining the
* correct aspect ratio) to such a size that the VGA scaler can cope with
* scaling.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::AdjustSourceSizeForCapture(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    BOOL fUpdateRequired = FALSE;

    AMTRACE((TEXT("CAMVideoPort::AdjustSourceSizeForCapture")));

    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));
    DbgLog((LOG_TRACE, 1, TEXT("Dest(%d, %d, %d, %d)"),
            pWinInfo->DestRect.left, pWinInfo->DestRect.top,
            pWinInfo->DestRect.right, pWinInfo->DestRect.bottom));

    DWORD cyCapture = m_cyCapture;
    if (m_fCaptureInterleaved) {
        cyCapture /= 2;
    }

    //
    // First make sure that we are capturing at the correct size.
    //

    if (m_lDecoderImageWidth == m_cxCapture &&
        m_lDecoderImageHeight == cyCapture) {

        DbgLog((LOG_TRACE, 1, TEXT("Capture size matches image size")));

        //
        // We don't need to pre-scale at the video port, so make sure that it
        // is turned off.
        //
        if (m_svpInfo.dwPrescaleWidth != 0 || m_svpInfo.dwPrescaleHeight != 0) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning off PRE-SCALE")));

            m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = 0;
            m_svpInfo.dwPrescaleHeight = 0;
            fUpdateRequired = TRUE;
        }

        //
        // Reset the decimation ratio's
        //
        m_dwDeciNumX = 1000; m_dwDeciDenX = 1000;
        m_dwDeciNumY = 1000; m_dwDeciDenY = 1000;
    }
    else {

        //
        // We do need to pre-scale at the video port, make sure that it is
        // turned on.
        //

        if (m_svpInfo.dwPrescaleWidth != m_cxCapture ||
            m_svpInfo.dwPrescaleHeight != cyCapture) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning on PRE-SCALE at (%d, %d)"),
                    m_cxCapture, cyCapture ));

            //
            // Need to do some more checking here.  Basically, I'm relying on
            // the decoder connected to the video port to specify a size that
            // the video port can actually scale to.
            //

            ASSERT(CheckVideoPortAlignment(m_cxCapture) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeX, m_lDecoderImageWidth,
                                        m_cxCapture, m_ulDeciStepX) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeY, m_lDecoderImageHeight,
                                        cyCapture, m_ulDeciStepY) == TRUE);

            m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = m_cxCapture;
            m_svpInfo.dwPrescaleHeight = cyCapture;
            fUpdateRequired = TRUE;
        }


        //
        // Update the decimation ratio's
        //
        m_dwDeciDenX = 1000;
        m_dwDeciNumX = (DWORD)MulDiv(m_cxCapture, m_dwDeciDenX, m_lDecoderImageWidth);
        m_dwDeciDenY = 1000;
        m_dwDeciNumY = (DWORD)MulDiv(cyCapture, m_dwDeciDenY, m_lDecoderImageHeight);


        //
        // make sure that the source rectangle reflects the new source video
        // image file
        //
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.right  = rcSrc.left + m_cxCapture;
        rcSrc.bottom = rcSrc.top + m_cyCapture;
    }

    //
    // Second, make sure that any shrinking falls within the capabilities
    // of the scaler on the VGA chip, cropping if necessary
    //
    m_pIVPControl->CropSourceRect(pWinInfo, dwMinZoomFactorX, dwMinZoomFactorY);


    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));

    return fUpdateRequired;
}


/*****************************Private*Routine******************************\
* Running
*
* Returns TRUE if the filter graph is in the "running" state.
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::Running()
{
    AMTRACE((TEXT("CAMVideoPort::Running")));

    return !(m_VPState == AMVP_VIDEO_STOPPED && !m_bStart);
}


/*****************************Private*Routine******************************\
* VideoPortDecimationBackend
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::VideoPortDecimationBackend(
    LPWININFO pWinInfo,
    DWORD dwDecNumX,
    DWORD dwDecDenX,
    DWORD dwDecNumY,
    DWORD dwDecDenY
    )
{
    AMTRACE((TEXT("CAMVideoPort::VideoPortDecimationBackend")));

    //
    // This is the same backend processing as the legacy code,
    // should make this into a function and avoid the code duplication.
    //

    DDVIDEOPORTINFO svpInfo = m_svpInfo;
    if ((dwDecNumX != dwDecDenX) || (dwDecNumY != dwDecDenY)) {

        DbgLog((LOG_TRACE, 1,
                TEXT("prescaling, original image width is %d"),
                m_lImageWidth));

        //
        // Apply the video port pre-scale width factor
        //
        m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = MulDiv(m_lImageWidth, dwDecNumX, dwDecDenX);

        //
        // Check the video port is aligned to the specified boundardy
        //
        if (CheckVideoPortAlignment(m_svpInfo.dwPrescaleWidth) == FALSE) {

            DbgLog((LOG_TRACE, 1,
                    TEXT("pre aligned prescale width = %d"),
                    m_svpInfo.dwPrescaleWidth));

            DWORD dwPrescaleWidth = (m_svpInfo.dwPrescaleWidth &
                    (~(m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)));

            dwDecNumX = MulDiv(dwPrescaleWidth, dwDecDenX, m_lImageWidth);
            m_svpInfo.dwPrescaleWidth = dwPrescaleWidth;

            DbgLog((LOG_TRACE, 1,
                    TEXT("Cause of Alignment restrictions, now new")
                    TEXT(" m_svpInfo.dwPrescaleWidth = %d"),
                    m_svpInfo.dwPrescaleWidth));
        }

        m_svpInfo.dwPrescaleHeight =
            MulDiv(m_lImageHeight, dwDecNumY, dwDecDenY);

        DbgLog((LOG_TRACE, 1, TEXT("PrescaleWidth = %d, PrescaleHeight = %d"),
                m_svpInfo.dwPrescaleWidth, m_svpInfo.dwPrescaleHeight));

        // scale the SrcRect by the decimation values computed
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.left   = MulDiv(rcSrc.left,   dwDecNumX, dwDecDenX);
        rcSrc.right  = MulDiv(rcSrc.right,  dwDecNumX, dwDecDenX);
        rcSrc.top    = MulDiv(rcSrc.top ,   dwDecNumY, dwDecDenY);
        rcSrc.bottom = MulDiv(rcSrc.bottom, dwDecNumY, dwDecDenY);
        DbgLog((LOG_TRACE, 1,
                TEXT("Src(%d, %d, %d, %d)"),
                rcSrc.left, rcSrc.top, rcSrc.right, rcSrc.bottom));
        m_bVPDecimating = TRUE;
    }
    else {
        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;
    }

    m_dwDeciNumX = dwDecNumX;
    m_dwDeciDenX = dwDecDenX;
    m_dwDeciNumY = dwDecNumY;
    m_dwDeciDenY = dwDecDenY;

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumX = %d m_dwDeciDenX = %d"),
            m_dwDeciNumX, m_dwDeciDenX));

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumY = %d m_dwDeciDenY = %d"),
            m_dwDeciNumY, m_dwDeciDenY));

    return m_svpInfo.dwVPFlags != svpInfo.dwVPFlags ||
           m_svpInfo.dwPrescaleWidth != svpInfo.dwPrescaleWidth ||
           m_svpInfo.dwPrescaleHeight != svpInfo.dwPrescaleHeight;
}


/*****************************Private*Routine******************************\
* TryVideoPortDecimation
*
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
HRESULT
CAMVideoPort::TryVideoPortDecimation(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY,
    BOOL* lpUpdateRequired
    )
{
    AMTRACE((TEXT("CAMVideoPort::TryVideoPortDecimation")));

    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, E_INVALIDARG);


    //
    // By default we don't need to call UpdateVideo on the video port
    //

    *lpUpdateRequired = FALSE;


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);

    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return E_FAIL;
    }


    //
    // We only decimate at the video port if it supports arbitary scaling
    //

    if (m_DecimationModeX != DECIMATE_ARB ||
        m_DecimationModeY != DECIMATE_ARB) {

        return E_FAIL;
    }


    //
    // Work out the decimation width and height as a pair of ratios,
    // we do this to remain compatible with the legacy code.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecNumY = 1000;

    DWORD dwCurZoomX = MulDiv(WIDTH(&pWinInfo->DestRect), 1000, dwSrcWidth);
    DWORD dwCurZoomY = MulDiv(HEIGHT(&pWinInfo->DestRect), 1000, dwSrcHeight);

    if (dwCurZoomX < dwMinZoomFactorX) {
        // note that we round down here
        dwDecNumX = (1000 * dwCurZoomX) / dwMinZoomFactorX;
    }

    if (dwCurZoomY < dwMinZoomFactorY) {
        // note that we round down here
        dwDecNumY = (1000 * dwCurZoomY) / dwMinZoomFactorY;
    }


    *lpUpdateRequired = VideoPortDecimationBackend(pWinInfo, dwDecNumX, 1000,
                                                   dwDecNumY, 1000);
    return S_OK;
}

/*****************************Private*Routine******************************\
* AdjustSourceSize
*
* This function should only adjust the source rectangle if the source rectangle
* is actually larger than the destination rectangle AND the required shrink
* is beyond the capabilities of the scaler on the VGA chip.
*
* There is a special case if we are capturing, this case is identified by
* m_fCapturing being set to TRUE.  In this case we simply pass the parameters
* on to AdjustSourceSizeForCapture defined above.
*
* To ensure that the video image displayed still looks correct we make use of
* the scaling abilities of the video port.  We remove or reduce the shrink by
* reducing the size of the video coming over the video port.  This may be
* done in either the X or Y axis as necessary.
*
* The function first calculates the minimum shrink factor in both x and y
* directions.  The minimum factor in the x direction depends upon the bandwidth
* restrictions of the video port as well as the capabilities of the VGA scaler.
* The minimum shrink factor is scaled by 1000.
*
* Next for each axis we determine the current shrink factor, this is the ratio
* of the destination rectangle to the source rectangle scaled by 1000.
* If the current shrink factor is less than the minimum shrink factor we have to
* use the video port scaler to shrink the source rectangle to such a size that
* the VGA scaler is able to cope with the required scaling operation.
*
* There are three methods of scaling at the video port, the choice of method
* used is determined by querying the video port.  The three methods are:
*
* 1. Arbitrary:
* This means that the video port scaler can shrink the video
* to any requested size.  In this case we simply do all the scaling in the
* video port, the VGA scaler is not really used as the source rectangle is now
* the same size as the destination rectangle.
*
* 2. Increment:
* This means that the video port scaler can shrink the video in increments of
* x / N, where N is a constant integer returned from the video port and x is an
* variable integer in the range from 1 to (N-1).  We adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
* 3. Binary:
* Here the video port can only shrink the video by a binary factor, that is 1/x,
* where x is a power of 2.  Again we adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
*
* See additional comments in OVMixer.htm
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
BOOL
CAMVideoPort::AdjustSourceSize(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("CAMVideoPort::AdjustSourceSize")));
    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, E_INVALIDARG);


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);
    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return FALSE;
    }


    //
    // Another special case for capturing, see the comments above.
    //
    if (m_fCapturing) {
        return AdjustSourceSizeForCapture(pWinInfo,dwMinZoomFactorX,
                                          dwMinZoomFactorY);
    }


    //
    // Determine the adjustment for the x axis.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecDenX = 1000;
    DWORD dwDstWidth  = WIDTH(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorX = MulDiv(dwDstWidth,  1000, dwSrcWidth);

    switch (m_DecimationModeX) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {
            dwDecNumX = dwCurZoomFactorX;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN X")));
        while ((DWORD)MulDiv(dwDstWidth, dwDecDenX, dwSrcWidth)
                < dwMinZoomFactorX)
        {
            dwDecDenX *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {

            dwDecNumX = MulABC_DivDE(dwDstWidth, m_ulDeciStepX, 1000,
                                     dwMinZoomFactorX, dwSrcWidth);
            dwDecDenX = m_ulDeciStepX;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumX = %d dwDecDenX = %d"),
                    dwDecNumX, dwDecDenX ));
        }
        break;
    }


    //
    // Determine the adjustment for the y axis.
    //
    DWORD dwDecNumY = 1000;
    DWORD dwDecDenY = 1000;
    DWORD dwDstHeight = HEIGHT(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorY = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    switch (m_DecimationModeY) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {
            dwDecNumY = dwCurZoomFactorY;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN Y")));
        while ((DWORD)MulDiv(dwDecDenY, dwDstWidth, dwSrcWidth)
                < dwMinZoomFactorY)
        {
            dwDecDenY *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {

            dwDecNumY = MulABC_DivDE(dwDstHeight, m_ulDeciStepY, 1000,
                                     dwMinZoomFactorY, dwSrcHeight);
            dwDecDenY = m_ulDeciStepY;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumY = %d dwDecDenY = %d"),
                    dwDecNumY, dwDecDenY ));
        }
        break;
    }

    return VideoPortDecimationBackend(pWinInfo, dwDecNumX, dwDecDenX,
                                      dwDecNumY, dwDecDenY);
}



/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::BeyondOverlayCaps(
    DWORD ScaleFactor,
    DWORD xMin,
    DWORD yMin
    )
{
    return ScaleFactor < xMin || ScaleFactor < yMin;
}



/*****************************Private*Routine******************************\
* TryDecoderDecimation
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CAMVideoPort::TryDecoderDecimation(
    LPWININFO pWinInfo
    )
{
    //
    // Extract the width and height that we are trying to decimate
    // the video image down too
    //

    DWORD dwWidth = WIDTH(&pWinInfo->DestRect);
    DWORD dwHeight = HEIGHT(&pWinInfo->DestRect);


    //
    // Try to use the new IDecimateVideoImage interface on our upstream
    // filter
    //

    IDecimateVideoImage* lpDVI;
    HRESULT hr = m_pIVPControl->GetVideoDecimation(&lpDVI);
    if (SUCCEEDED(hr)) {
        hr = lpDVI->SetDecimationImageSize(dwWidth, dwHeight);
        lpDVI->Release();
    }


    //
    // If that failed try to decimate using the old IVPConfig interface
    //

    if (FAILED(hr)) {

        AMVPSIZE amvpSize;
        amvpSize.dwWidth = dwWidth;
        amvpSize.dwHeight = dwHeight;

        DbgLog((LOG_TRACE, 1,
                TEXT("SetScalingFactors to (%d, %d)"),
                amvpSize.dwWidth, amvpSize.dwHeight));

        hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
    }

    //
    // If we were successful update our state variables
    //
    if (SUCCEEDED(hr)) {

        m_bDecimating = TRUE;
        pWinInfo->SrcRect.right = m_lWidth = dwWidth;
        pWinInfo->SrcRect.bottom = m_lHeight = dwHeight;
    }
    else {
        ResetDecoderDecimationIfSet();
        hr = E_FAIL;
    }

    return hr;
}



/*****************************Private*Routine******************************\
* ResetVPDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::ResetVPDecimationIfSet()
{
    BOOL bUpdateRequired = m_bVPDecimating;
    if (m_bVPDecimating) {

        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;

        m_bVPDecimating = FALSE;
        m_dwDeciNumX = m_dwDeciDenX = 1000;
        m_dwDeciNumY = m_dwDeciDenY = 1000;
    }

    return bUpdateRequired;
}



/*****************************Private*Routine******************************\
* ResetDecoderDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
void
CAMVideoPort::ResetDecoderDecimationIfSet()
{
    if (m_bDecimating) {

        IDecimateVideoImage* lpDVI;
        HRESULT hr = m_pIVPControl->GetVideoDecimation(&lpDVI);
        if (SUCCEEDED(hr)) {
            hr = lpDVI->ResetDecimationImageSize();
            lpDVI->Release();
        }


        if (FAILED(hr)) {
            AMVPSIZE amvpSize;
            amvpSize.dwWidth = m_lDecoderImageWidth;
            amvpSize.dwHeight = m_lDecoderImageHeight;

            DbgLog((LOG_TRACE,1,
                    TEXT("SetScalingFactors to (%d, %d)"),
                    amvpSize.dwWidth, amvpSize.dwHeight));

            hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
        }

        if (SUCCEEDED(hr)) {
            m_bDecimating = FALSE;
            m_lWidth = 0;
            m_lHeight = 0;
        }
    }
}



/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Video Port case
*
* This is where we enforce the chosen decimation strategy for the Video Port
* case.
*
* History:
* Tue 07/13/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::ApplyDecimation(
    LPWININFO pWinInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating
    )
{
    AMTRACE((TEXT("CAMVideoPort::ApplyDecimation")));
    BOOL bUpdateRequired = FALSE;

    DECIMATION_USAGE dwUsage;
    m_pIVPControl->GetDecimationUsage(&dwUsage);


    //
    // Determine the current min zoom factors givin the current overlay and
    // video port connection
    //

    DWORD dwMinZoomX, dwMinZoomY;
    GetMinZoomFactors(pWinInfo, bColorKeying, bYInterpolating,
                      &dwMinZoomX, &dwMinZoomY);

    if ((dwUsage == DECIMATION_LEGACY) ||
        (dwUsage == DECIMATION_DEFAULT && m_fCapturing)) {

        bUpdateRequired = AdjustSourceSize(pWinInfo,
                                           dwMinZoomX,
                                           dwMinZoomY);
    }


    else {

        if (Running()) {

            DWORD ScaleFactor = ::GetCurrentScaleFactor(pWinInfo);
            if (IsDecimationNeeded(ScaleFactor)) {

                switch (dwUsage) {

                case DECIMATION_USE_OVERLAY_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    m_pIVPControl->CropSourceRect(pWinInfo,
                                                  dwMinZoomX,
                                                  dwMinZoomY);
                    break;

                case DECIMATION_USE_DECODER_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        m_pIVPControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_USE_VIDEOPORT_ONLY:
                    ResetDecoderDecimationIfSet();
                    if (TryVideoPortDecimation(pWinInfo, 1000,
                                               1000,
                                               &bUpdateRequired) != S_OK) {

                        m_pIVPControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_DEFAULT:
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        if (BeyondOverlayCaps(ScaleFactor, dwMinZoomX,
                                              dwMinZoomY)) {

                            if (TryVideoPortDecimation(pWinInfo,
                                                       dwMinZoomX,
                                                       dwMinZoomY,
                                                       &bUpdateRequired) != S_OK) {

                                m_pIVPControl->CropSourceRect(pWinInfo,
                                                              dwMinZoomX,
                                                              dwMinZoomY);
                            }
                        }
                    }
                    break;
                }
            }
            else {

                ResetDecoderDecimationIfSet();
                bUpdateRequired = ResetVPDecimationIfSet();
            }
        }


        else {

            if (m_bVPDecimating) {

                //
                // Apply the current pre-scale to the source image.
                //

                RECT &rcSrc = pWinInfo->SrcRect;
                rcSrc.left = MulDiv(rcSrc.left, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.top = MulDiv(rcSrc.top, m_dwDeciNumY, m_dwDeciDenY);
                rcSrc.right = MulDiv(rcSrc.right, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.bottom = MulDiv(rcSrc.bottom, m_dwDeciNumY, m_dwDeciDenY);
            }

            if (m_bDecimating) {

                //
                // Apply the current decoder decimation to the source image.
                //

                pWinInfo->SrcRect.right = m_lWidth;
                pWinInfo->SrcRect.bottom = m_lHeight;
            }

            //
            // Then make sure that any shrinking falls within the capabilities
            // of the scaler on the VGA chip, cropping if necessary.
            //

            m_pIVPControl->CropSourceRect(pWinInfo, dwMinZoomX, dwMinZoomY);
        }
    }

    return bUpdateRequired;
}
/******************************Public*Routine******************************\
* MulABC_DivDE
*
* Performs the following calculation:  ((A*B*C) / (D*E)) rounding the result
* to the nearest integer.
*
* History:
* 3/3/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD MulABC_DivDE(DWORD A, DWORD B, DWORD C, DWORD D, DWORD E)
{

    unsigned __int64 Num = (unsigned __int64)A * (unsigned __int64)B;
    unsigned __int64 Den = (unsigned __int64)D * (unsigned __int64)E;

    if (Den == 0) {
        Den = 1;
    }

    Num *= (unsigned __int64)C;
    Num += (Den / 2);

    unsigned __int64 Res = Num / Den;

    return (DWORD)Res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\macvis.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// MacVis.cpp:  Overlay Mixer's Macrovision support code
//

#include <streams.h>
#include <windowsx.h>

#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx
#include <macvis.h>
#include <ovmixer.h>

CDispMacroVision::CDispMacroVision(COMFilter *pOvMFilter)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::CDispMacroVision(0x%lx)"), pOvMFilter)) ;
    m_dwCPKey = 0 ;
    m_pOvMFilter = pOvMFilter ;
}


CDispMacroVision::~CDispMacroVision(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::~CDispMacroVision()"))) ;
    SetMacroVision(0) ;
    StopMacroVision() ;
    ASSERT(0 == m_dwCPKey) ;
}


//
// This is a wrapper function to get the correct HMONITOR from the OverlayMixer.
//
HMONITOR
CDispMacroVision::GetMonitor(void)
{
    HMONITOR  hMon ;
    ASSERT(m_pOvMFilter) ;
    hMon = m_pOvMFilter->GetCurrentMonitor() ;
    DbgLog((LOG_TRACE, 3, TEXT("Monitor handle is %ld"), hMon)) ;
    return hMon ;
}


BOOL
CDispMacroVision::StopMacroVision()
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::StopMacroVision()"))) ;

    if (0 == m_dwCPKey)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Copy prot key was not acquired. Nothing to release."))) ;
        return TRUE ;  // success, what else?
    }

    HMONITOR  hMon = GetMonitor() ;

    MONITORINFOEX  mi ;
    mi.cbSize = sizeof(mi) ;
    if (! GetMonitorInfo(hMon, &mi) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetMonitorInfo() failed (Error: %ld)"),
                GetLastError())) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("DeviceName: '%s'"), mi.szDevice)) ;

    LONG             lRet ;
    VIDEOPARAMETERS  VidParams ;
    DEVMODE          DevMode ;
    // DISPLAY_DEVICE   dd ;
    // ZeroMemory(&dd, sizeof(dd)) ;
    // dd.cb = sizeof(dd) ;

    ZeroMemory(&DevMode, sizeof(DevMode)) ;
    DevMode.dmSize = sizeof(DevMode) ;

    ZeroMemory(&VidParams, sizeof(VidParams)) ;
    VidParams.Guid      = guidVidParam ;
    VidParams.dwCommand = VP_COMMAND_GET ;

    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx(_GET) failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    if (! ( (VidParams.dwFlags & VP_FLAGS_COPYPROTECT) &&
            (VidParams.dwCPType & VP_CP_TYPE_APS_TRIGGER) &&
            (VidParams.dwTVStandard & VidParams.dwCPStandard) ) )
    {
        // How did we acquire CP key in teh first place?
        DbgLog((LOG_ERROR, 0,
            TEXT("Copy prot weird error case (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;
        return FALSE ;
    }

    VidParams.dwCommand    = VP_COMMAND_SET ;
    VidParams.dwFlags      = VP_FLAGS_COPYPROTECT ;
    VidParams.dwCPType     = VP_CP_TYPE_APS_TRIGGER ;
    VidParams.dwCPCommand  = VP_CP_CMD_DEACTIVATE ;
    VidParams.dwCPKey      = m_dwCPKey ;
    VidParams.bCP_APSTriggerBits = (BYTE) 0 ;  // some value
    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx() failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    DbgLog((LOG_TRACE, 1, TEXT("Macrovision deactivated on key %lu"), m_dwCPKey)) ;
    m_dwCPKey = 0 ;

    return TRUE ;
}


//
// This function applies Macrovision based on the input parameter dwCPBits.
// hWnd is the handle of the window in which content is played back.
//
// Returns TRUE on success and FALSE on any failure.
//
BOOL
CDispMacroVision::SetMacroVision(DWORD dwCPBits)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::SetMacroVision(0x%lx)"), dwCPBits)) ;

    //
    // If MV is currently not set at all and the new CP bits is 0 (which happens
    // when from the Nav we reset the MV bits on start / stop of playback), we
    // don't really need to do anything -- MV not started and doesn't need to be
    // started.  So just leave queitly...
    //
    if (0 == m_dwCPKey  &&  // no key acquired so far
        0 == dwCPBits)      // MV CPBits is 0
    {
        DbgLog((LOG_TRACE, 1, TEXT("Copy prot is not enabled now and new CP bits is 0 -- so skip it."))) ;
        return TRUE ;  // we don't need to do anything, so success.
    }

    HMONITOR  hMon = GetMonitor() ;

    MONITORINFOEX  mi ;
    mi.cbSize = sizeof(mi) ;
    if (! GetMonitorInfo(hMon, &mi) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetMonitorInfo() failed (Error: %ld)"),
                GetLastError())) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("DeviceName: '%s'"), mi.szDevice)) ;

    LONG             lRet ;
    VIDEOPARAMETERS  VidParams ;
    DEVMODE          DevMode ;
    // DISPLAY_DEVICE   dd ;
    // ZeroMemory(&dd, sizeof(dd)) ;
    // dd.cb = sizeof(dd) ;

    ZeroMemory(&DevMode, sizeof(DevMode)) ;
    DevMode.dmSize = sizeof(DevMode) ;

    ZeroMemory(&VidParams, sizeof(VidParams)) ;
    VidParams.Guid      = guidVidParam ;
    VidParams.dwCommand = VP_COMMAND_GET ;

    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx(_GET) failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    if (0 == VidParams.dwFlags ||
        VP_TV_STANDARD_WIN_VGA == VidParams.dwTVStandard)
    {
        DbgLog((LOG_TRACE, 1, TEXT("** Copy protection NOT required (dwFlags=0x%lx, dwTVStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwTVStandard));
        return TRUE ;
    }

    //
    // Check to see if
    // a) the device supports copy prot
    // b) CP type is APS trigger
    // c) current TV standard and CP standard have commonality.
    // If so, apply copy prot. Otherwise error.
    //
    if ( (VidParams.dwFlags & VP_FLAGS_COPYPROTECT) &&
         (VidParams.dwCPType & VP_CP_TYPE_APS_TRIGGER) &&
         (VidParams.dwTVStandard & VidParams.dwCPStandard) )
    {
        DbgLog((LOG_TRACE, 3,
            TEXT("** Copy prot needs to be applied (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;

        VidParams.dwCommand = VP_COMMAND_SET ;          // do we have to set it again??
        VidParams.dwFlags   = VP_FLAGS_COPYPROTECT ;
        VidParams.dwCPType  = VP_CP_TYPE_APS_TRIGGER ;
        VidParams.bCP_APSTriggerBits = (BYTE) (dwCPBits & 0xFF) ;

        // Check if we already have a copy prot key; if not, get one now
        if (0 == m_dwCPKey)  // no key acquired so far
        {
            // Acquire a new key (that also aplies it, so no separate Set reqd)
            VidParams.dwCPCommand = VP_CP_CMD_ACTIVATE ;
            VidParams.dwCPKey     = 0 ;
            lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                           CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                           &VidParams) ;
            if (DISP_CHANGE_SUCCESSFUL != lRet)
            {
                DbgLog((LOG_ERROR, 0,
                    TEXT("** ChangeDisplaySettingsEx() failed (%ld) to activate copy prot"), lRet)) ;
                return FALSE ;
            }

            m_dwCPKey = VidParams.dwCPKey ;
            DbgLog((LOG_TRACE, 3, TEXT("** Copy prot activated. Key value is %lu"), m_dwCPKey)) ;
        }
        else  // key already acquired
        {
            // apply the copy prot bits specified in the content
            VidParams.dwCPCommand = VP_CP_CMD_CHANGE ;
            VidParams.dwCPKey     = m_dwCPKey ;
            DbgLog((LOG_TRACE, 5, TEXT("** Going to call ChangeDisplaySettingsEx(_SET)..."))) ;
            lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                           CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                           &VidParams) ;
            if (DISP_CHANGE_SUCCESSFUL != lRet)
            {
                DbgLog((LOG_ERROR, 0,
                    TEXT("** ChangeDisplaySettingsEx() failed (%ld) to set copy prot bits (%lu)"),
                    lRet, dwCPBits)) ;
                return FALSE ;
            }
            else
                DbgLog((LOG_TRACE, 3, TEXT("** Copy prot bits (0x%lx) applied"), dwCPBits)) ;
        }
    }
    else
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("** Copy prot error case (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;
        return FALSE ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\ddva.h ===
/*==========================================================================;
 *
 *  Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE4    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE4    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE4, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\macvis.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
// MacVis.h: Overlay Mixer's MacroVision support code header
//

#ifndef __MACVIS_H__
#define __MACVIS_H__


//
// The magic GUID for Macrovision etc enabling (from winuser.h). It has 
// not been given a name there and so is used here directly.
//
static const GUID guidVidParam = 
    {0x2c62061, 0x1097, 0x11d1, {0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e}} ;

//
// Combination of all the VP_TV_XXX flags (w/o _WIN_VGA) gives 0x7FFF
//
#define ValidTVStandard(dw)  (dw & 0x7FFF)

//
// MacroVision implementation wrapped in a class for Overlay Mixer
//
class CDispMacroVision {

    public:
        CDispMacroVision(COMFilter *pOvMFilter) ;
        ~CDispMacroVision(void) ;

        BOOL      SetMacroVision(DWORD dwCPBits) ;
        BOOL      StopMacroVision(void) ;
        HMONITOR  GetMonitor(void) ;

    private:
        DWORD         m_dwCPKey ;
        COMFilter    *m_pOvMFilter ;
} ;

#endif // __MACVIS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\omoutpin.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include <dvdmedia.h>
#include <macvis.h>
#include <ovmixer.h>
#include <resource.h>
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx

// constructor
COMOutputPin::COMOutputPin(TCHAR *pObjectName, COMFilter *pFilter, CCritSec *pLock,
			   HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo)
			   : CBaseOutputPin(pObjectName, pFilter, pLock, phr, pPinName)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::Constructor")));

    m_pFilterLock = pLock;

    m_pPosition = NULL;
    m_dwPinId = dwPinNo;
    m_pFilter = pFilter;
    m_pIOverlay = NULL;
    m_bAdvise = FALSE;
    m_pDrawClipper = NULL;

    // stuff to handle the new winproc of the window
    m_bWindowDestroyed = TRUE;
    m_lOldWinUserData = 0;
    m_hOldWinProc = NULL;

    m_hwnd = NULL;
    m_hDC = NULL;
    m_dwConnectWidth = 0;
    m_dwConnectHeight = 0;

//CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::Constructor")));
    return;
}

// destructor
COMOutputPin::~COMOutputPin()
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::Destructor")));

    CAutoLock cLock(m_pFilterLock);

    if (m_pPosition)
    {
        m_pPosition->Release();
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::Destructor")));

    return;
}

// overriden to expose IMediaPosition and IMediaSeeking control interfaces
STDMETHODIMP COMOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::NonDelegatingQueryInterface")));

    CAutoLock cLock(m_pFilterLock);

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking)
    {
        // we should have an input pin by now
        if (m_pPosition == NULL)
        {
            hr = CreatePosPassThru(GetOwner(), FALSE, (IPin *)m_pFilter->GetPin(0), &m_pPosition);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
        hr = m_pPosition->QueryInterface(riid, ppv);
        goto CleanUp;
    }

    DbgLog((LOG_TRACE, 5, TEXT("QI'ing CBaseOutputPin")));
    hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2, TEXT("CBaseOutputPin::NonDelegatingQueryInterface(riid) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::NonDelegatingQueryInterface")));
    return hr;
}

// check a given transform
HRESULT COMOutputPin::CheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::CheckMediaType")));

    CAutoLock cLock(m_pFilterLock);

    // we only allow a subtype overlay connection
    if (pmt->majortype != MEDIATYPE_Video || pmt->subtype != MEDIASUBTYPE_Overlay)
    {
	hr = S_FALSE;
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pFilter->CheckMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5, TEXT("m_pFilter->CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::CheckMediaType")));
    return hr;
}

// Propose with a MEDIASUBTYPE_Overlay
HRESULT COMOutputPin::GetMediaType(int iPosition,CMediaType *pmt)
{
    HRESULT hr = NOERROR;
    DWORD dwConnectWidth = 0;
    DWORD dwConnectHeight = 0;
    VIDEOINFOHEADER *pvi = NULL;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::GetMediaType")));

    CAutoLock cLock(m_pFilterLock);

    //  Can't be < 0 - it's the base classes calling us
    ASSERT(iPosition >= 0);

    if (iPosition > 0)
    {
        hr = VFW_S_NO_MORE_ITEMS;
        goto CleanUp;
    }

    // I am allocating a large enough buffer for palettized and non-palettized formats
    pvi = (VIDEOINFOHEADER *) pmt->AllocFormatBuffer(sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));
    if (NULL == pvi)
    {
	DbgLog((LOG_ERROR, 1, TEXT("pmt->AllocFormatBuffer failed")));
	hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    ZeroMemory(pvi, sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));


    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->majortype = MEDIATYPE_Video;
    pmt->subtype   = MEDIASUBTYPE_Overlay;
    pmt->bFixedSizeSamples    = FALSE;
    pmt->bTemporalCompression = FALSE;
    pmt->lSampleSize          = 0;

    // We set the BITMAPINFOHEADER to be a really basic eight bit palettised
    // format so that the video renderer will always accept it. We have to
    // provide a valid media type as source filters can swap between the
    // IMemInputPin and IOverlay transports as and when they feel like it

    pHeader = HEADER(pvi);

    dwConnectWidth = DEFAULT_WIDTH;
    dwConnectHeight = DEFAULT_HEIGHT;

    pHeader->biWidth  = dwConnectWidth;
    pHeader->biHeight = dwConnectHeight;

    pHeader->biSize   = sizeof(BITMAPINFOHEADER);
    pHeader->biPlanes = 1;
    pHeader->biBitCount = 8;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::GetMediaType")));
    return hr;
}

// called after we have agreed a media type to actually set it
HRESULT COMOutputPin::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::SetMediaType")));

    CAutoLock cLock(m_pFilterLock);

    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Set the base class media type (should always succeed)
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pFilter->SetMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::SetMediaType")));
    return hr;
}

// Complete Connect
HRESULT COMOutputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    DWORD dwAdvise = 0, dwInputPinCount = 0, i = 0;
    COLORKEY ColorKey;
    VIDEOINFOHEADER *pVideoInfoHeader = NULL;
    DDSURFACEDESC SurfaceDescP;
    COMInputPin *pInputPin = NULL;
    BOOL bDoDeletePrimSurface = TRUE;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::CompleteConnect")));

    CAutoLock cLock(m_pFilterLock);

    // get the connection mediatype dimensions and store them
    pVideoInfoHeader = (VIDEOINFOHEADER *) (m_mt.Format());
    ASSERT(pVideoInfoHeader);
    m_dwConnectWidth = (DWORD)abs(pVideoInfoHeader->bmiHeader.biWidth);
    m_dwConnectHeight = (DWORD)abs(pVideoInfoHeader->bmiHeader.biHeight);
    ASSERT(m_dwConnectWidth > 0 && m_dwConnectHeight > 0);

    // try to get the IOverlay interface	
    hr = pReceivePin->QueryInterface(IID_IOverlay, (void **)&m_pIOverlay);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 1, TEXT("QueryInterface for IOverlay failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // get the renderer's window handle to subclass it later
    hr = m_pIOverlay->GetWindowHandle(&m_hwnd);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 1, TEXT("m_pIOverlay->GetWindowHandle failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    m_hDC = ::GetDC(m_hwnd);
    ASSERT(m_hDC);

    if (m_bWindowDestroyed)
    {
	// subclass the window
        hr = SetNewWinProc();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("SetNewWinProc failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
	
        m_bWindowDestroyed = FALSE;
    }

    // set up the advise link
#ifdef DO_ADVISE_CLIPPING
    dwAdvise = ADVISE_CLIPPING | ADVISE_PALETTE;
#else
    dwAdvise = ADVISE_POSITION | ADVISE_PALETTE;
#endif
    hr = m_pIOverlay->Advise(m_pFilter, dwAdvise);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 1, TEXT("m_pIOverlay->Advise failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_bAdvise = TRUE;

    hr = AttachWindowClipper();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 1, TEXT("AttachWindowClipper failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    //
    // We want to know if the downstream filter we are connecting to can do MacroVision
    // copy protection. This will help us do copy protection in OverlayMixer on a
    // "if necessary" basis.
    // SIDE ADVANTAGE: Even if someone writes a custom Video Renderer filter that doesn't
    // do Macrovision, our copy protection will still work, because OverlayMixer will do it.
    // THE DISADVANTAGE: if someone puts in a filter between OverlayMixer and Video
    // Renderer then the following check will detect is as "no copy protection" from the
    // Video Renderer and will do it itself which may cause double activate leading to
    // failure on some display drivers.  But that doesn't happen anyway.
    //
    IKsPropertySet *pKsPS ;
    ULONG           ulTypeSupport ;
    PIN_INFO        pi ;
    pReceivePin->QueryPinInfo(&pi) ;
    if (pi.pFilter)
    {
        if (SUCCEEDED(pi.pFilter->QueryInterface(IID_IKsPropertySet, (LPVOID *)&pKsPS)))
        {
            DbgLog((LOG_TRACE, 5, TEXT("Filter of pin %s supports IKsPropertySet"), (LPCTSTR)CDisp(pReceivePin))) ;
            if ( S_OK == pKsPS->QuerySupported(
                                    AM_KSPROPSETID_CopyProt,
                                    AM_PROPERTY_COPY_MACROVISION,
                                    &ulTypeSupport)  &&
                 (ulTypeSupport & KSPROPERTY_SUPPORT_SET) )
            {
                DbgLog((LOG_TRACE, 1, TEXT("Filter for pin %s supports copy protection"),
                        (LPCTSTR)CDisp(pReceivePin))) ;
                m_pFilter->SetCopyProtect(FALSE) ;  // need NOT copy protect
            }
            else
            {
                DbgLog((LOG_TRACE, 1, TEXT("Filter for pin %s DOES NOT support copy protection"),
                        (LPCTSTR)CDisp(pReceivePin))) ;
                m_pFilter->SetCopyProtect(TRUE) ;   // need to copy protect -- redundant setting
            }

            pKsPS->Release() ;
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("WARNING: Filter of pin %s doesn't support IKsPropertySet"),
                    (LPCTSTR)CDisp(pReceivePin))) ;
        }
        pi.pFilter->Release() ;   // must release it now
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: No pin info for Pin %s!!!"), (LPCTSTR)CDisp(pReceivePin))) ;
    }

    // call the base class
    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::CompleteConnect failed, hr = 0x%x"),
            hr));
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pFilter->CompleteConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // get the colorkey and use it if the upstream filter hasn't set it
    // already
    if (!m_pFilter->ColorKeySet()) {
        hr = m_pIOverlay->GetDefaultColorKey(&ColorKey);
        if (SUCCEEDED(hr)) {
            COMInputPin *pInputPin = (COMInputPin *)m_pFilter->GetPin(0);
            if (pInputPin) {
                pInputPin->SetColorKey(&ColorKey);
            }
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::CompleteConnect")));
    return hr;
}

HRESULT COMOutputPin::BreakConnect()
{
    HRESULT hr = NOERROR;
    DWORD dwInputPinCount = 0, i = 0;
    COMInputPin *pInputPin;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::BreakConnect")));

    CAutoLock cLock(m_pFilterLock);

    if (m_hDC)
    {
        ReleaseDC(m_hwnd, m_hDC);
        m_hDC = NULL;
    }

    if (!m_bWindowDestroyed)
    {
        SetOldWinProc();
	
	m_bWindowDestroyed = TRUE;
    }

    // release the IOverlay interface
    if (m_pIOverlay != NULL)
    {
        if (m_bAdvise)
        {
            m_pIOverlay->Unadvise();
            m_bAdvise = FALSE;
        }
        m_pIOverlay->Release();
        m_pIOverlay = NULL;
    }

    // Reset copy protection need flag on disconnect
    m_pFilter->SetCopyProtect(TRUE) ;   // need to copy protect

    // call the base class
    hr = CBaseOutputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::BreakConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pFilter->BreakConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->BreakConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::BreakConnect")));
    return hr;
}

// we don't use the memory based transport so all we care about
// is that the pin is connected.
HRESULT COMOutputPin::DecideBufferSize(IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES * pProp)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::DecideBufferSize")));

    CAutoLock cLock(m_pFilterLock);

    if (!IsConnected())
    {
        DbgBreak("DecideBufferSize called when !m_pOutput->IsConnected()");
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::DecideBufferSize")));
    return hr;
}

struct MONITORDATA {
    HMONITOR hMonPB;
    BOOL fMsgShouldbeDrawn;
};

/*****************************Private*Routine******************************\
* MonitorEnumProc
*
* On Multi-Monitor systems make sure that the part of the window that is not
* on the primary monitor is black.
*
* History:
* Thu 06/03/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL CALLBACK
MonitorEnumProc(
  HMONITOR hMonitor,        // handle to display monitor
  HDC hdc,                  // handle to monitor-appropriate device context
  LPRECT lprcMonitor,       // pointer to monitor intersection rectangle
  LPARAM dwData             // data passed from EnumDisplayMonitors
  )
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering ::MonitorEnumProc")));
    MONITORDATA* lpmd = (MONITORDATA*)dwData;

    if (lpmd->hMonPB != hMonitor) {
        FillRect(hdc, lprcMonitor, (HBRUSH)GetStockObject(BLACK_BRUSH));
        lpmd->fMsgShouldbeDrawn = TRUE;
    }
    DbgLog((LOG_TRACE, 5, TEXT("Leaving ::MonitorEnumProc")));
    return TRUE;
}


// our winproc
// All we are interested in is the WM_CLOSE event
extern "C" const TCHAR chMultiMonWarning[];
extern int GetRegistryDword(HKEY hk, const TCHAR *pKey, int iDefault);
LRESULT WINAPI COMOutputPin::NewWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LONG_PTR lNewUserData;
    DWORD errCode;
    WNDPROC hOldWinProc;
    COMOutputPin* pData = NULL;
    LRESULT lRetVal = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::NewWndProc")));
    SetLastError(0);
    lNewUserData = GetWindowLongPtr(hWnd, GWLP_USERDATA);
    errCode = GetLastError();

    if (!lNewUserData && errCode != 0)
    {
	DbgLog((LOG_ERROR,0,TEXT("GetWindowLong failed, THIS SHOULD NOT BE HAPPENING!!!")));
        goto CleanUp;
    }

    pData = (COMOutputPin*)lNewUserData;
    ASSERT(pData);
    hOldWinProc = pData->m_hOldWinProc;
    if (!hOldWinProc) {
        goto CleanUp;
    }


    //
    // Look out for our special registered monitor changed message
    //
    if (message == pData->m_pFilter->m_MonitorChangeMsg) {
	lRetVal = pData->m_pFilter->OnDisplayChange(FALSE);
	goto CleanUp;
    }


    switch (message) {

    case WM_TIMER :
	pData->m_pFilter->OnTimer();
	break;

    case WM_SHOWWINDOW :
	// if show status is false, means window is being hidden
	pData->m_pFilter->OnShowWindow(hWnd, (BOOL)wParam);
	break;

#ifdef DEBUG
    case WM_DISPLAY_WINDOW_TEXT:
        SetWindowText(hWnd, pData->m_pFilter->m_WindowText);
        break;
#endif
    case WM_PAINT :
        pData->m_pFilter->OnDrawAll();

        if (GetSystemMetrics(SM_CMONITORS) > 1 ) {

            lRetVal = 0;

            PAINTSTRUCT ps;
            MONITORDATA md;

            md.hMonPB = pData->m_pFilter->GetCurrentMonitor(FALSE);
            md.fMsgShouldbeDrawn = FALSE;
            HDC hdc = BeginPaint(hWnd, &ps);
            EnumDisplayMonitors(hdc, NULL, MonitorEnumProc,(LPARAM)&md);

            if (md.fMsgShouldbeDrawn &&
                pData->m_pFilter->m_fMonitorWarning &&
                GetRegistryDword(HKEY_CURRENT_USER, chMultiMonWarning, 1)) {

                RECT rc;
                TCHAR sz[256];

                if (LoadString(g_hInst, IDS_HW_LIMIT, sz, 256)) {
                    GetClientRect(hWnd, &rc);
                    SetBkColor(hdc, RGB(0,0,0));
                    SetTextColor(hdc, RGB(255,255,0));
                    DrawText(hdc, sz, -1, &rc, DT_CENTER | DT_WORDBREAK);
                }
            }

            EndPaint(hWnd, &ps);

            // We goto CleanUp because we don't want the Video Renderer
            // window procedure calling BeginPaint/EndPaint

            goto CleanUp;
        }

        break;
	
        //
        // When we detect a display change we tell the filter about it
        // We don't pass this message on to the Video Renderer window
        // procedure because we don't want it starting the
        // reconnection procedure all over again.
        //
    case WM_DISPLAYCHANGE:
	lRetVal = pData->m_pFilter->OnDisplayChange(TRUE);
	goto CleanUp;
	
    default:
	break;
    }

    lRetVal = CallWindowProc(hOldWinProc, hWnd, message, wParam, lParam);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::NewWndProc")));
    return lRetVal;
}


// function to subclass the renderers window
HRESULT COMOutputPin::SetNewWinProc()
{
    HRESULT hr = NOERROR;
    DWORD errCode;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::SetNewWinProc")));

    CAutoLock cLock(m_pFilterLock);

    ASSERT(m_hwnd);	

    SetLastError(0);
    m_lOldWinUserData = SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)this);
    errCode = GetLastError();

    if (!m_lOldWinUserData && errCode != 0)
    {
	DbgLog((LOG_ERROR, 1, TEXT("SetNewWinProc->SetWindowLong failed, errCode = %d"), errCode));
        hr = E_FAIL;
        goto CleanUp;
    }
    else
    {
	DbgLog((LOG_TRACE, 2, TEXT("new WinUserData value = %d, old val was %d"), this, m_lOldWinUserData));
    }


    SetLastError(0);
    m_hOldWinProc = (WNDPROC)SetWindowLongPtr(m_hwnd, GWLP_WNDPROC, (LONG_PTR)NewWndProc);
    errCode = GetLastError();

    if (!m_hOldWinProc && errCode != 0)
    {
	DbgLog((LOG_ERROR,0,TEXT("SetNewWinProc->SetWindowLong failed, errCode = %d"), errCode));
        hr = E_FAIL;
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::SetNewWinProc")));
    return NOERROR;
}

//change back to the oldWinProc again
HRESULT COMOutputPin::SetOldWinProc()
{
    HRESULT hr = NOERROR;
    LONG_PTR lOldWinProc;
    DWORD errCode;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::SetOldWinProc")));

    CAutoLock cLock(m_pFilterLock);

    if (m_hOldWinProc)
    {
	SetLastError(0);
	lOldWinProc = SetWindowLongPtr(m_hwnd, GWLP_WNDPROC, (LONG_PTR)m_hOldWinProc);
	errCode = GetLastError();
	
	if (!lOldWinProc && errCode != 0)
	{
	    DbgLog((LOG_ERROR,0,TEXT("SetWindowLong failed, errCode = %d"), errCode));
	    hr = E_FAIL;
	    goto CleanUp;
	}
	else
	{
	    DbgLog((LOG_ERROR,0,TEXT("GOING BACK TO OLD WINPROC : NewWinProc->SetWindowLong succeeded")));
            m_hOldWinProc = 0;
	    goto CleanUp;
	}
    }
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::SetOldWinProc")));
    return hr;
}

// release the clipper for the primary surface
DWORD COMOutputPin::ReleaseWindowClipper()
{
    AMTRACE((TEXT("COMOutputPin::ReleaseWindowClipper")));
    CAutoLock cLock(m_pFilterLock);
    DWORD dwRefCnt = 0;

    if (m_pDrawClipper)
    {
	dwRefCnt = m_pDrawClipper->Release();

        //
        // The ref should be 1 here not zero, this is because the
        // primary surface has a ref count on the clipper.  The
        // clipper will get released when the primary surface is
        // released
        //

        ASSERT(dwRefCnt == 1);
	m_pDrawClipper = NULL;
    }

    return dwRefCnt;
}

// Prepare the clipper for the primary surface
HRESULT COMOutputPin::AttachWindowClipper()
{
    HRESULT hr = NOERROR;
    LPDIRECTDRAW pDirectDraw = NULL;
    LPDIRECTDRAWSURFACE pPrimarySurface = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::AttachWindowClipper")));

    CAutoLock cLock(m_pFilterLock);

    // some asserts
    ASSERT(m_pDrawClipper == NULL);

    pDirectDraw = m_pFilter->GetDirectDraw();
    if (!pDirectDraw)
    {
	DbgLog((LOG_ERROR, 1, TEXT("pDirectDraw = NULL")));
        // if there is no primary surface that is ok
	hr = NOERROR;
        goto CleanUp;
    }

    pPrimarySurface = m_pFilter->GetPrimarySurface();
    if (!pPrimarySurface)
    {
	DbgLog((LOG_ERROR, 1, TEXT("pPrimarySurface = NULL")));
        // if there is no primary surface that is ok
	hr = NOERROR;
        goto CleanUp;
    }

    // Create the IDirectDrawClipper interface
    hr = pDirectDraw->CreateClipper((DWORD)0, &m_pDrawClipper, NULL);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 1, TEXT("Function ClipPrepare, CreateClipper failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Give the clipper the video window handle
    hr = m_pDrawClipper->SetHWnd((DWORD)0, m_hwnd);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 1, TEXT("Function ClipPrepare, SetHWnd failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    //
    // Set Clipper
    // The primary surface AddRef's the clipper object, so we can
    // delete it here as we don't need to reference it anymore.
    //
    hr = pPrimarySurface->SetClipper(m_pDrawClipper);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR,0, TEXT("Function ClipPrepare, SetClipper failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

CleanUp:
    ReleaseWindowClipper();
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::AttachWindowClipper")));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\omva.cpp ===
/******************************Module*Header*******************************\
* Module Name: omva.cpp
*
* Overlay mixer video accelerator functionality
*
* Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/

#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>     // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <dvdmedia.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include <macvis.h>
#include <ovmixer.h>
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx
#include <malloc.h>


//
//  Check if a media subtype GUID is a video accelerator type GUID
//
//  This function calls the DirectDraw video accelerator container
//  to list the video accelerator GUIDs and checks to see if the
//  Guid passed in is a supported video accelerator GUID.
//
//  We should only do this if the upstream pin support IVideoAccleratorNotify
//  since otherwise they may be trying to use the GUID without the
//  video accelerator interface
//
BOOL COMInputPin::IsSuitableVideoAcceleratorGuid(const GUID * pGuid)
{
    HRESULT hr = NOERROR;
    LPDIRECTDRAW pDirectDraw = NULL;
    DWORD dwNumGuidsSupported = 0, i = 0;
    LPGUID pGuidsSupported = NULL;
    BOOL bMatchFound = FALSE;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::IsSuitableVideoAcceleratorGuid")));

    ASSERT(pGuid);

    if (!m_pIDDVAContainer)
    {
        pDirectDraw = m_pFilter->GetDirectDraw();
        ASSERT(pDirectDraw);

        hr = pDirectDraw->QueryInterface(IID_IDDVideoAcceleratorContainer, (void**)&m_pIDDVAContainer);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pDirectDraw->QueryInterface(IID_IVideoAcceleratorContainer) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        else
        {
            DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("pDirectDraw->QueryInterface(IID_IVideoAcceleratorContainer) succeeded")));
        }
    }

    ASSERT(m_pIDDVAContainer);

    // get the guids supported by the vga

    // find the number of guids supported
    hr = m_pIDDVAContainer->GetVideoAcceleratorGUIDs(&dwNumGuidsSupported, NULL);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIDDVAContainer->GetVideoAcceleratorGUIDs failed, hr = 0x%x"), hr));
	goto CleanUp;
    }
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("%d Motion comp GUIDs supported")));
    ASSERT(dwNumGuidsSupported);
    if (0 == dwNumGuidsSupported)
    {
        goto CleanUp;
    }

    // allocate the necessary memory
    pGuidsSupported = (LPGUID) _alloca(dwNumGuidsSupported*sizeof(GUID));

    // get the guids proposed
    hr = m_pIDDVAContainer->GetVideoAcceleratorGUIDs(&dwNumGuidsSupported, pGuidsSupported);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIDDVAContainer->GetVideoAcceleratorGUIDs failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    for (i = 0; i < dwNumGuidsSupported; i++)
    {
        if (*pGuid == pGuidsSupported[i])
        {
            bMatchFound = TRUE;
            break;
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("%s %s suitable video accelerator GUID"),
           (LPCTSTR)CDisp(*pGuid), bMatchFound ? TEXT("is") : TEXT("is not")));
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::IsSuitableVideoAcceleratorGuid")));
    return bMatchFound;
}

// initialize the m_ddUncompDataInfo struct
// get the uncompressed pixel format by choosing the first of all formats supported by the vga
HRESULT COMInputPin::InitializeUncompDataInfo(BITMAPINFOHEADER *pbmiHeader)
{
    HRESULT hr = NOERROR;

    AMVAUncompBufferInfo amvaUncompBufferInfo;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::InitializeUncompDataInfo")));

    // find the number of entries to be proposed
    hr = m_pIVANotify->GetUncompSurfacesInfo(&m_mcGuid, &amvaUncompBufferInfo);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIVANotify->GetUncompSurfacesInfo failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    // initialize the m_ddUncompDataInfo structure
    // We choose the first pixel format since we don't care
    // provided we can make a surface (which we assume we can)
    INITDDSTRUCT(m_ddUncompDataInfo);
    m_ddUncompDataInfo.dwUncompWidth       = pbmiHeader->biWidth;
    m_ddUncompDataInfo.dwUncompHeight      = pbmiHeader->biHeight;
    m_ddUncompDataInfo.ddUncompPixelFormat = amvaUncompBufferInfo.ddUncompPixelFormat;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Uncompressed buffer pixel format %s"),
           (LPCTSTR)CDispPixelFormat(&amvaUncompBufferInfo.ddUncompPixelFormat)));

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::InitializeUncompDataInfo")));
    return hr;
}


HRESULT COMInputPin::AllocateVACompSurfaces(LPDIRECTDRAW pDirectDraw, BITMAPINFOHEADER *pbmiHeader)
{
    HRESULT hr = NOERROR;
    DWORD i = 0, j = 0;
    LPDDVACompBufferInfo pddCompSurfInfo = NULL;
    DDSURFACEDESC2 SurfaceDesc2;
    LPDIRECTDRAWSURFACE4 pSurface4 = NULL;
    LPDIRECTDRAW4 pDirectDraw4 = NULL;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::AllocateVACompSurfaces")));

    ASSERT(pDirectDraw);
    ASSERT(pbmiHeader);

    // get the compressed buffer info

    // find the number of entries to be proposed
    hr = m_pIDDVAContainer->GetCompBufferInfo(&m_mcGuid, &m_ddUncompDataInfo, &m_dwCompSurfTypes, NULL);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pIVANotify->GetCompBufferInfo failed, hr = 0x%x"), hr));
	goto CleanUp;
    }
    if (!m_dwCompSurfTypes)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    // allocate the necessary memory
    pddCompSurfInfo = (DDVACompBufferInfo *)_alloca(sizeof(DDVACompBufferInfo) * m_dwCompSurfTypes);

    // memset the allocated memory to zero
    memset(pddCompSurfInfo, 0, m_dwCompSurfTypes*sizeof(DDVACompBufferInfo));

    // set the right size of all the structs
    for (i = 0; i < m_dwCompSurfTypes; i++)
    {
        pddCompSurfInfo[i].dwSize = sizeof(DDVACompBufferInfo);
    }

    // get the entries proposed
    hr = m_pIDDVAContainer->GetCompBufferInfo(&m_mcGuid, &m_ddUncompDataInfo, &m_dwCompSurfTypes, pddCompSurfInfo);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("GetCompBufferInfo failed, hr = 0x%x"), hr));
	goto CleanUp;
    }
    //  Dump the formats
#ifdef DEBUG

#endif

    hr = pDirectDraw->QueryInterface(IID_IDirectDraw4, (void**)&pDirectDraw4);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pDirectDraw->QueryInterface(IID_IDirectDraw4) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Set the surface description common to all kinds of surfaces
    INITDDSTRUCT(SurfaceDesc2);
    SurfaceDesc2.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT;

    // allocate memory for storing comp_surface_info
    m_pCompSurfInfo = new COMP_SURFACE_INFO[m_dwCompSurfTypes + 1];
    if (!m_pCompSurfInfo)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    memset(m_pCompSurfInfo, 0, (m_dwCompSurfTypes+1)*sizeof(COMP_SURFACE_INFO));

    // allocate the compressed surfaces
    for (i = 1; i <= m_dwCompSurfTypes; i++)
    {
        DWORD dwAlloc = pddCompSurfInfo[i-1].dwNumCompBuffers;
        if (dwAlloc == 0) {
            continue;
        }

        ASSERT(pddCompSurfInfo[i-1].dwNumCompBuffers);

        // allocate memory for storing surface_info for surfaces of this type
        m_pCompSurfInfo[i].pSurfInfo = new SURFACE_INFO[dwAlloc];
        if (!m_pCompSurfInfo[i].pSurfInfo)
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        // memset the allocated memory to zero
        memset(m_pCompSurfInfo[i].pSurfInfo, 0, dwAlloc*sizeof(SURFACE_INFO));

        // intialize the pddCompSurfInfo[i-1] struct
        dwAlloc = m_pCompSurfInfo[i].dwAllocated = pddCompSurfInfo[i-1].dwNumCompBuffers;

        SurfaceDesc2.ddsCaps = pddCompSurfInfo[i-1].ddCompCaps;
        SurfaceDesc2.dwWidth = pddCompSurfInfo[i-1].dwWidthToCreate;
        SurfaceDesc2.dwHeight = pddCompSurfInfo[i-1].dwHeightToCreate;
        memcpy(&SurfaceDesc2.ddpfPixelFormat, &pddCompSurfInfo[i-1].ddPixelFormat, sizeof(DDPIXELFORMAT));

        // create the surfaces, storing surfaces handles for each
        for (j = 0; j < dwAlloc; j++)
        {
            hr = pDirectDraw4->CreateSurface(&SurfaceDesc2, &m_pCompSurfInfo[i].pSurfInfo[j].pSurface, NULL);
	    if (FAILED(hr))
	    {
		DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("Function CreateSurface failed, hr = 0x%x"), hr));
                goto CleanUp;
	    }
        }
    }

CleanUp:

    if (pDirectDraw4)
    {
        pDirectDraw4->Release();
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::AllocateVACompSurfaces")));
    return hr;

}

// allocate the uncompressed buffer
HRESULT COMInputPin::AllocateMCUncompSurfaces(LPDIRECTDRAW pDirectDraw, BITMAPINFOHEADER *pbmiHeader)
{
    HRESULT hr = NOERROR;
    AMVAUncompBufferInfo amUncompBufferInfo;
    DDSURFACEDESC2 SurfaceDesc2;
    LPDIRECTDRAWSURFACE4 pSurface4 = NULL;
    LPDIRECTDRAW4 pDirectDraw4 = NULL;
    DDSCAPS2 ddSurfaceCaps;
    DWORD i = 0, dwTotalBufferCount = 0;
    SURFACE_INFO *pSurfaceInfo;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::AllocateMCUncompSurfaces")));

    ASSERT(pDirectDraw);
    ASSERT(pbmiHeader);

    // get the uncompressed surface info from the decoder
    memset(&amUncompBufferInfo, 0, sizeof(AMVAUncompBufferInfo));
    hr = m_pIVANotify->GetUncompSurfacesInfo(&m_mcGuid, &amUncompBufferInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,  TEXT("m_pIVANotify->GetUncompSurfacesInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    hr = pDirectDraw->QueryInterface(IID_IDirectDraw4, (void**)&pDirectDraw4);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pDirectDraw->QueryInterface(IID_IDirectDraw4) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Set the surface description common to all kinds of surfaces
    memset((LPVOID)&SurfaceDesc2, 0, sizeof(DDSURFACEDESC2));
    SurfaceDesc2.dwSize = sizeof(DDSURFACEDESC2);
    SurfaceDesc2.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT;

    // store the caps and dimensions
    SurfaceDesc2.ddsCaps.dwCaps = DDSCAPS_OVERLAY | DDSCAPS_VIDEOMEMORY;
    SurfaceDesc2.dwWidth = pbmiHeader->biWidth;
    SurfaceDesc2.dwHeight = pbmiHeader->biHeight;

    // define the pixel format
    SurfaceDesc2.ddpfPixelFormat = m_ddUncompDataInfo.ddUncompPixelFormat;

    if (amUncompBufferInfo.dwMinNumSurfaces > amUncompBufferInfo.dwMaxNumSurfaces) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("dwMinNumSurface > dwMaxNumSurfaces")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (amUncompBufferInfo.dwMinNumSurfaces == 0) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("dwMinNumSurface == 0")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    for (dwTotalBufferCount = max(amUncompBufferInfo.dwMaxNumSurfaces,3);
         dwTotalBufferCount >= amUncompBufferInfo.dwMinNumSurfaces;
         dwTotalBufferCount--)
    {
        // CleanUp stuff from the last loop
        if (pSurface4)
        {
            pSurface4->Release();
            pSurface4 = NULL;
        }

	if (dwTotalBufferCount > 1)
	{
	    SurfaceDesc2.dwFlags |= DDSD_BACKBUFFERCOUNT;
	    SurfaceDesc2.ddsCaps.dwCaps |= DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_LOCALVIDMEM;
	    SurfaceDesc2.dwBackBufferCount = dwTotalBufferCount-1;
	}
	else
	{
	    SurfaceDesc2.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
	    SurfaceDesc2.ddsCaps.dwCaps &= ~(DDSCAPS_FLIP | DDSCAPS_COMPLEX);
	    SurfaceDesc2.dwBackBufferCount = 0;
	}

	hr = pDirectDraw4->CreateSurface(&SurfaceDesc2, &pSurface4, NULL);
	if (FAILED(hr))
	{
	    DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("Function CreateSurface failed in Video memory, BackBufferCount = %d, hr = 0x%x"), dwTotalBufferCount-1, hr));
	}

        if (SUCCEEDED(hr))
        {
	    break;
        }
    }

    if (FAILED(hr))
        goto CleanUp;

    ASSERT(pSurface4);

    // store the complex surface in m_pDirectDrawSurface
    hr = pSurface4->QueryInterface(IID_IDirectDrawSurface, (void**)&m_pDirectDrawSurface);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pSurface4->QueryInterface(IID_IDirectDrawSurface) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(m_pDirectDrawSurface);

    m_dwBackBufferCount = SurfaceDesc2.dwBackBufferCount;

    ASSERT(m_pCompSurfInfo && NULL == m_pCompSurfInfo[0].pSurfInfo);
    m_pCompSurfInfo[0].pSurfInfo = new SURFACE_INFO[m_dwBackBufferCount + 1];
    if (NULL == m_pCompSurfInfo[0].pSurfInfo)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allcated memory to zero
    memset(m_pCompSurfInfo[0].pSurfInfo, 0, (m_dwBackBufferCount+1)*sizeof(SURFACE_INFO));

    pSurfaceInfo = m_pCompSurfInfo[0].pSurfInfo;
    m_pCompSurfInfo[0].dwAllocated = m_dwBackBufferCount + 1;
    // initalize the m_ppUncompSurfaceList
    pSurfaceInfo->pSurface = pSurface4;
    pSurface4 = NULL;

    for (i = 0; i < m_dwBackBufferCount; i++)
    {
        memset((void*)&ddSurfaceCaps, 0, sizeof(DDSCAPS2));
        ddSurfaceCaps.dwCaps = DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_OVERLAY;

        // Get the back buffer surface
        // New version of DirectX now requires DDSCAPS2 (header file
        // bug)
        // Note that this AddRef's the surface so we should be sure to
        // release them
	hr = pSurfaceInfo[i].pSurface->GetAttachedSurface(&ddSurfaceCaps, &pSurfaceInfo[i+1].pSurface);
	if (FAILED(hr))
	{
	    DbgLog((LOG_ERROR, VA_ERROR_LEVEL,  TEXT("Function pDDrawSurface->GetAttachedSurface failed, hr = 0x%x"), hr));
	    goto CleanUp;
	}
    }

    //  Pass back number of surfaces actually allocated
    hr = m_pIVANotify->SetUncompSurfacesInfo(
             min(dwTotalBufferCount, amUncompBufferInfo.dwMaxNumSurfaces));

CleanUp:

    if (pSurface4)
    {
        pSurface4->Release();
        pSurface4 = NULL;
    }

    if (pDirectDraw4)
    {
        pDirectDraw4->Release();
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::AllocateMCUncompSurfaces")));
    return hr;
}

// create the motion comp object, using the misc data from the decoder
HRESULT COMInputPin::CreateVideoAcceleratorObject()
{
    HRESULT hr = NOERROR;
    DWORD dwSizeMiscData = 0;
    LPVOID pMiscData = NULL;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::CreateVideoAcceleratorObject")));

    // get the data to be passed from the decoder
    hr = m_pIVANotify->GetCreateVideoAcceleratorData(&m_mcGuid, &dwSizeMiscData, &pMiscData);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIVANotify->GetCreateVideoAcceleratorData failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    // ask the vga for the motion comp object
    m_pIDDVideoAccelerator = NULL;
    hr = m_pIDDVAContainer->CreateVideoAccelerator(&m_mcGuid, &m_ddUncompDataInfo, pMiscData, dwSizeMiscData, &m_pIDDVideoAccelerator, NULL);

    //  Free motion comp data
    CoTaskMemFree(pMiscData);

    if (FAILED(hr) || !m_pIDDVideoAccelerator)
    {
        if (SUCCEEDED(hr)) {
            hr = E_FAIL;
        }
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIDDVAContainer->CreateVideoAcceleratorideo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::CreateVideoAcceleratorObject")));
    return hr;
}



HRESULT COMInputPin::VACompleteConnect(IPin *pReceivePin, const CMediaType *pMediaType)
{
    HRESULT hr = NOERROR;
    BITMAPINFOHEADER *pbmiHeader = NULL;
    DWORD dwNumUncompFormats = 0;
    LPDIRECTDRAW pDirectDraw = NULL;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::VACompleteConnect")));

    ASSERT(m_pIDDVAContainer);
    ASSERT(pReceivePin);
    ASSERT(pMediaType);
    pbmiHeader = GetbmiHeader(pMediaType);
    if ( ! pbmiHeader )
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    pDirectDraw = m_pFilter->GetDirectDraw();
    ASSERT(pDirectDraw);

    // save the decoder's guid
    m_mcGuid = pMediaType->subtype;

    // initialize the get the uncompressed formats supported by the vga
    hr = InitializeUncompDataInfo(pbmiHeader);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,   TEXT("InitializeUncompDataInfo failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    // get the internal memory info
#if 0
    memset(&m_ddvaInternalMemInfo, 0, sizeof(DDVAInternalMemInfo));
    m_ddvaInternalMemInfo.dwSize = sizeof(DDVAInternalMemInfo);
    hr = m_pIDDVAContainer->GetInternalMemInfo(&m_mcGuid, &m_ddUncompDataInfo, &m_ddvaInternalMemInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,  TEXT("m_pIDDVAContainer->GetInternalMemInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
#endif


    // allocate compressed buffers
    hr = AllocateVACompSurfaces(pDirectDraw, pbmiHeader);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,  TEXT("AllocateVACompSurfaces failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // allocate uncompressed buffers
    hr = AllocateMCUncompSurfaces(pDirectDraw, pbmiHeader);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,  TEXT("AllocateMCUncompSurfaces failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // create the motion comp object
    hr = CreateVideoAcceleratorObject();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,  TEXT("CreateVideoAcceleratorObject failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::VACompleteConnect")));
    return hr;
}

HRESULT COMInputPin::VABreakConnect()
{
    HRESULT hr = NOERROR;
    DWORD i = 0, j = 0;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::VABreakConnect")));

    if (m_pCompSurfInfo)
    {
        for (i = 0; i < m_dwCompSurfTypes + 1; i++)
        {
            DWORD dwAlloc = m_pCompSurfInfo[i].dwAllocated;

            if (!m_pCompSurfInfo[i].pSurfInfo)
                continue;

            // release the compressed surfaces
            for (j = 0; j < dwAlloc; j++)
            {
                if (m_pCompSurfInfo[i].pSurfInfo[j].pSurface)
                {
                    //  Unlock if necessary
                    if (m_pCompSurfInfo[i].pSurfInfo[j].pBuffer) {
                        m_pCompSurfInfo[i].pSurfInfo[j].pSurface->Unlock(NULL);
                    }
                    m_pCompSurfInfo[i].pSurfInfo[j].pSurface->Release();
                }
            }
            delete [] m_pCompSurfInfo[i].pSurfInfo;
        }
        delete [] m_pCompSurfInfo;
        m_pCompSurfInfo = NULL;
    }
    m_dwCompSurfTypes = 0;

    if (m_pIDDVideoAccelerator)
    {
        m_pIDDVideoAccelerator->Release();
        m_pIDDVideoAccelerator = NULL;
    }

    if (m_pIDDVAContainer)
    {
        m_pIDDVAContainer->Release();
        m_pIDDVAContainer = NULL;
    }

    if (m_pIVANotify)
    {
        m_pIVANotify->Release();
        m_pIVANotify = NULL;
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::VABreakConnect")));
    return hr;
}




// pdwNumGuidsSupported is an IN OUT paramter
// pGuidsSupported is an IN OUT paramter
// if pGuidsSupported is NULL,  pdwNumGuidsSupported should return back with the
// number of uncompressed pixel formats supported
// Otherwise pGuidsSupported is an array of *pdwNumGuidsSupported structures

STDMETHODIMP COMInputPin::GetVideoAcceleratorGUIDs(LPDWORD pdwNumGuidsSupported, LPGUID pGuidsSupported)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::GetVideoAcceleratorGUIDs")));

    CAutoLock cLock(m_pFilterLock);

    if (!m_pIDDVAContainer)
    {
        IDirectDraw *pDirectDraw;
        pDirectDraw = m_pFilter->GetDirectDraw();
        ASSERT(pDirectDraw);

        hr = pDirectDraw->QueryInterface(IID_IDDVideoAcceleratorContainer, (void**)&m_pIDDVAContainer);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pDirectDraw->QueryInterface(IID_IVideoAcceleratorContainer) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        else
        {
            DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("pDirectDraw->QueryInterface(IID_IVideoAcceleratorContainer) succeeded")));
        }
    }

    ASSERT(m_pIDDVAContainer);

    hr = m_pIDDVAContainer->GetVideoAcceleratorGUIDs(pdwNumGuidsSupported, pGuidsSupported);

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::GetVideoAcceleratorGUIDs")));
    return hr;
}

// pGuid is an IN parameter
// pdwNumFormatsSupported is an IN OUT paramter
// pFormatsSupported is an IN OUT paramter (caller should make sure to set the size of EACH struct)
// if pFormatsSupported is NULL,  pdwNumFormatsSupported should return back with
// the number of uncompressed pixel formats supported
// Otherwise pFormatsSupported is an array of *pdwNumFormatsSupported structures

STDMETHODIMP COMInputPin::GetUncompFormatsSupported(const GUID * pGuid, LPDWORD pdwNumFormatsSupported,
                                                    LPDDPIXELFORMAT pFormatsSupported)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::GetUncompFormatsSupported")));

    CAutoLock cLock(m_pFilterLock);

    if (!m_pIDDVAContainer)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    hr = m_pIDDVAContainer->GetUncompFormatsSupported((GUID *)pGuid, pdwNumFormatsSupported, pFormatsSupported);

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::GetUncompFormatsSupported")));
    return hr;
}

// pGuid is an IN parameter
// pddvaUncompDataInfo is an IN parameter
// pddvaInternalMemInfo is an IN OUT parameter (caller should make sure to set the size of struct)
// currently only gets info about how much scratch memory will the hal allocate for its private use

STDMETHODIMP COMInputPin::GetInternalMemInfo(const GUID * pGuid, const AMVAUncompDataInfo *pamvaUncompDataInfo,
                                             LPAMVAInternalMemInfo pamvaInternalMemInfo)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::GetInternalMemInfo")));

    CAutoLock cLock(m_pFilterLock);

    if (!m_pIDDVAContainer)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    DDVAUncompDataInfo ddvaDataInfo;
    INITDDSTRUCT(ddvaDataInfo);

    ddvaDataInfo.dwUncompWidth       = pamvaUncompDataInfo->dwUncompWidth;
    ddvaDataInfo.dwUncompHeight      = pamvaUncompDataInfo->dwUncompHeight;
    ddvaDataInfo.ddUncompPixelFormat = pamvaUncompDataInfo->ddUncompPixelFormat;

    DDVAInternalMemInfo ddvaInternalMemInfo;
    INITDDSTRUCT(ddvaInternalMemInfo);

    //  Unfortunately the ddraw header files don't use const
    hr = m_pIDDVAContainer->GetInternalMemInfo(
             (GUID *)pGuid,
             &ddvaDataInfo,
             &ddvaInternalMemInfo);

    if (SUCCEEDED(hr)) {
        pamvaInternalMemInfo->dwScratchMemAlloc =
            ddvaInternalMemInfo.dwScratchMemAlloc;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::GetInternalMemInfo")));
    return hr;
}

// pGuid is an IN parameter
// pddvaUncompDataInfo is an IN parameter
// pdwNumTypesCompBuffers is an IN OUT paramter
// pddvaCompBufferInfo is an IN OUT paramter (caller should make sure to set the size of EACH struct)
// if pddvaCompBufferInfo is NULL,  pdwNumTypesCompBuffers should return back with the number of types of
// compressed buffers
// Otherwise pddvaCompBufferInfo is an array of *pdwNumTypesCompBuffers structures

STDMETHODIMP COMInputPin::GetCompBufferInfo(const GUID * pGuid, const AMVAUncompDataInfo *pamvaUncompDataInfo,
                                            LPDWORD pdwNumTypesCompBuffers,  LPAMVACompBufferInfo pamvaCompBufferInfo)
{
    HRESULT hr = NOERROR;
    DDVACompBufferInfo *pddvaCompBufferInfo = NULL; // Stays NULL if pamvaComBufferInfo is NULL

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::GetCompBufferInfo")));

    CAutoLock cLock(m_pFilterLock);

    if (!m_pIDDVAContainer)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    DDVAUncompDataInfo ddvaDataInfo;
    INITDDSTRUCT(ddvaDataInfo);
    ddvaDataInfo.dwUncompWidth       = pamvaUncompDataInfo->dwUncompWidth;
    ddvaDataInfo.dwUncompHeight      = pamvaUncompDataInfo->dwUncompHeight;
    ddvaDataInfo.ddUncompPixelFormat = pamvaUncompDataInfo->ddUncompPixelFormat;


    if (pamvaCompBufferInfo) {
        pddvaCompBufferInfo = (DDVACompBufferInfo *)
            _alloca(sizeof(DDVACompBufferInfo) * (*pdwNumTypesCompBuffers));
        for (DWORD j = 0; j < *pdwNumTypesCompBuffers; j++) {
            INITDDSTRUCT(pddvaCompBufferInfo[j]);
        }
    }

    hr = m_pIDDVAContainer->GetCompBufferInfo(
              (GUID *)pGuid,
              &ddvaDataInfo,
              pdwNumTypesCompBuffers,
              pddvaCompBufferInfo);

    if ((SUCCEEDED(hr) || hr == DDERR_MOREDATA) && pamvaCompBufferInfo) {

        for (DWORD i = 0; i < *pdwNumTypesCompBuffers; i++) {
            DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Compressed buffer type(%d) %d buffers width(%d) height(%d) bytes(%d)"),
                    i,
                    pddvaCompBufferInfo[i].dwNumCompBuffers,
                    pddvaCompBufferInfo[i].dwWidthToCreate,
                    pddvaCompBufferInfo[i].dwHeightToCreate,
                    pddvaCompBufferInfo[i].dwBytesToAllocate));


            pamvaCompBufferInfo[i].dwNumCompBuffers     = pddvaCompBufferInfo[i].dwNumCompBuffers;
            pamvaCompBufferInfo[i].dwWidthToCreate      = pddvaCompBufferInfo[i].dwWidthToCreate;
            pamvaCompBufferInfo[i].dwHeightToCreate     = pddvaCompBufferInfo[i].dwHeightToCreate;
            pamvaCompBufferInfo[i].dwBytesToAllocate    = pddvaCompBufferInfo[i].dwBytesToAllocate;
            pamvaCompBufferInfo[i].ddCompCaps           = pddvaCompBufferInfo[i].ddCompCaps;
            pamvaCompBufferInfo[i].ddPixelFormat        = pddvaCompBufferInfo[i].ddPixelFormat;
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::GetCompBufferInfo")));
    return hr;
}


HRESULT COMInputPin::CheckValidMCConnection()
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::CheckValidMCConnection")));

    // if not connected, this function does not make much sense
    if (!IsCompletelyConnected())
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pin not connected, exiting")));
	hr = VFW_E_NOT_CONNECTED;
	goto CleanUp;
    }

    if (m_RenderTransport != AM_VIDEOACCELERATOR)
    {
        hr = VFW_E_INVALIDSUBTYPE;
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::CheckValidMCConnection")));
    return hr;
}

STDMETHODIMP COMInputPin::GetInternalCompBufferInfo(LPDWORD pdwNumTypesCompBuffers,  LPAMVACompBufferInfo pamvaCompBufferInfo)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::GetInternalCompBufferInfo")));

    CAutoLock cLock(m_pFilterLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    ASSERT(m_pIDDVAContainer);

    DDVACompBufferInfo ddvaCompBufferInfo;
    INITDDSTRUCT(ddvaCompBufferInfo);

    AMVAUncompDataInfo amvaUncompDataInfo;
    amvaUncompDataInfo.dwUncompWidth         = m_ddUncompDataInfo.dwUncompWidth;
    amvaUncompDataInfo.dwUncompHeight        = m_ddUncompDataInfo.dwUncompHeight;
    amvaUncompDataInfo.ddUncompPixelFormat   = m_ddUncompDataInfo.ddUncompPixelFormat;
    hr = GetCompBufferInfo(&m_mcGuid, &amvaUncompDataInfo, pdwNumTypesCompBuffers, pamvaCompBufferInfo);

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Leaving COMInputPin::GetInternalCompBufferInfo")));
    return hr;
}

STDMETHODIMP COMInputPin::BeginFrame(const AMVABeginFrameInfo *pamvaBeginFrameInfo)
{
    HRESULT hr = NOERROR;
    DDVABeginFrameInfo ddvaBeginFrameInfo;
    SURFACE_INFO *pSurfInfo;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::BeginFrame")));

    CAutoLock cLock(m_pFilterLock);

    if (!pamvaBeginFrameInfo)
    {
        hr = E_POINTER;
        goto CleanUp;
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("BeginFrame index %d"), pamvaBeginFrameInfo->dwDestSurfaceIndex));

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }


    INITDDSTRUCT(ddvaBeginFrameInfo);

    pSurfInfo = SurfaceInfoFromTypeAndIndex(
                             0xFFFFFFFF,
                             pamvaBeginFrameInfo->dwDestSurfaceIndex);
    if (pSurfInfo == NULL) {
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    ddvaBeginFrameInfo.pddDestSurface = pSurfInfo->pSurface;

    ddvaBeginFrameInfo.dwSizeInputData  = pamvaBeginFrameInfo->dwSizeInputData;
    ddvaBeginFrameInfo.pInputData       = pamvaBeginFrameInfo->pInputData;
    ddvaBeginFrameInfo.dwSizeOutputData = pamvaBeginFrameInfo->dwSizeOutputData;
    ddvaBeginFrameInfo.pOutputData      = pamvaBeginFrameInfo->pOutputData;

    ASSERT(m_pIDDVideoAccelerator);
    hr = m_pIDDVideoAccelerator->BeginFrame(&ddvaBeginFrameInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIDDVideoAccelerator->BeginFrame failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::BeginFrame returnd 0x%8.8X"), hr));
    return hr;
}

// end a frame, the pMiscData is passed directly to the hal
// only valid to call this after the pins are connected

STDMETHODIMP COMInputPin::EndFrame(const AMVAEndFrameInfo *pEndFrameInfo)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::EndFrame")));

    CAutoLock cLock(m_pFilterLock);

    if (NULL == pEndFrameInfo) {
        hr = E_POINTER;
        goto CleanUp;
    }

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    ASSERT(m_pIDDVideoAccelerator);

    DDVAEndFrameInfo ddvaEndFrameInfo;
    INITDDSTRUCT(ddvaEndFrameInfo);
    ddvaEndFrameInfo.dwSizeMiscData = pEndFrameInfo->dwSizeMiscData;
    ddvaEndFrameInfo.pMiscData      = pEndFrameInfo->pMiscData;

    hr = m_pIDDVideoAccelerator->EndFrame(&ddvaEndFrameInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIDDVideoAccelerator->EndFrame failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::EndFrame returned 0x%8.8X"), hr));
    return hr;
}

//  Get surface into structure given buffer type and buffer index
SURFACE_INFO *COMInputPin::SurfaceInfoFromTypeAndIndex(DWORD dwTypeIndex, DWORD dwBufferIndex)
{
    LPCOMP_SURFACE_INFO pCompSurfInfo;

    // make sure that type-index is less than the number of types
    if ((DWORD)(dwTypeIndex + 1) > m_dwCompSurfTypes)
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("dwTypeIndex is invalid, dwTypeIndex = %d, m_dwCompSurfTypes = %d"),
            dwTypeIndex, m_dwCompSurfTypes));
        return NULL;
    }


    // cache the pointer to the list they are interested in
    // Add 1 to allow for uncompressed surfaces
    pCompSurfInfo = m_pCompSurfInfo + (DWORD)(dwTypeIndex + 1);
    ASSERT(pCompSurfInfo);
    if (dwBufferIndex >= pCompSurfInfo->dwAllocated)
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("dwBufferIndex is invalid, dwBufferIndex = %d, dwAllocated = %d"),
            dwBufferIndex, pCompSurfInfo->dwAllocated));
        return NULL;
    }
    ASSERT(pCompSurfInfo->dwAllocated != 0);

    // get the pointer to the next available unlocked buffer info struct
    return pCompSurfInfo->pSurfInfo + dwBufferIndex;

}

//  Cycle through the compressed buffers
STDMETHODIMP COMInputPin::GetBuffer(
    DWORD dwTypeIndex,
    DWORD dwBufferIndex,
    BOOL bReadOnly,
    LPVOID *ppBuffer,
    LPLONG lpStride)
{
    HRESULT hr = NOERROR;
    LPSURFACE_INFO pSurfInfo = NULL;
    DDSURFACEDESC2 ddsd;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::GetBuffer type %d, index %d"),
            dwTypeIndex, dwBufferIndex));

    CAutoLock cLock(m_pFilterLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    if (ppBuffer == NULL || lpStride == NULL) {
        hr = E_POINTER;
        goto CleanUp;
    }

    pSurfInfo = SurfaceInfoFromTypeAndIndex(dwTypeIndex, dwBufferIndex);

    if (pSurfInfo == NULL) {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // Check buffer not already locked
    if (pSurfInfo->pBuffer != NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("No more free buffers left or the decoder is releasing buffers out of order, returning E_UNEXPECTED")));
        goto CleanUp;
    }

    //  Wait until previous motion comp operation is complete
    while (DDERR_WASSTILLDRAWING ==
           m_pIDDVideoAccelerator->QueryRenderStatus(
               pSurfInfo->pSurface,
               bReadOnly ? DDVA_QUERYRENDERSTATUSF_READ : 0)) {
        Sleep(1);
    }
    //  Now lock the surface
    INITDDSTRUCT(ddsd);
    for (; ; )
    {
        hr = pSurfInfo->pSurface->Lock(NULL, &ddsd, DDLOCK_NOSYSLOCK, NULL);
        if (hr == DDERR_WASSTILLDRAWING)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Compressed surface is busy")));
            Sleep(1);
        }
        else
        {
            break;
        }
    }

    if (dwBufferIndex == 0xFFFFFFFF && !bReadOnly) {
        //  Check if surface is being displayed
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pSurfInfo->pSurface->Lock failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    pSurfInfo->pBuffer = ddsd.lpSurface;
    *ppBuffer = ddsd.lpSurface;
    *lpStride = ddsd.lPitch;

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::GetBuffer returned 0x%8.8X"), hr));
    return hr;
}


//  unlock a compressed buffer
STDMETHODIMP COMInputPin::ReleaseBuffer(DWORD dwTypeIndex, DWORD dwBufferIndex)
{
    HRESULT hr = NOERROR;
    LPSURFACE_INFO pSurfInfo;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::ReleaseBuffer type %d, index %d"),
           dwTypeIndex, dwBufferIndex));

    CAutoLock cLock(m_pFilterLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    pSurfInfo = SurfaceInfoFromTypeAndIndex(dwTypeIndex, dwBufferIndex);
    if (NULL == pSurfInfo)
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("GetInfoFromCookie failed, hr = 0x%x"), hr));
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    // make sure there is a valid buffer pointer and it is the same as
    // what we have cached
    if (NULL == pSurfInfo->pBuffer)
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pBuffer is not valid, pBuffer = 0x%x, pSurfInfo->pBuffer = 0x%x"), pSurfInfo->pBuffer, pSurfInfo->pSurface));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_LOCKED);
        goto CleanUp;
    }

    //  For some reason IDirectDrawSurface4 wants an LPRECT here
    //  I hope NULL is OK
    hr = pSurfInfo->pSurface->Unlock(NULL);
    if (SUCCEEDED(hr))
    {
        pSurfInfo->pBuffer = NULL;
    }
    else
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("pSurfInfo->pSurface->Unlock failed, hr = 0x%x"), hr));
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::ReleaseBuffer returned 0x%8.8X"), hr));
    return hr;
}


//  Perform a decode operation
STDMETHODIMP COMInputPin::Execute(
        DWORD dwFunction,
        LPVOID lpPrivateInputData,
        DWORD cbPrivateInputData,
        LPVOID lpPrivateOutputData,
        DWORD cbPrivateOutputData,
        DWORD dwNumBuffers,
        const AMVABUFFERINFO *pamvaBufferInfo
)
{
    HRESULT hr = NOERROR;
    DWORD i = 0;
    DDVABUFFERINFO *pddvaBufferInfo = NULL;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::Execute")));

    CAutoLock cLock(m_pFilterLock);


    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    pddvaBufferInfo = (DDVABUFFERINFO *)_alloca(sizeof(DDVABUFFERINFO) * dwNumBuffers);

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Execute Function %d, %d buffers :"),
            dwFunction, dwNumBuffers));
    for (i = 0; i < dwNumBuffers; i++)
    {
        DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("    Type(%d) Index(%d) offset(%d) size(%d)"),
                pamvaBufferInfo[i].dwTypeIndex,
                pamvaBufferInfo[i].dwBufferIndex,
                pamvaBufferInfo[i].dwDataOffset,
                pamvaBufferInfo[i].dwDataSize));

        LPSURFACE_INFO pSurfInfo =
            SurfaceInfoFromTypeAndIndex(
                pamvaBufferInfo[i].dwTypeIndex,
                pamvaBufferInfo[i].dwBufferIndex);

        if (pSurfInfo == NULL)
        {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("GetInfoFromCookie failed, hr = 0x%x, i = %d"), hr, i));
            hr = E_INVALIDARG;
            goto CleanUp;
        }

        INITDDSTRUCT(pddvaBufferInfo[i]);
        pddvaBufferInfo[i].dwDataOffset   = pamvaBufferInfo[i].dwDataOffset;
        pddvaBufferInfo[i].dwDataSize     = pamvaBufferInfo[i].dwDataSize;
        pddvaBufferInfo[i].pddCompSurface = pSurfInfo->pSurface;
    }

    ASSERT(m_pIDDVideoAccelerator);


    hr = m_pIDDVideoAccelerator->Execute(
             dwFunction,
             lpPrivateInputData,
             cbPrivateInputData,
             lpPrivateOutputData,
             cbPrivateOutputData,
             dwNumBuffers,
             pddvaBufferInfo);

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIDDVideoAccelerator->Execute failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::Execute returned 0x%8.8X"), hr));
    return hr;
}

// QueryRenderStatus of a particular (possibly a set of) macro block
// dwNumBlocks is an IN parameter
// pdwCookies is an IN parameter which is array (of length dwNumBlocks) of cookies which server as
// identifiers for the corresponding members of pddvaMacroBlockInfo
// pddvaMacroBlockInfo is an IN parameter which is array (of length dwNumBlocks) of structures
// only valid to call this after the pins are connected
STDMETHODIMP COMInputPin::QueryRenderStatus(
        DWORD dwTypeIndex,
        DWORD dwBufferIndex,
        DWORD dwFlags)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Entering COMInputPin::QueryRenderStatus - type(%d), buffer(%d), flags(0x%8.8X)"),
            dwTypeIndex, dwBufferIndex, dwFlags));

    CAutoLock cLock(m_pFilterLock);

    LPSURFACE_INFO pSurfInfo =
        SurfaceInfoFromTypeAndIndex(dwTypeIndex, dwBufferIndex);

    if (pSurfInfo == NULL) {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }

    hr = m_pIDDVideoAccelerator->QueryRenderStatus(pSurfInfo->pSurface, dwFlags);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("m_pIDDVideoAccelerator->QueryRenderStatus failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::QueryRenderStatus returned 0x%8.8X"), hr));
    if (hr == DDERR_WASSTILLDRAWING) {
        hr = E_PENDING;
    }
    return hr;
}

STDMETHODIMP COMInputPin::DisplayFrame(DWORD dwFlipToIndex, IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;
    DWORD dwNumUncompFrames = m_dwBackBufferCount + 1, dwFlipFromIndex = 0, i = 0;
    SURFACE_INFO *pSurfInfo;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::DisplayFrame - index %d"), dwFlipToIndex));

    CAutoLock cLock(m_pFilterLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
	goto CleanUp;
    }
    pSurfInfo = SurfaceInfoFromTypeAndIndex(
                             0xFFFFFFFF,
                             dwFlipToIndex);
    if (pSurfInfo == NULL) {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    for (i = 0; i < dwNumUncompFrames; i++)
    {
        if (IsEqualObject(m_pCompSurfInfo[0].pSurfInfo[i].pSurface, m_pDirectDrawSurface))
        {
            dwFlipFromIndex = i;
        }
    }

    pSurfInfo->pSurface->QueryInterface(
        IID_IDirectDrawSurface, (void **)&m_pBackBuffer);
    m_pBackBuffer->Release();

    hr = Receive(pMediaSample);
    if (FAILED(hr))
    {
        goto CleanUp;
    }


    if (FAILED(hr)) {
        //  Should we poll if we got DDERR_WASSTINGDRAWING?
        goto CleanUp;
    }

    //  DirectDraw switches the memory under the pointers
    //  so mimic that in our list
    if (m_bReallyFlipped) {

        LPDIRECTDRAWSURFACE4 pTempSurface;

        // we should have successfully called flip by this point, swap the two
        pTempSurface = m_pCompSurfInfo[0].pSurfInfo[dwFlipToIndex].pSurface;
        m_pCompSurfInfo[0].pSurfInfo[dwFlipToIndex].pSurface = m_pCompSurfInfo[0].pSurfInfo[dwFlipFromIndex].pSurface;
        m_pCompSurfInfo[0].pSurfInfo[dwFlipFromIndex].pSurface = pTempSurface;
    }

CleanUp:
    if (SUCCEEDED(hr))
    {
        if (m_bOverlayHidden)
        {
	    m_bOverlayHidden = FALSE;
	    // make sure that the video frame gets updated by redrawing everything
	    EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        }
    }
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("leaving COMInputPin::DisplayFrame return 0x%8.8X"), hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\omfilter.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


// known problems:

#include <streams.h>
#include <ddraw.h>
#include <ddmm.h>
#include <mmsystem.h>   // Needed for definition of timeGetTime
#include <limits.h>     // Standard data type limit definitions
#include <ddmmi.h>
#include <dciddi.h>
#include <dvdmedia.h>
#include <amstream.h>

#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif // FILTER_DLL
#include <macvis.h>   // for Macrovision support
#include <ovmixer.h>
#include <initguid.h>
#include <malloc.h>
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx


extern "C" const TCHAR szPropPage[];
extern "C" const TCHAR chRegistryKey[];
extern int GetRegistryDword(HKEY hk, const TCHAR *pKey, int iDefault);

DEFINE_GUID(IID_IDirectDraw4,
            0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5);

DEFINE_GUID(IID_IDDrawNonExclModeVideo,
            0xec70205c,0x45a3,0x4400,0xa3,0x65,0xc4,0x47,0x65,0x78,0x45,0xc7);

AMOVIESETUP_MEDIATYPE sudPinOutputTypes[] =
{
    {
        &MEDIATYPE_Video,           // Major type
        &MEDIASUBTYPE_Overlay       // Minor type
    }
};
AMOVIESETUP_MEDIATYPE sudPinInputTypes[] =
{
    {
        &MEDIATYPE_Video,           // Major type
        &MEDIASUBTYPE_NULL          // Minor type
    }
};

AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",               // Pin's string name
        FALSE,                  // Is it rendered
        FALSE,                  // Is it an output
        FALSE,                  // Allowed none
        TRUE,                   // Allowed many
        &CLSID_NULL,            // Connects to filter
        L"Output",              // Connects to pin
        NUMELMS(sudPinInputTypes), // Number of types
        sudPinInputTypes        // Pin information
    },
    {
        L"Output",              // Pin's string name
        FALSE,                  // Is it rendered
        TRUE,                   // Is it an output
        FALSE,                  // Allowed none
        FALSE,                  // Allowed many
        &CLSID_NULL,            // Connects to filter
        L"Input",               // Connects to pin
        NUMELMS(sudPinOutputTypes), // Number of types
        sudPinOutputTypes      // Pin information
    }
};

const AMOVIESETUP_FILTER sudOverlayMixer =
{
    &CLSID_OverlayMixer,    // Filter CLSID
    L"Overlay Mixer",       // Filter name
    MERIT_DO_NOT_USE,       // Filter merit
    0,                      // Number pins
    NULL                    // Pin details
};
const AMOVIESETUP_FILTER sudOverlayMixer2 =
{
    &CLSID_OverlayMixer2,    // Filter CLSID
    L"Overlay Mixer2",       // Filter name
    MERIT_UNLIKELY,         // Filter merit
    NUMELMS(psudPins),      // Number pins
    psudPins                // Pin details
};

#if defined(DEBUG) && !defined(_WIN64)
int     iOVMixerDump;
HFILE   DbgFile = HFILE_ERROR;
BOOL    fDbgInitialized;
int     iOpenCount = 0;
int     iFPSLog;
#endif

#ifdef FILTER_DLL
// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance
//
//  Property set defines for notifying owner.
//
// {7B390654-9F74-11d1-AA80-00C04FC31D60}
//#define DO_INIT_GUID
DEFINE_GUID(AMPROPSETID_NotifyOwner,
            0x7b390654, 0x9f74, 0x11d1, 0xaa, 0x80, 0x0, 0xc0, 0x4f, 0xc3, 0x1d, 0x60);
//#undef DO_INIT_GUID

CFactoryTemplate g_Templates[] =
{
    { L"Overlay Mixer", &CLSID_OverlayMixer, COMFilter::CreateInstance, NULL, &sudOverlayMixer },
    { L"Overlay Mixer2", &CLSID_OverlayMixer2, COMFilter::CreateInstance2, NULL, &sudOverlayMixer2 },
    { L"VideoPort Object", &CLSID_VPObject, CAMVideoPort::CreateInstance, NULL, NULL },
    { L"", &CLSID_COMQualityProperties,COMQualityProperties::CreateInstance},
    { L"", &CLSID_COMPinConfigProperties,COMPinConfigProperties::CreateInstance},
    { L"", &CLSID_COMPositionProperties,COMPositionProperties::CreateInstance},
    { L"", &CLSID_COMVPInfoProperties,COMVPInfoProperties::CreateInstance}

};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// DllRegisterSever
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
} // DllRegisterServer


// DllUnregisterServer
HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
} // DllUnregisterServer

#endif // FILTER_DLL

#if defined(DEBUG) && !defined(_WIN64)
void OpenDbgFile()
{
    OFSTRUCT ofs;
    char    szFileName[MAX_PATH];

    ofs.cBytes = sizeof(ofs);
    GetProfileStringA("OVMixer", "FileName",
                      "c:\\OVMixer.log", szFileName, MAX_PATH);

    DbgFile = OpenFile(szFileName, &ofs, OF_READWRITE);

    if (DbgFile == HFILE_ERROR && ERROR_FILE_NOT_FOUND == GetLastError()) {
        DbgFile = _lcreat(szFileName, 0);
    }

    if (DbgFile != HFILE_ERROR) {
        _llseek(DbgFile, 0, FILE_END);
        DbgLog((LOG_TRACE, 0, TEXT(" ********* New Log ********* \r\n")));
    }
}

void InitDebug(void)
{
    iFPSLog = GetProfileIntA("OVMixer", "FPS", 0);

    if (!fDbgInitialized) {
        iOVMixerDump = GetProfileIntA("OVMixer", "Debug", 0);
        if (iOVMixerDump) {
            OpenDbgFile();
        }
        fDbgInitialized = TRUE;
    }
    if (iOVMixerDump) {
        iOpenCount++;
    }
}

void TermDebug(void)
{
    if (iOVMixerDump) {
        iOpenCount--;
        if (iOpenCount == 0) {
            _lclose(DbgFile);
            iOVMixerDump = 0;
            fDbgInitialized = FALSE;
        }
    }
}
#endif

// CreateInstance
// This goes in the factory template table to create new filter instances
CUnknown *COMFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
#if defined(DEBUG) && !defined(_WIN64)
    InitDebug();
#endif
    return new COMFilter(NAME("VideoPort Mixer"), pUnk, phr, false);
} // CreateInstance

// CreateInstance2
// This goes in the factory template table to create new filter instances
CUnknown *COMFilter::CreateInstance2(LPUNKNOWN pUnk, HRESULT *phr)
{
#if defined(DEBUG) && !defined(_WIN64)
    InitDebug();
#endif
    return new COMFilter(NAME("VideoPort Mixer"), pUnk, phr, true);
} // CreateInstance


#pragma warning(disable:4355)


// Constructor
COMFilter::COMFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, bool bOnlyVideoInfo2)
: CBaseFilter(pName, pUnk, &this->m_csFilter, CLSID_OverlayMixer, phr),
  m_BPCWrap(this),
  m_pIMixerOCXNotify(NULL),
  m_bWinInfoStored(FALSE),
  m_hDC(NULL),
  m_bOnlySupportVideoInfo2(bOnlyVideoInfo2),
  m_bExternalDirectDraw(FALSE),
  m_bExternalPrimarySurface(FALSE),
  m_MacroVision(this),
  m_pExclModeCallback(NULL),
  m_bColorKeySet(FALSE),
  m_pPosition(NULL),
  m_bOverlayVisible(FALSE),
  m_bCopyProtect(TRUE),
  m_dwKernelCaps(0),
  m_dwPinConfigNext(0),
  m_bHaveCheckedMMatics(FALSE),
  m_bIsFaultyMMatics(FALSE),
  m_dwOverlayFX(0)
{
    SetRectEmpty(&m_rcOverlaySrc);
    SetRectEmpty(&m_rcOverlayDest);

    HRESULT hr = NOERROR;
    ASSERT(phr != NULL);

    m_dwInputPinCount = 0;
    m_pOutput = NULL;
    m_dwMaxPinId = 0;

    m_hDirectDraw = NULL;
    m_pDirectDraw = NULL;
    m_pUpdatedDirectDraw = NULL;
    m_pPrimarySurface = NULL;
    m_pUpdatedPrimarySurface = NULL;
    m_bNeedToRecreatePrimSurface = FALSE;
    m_fDisplayChangePosted = FALSE;
    m_UsingIDDrawNonExclModeVideo = FALSE;
    m_UsingIDDrawExclModeVideo = FALSE;

    memset(&m_WinInfo, 0, sizeof(WININFO));
    m_dwAdjustedVideoWidth = 0;
    m_dwAdjustedVideoHeight = 0;

    m_bWindowless = FALSE;
    m_bUseGDI = FALSE;

    // palette info
    m_dwNumPaletteEntries = 0;
    m_lpDDrawInfo = NULL;

    //
    // Initialize DDraw the MMon structures
    //
    m_dwDDObjReleaseMask = 0;
    m_pOldDDObj = NULL;
    m_MonitorChangeMsg = RegisterWindowMessage(TEXT("OVMMonitorChange"));
    hr = LoadDDrawLibrary(m_hDirectDraw, m_lpfnDDrawCreate,
                          m_lpfnDDrawEnum, m_lpfnDDrawEnumEx);
    if (FAILED(hr)) {
        goto CleanUp;
    }

    hr = GetDDrawGUIDs(&m_dwDDrawInfoArrayLen, &m_lpDDrawInfo);
    if (FAILED(hr)) {
        goto CleanUp;
    }

    AMDDRAWGUID guid;

    hr = GetDefaultDDrawGUID(&guid);
    if (FAILED(hr)) {
        goto CleanUp;
    }

    if (FAILED(SetDDrawGUID(&guid))) {
        ZeroMemory(&guid, sizeof(guid));
        hr = SetDDrawGUID(&guid);
        if (FAILED(hr)) {
            goto CleanUp;
        }
        else {
            SetDefaultDDrawGUID(&guid);
        }
    }

    m_fMonitorWarning = (m_lpCurrentMonitor->ddHWCaps.dwMaxVisibleOverlays < 1);

    SetDecimationUsage(DECIMATION_DEFAULT);

    ZeroMemory(&m_ColorKey, sizeof(COLORKEY));
    m_ColorKey.KeyType |= (CK_INDEX | CK_RGB);
    m_ColorKey.PaletteIndex = DEFAULT_DEST_COLOR_KEY_INDEX;
    m_ColorKey.HighColorValue = m_ColorKey.LowColorValue = DEFAULT_DEST_COLOR_KEY_RGB;

    // artifically increase the refcount since creation of the pins might
    // end up calling Release() on the filter
    m_cRef++;

    // create the pins
    hr = CreatePins();
    if (FAILED(hr)) {

CleanUp:
        //  Only update the return code if we failed.  That way we don't
        //  lose a failure from (say) CBaseFilter's constructor
        *phr = hr;
    }
    else {

        // restore the ref-count of the filter.
        m_cRef--;
    }
}

COMFilter::~COMFilter()
{
    //  No need to lock - only 1 thread has a pointer to us

    if (m_pIMixerOCXNotify)
    {
        m_pIMixerOCXNotify->Release();
        m_pIMixerOCXNotify = NULL;
    }

    //  Release exclusive mode callback
    if (m_pExclModeCallback) {
        m_pExclModeCallback->Release();
        m_pExclModeCallback = NULL;
    }

    //  Release passthru
    if (m_pPosition) {
        m_pPosition->Release();
    }

    // release the primary surface
    ReleasePrimarySurface();

    // release directdraw, primary surface etc.
    ReleaseDirectDraw();

    // release the DDraw guid info
    CoTaskMemFree(m_lpDDrawInfo);

    // delete the pins
    DeletePins();

    m_BPCWrap.TurnBPCOn();

    // Decrement module load count
    if (m_hDirectDraw)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Unloading ddraw library")));
        FreeLibrary(m_hDirectDraw);
        m_hDirectDraw = NULL;
    }
#if defined(DEBUG) && !defined(_WIN64)
    TermDebug();
#endif
}

// Creates the pins for the filter. Override to use different pins
HRESULT COMFilter::CreatePins()
{
    HRESULT hr = NOERROR;
    const WCHAR wszPinName[] = L"Input00";

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::CreatePins")));

    // create one input pin at this point (with VP Support)
    hr = CreateInputPin(TRUE);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CreateInputPin failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Allocate the output pin
    m_pOutput = new COMOutputPin(NAME("OverlayMixer output pin"), this, &m_csFilter, &hr, L"Output",  m_dwMaxPinId);
    if (m_pOutput == NULL || FAILED(hr))
    {
        if (SUCCEEDED(hr))
            hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 1, TEXT("Unable to create the output pin, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // increament the pin id counter
    m_dwMaxPinId++;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::CreatePins")));
    return hr;
}

// COMFilter::DeletePins
void COMFilter::DeletePins()
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::DeletePins")));

    //  Only called from the destructor so no need to lock
    //  If some other thread is trying to lock us on our lock we're in
    //  trouble anyway since we're going away

    delete m_pOutput;
    m_pOutput = NULL;

    // note that since CreateInputPin addrefs the mem pins, we have
    // to release them here. The NonDelegatingQueryRelease will call
    // DeleteInputPin, which would delete the pin.
    for (DWORD i = 1; i < m_dwInputPinCount; i++)
    {
        // while addrefing the pin, the filter has to increment its own ref-count inorder to avoid
        //  a ref-count less than zero etc
        AddRef();
        m_apInput[i]->Release();
    }

    if (m_dwInputPinCount > 0 && NULL != m_apInput[0]) {
        // while addrefing the pin, the filter has to increment its own ref-count inorder to avoid
        //  a ref-count less than zero etc
        AddRef();
        m_apInput[0]->Release();
        delete m_apInput[0];
        m_apInput[0] = NULL;
        m_dwInputPinCount--;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::DeletePins")));
}


// CreateInputPin
HRESULT COMFilter::CreateInputPin(BOOL bVPSupported)
{
    HRESULT hr = NOERROR;
    WCHAR wszPinName[20];
    COMInputPin *pPin;
    LPDIRECTDRAWSURFACE pPrimarySurface = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::CreateInputPin")));

    ASSERT(m_dwInputPinCount <= MAX_PIN_COUNT);
    // make sure we are not exceeding the limit
    if (m_dwInputPinCount == MAX_PIN_COUNT)
        return NOERROR;

    // if it is an external primary surface, do not create any more input pins
    if (!m_UsingIDDrawNonExclModeVideo && m_bExternalPrimarySurface && m_dwInputPinCount == 1)
    {
        DbgLog((LOG_TRACE, 2, TEXT("m_bExternalPrimarySurface is true, so exiting funtion,")));
        return NOERROR;
    }

    // if we are using GDI, do not create any more input pins
    if (m_bUseGDI && m_dwInputPinCount == 1)
    {
        DbgLog((LOG_TRACE, 2, TEXT("m_bUseGDI is true, so exiting funtion,")));
        return NOERROR;
    }

    CAutoLock l(&m_csFilter);


    // create the pin
    wsprintfW(wszPinName, L"Input%d", m_dwMaxPinId);
    pPin = new COMInputPin(NAME("OverlayMixer Input pin"), this, &m_csFilter, bVPSupported, &hr, wszPinName, m_dwMaxPinId);
    if (pPin == NULL || FAILED(hr))
    {
        if (SUCCEEDED(hr)) {
            hr = E_OUTOFMEMORY;
        } else {
            delete pPin;
        }
        goto CleanUp;
    }


    DbgLog((LOG_TRACE, 3, TEXT("Created Pin, No = %d"), m_dwInputPinCount));

    // while addrefing the pin, the filter has to decrement its own ref-count inorder to avoid a
    // circular ref-count
    pPin->AddRef();
    Release();

    m_apInput[m_dwInputPinCount] = pPin;
    m_dwInputPinCount++;
    m_dwMaxPinId++;
    IncrementPinVersion();

    // pins do not support VideoPort or IOverlay connection by default.
    // Also there default RenderTransport is AM_OFFSCREEN, and default
    // AspectRatioMode is AspectRatioMode is AM_ARMODE_STRETCHED
    // therefore in the non-GDI case only the first pins parmameters need to be modified
    if (m_bUseGDI)
    {
        m_apInput[m_dwInputPinCount-1]->SetRenderTransport(AM_GDI);
    }
    else if (m_dwInputPinCount == 1)
    {
	m_apInput[m_dwInputPinCount-1]->SetRenderTransport(AM_OVERLAY);
	m_apInput[m_dwInputPinCount-1]->SetIOverlaySupported(TRUE);
        m_apInput[m_dwInputPinCount-1]->SetVPSupported(TRUE);
        m_apInput[m_dwInputPinCount-1]->SetVideoAcceleratorSupported(TRUE);
        m_apInput[m_dwInputPinCount-1]->SetAspectRatioMode(AM_ARMODE_LETTER_BOX);
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::CreateInputPin")));
    return hr;
} // CreateInputPin

// DeleteInputPin
void COMFilter::DeleteInputPin(COMInputPin *pPin)
{
    DWORD iPinCount;
    BOOL bPinFound = FALSE;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::DeleteInputPin")));

    CAutoLock l(&m_csFilter);

    // we don't delete the first pin
    for (iPinCount = 1; iPinCount < m_dwInputPinCount; iPinCount++)
    {
        if (bPinFound) {
            m_apInput[iPinCount - 1] = m_apInput[iPinCount];
        } else {
            if (m_apInput[iPinCount] == (COMInputPin*)pPin)
            {
                delete pPin;
                bPinFound = TRUE;
            }
        }
    }

    ASSERT(bPinFound);
    m_dwInputPinCount--;
    IncrementPinVersion();

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::DeleteInputPin")));
    return;
} // DeleteInputPin


// NonDelegatingQueryInterface
STDMETHODIMP COMFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::NonDelegatingQueryInterface")));
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    if (riid == IID_IAMOverlayMixerPosition)
    {
        return GetInterface((IAMOverlayMixerPosition *) this, ppv);
    }
    if (riid == IID_IAMOverlayMixerPosition2)
    {
        return GetInterface((IAMOverlayMixerPosition2 *) this, ppv);
    }
    else if (riid == IID_IMixerOCX)
    {
        return GetInterface((IMixerOCX *) this, ppv);
    }
    else if (riid == IID_IDDrawExclModeVideo) {
        if (m_UsingIDDrawNonExclModeVideo) {
            return E_NOINTERFACE;
        } else {
            m_UsingIDDrawExclModeVideo = true;
            return GetInterface(static_cast<IDDrawExclModeVideo *>(this), ppv);
        }
    }
    else if (riid == IID_IDDrawNonExclModeVideo) {
        if (m_UsingIDDrawExclModeVideo) {
            return E_NOINTERFACE;
        } else {
            m_UsingIDDrawNonExclModeVideo = true;
            return GetInterface(static_cast<IDDrawNonExclModeVideo *>(this), ppv);
        }
    }
    else if (riid == IID_IAMVideoDecimationProperties)
    {
        return GetInterface((IAMVideoDecimationProperties *) this, ppv);
    }
    else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking)
    {
        // we should have an input pin by now
        ASSERT(m_apInput[0] != NULL);
        if (m_pPosition == NULL)
        {
            HRESULT hr = CreatePosPassThru(GetOwner(), FALSE, m_apInput[0], &m_pPosition);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
                return hr;
            }
        }
        return m_pPosition->QueryInterface(riid, ppv);
    }

    else if (riid == IID_ISpecifyPropertyPages && 0 != GetRegistryDword(HKEY_CURRENT_USER , szPropPage, 0))
    {
        return GetInterface((ISpecifyPropertyPages *)this, ppv);
    }
    else if (riid == IID_IQualProp) {
        return GetInterface((IQualProp *)this, ppv);
    }
    else if (riid == IID_IEnumPinConfig) {
        return GetInterface((IEnumPinConfig *)this, ppv);
    }
    else if (riid == IID_IAMOverlayFX) {
        return GetInterface((IAMOverlayFX *)this, ppv);
    }
    else if (riid == IID_IAMSpecifyDDrawConnectionDevice) {
        return GetInterface((IAMSpecifyDDrawConnectionDevice *)this, ppv);
    }
    else if (riid == IID_IKsPropertySet) {
        return GetInterface((IKsPropertySet *)this, ppv);
    }

    CAutoLock l(&m_csFilter);

    //
    if (riid == IID_IVPNotify || riid == IID_IVPNotify2 ||
        riid == IID_IVPInfo)

    {
        return m_apInput[0]->NonDelegatingQueryInterface(riid, ppv);
    }

    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP COMFilter::GetPages(CAUUID *pPages)
{
#if defined(DEBUG)
    pPages->cElems = 4+m_dwInputPinCount;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(4+m_dwInputPinCount));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

#define COM_QUAL
#ifdef COM_QUAL
    pPages->pElems[0]   = CLSID_COMQualityProperties;
#else
    pPages->pElems[0]   = CLSID_QualityProperties;
#endif

    pPages->pElems[1] = CLSID_COMPositionProperties;
    pPages->pElems[2] = CLSID_COMVPInfoProperties;
    pPages->pElems[3] = CLSID_COMDecimationProperties;

    // Add PinConfig page for all input pins first
    for (unsigned int i=0; i<m_dwInputPinCount; i++)
    {
        pPages->pElems[4+i] = CLSID_COMPinConfigProperties;
    }
#else
    pPages->cElems = 3+m_dwInputPinCount;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(3+m_dwInputPinCount));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

#define COM_QUAL
#ifdef COM_QUAL
    pPages->pElems[0]   = CLSID_COMQualityProperties;
#else
    pPages->pElems[0]   = CLSID_QualityProperties;
#endif

    pPages->pElems[1] = CLSID_COMPositionProperties;
    pPages->pElems[2] = CLSID_COMVPInfoProperties;

    // Add PinConfig page for all input pins first
    for (unsigned int i=0; i<m_dwInputPinCount; i++)
    {
        pPages->pElems[3+i] = CLSID_COMPinConfigProperties;
    }

#endif
    return NOERROR;
}

// IEnumPinConfig support

STDMETHODIMP COMFilter::Next(IMixerPinConfig3 **pPinConfig)
{
    HRESULT hr = m_apInput[m_dwPinConfigNext]->QueryInterface(IID_IMixerPinConfig3,
        (void **) pPinConfig);
    m_dwPinConfigNext++;
    m_dwPinConfigNext = m_dwPinConfigNext%m_dwInputPinCount;
    return hr;
}

// IQualProp property page support

STDMETHODIMP COMFilter::get_FramesDroppedInRenderer(int *cFramesDropped)
{
    COMInputPin *pPin = m_apInput[0];
    if (pPin && pPin->m_pSyncObj)
        return pPin->m_pSyncObj->get_FramesDroppedInRenderer(cFramesDropped);
    return S_FALSE;
}

STDMETHODIMP COMFilter::get_FramesDrawn(int *pcFramesDrawn)
{
    COMInputPin *pPin = m_apInput[0];
    if (pPin && pPin->m_pSyncObj)
        return pPin->m_pSyncObj->get_FramesDrawn(pcFramesDrawn);
    return S_FALSE;
}

STDMETHODIMP COMFilter::get_AvgFrameRate(int *piAvgFrameRate)
{
    COMInputPin *pPin = m_apInput[0];
    if (pPin && pPin->m_pSyncObj)
        return pPin->m_pSyncObj->get_AvgFrameRate(piAvgFrameRate);
    return S_FALSE;
}

STDMETHODIMP COMFilter::get_Jitter(int *piJitter)
{
    COMInputPin *pPin = m_apInput[0];
    if (pPin && pPin->m_pSyncObj)
        return pPin->m_pSyncObj->get_Jitter(piJitter);
    return S_FALSE;
}

STDMETHODIMP COMFilter::get_AvgSyncOffset(int *piAvg)
{
    COMInputPin *pPin = m_apInput[0];
    if (pPin && pPin->m_pSyncObj)
        return pPin->m_pSyncObj->get_AvgSyncOffset(piAvg);
    return S_FALSE;
}

STDMETHODIMP COMFilter::get_DevSyncOffset(int *piDev)
{
    COMInputPin *pPin = m_apInput[0];
    if (pPin && pPin->m_pSyncObj)
        return pPin->m_pSyncObj->get_DevSyncOffset(piDev);
    return S_FALSE;
}

int COMFilter::GetPinCount()
{
    if (m_pOutput)
        return m_dwInputPinCount + 1;
    else
        return m_dwInputPinCount;
}

// returns a non-addrefed CBasePin *
CBasePin* COMFilter::GetPin(int n)
{
    CBasePin *pRetPin = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetPin")));

    CAutoLock l(&m_csFilter);

    // check that the pin requested is within range
    if (n > (int)m_dwInputPinCount)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Bad Pin Requested, n = %d, No. of Pins = %d"),
            n, m_dwInputPinCount+1));
        pRetPin = NULL;
        goto CleanUp;
    }

    // return the output pin
    if (n == (int)m_dwInputPinCount)
    {
        // if there is no output pin, we will return NULL which is the right
        // thing to do
        pRetPin = m_pOutput;
        goto CleanUp;
    }

    // return an input pin
    pRetPin = m_apInput[n];
    goto CleanUp;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetPin")));
    return pRetPin;
}


// the base classes inform the pins of every state transition except from
// run to pause. Overriding Pause to inform the input pins about that transition also
STDMETHODIMP COMFilter::Pause()
{
    HRESULT hr = NOERROR;
    DWORD i;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::Pause")));

    CAutoLock l(&m_csFilter);

    if (m_State == State_Paused)
    {
        return m_apInput[0]->CompleteStateChange(State_Paused);
    }

    if (m_apInput[0]->IsConnected() == FALSE)
    {
        m_State = State_Paused;
        return m_apInput[0]->CompleteStateChange(State_Paused);
    }

    if (m_State == State_Running)
    {
        // set the pointer to DirectDraw and the PrimarySurface on All the Input Pins
        for (i = 0; i < m_dwInputPinCount; i++)
        {
            hr = m_apInput[i]->RunToPause();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_apInput[i]->RunToPause failed, i = %d, hr = 0x%x"),
                    i, hr));
                goto CleanUp;
            }
        }
    }

CleanUp:
    hr = CBaseFilter::Pause();
    if (FAILED(hr))
    {
        return hr;
    }


    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::Pause")));
    return m_apInput[0]->CompleteStateChange(State_Paused);
}


// Overridden the base class Stop() method just to stop MV.
STDMETHODIMP COMFilter::Stop()
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::Stop")));

    CAutoLock l(&m_csFilter) ;

    HRESULT  hr = NOERROR ;

#if 0  // OvMixer resets MV bit ONLY in the destructor
    //
    // Release the copy protection key now
    //
    if (! m_MacroVision.StopMacroVision() )
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Stopping copy protection failed"))) ;
        // hr = E_UNEXPECTED ;
    }
#endif // #if 0

    hr = CBaseFilter::Stop() ;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::Stop")));

    return hr ;
}


HRESULT COMFilter::RecreatePrimarySurface(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    HRESULT hr = NOERROR;
    LPDIRECTDRAW pDirectDraw = NULL;
    LPDIRECTDRAWSURFACE pPrimarySurface = NULL;
    LPDIRECTDRAWSURFACE3 pPrimarySurface3 = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::RecreatePrimarySurface")));

    // addref the new primary surface provided
    if (pDDrawSurface)
    {
        pDDrawSurface->AddRef() ;
    }
    else if (m_UsingIDDrawNonExclModeVideo) {
        pDDrawSurface = m_pUpdatedPrimarySurface;
        m_pUpdatedPrimarySurface = NULL;
    }

    // release the primary surface
    ReleasePrimarySurface();

    // if given a valid ddraw surface, make a copy of it (we have already addref'd it)
    // else allocate your own
    if (pDDrawSurface)
    {
        m_pPrimarySurface = pDDrawSurface;
    }
    else
    {
        // create a new primary surface
        hr = CreatePrimarySurface();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("CreatePrimarySurface() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // attach a window clipper
        if (m_pOutput && m_pOutput->IsConnected())
        {
            hr = m_pOutput->AttachWindowClipper();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_pOutput->AttachWindowClipper() failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
    }


    // Try for the IDirectDrawSurface3 interface. If it works, we're on DX5 at least
    hr = m_pPrimarySurface->QueryInterface(IID_IDirectDrawSurface3, (void**)&pPrimarySurface3);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDraw->CreateSurface failed, hr = 0x%x"), hr));
        hr = VFW_E_DDRAW_VERSION_NOT_SUITABLE;
        goto CleanUp;
    }

    // get the ddraw object this primary surface has been made of
    hr = pPrimarySurface3->GetDDInterface((void**)&pDirectDraw);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pPrimarySurface3->GetDDInterface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // make sure this primary surface has been created by the same ddraw object that we have
    if (!m_pDirectDraw || !pDirectDraw || !(IsEqualObject(m_pDirectDraw, pDirectDraw)))
    {
        hr = E_FAIL;
        DbgLog((LOG_ERROR, 1, TEXT("pDirectDraw != m_pDirectDraw, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (m_DirectCaps.dwCaps & DDCAPS_OVERLAY)
    {
        BOOL bColorKeySet = m_bColorKeySet;
        hr = SetColorKey(&m_ColorKey);
        m_bColorKeySet = bColorKeySet;
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("SetColorKey() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    // by this point we should have a valid primary surface

CleanUp:
    // if anything fails, might as well as release everything
    if (FAILED(hr))
    {
        // release the primary surface
        ReleasePrimarySurface();
    }

    if (pPrimarySurface3)
    {
        pPrimarySurface3->Release();
        pPrimarySurface3 = NULL;
    }

    if (pDirectDraw)
    {
        pDirectDraw->Release();
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::RecreatePrimarySurface")));
    return hr;
}

int COMFilter::GetPinPosFromId(DWORD dwPinId)
{
    int iPinPos = -1;

    for (int i = 0; i < (int)m_dwInputPinCount; i++)
    {
        if (m_apInput[i]->GetPinId() == dwPinId)
        {
            iPinPos = i;
            break;
        }
    }

    if (m_pOutput && (m_pOutput->GetPinId() == dwPinId))
    {
        iPinPos = MAX_PIN_COUNT;
    }

    return iPinPos;
}

HRESULT COMFilter::CompleteConnect(DWORD dwPinId)
{
    HRESULT hr = NOERROR;
    int iPinPos = -1;
    CMediaType inPinMediaType, outPinMediaType;

    IPin *pPeerOutputPin = NULL;

    BOOL bNeededReconnection = FALSE;
    DWORD dwNewWidth = 0, dwNewHeight = 0, dwPictAspectRatioX = 0, dwPictAspectRatioY = 0;
    DRECT rdDim;
    RECT rDim;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::CompleteConnect")));

    CAutoLock l(&m_csFilter);

    iPinPos = GetPinPosFromId(dwPinId);
    ASSERT(iPinPos >= 0 && iPinPos <= MAX_PIN_COUNT);

    // we may need to recreate the primary surface here if this complete-connect
    // is a result of a reconnect due to a wm_displaychange
    if (iPinPos == 0 && m_bNeedToRecreatePrimSurface && !m_bUseGDI && m_pOutput && m_pOutput->IsConnected())
    {
        hr = RecreatePrimarySurface(NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,1,TEXT("RecreatePrimarySurface failed, hr = 0x%x"), hr));
            hr = NOERROR;
        }
        m_bNeedToRecreatePrimSurface = FALSE;
    }


    if (iPinPos == 0)
    {
        // find the input pin connection mediatype
        hr = m_apInput[0]->CurrentAdjustedMediaType(&inPinMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("CurrentAdjustedMediaType failed")));
            goto CleanUp;
        }

        pHeader = GetbmiHeader(&inPinMediaType);
        if (!pHeader)
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        hr = ::GetPictAspectRatio(&inPinMediaType, &dwPictAspectRatioX, &dwPictAspectRatioY);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("GetPictAspectRatio failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        ASSERT(dwPictAspectRatioX > 0);
        ASSERT(dwPictAspectRatioY > 0);

        // get the image dimensions and store them in the mediasample
        SetRect(&rdDim, 0, 0, abs(pHeader->biWidth), abs(pHeader->biHeight));
        TransformRect(&rdDim, ((double)dwPictAspectRatioX/(double)dwPictAspectRatioY), AM_STRETCH);
        rDim = MakeRect(rdDim);

        m_dwAdjustedVideoWidth = WIDTH(&rDim);
        m_dwAdjustedVideoHeight = HEIGHT(&rDim);

        SetRect(&m_WinInfo.SrcRect, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
    }

    // reconnect the output pin based on the mediatype of the input pin
    if ((iPinPos == MAX_PIN_COUNT && m_apInput[0]->IsConnected()) ||
        (iPinPos == 0 && m_pOutput && m_pOutput->IsConnected()))
    {
        // find the renderer's pin
        pPeerOutputPin = m_pOutput->GetConnected();
        if (pPeerOutputPin == NULL)
        {
            DbgLog((LOG_ERROR,0,TEXT("ConnectedTo failed")));
            goto CleanUp;
        }
        ASSERT(pPeerOutputPin);

        // find the output pin connection mediatype
        hr = m_pOutput->ConnectionMediaType(&outPinMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("ConnectionMediaType failed")));
            goto CleanUp;
        }

        pHeader = GetbmiHeader(&outPinMediaType);
        if (!pHeader)
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        // compare the new values with the current ones.
        // See if we need to reconnect at all
        if (pHeader->biWidth != (LONG)m_dwAdjustedVideoWidth ||
            pHeader->biHeight != (LONG)m_dwAdjustedVideoHeight)
        {
            bNeededReconnection = TRUE;
        }

        // If we don't need reconnection, bail out
        if (bNeededReconnection)
        {

            // Ok we do need reconnection, set the right values
            pHeader->biWidth = m_dwAdjustedVideoWidth;
            pHeader->biHeight = m_dwAdjustedVideoHeight;
            if (outPinMediaType.formattype == FORMAT_VideoInfo)
            {
                SetRect(&(((VIDEOINFOHEADER*)(outPinMediaType.pbFormat))->rcSource), 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
                SetRect(&(((VIDEOINFOHEADER*)(outPinMediaType.pbFormat))->rcTarget), 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
            }
            else if (outPinMediaType.formattype == FORMAT_VideoInfo2)
            {
                SetRect(&(((VIDEOINFOHEADER2*)(outPinMediaType.pbFormat))->rcSource), 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
                SetRect(&(((VIDEOINFOHEADER2*)(outPinMediaType.pbFormat))->rcTarget), 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
            }


            // Query the upstream filter asking if it will accept the new media type.
            hr = pPeerOutputPin->QueryAccept(&outPinMediaType);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,TEXT("m_pVPDraw->QueryAccept failed")));
                goto CleanUp;
            }

            // Reconnect using the new media type.
            hr = ReconnectPin(pPeerOutputPin, &outPinMediaType);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,TEXT("m_pVPDraw->Reconnect failed")));
                goto CleanUp;
            }
        }
    }

CleanUp:

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::CompleteConnect")));
    hr = NOERROR;
    return hr;
}

HRESULT COMFilter::BreakConnect(DWORD dwPinId)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::BreakConnect")));

    CAutoLock l(&m_csFilter);

    if (dwPinId == 0) {
        m_bColorKeySet = FALSE;
    }

    int iPinPos = GetPinPosFromId(dwPinId);
    ASSERT(iPinPos >= 0 && iPinPos <= MAX_PIN_COUNT);

    hr = CanExclusiveMode();
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5, TEXT("CanExclusiveMode failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if atleast one pin is connected, we are not going to do anything
    hr = ConfirmPreConnectionState(dwPinId);
    if (FAILED(hr))
    {

        DbgLog((LOG_TRACE, 3, TEXT("filter not in preconnection state, hr = 0x%x"), hr));
        goto CleanUp;
    }


CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::BreakConnect")));
    return NOERROR;
}

HRESULT COMFilter::SetMediaType(DWORD dwPinId, const CMediaType *pmt)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::SetMediaType")));

    CAutoLock l(&m_csFilter);

    // make sure that the filter has created a direct-draw object and primary surface
    // successfully
    if (!m_bUseGDI)
    {
        LPDIRECTDRAW pDirectDraw = NULL;
        LPDIRECTDRAWSURFACE pPrimarySurface = NULL;

        pDirectDraw = GetDirectDraw();
        if (pDirectDraw) {
            pPrimarySurface = GetPrimarySurface();
        }

        if (!pDirectDraw || !pPrimarySurface)
        {
            DbgLog((LOG_ERROR, 1, TEXT("pDirectDraw = 0x%x, pPrimarySurface = 0x%x"), pDirectDraw, pPrimarySurface));
            hr = E_FAIL;
            goto CleanUp;
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::SetMediaType")));
    return hr;
}

// gets events notifications from pins
HRESULT COMFilter::EventNotify(DWORD dwPinId, long lEventCode, long lEventParam1, long lEventParam2)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::EventNotify")));

    CAutoLock l(&m_csFilter);

    if (lEventCode == EC_COMPLETE)
    {
        if (m_pOutput)
        {
            IPin *pRendererPin = m_pOutput->CurrentPeer();

            //  Output pin may not be connected (for instance
            //  RenegotiateVPParameters can fail while connecting
            if (pRendererPin) {
                pRendererPin->EndOfStream();
            }
        }
        else
        {
            NotifyEvent(EC_COMPLETE,S_OK,0);
        }
    }
    else if (lEventCode == EC_OVMIXER_REDRAW_ALL)
    {
        if (!m_bWindowless)
        {
            // redraw all
            hr = OnDrawAll();
        }
        else
        {
            if (m_pIMixerOCXNotify)
                m_pIMixerOCXNotify->OnInvalidateRect(NULL);
        }
    }
    else
    {
        NotifyEvent(lEventCode, lEventParam1, lEventParam2);
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::EventNotify")));
    return hr;
}

HRESULT COMFilter::OnDisplayChangeBackEnd()
{
    AMTRACE((TEXT("COMFilter::OnDisplayChangeBackEnd")));

    HRESULT hr = NOERROR;
    IPin **ppPin = NULL;
    DWORD i;

    m_Display.RefreshDisplayType(m_lpCurrentMonitor->szDevice);
    m_fMonitorWarning = (m_lpCurrentMonitor->ddHWCaps.dwMaxVisibleOverlays < 1);

    // this ensures that the primary surface will be recreated on the next complete-connect
    // of the first input pin. This will ensure that the overlay surface (if any) is released
    // by then.
    m_bNeedToRecreatePrimSurface = TRUE;

    // The Overlay Mixer can have at most MAX_PIN_COUNT input pins.
    ASSERT(MAX_PIN_COUNT == NUMELMS(m_apInput));
    IPin* apPinLocal[MAX_PIN_COUNT];

    DWORD dwPinCount;
    ULONG AllocSize = sizeof(IPin*) * m_dwInputPinCount;
    ppPin = (IPin**)CoTaskMemAlloc(AllocSize);
    if (ppPin) {
        ZeroMemory(ppPin, AllocSize);

        // now tell each input pin to reconnect
        for (dwPinCount = 0, i = 0; i < m_dwInputPinCount; i++)
        {
            // notify each pin about the change
            hr = m_apInput[i]->OnDisplayChange();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_apInput[%d]->OnDisplayChange() failed"), i));
                continue;
            }

            // get IPin interface
            if (hr == S_OK) {
                hr = m_apInput[i]->QueryInterface(IID_IPin, (void**)&ppPin[dwPinCount]);
                ASSERT(SUCCEEDED(hr));
                ASSERT(ppPin[dwPinCount]);

                apPinLocal[dwPinCount] = ppPin[dwPinCount];

                dwPinCount++;
            }

            m_dwDDObjReleaseMask |= (1 << m_apInput[i]->m_dwPinId);
        }


        m_pOldDDObj = m_pDirectDraw;
        if (m_pOldDDObj)
            m_pOldDDObj->AddRef();
        ReleasePrimarySurface();
        ReleaseDirectDraw();

        //
        // Pass our input pin array as parameter on the event, we don't free
        // the allocated memory - this is done by the event processing
        // code in the Filter Graph.  ppPin cannot be accessed after it is passed
        // to the Filter Graph because the Filter Graph can release ppPin's 
        // memory at any time.
        //
        if (dwPinCount > 0) {
            NotifyEvent(EC_DISPLAY_CHANGED, (LONG_PTR)ppPin, (LONG_PTR)dwPinCount);
        }

        // Release the IPin interfaces
        for (i = 0; i < dwPinCount; i++) {
           apPinLocal[i]->Release();
        }
    }
    else hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT COMFilter::OnDisplayChange(BOOL fRealDisplayChange)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::OnDisplayChange")));

    CAutoLock l(&m_csFilter);

    //
    // If we are being called as the result of a real display change
    // rather than the user moving the window onto another monitor
    // we need to refresh the array of DDraw device info.
    //
    if (fRealDisplayChange) {
        CoTaskMemFree(m_lpDDrawInfo);
        hr = GetDDrawGUIDs(&m_dwDDrawInfoArrayLen, &m_lpDDrawInfo);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("Failed to enumerate DDraw devices")));
            return hr;
        }
    }
    m_fDisplayChangePosted = FALSE; // ok again


    //
    // Now we are just moving monitors check that the monitor that we are
    // moving to actually has an overlay that we can use.
    //
    if (!fRealDisplayChange) {

        HMONITOR hMon = DeviceFromWindow(GetWindow(), NULL, NULL);

        //
        // Are we actually moving monitors ?
        //

        if (hMon == m_lpCurrentMonitor->hMon) {
            return S_OK;
        }

        AMDDRAWMONITORINFO* p = m_lpDDrawInfo;
        for (; p < &m_lpDDrawInfo[m_dwDDrawInfoArrayLen]; p++) {
            if (hMon == p->hMon) {
                if (p->ddHWCaps.dwMaxVisibleOverlays < 1) {
                    m_fMonitorWarning = TRUE;
                    return S_OK;
                }
                break;
            }
        }
    }

    // reset which monitor we think we're on.  This may have changed
    // and initialze to use the new monitor
    GetCurrentMonitor();

    // let the common back end do the real work

    hr = OnDisplayChangeBackEnd();

    if (!fRealDisplayChange && SUCCEEDED(hr))
        PostMessage(GetWindow(), WM_SHOWWINDOW, TRUE, 0);

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::OnDisplayChange")));
    return hr;
}

HRESULT COMFilter::OnTimer()
{
    HRESULT hr = NOERROR;
    DWORD i = 0;

    CAutoLock l(&m_csFilter);

    //  REVIEW - why would we get here and m_bUseGDI be TRUE?
    if (m_bUseGDI)
    {
        goto CleanUp;
    }

    if (!m_pPrimarySurface)
    {
        if (m_pDirectDraw)
        {
            hr = RecreatePrimarySurface(NULL);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,2,TEXT("In Ontimer, RecreatePrimarySurface failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            else
            {
                DbgLog((LOG_TRACE, 2, TEXT("In Ontimer, RecreatePrimarySurface succeeded")));
            }
        }
        else goto CleanUp;
    }
    else
    {
        ASSERT(m_pPrimarySurface);
        if (m_pPrimarySurface->IsLost() != DDERR_SURFACELOST)
        {
            goto CleanUp;
        }

        if (m_pDirectDraw) {
            LPDIRECTDRAW4 pDD4;
            if (S_OK == m_pDirectDraw->QueryInterface(IID_IDirectDraw4, (LPVOID *)&pDD4)) {
                pDD4->RestoreAllSurfaces();
                pDD4->Release();
            }
        }

        hr = m_pPrimarySurface->Restore();
        if (FAILED(hr))
            goto CleanUp;
    }

    for (i = 0; i < m_dwInputPinCount; i++)
    {
        hr = m_apInput[i]->RestoreDDrawSurface();
        if (FAILED(hr))
        {
            goto CleanUp;
        }
    }

    EventNotify(GetPinCount(), EC_NEED_RESTART, 0, 0);
    EventNotify(GetPinCount(), EC_OVMIXER_REDRAW_ALL, 0, 0);

CleanUp:

    return hr;
}

STDMETHODIMP COMFilter::GetState(DWORD dwMSecs,FILTER_STATE *pState)
{
    HRESULT hr = NOERROR;

    CAutoLock l(&m_csFilter);

    hr = m_apInput[0]->GetState(dwMSecs, pState);
    if (hr == E_NOTIMPL)
    {
        hr = CBaseFilter::GetState(dwMSecs, pState);
    }
    return hr;
}





// this function can be used to provide a ddraw object to the filter. A null argument
// to the filter forces it to allocate its own.
STDMETHODIMP COMFilter::SetDDrawObject(LPDIRECTDRAW pDDObject)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::SetDDrawObject(0x%lx)"), pDDObject));

    hr = CanExclusiveMode();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CanExclusiveMode failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if atleast one pin is connected, just cache the ddraw object given
    hr = ConfirmPreConnectionState();
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("filter not in preconnection state, hr = 0x%x"), hr));

#if 0   //
        // This is disabled because of a bug hit by the OvMixer test app that
        // sets the DDraw object and surface and then tries to reconnect the
        // pins to get those DDraw params to be used.
        // There are also a couple of asserts hit in the base classes due to the
        // way the output pin is deleted etc.
        //
        // The bug is in how InitDirectDraw() releases and resets m_pPrimarySurface
        // as well as m_pUpdatedPrimarySurface.  This causes OvMixer to use the
        // app-specified DDraw object but its own DDraw surface.  The fix for this
        // would be to not try to synch up these two interfaces in BreakConnect()
        // etc (that will also help in finding if the DDraw params are external
        // rather than using a BOOL as is done now).
        //

        // addref the new one
        if (pDDObject)
        {
            pDDObject->AddRef();
        }

        // release the old m_pUpdatedDirectDraw
        if (m_pUpdatedDirectDraw)
        {
            m_pUpdatedDirectDraw->Release();
        }

        m_pUpdatedDirectDraw = pDDObject;

        hr = NOERROR;
#endif // #if 0

        goto CleanUp;
    }

    // either addref the given ddraw object or allocate our own
    // if anything fails, InitDirectDraw does the cleanup, so that our state is consistent
    hr = InitDirectDraw(pDDObject);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("InitDirectDraw failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::SetDDrawObject")));
    return hr;
}


/******************************Public*Routine******************************\
* ChangeMonitor
*
* Allows an application to tell the OVMixer that it would like to change
* to displaying the video on a new monitor.  The OVMixer will only change
* to the new monitor if the monitor has the necessary hw available upon it.
*
* If we are connected thru VPE or IOveraly, then monitor changes are not
* possible.  If the new DDraw device does not support overlays then again
* we can not change monitors.
*
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::ChangeMonitor(
    HMONITOR hMon,
    LPDIRECTDRAW pDDrawObject,
    LPDIRECTDRAWSURFACE pDDrawSurface
    )
{
    AMTRACE((TEXT("COMFilter::ChangeMonitor")));
    CAutoLock l(&m_csFilter);

    //
    // Validate the DDraw parameters
    //

    if (!(pDDrawObject && pDDrawSurface))
    {
        DbgLog((LOG_ERROR, 1, TEXT("ChangeMonitor: Either pDDrawObject or pDDrawSurface are invalid")));
        return E_POINTER;
    }

    //
    // Check for VPE and IOverlay - we can't change monitor with these
    //

    if (m_apInput[0]->m_RenderTransport == AM_VIDEOPORT ||
        m_apInput[0]->m_RenderTransport == AM_IOVERLAY)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ChangeMonitor: Can't change monitor when using VideoPort or IOverlay")));
        return E_FAIL;
    }


    //
    // Are we actually moving monitors ?
    //

    if (hMon == m_lpCurrentMonitor->hMon)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ChangeMonitor: Specified must be different to current monitor")));
        return E_INVALIDARG;
    }


    //
    // Now check that the specified hMonitor is valid and that the monitor that
    // we are moving to actually has an overlay that we can use.
    //

    AMDDRAWMONITORINFO* p = m_lpDDrawInfo;
    for (; p < &m_lpDDrawInfo[m_dwDDrawInfoArrayLen]; p++)
    {
        if (hMon == p->hMon)
        {
            if (p->ddHWCaps.dwMaxVisibleOverlays < 1)
            {
                DbgLog((LOG_ERROR, 1, TEXT("ChangeMonitor: Can't change to a monitor that has no overlays")));
                return E_FAIL;
            }
            break;
        }
    }


    if (p == &m_lpDDrawInfo[m_dwDDrawInfoArrayLen])
    {
        DbgLog((LOG_ERROR, 1, TEXT("ChangeMonitor: hMonitor parameter is not valid")));
        return E_INVALIDARG;
    }


    //
    // Everything looks OK so reset the current monitor that we are using,
    // save the passed DDraw Object and surface and call the backend code that
    // does the actual work
    //

    m_lpCurrentMonitor = p;
    m_pUpdatedDirectDraw = pDDrawObject;
    m_pUpdatedDirectDraw->AddRef();
    m_pUpdatedPrimarySurface = pDDrawSurface;
    m_pUpdatedPrimarySurface->AddRef();

    return OnDisplayChangeBackEnd();
}


/******************************Public*Routine******************************\
* DisplayModeChanged
*
*
*
* History:
* Tue 11/23/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::DisplayModeChanged(
    HMONITOR hMon,
    LPDIRECTDRAW pDDrawObject,
    LPDIRECTDRAWSURFACE pDDrawSurface
    )
{
    AMTRACE((TEXT("COMFilter::DisplayModeChanged")));
    //
    // Validate the DDraw parameters
    //

    if (!(pDDrawObject && pDDrawSurface))
    {
        DbgLog((LOG_ERROR, 1, TEXT("DisplayModeChanged: Either pDDrawObject or pDDrawSurface are invalid")));
        return E_POINTER;
    }

    DbgLog((LOG_TRACE, 1, TEXT("Display Mode Changed : - OLD monitor = %hs 0x%X"),
            m_lpCurrentMonitor->szDevice,
            hMon ));
    //
    // Refresh our display monitors array as the old array has become
    // invalid as a result of the DisplayMode change
    //
    CAutoLock l(&m_csFilter);
    CoTaskMemFree(m_lpDDrawInfo);
    HRESULT hr = GetDDrawGUIDs(&m_dwDDrawInfoArrayLen, &m_lpDDrawInfo);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("Failed to enumerate DDraw devices")));
        return hr;
    }

    AMDDRAWMONITORINFO* p = m_lpDDrawInfo;
    for (; p < &m_lpDDrawInfo[m_dwDDrawInfoArrayLen]; p++)
    {
        if (hMon == p->hMon)
        {
            if (p->ddHWCaps.dwMaxVisibleOverlays < 1)
            {
                DbgLog((LOG_ERROR, 1, TEXT("DisplayModeChanged: This monitor has no overlays")));
                return E_FAIL;
            }
            break;
        }
    }


    if (p == &m_lpDDrawInfo[m_dwDDrawInfoArrayLen])
    {
        DbgLog((LOG_ERROR, 1, TEXT("DisplayModeChanged: hMon parameter is not valid")));
        return E_INVALIDARG;
    }

    //
    // Let the common back end code do the actual work
    //
    m_lpCurrentMonitor = p;
    m_pUpdatedDirectDraw = pDDrawObject;
    m_pUpdatedDirectDraw->AddRef();
    m_pUpdatedPrimarySurface = pDDrawSurface;
    m_pUpdatedPrimarySurface->AddRef();
    DbgLog((LOG_TRACE, 1, TEXT("Display Mode Changed : - NEW monitor = %hs 0x%X"),
            m_lpCurrentMonitor->szDevice,
            p->hMon ));
    return OnDisplayChangeBackEnd();
}

/******************************Public*Routine******************************\
* RestoreSurfaces
*
*
*
* History:
* Tue 11/23/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::RestoreSurfaces()
{
    AMTRACE((TEXT("COMFilter::RestoreSurfaces")));

    DWORD i;
    HRESULT hr = S_OK;
    CAutoLock l(&m_csFilter);

    LPDIRECTDRAW  pDD = GetDirectDraw();
    if (pDD) {
        LPDIRECTDRAW4 pDD4;
        if (S_OK == pDD->QueryInterface(IID_IDirectDraw4, (LPVOID *)&pDD4)) {
            pDD4->RestoreAllSurfaces();
            pDD4->Release();
        }
    }

    for (i = 0; i < m_dwInputPinCount; i++)
    {
        hr = m_apInput[i]->RestoreDDrawSurface();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    EventNotify(GetPinCount(), EC_NEED_RESTART, 0, 0);
    EventNotify(GetPinCount(), EC_OVMIXER_REDRAW_ALL, 0, 0);

    return hr;
}

// gets the ddraw object currently being used by the overlay mixer. If the app has not
// set any ddraw object and the ovmixer has not yet allocated one, then *ppDDrawObject
// will be set to NULL and *pbUsingExternal will be set to FALSE. Otherwise *pbUsingExternal
// will be set to TRUE if the ovmixer is currently USING an app given ddraw object and FALSE
// othewise
STDMETHODIMP COMFilter::GetDDrawObject(LPDIRECTDRAW *ppDDrawObject, LPBOOL pbUsingExternal)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetDDrawObject")));

    hr = CanExclusiveMode();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CanExclusiveMode failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (!ppDDrawObject)
    {
        DbgLog((LOG_ERROR, 1, TEXT("invalid argument, ppDDrawObject == NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pbUsingExternal)
    {
        DbgLog((LOG_ERROR, 1, TEXT("invalid argument, ppDDrawObject == NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // make a copy of our ddraw object and addref it (if not NULL)
    *ppDDrawObject = m_pDirectDraw;
    if (m_pDirectDraw)
        m_pDirectDraw->AddRef();

    *pbUsingExternal = m_bExternalDirectDraw;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetDDrawObject")));
    return hr;

}



// this function can be used to provide a primary surface to the filter. A null argument
// to the filter forces it to allocate its own. This function makes sure that the surface
// provided exposes IDirectDrawSurface3, and is consistent with the ddraw object provided
// Furthermore, a non NULL argument provided here means that we are supposed to be windowless
// and are not supposed to touch the bits of the primary surface. So we stop painting the
// colorkey ourselves and expose only one input pin, which uses an overlay surface to do the
// rendering
STDMETHODIMP COMFilter::SetDDrawSurface(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("COMFilter::SetDDrawSurface(0x%lx)"), pDDrawSurface));

    hr = CanExclusiveMode();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CanExclusiveMode failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if atleast one pin is connected, just cache the ddraw surface given
    hr = ConfirmPreConnectionState();
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("filter not in preconnection state, hr = 0x%x"), hr));

#if 0   //
        // This is disabled because of a bug hit by the OvMixer test app that
        // sets the DDraw object and surface and then tries to reconnect the
        // pins to get those DDraw params to be used.
        // There are also a couple of asserts hit in the base classes due to the
        // way the output pin is deleted etc.
        //
        // The bug is in how InitDirectDraw() releases and resets m_pPrimarySurface
        // as well as m_pUpdatedPrimarySurface.  This causes OvMixer to use the
        // app-specified DDraw object but its own DDraw surface.  The fix for this
        // would be to not try to synch up these two interfaces in BreakConnect()
        // etc (that will also help in finding if the DDraw params are external
        // rather than using a BOOL as is done now).
        //

        // addref the new one
        if (pDDrawSurface)
        {
            pDDrawSurface->AddRef();
        }

        // release the old m_pUpdatedPrimarySurface
        if (m_pUpdatedPrimarySurface)
        {
            m_pUpdatedPrimarySurface->Release();
        }

        m_pUpdatedPrimarySurface = pDDrawSurface;

        hr = NOERROR;
#endif // #if 0

        goto CleanUp;
    }

    // allocate a primary surface if the argument is NULL, otherwise addref the one
    // provided. Also set clipper, colorkey etc
    hr = RecreatePrimarySurface(pDDrawSurface);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("InitDirectDraw failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if argument is not NULL, delete output pin
    if (pDDrawSurface)
    {
        // get rid of the output pin
        delete m_pOutput;
        m_pOutput = NULL;
        IncrementPinVersion();

        m_bExternalPrimarySurface = TRUE;
    }
    else
    {
        // create an outpin pin here
        if (!m_pOutput)
        {
            // Allocate the output pin
            m_pOutput = new COMOutputPin(NAME("OverlayMixer output pin"), this, &m_csFilter, &hr, L"Output",  m_dwMaxPinId);

            // if creation of output pin fails, it is catastrophic and there is nothing we can do about that
            if (!m_pOutput || FAILED(hr))
            {
                if (SUCCEEDED(hr))
                    hr = E_OUTOFMEMORY;

                DbgLog((LOG_ERROR, 1, TEXT("Unable to create the output pin, hr = 0x%x"), hr));
                goto CleanUp;
            }
            IncrementPinVersion();

            // increament the pin id counter
            m_dwMaxPinId++;
        }


        m_bExternalPrimarySurface = FALSE;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::SetDDrawSurface")));
    return hr;
}

// gets the ddraw surface currently being used by the overlay mixer. If the app has not
// set any ddraw surface and the ovmixer has not yet allocated one, then *ppDDrawSurface
// will be set to NULL and *pbUsingExternal will be set to FALSE. Otherwise *pbUsingExternal
// will be set to TRUE if the ovmixer is currently USING an app given ddraw surface and FALSE
// otherwise
STDMETHODIMP COMFilter::GetDDrawSurface(LPDIRECTDRAWSURFACE *ppDDrawSurface, LPBOOL pbUsingExternal)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetDDrawSurface")));

    hr = CanExclusiveMode();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CanExclusiveMode failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (!ppDDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("invalid argument, ppDDrawObject == NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pbUsingExternal)
    {
        DbgLog((LOG_ERROR, 1, TEXT("invalid argument, ppDDrawObject == NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    *ppDDrawSurface = m_pPrimarySurface;
    if (m_pPrimarySurface)
        m_pPrimarySurface->AddRef();

    *pbUsingExternal = m_bExternalPrimarySurface;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetDDrawSurface")));
    return hr;
}

// this function is used to give a source and dest rect to the filter in
// the event that an external primary surface has been provided
STDMETHODIMP COMFilter::SetDrawParameters(LPCRECT prcSource, LPCRECT prcTarget)
{
    HRESULT hr = NOERROR;
    RECT ScreenRect;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::SetDrawParamters")));

    hr = CanExclusiveMode();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CanExclusiveMode failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if it is not an external primary surface, we are not windowless, so calling this
    // function does not make sense
    if (!m_bExternalPrimarySurface)
    {
        hr = E_UNEXPECTED;
        DbgLog((LOG_ERROR, 1, TEXT("m_bExternalPrimarySurface is false, so exiting funtion,")));
        goto CleanUp;
    }

    if (!prcTarget)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR, 1, TEXT("NULL target rect pointer, so exiting funtion,")));
        goto CleanUp;
    }

    memset(&m_WinInfo, 0, sizeof(WININFO));

    if (prcSource)
    {
        m_WinInfo.SrcRect = *prcSource;
        if (!m_UsingIDDrawNonExclModeVideo) {
            ScaleRect(&m_WinInfo.SrcRect, (double)MAX_REL_NUM, (double)MAX_REL_NUM, (double)m_dwAdjustedVideoWidth, (double)m_dwAdjustedVideoHeight);
        }
    }
    else
    {
        SetRect(&m_WinInfo.SrcRect, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
    }

    // make sure that the target rect specified by the app is within the screen coordinates
    // of the current monitor. Currently the ovmixer is not multimon aware and therefore the
    // macrovsion bits are only checked on the primary vga card. So essentially this is a
    // safeguard for dvd
    m_WinInfo.DestRect = *prcTarget;
    IntersectRect(&m_WinInfo.DestClipRect, prcTarget, &m_lpCurrentMonitor->rcMonitor);
    m_bWinInfoStored = TRUE;

    OnDrawAll();

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::SetDrawParamters")));
    return hr;
}

// Note that
// IAMDDrawExclusiveMode::GetVideoSize() is implemented as part of IMixerOCX interface.


LPDIRECTDRAW COMFilter::GetDirectDraw()
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetDirectDraw")));

    CAutoLock l(&m_csFilter);

    ASSERT(!m_bUseGDI);
    if (!m_pDirectDraw)
    {
        hr = InitDirectDraw(NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function InitDirectDraw failed, hr = 0x%x"), hr));
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetDirectDraw")));
    ASSERT(m_pDirectDraw);
    return m_pDirectDraw;
}

LPDDCAPS COMFilter::GetHardwareCaps()
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetHardwareCaps")));

    CAutoLock l(&m_csFilter);

    ASSERT(!m_bUseGDI);

    if (!m_pDirectDraw)
    {
        hr = InitDirectDraw(NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function InitDirectDraw failed, hr = 0x%x"), hr));
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetHardwareCaps")));

    if (m_pDirectDraw)
    {
        return &m_DirectCaps;
    }
    else
    {
        return NULL;
    }
}

LPDIRECTDRAWSURFACE COMFilter::GetPrimarySurface()
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetPrimarySurface")));

    CAutoLock l(&m_csFilter);

    ASSERT(!m_bUseGDI);

    if (!m_pPrimarySurface && m_pDirectDraw)
    {
        // create the primary surface, set the colorkey on it etc
        hr = RecreatePrimarySurface(NULL);
        if (FAILED(hr))
        {
            hr = NOERROR;
            goto CleanUp;
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetPrimarySurface")));
    return m_pPrimarySurface;
}



/*****************************Private*Routine******************************\
* LoadDDrawLibrary
*
* Loads the DDraw library and tries to get pointer to DirectDrawCreate,
* DirectDrawEnum and DirectDrawEnumEx.
*
* History:
* Thu 08/26/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
LoadDDrawLibrary(
    HINSTANCE& hDirectDraw,
    LPDIRECTDRAWCREATE& lpfnDDrawCreate,
    LPDIRECTDRAWENUMERATEA& lpfnDDrawEnum,
    LPDIRECTDRAWENUMERATEEXA& lpfnDDrawEnumEx
    )
{
    UINT ErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hDirectDraw = LoadLibrary(TEXT("DDRAW.DLL"));
    SetErrorMode(ErrorMode);

    if (!hDirectDraw) {
        return AmHresultFromWin32(ERROR_DLL_NOT_FOUND);
    }


    lpfnDDrawCreate = (LPDIRECTDRAWCREATE)GetProcAddress(
            hDirectDraw, "DirectDrawCreate");

    if (!lpfnDDrawCreate) {
        return AmHresultFromWin32(ERROR_PROC_NOT_FOUND);
    }


    lpfnDDrawEnum = (LPDIRECTDRAWENUMERATEA)GetProcAddress(
            hDirectDraw, "DirectDrawEnumerateA");
    if (!lpfnDDrawEnum) {
        return AmHresultFromWin32(ERROR_PROC_NOT_FOUND);
    }

    lpfnDDrawEnumEx = (LPDIRECTDRAWENUMERATEEXA)GetProcAddress(
            hDirectDraw, "DirectDrawEnumerateExA");

    return S_OK;

}

/*****************************Private*Routine******************************\
* CreateDirectDrawObject
*
*
*
* History:
* Fri 08/20/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CreateDirectDrawObject(
    const AMDDRAWGUID& GUID,
    LPDIRECTDRAW *ppDirectDraw,
    LPDIRECTDRAWCREATE lpfnDDrawCreate
    )
{
    UINT ErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    HRESULT hr = (*lpfnDDrawCreate)(GUID.lpGUID, ppDirectDraw, NULL);
    SetErrorMode(ErrorMode);
    return hr;
}


// This function is used to allocate the direct-draw related resources.
// This includes allocating the direct-draw service provider
HRESULT COMFilter::InitDirectDraw(LPDIRECTDRAW pDirectDraw)
{
    HRESULT hr = NOERROR;
    HRESULT hrFailure = VFW_E_DDRAW_CAPS_NOT_SUITABLE;
    DDSURFACEDESC SurfaceDescP;
    int i;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::InitDirectDraw")));

    CAutoLock l(&m_csFilter);

    // release the existing primary surface, since it might be inconsistent with the
    // new ddraw object
    ReleasePrimarySurface();

    // addref the new ddraw object
    if (pDirectDraw)
    {
        pDirectDraw->AddRef();
    }
    else if (m_UsingIDDrawNonExclModeVideo) {
        pDirectDraw = m_pUpdatedDirectDraw;
        m_pUpdatedDirectDraw = NULL;
    }

    // release the previous direct draw object if any
    ReleaseDirectDraw();

    // if given a valid ddraw object, make a copy of it (we have already addref'd it)
    // else allocate your own
    if (pDirectDraw)
    {
        m_pDirectDraw = pDirectDraw;
        m_bExternalDirectDraw = TRUE;
    }
    else
    {
        // Ask the loader to create an instance
        DbgLog((LOG_TRACE, 2, TEXT("Creating a DDraw device on %hs monitor"),
                m_lpCurrentMonitor->szDevice));

        //hr = LoadDirectDraw(m_achMonitor, &m_pDirectDraw, &m_hDirectDraw);
        hr = CreateDirectDrawObject(m_lpCurrentMonitor->guid,
                                    &m_pDirectDraw, m_lpfnDDrawCreate);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function InitDirectDraw, LoadDirectDraw failed")));
            hr = hrFailure;
            goto CleanUp;
        }

        m_bExternalDirectDraw = FALSE;
    }

    // Initialise our capabilities structures
    ASSERT(m_pDirectDraw);

    INITDDSTRUCT(m_DirectCaps);
    INITDDSTRUCT(m_DirectSoftCaps);

    // Load the hardware and emulation capabilities
    hr = m_pDirectDraw->GetCaps(&m_DirectCaps,&m_DirectSoftCaps);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDraw->GetCapsGetCaps failed")));
        hr = hrFailure;
        goto CleanUp;
    }

    // Get the kernel caps
    IDirectDrawKernel *pDDKernel;
    if (SUCCEEDED(m_pDirectDraw->QueryInterface(
            IID_IDirectDrawKernel, (void **)&pDDKernel))) {
        DDKERNELCAPS ddCaps;
        ddCaps.dwSize = sizeof(ddCaps);
        if (SUCCEEDED(pDDKernel->GetCaps(&ddCaps))) {
            m_dwKernelCaps = ddCaps.dwCaps;
        }
        pDDKernel->Release();
    }

    // make sure the caps are ok
    hr = CheckCaps();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckCaps failed")));
        goto CleanUp;
    }

    if (!m_bExternalDirectDraw)
    {
        // Set the cooperation level on the surface to be shared
        hr = m_pDirectDraw->SetCooperativeLevel(NULL, DDSCL_NORMAL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDraw->SetCooperativeLevel failed")));
            hr = hrFailure;
            goto CleanUp;
        }
    }

    // if we have reached this point, we should have a valid ddraw object
    ASSERT(m_pDirectDraw);

CleanUp:

    // anything fails, might as well as release the whole thing
    if (FAILED(hr))
    {
        ReleaseDirectDraw();
    }
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::InitDirectDraw")));
    return hr;
}

HRESULT COMFilter::CheckCaps()
{
    HRESULT hr = NOERROR;
    DWORD dwMinStretch, dwMaxStretch;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::CheckCaps")));

    CAutoLock l(&m_csFilter);

    if (m_DirectCaps.dwCaps2 & DDCAPS2_VIDEOPORT)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Device does support a Video Port")));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Device does not support a Video Port")));
    }


    if(m_DirectCaps.dwCaps & DDCAPS_OVERLAY)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Device does support Overlays")));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Device does not support Overlays")));
    }

    // get all direct-draw capabilities
    if (m_DirectCaps.dwCaps & DDCAPS_OVERLAYSTRETCH)
    {
        DbgLog((LOG_TRACE, 1, TEXT("hardware can support overlay strecthing")));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("hardware can't support overlay strecthing")));
    }

    // get the alignment restriction on src boundary
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNBOUNDARYSRC)
    {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignBoundarySrc = %d"), m_DirectCaps.dwAlignBoundarySrc));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on BoundarySrc")));
    }

    // get the alignment restriction on dest boundary
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNBOUNDARYDEST)
    {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignBoundaryDest = %d"), m_DirectCaps.dwAlignBoundaryDest));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on BoundaryDest")));
    }

    // get the alignment restriction on src size
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNSIZESRC)
    {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignSizeSrc = %d"), m_DirectCaps.dwAlignSizeSrc));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on SizeSrc")));
    }

    // get the alignment restriction on dest size
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNSIZEDEST)
    {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignSizeDest = %d"), m_DirectCaps.dwAlignSizeDest));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on SizeDest")));
    }

    if (m_DirectCaps.dwMinOverlayStretch)
    {
        dwMinStretch = m_DirectCaps.dwMinOverlayStretch;
        DbgLog((LOG_TRACE, 1, TEXT("Min Stretch = %d"), dwMinStretch));
    }

    if (m_DirectCaps.dwMaxOverlayStretch)
    {
        dwMaxStretch = m_DirectCaps.dwMaxOverlayStretch;
        DbgLog((LOG_TRACE, 1, TEXT("Max Stretch = %d"), dwMaxStretch));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKX))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKX")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKXN))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKXN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKY))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKY")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKYN))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKYN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHX))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHX")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHXN))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHXN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHY))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHY")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHYN))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHYN")));
    }

    if ((m_DirectCaps.dwSVBFXCaps & DDFXCAPS_BLTARITHSTRETCHY))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver uses arithmetic operations to blt from system to video")));
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Driver uses pixel-doubling to blt from system to video")));
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::CheckCaps")));
    return hr;
}


// this function is used to release the resources allocated by the function
// "InitDirectDraw". these include the direct-draw service provider and the
// primary surfaces
DWORD COMFilter::ReleaseDirectDraw()
{
    AMTRACE((TEXT("COMFilter::ReleaseDirectDraw")));
    DWORD dwRefCnt = 0;

    CAutoLock l(&m_csFilter);

    // Release any DirectDraw provider interface
    DbgLog((LOG_TRACE, 1, TEXT("Release DDObj 0x%p\n"), m_pDirectDraw));
    if (m_pDirectDraw)
    {
        //
        // Gross Hack ALERT !!
        //
        if (GetModuleHandle(TEXT("VBISURF.AX")) ||
            GetModuleHandle(TEXT("VBISURF.DLL"))) {

            //
            // In its wisdom, DDraw deletes all DDraw resources created in the
            // process when any DDraw Object in that process gets deleted -
            // regardless of whether this DDraw object created them or not.  This
            // only becomes a problem if the VBISURF filter is present in the
            // filter graph as it creates its own DDraw Object which it may
            // use after we delete ours.  This means that any surfaces, VP objects
            // that VBISURF creates get destroyed when we delete our DDraw object.
            //
            // The solution: leak the DDraw object !!
            //
        }
        else {
            dwRefCnt = m_pDirectDraw->Release();
        }
        m_pDirectDraw = NULL;
    }

    ZeroMemory(&m_DirectCaps, sizeof(DDCAPS));
    ZeroMemory(&m_DirectSoftCaps, sizeof(DDCAPS));

    return dwRefCnt;
}

// function to create the primary surface
HRESULT COMFilter::CreatePrimarySurface()
{
    HRESULT hr = E_FAIL;
    DDSURFACEDESC SurfaceDescP;
    DWORD dwInputPinCount = 0, i = 0;
    COMInputPin *pInputPin = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::CreatePrimarySurface")));

    CAutoLock l(&m_csFilter);
    if (m_pDirectDraw) {
        ASSERT(m_pPrimarySurface == NULL);

        // Create the primary surface
        INITDDSTRUCT(SurfaceDescP);
        SurfaceDescP.dwFlags = DDSD_CAPS;
        SurfaceDescP.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
        hr = m_pDirectDraw->CreateSurface(&SurfaceDescP, &m_pPrimarySurface, NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function CreatePrimarySurface failed, hr = 0x%x"), hr));
            m_pPrimarySurface = NULL;
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::CreatePrimarySurface")));
    return hr;
}

// function to release the primary surface
DWORD COMFilter::ReleasePrimarySurface()
{
    AMTRACE((TEXT("COMFilter::ReleasePrimarySurface")));
    HRESULT hr = NOERROR;
    DWORD dwRefCount = 0;

    CAutoLock l(&m_csFilter);

    if (m_pPrimarySurface)
    {
        dwRefCount = m_pPrimarySurface->Release();
        m_pPrimarySurface = NULL;
    }

    return dwRefCount;
}


HRESULT ComputeSurfaceRefCount(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    DWORD dwRefCount = 0;
    if (!pDDrawSurface)
    {
        DbgLog((LOG_TRACE, 5, TEXT("ComputeSurfaceRefCount, pDDrawSurface is NULL")));
        return NOERROR;
    }

    pDDrawSurface->AddRef();
    dwRefCount = pDDrawSurface->Release();
    DbgLog((LOG_TRACE, 5, TEXT("ComputeSurfaceRefCount, dwRefCount = %d"), dwRefCount));
    return NOERROR;
}

// this function is used to tell the filter, what the colorkey is. Also sets the
// colorkey on the primary surface
// The semantics is that in the palettized mode, if pColorKey->KeyType & CK_INDEX is
// set, that the index specified in the colorkey will be used otherwise the colorref
// will be used.
// if pColorKey->KeyType & CK_RGB is not set, the function returns E_INVALIDARG even
// if the mode is palettized right now, because we need teh colorref if the display mode
// changes.
HRESULT COMFilter::SetColorKey(COLORKEY *pColorKey)
{
    HRESULT hr = NOERROR;
    DDCOLORKEY DDColorKey;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::SetColorKey")));

    CAutoLock l(&m_csFilter);

#if defined(DEBUG)
    DbgLog((LOG_TRACE, 5, TEXT("Type       =0x%8.8X"), pColorKey->KeyType));
    switch (pColorKey->KeyType) {
    case CK_INDEX:
        DbgLog((LOG_TRACE, 5, TEXT("Invalid Key Type")));
        break;

    case CK_INDEX|CK_RGB:
        DbgLog((LOG_TRACE, 5, TEXT("Index  =0x%8.8X"), pColorKey->PaletteIndex));
        break;

    case CK_RGB:
        DbgLog((LOG_TRACE, 5, TEXT("LoColor=0x%8.8X"), pColorKey->LowColorValue));
        DbgLog((LOG_TRACE, 5, TEXT("HiColor=0x%8.8X"), pColorKey->HighColorValue));
        break;
    }
#endif

    // check for valid pointer
    if (!pColorKey)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pColorKey is NULL")));
        hr = E_POINTER;
        goto CleanUp;
    }

    // check for valid flags
    if (!(pColorKey->KeyType & CK_RGB))
    {
        DbgLog((LOG_ERROR, 1, TEXT("!(pColorKey->KeyType & CK_RGB)")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // check for primary surface
    if (!m_pPrimarySurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pPrimarySurface is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // check if the display is palettised on not
    if ((m_Display.IsPalettised()) &&
        (pColorKey->KeyType & CK_INDEX))
    {
        if ( (pColorKey->PaletteIndex > 255))
        {
            DbgLog((LOG_ERROR, 1, TEXT("pColorKey->PaletteIndex invalid")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }

        DDColorKey.dwColorSpaceLowValue = pColorKey->PaletteIndex;
        DDColorKey.dwColorSpaceHighValue = pColorKey->PaletteIndex;
    }

    else

    {
        DWORD dwColorVal;
        dwColorVal = DDColorMatch(m_pPrimarySurface, pColorKey->LowColorValue, hr);

        if (FAILED(hr)) {
            dwColorVal = DDColorMatchOffscreen(m_pDirectDraw, pColorKey->LowColorValue, hr);
        }
        DDColorKey.dwColorSpaceLowValue = dwColorVal;
        DDColorKey.dwColorSpaceHighValue = dwColorVal;
    }


    // Tell the primary surface what to expect
    hr = m_pPrimarySurface->SetColorKey(DDCKEY_DESTOVERLAY, &DDColorKey);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("pPrimarySurface->SetColorKey failed")));
        goto CleanUp;
    }

    // store the colorkey
    m_ColorKey = *pColorKey;
    m_bColorKeySet = TRUE;

    // Notify color key changes
    if (m_pExclModeCallback) {
        m_pExclModeCallback->OnUpdateColorKey(&m_ColorKey,
                                              DDColorKey.dwColorSpaceLowValue);
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::SetColorKey")));
    return hr;
}

HRESULT COMFilter::GetColorKey(COLORKEY *pColorKey, DWORD *pColor)
{
    HRESULT hr =  NOERROR;
    DWORD dwColor = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetColorKey")));

    CAutoLock l(&m_csFilter);

    ASSERT(pColorKey != NULL || pColor != NULL);

    if (pColorKey)
    {
        *pColorKey = m_ColorKey;
    }

    if (pColor)
    {
        if (!m_pPrimarySurface)
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pPrimarySurface = NULL, returning E_UNEXPECTED")));
            hr = E_UNEXPECTED;
            goto CleanUp;
        }

        if (m_Display.IsPalettised() && (m_ColorKey.KeyType & CK_INDEX))
        {
            dwColor = m_ColorKey.PaletteIndex;
        }
        else
        {
            dwColor = DDColorMatch(m_pPrimarySurface, m_ColorKey.LowColorValue, hr);
            if (FAILED(hr)) {
                dwColor = DDColorMatchOffscreen(m_pDirectDraw, m_ColorKey.LowColorValue, hr);
            }
        }

        *pColor = dwColor;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetColorKey")));
    return hr;
}

HRESULT COMFilter::PaintColorKey(HRGN hPaintRgn, COLORKEY *pColorKey)
{

    HRESULT hr = NOERROR;

    LPRGNDATA pBuffer = NULL;
    DWORD dwTemp, dwBuffSize = 0, dwRetVal = 0;
    LPRECT pDestRect;
    DDBLTFX ddFX;
    DWORD dwColorKey;
    HBRUSH hBrush = NULL;
    HDC hdc = NULL;

    CAutoLock l(&m_csFilter);

    ASSERT(pColorKey);

    // if it is an external primary surface, do not paint anything on the primary surface
    if (m_bExternalPrimarySurface)
    {
        DbgLog((LOG_TRACE, 2, TEXT("m_bExternalPrimarySurface is true, so exiting funtion,")));
        goto CleanUp;
    }

    if (m_bUseGDI)
    {
        hBrush = CreateSolidBrush(pColorKey->LowColorValue);
        if ( ! hBrush )
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        hdc = GetDestDC();
        if ( ! hdc )
        {
            hr = E_OUTOFMEMORY;
            DeleteObject( hBrush );
            goto CleanUp;
        }

        OffsetRgn(hPaintRgn, -m_WinInfo.TopLeftPoint.x, -m_WinInfo.TopLeftPoint.y);
        FillRgn(hdc, hPaintRgn, hBrush);

        // Delete the GDI objects we created
        EXECUTE_ASSERT(DeleteObject(hBrush));

        goto CleanUp;
    }


    ASSERT(m_pPrimarySurface);

    dwRetVal = GetRegionData(hPaintRgn, 0, NULL);
    ASSERT(dwRetVal);
    dwBuffSize = dwRetVal;
    pBuffer = (LPRGNDATA) new char[dwBuffSize];
    if ( ! pBuffer )
        return S_OK;    // dont propagate error, since CleanUp does not

    dwRetVal = GetRegionData(hPaintRgn, dwBuffSize, pBuffer);
    ASSERT(pBuffer->rdh.iType == RDH_RECTANGLES);

    //ASSERT(dwBuffSize == (pBuffer->rdh.dwSize + pBuffer->rdh.nRgnSize));

    dwColorKey = DDColorMatch(m_pPrimarySurface, pColorKey->LowColorValue, hr);
    if (FAILED(hr)) {
        dwColorKey = DDColorMatchOffscreen(m_pDirectDraw, pColorKey->LowColorValue, hr);
    }

    // Peform a DirectDraw colorfill BLT.  DirectDraw will automatically
    // query the attached clipper object, handling occlusion.
    INITDDSTRUCT(ddFX);
    ddFX.dwFillColor = dwColorKey;

    for (dwTemp = 0; dwTemp < pBuffer->rdh.nCount; dwTemp++)
    {
        pDestRect = (LPRECT)((char*)pBuffer + pBuffer->rdh.dwSize + dwTemp*sizeof(RECT));
        ASSERT(pDestRect);

        RECT TargetRect = *pDestRect;
        OffsetRect(&TargetRect,
                   -m_lpCurrentMonitor->rcMonitor.left,
                   -m_lpCurrentMonitor->rcMonitor.top);

        hr = m_pPrimarySurface->Blt(&TargetRect, NULL, NULL,
                                    DDBLT_COLORFILL | DDBLT_WAIT, &ddFX);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0, TEXT("m_pPrimarySurface->Blt failed, hr = 0x%x"), hr));
            DbgLog((LOG_ERROR,0, TEXT("Destination Rect = {%d, %d, %d, %d}"),
                pDestRect->left, pDestRect->top, pDestRect->right, pDestRect->bottom));
            goto CleanUp;
        }
    }

CleanUp:
    delete [] pBuffer;
    // !!! return hr;
    return S_OK;
}

void COMFilter::GetPinsInZOrder(DWORD *pdwZOrder)
{
    BOOL bMisMatchFound;
    int i;
    DWORD temp;

    for (i = 0; i < (int)m_dwInputPinCount; i++)
    {
        pdwZOrder[i] = i;
    }

    do
    {
        bMisMatchFound = FALSE;

        for (i = 0; i < (int)m_dwInputPinCount-1; i++)
        {
            if (m_apInput[pdwZOrder[i + 1]]->GetInternalZOrder() <
                m_apInput[pdwZOrder[i]]->GetInternalZOrder())
            {
                temp = pdwZOrder[i+1];
                pdwZOrder[i+1] = pdwZOrder[i];
                pdwZOrder[i] = temp;
                bMisMatchFound = TRUE;
            }
        }
    }
    while (bMisMatchFound);
}

BOOL DellDVDPlayer()
{
    TCHAR szModuleName[MAX_PATH];
    static const TCHAR szDellPlayer[] = TEXT("viewdvd.exe");

    if (0 != GetModuleFileName((HMODULE)NULL, szModuleName, MAX_PATH))
    {
        TCHAR   szPathName[2 * MAX_PATH];
        TCHAR*  lpszFileName;

        if (0 != GetFullPathName(szModuleName, 2 * MAX_PATH,
                                 szPathName, &lpszFileName))
        {
            return 0 == lstrcmpi(lpszFileName, szDellPlayer);
        }
    }

    return FALSE;
}

HRESULT COMFilter::OnShowWindow(HWND hwnd, BOOL fShow)
{
    HRESULT hr = E_FAIL;

    RECT rcSrc = m_WinInfo.SrcRect, rcDest;

    if (fShow)
    {
        if (!DellDVDPlayer()) {

            // Restore the original destination rect
            IBasicVideo* Ibv = NULL;
            hr = GetBasicVideoFromOutPin(&Ibv);
            if (SUCCEEDED(hr))
            {
                hr = Ibv->GetDestinationPosition(&rcDest.left, &rcDest.top,
                                                 &rcDest.right, &rcDest.bottom);
                if (SUCCEEDED(hr))
                {
                    rcDest.right += rcDest.left;
                    rcDest.bottom += rcDest.top;
                    MapWindowPoints(hwnd, HWND_DESKTOP, (LPPOINT)&rcDest, 2);
                }
                Ibv->Release();
            }

            if (SUCCEEDED(hr))
            {
                hr = OnClipChange(&rcSrc, &rcDest, NULL);
            }

        }

        // else, we arn't connected to a Video Renderer so do nothing
        // which is what the original code would have done.
    }
    else
    {
        // make the dest empty
        SetRect(&rcDest, 0, 0, 0, 0);
        hr = OnClipChange(&rcSrc, &rcDest, NULL);
    }

    return hr;
}

HDC COMFilter::GetDestDC()
{
    if (m_pOutput)
        return m_pOutput->GetDC();
    else
        return m_hDC;
}

HWND COMFilter::GetWindow()
{
    if (m_pOutput)
        return m_pOutput->GetWindow();
    else
        return NULL;
}


HRESULT COMFilter::OnDrawAll()
{
    HRESULT hr = NOERROR;
    HRGN hMainRgn = NULL, hUncroppedMainRgn = NULL, hSubRgn = NULL, hBlackRgn = NULL;
    RECT rSubPinDestRect, rUncroppedDestRect;
    DRECT rdSrcRect, rdDestRect;
    DWORD i, j, dwInputPinCount = 0, dwBlendingParameter = 0, dwNextPinInZOrder = 0;
    int iRgnType = 0;
    COMInputPin *pPin;
    WININFO WinInfo;
    COLORKEY blackColorKey;
    BOOL bStreamTransparent = FALSE;
    DWORD pdwPinsInZOrder[MAX_PIN_COUNT];

    DbgLog((LOG_TRACE,2,TEXT("Entering OnDrawAll")));

    CAutoLock l(&m_csFilter);

    if (!m_bWinInfoStored)
    {
        goto CleanUp;
    }

    // if there is no primary surface in the non-GDI case, no point in going on
    if (!m_bUseGDI && !m_pPrimarySurface)
    {
        DbgLog((LOG_ERROR,2,TEXT("the Primary Surface is NULL")));
        goto CleanUp;
    }

    // we will use black on the rest of the region left
    blackColorKey.KeyType = CK_INDEX | CK_RGB;
    blackColorKey.PaletteIndex = 0;
    blackColorKey.LowColorValue = blackColorKey.HighColorValue = RGB(0,0,0);

    // make a region out of the destination clip rect
    hBlackRgn = CreateRectRgnIndirect(&m_WinInfo.DestClipRect);
    if (!hBlackRgn)
    {
        DbgLog((LOG_TRACE,5,TEXT("CreateRectRgnIndirect(&m_WinInfo.DestClipRect) failed")));
        goto CleanUp;
    }

    // the first pin has to be connected, otherwise bail out
    if (!m_apInput[0]->IsCompletelyConnected())
    {
        //  REVIEW - when can this happen?
        DbgLog((LOG_TRACE,5,TEXT("None of the input pins are connected")));

        // paint the remaining region black
        hr = PaintColorKey(hBlackRgn, &blackColorKey);
        ASSERT(SUCCEEDED(hr));

        //  REVIEW CleanUp will clean up hBlackRgn
        goto CleanUp;
    }

    ASSERT(!IsRectEmpty(&m_WinInfo.SrcRect));

    // copy m_WinInfo.SrcRect into rdDestRect
    SetRect(&rdSrcRect, m_WinInfo.SrcRect.left, m_WinInfo.SrcRect.top, m_WinInfo.SrcRect.right, m_WinInfo.SrcRect.bottom);
    ASSERT((m_dwAdjustedVideoWidth != 0) && (m_dwAdjustedVideoHeight != 0));
    ScaleRect(&rdSrcRect, (double)m_dwAdjustedVideoWidth, (double)m_dwAdjustedVideoHeight, (double)MAX_REL_NUM, (double)MAX_REL_NUM);

    // copy m_WinInfo.DestRect into rdDestRect
    SetRect(&rdDestRect, m_WinInfo.DestRect.left, m_WinInfo.DestRect.top, m_WinInfo.DestRect.right, m_WinInfo.DestRect.bottom);

    dwInputPinCount = m_dwInputPinCount;
    ASSERT(dwInputPinCount >= 1);

    // get the pointer to an array in which the pin numbers are stored in increasing z order
    // the number of elements in that array is the input pin count
    GetPinsInZOrder(pdwPinsInZOrder);

    for (i = 0; i < dwInputPinCount; i++)
    {
        ASSERT(hMainRgn == NULL);

        // get the pin number with the next lower most z order
        dwNextPinInZOrder = pdwPinsInZOrder[i];
        ASSERT( dwNextPinInZOrder <= dwInputPinCount);

        // get the corresponding pin
        pPin = m_apInput[dwNextPinInZOrder];
        ASSERT(pPin);

        // get the pin's blending parameter
        hr = pPin->GetBlendingParameter(&dwBlendingParameter);
        ASSERT(SUCCEEDED(hr));

        if ((!pPin->IsCompletelyConnected()) || (dwBlendingParameter == 0))
            continue;

        memset(&WinInfo, 0, sizeof(WININFO));

        WinInfo.TopLeftPoint = m_WinInfo.TopLeftPoint;

        // ask the pin about its rectangles
        pPin->CalcSrcDestRect(&rdSrcRect, &rdDestRect, &WinInfo.SrcRect, &WinInfo.DestRect, &rUncroppedDestRect);

        // make sure the rect is clipped within the m_WinInfo.DestClipRect
        IntersectRect(&WinInfo.DestClipRect, &WinInfo.DestRect, &m_WinInfo.DestClipRect);

        // make a region out of it
        hMainRgn = CreateRectRgnIndirect(&WinInfo.DestClipRect);
        if (!hMainRgn)
            continue;

        // make a region out of it
        hUncroppedMainRgn = CreateRectRgnIndirect(&rUncroppedDestRect);
        if (!hUncroppedMainRgn)
            //  REVIEW won't we leak hMainRgn here?
            continue;

        // Update the new black region by subtracting the main region from it
        iRgnType = CombineRgn(hBlackRgn, hBlackRgn, hUncroppedMainRgn, RGN_DIFF);
        if (iRgnType == ERROR)
        {
            DbgLog((LOG_ERROR,0, TEXT("CombineRgn(hBlackRgn, hNewPrimRgn, hBlackRgn, RGN_DIFF) FAILED")));
            goto CleanUp;
        }


        for (j = i+1; j < dwInputPinCount; j++)
        {
            ASSERT(hSubRgn == NULL);

            // get the pin number with the next lower most z order
            dwNextPinInZOrder = pdwPinsInZOrder[j];
            ASSERT( dwNextPinInZOrder <= dwInputPinCount);

            // assert that the z order of the sub pin is higher than that of the ain pin
            ASSERT(m_apInput[pdwPinsInZOrder[j]]->GetInternalZOrder() >
                   m_apInput[pdwPinsInZOrder[i]]->GetInternalZOrder());

            // get the sub pin
            pPin = m_apInput[dwNextPinInZOrder];
            ASSERT(pPin);

            // get the pin's blending parameter
            hr = pPin->GetBlendingParameter(&dwBlendingParameter);
            ASSERT(SUCCEEDED(hr));

            // check if the secondary stream is transparent. If it is, then we shouldn't
            // subtract its region from the main region
            hr = pPin->GetStreamTransparent(&bStreamTransparent);
            ASSERT(SUCCEEDED(hr));

            if ((!pPin->IsCompletelyConnected()) || (dwBlendingParameter == 0) || (bStreamTransparent))
                continue;

            // ask the pin about its destination rectangle, we are not interested in the
            // source rect
            pPin->CalcSrcDestRect(&rdSrcRect, &rdDestRect, NULL, &rSubPinDestRect, NULL);
            if (IsRectEmpty(&rSubPinDestRect))
                continue;

            // make sure the rect is clipped within the m_WinInfo.DestClipRect
            IntersectRect(&rSubPinDestRect, &rSubPinDestRect, &m_WinInfo.DestClipRect);

            // make a region out of it
            hSubRgn = CreateRectRgnIndirect(&rSubPinDestRect);

            //  REVIEW - presumably this can be NULL though right?
            ASSERT(hSubRgn);

            // adjust the primary region
            iRgnType = CombineRgn(hMainRgn, hMainRgn, hSubRgn, RGN_DIFF);
            if (iRgnType == ERROR)
            {
                // now the hNewPrimRgn might be in a bad state, bail out
                DbgLog((LOG_ERROR,0, TEXT("CombineRgn(hMainRgn, hMainRgn, hSubRgn, RGN_DIFF) FAILED, UNEXPECTED!!")));
            }

            DeleteObject(hSubRgn);
            hSubRgn = NULL;
        }

        WinInfo.hClipRgn = hMainRgn;

        DbgLog((LOG_TRACE, 2, TEXT("Printing WinInfo")));
        DbgLog((LOG_TRACE, 2, TEXT("SrcRect = %d, %d, %d, %d"), WinInfo.SrcRect.left,
            WinInfo.SrcRect.top, WinInfo.SrcRect.right, WinInfo.SrcRect.bottom));
        DbgLog((LOG_TRACE, 2, TEXT("DestRect = %d, %d, %d, %d"), WinInfo.DestRect.left,
            WinInfo.DestRect.top, WinInfo.DestRect.right, WinInfo.DestRect.bottom));

        // get the pin number from i
        dwNextPinInZOrder = pdwPinsInZOrder[i];
        ASSERT( dwNextPinInZOrder <= dwInputPinCount);

        // get the corresponding pin
        pPin = m_apInput[dwNextPinInZOrder];
        ASSERT(pPin);

        // ask the pin to draw its contents
        pPin->OnClipChange(&WinInfo);

        // should we delete hMainRgn here??
        if (hMainRgn)
        {
            DeleteObject(hMainRgn);
            hMainRgn = NULL;
        }

        if (hUncroppedMainRgn)
        {
            DeleteObject(hUncroppedMainRgn);
            hUncroppedMainRgn = NULL;
        }
    }

    // paint the remaining region black
    hr = PaintColorKey(hBlackRgn, &blackColorKey);
    ASSERT(SUCCEEDED(hr));
    DeleteObject(hBlackRgn);
    hBlackRgn = NULL;


CleanUp:
    if (hMainRgn)
    {
        DeleteObject(hMainRgn);
        hMainRgn = NULL;
    }

    if (hUncroppedMainRgn)
    {
        DeleteObject(hUncroppedMainRgn);
        hUncroppedMainRgn = NULL;
    }

    if (hSubRgn)
    {
        DeleteObject(hSubRgn);
        hSubRgn = NULL;
    }

    if (hBlackRgn)
    {
        DeleteObject(hBlackRgn);
        hBlackRgn = NULL;
    }

    return hr;
}

// gets the number and pointer to the palette enteries
HRESULT COMFilter::GetPaletteEntries(DWORD *pdwNumPaletteEntries, PALETTEENTRY **ppPaletteEntries)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetPaletteEntries")));

    if (!pdwNumPaletteEntries)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwNumPaletteEntries is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!ppPaletteEntries)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppPaletteEntries is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        CAutoLock l(&m_csFilter);
        if (m_dwNumPaletteEntries == 0)
        {
            DbgLog((LOG_ERROR, 1, TEXT("no palette, returning E_FAIL, m_dwNumPaletteEntries = %d, m_pPaletteEntries = 0x%x"),
                m_dwNumPaletteEntries, m_pPaletteEntries));
            hr = E_FAIL;
            goto CleanUp;
        }

        *pdwNumPaletteEntries = m_dwNumPaletteEntries;
        *ppPaletteEntries = m_pPaletteEntries;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetPaletteEntries")));
    return hr;
}


STDMETHODIMP COMFilter::OnColorKeyChange(const COLORKEY *pColorKey)          // Defines new colour key
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::OnColorKeyChange")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::OnColorKeyChange")));

    return NOERROR;
}


STDMETHODIMP COMFilter::OnClipChange(const RECT* pSrcRect, const RECT* pDestRect,
                                     const RGNDATA * pRegionData)
{
    HRESULT hr = NOERROR;
    HWND hwnd;
    DbgLog((LOG_TRACE,5,TEXT("Entering OnClipChange")));

    {
        CAutoLock l(&m_csFilter);

        ASSERT(pSrcRect && pDestRect);
        hwnd = m_pOutput->GetWindow();

        // totally empty rectangles means that the window is in transition
        if (IsRectEmpty(pSrcRect))
        {
            DbgLog((LOG_TRACE,5,TEXT("the source rectangle is empty")));
            goto CleanUp;
        }

        // update the WinInfo
        ZeroMemory(&m_WinInfo, sizeof(WININFO));
        EXECUTE_ASSERT(ClientToScreen(hwnd, &(m_WinInfo.TopLeftPoint)));

        m_WinInfo.SrcRect = *pSrcRect;
        m_WinInfo.DestRect = *pDestRect;

        RECT rcClient;
        GetClientRect(hwnd, &rcClient);
        MapWindowRect(hwnd, HWND_DESKTOP, &rcClient);
        IntersectRect(&m_WinInfo.DestClipRect, &rcClient, &m_WinInfo.DestRect);
        IntersectRect(&m_WinInfo.DestClipRect, &m_lpCurrentMonitor->rcMonitor,
                      &m_WinInfo.DestClipRect);

        m_WinInfo.hClipRgn = NULL;
        m_bWinInfoStored = TRUE;

        // if the window is not visible, don't bother
        if (!m_pOutput || !(m_pOutput->GetWindow()) || !IsWindowVisible(m_pOutput->GetWindow()))
        {
            DbgLog((LOG_TRACE,5,TEXT("The window is not visible yet or the Priamry Surface is NULL")));
            goto CleanUp;
        }
    }

    InvalidateRect(hwnd, NULL, FALSE);
//    UpdateWindow(hwnd);

CleanUp:
    return hr;
}

STDMETHODIMP COMFilter::OnPaletteChange(DWORD dwColors, const PALETTEENTRY *pPalette)       // Array of palette colours
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT(" Entering COMFilter::OnPaletteChange")));

    CAutoLock l(&m_csFilter);

    ASSERT(dwColors);
    ASSERT(pPalette);

    m_dwNumPaletteEntries = dwColors;
    memcpy(m_pPaletteEntries, pPalette, (dwColors * sizeof(PALETTEENTRY)));

    // set the pointer to the Primary Surface on the input pins
    for (DWORD i = 0; i < m_dwInputPinCount; i++)
    {
        m_apInput[i]->NewPaletteSet();
    }

    DbgLog((LOG_TRACE, 5, TEXT(" Leaving COMFilter::OnPaletteChange")));
    return NOERROR;
}

HRESULT COMFilter::CanExclusiveMode()
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::CanExclusiveMode")));

    if (m_bWindowless)
    {
        ASSERT(m_bUseGDI);
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::CanExclusiveMode")));
    return hr;
}

HRESULT COMFilter::ConfirmPreConnectionState(DWORD dwExcludePinId)
{
    HRESULT hr = NOERROR;
    DWORD i = 0;

    // is the input pin already connected?
    for (i = 0; i < m_dwInputPinCount; i++)
    {
        if ((m_apInput[i]->GetPinId() != dwExcludePinId) && m_apInput[i]->IsConnected())
        {
            hr = VFW_E_ALREADY_CONNECTED;
            DbgLog((LOG_ERROR, 1, TEXT("m_apInput[i]->IsConnected() , i = %d, returning hr = 0x%x"), i, hr));
            goto CleanUp;
        }
    }

    // is the output pin already connected?
    if (m_pOutput && (m_pOutput->GetPinId() != dwExcludePinId) && m_pOutput->IsConnected())
    {
        hr = VFW_E_ALREADY_CONNECTED;
        DbgLog((LOG_ERROR, 1, TEXT("m_pOutput->IsConnected() , returning hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

STDMETHODIMP COMFilter::OnPositionChange(const RECT *pSrcRect, const RECT *pDestRect)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::OnPositionChange")));
    hr = OnClipChange(pSrcRect, pDestRect, NULL);
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::OnPositionChange")));
    return hr;
}

STDMETHODIMP COMFilter::GetNativeVideoProps(LPDWORD pdwVideoWidth, LPDWORD pdwVideoHeight, LPDWORD pdwPictAspectRatioX, LPDWORD pdwPictAspectRatioY)
{
    HRESULT hr = NOERROR;
    CMediaType cMediaType;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetVideoSizeAndAspectRatio")));

    hr = CanExclusiveMode();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CanExclusiveMode failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (!pdwVideoWidth || !pdwVideoHeight || !pdwPictAspectRatioX || !pdwPictAspectRatioY)
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!m_apInput[0]->IsConnected())
    {
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    hr = m_apInput[0]->CurrentAdjustedMediaType(&cMediaType);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_paInput[0]->CurrentAdjustedMediaType failed, hr = 0x%x"), hr));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // get the native width and height from the mediatype
    pHeader = GetbmiHeader(&cMediaType);
    ASSERT(pHeader);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    *pdwVideoWidth = abs(pHeader->biWidth);
    *pdwVideoHeight = abs(pHeader->biHeight);

    // sanity checks
    ASSERT(*pdwVideoWidth > 0);
    ASSERT(*pdwVideoHeight > 0);

    // get the picture aspect ratio from the mediatype
    hr = ::GetPictAspectRatio(&cMediaType, pdwPictAspectRatioX, pdwPictAspectRatioY);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetPictAspectRatio failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }

    // sanity checks
    ASSERT(*pdwPictAspectRatioX > 0);
    ASSERT(*pdwPictAspectRatioY > 0);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetVideoSizeAndAspectRatio")));
    return hr;
}

//
//   Set callback interface for exclusive mode support
//
STDMETHODIMP COMFilter::SetCallbackInterface(IDDrawExclModeVideoCallback *pCallback, DWORD dwFlags)
{
    if (0 != dwFlags) {
        return E_INVALIDARG;
    }

    if (pCallback) {
        pCallback->AddRef();
    }
    if (m_pExclModeCallback) {
        m_pExclModeCallback->Release();
    }
    m_pExclModeCallback = pCallback;
    return S_OK;
}



/*****************************Private*Routine******************************\
* FormatSupported
*
*
*
* History:
* Mon 11/15/1999 - StEstrop - Created
*
\**************************************************************************/
bool
FormatSupported(
    DWORD dwFourCC
    )
{
    return dwFourCC == mmioFOURCC('Y', 'V', '1', '2') ||
           dwFourCC == mmioFOURCC('Y', 'U', 'Y', '2') ||
           dwFourCC == mmioFOURCC('U', 'Y', 'V', 'Y');
}


/******************************Public*Routine******************************\
* COMFilter::IsImageCaptureSupported
*
* Allow an app to determine ahead of time whether frame capture is possible
*
* History:
* Mon 11/15/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::IsImageCaptureSupported()
{
    AMTRACE((TEXT("COMFilter::IsImageCaptureSupported")));
    HRESULT hr = E_NOTIMPL;

    LPDIRECTDRAWSURFACE pOverlaySurface = NULL;
    CAutoLock l(&m_csFilter);

    CMediaType cMediaType;

    hr = m_apInput[0]->CurrentAdjustedMediaType(&cMediaType);
    if (SUCCEEDED(hr))
    {
        hr = m_apInput[0]->GetOverlaySurface(&pOverlaySurface);
        if (SUCCEEDED(hr))
        {
            DDSURFACEDESC ddsd;
            INITDDSTRUCT(ddsd);

            hr = pOverlaySurface->GetSurfaceDesc(&ddsd);
            if (SUCCEEDED(hr))
            {
                if (FormatSupported(ddsd.ddpfPixelFormat.dwFourCC))
                {
                    return S_OK;
                }
            }
        }
    }

    return S_FALSE;
}


/*****************************Private*Routine******************************\
* GetCurrentImage
*
*
*
* History:
* Wed 10/06/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetCurrentImage(
    YUV_IMAGE** lplpImage
    )
{
    AMTRACE((TEXT("COMFilter::GetCurrentImage")));
    HRESULT hr = E_NOTIMPL;

    LPDIRECTDRAWSURFACE pOverlaySurface = NULL;
    CAutoLock l(&m_csFilter);

    CMediaType cMediaType;

    hr = m_apInput[0]->CurrentAdjustedMediaType(&cMediaType);
    if (SUCCEEDED(hr)) {

        hr = m_apInput[0]->GetOverlaySurface(&pOverlaySurface);
        if (SUCCEEDED(hr)) {

            DDSURFACEDESC ddsd;
            INITDDSTRUCT(ddsd);

            hr = pOverlaySurface->GetSurfaceDesc(&ddsd);

            if (FAILED(hr) || !FormatSupported(ddsd.ddpfPixelFormat.dwFourCC))
            {
                return E_NOTIMPL;
            }


            DWORD dwImageSize = ddsd.dwHeight * ddsd.lPitch;

            YUV_IMAGE* lpImage =
                *lplpImage = (YUV_IMAGE*)CoTaskMemAlloc(
                    dwImageSize + sizeof(YUV_IMAGE));

            lpImage->lHeight     = ddsd.dwHeight;
            lpImage->lWidth      = ddsd.dwWidth;
            lpImage->lBitsPerPel = ddsd.ddpfPixelFormat.dwYUVBitCount;
            lpImage->lStride     = ddsd.lPitch;
            lpImage->dwFourCC    = ddsd.ddpfPixelFormat.dwFourCC;
            lpImage->dwImageSize = dwImageSize;

            GetPictAspectRatio(&cMediaType, (LPDWORD)&lpImage->lAspectX,
                               (LPDWORD)&lpImage->lAspectY);

            lpImage->dwFlags = DM_TOPDOWN_IMAGE;

            DWORD dwInterlaceFlags;
            GetInterlaceFlagsFromMediaType(&cMediaType, &dwInterlaceFlags);

            AM_RENDER_TRANSPORT amRT;
            m_apInput[0]->GetRenderTransport(&amRT);

            if (DisplayingFields(dwInterlaceFlags) || amRT == AM_VIDEOPORT) {
                lpImage->dwFlags |= DM_FIELD_IMAGE;
            }
            else {
                lpImage->dwFlags |= DM_FRAME_IMAGE;
            }

            INITDDSTRUCT(ddsd);
            while ((hr = pOverlaySurface->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
                Sleep(1);

            if (hr == DD_OK)
            {
                LPBYTE lp = ((LPBYTE)lpImage) + sizeof(YUV_IMAGE);
                CopyMemory(lp, ddsd.lpSurface, dwImageSize);
                pOverlaySurface->Unlock(NULL);
            }
        }
    }

    return hr;
}

STDMETHODIMP COMFilter::GetVideoSize(LPDWORD pdwVideoWidth, LPDWORD pdwVideoHeight)
{
    HRESULT hr = NOERROR;
    CMediaType cMediaType;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetVideoSize")));

    if (!pdwVideoWidth || !pdwVideoHeight)
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!m_apInput[0]->IsConnected())
    {
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    hr = m_apInput[0]->CurrentAdjustedMediaType(&cMediaType);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_paInput[0]->CurrentAdjustedMediaType failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }

    // get the native width and height from the mediatype
    pHeader = GetbmiHeader(&cMediaType);
    ASSERT(pHeader);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_FAIL;
        goto CleanUp;
    }

    *pdwVideoWidth = abs(pHeader->biWidth);
    *pdwVideoHeight = abs(pHeader->biHeight);

    // sanity checks
    ASSERT(*pdwVideoWidth > 0);
    ASSERT(*pdwVideoHeight > 0);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetVideoSize")));
    return hr;
}

//  This is called by our container when they want us to draw
//  a frame
STDMETHODIMP COMFilter::OnDraw(HDC hdcDraw, LPCRECT prcDrawRect)
{
    HRESULT hr = NOERROR;

    m_hDC = hdcDraw;
    m_WinInfo.DestRect = *prcDrawRect;
    m_WinInfo.DestClipRect = *prcDrawRect;

    if (m_bWinInfoStored)
        OnDrawAll();
    m_hDC = NULL;

    return hr;
}

STDMETHODIMP COMFilter::SetDrawRegion(LPPOINT lpptTopLeftSC, LPCRECT prcDrawCC, LPCRECT prcClipCC)
{
    HRESULT hr = NOERROR;

    if (!prcDrawCC || !prcClipCC)
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    memset(&m_WinInfo, 0, sizeof(WININFO));

#if 0
    if (lpptTopLeftSC)
    {
        m_WinInfo.TopLeftPoint = *lpptTopLeftSC;
    }
#endif

    SetRect(&m_WinInfo.SrcRect, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
    m_WinInfo.DestRect = *prcDrawCC;
    m_WinInfo.DestClipRect = *prcClipCC;
    m_bWinInfoStored = TRUE;

CleanUp:
    return hr;
}



STDMETHODIMP COMFilter::Advise(IMixerOCXNotify *pmdns)
{
    HRESULT hr = NOERROR;

    if (!pmdns)
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // Is there an advise link already defined
    if (m_pIMixerOCXNotify)
    {
        hr = VFW_E_ADVISE_ALREADY_SET;
        DbgLog((LOG_ERROR, 1, TEXT("m_pIMixerOCXNotify = 0x%x, returning hr = 0x%x"), m_pIMixerOCXNotify, hr));
        goto CleanUp;
    }

    hr = ConfirmPreConnectionState();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("filter not in preconnection state, hr = 0x%x"), hr));
        goto CleanUp;
    }

    m_pIMixerOCXNotify = pmdns;
    m_pIMixerOCXNotify->AddRef();

    // we know that we have only input pin. Ask it to use GDI and not to support
    // videoport or overlay connected. Also no aspect-ratio-correction needed
    ASSERT(m_apInput[0]);
    m_apInput[0]->SetRenderTransport(AM_GDI);
    m_apInput[m_dwInputPinCount-1]->SetIOverlaySupported(FALSE);
    m_apInput[m_dwInputPinCount-1]->SetVPSupported(FALSE);
    m_apInput[m_dwInputPinCount-1]->SetVideoAcceleratorSupported(FALSE);
    m_apInput[m_dwInputPinCount-1]->SetAspectRatioMode(AM_ARMODE_STRETCHED);

    // get rid of the output pin
    delete m_pOutput;
    m_pOutput = NULL;
    IncrementPinVersion();

    //  Right now windowless is synonymous with use GDI
    m_bWindowless = TRUE;
    m_bUseGDI = TRUE;

CleanUp:
    return hr;
}

STDMETHODIMP COMFilter::UnAdvise()
{
    HRESULT hr = NOERROR;

    if (m_pIMixerOCXNotify)
    {
        m_pIMixerOCXNotify->Release();
        m_pIMixerOCXNotify = NULL;
    }

    return hr;
}


// this is a function implemented solely to handle floating point rounding errors.
// dEpsilon defines the error margin. So if a floating point number is within I-e, I+e (inclusive)
// (I is an integer, e is dEpsilon), we return its floor as I itself, otherwise we go to the
// base defintion of myfloor
double myfloor(double dNumber, double dEpsilon)
{
    if (dNumber > dEpsilon)
        return myfloor(dNumber + dEpsilon);
    else if (dNumber < -dEpsilon)
        return myfloor(dNumber - dEpsilon);
    else
        return 0;
}

// have to define my own floor inorder to avoid pulling in the C runtime
double myfloor(double dNumber)
{
    // cast it to LONGLONG to get rid of the fraction
    LONGLONG llNumber = (LONGLONG)dNumber;

    if ((dNumber > 0) && ((double)llNumber > dNumber))
    {
        // need to push ccNumber towards zero (eg 5.7)
        return (double)(llNumber-1);
    }
    else if ((dNumber < 0) && ((double)llNumber < dNumber))
    {
        // need to push ccNumber towards zero (eg -5.7)
        return (double)(llNumber+1);
    }
    else
    {
        // numbers like 5.3 or -5.3
        return (double)(llNumber);
    }
}

// this is a function implemented solely to handle floating point rounding errors.
// dEpsilon defines the error margin. So if a floating point number is within I-e, I+e (inclusive)
// (I is an integer, e is dEpsilon), we return its ceil as I itself, otherwise we go to the
// base defintion of myceil
double myceil(double dNumber, double dEpsilon)
{
    if (dNumber > dEpsilon)
        return myceil(dNumber - dEpsilon);
    else if (dNumber < -dEpsilon)
        return myceil(dNumber + dEpsilon);
    else
        return 0;
}

// have to define my own ceil inorder to avoid pulling in the C runtime
double myceil(double dNumber)
{
    // cast it to LONGLONG to get rid of the fraction
    LONGLONG llNumber = (LONGLONG)dNumber;

    if ((dNumber > 0) && ((double)llNumber < dNumber))
    {
        // need to push ccNumber away from zero (eg 5.3)
        return (double)(llNumber+1);
    }
    else if ((dNumber < 0) && ((double)llNumber > dNumber))
    {
        // need to push ccNumber away from zero (eg -5.3)
        return (double)(llNumber-1);
    }
    else
    {
        // numbers like 5.7 or -5.7
        return (double)(llNumber);
    }
}

RECT CalcSubRect(const RECT *pRect, const RECT *pRelativeRect)
{
    long lDestWidth, lDestHeight;
    double dLeftFrac = 0.0, dRightFrac = 0.0, dTopFrac = 0.0, dBottomFrac = 0.0;
    RECT rSubRect;

    ASSERT(pRect);
    ASSERT(pRelativeRect);

    dLeftFrac = ((double)pRelativeRect->left) / ((double) MAX_REL_NUM);
    dTopFrac = ((double)pRelativeRect->top) / ((double) MAX_REL_NUM);
    dRightFrac = ((double)pRelativeRect->right) / ((double) MAX_REL_NUM);
    dBottomFrac = ((double)pRelativeRect->bottom) / ((double) MAX_REL_NUM);

    lDestWidth = pRect->right - pRect->left;
    lDestHeight = pRect->bottom - pRect->top;

    rSubRect.left = pRect->left + (long)(lDestWidth*dLeftFrac);
    rSubRect.right = pRect->left + (long)(lDestWidth*dRightFrac);
    rSubRect.top = pRect->top + (long)(lDestHeight*dTopFrac);
    rSubRect.bottom = pRect->top + (long)(lDestHeight*dBottomFrac);

    DbgLog((LOG_TRACE,2,TEXT("rSubRect = {%d, %d, %d, %d}"), rSubRect.left,
        rSubRect.top, rSubRect.right, rSubRect.bottom));

    return rSubRect;
}

void SetRect(DRECT *prdRect, LONG lLeft, LONG lTop, LONG lRight, LONG lBottom)
{
    ASSERT(prdRect);
    prdRect->left = (double)lLeft;
    prdRect->top = (double)lTop;
    prdRect->right = (double)lRight;
    prdRect->bottom = (double)lBottom;
}

// this function is only suitable for DRECTS whose coordinates are non-negative
RECT MakeRect(DRECT rdRect)
{
    RECT rRect;

    if (rdRect.left >= 0)
        rRect.left = (LONG)myceil(rdRect.left, EPSILON);
    else
        rRect.left = (LONG)myfloor(rdRect.left, EPSILON);

    if (rdRect.top >= 0)
        rRect.top = (LONG)myceil(rdRect.top, EPSILON);
    else
        rRect.top = (LONG)myfloor(rdRect.top, EPSILON);


    if (rdRect.right >= 0)
        rRect.right = (LONG)myfloor(rdRect.right, EPSILON);
    else
        rRect.right = (LONG)myceil(rdRect.right, EPSILON);


    if (rdRect.bottom >= 0)
        rRect.bottom = (LONG)myfloor(rdRect.bottom, EPSILON);
    else
        rRect.bottom = (LONG)myceil(rdRect.bottom, EPSILON);

    return rRect;
}

void DbgLogRect(DWORD dwLevel, LPCTSTR pszDebugString, const DRECT *prdRect)
{
    RECT rRect;
    rRect = MakeRect(*prdRect);
    DbgLogRect(dwLevel, pszDebugString, &rRect);
    return;
}

void DbgLogRect(DWORD dwLevel, LPCTSTR pszDebugString, const RECT *prRect)
{
    DbgLog((LOG_TRACE, dwLevel, TEXT("%s %d, %d, %d, %d"), pszDebugString, prRect->left, prRect->top, prRect->right, prRect->bottom));
    return;
}


double GetWidth(const DRECT *prdRect)
{
    ASSERT(prdRect);
    return (prdRect->right - prdRect->left);
}

double GetHeight(const DRECT *prdRect)
{
    ASSERT(prdRect);
    return (prdRect->bottom - prdRect->top);
}

BOOL IsRectEmpty(const DRECT *prdRect)
{
    BOOL bRetVal = FALSE;
    RECT rRect;

    ASSERT(prdRect);
    rRect = MakeRect(*prdRect);
    bRetVal = IsRectEmpty(&rRect);
    return bRetVal;
}

BOOL IntersectRect(DRECT *prdIRect, const DRECT *prdRect1, const DRECT *prdRect2)
{
    ASSERT(prdIRect);
    ASSERT(prdRect1);
    ASSERT(prdRect2);

    prdIRect->left = (prdRect1->left >= prdRect2->left) ? prdRect1->left : prdRect2->left;
    prdIRect->top = (prdRect1->top >= prdRect2->top) ? prdRect1->top : prdRect2->top;
    prdIRect->right = (prdRect1->right <= prdRect2->right) ? prdRect1->right : prdRect2->right;
    prdIRect->bottom = (prdRect1->bottom <= prdRect2->bottom) ? prdRect1->bottom : prdRect2->bottom;

    // if the two rects do not intersect, the above computations will result in a invalid rect
    if (prdIRect->right < prdIRect->left ||
        prdIRect->bottom < prdIRect->top)
    {
        SetRect(prdIRect, 0, 0, 0, 0);
        return FALSE;
    }
    return TRUE;
}

// just a helper function to scale a DRECT
void ScaleRect(DRECT *prdRect, double dOrigX, double dOrigY, double dNewX, double dNewY)
{
    ASSERT(prdRect);
    ASSERT(dOrigX > 0);
    ASSERT(dOrigY > 0);
    //ASSERT(dNewX > 0);
    //ASSERT(dNewY > 0);

    prdRect->left = prdRect->left * dNewX / dOrigX;
    prdRect->top = prdRect->top * dNewY / dOrigY;
    prdRect->right = prdRect->right * dNewX / dOrigX;
    prdRect->bottom = prdRect->bottom * dNewY / dOrigY;
}

// just a helper function to scale a RECT.
void ScaleRect(RECT *prRect, double dOrigX, double dOrigY, double dNewX, double dNewY)
{
    DRECT rdRect;

    ASSERT(prRect);
    ASSERT(dOrigX > 0);
    ASSERT(dOrigY > 0);
    //ASSERT(dNewX > 0);
    //ASSERT(dNewY > 0);

    SetRect(&rdRect, prRect->left, prRect->top, prRect->right, prRect->bottom);
    ScaleRect(&rdRect, dOrigX, dOrigY, dNewX, dNewY);
    *prRect = MakeRect(rdRect);
}

// just a helper function, to get the letterboxed or cropped rect
// Puts the transformed rectangle into pRect.
double TransformRect(DRECT *prdRect, double dPictAspectRatio, AM_TRANSFORM transform)
{
    double dWidth, dHeight, dNewWidth, dNewHeight;

    double dResolutionRatio = 0.0, dTransformRatio = 0.0;

    ASSERT(transform == AM_SHRINK || transform == AM_STRETCH);

    dNewWidth = dWidth = prdRect->right - prdRect->left;
    dNewHeight = dHeight = prdRect->bottom - prdRect->top;

    dResolutionRatio = dWidth / dHeight;
    dTransformRatio = dPictAspectRatio / dResolutionRatio;

    // shrinks one dimension to maintain the coorect aspect ratio
    if (transform == AM_SHRINK)
    {
        if (dTransformRatio > 1.0)
        {
            dNewHeight = dNewHeight / dTransformRatio;
        }
        else if (dTransformRatio < 1.0)
        {
            dNewWidth = dNewWidth * dTransformRatio;
        }
    }
    // stretches one dimension to maintain the coorect aspect ratio
    else if (transform == AM_STRETCH)
    {
        if (dTransformRatio > 1.0)
        {
            dNewWidth = dNewWidth * dTransformRatio;
        }
        else if (dTransformRatio < 1.0)
        {
            dNewHeight = dNewHeight / dTransformRatio;
        }
    }

    if (transform == AM_SHRINK)
    {
        ASSERT(dNewHeight <= dHeight);
        ASSERT(dNewWidth <= dWidth);
    }
    else
    {
        ASSERT(dNewHeight >= dHeight);
        ASSERT(dNewWidth >= dWidth);
    }

    // cut or add equal portions to the changed dimension

    prdRect->left += (dWidth - dNewWidth)/2.0;
    prdRect->right = prdRect->left + dNewWidth;

    prdRect->top += (dHeight - dNewHeight)/2.0;
    prdRect->bottom = prdRect->top + dNewHeight;

    return dTransformRatio;
}



// Just a helper function to calculate the part of the source rectangle
// that corresponds to the Clipped area of the destination rectangle
// Very useful for UpdateOverlay or blting functions.
HRESULT CalcSrcClipRect(const DRECT *prdSrcRect, DRECT *prdSrcClipRect,
                        const DRECT *prdDestRect, DRECT *prdDestClipRect)
{
    HRESULT hr = NOERROR;
    double dSrcToDestWidthRatio = 0.0, dSrcToDestHeightRatio = 0.0;
    DRECT rdSrcRect;

    DbgLog((LOG_TRACE,5,TEXT("Entering CalcSrcClipRect")));

    CheckPointer(prdDestRect, E_INVALIDARG);
    CheckPointer(prdDestClipRect, E_INVALIDARG);
    CheckPointer(prdSrcRect, E_INVALIDARG);
    CheckPointer(prdSrcClipRect, E_INVALIDARG);

    SetRect(&rdSrcRect, 0, 0, 0, 0);

    // initialize the prdSrcClipRect only if it is not the same as prdSrcRect
    if (prdSrcRect != prdSrcClipRect)
    {
        SetRect(prdSrcClipRect, 0, 0, 0, 0);
    }

    // Assert that none of the given rects are empty
    if (GetWidth(prdSrcRect) < 1 || GetHeight(prdSrcRect) < 1)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR,2,TEXT("prdSrcRect is invalid")));
        DbgLog((LOG_ERROR,2,TEXT("SrcRect = {%d, %d, %d, %d}"),
            prdSrcRect->left, prdSrcRect->top, prdSrcRect->right, prdSrcRect->bottom));
        goto CleanUp;
    }
    if (GetWidth(prdDestRect) < 1 || GetHeight(prdDestRect) < 1)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_TRACE,2,TEXT("pRect is NULL")));
        DbgLog((LOG_ERROR,2,TEXT("DestRect = {%d, %d, %d, %d}"),
            prdDestRect->left, prdDestRect->top, prdDestRect->right, prdDestRect->bottom));
        goto CleanUp;
    }

    // make a copy of the prdSrcRect incase prdSrcRect and prdSrcClipRect are the same pointers
    rdSrcRect = *prdSrcRect;

    // Assert that the dest clipping rect is not completely outside the dest rect
    if (IntersectRect(prdDestClipRect, prdDestRect, prdDestClipRect) == FALSE)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_TRACE,2,TEXT("IntersectRect of DestRect and DestClipRect returned FALSE")));
        goto CleanUp;
    }

    // Calculate the source to destination width and height ratios
    dSrcToDestWidthRatio = GetWidth(&rdSrcRect) / GetWidth(prdDestRect);
    dSrcToDestHeightRatio = GetHeight(&rdSrcRect) / GetHeight(prdDestRect);

    // From the dest section visible calculate the source required
    prdSrcClipRect->left = rdSrcRect.left + ((prdDestClipRect->left - prdDestRect->left) * dSrcToDestWidthRatio);
    prdSrcClipRect->right = rdSrcRect.left + ((prdDestClipRect->right - prdDestRect->left) * dSrcToDestWidthRatio);
    prdSrcClipRect->top = rdSrcRect.top + ((prdDestClipRect->top - prdDestRect->top) * dSrcToDestHeightRatio);
    prdSrcClipRect->bottom = rdSrcRect.top + ((prdDestClipRect->bottom - prdDestRect->top) * dSrcToDestHeightRatio);

    // Check we have a valid source rectangle
    if (IsRectEmpty(prdSrcClipRect))
    {
        DbgLog((LOG_TRACE,1,TEXT("SrcClipRect is empty, UNEXPECTED!!")));
    }

    DbgLog((LOG_TRACE,5,TEXT("DestRect = {%d, %d, %d, %d}"),
        prdDestRect->left, prdDestRect->top, prdDestRect->right, prdDestRect->bottom));
    DbgLog((LOG_TRACE,5,TEXT("DestClipRect = {%d, %d, %d, %d}"),
        prdDestClipRect->left, prdDestClipRect->top, prdDestClipRect->right, prdDestClipRect->bottom));
    DbgLog((LOG_TRACE,5,TEXT("SrcRect = {%d, %d, %d, %d}"),
        rdSrcRect.left, rdSrcRect.top, rdSrcRect.right, rdSrcRect.bottom));
    DbgLog((LOG_TRACE,5,TEXT("SrcClipRect = {%d, %d, %d, %d}"),
        prdSrcClipRect->left, prdSrcClipRect->top, prdSrcClipRect->right, prdSrcClipRect->bottom));

CleanUp:
    DbgLog((LOG_TRACE,5,TEXT("Leaving CalcSrcClipRect")));
    return hr;
}

// Just a helper function to calculate the part of the source rectangle
// that corresponds to the Clipped area of the destination rectangle
// Very useful for UpdateOverlay or blting functions.
HRESULT CalcSrcClipRect(const RECT *pSrcRect, RECT *pSrcClipRect,
                        const RECT *pDestRect, RECT *pDestClipRect,
                        BOOL bMaintainRatio)
{
    HRESULT hr = NOERROR;
    double dSrcToDestWidthRatio = 0.0, dSrcToDestHeightRatio = 0.0;
    RECT rSrcRect;

    DbgLog((LOG_TRACE,5,TEXT("Entering CalcSrcClipRect")));

    CheckPointer(pDestRect, E_INVALIDARG);
    CheckPointer(pDestClipRect, E_INVALIDARG);
    CheckPointer(pSrcRect, E_INVALIDARG);
    CheckPointer(pSrcClipRect, E_INVALIDARG);

    SetRect(&rSrcRect, 0, 0, 0, 0);

    // initialize the prdSrcClipRect only if it is not the same as prdSrcRect
    if (pSrcRect != pSrcClipRect)
    {
        SetRect(pSrcClipRect, 0, 0, 0, 0);
    }

    // Assert that none of the given rects are empty
    if (WIDTH(pSrcRect) == 0 || HEIGHT(pSrcRect) == 0)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR,2,TEXT("pSrcRect is invalid")));
        DbgLog((LOG_ERROR,2,TEXT("SrcRect = {%d, %d, %d, %d}"),
            pSrcRect->left, pSrcRect->top, pSrcRect->right, pSrcRect->bottom));
        goto CleanUp;
    }
    if (WIDTH(pDestRect) == 0 || HEIGHT(pDestRect) == 0)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_TRACE,2,TEXT("pRect is NULL")));
        DbgLog((LOG_ERROR,2,TEXT("DestRect = {%d, %d, %d, %d}"),
            pDestRect->left, pDestRect->top, pDestRect->right, pDestRect->bottom));
        goto CleanUp;
    }

    // make a copy of the pSrcRect incase pSrcRect and pSrcClipRect are the same pointers
    rSrcRect = *pSrcRect;
    // Assert that the dest clipping rect is not completely outside the dest rect
    if (IntersectRect(pDestClipRect,pDestRect, pDestClipRect) == FALSE)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_TRACE,2,TEXT("IntersectRect of DestRect and DestClipRect returned FALSE")));
        goto CleanUp;
    }

    // Calculate the source to destination width and height ratios
    dSrcToDestWidthRatio = ((double) (WIDTH(&rSrcRect))) / ((double) (WIDTH(pDestRect)));
    dSrcToDestHeightRatio = ((double) (HEIGHT(&rSrcRect))) / ((double) (HEIGHT(pDestRect)));

    // From the dest section visible calculate the source required
    if (bMaintainRatio)
    {
        DRECT rdSrcClipRect;
        rdSrcClipRect.left = (double)rSrcRect.left +
            ((double)(pDestClipRect->left - pDestRect->left)) * dSrcToDestWidthRatio;
        rdSrcClipRect.right = (double)rSrcRect.left +
            ((double)(pDestClipRect->right - pDestRect->left)) * dSrcToDestWidthRatio;
        rdSrcClipRect.top = (double)rSrcRect.top +
            ((double)(pDestClipRect->top - pDestRect->top)) * dSrcToDestHeightRatio;
        rdSrcClipRect.bottom = (double)rSrcRect.top +
            ((double)(pDestClipRect->bottom - pDestRect->top)) * dSrcToDestHeightRatio;
        *pSrcClipRect = MakeRect(rdSrcClipRect);
    }
    else
    {
        pSrcClipRect->left = rSrcRect.left +
            (LONG)(((double)(pDestClipRect->left - pDestRect->left)) * dSrcToDestWidthRatio);
        pSrcClipRect->right = rSrcRect.left +
            (LONG)(((double)(pDestClipRect->right - pDestRect->left)) * dSrcToDestWidthRatio);
        pSrcClipRect->top = rSrcRect.top +
            (LONG)(((double)(pDestClipRect->top - pDestRect->top)) * dSrcToDestHeightRatio);
        pSrcClipRect->bottom = rSrcRect.top +
            (LONG)(((double)(pDestClipRect->bottom - pDestRect->top)) * dSrcToDestHeightRatio);
    }

    // Check we have a valid source rectangle
    if (IsRectEmpty(pSrcClipRect))
    {
        DbgLog((LOG_TRACE,5,TEXT("SrcClipRect is empty, UNEXPECTED!!")));
    }

    DbgLog((LOG_TRACE,5,TEXT("DestRect = {%d, %d, %d, %d}"),
        pDestRect->left, pDestRect->top, pDestRect->right, pDestRect->bottom));
    DbgLog((LOG_TRACE,5,TEXT("DestClipRect = {%d, %d, %d, %d}"),
        pDestClipRect->left, pDestClipRect->top, pDestClipRect->right, pDestClipRect->bottom));
    DbgLog((LOG_TRACE,5,TEXT("SrcRect = {%d, %d, %d, %d}"),
        rSrcRect.left, rSrcRect.top, rSrcRect.right, rSrcRect.bottom));
    DbgLog((LOG_TRACE,5,TEXT("SrcClipRect = {%d, %d, %d, %d}"),
        pSrcClipRect->left, pSrcClipRect->top, pSrcClipRect->right, pSrcClipRect->bottom));

CleanUp:
    DbgLog((LOG_TRACE,5,TEXT("Leaving CalcSrcClipRect")));
    return hr;
}

HRESULT AlignOverlaySrcDestRects(LPDDCAPS pddDirectCaps, RECT *pSrcRect, RECT *pDestRect)
{
    HRESULT hr = NOERROR;
    DWORD dwNewSrcWidth = 0, dwTemp = 0;
    double dOldZoomFactorX = 0.0, dNewZoomFactorX = 0.0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::AllignOverlaySrcDestRects")));

    if (!pSrcRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pSrcRect = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pDestRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pSrcRect = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // Assert that none of the given rects are empty
    if (WIDTH(pSrcRect) == 0 || WIDTH(pDestRect) == 0)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR,2,TEXT("one of the rects is empty")));
        DbgLog((LOG_ERROR,2,TEXT("SrcRect = {%d, %d, %d, %d}"),
            pSrcRect->left, pSrcRect->top, pSrcRect->right, pSrcRect->bottom));
        DbgLog((LOG_ERROR,2,TEXT("DestRect = {%d, %d, %d, %d}"),
            pDestRect->left, pDestRect->top, pDestRect->right, pDestRect->bottom));
        goto CleanUp;
    }

    dOldZoomFactorX = ((double) WIDTH(pDestRect)) / ((double) WIDTH(pSrcRect));

    // align the dest boundary (remember we can only decrease the DestRect.left). Use of colorkey will make sure that
    // that we are clipped properly.
    if ((pddDirectCaps->dwCaps) & DDCAPS_ALIGNBOUNDARYDEST)
    {
        dwTemp = pDestRect->left & (pddDirectCaps->dwAlignBoundaryDest-1);
        pDestRect->left -= dwTemp;
        ASSERT(pDestRect->left >= 0);
    }

    // align the dest width (remember we can only increase the DestRect.right). Use of colorkey will make sure that
    // that we are clipped properly.
    if ((pddDirectCaps->dwCaps) & DDCAPS_ALIGNSIZEDEST)
    {
        dwTemp = (pDestRect->right - pDestRect->left) & (pddDirectCaps->dwAlignSizeDest-1);
        if (dwTemp != 0)
        {
            pDestRect->right += pddDirectCaps->dwAlignBoundaryDest - dwTemp;
        }
    }

    // align the src boundary (remember we can only increase the SrcRect.left)
    if ((pddDirectCaps->dwCaps) & DDCAPS_ALIGNBOUNDARYSRC)
    {
        dwTemp = pSrcRect->left & (pddDirectCaps->dwAlignBoundarySrc-1);
        if (dwTemp != 0)
        {
            pSrcRect->left += pddDirectCaps->dwAlignBoundarySrc - dwTemp;
        }
    }

    // align the src width (remember we can only decrease the SrcRect.right)
    if ((pddDirectCaps->dwCaps) & DDCAPS_ALIGNSIZESRC)
    {
        dwTemp = (pSrcRect->right - pSrcRect->left) & (pddDirectCaps->dwAlignSizeSrc-1);
        pSrcRect->right -= dwTemp;
    }

    // It is possible that one of the rects became empty at this point
    if (WIDTH(pSrcRect) == 0 || WIDTH(pDestRect) == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("one of the rects is empty")));
        DbgLog((LOG_ERROR,2,TEXT("SrcRect = {%d, %d, %d, %d}"),
            pSrcRect->left, pSrcRect->top, pSrcRect->right, pSrcRect->bottom));
        DbgLog((LOG_ERROR,2,TEXT("DestRect = {%d, %d, %d, %d}"),
            pDestRect->left, pDestRect->top, pDestRect->right, pDestRect->bottom));
        goto CleanUp;
    }

    dNewZoomFactorX = ((double) WIDTH(pDestRect)) / ((double) WIDTH(pSrcRect));

//    ASSERT(dNewZoomFactorX >= dOldZoomFactorX);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::AllignOverlaySrcDestRects")));
    return hr;
}


// convert a RGB color to a pysical color.
// we do this by leting GDI SetPixel() do the color matching
// then we lock the memory and see what it got mapped to.
DWORD DDColorMatch(IDirectDrawSurface *pdds, COLORREF rgb, HRESULT& hr)
{
    COLORREF rgbT;
    HDC hdc;
    DWORD dw = CLR_INVALID;
    DDSURFACEDESC ddsd;

    hr = NOERROR;
    //  use GDI SetPixel to color match for us
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        rgbT = GetPixel(hdc, 0, 0);             // save current pixel value
        SetPixel(hdc, 0, 0, rgb);               // set our value
        pdds->ReleaseDC(hdc);
    }

    // now lock the surface so we can read back the converted color
    ddsd.dwSize = sizeof(ddsd);
    while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;

    if (hr == DD_OK)
    {
        // get DWORD
        dw  = *(DWORD *)ddsd.lpSurface;

        // mask it to bpp
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 32)
            dw &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount)-1;
        pdds->Unlock(NULL);
    }

    //  now put the color that was there back.
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        SetPixel(hdc, 0, 0, rgbT);
        pdds->ReleaseDC(hdc);
    }

    return dw;
}

// convert a RGB color to a pysical color.
// we do this by leting GDI SetPixel() do the color matching
// then we lock the memory and see what it got mapped to.
DWORD DDColorMatchOffscreen(
    IDirectDraw *pdd,
    COLORREF rgb,
    HRESULT& hr
    )
{
    COLORREF rgbT;
    HDC hdc;
    DWORD dw = CLR_INVALID;
    DDSURFACEDESC ddsd;
    IDirectDrawSurface* pdds;

    hr = NOERROR;
    INITDDSTRUCT(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth = 16;
    ddsd.dwHeight = 16;
    hr = pdd->CreateSurface(&ddsd, &pdds, NULL);
    if (hr != DD_OK) {
        return 0;
    }

    //  use GDI SetPixel to color match for us
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        rgbT = GetPixel(hdc, 0, 0);             // save current pixel value
        SetPixel(hdc, 0, 0, rgb);               // set our value
        pdds->ReleaseDC(hdc);
    }

    // now lock the surface so we can read back the converted color
    INITDDSTRUCT(ddsd);
    while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;

    if (hr == DD_OK)
    {
        // get DWORD
        dw  = *(DWORD *)ddsd.lpSurface;

        // mask it to bpp
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 32)
            dw &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount)-1;
        pdds->Unlock(NULL);
    }

    //  now put the color that was there back.
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        SetPixel(hdc, 0, 0, rgbT);
        pdds->ReleaseDC(hdc);
    }

    pdds->Release();

    hr = NOERROR;
    return dw;
}

BITMAPINFOHEADER *GetbmiHeader(const CMediaType *pMediaType)
{
    BITMAPINFOHEADER *pHeader = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    if (!(pMediaType->pbFormat))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType->pbFormat is NULL")));
        goto CleanUp;
    }

    if ((pMediaType->formattype == FORMAT_VideoInfo) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER)))
    {
        pHeader = &(((VIDEOINFOHEADER*)(pMediaType->pbFormat))->bmiHeader);
        goto CleanUp;
    }


    if ((pMediaType->formattype == FORMAT_VideoInfo2) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER2)))

    {
        pHeader = &(((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->bmiHeader);
        goto CleanUp;
    }
CleanUp:
    return pHeader;
}

// Return the bit masks for the true colour VIDEOINFO or VIDEOINFO2 provided
const DWORD *GetBitMasks(const CMediaType *pMediaType)
{
    BITMAPINFOHEADER *pHeader = NULL;
    static DWORD FailMasks[] = {0,0,0};
    const DWORD *pdwBitMasks = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        goto CleanUp;
    }

    if (pHeader->biCompression != BI_RGB)
    {
        pdwBitMasks = (const DWORD *)((LPBYTE)pHeader + pHeader->biSize);
        goto CleanUp;

    }

    ASSERT(pHeader->biCompression == BI_RGB);
    switch (pHeader->biBitCount)
    {
    case 16:
        {
            pdwBitMasks = bits555;
            break;
        }
    case 24:
        {
            pdwBitMasks = bits888;
            break;
        }

    case 32:
        {
            pdwBitMasks = bits888;
            break;
        }
    default:
        {
            pdwBitMasks = FailMasks;
            break;
        }
    }

CleanUp:
    return pdwBitMasks;
}

// Return the pointer to the byte after the header
BYTE* GetColorInfo(const CMediaType *pMediaType)
{
    BITMAPINFOHEADER *pHeader = NULL;
    BYTE *pColorInfo = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        goto CleanUp;
    }

    pColorInfo = ((LPBYTE)pHeader + pHeader->biSize);

CleanUp:
    return pColorInfo;
}

// checks whether the mediatype is palettised or not
HRESULT IsPalettised(const CMediaType *pMediaType, BOOL *pPalettised)
{
    HRESULT hr = NOERROR;
    BITMAPINFOHEADER *pHeader = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pPalettised)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pPalettised is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_FAIL;
        goto CleanUp;
    }

    if (pHeader->biBitCount <= iPALETTE)
        *pPalettised = TRUE;
    else
        *pPalettised = FALSE;

CleanUp:
    return hr;
}

HRESULT GetPictAspectRatio(const CMediaType *pMediaType, DWORD *pdwPictAspectRatioX, DWORD *pdwPictAspectRatioY)
{
    HRESULT hr = NOERROR;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!(pMediaType->pbFormat))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType->pbFormat is NULL")));
        goto CleanUp;
    }

    if (!pdwPictAspectRatioX)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwPictAspectRatioX is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pdwPictAspectRatioY)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwPictAspectRatioY is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }


    if ((pMediaType->formattype == FORMAT_VideoInfo) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER)))
    {
        *pdwPictAspectRatioX = abs(((VIDEOINFOHEADER*)(pMediaType->pbFormat))->bmiHeader.biWidth);
        *pdwPictAspectRatioY = abs(((VIDEOINFOHEADER*)(pMediaType->pbFormat))->bmiHeader.biHeight);
        goto CleanUp;
    }

    if ((pMediaType->formattype == FORMAT_VideoInfo2) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER2)))
    {
        *pdwPictAspectRatioX = ((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->dwPictAspectRatioX;
        *pdwPictAspectRatioY = ((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->dwPictAspectRatioY;
        goto CleanUp;
    }

CleanUp:
    return hr;
}



// get the InterlaceFlags from the mediatype. If the format is VideoInfo, it returns
// the flags as zero.
HRESULT GetInterlaceFlagsFromMediaType(const CMediaType *pMediaType, DWORD *pdwInterlaceFlags)
{
    HRESULT hr = NOERROR;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering GetInterlaceFlagsFromMediaType")));

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pdwInterlaceFlags)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // get the header just to make sure the mediatype is ok
    pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (pMediaType->formattype == FORMAT_VideoInfo)
    {
        *pdwInterlaceFlags = 0;
    }
    else if (pMediaType->formattype == FORMAT_VideoInfo2)
    {
        *pdwInterlaceFlags = ((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->dwInterlaceFlags;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving GetInterlaceFlagsFromMediaType")));
    return hr;
}


// get the rcSource from the mediatype
// if rcSource is empty, it means take the whole image
HRESULT GetSrcRectFromMediaType(const CMediaType *pMediaType, RECT *pRect)
{
    HRESULT hr = NOERROR;
    BITMAPINFOHEADER *pHeader = NULL;
    LONG dwWidth = 0, dwHeight = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering GetSrcRectFromMediaType")));

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    dwWidth = abs(pHeader->biWidth);
    dwHeight = abs(pHeader->biHeight);

    ASSERT((pMediaType->formattype == FORMAT_VideoInfo) || (pMediaType->formattype == FORMAT_VideoInfo2));

    if (pMediaType->formattype == FORMAT_VideoInfo)
    {
        *pRect = ((VIDEOINFOHEADER*)(pMediaType->pbFormat))->rcSource;
    }
    else if (pMediaType->formattype == FORMAT_VideoInfo2)
    {
        *pRect = ((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->rcSource;
    }

    DWORD dwInterlaceFlags;
    if (SUCCEEDED(GetInterlaceFlagsFromMediaType(pMediaType, &dwInterlaceFlags)) &&
       DisplayingFields(dwInterlaceFlags)) {

        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            (pRect->bottom / 2) > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcSource of mediatype is invalid")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }
    else {
        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            pRect->bottom > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcSource of mediatype is invalid")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }

    // An empty rect means the whole image, Yuck!
    if (IsRectEmpty(pRect))
        SetRect(pRect, 0, 0, dwWidth, dwHeight);

    // if either the width or height is zero then better set the whole
    // rect to be empty so that the callee can catch it that way
    if (WIDTH(pRect) == 0 || HEIGHT(pRect) == 0)
        SetRect(pRect, 0, 0, 0, 0);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving GetSrcRectFromMediaType")));
    return hr;
}

// get the rcTarget from the mediatype, after converting it to base MAX_REL_NUM
// if rcTarget is empty, it means take the whole image
HRESULT GetDestRectFromMediaType(const CMediaType *pMediaType, RECT *pRect)
{
    HRESULT hr = NOERROR;
    BITMAPINFOHEADER *pHeader = NULL;
    LONG dwWidth = 0, dwHeight = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering GetDestRectFromMediaType")));

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    dwWidth = abs(pHeader->biWidth);
    dwHeight = abs(pHeader->biHeight);

    ASSERT((pMediaType->formattype == FORMAT_VideoInfo) || (pMediaType->formattype == FORMAT_VideoInfo2));

    if (pMediaType->formattype == FORMAT_VideoInfo)
    {
        *pRect = ((VIDEOINFOHEADER*)(pMediaType->pbFormat))->rcTarget;
    }
    else if (pMediaType->formattype == FORMAT_VideoInfo2)
    {
        *pRect = ((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->rcTarget;
    }

    DWORD dwInterlaceFlags;
    if (SUCCEEDED(GetInterlaceFlagsFromMediaType(pMediaType, &dwInterlaceFlags)) &&
       DisplayingFields(dwInterlaceFlags)) {

        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            (pRect->bottom / 2) > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcTarget of mediatype is invalid")));
            SetRect(pRect, 0, 0, dwWidth, dwHeight);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }
    else {
        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            pRect->bottom > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcTarget of mediatype is invalid")));
            SetRect(pRect, 0, 0, dwWidth, dwHeight);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }

    // An empty rect means the whole image, Yuck!
    if (IsRectEmpty(pRect))
        SetRect(pRect, 0, 0, dwWidth, dwHeight);

    // if either the width or height is zero then better set the whole
    // rect to be empty so that the callee can catch it that way
    if (WIDTH(pRect) == 0 || HEIGHT(pRect) == 0)
        SetRect(pRect, 0, 0, 0, 0);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving GetDestRectFromMediaType")));
    return hr;
}

// this function computes scaling and cropping rects from the src/dest rects in the mediatype
//
// RobinSp:
//     The scaling rectangle is just the image of the full source
//     rectangle when transformed by the affine transform that takes
//     the actual media type's source rectangle into the
//     media type's destination rectangle:
//
//     This should be rewritten:
//     *prdScaledRect = XForm(rcSource, rcTarget)(0, 0, bmHeader.dwWidth, bmiHeader.dwHeight)
//
//     The cropping rectangle is exactly the destination rectangle so
//     I'm not sure what the code below is doing.
//
HRESULT GetScaleCropRectsFromMediaType(const CMediaType *pMediaType, DRECT *prdScaledRect, DRECT *prdCroppedRect)
{
    HRESULT hr = NOERROR;
    RECT rSrc, rTarget;
    DRECT rdScaled, rdCropped;
    DWORD dwImageWidth = 0, dwImageHeight = 0;
    double Sx = 0.0, Sy = 0.0;
    BITMAPINFOHEADER *pHeader = NULL;
    double dLeftFrac = 0.0, dRightFrac = 0.0, dTopFrac = 0.0, dBottomFrac = 0.0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering GetScaleCropRectsFromMediaType")));

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    SetRect(&rSrc, 0, 0, 0, 0);
    SetRect(&rTarget, 0, 0, 0, 0);
    SetRect(&rdScaled, 0, 0, 0, 0);
    SetRect(&rdCropped, 0, 0, 0, 0);

    // get the source rect from the current mediatype
    hr = GetSrcRectFromMediaType(pMediaType, &rSrc);
    ASSERT(SUCCEEDED(hr));

    DbgLogRectMacro((2, TEXT("rSrc = "), &rSrc));


    // get the dest specified by the mediatype
    hr = GetDestRectFromMediaType(pMediaType, &rTarget);
    if ( FAILED(hr) )
        goto CleanUp;

    DbgLogRectMacro((2, TEXT("rTarget = "), &rTarget));

    pHeader = GetbmiHeader(pMediaType);
    if ( NULL == pHeader )
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    dwImageWidth = abs(pHeader->biWidth);
    dwImageHeight = abs(pHeader->biHeight);

    Sx = ((double)(rTarget.right - rTarget.left)) / ((double)(rSrc.right - rSrc.left));
    Sy = ((double)(rTarget.bottom - rTarget.top)) / ((double)(rSrc.bottom - rSrc.top));

    DbgLog((LOG_ERROR, 2, TEXT("Sx * 1000 = %d"), (DWORD)(Sx*1000.0)));
    DbgLog((LOG_ERROR, 2, TEXT("Sy * 1000 = %d"), (DWORD)(Sy*1000.0)));

    rdScaled.left = rTarget.left - (double)rSrc.left * Sx;
    rdScaled.top = rTarget.top - (double)rSrc.top * Sy;
    rdScaled.right = rdScaled.left + (double)dwImageWidth * Sx;
    rdScaled.bottom = rdScaled.top  + (double)dwImageHeight * Sy;

    DbgLogRectMacro((2, TEXT("rdScaled = "), &rdScaled));

    dLeftFrac = ((double)rSrc.left) / ((double) dwImageWidth);
    dTopFrac = ((double)rSrc.top) / ((double) dwImageHeight);
    dRightFrac = ((double)rSrc.right) / ((double) dwImageWidth);
    dBottomFrac = ((double)rSrc.bottom) / ((double) dwImageHeight);

    rdCropped.left = rdScaled.left + GetWidth(&rdScaled)*dLeftFrac;
    rdCropped.right = rdScaled.left + GetWidth(&rdScaled)*dRightFrac;
    rdCropped.top = rdScaled.top + GetHeight(&rdScaled)*dTopFrac;
    rdCropped.bottom = rdScaled.top + GetHeight(&rdScaled)*dBottomFrac;

    DbgLogRectMacro((2, TEXT("rdCropped = "), &rdCropped));

    if (prdScaledRect)
    {
        *prdScaledRect = rdScaled;
    }

    if (prdCroppedRect)
    {
        *prdCroppedRect = rdCropped;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving GetScaleCropRectsFromMediaType")));
    return hr;
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE * WINAPI AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource, GUID formattype)
{
    DWORD dwFormatSize = 0;
    BYTE *pFormatPtr = NULL;
    AM_MEDIA_TYPE *pMediaType = NULL;
    HRESULT hr = NOERROR;

    if (formattype == FORMAT_VideoInfo)
        dwFormatSize = sizeof(VIDEOINFO);
    else if (formattype == FORMAT_VideoInfo2)
        dwFormatSize = sizeof(TRUECOLORINFO) + sizeof(VIDEOINFOHEADER2) + 4;    // actually this should be sizeof sizeof(VIDEOINFO2) once we define that

    // Make sure that dwFormatSize is at least as big as the size of the source format
    if (pmtSource)
    {
        dwFormatSize = max(dwFormatSize, pmtSource->cbFormat);
    }
    
    pMediaType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (!pMediaType)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    pFormatPtr = (BYTE *)CoTaskMemAlloc(dwFormatSize);
    if (!pFormatPtr)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    if (pmtSource)
    {
        *pMediaType = *pmtSource;
        pMediaType->cbFormat = dwFormatSize;
        CopyMemory(pFormatPtr, pmtSource->pbFormat, pmtSource->cbFormat);
    }
    else
    {
        ZeroMemory(pMediaType, sizeof(*pMediaType));
        ZeroMemory(pFormatPtr, dwFormatSize);
        pMediaType->majortype = MEDIATYPE_Video;
        pMediaType->formattype = formattype;
        pMediaType->cbFormat = dwFormatSize;
    }
    pMediaType->pbFormat = pFormatPtr;

CleanUp:
    if (FAILED(hr))
    {
        if (pMediaType)
        {
            CoTaskMemFree((PVOID)pMediaType);
            pMediaType = NULL;
        }
        if (!pFormatPtr)
        {
            CoTaskMemFree((PVOID)pFormatPtr);
            pFormatPtr = NULL;
        }
    }
    return pMediaType;
}

// Helper function converts a DirectDraw surface to a media type.
// The surface description must have:
//  Height
//  Width
//  lPitch
//  PixelFormat

// Initialise our output type based on the DirectDraw surface. As DirectDraw
// only deals with top down display devices so we must convert the height of
// the surface returned in the DDSURFACEDESC into a negative height. This is
// because DIBs use a positive height to indicate a bottom up image. We also
// initialise the other VIDEOINFO fields although they're hardly ever needed

AM_MEDIA_TYPE *ConvertSurfaceDescToMediaType(const LPDDSURFACEDESC pSurfaceDesc, BOOL bInvertSize, CMediaType cMediaType)
{
    HRESULT hr = NOERROR;
    AM_MEDIA_TYPE *pMediaType = NULL;
    BITMAPINFOHEADER *pbmiHeader = NULL;
    int bpp = 0;

    if ((*cMediaType.FormatType() != FORMAT_VideoInfo ||
        cMediaType.FormatLength() < sizeof(VIDEOINFOHEADER)) &&
        (*cMediaType.FormatType() != FORMAT_VideoInfo2 ||
        cMediaType.FormatLength() < sizeof(VIDEOINFOHEADER2)))
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    pMediaType = AllocVideoMediaType(&cMediaType, cMediaType.formattype);
    if (pMediaType == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    pbmiHeader = GetbmiHeader((const CMediaType*)pMediaType);
    if (!pbmiHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pbmiHeader is NULL, UNEXPECTED!!")));
        hr = E_FAIL;
        goto CleanUp;
    }

    // Convert a DDSURFACEDESC into a BITMAPINFOHEADER (see notes later). The
    // bit depth of the surface can be retrieved from the DDPIXELFORMAT field
    // in the DDpSurfaceDesc-> The documentation is a little misleading because
    // it says the field is permutations of DDBD_*'s however in this case the
    // field is initialised by DirectDraw to be the actual surface bit depth

    pbmiHeader->biSize = sizeof(BITMAPINFOHEADER);

    if (pSurfaceDesc->dwFlags & DDSD_PITCH)
    {
        pbmiHeader->biWidth = pSurfaceDesc->lPitch;
        // Convert the pitch from a byte count to a pixel count.
        // For some weird reason if the format is not a standard bit depth the
        // width field in the BITMAPINFOHEADER should be set to the number of
        // bytes instead of the width in pixels. This supports odd YUV formats
        // like IF09 which uses 9bpp.
        int bpp = pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
        if (bpp == 8 || bpp == 16 || bpp == 24 || bpp == 32)
        {
            pbmiHeader->biWidth /= (bpp / 8);   // Divide by number of BYTES per pixel.
        }
    }
    else
    {
        pbmiHeader->biWidth = pSurfaceDesc->dwWidth;
        // BUGUBUG -- Do something odd here with strange YUV pixel formats?  Or does it matter?
    }

    pbmiHeader->biHeight = pSurfaceDesc->dwHeight;
    if (bInvertSize)
    {
        pbmiHeader->biHeight = -pbmiHeader->biHeight;
    }
    pbmiHeader->biPlanes        = 1;
    pbmiHeader->biBitCount      = (USHORT) pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
    pbmiHeader->biCompression   = pSurfaceDesc->ddpfPixelFormat.dwFourCC;
    pbmiHeader->biClrUsed       = 0;
    pbmiHeader->biClrImportant  = 0;


    // For true colour RGB formats tell the source there are bit fields
    if (pbmiHeader->biCompression == BI_RGB)
    {
        if (pbmiHeader->biBitCount == 16 || pbmiHeader->biBitCount == 32)
        {
            pbmiHeader->biCompression = BI_BITFIELDS;
        }
    }

    if (pbmiHeader->biBitCount <= iPALETTE)
    {
        pbmiHeader->biClrUsed = 1 << pbmiHeader->biBitCount;
    }

    pbmiHeader->biSizeImage = DIBSIZE(*pbmiHeader);



    // The RGB bit fields are in the same place as for YUV formats
    if (pbmiHeader->biCompression != BI_RGB)
    {
        DWORD *pdwBitMasks = NULL;
        pdwBitMasks = (DWORD*)(::GetBitMasks((const CMediaType *)pMediaType));
        if ( ! pdwBitMasks )
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }
        // GetBitMasks only returns the pointer to the actual bitmasks
        // in the mediatype if biCompression == BI_BITFIELDS
        pdwBitMasks[0] = pSurfaceDesc->ddpfPixelFormat.dwRBitMask;
        pdwBitMasks[1] = pSurfaceDesc->ddpfPixelFormat.dwGBitMask;
        pdwBitMasks[2] = pSurfaceDesc->ddpfPixelFormat.dwBBitMask;
    }

    // And finish it off with the other media type fields
    pMediaType->subtype = GetBitmapSubtype(pbmiHeader);
    pMediaType->lSampleSize = pbmiHeader->biSizeImage;

    // set the src and dest rects if necessary
    if (pMediaType->formattype == FORMAT_VideoInfo)
    {
        VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *)pMediaType->pbFormat;
        VIDEOINFOHEADER *pSrcVideoInfo = (VIDEOINFOHEADER *)cMediaType.pbFormat;

        // if the surface allocated is different than the size specified by the decoder
        // then use the src and dest to ask the decoder to clip the video
        if ((abs(pVideoInfo->bmiHeader.biHeight) != abs(pSrcVideoInfo->bmiHeader.biHeight)) ||
            (abs(pVideoInfo->bmiHeader.biWidth) != abs(pSrcVideoInfo->bmiHeader.biWidth)))
        {
            if (IsRectEmpty(&(pVideoInfo->rcSource)))
            {
                pVideoInfo->rcSource.left = pVideoInfo->rcSource.top = 0;
                pVideoInfo->rcSource.right = pSurfaceDesc->dwWidth;
                pVideoInfo->rcSource.bottom = pSurfaceDesc->dwHeight;
            }
            if (IsRectEmpty(&(pVideoInfo->rcTarget)))
            {
                pVideoInfo->rcTarget.left = pVideoInfo->rcTarget.top = 0;
                pVideoInfo->rcTarget.right = pSurfaceDesc->dwWidth;
                pVideoInfo->rcTarget.bottom = pSurfaceDesc->dwHeight;
            }
        }
    }
    else if (pMediaType->formattype == FORMAT_VideoInfo2)
    {
        VIDEOINFOHEADER2 *pVideoInfo2 = (VIDEOINFOHEADER2 *)pMediaType->pbFormat;
        VIDEOINFOHEADER2 *pSrcVideoInfo2 = (VIDEOINFOHEADER2 *)cMediaType.pbFormat;

        // if the surface allocated is different than the size specified by the decoder
        // then use the src and dest to ask the decoder to clip the video
        if ((abs(pVideoInfo2->bmiHeader.biHeight) != abs(pSrcVideoInfo2->bmiHeader.biHeight)) ||
            (abs(pVideoInfo2->bmiHeader.biWidth) != abs(pSrcVideoInfo2->bmiHeader.biWidth)))
        {
            if (IsRectEmpty(&(pVideoInfo2->rcSource)))
            {
                pVideoInfo2->rcSource.left = pVideoInfo2->rcSource.top = 0;
                pVideoInfo2->rcSource.right = pSurfaceDesc->dwWidth;
                pVideoInfo2->rcSource.bottom = pSurfaceDesc->dwHeight;
            }
            if (IsRectEmpty(&(pVideoInfo2->rcTarget)))
            {
                pVideoInfo2->rcTarget.left = pVideoInfo2->rcTarget.top = 0;
                pVideoInfo2->rcTarget.right = pSurfaceDesc->dwWidth;
                pVideoInfo2->rcTarget.bottom = pSurfaceDesc->dwHeight;
            }
        }
    }

CleanUp:
    if (FAILED(hr))
    {
        if (pMediaType)
        {
            FreeMediaType(*pMediaType);
            pMediaType = NULL;
        }
    }
    return pMediaType;
}


typedef HRESULT (*LPFNPAINTERPROC)(LPDIRECTDRAWSURFACE pDDrawSurface);

HRESULT YV12PaintSurfaceBlack(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    HRESULT hr = NOERROR;
    DDSURFACEDESC ddsd;

    // now lock the surface so we can start filling the surface with black
    ddsd.dwSize = sizeof(ddsd);
    while ((hr = pDDrawSurface->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        Sleep(1);

    if (hr == DD_OK)
    {
        DWORD y;
        LPBYTE pDst = (LPBYTE)ddsd.lpSurface;
        LONG  OutStride = ddsd.lPitch;
        DWORD VSize = ddsd.dwHeight;
        DWORD HSize = ddsd.dwWidth;

        // Y Component
        for (y = 0; y < VSize; y++) {
            FillMemory(pDst, HSize, (BYTE)0x10);     // 1 line at a time
            pDst += OutStride;
        }

        HSize /= 2;
        VSize /= 2;
        OutStride /= 2;

        // Cb Component
        for (y = 0; y < VSize; y++) {
            FillMemory(pDst, HSize, (BYTE)0x80);     // 1 line at a time
            pDst += OutStride;
        }

        // Cr Component
        for (y = 0; y < VSize; y++) {
            FillMemory(pDst, HSize, (BYTE)0x80);     // 1 line at a time
            pDst += OutStride;
        }

        pDDrawSurface->Unlock(NULL);
    }

    return hr;
}

HRESULT GDIPaintSurfaceBlack(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    HRESULT hr;
    DDSURFACEDESC ddSurfaceDesc;
    RECT rc;
    HDC hdc;

    // get the surface description
    INITDDSTRUCT(ddSurfaceDesc);
    hr = pDDrawSurface->GetSurfaceDesc(&ddSurfaceDesc);
    if (FAILED(hr))
        return hr;

    // get the DC
    hr = pDDrawSurface->GetDC(&hdc);
    if (FAILED(hr)) {
        // Robin says NT 4.0 has a bug which means ReleaseDC must
        // be called even though GetDC failed.
        pDDrawSurface->ReleaseDC(hdc);
        return hr;
    }

    SetRect(&rc, 0, 0, ddSurfaceDesc.dwWidth, ddSurfaceDesc.dwHeight);
    FillRect(hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));

    return pDDrawSurface->ReleaseDC(hdc);
}


HRESULT DX1PaintSurfaceBlack(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    DWORD dwBlackColor;
    DDBLTFX ddFX;
    DDSURFACEDESC ddSurfaceDesc;
    HRESULT hr;

    // get the surface description
    INITDDSTRUCT(ddSurfaceDesc);
    hr = pDDrawSurface->GetSurfaceDesc(&ddSurfaceDesc);
    if (FAILED(hr))
        return hr;

    // compute the black value if the fourCC code is suitable, otherwise can't handle it
    switch (ddSurfaceDesc.ddpfPixelFormat.dwFourCC)
    {
    case mmioFOURCC('Y','V','1','2'):
        return YV12PaintSurfaceBlack(pDDrawSurface);

    case YUY2:
        dwBlackColor = 0x80108010;
        break;

    case UYVY:
        dwBlackColor = 0x10801080;
        break;

    default:
        DbgLog((LOG_ERROR, 1, TEXT("ddSurfaceDesc.ddpfPixelFormat.dwFourCC not one of the values in the table, so exiting function")));
        return E_FAIL;
    }

    INITDDSTRUCT(ddFX);
    ddFX.dwFillColor = dwBlackColor;
    return pDDrawSurface->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &ddFX);
}

#if 0

//JEFFNO: AlphaBlt has been removed from DX7...

HRESULT DX7PaintSurfaceBlack(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    LPDIRECTDRAWSURFACE7 pDDSurf7 = NULL;
    HRESULT hr;

    hr = pDDrawSurface->QueryInterface(IID_IDirectDrawSurface7, (LPVOID *)&pDDSurf7);
    if (SUCCEEDED(hr) && pDDSurf7)
    {
        // AlphaBlend here.
        DDALPHABLTFX ddAlphaBltFX;

        ddAlphaBltFX.ddargbScaleFactors.alpha = 0;
        ddAlphaBltFX.ddargbScaleFactors.red   = 0;
        ddAlphaBltFX.ddargbScaleFactors.green = 0;
        ddAlphaBltFX.ddargbScaleFactors.blue  = 0;

        hr = pDDSurf7->AlphaBlt(NULL, NULL, NULL, DDABLT_NOBLEND, &ddAlphaBltFX);
        pDDSurf7->Release();
    }

    if (FAILED(hr)) {
        return DX1PaintSurfaceBlack(pDDrawSurface);
    }

    return hr;
}
#endif

// function used to fill the ddraw surface with black color.
HRESULT PaintDDrawSurfaceBlack(LPDIRECTDRAWSURFACE pDDrawSurface)
{
    HRESULT hr = NOERROR;
    LPDIRECTDRAWSURFACE *ppDDrawSurface = NULL;
    LPDIRECTDRAWSURFACE7 pDDSurf7 = NULL;
    DDSCAPS ddSurfaceCaps;
    DDSURFACEDESC ddSurfaceDesc;
    DWORD dwAllocSize;
    DWORD i = 0, dwTotalBufferCount = 1;
    LPFNPAINTERPROC lpfnPaintProc = NULL;

    DbgLog((LOG_TRACE, 5,TEXT("Entering CAMVideoPort::PaintDDrawSurfaceBlack")));


    // get the surface description
    INITDDSTRUCT(ddSurfaceDesc);
    hr = pDDrawSurface->GetSurfaceDesc(&ddSurfaceDesc);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pDDrawSurface->GetSurfaceDesc failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (ddSurfaceDesc.ddpfPixelFormat.dwFlags & DDPF_RGB ) {

        lpfnPaintProc = GDIPaintSurfaceBlack;
    }
    else {

        // look to see if DX7 is available
#if 0
        //JEFFNO: DX7 no longer supports alphablt
        hr = pDDrawSurface->QueryInterface(IID_IDirectDrawSurface7, (LPVOID *)&pDDSurf7);
        if (SUCCEEDED(hr) && pDDSurf7)
        {
            lpfnPaintProc = DX7PaintSurfaceBlack;
            pDDSurf7->Release();
            pDDSurf7 = NULL;
        }
        else
#endif //0
        {
            lpfnPaintProc = DX1PaintSurfaceBlack;
        }
    }

    if (ddSurfaceDesc.dwFlags & DDSD_BACKBUFFERCOUNT)
    {
        dwTotalBufferCount = ddSurfaceDesc.dwBackBufferCount + 1;
    }

    if (dwTotalBufferCount == 1)
    {
        hr = (*lpfnPaintProc)(pDDrawSurface);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0, TEXT("pDDrawSurface->Blt failed, hr = 0x%x"), hr));
        }
        goto CleanUp;
    }

    dwAllocSize = dwTotalBufferCount*sizeof(LPDIRECTDRAWSURFACE);
    ppDDrawSurface = (LPDIRECTDRAWSURFACE*)_alloca(dwAllocSize);
    ZeroMemory((LPVOID)ppDDrawSurface, dwAllocSize);

    ZeroMemory((LPVOID)&ddSurfaceCaps, sizeof(DDSCAPS));
    ddSurfaceCaps.dwCaps = DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_OVERLAY;
    for (i = 0; i < dwTotalBufferCount; i++)
    {
        DWORD dwNextEntry = (i+1) % dwTotalBufferCount;
        LPDIRECTDRAWSURFACE pCurrentDDrawSurface = NULL;

        if (i == 0)
            pCurrentDDrawSurface = pDDrawSurface;
        else
            pCurrentDDrawSurface = ppDDrawSurface[i];
        ASSERT(pCurrentDDrawSurface);


        // Get the back buffer surface and store it in the next (in the circular sense) entry
        hr = pCurrentDDrawSurface->GetAttachedSurface(&ddSurfaceCaps, &(ppDDrawSurface[dwNextEntry]));
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0, TEXT("Function pDDrawSurface->GetAttachedSurface failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        ASSERT(ppDDrawSurface[dwNextEntry]);

        // Peform a DirectDraw colorfill BLT
        hr = (*lpfnPaintProc)(ppDDrawSurface[dwNextEntry]);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0, TEXT("ppDDrawSurface[dwNextEntry]->Blt failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

CleanUp:
    if (ppDDrawSurface)
    {
        for (i = 0; i < dwTotalBufferCount; i++)
        {
            if (ppDDrawSurface[i])
            {
                ppDDrawSurface[i]->Release();
                ppDDrawSurface[i] = NULL;
            }
        }

        ppDDrawSurface = NULL;
    }

    DbgLog((LOG_TRACE, 5,TEXT("Leaving PaintDDrawSurfaceBlack")));
    return hr;
}


STDMETHODIMP COMFilter::GetScaledDest(RECT *prcSrc, RECT *prcDst)
{
    if (!m_apInput[0])
        return E_FAIL;

    DWORD dwImageWidth=0, dwImageHeight=0;
    RECT rcSource, rcDest;
    m_apInput[0]->GetSourceAndDest(&rcSource, &rcDest, &dwImageWidth, &dwImageHeight);

    if (IsRectEmpty(&rcSource))
        return E_FAIL;

    DbgLog((LOG_TRACE, 3, TEXT("Source rect: (%d,%d,%d,%d)"), rcSource.left, rcSource.top, rcSource.right, rcSource.bottom));
    DbgLog((LOG_TRACE, 3, TEXT("Dest rect: (%d,%d,%d,%d)"), rcDest.left, rcDest.top, rcDest.right, rcDest.bottom));
    DbgLog((LOG_TRACE, 3, TEXT("Image size: %dx%d"), dwImageWidth, dwImageHeight));


    // when there is no output pin we are in WindowLess mode, in which case
    // all co-ordinates should be in the Desktop co-ordinate space, otherwise
    // everything is in the Renderer Window co-ordinate space.

    if (m_pOutput) {

        ScreenToClient(m_pOutput->GetWindow(), (LPPOINT)&rcDest);
        ScreenToClient(m_pOutput->GetWindow(), (LPPOINT)&rcDest+1);

        DbgLog((LOG_TRACE, 3, TEXT("Client dest rect: (%d,%d,%d,%d)"), rcDest.left, rcDest.top, rcDest.right, rcDest.bottom));
    }


    //
    // Determine the source rectangle being displayed, take into account
    // that the decoder may be decimating the image given to the OVMixer.
    //

    long OrgSrcX = WIDTH(prcSrc);
    long OrgSrcY = HEIGHT(prcSrc);

    prcSrc->left = MulDiv(rcSource.left, OrgSrcX, dwImageWidth);
    prcSrc->right = MulDiv(rcSource.right, OrgSrcX, dwImageWidth);
    prcSrc->top = MulDiv(rcSource.top, OrgSrcY, dwImageHeight);
    prcSrc->bottom = MulDiv(rcSource.bottom, OrgSrcY, dwImageHeight);


    *prcDst = rcDest;

    return S_OK;
}

STDMETHODIMP COMFilter::GetOverlayRects(RECT *rcSrc, RECT *rcDest)
{
    HRESULT hr = S_OK;
    IOverlay *pIOverlay = NULL;
    hr = m_apInput[0]->QueryInterface(IID_IOverlay, (LPVOID *)&pIOverlay);
    if (SUCCEEDED(hr)) {
        pIOverlay->GetVideoPosition( rcSrc, rcDest);
        pIOverlay->Release();
    }
    return hr;
}

STDMETHODIMP COMFilter::GetVideoPortRects(RECT *rcSrc, RECT *rcDest)
{
    HRESULT hr = S_OK;
    IVPInfo *pIVPInfo = NULL;
    hr = QueryInterface(IID_IVPInfo, (LPVOID *)&pIVPInfo);
    if (SUCCEEDED(hr)) {
        pIVPInfo->GetRectangles( rcSrc, rcDest);
        pIVPInfo->Release();
    }
    return hr;
}

STDMETHODIMP COMFilter::GetBasicVideoRects(RECT *rcSrc, RECT *rcDest)
{
    HRESULT hr = S_OK;
    IBasicVideo* Ibv = NULL;
    hr = GetBasicVideoFromOutPin(&Ibv);
    if (SUCCEEDED(hr))
    {
        hr = Ibv->GetSourcePosition
            (&rcSrc->left, &rcSrc->top, &rcSrc->right, &rcSrc->bottom);
        if (SUCCEEDED(hr))
        {
            rcSrc->right += rcSrc->left;
            rcSrc->bottom += rcSrc->top;
        }

        hr = Ibv->GetDestinationPosition
            (&rcDest->left, &rcDest->top, &rcDest->right, &rcDest->bottom);
        if (SUCCEEDED(hr))
        {
            rcDest->right += rcDest->left;
            rcDest->bottom += rcDest->top;
        }
        Ibv->Release();
    }
    return hr;
}



HRESULT COMFilter::GetBasicVideoFromOutPin(IBasicVideo** pBasicVideo)
{
    HRESULT hr = E_FAIL;
    COMOutputPin* pOutPin = GetOutputPin();
    if (pOutPin)
    {
        IPin* IPeerPin = pOutPin->CurrentPeer();
        if (IPeerPin)
        {
            PIN_INFO PinInfo;
            hr = IPeerPin->QueryPinInfo(&PinInfo);
            if (SUCCEEDED(hr))
            {
                hr = PinInfo.pFilter->QueryInterface(IID_IBasicVideo, (LPVOID *)pBasicVideo);
                PinInfo.pFilter->Release();
            }
        }
    }
    return hr;
}


/******************************Public*Routine******************************\
* QueryOverlayFXCaps
*
* Returns the current effect caps for the DDraw Object currently in use.
*
* History:
* Tue 07/06/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::QueryOverlayFXCaps(
    DWORD *lpdwOverlayFXCaps
    )
{
    CAutoLock l(&m_csFilter);

    if (!lpdwOverlayFXCaps) {
        return E_POINTER;
    }

    LPDDCAPS lpCaps = GetHardwareCaps();
    if (lpCaps)
    {
        DWORD dwFlags = 0;

        if (lpCaps->dwFXCaps & DDFXCAPS_OVERLAYMIRRORLEFTRIGHT)
        {
            dwFlags |= AMOVERFX_MIRRORLEFTRIGHT;
        }

        if (lpCaps->dwFXCaps & DDFXCAPS_OVERLAYMIRRORUPDOWN)
        {
            dwFlags |= AMOVERFX_MIRRORUPDOWN;
        }

        if (lpCaps->dwFXCaps & DDFXCAPS_OVERLAYDEINTERLACE)
        {
            dwFlags |= AMOVERFX_DEINTERLACE;
        }

        *lpdwOverlayFXCaps = dwFlags;
        return S_OK;
    }

    return E_FAIL;
}


/******************************Public*Routine******************************\
* SetOverlayFX
*
* Validates that the user specified FX flags are valid, then
* updates the internal FX state and calls UpdateOverlay to reflect the
* new effect to the display.
*
* History:
* Tue 07/06/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::SetOverlayFX(
    DWORD dwOverlayFX
    )
{
    CAutoLock l(&m_csFilter);
    DWORD dwCaps;

    //
    // get the current overlay caps
    //

    if (S_OK == QueryOverlayFXCaps(&dwCaps))
    {
        //
        // check that the caller is asking us to do
        // something that is valid
        //

        dwCaps |= AMOVERFX_DEINTERLACE;    // deinterlacing is a hint
        if (dwOverlayFX != (dwOverlayFX & dwCaps))
        {
            return E_INVALIDARG;
        }

        m_dwOverlayFX = 0;
        if (dwOverlayFX & AMOVERFX_MIRRORLEFTRIGHT)
        {
            m_dwOverlayFX |= DDOVERFX_MIRRORLEFTRIGHT;
        }

        if (dwOverlayFX & AMOVERFX_MIRRORUPDOWN)
        {
            m_dwOverlayFX |= DDOVERFX_MIRRORUPDOWN;
        }
        if (dwOverlayFX & AMOVERFX_DEINTERLACE)
        {
            m_dwOverlayFX |= DDOVERFX_DEINTERLACE;
        }

        //
        // call UpdateOverlay to make the new FX flags take effect
        //
        return m_apInput[0]->ApplyOvlyFX();
    }

    return E_FAIL;
}

/******************************Public*Routine******************************\
* GetOverlayFX
*
* Returns the current overlay FX that is in use.
*
* History:
* Tue 07/06/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetOverlayFX(
    DWORD *lpdwOverlayFX
    )
{
    CAutoLock l(&m_csFilter);
    if (lpdwOverlayFX)
    {
        *lpdwOverlayFX = m_dwOverlayFX;
        return S_OK;
    }
    return E_POINTER;
}



//  Wrapper for UpdateOverlay - we track the overlay state and do
//  notifications and manage painting the color key

HRESULT COMFilter::CallUpdateOverlay(
                          IDirectDrawSurface *pSurface,
                          LPRECT prcSrcCall,
                          LPDIRECTDRAWSURFACE pDestSurface,
                          LPRECT prcDestCall,
                          DWORD dwFlags,
                          IOverlayNotify *pIOverlayNotify,
                          LPRGNDATA pBuffer)
{
#define CAPS_HACK
#ifdef CAPS_HACK
    if (!(m_DirectCaps.dwCaps2 & DDCAPS2_CANBOBINTERLEAVED) &&
        (dwFlags & (DDOVER_INTERLEAVED | DDOVER_BOB))==
         (DDOVER_INTERLEAVED | DDOVER_BOB)) {
        dwFlags &= ~(DDOVER_INTERLEAVED | DDOVER_BOB);
    }
#endif
    LPRECT prcSrc = prcSrcCall;
    LPRECT prcDest = prcDestCall;

    DbgLog((LOG_TRACE, 2, TEXT("UpdateOverlayFlags %8.8X"), dwFlags));

    //  Have we changed anything?
    DWORD dwUpdFlags = 0;
    BOOL bNewVisible = m_bOverlayVisible;

    if ((dwFlags & DDOVER_SHOW) && !m_bOverlayVisible ||
        (dwFlags & DDOVER_HIDE) && m_bOverlayVisible) {

        dwUpdFlags |= AM_OVERLAY_NOTIFY_VISIBLE_CHANGE;
        bNewVisible = !bNewVisible;

        //  If we're going invisible
        if (NULL == m_pExclModeCallback && !bNewVisible) {
            m_bOverlayVisible = FALSE;
            //  Here's where we should remove the overlay color
        }
    }

    if (prcSrc == NULL) {
        prcSrc = &m_rcOverlaySrc;
    } else if (!EqualRect(prcSrc, &m_rcOverlaySrc)) {
        dwUpdFlags |= AM_OVERLAY_NOTIFY_SOURCE_CHANGE;
    }

    if (prcDest == NULL) {
        prcDest = &m_rcOverlayDest;
    } else if (!EqualRect(prcDest, &m_rcOverlayDest)) {
        dwUpdFlags |= AM_OVERLAY_NOTIFY_DEST_CHANGE;
    }
    DbgLog((LOG_TRACE, 2, TEXT("CallUpadateOverlay flags (0x%8.8X)")
                          TEXT("dest (%d,%d,%d,%d)"),
                          dwFlags,
                          prcDest->left,
                          prcDest->top,
                          prcDest->right,
                          prcDest->bottom));

    if (dwUpdFlags != 0) {
        if (m_pExclModeCallback) {
            m_pExclModeCallback->OnUpdateOverlay(TRUE,     // Before
                                                 dwUpdFlags,
                                                 m_bOverlayVisible,
                                                 &m_rcOverlaySrc,
                                                 &m_rcOverlayDest,
                                                 bNewVisible,
                                                 prcSrc,
                                                 prcDest);
        }
    }

    HRESULT hr = S_OK;
    DDOVERLAYFX ddOVFX;
    DDOVERLAYFX* lpddOverlayFx;

    if (dwFlags & DDOVER_HIDE) {
        dwFlags &= ~DDOVER_DDFX;
        lpddOverlayFx = NULL;
    }
    else {
        INITDDSTRUCT(ddOVFX);
        dwFlags |= DDOVER_DDFX;
        lpddOverlayFx = &ddOVFX;
        lpddOverlayFx->dwDDFX = m_dwOverlayFX;
    }

    if (pSurface) {

        if (prcSrcCall && prcDestCall) {

            RECT rcSrc = *prcSrcCall;
            RECT rcDst = *prcDestCall;

            // shrinking horizontally and driver can't arbitrarly shrink in X ?
            if ((!(m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKX)) &&
                (WIDTH(&rcSrc) > WIDTH(&rcDst))) {

                rcSrc.right = rcSrc.left + WIDTH(&rcDst);
            }

            // shrinking vertically and driver can't arbitrarly shrink in Y ?
            if ((!(m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKY)) &&
                (HEIGHT(&rcSrc) > HEIGHT(&rcDst))) {

                rcSrc.bottom = rcSrc.top + HEIGHT(&rcDst);
            }

            RECT TargetRect = rcDst;
            OffsetRect(&TargetRect,
                       -m_lpCurrentMonitor->rcMonitor.left,
                       -m_lpCurrentMonitor->rcMonitor.top);

            hr = pSurface->UpdateOverlay(
                               &rcSrc,
                               pDestSurface,
                               &TargetRect,
                               dwFlags,
                               lpddOverlayFx);
        }
        else {

            if (prcDestCall) {

                RECT TargetRect = *prcDestCall;
                OffsetRect(&TargetRect,
                           -m_lpCurrentMonitor->rcMonitor.left,
                           -m_lpCurrentMonitor->rcMonitor.top);

                hr = pSurface->UpdateOverlay(
                                   prcSrcCall,
                                   pDestSurface,
                                   &TargetRect,
                                   dwFlags,
                                   lpddOverlayFx);
            }
            else {

                hr = pSurface->UpdateOverlay(
                                   prcSrcCall,
                                   pDestSurface,
                                   prcDestCall,
                                   dwFlags,
                                   lpddOverlayFx);

            }
        }
    } else {
        if (pIOverlayNotify) {
            if (pBuffer) {
                pIOverlayNotify->OnClipChange(prcSrcCall, prcDestCall, pBuffer);
            } else {
                pIOverlayNotify->OnPositionChange(prcSrcCall, prcDestCall);
            }
        }
    }

    //hr = pSurface->Flip(NULL, DDFLIP_WAIT);

    //  Notify afterwards
    if (dwUpdFlags != 0) {
        BOOL bOldVisible = m_bOverlayVisible;
        RECT rcOldSource = m_rcOverlaySrc;
        RECT rcOldDest   = m_rcOverlayDest;
        m_bOverlayVisible = bNewVisible;
        m_rcOverlaySrc    = *prcSrc;
        m_rcOverlayDest   = *prcDest;
        if (m_pExclModeCallback) {
            m_pExclModeCallback->OnUpdateOverlay(FALSE,    // After
                                                 dwUpdFlags,
                                                 bOldVisible,
                                                 &rcOldSource,
                                                 &rcOldDest,
                                                 bNewVisible,
                                                 prcSrc,
                                                 prcDest);
        } else {
            if (!bOldVisible && bNewVisible) {
                // Here's where we should draw the color key
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* QueryDecimationUsage
*
*
*
* History:
* Wed 07/07/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::QueryDecimationUsage(
    DECIMATION_USAGE* lpUsage
    )
{
    if (lpUsage) {
        *lpUsage = m_dwDecimation;
        return S_OK;
    }
    return E_POINTER;
}


/******************************Public*Routine******************************\
* SetDecimationUsage
*
*
*
* History:
* Wed 07/07/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::SetDecimationUsage(
    DECIMATION_USAGE Usage
    )
{
    CAutoLock l(&m_csFilter);

    switch (Usage) {
    case DECIMATION_LEGACY:
    case DECIMATION_USE_DECODER_ONLY:
    case DECIMATION_USE_OVERLAY_ONLY:
    case DECIMATION_DEFAULT:
        break;

    case DECIMATION_USE_VIDEOPORT_ONLY:
        // only allow this mode if we are actually using a video port
        if (m_apInput[0]->m_RenderTransport == AM_VIDEOPORT) {
            break;
        }

        // else fall thru

    default:
        return E_INVALIDARG;
    }
    DECIMATION_USAGE dwOldUsage = m_dwDecimation;
    m_dwDecimation = Usage;


    if (dwOldUsage != m_dwDecimation) {
        EventNotify(GetPinCount(), EC_OVMIXER_REDRAW_ALL, 0, 0);
    }

    return S_OK;
}


// This function allocates a shared memory block for use by the upstream filter
// generating DIBs to render. The memory block is created in shared
// memory so that GDI doesn't have to copy the memory in BitBlt
HRESULT CreateDIB(LONG lSize, BITMAPINFO *pBitMapInfo, DIBDATA *pDibData)
{
    HRESULT hr = NOERROR;
    BYTE *pBase = NULL;            // Pointer to the actual image
    HANDLE hMapping = NULL;        // Handle to mapped object
    HBITMAP hBitmap = NULL;        // DIB section bitmap handle
    DWORD dwError = 0;

    AMTRACE((TEXT("CreateDIB")));

    // Create a file mapping object and map into our address space
    hMapping = CreateFileMapping(hMEMORY, NULL,  PAGE_READWRITE,  (DWORD) 0, lSize, NULL);           // No name to section
    if (hMapping == NULL)
    {
        dwError = GetLastError();
        hr = AmHresultFromWin32(dwError);
        goto CleanUp;
    }

    // create the DibSection
    hBitmap = CreateDIBSection((HDC)NULL, pBitMapInfo, DIB_RGB_COLORS,
        (void**) &pBase, hMapping, (DWORD) 0);
    if (hBitmap == NULL || pBase == NULL)
    {
        dwError = GetLastError();
        hr = AmHresultFromWin32(dwError);
        goto CleanUp;
    }

    // Initialise the DIB information structure
    pDibData->hBitmap = hBitmap;
    pDibData->hMapping = hMapping;
    pDibData->pBase = pBase;
    pDibData->PaletteVersion = PALETTE_VERSION;
    GetObject(hBitmap, sizeof(DIBSECTION), (void*)&(pDibData->DibSection));

CleanUp:
    if (FAILED(hr))
    {
        EXECUTE_ASSERT(CloseHandle(hMapping));
    }
    return hr;
}

// DeleteDIB
//
// This function just deletes DIB's created by the above CreateDIB function.
//
HRESULT DeleteDIB(DIBDATA *pDibData)
{
    if (!pDibData)
    {
        return E_INVALIDARG;
    }

    if (pDibData->hBitmap)
    {
        DeleteObject(pDibData->hBitmap);
    }

    if (pDibData->hMapping)
    {
        CloseHandle(pDibData->hMapping);
    }

    ZeroMemory(pDibData, sizeof(*pDibData));

    return NOERROR;
}


// function used to blt the data from the source to the target dc
void FastDIBBlt(DIBDATA *pDibData, HDC hTargetDC, HDC hSourceDC, RECT *prcTarget, RECT *prcSource)
{
    HBITMAP hOldBitmap = NULL;         // Store the old bitmap
    DWORD dwSourceWidth = 0, dwSourceHeight = 0, dwTargetWidth = 0, dwTargetHeight = 0;

    ASSERT(prcTarget);
    ASSERT(prcSource);

    dwSourceWidth = WIDTH(prcSource);
    dwSourceHeight = HEIGHT(prcSource);
    dwTargetWidth = WIDTH(prcTarget);
    dwTargetHeight = HEIGHT(prcTarget);

    hOldBitmap = (HBITMAP) SelectObject(hSourceDC, pDibData->hBitmap);


    // Is the destination the same size as the source
    if ((dwSourceWidth == dwTargetWidth) && (dwSourceHeight == dwTargetHeight))
    {
        // Put the image straight into the target dc
        BitBlt(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
               dwTargetHeight, hSourceDC, prcSource->left, prcSource->top,
               SRCCOPY);
    }
    else
    {
        // Stretch the image when copying to the target dc
        StretchBlt(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, hSourceDC, prcSource->left, prcSource->top,
            dwSourceWidth, dwSourceHeight, SRCCOPY);
    }

    // Put the old bitmap back into the device context so we don't leak
    SelectObject(hSourceDC, hOldBitmap);
}

// funtion used to transfer pixels from the DIB to the target dc
void SlowDIBBlt(BYTE *pDibBits, BITMAPINFOHEADER *pHeader, HDC hTargetDC, RECT *prcTarget, RECT *prcSource)
{
    DWORD dwSourceWidth = 0, dwSourceHeight = 0, dwTargetWidth = 0, dwTargetHeight = 0;

    ASSERT(prcTarget);
    ASSERT(prcSource);

    dwSourceWidth = WIDTH(prcSource);
    dwSourceHeight = HEIGHT(prcSource);
    dwTargetWidth = WIDTH(prcTarget);
    dwTargetHeight = HEIGHT(prcTarget);

    // Is the destination the same size as the source
    if ((dwSourceWidth == dwTargetWidth) && (dwSourceHeight == dwTargetHeight))
    {
        UINT uStartScan = 0, cScanLines = pHeader->biHeight;

        // Put the image straight into the target dc
        SetDIBitsToDevice(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, prcSource->left, prcSource->top, uStartScan, cScanLines,
            pDibBits, (BITMAPINFO*) pHeader, DIB_RGB_COLORS);
    }
    else
    {
        // if the origin of bitmap is bottom-left, adjust soruce_rect_top
        // to be the bottom-left corner instead of the top-left.
        LONG lAdjustedSourceTop = (pHeader->biHeight > 0) ? (pHeader->biHeight - prcSource->bottom) :
            (prcSource->top);

        // stretch the image into the target dc
        StretchDIBits(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, prcSource->left, lAdjustedSourceTop, dwSourceWidth, dwSourceHeight,
            pDibBits, (BITMAPINFO*) pHeader, DIB_RGB_COLORS, SRCCOPY);
    }

}


/******************************Public*Routine******************************\
* Set
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::Set(
    REFGUID guidPropSet,
    DWORD dwPropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData
    )
{
    AMTRACE((TEXT("COMFilter::Set")));

    if (guidPropSet != AM_KSPROPSETID_FrameStep)
    {
        return E_PROP_SET_UNSUPPORTED ;
    }

    if (dwPropID != AM_PROPERTY_FRAMESTEP_STEP &&
        dwPropID != AM_PROPERTY_FRAMESTEP_CANCEL &&
        dwPropID != AM_PROPERTY_FRAMESTEP_CANSTEP &&
        dwPropID != AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE)
    {
        return E_PROP_ID_UNSUPPORTED;
    }

    switch (dwPropID) {
    case AM_PROPERTY_FRAMESTEP_STEP:

        if (cbPropData < sizeof(AM_FRAMESTEP_STEP)) {
            return E_INVALIDARG;
        }

        if (0 == ((AM_FRAMESTEP_STEP *)pPropData)->dwFramesToStep) {
            return E_INVALIDARG;
        }

        return m_apInput[0]->SetFrameStepMode(((AM_FRAMESTEP_STEP *)pPropData)->dwFramesToStep);

    case AM_PROPERTY_FRAMESTEP_CANCEL:
        return  m_apInput[0]->CancelFrameStepMode();

    case AM_PROPERTY_FRAMESTEP_CANSTEP:
    case AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE:
        if (m_apInput[0]->m_RenderTransport == AM_VIDEOPORT ||
            m_apInput[0]->m_RenderTransport == AM_IOVERLAY) {

           return S_FALSE;
        }
        return S_OK;
    }

    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* Get
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::Get(
    REFGUID guidPropSet,
    DWORD dwPropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData,
    DWORD *pcbReturned
    )
{
    AMTRACE((TEXT("COMFilter::Get")));
    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* QuerySupported
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::QuerySupported(
    REFGUID guidPropSet,
    DWORD dwPropID,
    DWORD *pTypeSupport
    )
{
    AMTRACE((TEXT("COMFilter::QuerySupported")));

    if (guidPropSet != AM_KSPROPSETID_FrameStep)
    {
        return E_PROP_SET_UNSUPPORTED;
    }

    if (dwPropID != AM_PROPERTY_FRAMESTEP_STEP &&
        dwPropID != AM_PROPERTY_FRAMESTEP_CANCEL)
    {
        return E_PROP_ID_UNSUPPORTED;
    }

    if (pTypeSupport)
    {
        *pTypeSupport = KSPROPERTY_SUPPORT_SET ;
    }

    return S_OK;
}

//
//  More or less lifted from the w2k SFP code
//
static HRESULT GetFileVersion (const TCHAR* pszFile, // file
                       UINT64* pFileVersion )
{
    DWORD               dwSize, dwHandle;
    VS_FIXEDFILEINFO    *pFixedVersionInfo;
    DWORD               dwVersionInfoSize;
    DWORD               dwReturnCode;

    dwSize = GetFileVersionInfoSize( const_cast<TCHAR *>(pszFile), &dwHandle);

    HRESULT hr = S_OK;
    *pFileVersion = 0;

    // .txt and .inf, etc files might not have versions
    if( dwSize == 0 )
    {
        dwReturnCode = GetLastError();
        hr = E_FAIL;
    } else {
        LPVOID pVersionInfo= new BYTE [dwSize];

        if( NULL == pVersionInfo) {
            hr = E_OUTOFMEMORY;
        } else {
            if( !GetFileVersionInfo( const_cast<TCHAR *>(pszFile), dwHandle, dwSize, pVersionInfo ) ) {
                dwReturnCode = GetLastError();
                DbgLog((LOG_ERROR, 1,  TEXT("Error in GetFileVersionInfo for %s. ec=%d"),
                           pszFile, dwReturnCode));
                hr = E_FAIL;
            } else {
                if( !VerQueryValue( pVersionInfo,
                        TEXT("\\"), // we need the root block
                        (LPVOID *) &pFixedVersionInfo,
                        (PUINT)  &dwVersionInfoSize ) )
                {
                    dwReturnCode = GetLastError();
                    hr = E_FAIL;
                } else {
                    *pFileVersion =  pFixedVersionInfo->dwFileVersionMS;
                    *pFileVersion = UINT64(*pFileVersion)<<32;
                    *pFileVersion += pFixedVersionInfo->dwFileVersionLS;
                }
            }
            delete [] pVersionInfo;
        }
    }
    return hr;
}


// V5.00.00.38 to v.42 of the MMatics decoder try to use the MoComp interfaces incorrectly
// (it mixes the MoComp GetBuffer/Release with DisplayFrame())
// We'll deny them so that we don't crash / show black

BOOL COMFilter::IsFaultyMMaticsMoComp()
{
    if( !m_bHaveCheckedMMatics ) {
        m_bHaveCheckedMMatics = TRUE;

        // the connected pin doesn't tell us the correct version, so we'll see if
        // MMatics is running.  We don't expect it to be run concurrently with another decoder
        const TCHAR* pszDecoderName = TEXT( "DVD Express AV Decoder.dll");
        HMODULE hModule = GetModuleHandle( pszDecoderName );
        if( hModule ) {
            UINT64 ullVersion;
#define MAKE_VER_NUM( v1, v2, v3, v4 ) (((UINT64(v1) << 16 | (v2) )<<16 | (v3) ) << 16 | (v4) )

			TCHAR szFilename[1024];
			if( GetModuleFileName( hModule, szFilename, NUMELMS(szFilename) ) ) {
				if( SUCCEEDED( GetFileVersion( szFilename, &ullVersion ) )) {
					if( MAKE_VER_NUM( 5, 0, 0, 38 ) <=  ullVersion &&
														ullVersion <= MAKE_VER_NUM( 5, 0, 0, 42 ) )
					{
						// ASSERT( !"Bogus MMatics Version detected" );
						m_bIsFaultyMMatics = TRUE;
					}
				}
			}
        }
    }
    return m_bIsFaultyMMatics;
}

#if defined(DEBUG) && !defined(_WIN64)
void WINAPI
OVMixerDebugLog(
    DWORD Type,
    DWORD Level,
    const TCHAR *pFormat,
    ...
    )
{
    TCHAR szInfo[1024];
#if defined(UNICODE)
    char  szInfoA[1024];
#endif

    /* Format the variable length parameter list */

    if (Level > (DWORD)iOVMixerDump) {
        return;
    }

    va_list va;
    va_start(va, pFormat);

    wsprintf(szInfo, TEXT("OVMIXER (tid %x) : "), GetCurrentThreadId());
    wvsprintf(szInfo + lstrlen(szInfo), pFormat, va);

    lstrcat(szInfo, TEXT("\r\n"));


#if defined(UNICODE)
    wsprintfA(szInfoA, "%ls", szInfo);
    _lwrite(DbgFile, szInfoA, lstrlenA(szInfoA));
#else
    _lwrite(DbgFile, szInfo, lstrlen(szInfo));
#endif

    va_end(va);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\ominpin.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>     // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <dvdmedia.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include <macvis.h>
#include <ovmixer.h>
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx
#include <malloc.h>
#ifdef PERF
#include <measure.h>
#endif

//
//   Flipping surface implementation
//
//   To allow decoders to hold on to surfaces for out of order decode
//   we flip directly to the surface pass on Receive rather than
//   use the default NULL target surface for Flip().
//
//   This works in the following way
//
//   The COMPinputPin::m_pDirectDrawSurface points to the FRONT buffer
//
//   When Receive is called we Flip() the front buffer and because we
//   do an explicit Flip() DirectDraw swaps the memory pointers for the
//   current Front buffer and the surface passed in which is then attached
//   to the front buffer.
//
//   The received buffer is then put at the back of the queue so (correctly)
//   the previous front buffer is now at the back of the queue to be handed
//   to the application
//
//   The allocator actually has one more buffer than was actually requested
//   so the previous front buffer won't actually be requested until the next
//   Receive and hence the previous Flip() has time to complete.
//

//  Video accelerator disable interface
const TCHAR szVideoAcc[] = TEXT("Video Acceleration");

extern "C"
const TCHAR szPropPage[] = TEXT("Property Pages");

extern "C"
const TCHAR chRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\Overlay Mixer");

extern "C"
const TCHAR chMultiMonWarning[] = TEXT("MMon warn");

/******************************Public*Routine******************************\
* GetRegistryDword
*
*
*
\**************************************************************************/
int
GetRegistryDword(
    HKEY hk,
    const TCHAR *pKey,
    int iDefault
)
{
    HKEY hKey;
    LONG lRet;
    int  iRet = iDefault;

    lRet = RegOpenKeyEx(hk, chRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;

        dwLen = sizeof(iRet);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, 0L, &dwType,
                                             (LPBYTE)&iRet, &dwLen)) {
            iRet = iDefault;
        }
        RegCloseKey(hKey);
    }
    return iRet;
}

/******************************Public*Routine******************************\
* SetRegistryDword
*
*
*
\**************************************************************************/
LONG
SetRegistryDword(
    HKEY hk,
    const TCHAR *pKey,
    int iRet
)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(hk, chRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, 0L, REG_DWORD,
                             (LPBYTE)&iRet, sizeof(iRet));
        RegCloseKey(hKey);
    }
    return lRet;
}

///////////////////////////////////////////
// CLASS CDDrawMediaSample implemented here
///////////////////////////////////////////

// constructor
CDDrawMediaSample::CDDrawMediaSample(TCHAR *pName, CBaseAllocator *pAllocator, HRESULT *phr, LPBYTE pBuffer, LONG length,
                                     bool bKernelFlip)
: CMediaSample(pName, pAllocator, phr, pBuffer, length)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering CDDrawMediaSample::Constructor")));

    m_pDirectDrawSurface = NULL;
    m_dwDDrawSampleSize  = 0;
    m_bSurfaceLocked     = FALSE;
    m_bKernelLock        = bKernelFlip;
    SetRect(&m_SurfaceRect, 0, 0, 0, 0);

    memset(&m_DibData, 0, sizeof(DIBDATA));
    m_bInit = FALSE;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CDDrawMediaSample::Constructor")));
    return;
}

// destructor
CDDrawMediaSample::~CDDrawMediaSample(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::Destructor")));

    if (m_pDirectDrawSurface)
    {
        __try {
            m_pDirectDrawSurface->Release() ;  // release surface now
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
        m_pDirectDrawSurface = NULL;
    }

    if (m_bInit)
    {
        if (m_DibData.hBitmap)
        {
            EXECUTE_ASSERT(DeleteObject(m_DibData.hBitmap));
        }
        if (m_DibData.hMapping)
        {
            EXECUTE_ASSERT(CloseHandle(m_DibData.hMapping));
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::Destructor")));
    return;
}

HRESULT CDDrawMediaSample::SetDDrawSampleSize(DWORD dwDDrawSampleSize)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));

    m_dwDDrawSampleSize = dwDDrawSampleSize;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));
    return hr;
}

HRESULT CDDrawMediaSample::GetDDrawSampleSize(DWORD *pdwDDrawSampleSize)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));

    if (!pdwDDrawSampleSize)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad Arguments, pdwDDrawSampleSize = NULL")));
        hr = E_POINTER;
        goto CleanUp;
    }

    *pdwDDrawSampleSize = m_dwDDrawSampleSize;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));
    return hr;
}

HRESULT CDDrawMediaSample::SetDDrawSurface(LPDIRECTDRAWSURFACE pDirectDrawSurface)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));

    if (pDirectDrawSurface)               // only if new surface is not NULL...
        pDirectDrawSurface->AddRef() ;    // ...add a ref count on it

    if (m_pDirectDrawSurface)             // if there was a surface already...
        m_pDirectDrawSurface->Release() ; // ... then release it now

    m_pDirectDrawSurface = pDirectDrawSurface;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));
    return hr;
}

HRESULT CDDrawMediaSample::GetDDrawSurface(LPDIRECTDRAWSURFACE *ppDirectDrawSurface)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));

    if (!ppDirectDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad Arguments, ppDirectDrawSurface = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    *ppDirectDrawSurface = m_pDirectDrawSurface;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetDDrawSampleSize")));
    return hr;
}
// overridden to expose IDirectDrawMediaSample
STDMETHODIMP CDDrawMediaSample::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CDDrawMediaSample::QueryInterface")));

    if (riid == IID_IDirectDrawMediaSample && m_pDirectDrawSurface)
    {
        hr = GetInterface((IDirectDrawMediaSample*)this, ppv);
#ifdef DEBUG
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IDirectDrawMediaSample*) failed, hr = 0x%x"), hr));
        }
#endif
    }
    else
    {
        hr = CMediaSample::QueryInterface(riid, ppv);
#ifdef DEBUG
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("CUnknown::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
#endif
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CDDrawMediaSample::QueryInterface")));
    return hr;
}

// Implement IDirectDrawMediaSample
STDMETHODIMP CDDrawMediaSample::GetSurfaceAndReleaseLock(IDirectDrawSurface **ppDirectDrawSurface,
                                                         RECT* pRect)
{
    HRESULT hr = NOERROR;
    BYTE *pBufferPtr;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CDDrawMediaSample::GetSurfaceAndReleaseLock")));

    // make sure the surface is locked
    if (!m_bSurfaceLocked)
    {
        DbgLog((LOG_ERROR, 4, TEXT("m_bSurfaceLocked is FALSE, can't unlock surface twice, returning E_UNEXPECTED")));
        goto CleanUp;

    }

    // make sure you have a direct draw surface pointer
    if (!m_pDirectDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface is NULL, returning E_FAIL")));
        hr = E_FAIL;
        goto CleanUp;

    }

    hr = GetPointer(&pBufferPtr);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetPointer() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    ASSERT(m_pDirectDrawSurface);
    hr = m_pDirectDrawSurface->Unlock((LPVOID)pBufferPtr);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface->Unlock failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    // Can't do this to make the 829/848 work with the ovmixer. The reason is that those
    // drivers unlock the surface just after GetBuffer (to avoid the win16 lock), however
    // there is a bunch of code in the proxy which ASSERTS for a valid pointer value
    /*
    // update the pointer value, however keep the SampleSize around
    hr = SetPointer(NULL, 0);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("SetPointer() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }
    */

    if (ppDirectDrawSurface)
        *ppDirectDrawSurface  = m_pDirectDrawSurface;
    if (pRect)
        *pRect = m_SurfaceRect;
    m_bSurfaceLocked = FALSE;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CDDrawMediaSample::GetSurfaceAndReleaseLock")));
    return hr;
}

STDMETHODIMP CDDrawMediaSample::LockMediaSamplePointer(void)
{
    HRESULT hr = NOERROR;
    DWORD dwDDrawSampleSize = 0;
    DDSURFACEDESC ddSurfaceDesc;
    DWORD dwLockFlags = DDLOCK_WAIT;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CDDrawMediaSample::LockMediaSamplePointer")));

    // make sure the surface is locked
    if (m_bSurfaceLocked)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_bSurfaceLocked is TRUE, can't lock surface twice, returning E_UNEXPECTED")));
        hr = E_UNEXPECTED;
        goto CleanUp;

    }

    // make sure you have a direct draw surface pointer
    if (!m_pDirectDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface is NULL, returning E_FAIL")));
        hr = E_FAIL;
        goto CleanUp;

    }

    // set the dwSize of ddSurfaceDesc
    INITDDSTRUCT(ddSurfaceDesc);

    // lock the surface - no need to grab the win16 lock
    ASSERT(m_pDirectDrawSurface);

    //  Using DDLOCK_NOSYSLOCK caused us to get DDERR_SURFACEBUSY on some of
    //  our blts to the primary for painting the color key so we've
    //  stopped using it for now.

    IDirectDrawSurface7 *pSurface7;
    if (m_bKernelLock && SUCCEEDED(m_pDirectDrawSurface->QueryInterface(
           IID_IDirectDrawSurface7,
           (void **)&pSurface7))) {
        pSurface7->Release();
        dwLockFlags |= DDLOCK_NOSYSLOCK;
    }
    hr = m_pDirectDrawSurface->Lock(
             NULL,
             &ddSurfaceDesc,
             dwLockFlags,
             (HANDLE)NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface->Lock() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    hr = GetDDrawSampleSize(&dwDDrawSampleSize);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetDDrawSampleSize() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwDDrawSampleSize);


    // update the pointer value
    hr = SetPointer((BYTE*)ddSurfaceDesc.lpSurface, dwDDrawSampleSize);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("SetPointer() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    m_bSurfaceLocked = TRUE;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CDDrawMediaSample::LockMediaSamplePointer")));
    return hr;
}

// Set the shared memory DIB information
void CDDrawMediaSample::SetDIBData(DIBDATA *pDibData)
{
    ASSERT(pDibData);
    m_DibData = *pDibData;
    m_pBuffer = m_DibData.pBase;
    m_cbBuffer = m_dwDDrawSampleSize;
    m_bInit = TRUE;
}


// Retrieve the shared memory DIB data
DIBDATA *CDDrawMediaSample::GetDIBData()
{
    ASSERT(m_bInit == TRUE);
    return &m_DibData;
}


///////////////////////////////////////////
// CLASS COMInputAllocator implemented here
///////////////////////////////////////////

// constructor
COMInputAllocator::COMInputAllocator(COMInputPin *pPin, CCritSec *pLock, HRESULT *phr)
: CBaseAllocator(NAME("Video Allocator"), NULL, phr, TRUE, true)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::Constructor")));

    ASSERT(pPin != NULL && pLock != NULL);

    m_pPin = pPin;
    m_pFilterLock = pLock;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::Constructor")));

    //  REVIEW don't overwrite a failure code from CBaseAllocator
    return;
}

#ifdef DEBUG
// destructor
COMInputAllocator::~COMInputAllocator(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::Destructor")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::Destructor")));
    return;
}
#endif

// Override this to publicise IDirectDrawMediaSampleAllocator
STDMETHODIMP COMInputAllocator::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    AM_RENDER_TRANSPORT amRenderTransport;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::NonDelegatingQueryInterface")));

    CAutoLock cLock(m_pFilterLock);

    // get the pins render transport
    m_pPin->GetRenderTransport(&amRenderTransport);

    if ((riid == IID_IDirectDrawMediaSampleAllocator) &&
        (amRenderTransport == AM_OVERLAY || amRenderTransport == AM_OFFSCREEN))
    {
        hr = GetInterface((IDirectDrawMediaSampleAllocator*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("GetInterface((IDirectDrawMediaSampleAllocator*)this, ppv)  failed, hr = 0x%x"), hr));
        }
    }
    else
    {
        // call the base class
        hr = CBaseAllocator::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::NonDelegatingQueryInterface")));
    return hr;
}

STDMETHODIMP COMInputAllocator::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::SetProperties")));

    // call the base class
    hr = CBaseAllocator::SetProperties(pRequest, pActual);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::SetProperties() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the pin
    hr = m_pPin->OnSetProperties(pRequest, pActual);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pPin->AllocateSurfaces() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::SetProperties")));
    return hr;
}

// called when we receive a sample
HRESULT COMInputAllocator::GetBuffer(IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
                                     REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::GetBuffer")));

    // call the base class
    IMediaSample *pSample = NULL;
    hr = CBaseAllocator::GetBuffer(&pSample,pStartTime,pEndTime,dwFlags);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::GetBuffer() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the pin
    hr = m_pPin->OnGetBuffer(&pSample, pStartTime, pEndTime, dwFlags);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pPin->OnGetBuffer() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::GetBuffer")));
    {
        //  REVIEW why lock?  There are no variables in the allocato
        //  accessed here
        CAutoLock cAllocatorLock(this);
        if (FAILED(hr))
        {
            if (pSample)
            {
                IMemAllocatorNotifyCallbackTemp* pNotifyTemp = m_pNotify;
                m_pNotify = NULL;
                pSample->Release();
                m_pNotify = pNotifyTemp;
            }
            *ppSample = NULL;
        }
        else
        {
            ASSERT(pSample != NULL);
            *ppSample = pSample;
        }
    }
    return hr;
}


// called when the sample is released
HRESULT COMInputAllocator::ReleaseBuffer(IMediaSample *pSample)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::ReleaseBuffer")));

    // unlock the sample first
    hr = ((CDDrawMediaSample*)pSample)->GetSurfaceAndReleaseLock(NULL, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pSample->GetSurfaceAndReleaseLock() failed, hr = 0x%x"), hr));
        // goto CleanUp;
        // if this happens we still have to release the sample to the free list, so don't bail out
    }

    {
        CAutoLock cAllocatorLock(this);

        // Copy of base class code - put at end of the list
        {
            CheckPointer(pSample,E_POINTER);
            ValidateReadPtr(pSample,sizeof(IMediaSample));
            BOOL bRelease = FALSE;
            {
                CAutoLock cal(this);

                /* Put back on the free list */

                CMediaSample **ppTail;
                for (ppTail = &m_lFree.m_List; *ppTail;
                    ppTail = &((CDDrawMediaSample *)(*ppTail))->Next()) {
                }
                *ppTail = (CMediaSample *)pSample;
                ((CDDrawMediaSample *)pSample)->Next() = NULL;
                m_lFree.m_nOnList++;

                if (m_lWaiting != 0) {
                    NotifySample();
                }

                // if there is a pending Decommit, then we need to complete it by
                // calling Free() when the last buffer is placed on the free list

                LONG l1 = m_lFree.GetCount();
                if (m_bDecommitInProgress && (l1 == m_lAllocated)) {
                    Free();
                    m_bDecommitInProgress = FALSE;
                    bRelease = TRUE;
                }
            }

            if (m_pNotify) {
                m_pNotify->NotifyRelease();
            }
            // For each buffer there is one AddRef, made in GetBuffer and released
            // here. This may cause the allocator and all samples to be deleted
            if (bRelease)
            {
                Release();
            }
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::ReleaseBuffer")));
    return hr;
}

// allocate memory for the sample
HRESULT COMInputAllocator::Alloc()
{
    HRESULT hr = NOERROR;
    CDDrawMediaSample **ppSampleList = NULL;
    DWORD i;
    LONG lToAllocate;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::Alloc")));

    // call the base class
    hr = CBaseAllocator::Alloc();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::Alloc() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // allocate memory for pointers

    lToAllocate = (m_pPin->m_RenderTransport == AM_OVERLAY  &&
                   m_pPin->m_dwBackBufferCount > 1 &&
                   !m_pPin->m_bSyncOnFill &&
                   m_pPin->m_bCanOverAllocateBuffers) ?
             m_lCount + 1 : m_lCount;

    // allocate memory for an array of pointers
    ppSampleList = new CDDrawMediaSample *[lToAllocate];
    if (!ppSampleList)
    {
        DbgLog((LOG_ERROR, 1, TEXT("new BYTE[m_lCount*sizeof(CDDrawMediaSample*)] failed")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    for (i = 0; i < (DWORD)(lToAllocate); i++)
    {
        // Create a new sample
        ppSampleList[i] = new CDDrawMediaSample(NAME("Sample"), this, (HRESULT *) &hr, NULL, (LONG) 0,
                                       DDKERNELCAPS_LOCK & m_pPin->m_pFilter->KernelCaps() ?
                                       true : false);

        //  REVIEW - actually hr can't be a failure
        //  so we don't need to delete ppSampleList[i] here
        if (FAILED(hr) || ppSampleList[i] == NULL)
        {
            if (SUCCEEDED(hr))
                hr = E_OUTOFMEMORY;
            DbgLog((LOG_ERROR, 1, TEXT("new CDDrawMediaSample failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // this cannot fail
        m_lFree.Add(ppSampleList[i]);
        m_lAllocated++;
    }

    ASSERT(m_lAllocated == lToAllocate);

    // tell the pin
    hr = m_pPin->OnAlloc(ppSampleList, lToAllocate);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pPin->OnAlloc(), hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    delete[] ppSampleList;
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::Alloc")));
    return hr;
}

void COMInputAllocator::Free(void)
{
    CDDrawMediaSample *pSample;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::Free")));

    /* Should never be deleting this unless all buffers are freed */
    //  REVIEW - might not be true if we failed to allocate a sample
    ASSERT(m_lAllocated == m_lFree.GetCount());

    /* Free up all the CMediaSamples */

    for (;;)
    {
        pSample = (CDDrawMediaSample *) m_lFree.RemoveHead();
        if (pSample != NULL)
        {
            delete pSample;
        }
        else
        {
            break;
        }
    }

    m_lAllocated = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::Free")));
    return;
}


// function used to implement IDirectDrawMediaSampleAllocator.
// used to give a handle to the ddraw object used to allocate surfaces
STDMETHODIMP COMInputAllocator::GetDirectDraw(IDirectDraw **ppDirectDraw)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputAllocator::GetDirectDraw")));

    if (!ppDirectDraw)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of ppDirectDraw is invalid, ppDirectDraw = NULL")));
        hr = E_POINTER;
        goto CleanUp;

    }

    {
        //  REVIEW - why is the allocator locked - to protect m_pPin?
        //  bug m_pPin is not AddRef'd by us so in theory could go away
        //  anyway - better to addref if this is necessary
        //  who typically has a pointer to this object
        CAutoLock cAllocatorLock(this);
        *ppDirectDraw = m_pPin->GetDirectDraw();
        ASSERT(*ppDirectDraw);
    }


CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputAllocator::GetDirectDraw")));
    return hr;
}

/////////////////////////////////////
// CLASS COMInputPin implemented here
/////////////////////////////////////

// constructor
COMInputPin::COMInputPin(TCHAR *pObjectName, COMFilter *pFilter, CCritSec *pLock, BOOL bCreateVPObject, HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo)
: CBaseInputPin(pObjectName, pFilter, pLock, phr, pPinName)
{
    HRESULT hr = NOERROR;
    LPUNKNOWN pUnkOuter;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Constructor")));

    m_cOurRef = 0;
    m_pFilterLock = pLock;
    m_dwPinId = dwPinNo;
    m_pFilter = pFilter;

    m_bVPSupported = FALSE;
    m_pIVPUnknown = NULL;
    m_pIVPObject = NULL;

    m_bIOverlaySupported = FALSE;
    m_pIOverlayNotify = NULL;
    m_dwAdviseNotify = ADVISE_NONE;

    m_pSyncObj = NULL;

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
    m_CategoryGUID = GUID_NULL;
    m_Communication = KSPIN_COMMUNICATION_SOURCE;
    m_bStreamingInKernelMode = FALSE;
    m_OvMixerOwner = AM_OvMixerOwner_Unknown;

    m_pDirectDrawSurface = NULL;
    m_pBackBuffer = NULL;
    m_RenderTransport = AM_OFFSCREEN;
    m_dwBackBufferCount = 0;
    m_dwDirectDrawSurfaceWidth = 0;
    m_dwMinCKStretchFactor = 0;
    m_bOverlayHidden = TRUE;
    m_bSyncOnFill = FALSE;
    m_bDontFlip = FALSE ;
    m_bDynamicFormatNeeded = TRUE;
    m_bNewPaletteSet = TRUE;
    m_dwUpdateOverlayFlags = 0;
    m_dwInterlaceFlags = 0;
    m_dwFlipFlag = 0;
    m_bConnected = FALSE;
    m_bUsingOurAllocator = FALSE;
    m_hMemoryDC = NULL;
    m_bCanOverAllocateBuffers = TRUE;
    m_hEndOfStream = NULL;
    m_UpdateOverlayNeededAfterReceiveConnection = false;
    SetReconnectWhenActive(true);

    if (m_dwPinId == 0) {
        m_StepEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }
    else {
        m_StepEvent = NULL;
    }

    // -ve == normal playback
    // +ve == frames to skips
    //  0 == time to block
    m_lFramesToStep = -1;

#ifdef PERF
    m_PerfFrameFlipped = MSR_REGISTER(TEXT("Frame Drawn"));
    m_FrameReceived = MSR_REGISTER(TEXT("Sample Received"));
#endif


    // Set up buffer management stuff for WindowLess renderer
    ZeroMemory(&m_BackingDib, sizeof(m_BackingDib));
    m_BackingImageSize = 0L;

    memset(&m_WinInfo, 0, sizeof(WININFO));
    m_WinInfo.hClipRgn = CreateRectRgn(0, 0, 0, 0);

    if (m_dwPinId == 0)
        SetRect(&m_rRelPos, 0, 0, MAX_REL_NUM, MAX_REL_NUM);
    else
        SetRect(&m_rRelPos, 0, 0, 0, 0);


    // initialize with values such that using them before they are set
    // will cause bad things to happen
    m_dwZOrder = 0;
    m_dwInternalZOrder = (m_dwZOrder << 24) | m_dwPinId;
    m_dwBlendingParameter = MAX_BLEND_VAL;
    m_bStreamTransparent = FALSE;
    m_amAspectRatioMode = (m_dwPinId == 0) ? (AM_ARMODE_LETTER_BOX) : (AM_ARMODE_STRETCHED);
    m_bRuntimeNegotiationFailed = FALSE;

    m_bVideoAcceleratorSupported = FALSE;
    m_dwCompSurfTypes = 0;
    m_pCompSurfInfo = NULL;
    m_pIDDVAContainer = NULL;
    m_pIDDVideoAccelerator = NULL;
    m_pIVANotify = NULL;

    m_bDecimating = FALSE;
    m_lWidth = m_lHeight = 0L;

    if (bCreateVPObject)
    {
        // artifically increase the refcount since the following sequence might end up calling Release()
#ifdef DEBUG
        m_cRef++;
#endif
        m_cOurRef++;

        // this is the block we are trying to make safe by pumping up the ref-count
        {
            pUnkOuter = GetOwner();

            // create the VideoPort object
            hr = CoCreateInstance(CLSID_VPObject, pUnkOuter, CLSCTX_INPROC_SERVER,
                IID_IUnknown, (void**)&m_pIVPUnknown);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CoCreateInstance(CLSID_VPObject) failed, hr = 0x%x"), hr));
                goto CleanUp;
            }

            // if you are QIing the inner object then you must decrease the refcount of your outer unknown
            hr = m_pIVPUnknown->QueryInterface(IID_IVPObject, (void**)&m_pIVPObject);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->QueryInterface(IID_IVPObject) failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            Release();

            hr = m_pIVPObject->SetObjectLock(m_pFilterLock);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->SetObjectLock() failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }

        // restore the refcount
#ifdef DEBUG
        m_cRef--;
#endif
        m_cOurRef--;
    }

    m_pSyncObj = new CAMSyncObj(this, &m_pFilter->m_pClock, m_pFilterLock, &hr);
    if (!m_pSyncObj || FAILED(hr))
    {
        if (!FAILED(hr))
            hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 1, TEXT("new CAMSyncObj failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    if (FAILED(hr))
    {
        *phr = hr;
    }
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Constructor")));
    return;
}

// destructor
COMInputPin::~COMInputPin(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Destructor")));

    CAutoLock cLock(m_pFilterLock);

    if (m_pIVPObject)
    {
        LPUNKNOWN  pUnkOuter = GetOwner();
        ASSERT(pUnkOuter);

        // call addref on yourselves before calling the inner object's release
        pUnkOuter->AddRef();
        m_pIVPObject->Release();
        m_pIVPObject = NULL;
    }

    // release the inner object
    if (m_pIVPUnknown)
    {
        m_pIVPUnknown->Release();
        m_pIVPUnknown = NULL;
    }

    if (m_pSyncObj)
    {
        delete m_pSyncObj;
        m_pSyncObj = NULL;
    }

    if (m_WinInfo.hClipRgn)
    {
        DeleteObject(m_WinInfo.hClipRgn);
        m_WinInfo.hClipRgn = NULL;
    }

    if (m_dwPinId == 0 && m_StepEvent != NULL) {
        CloseHandle(m_StepEvent);
    }

    DeleteDIB(&m_BackingDib);

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Destructor")));
}

// overriden to expose IMediaPosition and IMediaSeeking control interfaces
STDMETHODIMP COMInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::NonDelegatingQueryInterface")));

    CAutoLock cLock(m_pFilterLock);

    if (riid == IID_IVPControl)
    {
        hr = GetInterface((IVPControl*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("GetInterface((IVPControl*)this, ppv)  failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (m_pIVPUnknown &&
         (riid == IID_IVPNotify || riid == IID_IVPNotify2 || riid == IID_IVPInfo))
    {
        hr = m_pIVPUnknown->QueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->QueryInterface failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IKsPin)
    {
        hr = GetInterface((IKsPin *)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IKsPin*) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IKsPropertySet)
    {
        hr = GetInterface((IKsPropertySet *)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IKsPropertySet*) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IMixerPinConfig)
    {
        hr = GetInterface((IMixerPinConfig*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface((IMixerPinConfig*)this, ppv) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IMixerPinConfig2)
    {
        hr = GetInterface((IMixerPinConfig2*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface((IMixerPinConfig2*)this, ppv) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IMixerPinConfig3)
    {
        hr = GetInterface((IMixerPinConfig3*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface((IMixerPinConfig3*)this, ppv) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IOverlay)
    {
        hr = GetInterface((IOverlay*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface((IOverlay*)this, ppv) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IPinConnection)
    {
        hr = GetInterface((IPinConnection*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface((IPinConnection*)this, ppv) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (riid == IID_IAMVideoAccelerator &&
            0 != GetRegistryDword(HKEY_LOCAL_MACHINE, szVideoAcc, 1) &&
            m_pFilter &&
            !m_pFilter->IsFaultyMMaticsMoComp() )
    {
        hr = GetInterface((IAMVideoAccelerator*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface((IAMVideoAccelerator*)this, ppv) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    else if (riid == IID_ISpecifyPropertyPages&& 0 != GetRegistryDword(HKEY_CURRENT_USER , szPropPage, 0)) {
        return GetInterface((ISpecifyPropertyPages *)this, ppv);
    }

    else
    {
        // call the base class
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::NonDelegatingQueryInterface")));
    return hr;
}

//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on our input pin. The base class CBasePin does not do any reference
// counting on the pin in RETAIL.
//
// Please refer to the comments for the NonDelegatingRelease method for more
// info on why we need to do this.
//
STDMETHODIMP_(ULONG) COMInputPin::NonDelegatingAddRef(void)
{
#ifdef DEBUG
    // Update the debug only variable maintained by the base class
    InterlockedIncrement(&m_cRef);
    ASSERT(m_cRef > 0);
#endif

    // Now update our reference count
    InterlockedIncrement(&m_cOurRef);
    ASSERT(m_cOurRef > 0);
    return m_pFilter->AddRef();

} // NonDelegatingAddRef


//
// NonDelegatingRelease
//
// CAMVPMemInputPin overrides this class so that we can take the pin out of our
// output pins list and delete it when its reference count drops to 1 and there
// is atleast two free pins.
//
// Note that CreateNextOutputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
// Moreover, the pin that we are about to delete must be a free pin(or else
// the reference would not have dropped to 1, and we must have atleast one
// other free pin(as the filter always wants to have one more free pin)
//
// Also, since CBasePin::NonDelegatingAddRef passes the call to the owning
// filter, we will have to call Release on the owning filter as well.
//
// Also, note that we maintain our own reference count m_cOurRef as the m_cRef
// variable maintained by CBasePin is debug only.
//
STDMETHODIMP_(ULONG) COMInputPin::NonDelegatingRelease(void)
{
#ifdef DEBUG
    // Update the debug only variable in CBasePin
    InterlockedDecrement(&m_cRef);
    ASSERT(m_cRef >= 0);
#endif

    // Now update our reference count
    InterlockedDecrement(&m_cOurRef);
    ASSERT(m_cOurRef >= 0);

    // if the reference count on the object has gone to one, remove
    // the pin from our output pins list and physically delete it
    // provided there are atealst two free pins in the list(including
    // this one)

    // Also, when the ref count drops to 0, it really means that our
    // filter that is holding one ref count has released it so we
    // should delete the pin as well.

    if (m_cOurRef <= 1)
    {
        CAutoLock cLock(m_pFilterLock);

        // default forces pin deletion
        int n = 2;
        // if m_cOurRef is 0, then it means we have released the pin
        // in which case we should always delete the pin.
        if (m_cOurRef == 1)
        {
            // Walk the list of pins, looking for count of free pins
            n = 0;
            for (int i = 0; i < m_pFilter->GetInputPinCount(); i++)
            {
                if (!(m_pFilter->GetPin(i)->IsConnected()))
                {
                    n++;
                }
            }
        }

        // If there are two free pins and this pin is not the primary pin, delete this one.
        if (n >= 2  && !(m_dwPinId == 0))
        {
            DWORD dwFilterRefCount;
            m_cOurRef = 0;
#ifdef DEBUG
            m_cRef = 0;
#endif

            // COM rules say we must protect against re-entrancy.
            // If we are an aggregator and we hold our own interfaces
            // on the aggregatee, the QI for these interfaces will
            // addref ourselves. So after doing the QI we must release
            // a ref count on ourselves. Then, before releasing the
            // private interface, we must addref ourselves. When we do
            // this from the destructor here it will result in the ref
            // count going to 1 and then back to 0 causing us to
            // re-enter the destructor. Hence we add extra refcounts here
            // once we know we will delete the object. Since we delete the
            // pin, when the refcount drops to 1, we make the refcount 2 here
            m_cOurRef = 2;

            dwFilterRefCount = m_pFilter->Release();

            m_pFilter->DeleteInputPin(this);

            return dwFilterRefCount;
        }
    }
    return m_pFilter->Release();

} // NonDelegatingRelease


// --- ISpecifyPropertyPages ---

STDMETHODIMP COMInputPin::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*1);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_COMPinConfigProperties;

    return NOERROR;
}


// this function just tells whether each sample consists of one or two fields
BOOL DisplayingFields(DWORD dwInterlaceFlags)
{
   if ((dwInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
        return TRUE;
    else
        return FALSE;
}

// this function just tells whether each sample consists of one or two fields
HRESULT GetTypeSpecificFlagsFromMediaSample(IMediaSample *pSample, DWORD *pdwTypeSpecificFlags)
{
    HRESULT hr = NOERROR;
    IMediaSample2 *pSample2 = NULL;
    AM_SAMPLE2_PROPERTIES SampleProps;

    /* Check for IMediaSample2 */
    if (SUCCEEDED(pSample->QueryInterface(IID_IMediaSample2, (void **)&pSample2)))
    {
        hr = pSample2->GetProperties(sizeof(SampleProps), (PBYTE)&SampleProps);
        pSample2->Release();
        if (FAILED(hr))
        {
            return hr;
        }
        *pdwTypeSpecificFlags = SampleProps.dwTypeSpecificFlags;
    }
    else
    {
        *pdwTypeSpecificFlags = 0;
    }
    return hr;
}

BOOL CheckTypeSpecificFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags)
{
    // first determine which field do we want to display here
    if ((dwInterlaceFlags & AMINTERLACE_1FieldPerSample) &&
        ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_INTERLEAVED_FRAME))
    {
        return FALSE;
    }

    if ((!(dwInterlaceFlags & AMINTERLACE_1FieldPerSample)) &&
        (((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1) ||
           ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD2)))
    {
        return FALSE;
    }

    if (dwTypeSpecificFlags & AM_VIDEO_FLAG_REPEAT_FIELD)
    {
        return FALSE;
    }

    return TRUE;
}

// given the interlace flags and the type-specific flags, this function determines whether we
// are supposed to display the sample in bob-mode or not. It also tells us, which direct-draw flag
// are we supposed to use when flipping. When displaying an interleaved frame, it assumes we are
// talking about the field which is supposed to be displayed first.
BOOL NeedToFlipOddEven(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags, DWORD *pdwFlipFlag)
{
    BOOL bDisplayField1 = TRUE;
    BOOL bField1IsOdd = TRUE;
    BOOL bNeedToFlipOddEven = FALSE;
    DWORD dwFlipFlag = 0;

    // if not interlaced content, mode is not bob
    if (!(dwInterlaceFlags & AMINTERLACE_IsInterlaced))
    {
        bNeedToFlipOddEven = FALSE;
        goto CleanUp;
    }

    // if sample have a single field, then check the field pattern
    if ((dwInterlaceFlags & AMINTERLACE_1FieldPerSample) &&
        (((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField1Only) ||
         ((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField2Only)))
    {
        bNeedToFlipOddEven = FALSE;
        goto CleanUp;
    }

    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOnly) ||
        (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOrWeave) &&
         (!(dwTypeSpecificFlags & AM_VIDEO_FLAG_WEAVE))))
    {
        // first determine which field do we want to display here
        if (dwInterlaceFlags & AMINTERLACE_1FieldPerSample)
        {
            // if we are in 1FieldPerSample mode, check which field is it
            ASSERT(((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1) ||
                ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD2));
            bDisplayField1 = ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1);
        }
        else
        {
            // ok the sample is an interleaved frame
            ASSERT((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_INTERLEAVED_FRAME);
            bDisplayField1 = (dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD1FIRST);
        }

        bField1IsOdd = (dwInterlaceFlags & AMINTERLACE_Field1First);

        // if we displaying field 1 and field 1 is odd or we are displaying field2 and field 2 is odd
        // then use DDFLIP_ODD. Exactly the opposite for DDFLIP_EVEN
        if ((bDisplayField1 && bField1IsOdd) || (!bDisplayField1 && !bField1IsOdd))
            dwFlipFlag = DDFLIP_ODD;
        else
            dwFlipFlag = DDFLIP_EVEN;

        bNeedToFlipOddEven = TRUE;
        goto CleanUp;
    }

CleanUp:
    if (pdwFlipFlag)
        *pdwFlipFlag = dwFlipFlag;
    return bNeedToFlipOddEven;
}

// given the interlace flags and the type-specific flags, this function determines whether we
// are supposed to display the sample in bob-mode or not. It also tells us, which direct-draw flag
// are we supposed to use when flipping. When displaying an interleaved frame, it assumes we are
// talking about the field which is supposed to be displayed first.
DWORD GetUpdateOverlayFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags)
{
    DWORD dwFlags = DDOVER_SHOW | DDOVER_KEYDEST;
    DWORD dwFlipFlag;

    if (NeedToFlipOddEven(dwInterlaceFlags, dwTypeSpecificFlags, &dwFlipFlag))
    {
        dwFlags |= DDOVER_BOB;
        if (!DisplayingFields(dwInterlaceFlags))
            dwFlags |= DDOVER_INTERLEAVED;
    }
    return dwFlags;
}

// this function checks if the InterlaceFlags are suitable or not
HRESULT COMInputPin::CheckInterlaceFlags(DWORD dwInterlaceFlags)
{
    HRESULT hr = NOERROR;


    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::CheckInterlaceFlags")));

    CAutoLock cLock(m_pFilterLock);

    if (dwInterlaceFlags & AMINTERLACE_UNUSED)
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // check that the display mode is one of the three allowed values
    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOnly) &&
        ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeWeaveOnly) &&
        ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOrWeave))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // if content is not interlaced, other bits are irrelavant, so we are done
    if (!(dwInterlaceFlags & AMINTERLACE_IsInterlaced))
    {
        goto CleanUp;
    }

    // samples are frames, not fields (so we can handle any display mode)
    if (!(dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
    {
        goto CleanUp;
    }

    // can handle a stream of just field1 or field2, whatever the display mode
    if (((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField1Only) ||
        ((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField2Only))
    {
        goto CleanUp;
    }

    // can handle only bob-mode for field samples
    if ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOnly)
    {
        goto CleanUp;
    }

    // cannot handle only Weave mode or BobOrWeave mode for field samples
    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeWeaveOnly) ||
         ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOrWeave))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // we should have covered all possible scenarios by now, so assert here
    ASSERT(1);

CleanUp:

    // we cannot handle bob mode with an offscreen surface or if the driver can't support it
    if (SUCCEEDED(hr))
    {
        LPDDCAPS pDirectCaps = m_pFilter->GetHardwareCaps();
        if ( pDirectCaps )
        {
            // call NeedToFlipOddEven with dwTypeSpecificFlags=0, to pretend that the
            // type-specific-flags is asking us to do bob-mode.
            if (((m_RenderTransport != AM_OVERLAY && m_RenderTransport != AM_VIDEOACCELERATOR) ||
                 (!((pDirectCaps->dwCaps2) & DDCAPS2_CANFLIPODDEVEN))) &&
                (NeedToFlipOddEven(dwInterlaceFlags, 0, NULL)))
            {
                hr = VFW_E_TYPE_NOT_ACCEPTED;
            }
        }
    }
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::CheckInterlaceFlags")));
    return hr;
}

// this function check if the mediatype on a dynamic format change is suitable.
// No lock is taken here. It is the callee's responsibility to maintain integrity!
HRESULT COMInputPin::DynamicCheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    BITMAPINFOHEADER *pNewHeader = NULL, *pOldHeader = NULL;
    DWORD dwOldInterlaceFlags = 0, dwNewInterlaceFlags = 0, dwCompareSize = 0;
    BOOL bOld1FieldPerSample = FALSE, bNew1FieldPerSample = FALSE;
    BOOL b1, b2;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::DynamicCheckMediaType")));

    // majortype and SubType are not allowed to change dynamically,
    // format type can change.
    if ((!(IsEqualGUID(pmt->majortype, m_mtNew.majortype))) ||
        (!(IsEqualGUID(pmt->subtype, m_mtNew.subtype))))
    {
        goto CleanUp;
    }

    // get the interlace flags of the new mediatype
    hr = GetInterlaceFlagsFromMediaType(pmt, &dwNewInterlaceFlags);
    if (FAILED(hr))
    {
        goto CleanUp;
    }

    // get the interlace flags of the new mediatype
    hr = GetInterlaceFlagsFromMediaType(&m_mtNew, &dwOldInterlaceFlags);
    if (FAILED(hr))
    {
        goto CleanUp;
    }

    //
    // There are several bugs in the following code !!
    // We goto CleanUp but hr has not been updated with a valid error code!!
    //

    bOld1FieldPerSample = (dwOldInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwOldInterlaceFlags & AMINTERLACE_1FieldPerSample);
    bNew1FieldPerSample = (dwNewInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwNewInterlaceFlags & AMINTERLACE_1FieldPerSample);


    // we do not allow dynamic format changes where you go from 1FieldsPerSample to
    // 2FieldsPerSample or vica-versa since that means reallocating the surfaces.
    if (bNew1FieldPerSample != bOld1FieldPerSample)
    {
        goto CleanUp;
    }

    pNewHeader = GetbmiHeader(pmt);
    if (!pNewHeader)
    {
        goto CleanUp;
    }

    pOldHeader = GetbmiHeader(&m_mtNew);
    if (!pNewHeader)
    {
        goto CleanUp;
    }

    dwCompareSize = FIELD_OFFSET(BITMAPINFOHEADER, biClrUsed);
    ASSERT(dwCompareSize < sizeof(BITMAPINFOHEADER));

    if (memcmp(pNewHeader, pOldHeader, dwCompareSize) != 0)
    {
        goto CleanUp;
    }

    hr = NOERROR;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::DynamicCheckMediaType")));
    return hr;
}


// check that the mediatype is acceptable. No lock is taken here. It is the callee's
// responsibility to maintain integrity!
HRESULT COMInputPin::CheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;
    BOOL bAcceptableVPMediatype = FALSE, bAcceptableNonVPMediatype = FALSE;
    BITMAPINFOHEADER *pHeader = NULL;
    VIDEOINFOHEADER2 *pVideoInfoHeader2 = NULL;
    RECT rTempRect;
    DWORD dwInterlaceFlags;
    LPDDCAPS pDirectCaps = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::CheckMediaType")));

    if (m_RenderTransport == AM_OVERLAY ||
        m_RenderTransport == AM_OFFSCREEN ||
        m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        pDirectCaps = m_pFilter->GetHardwareCaps();
        if (!pDirectCaps)
        {
            DbgLog((LOG_ERROR, 2, TEXT("no ddraw support, so not accepting this mediatype")));
            hr = VFW_E_TYPE_NOT_ACCEPTED;
            goto CleanUp;
        }
    }

    // check if the VP component likes this mediatype
    if (m_bVPSupported)
    {
        // check if the videoport object likes it
        hr = m_pIVPObject->CheckMediaType(pmt);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("m_pIVPObject->CheckMediaType failed, hr = 0x%x"), hr));
        }
        else
        {
            bAcceptableVPMediatype = TRUE;
            DbgLog((LOG_TRACE, 2, TEXT("m_pIVPObject->CheckMediaType succeeded, bAcceptableVPMediatype is TRUE")));
            goto CleanUp;
        }
    }

    // if subtype is overlay make sure we support IOverlay
    if (!m_bIOverlaySupported && pmt->subtype == MEDIASUBTYPE_Overlay)
    {
        DbgLog((LOG_TRACE, 2, TEXT("m_pIVPObject->CheckMediaType failed, Subtype = MEDIASUBTYPE_Overlay, however pin does not support IOverlay")));
        goto CleanUp;
    }

    // here we check if the header is ok, either by matching it with the connection mediatype
    // or examinining each field
    if (m_bConnected)
    {
        hr = DynamicCheckMediaType(pmt);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("DynamicCheckMediaType(const CMediaType* pmt) failed, hr = 0x%x"), hr));
            goto CleanUp;

        }
    }
    else
    {
        // make sure that the major type is appropriate
        if (pmt->majortype != MEDIATYPE_Video)
        {
            DbgLog((LOG_ERROR, 2, TEXT("pmt->majortype != MEDIATYPE_Video")));
            goto CleanUp;
        }

        if (MEDIASUBTYPE_HASALPHA(*pmt)) {

            DbgLog((LOG_ERROR, 1,
                    TEXT("CheckMediaType failed on Pin %d: Alpha formats ")
                    TEXT("not allowed by the OVMixer"), m_dwPinId));
            goto CleanUp;
        }

        pHeader = GetbmiHeader(pmt);
        if (!pHeader)
        {
            DbgLog((LOG_ERROR, 2, TEXT("pHeader is NULL")));
            goto CleanUp;
        }

        // make sure that the format type is appropriate
        if ((*pmt->FormatType() != FORMAT_VideoInfo || m_pFilter->OnlySupportVideoInfo2()) &&
            (*pmt->FormatType() != FORMAT_VideoInfo2))
        {
            DbgLog((LOG_ERROR, 2, TEXT("FormatType() != FORMAT_VideoInfo && FormatType() != FORMAT_VideoInfo2")));
            goto CleanUp;
        }

        // if the subtype is Overlay then we are not going to create any surfaces, therefore
        // we can skip these checks
        if (pmt->subtype != MEDIASUBTYPE_Overlay)
        {
            if (m_RenderTransport != AM_GDI && !IsSuitableVideoAcceleratorGuid(&pmt->subtype))
            {
                // Don't accept 4CC not supported by the driver
                if (pHeader->biCompression > BI_BITFIELDS)
                {
                    IDirectDraw *pDDraw = m_pFilter->GetDirectDraw();

                    //
                    // Only check the MoComp surface against the listed
                    // FOURCC's if the driver actually supports the
                    // MoComp interfaces.  This is because some drivers
                    // have hidden FOURCC surfaces that they don't report
                    // via calls to GetFourCCCodes.  This basically a
                    // hack for backward compatibility
                    //

                    if (pDDraw != NULL && m_pIDDVAContainer != NULL) {

                        DWORD dwCodes;
                        BOOL bFound = FALSE;
                        if (SUCCEEDED(pDDraw->GetFourCCCodes(&dwCodes, NULL))) {
                            LPDWORD pdwCodes = (LPDWORD)_alloca(dwCodes * sizeof(DWORD));
                            if (SUCCEEDED(pDDraw->GetFourCCCodes(&dwCodes, pdwCodes))) {
                                while (dwCodes--) {
                                    if (pdwCodes[dwCodes] == pHeader->biCompression) {
                                        bFound = TRUE;
                                        break;
                                    }
                                }
                                if (!bFound) {
                                    DbgLog((LOG_TRACE, 2, TEXT("4CC(%4.4s) not supported by driver"),
                                            &pHeader->biCompression));
                                    hr = VFW_E_TYPE_NOT_ACCEPTED;
                                    goto CleanUp;
                                }
                            }
                        }
                    }
                }
            }

            if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_VIDEOACCELERATOR)
            {
                FOURCCMap amFourCCMap(pmt->Subtype());

                ASSERT(pDirectCaps);
                if (!(pDirectCaps->dwCaps & DDCAPS_OVERLAY))
                {
                    DbgLog((LOG_ERROR, 2, TEXT("no overlay support in hardware, so not accepting this mediatype")));
                    goto CleanUp;
                }

#if 0
                //
                // This test below looks completely bogus for both AM_OVERLAY
                // and AM_VIDEOACCELERATOR render transports.  I'll remove it for now
                // see what breaks or starts working !!
                //
                // StEstrop 5th Feb 99.
                //

                // for the overlay surface case, we accept both RGB and YUV surfaces
                if ((pHeader->biCompression <= BI_BITFIELDS &&
                     m_pFilter->GetDisplay()->GetDisplayDepth() > pHeader->biBitCount) ||
                    (pHeader->biCompression > BI_BITFIELDS &&
                     pHeader->biCompression != amFourCCMap.GetFOURCC()))
                {
                    DbgLog((LOG_ERROR, 2, "Bit depth not suitable"));
                    goto CleanUp;
                }
#endif

            }
            else if (m_RenderTransport == AM_OFFSCREEN)
            {
                // since we create offscreen surfaces in system memory and ddraw cannot emulate
                // YUV to RGB conversion, we only accept RGB mediatypes in this scenario
                if (pHeader->biCompression > BI_BITFIELDS ||
                    m_pFilter->GetDisplay()->GetDisplayDepth() != pHeader->biBitCount)
                {
                    DbgLog((LOG_ERROR, 2, TEXT("Bit depth not suitable for RGB surfaces")));
                    goto CleanUp;
                }
            }
            else if (m_RenderTransport == AM_GDI)
            {
                hr = m_pFilter->GetDisplay()->CheckMediaType(pmt);
                if (FAILED(hr))
                {
                    goto CleanUp;
                }
            }
        }
    }

    // make sure the rcSource field is valid
    hr = GetSrcRectFromMediaType(pmt, &rTempRect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2, TEXT("GetSrcRectFromMediaType(&pmt, &rSrcRect) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // make sure the rcTarget field is valid
    hr = GetDestRectFromMediaType(pmt, &rTempRect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2, TEXT("GetDestRectFromMediaType(&pmt, &rSrcRect) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (*pmt->FormatType() == FORMAT_VideoInfo2)
    {
        pVideoInfoHeader2 = (VIDEOINFOHEADER2*)(pmt->pbFormat);

        dwInterlaceFlags = pVideoInfoHeader2->dwInterlaceFlags;

        hr = CheckInterlaceFlags(dwInterlaceFlags);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("CheckInterlaceFlags(dwInterlaceFlags) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        // make sure the reserved fields are zero
        if (pVideoInfoHeader2->dwReserved1 != 0 ||
            pVideoInfoHeader2->dwReserved2 != 0)
        {
            DbgLog((LOG_ERROR, 2, TEXT("Format VideoInfoHeader2, reserved fields not validpmt, &rSrcRect) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    // if we have so far things shoud be fine
    bAcceptableNonVPMediatype = TRUE;

//#define CHECK_REGISTRY
#ifdef CHECK_REGISTRY
    {
        HKEY hKey;
        CHAR szFourCC[5];
        if (pHeader->biCompression != BI_RGB &&
            pHeader->biCompression != BI_BITFIELDS &&
            !RegOpenKeyEx(HKEY_CURRENT_USER,
                          TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\Overlay Mixer"),
                          0,
                          KEY_QUERY_VALUE,
                          &hKey))
        {
            *(DWORD *)szFourCC = pHeader->biCompression;
            szFourCC[4] = '\0';
            DWORD dwType;
            DWORD dwValue;
            DWORD dwBufferSize = sizeof(dwValue);
            if (!RegQueryValueExA(hKey,
                                  szFourCC,
                                  NULL,
                                  &dwType,
                                  (PBYTE)&dwValue,
                                  &dwBufferSize))
            {
               if (dwValue == 0)
               {
                   DbgLog((LOG_ERROR, 1, TEXT("Surface type %hs disabled in registry"), szFourCC));
                   bAcceptableNonVPMediatype = FALSE;
               }
            }
            RegCloseKey(hKey);
        }
    }
#endif // CHECK_REGISTRY

CleanUp:
    if (!bAcceptableVPMediatype && !bAcceptableNonVPMediatype)
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::CheckMediaType")));
    return hr;
}

// called after we have agreed a media type to actually set it
HRESULT COMInputPin::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetMediaType")));

    CAutoLock cLock(m_pFilterLock);

    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    pHeader = GetbmiHeader(pmt);
    if (pHeader)
    {
        // store it in our mediatype as well
        m_mtNew = *pmt;

        // store the interlace flags since we use them again and again
        hr = GetInterlaceFlagsFromMediaType(&m_mtNew, &m_dwInterlaceFlags);
        ASSERT(SUCCEEDED(hr));

        // store the update overlay flags (give the type specific flag is WEAVE so that for BOB or WEAVE
        // mode, we not bob
        m_dwUpdateOverlayFlags = GetUpdateOverlayFlags(m_dwInterlaceFlags, AM_VIDEO_FLAG_WEAVE);
    }

    // Set the base class media type (should always succeed)
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // check if this is videoport or an IOverlay connection
    if (m_bVPSupported)
    {
        hr = m_pIVPObject->CheckMediaType(pmt);
        if (SUCCEEDED(hr))
        {
            ASSERT(m_bVPSupported);
            m_RenderTransport = AM_VIDEOPORT;
            m_pFilter->SetDecimationUsage(DECIMATION_LEGACY);
            hr = m_pIVPObject->SetMediaType(pmt);
            ASSERT(SUCCEEDED(hr));
            DbgLog((LOG_TRACE, 2, TEXT("m_RenderTransport is AM_VIDEOPORT")));
        }
        hr = NOERROR;
    }

    if (m_bIOverlaySupported && pmt->subtype == MEDIASUBTYPE_Overlay)
    {
        m_RenderTransport = AM_IOVERLAY;
        DbgLog((LOG_TRACE, 2, TEXT("m_bIOverlaySupported is TRUE")));
    }

    if (m_bVideoAcceleratorSupported && IsSuitableVideoAcceleratorGuid((LPGUID)&pmt->subtype))
    {
        if (m_pIVANotify == NULL) {
            // get the IHWVideoAcceleratorNotify interface from the input pin
            hr = m_Connected->QueryInterface(IID_IAMVideoAcceleratorNotify, (void **)&m_pIVANotify);
        }
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pIVANotify);
            /*  Check if motion comp is really supported */
            m_mtNewAdjusted = m_mtNew;
            m_RenderTransport = AM_VIDEOACCELERATOR;
            m_bSyncOnFill = FALSE;
            DbgLog((LOG_TRACE, 2, TEXT("this is a motion comp connection")));
        }
    }

    // tell the proxy not to allocate buffers if it is a videoport or overlay connection
    if (m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY  || m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        SetStreamingInKernelMode(TRUE);
    }

    // tell the owning filter
    hr = m_pFilter->SetMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }



CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetMediaType")));
    return hr;
}


HRESULT COMInputPin::CurrentAdjustedMediaType(CMediaType *pmt)
{
    ValidateReadWritePtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cLock(m_pFilterLock);

    /*  Copy constructor of m_mt allocates the memory */
    if (IsConnected())
    {
        *pmt = m_mtNewAdjusted;
        return S_OK;
    } else
    {
        pmt->InitMediaType();
        return VFW_E_NOT_CONNECTED;
    }
}

HRESULT COMInputPin::CopyAndAdjustMediaType(CMediaType *pmtTarget, CMediaType *pmtSource)
{
    BITMAPINFOHEADER *pHeader = NULL;

    ValidateReadWritePtr(pmtTarget,sizeof(AM_MEDIA_TYPE));
    ValidateReadWritePtr(pmtSource,sizeof(AM_MEDIA_TYPE));

    *pmtTarget = *pmtSource;

    if (m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY || m_RenderTransport == AM_GDI
        || m_RenderTransport == AM_VIDEOACCELERATOR)
        return NOERROR;

    ASSERT(m_dwDirectDrawSurfaceWidth);
    ASSERT(IsConnected());
    pHeader = GetbmiHeader(pmtTarget);
    if ( pHeader )
        pHeader->biWidth = (LONG)m_dwDirectDrawSurfaceWidth;

    return NOERROR;
}

#ifdef DEBUG
/*****************************Private*Routine******************************\
* VideoFormat2String
*
* Converts a video format block to a string - useful for debugging
*
* History:
* Tue 12/07/1999 - StEstrop - Created
*
\**************************************************************************/
void VideoFormat2String(
    LPTSTR szBuffer,
    const GUID* pFormatType,
    BYTE* pFormat,
    ULONG lFormatLength
    )
{
    if (!pFormat) {
        lstrcpy(szBuffer, TEXT("No format data specified"));
    }

    //
    // Video Format
    //
    if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo) ||
        IsEqualGUID(*pFormatType, FORMAT_MPEGVideo)) {

        VIDEOINFO * pVideoFormat = (VIDEOINFO *) pFormat;

        wsprintf(szBuffer, TEXT("%4.4hs %dx%d, %d bits"),
                 (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB " :
                 ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                 (LPSTR) &pVideoFormat->bmiHeader.biCompression),
                 pVideoFormat->bmiHeader.biWidth,
                 pVideoFormat->bmiHeader.biHeight,
                 pVideoFormat->bmiHeader.biBitCount);
    }
    else if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo2) ||
             IsEqualGUID(*pFormatType, FORMAT_MPEG2Video)) {

        VIDEOINFOHEADER2 * pVideoFormat = (VIDEOINFOHEADER2 *) pFormat;

        wsprintf(szBuffer, TEXT("%4.4hs %dx%d, %d bits"),
                 (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB " :
                 ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                 (LPSTR) &pVideoFormat->bmiHeader.biCompression ),
                 pVideoFormat->bmiHeader.biWidth,
                 pVideoFormat->bmiHeader.biHeight,
                 pVideoFormat->bmiHeader.biBitCount);

    }
    else {
        lstrcpy(szBuffer, TEXT("Unknown format"));
    }
}
#endif
// pConnector is the initiating connecting pin
// pmt is the media type we will exchange
// This function is also called while the graph is running when the
// up stream decoder filter wants to change the size of the
// decoded video.
//
// If the up stream decoder wants to change from one transport
// type to another, eg. from MoComp back to IMemInputPin then it
// should perform a dynamic filter reconnect via the IGraphConfig
// Reconnect method.
//
STDMETHODIMP COMInputPin::ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = NOERROR;
    COMInputAllocator * pAlloc = NULL;

    CAutoLock cLock(m_pFilterLock);

    CheckPointer(pmt, E_POINTER);
    CMediaType cmt(*pmt);

    if (m_Connected != pConnector || pConnector == NULL)
    {
        hr = CBaseInputPin::ReceiveConnection(pConnector, &cmt);
        goto CleanUp;
    }

#ifdef DEBUG
    DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection when connected")));
    if (pmt)
    {
        TCHAR   szFmt[128];
        VideoFormat2String(szFmt, &pmt->formattype, pmt->pbFormat, pmt->cbFormat);
        DbgLog((LOG_TRACE, 2, TEXT("Format is: %s"), szFmt));
    }
#endif

    //
    // We don't have an allocator when we are using MoComp
    //
    if (m_RenderTransport != AM_VIDEOACCELERATOR)
    {
        /*  Can only do this if the allocator can be reconfigured */
        pAlloc = (COMInputAllocator *)m_pAllocator;
        if (!pAlloc)
        {
            hr = E_FAIL;
            DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: Failed because of no allocator")));
            goto CleanUp;
        }

        if (!pAlloc->CanFree())
        {
            hr = VFW_E_WRONG_STATE;
            DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: Failed because allocator can't free")));
            goto CleanUp;
        }
    }


    m_bConnected = FALSE;

    hr = CheckMediaType(&cmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: CheckMediaType failed")));
        goto CleanUp;
    }

    ALLOCATOR_PROPERTIES Props;
    if (m_RenderTransport != AM_VIDEOACCELERATOR)
    {
        pAlloc->Decommit();
        pAlloc->GetProperties(&Props);

    }
    else {
        VABreakConnect();
    }

    // release the ddraw surface
    if (m_pDirectDrawSurface)
    {
        m_pDirectDrawSurface->Release();
        m_pDirectDrawSurface = NULL;
    }


    // back buffers are not addref'd so just set them to NULL
    m_dwBackBufferCount = 0;
    m_dwDirectDrawSurfaceWidth = 0;
    SetMediaType(&cmt);

    if (m_RenderTransport != AM_VIDEOACCELERATOR)
    {
        ALLOCATOR_PROPERTIES PropsActual;
        Props.cbBuffer = pmt->lSampleSize;
        hr = pAlloc->SetProperties(&Props, &PropsActual);
        if (SUCCEEDED(hr))
        {
            hr = pAlloc->Commit();
        }
        else goto CleanUp;
    }
    else {
        hr = VACompleteConnect(pConnector, &cmt);
        if (FAILED(hr)) goto CleanUp;
    }

    hr = UpdateMediaType();
    ASSERT(SUCCEEDED(hr));

    m_bConnected = TRUE;
    m_UpdateOverlayNeededAfterReceiveConnection = true;


CleanUp:
    return hr;
}

HRESULT COMInputPin::CheckConnect(IPin * pReceivePin)
{
    HRESULT hr = NOERROR;
    PKSMULTIPLE_ITEM pMediumList = NULL;
    IKsPin *pIKsPin = NULL;
    PKSPIN_MEDIUM pMedium = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::CheckConnect")));

    CAutoLock cLock(m_pFilterLock);

    if (m_bVPSupported)
    {
        hr = pReceivePin->QueryInterface(IID_IKsPin, (void **)&pIKsPin);
        if (FAILED(hr))
        {
            goto CleanUp;
        }
        ASSERT(pIKsPin);

        hr = pIKsPin->KsQueryMediums(&pMediumList);
        if (FAILED(hr))
        {
            goto CleanUp;
        }
        ASSERT(pMediumList);
        pMedium = (KSPIN_MEDIUM *)(pMediumList+1);
        SetKsMedium((const KSPIN_MEDIUM *)pMedium);
        goto CleanUp;
    }

CleanUp:

    // call the base class
    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CheckConnect failed, hr = 0x%x"), hr));
    }

    if (pIKsPin)
    {
        pIKsPin->Release();
        pIKsPin = NULL;
    }

    if (pMediumList)
    {
        CoTaskMemFree((void*)pMediumList);
        pMediumList = NULL;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::CheckConnect")));
    return hr;
}

HRESULT COMInputPin::UpdateMediaType()
{
    HRESULT hr = NOERROR;
    long lEventParam1 = 0, lEventParam2 = 0;
    DWORD dwVideoWidth = 0, dwVideoHeight = 0, dwPictAspectRatioX = 0, dwPictAspectRatioY = 0;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::UpdateMediaType")));

    // store m_mtNew in m_mtNewAdjusted with the width of the mediatype adjusted
    CopyAndAdjustMediaType(&m_mtNewAdjusted, &m_mtNew);

    // get the native width and height from the mediatype
    pHeader = GetbmiHeader(&m_mtNewAdjusted);
    ASSERT(pHeader);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_FAIL;
        goto CleanUp;
    }
    dwVideoWidth = abs(pHeader->biWidth);
    dwVideoHeight = abs(pHeader->biHeight);

    // get the picture aspect ratio from the mediatype
    hr = GetPictAspectRatio(&m_mtNewAdjusted, &dwPictAspectRatioX, &dwPictAspectRatioY);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetPictAspectRatio failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }

    // sanity checks
    ASSERT(dwVideoWidth > 0);
    ASSERT(dwVideoHeight > 0);
    ASSERT(dwPictAspectRatioX > 0);
    ASSERT(dwPictAspectRatioY > 0);

    if (m_pFilter->m_pExclModeCallback) {
        m_pFilter->m_pExclModeCallback->OnUpdateSize(dwVideoWidth,
                                                      dwVideoHeight,
                                                      dwPictAspectRatioX,
                                                      dwPictAspectRatioY);
    }


CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::UpdateMediaType")));
    return hr;
}

// final connect
HRESULT COMInputPin::FinalConnect()
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::FinalConnect")));

    if (m_bConnected)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    // update the mediatype, tell the filter about the updated dimensions
    hr = UpdateMediaType();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("UpdateMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the filter (might involve a reconnection with the output pin)
    hr = m_pFilter->CompleteConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if ( m_dwPinId == 0 &&
        (m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY)) {
        m_pFilter->m_fMonitorWarning = TRUE;
    }

    hr = m_pFilter->CreateInputPin(FALSE);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->CreateInputPin failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    m_bConnected = TRUE;

CleanUp:

//  if (SUCCEEDED(hr) && m_mt.pbFormat) {
//      DbgLog((LOG_TRACE, 1, TEXT("Display depth = %d"),
//              ((VIDEOINFOHEADER *)m_mt.pbFormat)->bmiHeader.biBitCount));
//  }
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::FinalConnect")));
    return hr;
}

// Complete Connect
HRESULT COMInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    AMVPDATAINFO amvpDataInfo;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::CompleteConnect")));

    CAutoLock cLock(m_pFilterLock);

    //
    // Do we need to create a DIB back buffer ?
    // We only do this if the transport is AM_GDI and
    // we are "WindowLess"
    //
    if (m_RenderTransport == AM_GDI && m_pFilter->UsingWindowless()) {

        DeleteDIB(&m_BackingDib);

        m_BackingImageSize = 0L;
        BITMAPINFOHEADER *pHeader = GetbmiHeader(&m_mt);

        if (pHeader) {

            m_BackingImageSize = pHeader->biSizeImage;
            hr = CreateDIB(m_BackingImageSize, (BITMAPINFO*)pHeader, &m_BackingDib);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CreateDIB in CompleteConnect failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            ZeroMemory(m_BackingDib.pBase, pHeader->biSizeImage);
        }
    }

    if (m_RenderTransport == AM_VIDEOPORT)
    {
        //get videoport from BPC.

        m_pFilter->m_BPCWrap.TurnBPCOff();

        // tell the videoport object
        hr = m_pIVPObject->CompleteConnect(pReceivePin);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->CompleteConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        m_bRuntimeNegotiationFailed = FALSE;
    }

    // call the base class
    hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    if (m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        // make sure the motion comp complete connect succeeds
        hr = VACompleteConnect(pReceivePin, &m_mt);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("VACompleteConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // tell the sync object
        hr = m_pSyncObj->CompleteConnect(pReceivePin);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->CompleteConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        hr = m_pFilter->CreateInputPin(FALSE);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->CreateInputPin failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // tell the owning filter
        hr = m_pFilter->CompleteConnect(m_dwPinId);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->CompleteConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // call the base class
        hr = CBaseInputPin::CompleteConnect(pReceivePin);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CompleteConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        m_bConnected = TRUE;
    }
    else
    if (m_RenderTransport != AM_VIDEOPORT && m_RenderTransport != AM_IOVERLAY)
    {
        // tell the sync object
        hr = m_pSyncObj->CompleteConnect(pReceivePin);
        ASSERT(SUCCEEDED(hr));

        m_bDynamicFormatNeeded = TRUE;
        m_hMemoryDC = NULL;
    }
    else
    {
        // tell the proxy not to allocate buffers if it is a videoport or overlay connection
        SetStreamingInKernelMode(TRUE);

        hr = FinalConnect();
        ASSERT(SUCCEEDED(hr));
    }

    // the decoders can support a particular property set to tell the ovmixer to not to try to over-allocate
    // buffers incase they want complete control over the buffers etc
    {
        HRESULT hr1 = NOERROR;
        IKsPropertySet *pIKsPropertySet = NULL;
        DWORD dwVal = 0, dwBytesReturned = 0;


        hr1 = pReceivePin->QueryInterface(IID_IKsPropertySet, (void**)&pIKsPropertySet);
        if (SUCCEEDED(hr1))
        {
            ASSERT(pIKsPropertySet);

            if (!pIKsPropertySet)
            {
                DbgLog((LOG_ERROR, 1, TEXT("pIKsPropertySet == NULL, even though QI returned success")));
                goto CleanUp;
            }

            hr1 = pIKsPropertySet->Get(AM_KSPROPSETID_ALLOCATOR_CONTROL, AM_KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,
                        NULL, 0, &dwVal, sizeof(dwVal), &dwBytesReturned);
            DbgLog((LOG_TRACE, 2, TEXT("pIKsPropertySet->Get(AM_KSPROPSETID_ALLOCATOR_CONTROL), hr1 = 0x%x, dwVal == %d, dwBytesReturned == %d"),
                hr1, dwVal, dwBytesReturned));


            // if the decoder supports this property
            // and its value is 1 and the decoder supports DDKERNELCAPS_FLIPOVERLAY,
            // than we will do exactly honour its request and the
            // and not make any attempt to allocate more in order to prevent tearing
            //
            if ((SUCCEEDED(hr1)) && (dwVal == 1) && (dwBytesReturned == sizeof(dwVal)) &&
                (DDKERNELCAPS_FLIPOVERLAY & m_pFilter->KernelCaps()))
            {
                DbgLog((LOG_TRACE, 2, TEXT("setting m_bCanOverAllocateBuffers == FALSE")));
                m_bCanOverAllocateBuffers = FALSE;
            }
            pIKsPropertySet->Release();
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::CompleteConnect")));
    return hr;
}

#if 0
HRESULT COMInputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    if (m_RenderTransport != AM_GDI) {
        return CBaseInputPin::GetMediaType(iPosition, pMediaType);
    }
    if (iPosition != 0) {
        return VFW_S_NO_MORE_ITEMS;
    }
    //  Return the display type
    CImageDisplay Display;

    //  Now create a media type
    if (!pMediaType->SetFormat((BYTE *)Display.GetDisplayFormat(),
                              sizeof(Display.GetDisplayFormat())))
    {
        return E_OUTOFMEMORY;
    }
    pMediaType->SetFormatType(&FORMAT_VideoInfo);
    pMediaType->SetType(&MEDIATYPE_Video);
    pMediaType->subtype = GetBitmapSubtype(&Display.GetDisplayFormat()->bmiHeader);
    return S_OK;
}
#endif

HRESULT COMInputPin::OnSetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr = NOERROR;

    IPin *pReceivePin = NULL;
    DDSURFACEDESC ddSurfaceDesc;
    IEnumMediaTypes *pEnumMediaTypes = NULL;
    CMediaType cMediaType;
    AM_MEDIA_TYPE *pNewMediaType = NULL, *pEnumeratedMediaType = NULL;
    ULONG ulFetched = 0;
    DWORD dwMaxBufferCount = 0;
    BOOL bFoundSuitableSurface = FALSE;
    BITMAPINFOHEADER *pHeader = NULL;
    LPDDCAPS pDirectCaps = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::OnSetProperties")));

    CAutoLock cLock(m_pFilterLock);

    // this function is only called after the base class CBaseAllocator::SetProperties() has been called
    // with the above parameters, so we don't have to do any parameter validation

    ASSERT(IsConnected());
    pReceivePin = CurrentPeer();
    ASSERT(pReceivePin);

    ASSERT(m_RenderTransport != AM_VIDEOPORT && m_RenderTransport != AM_IOVERLAY);
    ASSERT(m_RenderTransport != AM_IOVERLAY);
    ASSERT(m_RenderTransport != AM_VIDEOACCELERATOR);

    // we only care about the number of buffers requested, rest everything is ignored
    if (pRequest->cBuffers <= 0)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN)
    {
        pDirectCaps = m_pFilter->GetHardwareCaps();
        if (!pDirectCaps) {
            hr = E_FAIL;
            goto CleanUp;
        }

        ASSERT(pDirectCaps);

        // if SetProperties is being called when we have already allocated the surfaces, we refuse any
        // requests for change in buffer count
        if (m_pDirectDrawSurface)
        {
            ASSERT(IsConnected());

            // the upstream filters request for multiple buffers is only met, when we are allocating flipping
            // overlay surfaces
            if (m_RenderTransport == AM_OVERLAY)
            {
                pActual->cBuffers = m_dwBackBufferCount + 1 - (m_bCanOverAllocateBuffers ? EXTRA_BUFFERS_TO_FLIP : 0);
                // if triplebuffered or less, it is just one buffer
                if (pActual->cBuffers <= 0)
                    pActual->cBuffers = 1;
            }
            else if (m_RenderTransport == AM_OFFSCREEN)
            {
                pActual->cBuffers = 1;
            }
            goto CleanUp;
        }

        // Find a media type enumerator for the output pin
        hr = pReceivePin->EnumMediaTypes(&pEnumMediaTypes);
        if (FAILED(hr))
        {
            goto CleanUp;
        }

        ASSERT(pEnumMediaTypes);
        pEnumMediaTypes->Reset();

        do
        {
            // in this loop, this is where we CleanUp
            if (m_pDirectDrawSurface)
            {
                m_pDirectDrawSurface->Release();
                m_pDirectDrawSurface = NULL;
            }
            dwMaxBufferCount = 0;
            m_dwBackBufferCount = 0;

            if (pNewMediaType)
            {
                DeleteMediaType(pNewMediaType);
                pNewMediaType = NULL;

            }

            // Get the next media type from the enumerator
            hr = pEnumMediaTypes->Next(1, &pEnumeratedMediaType, &ulFetched);
            if (FAILED(hr) || ulFetched != 1)
            {
                break;
            }

            ASSERT(pEnumeratedMediaType);
            cMediaType = *pEnumeratedMediaType;
            DeleteMediaType(pEnumeratedMediaType);

            // Find a hardware accellerated surface for this media type. We do a few checks first, to see the
            // format block is a VIDEOINFO or VIDEOINFO2 (so it's a video type), and that the format is sufficiently large. We
            // also check that the source filter can actually supply this type.
            if (((*cMediaType.FormatType() == FORMAT_VideoInfo &&
                cMediaType.FormatLength() >= sizeof(VIDEOINFOHEADER)) ||
                (*cMediaType.FormatType() == FORMAT_VideoInfo2 &&
                cMediaType.FormatLength() >= sizeof(VIDEOINFOHEADER2))) &&
                pReceivePin->QueryAccept(&cMediaType) == S_OK)
            {
                LONG lSrcWidth, lSrcHeight;
                LPBITMAPINFOHEADER pbmiHeader;

                if (m_RenderTransport == AM_OVERLAY) {

                    pbmiHeader = GetbmiHeader(&cMediaType);
                    if (!pbmiHeader) {
                        DbgLog((LOG_ERROR, 1, TEXT("MediaType does not have a BitmapInfoHeader attached - try another")));
                        hr = E_FAIL;
                        continue;
                    }

                    lSrcWidth =  pbmiHeader->biWidth;
                    lSrcHeight =  abs(pbmiHeader->biHeight);
                }
                // create ddraw surface
                dwMaxBufferCount = pRequest->cBuffers + (m_bCanOverAllocateBuffers ? EXTRA_BUFFERS_TO_FLIP : 0);
                hr = CreateDDrawSurface(&cMediaType, m_RenderTransport, &dwMaxBufferCount, &m_pDirectDrawSurface);
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 1, TEXT("CreateDDrawSurface failed, hr = 0x%x"), hr));
                    continue;
                }
                else {
                    PaintDDrawSurfaceBlack(m_pDirectDrawSurface);
                }

                // get the surface description
                INITDDSTRUCT(ddSurfaceDesc);
                hr = m_pDirectDrawSurface->GetSurfaceDesc(&ddSurfaceDesc);
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface->GetSurfaceDesc failed, hr = 0x%x"), hr));
                    continue;
                }

                // make a mediatype out of the surface description
                pNewMediaType = ConvertSurfaceDescToMediaType(&ddSurfaceDesc, TRUE, cMediaType);
                if (!pNewMediaType)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("ConvertSurfaceDescToMediaType returned NULL")));
                    continue;
                }

                // store the mediatype (will be used to do a dynamic format change later)
                m_mtNew = *(CMediaType *)pNewMediaType;


                // free the temporary mediatype
                DeleteMediaType(pNewMediaType);
                pNewMediaType = NULL;

                // make sure the decoder likes this new mediatupe
                hr = pReceivePin->QueryAccept(&m_mtNew);
                if (hr != S_OK)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("QueryAccept failed, hr = 0x%x"), hr));
                    continue;
                }

                bFoundSuitableSurface = TRUE;
                if (m_RenderTransport == AM_OVERLAY) {
                    m_lSrcWidth = lSrcWidth;
                    m_lSrcHeight = lSrcHeight;
                }
                break;
            }
        }
        while (TRUE);

        pEnumMediaTypes->Release();

        if (!bFoundSuitableSurface)
        {
            DbgLog((LOG_ERROR, 1, TEXT("Could not create a suitable directdraw surface")));
            hr = E_FAIL;
            goto CleanUp;
        }

        ASSERT(m_pDirectDrawSurface);

        // in the overlay surfaces case, we need to do the synchronize in GetBuffer
        m_bSyncOnFill = (m_RenderTransport == AM_OVERLAY && m_dwBackBufferCount == 0);

        // the upstream filters request for multiple buffers is only met, when we are allocating flipping
        // overlay surfaces
        if (m_RenderTransport == AM_OVERLAY)
        {
            pActual->cBuffers = m_dwBackBufferCount + 1 - (m_bCanOverAllocateBuffers ? EXTRA_BUFFERS_TO_FLIP : 0);
            // if triplebuffered or less, it is just equivalent to one buffer
            if (pActual->cBuffers <= 0)
                pActual->cBuffers = 1;
        }
        else if (m_RenderTransport == AM_OFFSCREEN)
        {
            pActual->cBuffers = 1;
        }

        // this is for those cards which do bilinear-filtering while doing a stretch blt.
        // We do source-colorkeying so that the hal resorts to pixel doubling.
        // SOURCE_COLOR_REF is the colorkey used.
        if ((m_RenderTransport == AM_OFFSCREEN) &&
            ((pDirectCaps->dwSVBFXCaps) & DDFXCAPS_BLTARITHSTRETCHY))
        {
            DDCOLORKEY DDColorKey;
            DWORD dwColorVal = 0;

            dwColorVal = DDColorMatch(m_pDirectDrawSurface, SOURCE_COLOR_REF, hr);
            if (FAILED(hr)) {
                dwColorVal = DDColorMatchOffscreen(m_pFilter->GetDirectDraw(), SOURCE_COLOR_REF, hr);
            }

            DDColorKey.dwColorSpaceLowValue = DDColorKey.dwColorSpaceHighValue = dwColorVal;

            // Tell the primary surface what to expect
            hr = m_pDirectDrawSurface->SetColorKey(DDCKEY_SRCBLT, &DDColorKey);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,1, TEXT("m_pDirectDrawSurface->SetColorKeyDDCKEY_SRCBLT, &DDColorKey) failed")));
                goto CleanUp;
            }
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::AllocateSurfaces")));
    return hr;
}


HRESULT COMInputPin::BreakConnect(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::BreakConnect")));

    CAutoLock cLock(m_pFilterLock);


    if (m_RenderTransport == AM_VIDEOPORT)
    {
        // tell the videoport object
        ASSERT(m_pIVPObject);
        hr = m_pIVPObject->BreakConnect();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->BreakConnect failed, hr = 0x%x"), hr));
        }
    }

    if (m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        // break the motion comp connection
        hr = VABreakConnect();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("VABreakConnect failed, hr = 0x%x"), hr));
        }
    }

    if (m_RenderTransport == AM_IOVERLAY)
    {
        Unadvise();
    }
    else
    {
        // tell the sync object
        hr = m_pSyncObj->BreakConnect();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->BreakConnect failed, hr = 0x%x"), hr));
        }

        // release the ddraw surface
        if (m_pDirectDrawSurface)
        {
            m_pDirectDrawSurface->Release();
            m_pDirectDrawSurface = NULL;
        }

        // back buffers are not addref'd so just set them to NULL
        m_dwBackBufferCount = 0;
        m_dwDirectDrawSurfaceWidth = 0;

    }

    // if it is a videoport or ioverlay connection, set yourself for an overlay
    // connection the next time
    if (m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY || m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        m_RenderTransport = AM_OVERLAY;
    }

    // initialize the behaviour to telling the proxy to allocate buffers
    SetStreamingInKernelMode(FALSE);

    m_bOverlayHidden = TRUE;
    m_bUsingOurAllocator = FALSE;
    m_bCanOverAllocateBuffers = TRUE;

    if (m_hMemoryDC)
    {
        EXECUTE_ASSERT(DeleteDC(m_hMemoryDC));
        m_hMemoryDC = NULL;
    }

    // call the base class
    hr = CBaseInputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::BreakConnect failed, hr = 0x%x"), hr));
    }

    // tell the owning filter
    hr = m_pFilter->BreakConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->BreakConnect failed, hr = 0x%x"), hr));
    }

    const DWORD dwPinBit = (1 << m_dwPinId);
    if (m_pFilter->m_dwDDObjReleaseMask & dwPinBit) {

        m_pFilter->m_dwDDObjReleaseMask &= ~dwPinBit;
        if (!m_pFilter->m_dwDDObjReleaseMask) {
            m_pFilter->m_pOldDDObj->Release();
            m_pFilter->m_pOldDDObj = NULL;
        }
    }
    m_bConnected = FALSE;
//CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::BreakConnect")));
    return hr;
}

STDMETHODIMP COMInputPin::GetState(DWORD dwMSecs,FILTER_STATE *pState)
{
    CAutoLock cLock(m_pFilterLock);

    // if not connected or VideoPort Connection or IOverlay connection, then let the base class handle it
    // otherwise (overlay, offcreen, gdi, motion-comp) let the sync object handle it
    if (!IsConnected() || (m_RenderTransport == AM_VIDEOPORT) || (m_RenderTransport == AM_IOVERLAY))
    {
        return E_NOTIMPL;
    }
    else
    {
        ASSERT(m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR);
        return m_pSyncObj->GetState(dwMSecs, pState);
    }
}

HRESULT COMInputPin::CompleteStateChange(FILTER_STATE OldState)
{
    CAutoLock cLock(m_pFilterLock);
    if (m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY)
        return S_OK;
    else
    {
        ASSERT(m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR);
        return m_pSyncObj->CompleteStateChange(OldState);
    }
}

// transition from stop to pause state
HRESULT COMInputPin::Active(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Active")));

    CAutoLock cLock(m_pFilterLock);
    m_hEndOfStream = NULL;

    if (m_RenderTransport == AM_VIDEOPORT)
    {
        if (m_bOverlayHidden) {
            m_bOverlayHidden = FALSE;
            // tell the videoport object
            hr = m_pIVPObject->Active();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Active failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
    }
    else if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR)

    {
        // tell the sync object
        hr = m_pSyncObj->Active();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->Active failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        ASSERT(m_RenderTransport == AM_IOVERLAY);
        // only when all conections are in place can we be sure that this call
        // will succeed
        NotifyChange(ADVISE_DISPLAY_CHANGE);
    }

    // call the base class
    hr = CBaseInputPin::Active();
    // if it is a VP connection, this error is ok
    if ((m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY || m_RenderTransport == AM_VIDEOACCELERATOR) && hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Active failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Active")));
    return hr;
}

// transition from pause to stop state
HRESULT COMInputPin::Inactive(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Inactive")));

    CAutoLock cLock(m_pFilterLock);

    if (m_RenderTransport == AM_VIDEOPORT)
    {
        // tell the videoport object
        hr = m_pIVPObject->Inactive();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Inactive failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // make sure that if there is a run time error, stop succeeds
        if (m_bRuntimeNegotiationFailed && hr == VFW_E_NOT_CONNECTED)
        {
            hr = NOERROR;
        }
    }
    else if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        // tell the sync object
        hr = m_pSyncObj->Inactive();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->Inactive failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        ASSERT(m_RenderTransport == AM_IOVERLAY);
    }

    // call the base class
    hr = CBaseInputPin::Inactive();

    // if it is a VP connection, this error is ok
    if ((m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY || m_RenderTransport == AM_VIDEOACCELERATOR) && hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Inactive failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Inactive")));
    return hr;
}

// transition from pause to run state
HRESULT COMInputPin::Run(REFERENCE_TIME tStart)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Run")));

    CAutoLock cLock(m_pFilterLock);

    m_bDontFlip = FALSE ;   // need to reset it to do the right things in this session

    if (m_RenderTransport == AM_VIDEOPORT)
    {
        // tell the videoport object
        hr = m_pIVPObject->Run(tStart);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Run() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        // tell the sync object
        hr = m_pSyncObj->Run(tStart);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->Run() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

    }
    else
    {
        ASSERT(m_RenderTransport == AM_IOVERLAY);
    }

    // call the base class
    hr = CBaseInputPin::Run(tStart);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Run failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Run")));
    m_trLastFrame = -1;
    return hr;
}

// transition from run to pause state
HRESULT COMInputPin::RunToPause(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::RunToPause")));

    CAutoLock cLock(m_pFilterLock);

    if (m_RenderTransport == AM_VIDEOPORT)
    {
        // tell the videoport object
        hr = m_pIVPObject->RunToPause();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->RunToPause() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR)
    {
        // tell the sync object
        hr = m_pSyncObj->RunToPause();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->RunToPause() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        ASSERT(m_RenderTransport == AM_IOVERLAY);
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::RunToPause")));
    return hr;
}


HRESULT COMInputPin::SetFrameStepMode(DWORD dwFramesToStep /* 1 for now */)
{
    CAutoLock cLock(m_pFilterLock);

    //
    // If we are on the wrong monitor fail the call
    //

    HMONITOR ID;
    if (m_pFilter->IsWindowOnWrongMonitor(&ID))
        return E_FAIL;

    long l = m_lFramesToStep;
    m_lFramesToStep = dwFramesToStep;

    //
    // If we are currently blocked on the frame step event
    // release the receive thread so that we can get another
    // frame
    //

    if (l == 0) {
        SetEvent(m_StepEvent);
    }

    return S_OK;
}

HRESULT COMInputPin::CancelFrameStepMode()
{
    CAutoLock cLock(m_pFilterLock);

    //
    // cancel any outstanding steps
    //

    if (m_lFramesToStep == 0) {
        SetEvent(m_StepEvent);
    }
    m_lFramesToStep = -1;

    return S_OK;
}


// signals start of flushing on the input pin
HRESULT COMInputPin::BeginFlush(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::BeginFlush")));

    CAutoLock cLock(m_pFilterLock);
    m_hEndOfStream = 0;

    if (m_bFlushing)
    {
        return E_FAIL;
    }

    if (m_dwPinId == 0) {
        CancelFrameStepMode();
    }

    // if the conection is VideoPort or IOverlay, we do not care about flushing
    if (m_RenderTransport != AM_VIDEOPORT && m_RenderTransport != AM_IOVERLAY)
    {
        ASSERT(m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN ||
               m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR);

        // call the sync object
        hr = m_pSyncObj->BeginFlush();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->BeginFlush() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        ASSERT(m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY);
    }


    // call the base class
    hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::BeginFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::BeginFlush")));
    return hr;
}

// signals end of flushing on the input pin
HRESULT COMInputPin::EndFlush(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::EndFlush")));

    CAutoLock cLock(m_pFilterLock);

    if (!m_bFlushing)
    {
        return E_FAIL;
    }

    // if the conection is VideoPort or IOverlay, we do not care about flushing
    if (m_RenderTransport != AM_VIDEOPORT && m_RenderTransport != AM_IOVERLAY)
    {
        ASSERT(m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI || m_RenderTransport == AM_VIDEOACCELERATOR);

        // call the sync object
        hr = m_pSyncObj->EndFlush();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->EndFlush() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        ASSERT(m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY);
    }

    // call the base class
    hr = CBaseInputPin::EndFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::EndFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::EndFlush")));
    return hr;
}

// Send a quality message if required - this is the hack version
// that just passes the lateness
void COMInputPin::DoQualityMessage()
{
    CAutoLock cLock(m_pFilterLock);

    if (m_pFilter->m_State == State_Running &&
        SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID)
    {
        CRefTime CurTime;
        if (S_OK == m_pFilter->StreamTime(CurTime))
        {
            const REFERENCE_TIME tStart = SampleProps()->tStart;
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = CurTime > tStart ? Flood : Famine;
            msg.Late = CurTime - tStart;
            msg.TimeStamp = tStart;
            PassNotify(msg);

            if (m_trLastFrame > 0) {
                m_pSyncObj->m_AvgDelivery.NewFrame(CurTime - m_trLastFrame);
            }
            m_trLastFrame = CurTime;
        }
    }
}

BOOL
COMInputPin::DoFrameStepAndReturnIfNeeded()
{
    if (m_lFramesToStep == 0) {
        m_pFilterLock->Unlock();
        WaitForSingleObject(m_StepEvent, INFINITE);
        m_pFilterLock->Lock();
    }

    //
    // do we have frames to discard ?
    //

    if (m_lFramesToStep > 0) {
        m_lFramesToStep--;
        if (m_lFramesToStep > 0) {
            return TRUE;
        }
    }
    return FALSE;
}

// called when the upstream pin delivers us a sample
HRESULT COMInputPin::Receive(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;
    BOOL bNeedToFlipOddEven = FALSE;
    BOOL bDisplayingFields = FALSE;
    DWORD dwTypeSpecificFlags = 0;
    LPDIRECTDRAWSURFACE pPrimarySurface = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Receive")));
#ifdef PERF
    {
        DWORD dwTypeSpecificFlags;
        GetTypeSpecificFlagsFromMediaSample(pMediaSample, &dwTypeSpecificFlags);
        Msr_Integer(m_FrameReceived, dwTypeSpecificFlags);
    }
#endif

    m_bReallyFlipped = FALSE;
    // if it is IOverlay connection, bail out
    if (m_RenderTransport == AM_IOVERLAY)
    {
        hr = VFW_E_NOT_SAMPLE_CONNECTION;
        goto CleanUp;
    }

    if (m_RenderTransport == AM_VIDEOPORT)
    {
        hr = VFW_E_NOT_SAMPLE_CONNECTION;
        goto CleanUp;
    }

    if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN)
    {
        // this will unlock the surface
        // unlock the sample first
        hr = ((CDDrawMediaSample*)pMediaSample)->GetSurfaceAndReleaseLock(NULL, NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("pSample->GetSurfaceAndReleaseLock() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        OnReleaseBuffer(pMediaSample);

        // if there is no primary surface (due to a display mode change), fail the receive call
        pPrimarySurface = m_pFilter->GetPrimarySurface();
        if (!pPrimarySurface)
        {
            hr = E_FAIL;
            goto CleanUp;
        }
    }

    //
    // Frame step hack-o-matic
    //
    // This code acts as a gate - for a frame step of N frames
    // it discards N-1 frames and then lets the Nth frame thru the
    // the gate to be renderer in the normal way i.e. at the correct
    // time.  The next time Receive is called the gate is shut and
    // the thread blocks.  The gate only opens again when the step
    // is cancelled or another frame step request comes in.
    //
    // StEstrop - Thu 10/21/1999
    //

    if (m_dwPinId == 0) {

        if (m_RenderTransport != AM_VIDEOACCELERATOR) {

            CAutoLock cLock(m_pFilterLock);
            if (DoFrameStepAndReturnIfNeeded()) {
                goto CleanUp;
            }

        }
        else {

            if (DoFrameStepAndReturnIfNeeded()) {
                goto CleanUp;
            }
        }
    }

    if (m_bSyncOnFill)
    {
        CAutoLock cLock(m_pFilterLock);

        // make sure the base class says it is ok (checks the flushing and
        // filter state)
        hr = CBaseInputPin::Receive(pMediaSample);
        if (hr != NOERROR)
        {
            hr = E_FAIL;
            goto CleanUp;
        }
        DoQualityMessage();

        // Has the type changed on a media sample. We do all rendering
        // synchronously on the source thread, which has a side effect
        // that only one buffer is ever outstanding. Therefore when we
        // have Receive called we can go ahead and change the format
        {
            if (SampleProps()->dwSampleFlags & AM_SAMPLE_TYPECHANGED)
            {
                SetMediaType((CMediaType *)SampleProps()->pMediaType);

                // store m_mtNew in m_mtNewAdjusted with the width of the mediatype adjusted
                UpdateMediaType();
                // make sure that the video frame gets updated by redrawing everything
                EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
            }
        }

        m_pSyncObj->SetRepaintStatus(TRUE);
        if (m_pSyncObj->GetRealState() == State_Paused)
        {
            m_pSyncObj->Ready();
        }

        if ((m_mtNewAdjusted.formattype != FORMAT_VideoInfo) &&
            (!CheckTypeSpecificFlags(m_dwInterlaceFlags, m_SampleProps.dwTypeSpecificFlags)))
        {
            DbgLog((LOG_ERROR, 1, TEXT("CheckTypeSpecificFlags failed")));
            hr = E_FAIL;
            goto CleanUp;
        }

        // assert that we are not in bob mode
        bNeedToFlipOddEven = NeedToFlipOddEven(m_dwInterlaceFlags, 0, NULL);
        ASSERT(!bNeedToFlipOddEven);

        hr = DoRenderSample(pMediaSample);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("DoRenderSample(pMediaSample) failed, hr = 0x%x"), hr));
            hr = E_FAIL;
            goto CleanUp;
        }

    }
    else
    {
        {
            CAutoLock cLock(m_pFilterLock);

            // make sure the base class says it is ok (checks the flushing and
            // filter state)
            hr = CBaseInputPin::Receive(pMediaSample);
            if (hr != NOERROR)
            {
                hr = E_FAIL;
                goto CleanUp;
            }
            DoQualityMessage();

            // Has the type changed on a media sample. We do all rendering
            // synchronously on the source thread, which has a side effect
            // that only one buffer is ever outstanding. Therefore when we
            // have Receive called we can go ahead and change the format
            {
                if (SampleProps()->dwSampleFlags & AM_SAMPLE_TYPECHANGED)
                {
                    SetMediaType((CMediaType *)SampleProps()->pMediaType);

                    // store m_mtNew in m_mtNewAdjusted with the width of the mediatype adjusted
                    UpdateMediaType();
                    // make sure that the video frame gets updated by redrawing everything
                    EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
                }
            }

        }

        if ((m_mtNewAdjusted.formattype != FORMAT_VideoInfo) &&
            (!CheckTypeSpecificFlags(m_dwInterlaceFlags, m_SampleProps.dwTypeSpecificFlags)))
        {
            DbgLog((LOG_ERROR, 1, TEXT("CheckTypeSpecificFlags failed")));
            hr = E_FAIL;
            goto CleanUp;
        }

        bNeedToFlipOddEven = NeedToFlipOddEven(m_dwInterlaceFlags, m_SampleProps.dwTypeSpecificFlags, &m_dwFlipFlag);
        bDisplayingFields = DisplayingFields(m_dwInterlaceFlags);

        // call the sync object
        // We're already locked if we using video acceleration
        if (m_RenderTransport == AM_VIDEOACCELERATOR) {
            m_pFilterLock->Unlock();
        }


        hr = m_pSyncObj->Receive(pMediaSample);
        if (m_RenderTransport == AM_VIDEOACCELERATOR) {
            m_pFilterLock->Lock();
        }

        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->Receive() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        if (bNeedToFlipOddEven && !bDisplayingFields)
        {
            REFERENCE_TIME StartSample, EndSample;
            hr = m_pSyncObj->GetSampleTimes(pMediaSample, &StartSample, &EndSample);
            if (SUCCEEDED(hr))
            {
                // NewStartSample = (OldStartSample+EndSample)/2
                StartSample = StartSample+EndSample;
                StartSample = StartSample >> 1;
                pMediaSample->SetTime(&StartSample, &EndSample);
            }
            if (m_dwFlipFlag == DDFLIP_ODD)
                m_dwFlipFlag2 = DDFLIP_EVEN;
            else if (m_dwFlipFlag == DDFLIP_EVEN)
                m_dwFlipFlag2 = DDFLIP_ODD;

            // call the sync object
            hr = m_pSyncObj->ScheduleSampleUsingMMThread(pMediaSample);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->ScheduleSampleUsingMMThread() failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
    }

    //  Avoid pink flash
    if (m_UpdateOverlayNeededAfterReceiveConnection && m_dwPinId == 0)
    {
        //  Must be called with m_bConnected = TRUE
        EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        m_UpdateOverlayNeededAfterReceiveConnection = false;
    }
    //
    // If this is the target frame for a Step operation, m_lFramesToStep
    // will be equal to 0.  In which case we have to send an
    // EC_STEP_COMPLETE to the filter graph manager so that it can
    // pause the graph.
    //

    if (m_dwPinId == 0 && m_lFramesToStep == 0) {
        EventNotify(EC_STEP_COMPLETE, FALSE, 0);
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Receive")));
    return hr;
}


HRESULT COMInputPin::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
    CAutoLock cLock(m_pFilterLock);

    DoRenderSample(pMediaSample);

    return NOERROR;
}

HRESULT COMInputPin::FlipOverlayToItself()
{
    //  No need to lock - the surface pointers should not change in the
    //  middle of a flip
    ASSERT(m_pDirectDrawSurface);
    return  m_pDirectDrawSurface->Flip(m_pDirectDrawSurface, m_dwFlipFlag2);
}



// COMInputPin::DrawGDISample
//
//
//
HRESULT COMInputPin::DrawGDISample(IMediaSample *pMediaSample)
{
    DIBDATA *pDibData = NULL;
    LPRGNDATA pBuffer = NULL;
    LPRECT pDestRect;
    HDC hTargetDC = (HDC)NULL;
    HRESULT hr = NOERROR;
    LPBITMAPINFOHEADER pbmiHeader = NULL;
    LPBYTE pSampleBits = NULL;
    DWORD dwTemp, dwBuffSize, dwRetVal;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::DrawGDISample")));

    hTargetDC = m_pFilter->GetDestDC();
    ASSERT(hTargetDC);

    if (m_pFilter->UsingWindowless())
    {
        if (pMediaSample)
        {
            pDibData = ((CDDrawMediaSample*)pMediaSample)->GetDIBData();
        }
        else
        {
            pDibData = &m_BackingDib;
        }


        if (!pDibData || !pDibData->pBase)
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        if (!m_hMemoryDC)
        {
            EXECUTE_ASSERT(m_hMemoryDC = CreateCompatibleDC(hTargetDC));
            EXECUTE_ASSERT(SetStretchBltMode(hTargetDC,COLORONCOLOR));
            EXECUTE_ASSERT(SetStretchBltMode(m_hMemoryDC,COLORONCOLOR));
        }
    }
    else
    {
        pbmiHeader = GetbmiHeader(&m_mtNewAdjusted);
        ASSERT(pbmiHeader);

        hr = pMediaSample->GetPointer(&pSampleBits);
        if (FAILED(hr))
        {
            goto CleanUp;
        }
    }

    dwRetVal = GetRegionData(m_WinInfo.hClipRgn, 0, NULL);
    if (!dwRetVal)
        goto CleanUp;

    ASSERT(dwRetVal);
    dwBuffSize = dwRetVal;
    pBuffer = (LPRGNDATA) new char[dwBuffSize];
    if ( ! pBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    dwRetVal = GetRegionData(m_WinInfo.hClipRgn, dwBuffSize, pBuffer);
    ASSERT(pBuffer->rdh.iType == RDH_RECTANGLES);

    for (dwTemp = 0; dwTemp < pBuffer->rdh.nCount; dwTemp++)
    {
        pDestRect = (LPRECT)((char*)pBuffer + pBuffer->rdh.dwSize + dwTemp*sizeof(RECT));
        ASSERT(pDestRect);

        if (IsRectEmpty(&m_WinInfo.DestClipRect))
        {
            continue;
        }

        CalcSrcClipRect(&m_WinInfo.SrcRect, &m_WinInfo.SrcClipRect,
                        &m_WinInfo.DestRect, pDestRect);

        ASSERT(OffsetRect(pDestRect, -m_WinInfo.TopLeftPoint.x, -m_WinInfo.TopLeftPoint.y));

        if (pDibData)
            FastDIBBlt(pDibData, hTargetDC, m_hMemoryDC, pDestRect, &m_WinInfo.SrcClipRect);
        else
            SlowDIBBlt(pSampleBits, pbmiHeader, hTargetDC, pDestRect, &m_WinInfo.SrcClipRect);

    }
    EXECUTE_ASSERT(GdiFlush());

CleanUp:
    if (pBuffer)
    {
        delete [] pBuffer;
        pBuffer = NULL;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::DrawGDISample")));
    return hr;
}


// COMInputPin::DoRenderGDISample
//
// Renderering when the transport is GDI is pretty complex - hence
// we have a dedicated function to take care of it
//
HRESULT COMInputPin::DoRenderGDISample(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::DoRenderGDISample")));

    //
    // if we are in a pull model, don't draw anything in receive, just tell
    // the filter that we need to redraw.  Also, if we are not using our
    // allocator we need to save the image into the backing store.
    //
    if (pMediaSample)
    {
        if (m_pFilter->UsingWindowless())
        {
            m_bOverlayHidden = FALSE;

            if (!m_bUsingOurAllocator) {

                LPBYTE pSampleBits;
                hr = pMediaSample->GetPointer(&pSampleBits);
                if (SUCCEEDED(hr) && m_BackingDib.pBase) {
                    CopyMemory(m_BackingDib.pBase, pSampleBits, m_BackingImageSize);
                }
            }
            else {

                CDDrawMediaSample *pCDDrawMediaSample = (CDDrawMediaSample*)pMediaSample;

                DIBDATA DibTemp = *(pCDDrawMediaSample->GetDIBData());
                pCDDrawMediaSample->SetDIBData(&m_BackingDib);
                m_BackingDib = DibTemp;
            }

            // make sure that the video frame gets updated by redrawing everything
            EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        }
        else
        {
            DrawGDISample(pMediaSample);
        }
    }
    else
    {
        //
        // If we are in Windowless mode we use the previous buffer if
        // we are using our allocator, otherwise we use the back buffer.
        //
        if (m_pFilter->UsingWindowless())
        {
            DrawGDISample(NULL);
        }

        //
        // We are not in Windowless mode so use the old code.
        //
        else
        {
            pMediaSample = m_pSyncObj->GetCurrentSample();
            if (pMediaSample)
            {
                DrawGDISample(pMediaSample);
                pMediaSample->Release();
            }
            else
            {
                m_pSyncObj->SendRepaint();
            }
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::DoRenderGDISample")));
    return hr;
}


HRESULT COMInputPin::DoRenderSample(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;
    static DWORD dwFlags = 0;
    LPRGNDATA pBuffer = NULL;
    DWORD dwTemp, dwBuffSize = 0, dwRetVal = 0;
    LPRECT pDestRect = NULL;
    DWORD dwBlendingParameter = 1, dwTypeSpecificFlags = 0, dwUpdateOverlayFlags = 0;
    BOOL bDoReleaseSample = FALSE;


    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::DoRenderSample")));

    CAutoLock cLock(m_pFilterLock);

    hr = GetBlendingParameter(&dwBlendingParameter);
    ASSERT(SUCCEEDED(hr));

    if (dwBlendingParameter == 0)
        goto CleanUp;

    if ((m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_VIDEOACCELERATOR) && m_bSyncOnFill)
    {
        ; // do nothing
    }
    else if ((m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_VIDEOACCELERATOR) && !m_bSyncOnFill)
    {
        // using flipping surfaces
        ASSERT(m_pBackBuffer);

        if (! m_bDontFlip )   // don't flip if BltFast() failed
        {
            // For video accelerator stuff check the motion comp copmleted
            if (m_RenderTransport == AM_VIDEOACCELERATOR) {
                //  Wait until previous motion comp operation is complete
                IDirectDrawSurface4 *pSurface4;
                if (SUCCEEDED(m_pBackBuffer->QueryInterface(IID_IDirectDrawSurface4,
                    (void **)&pSurface4))) {
                    while (DDERR_WASSTILLDRAWING ==
                           m_pIDDVideoAccelerator->QueryRenderStatus(
                               pSurface4,
                               DDVA_QUERYRENDERSTATUSF_READ)) {
                        Sleep(1);
                    }
                    pSurface4->Release();
                }
            }
#ifdef PERF
            Msr_Note(m_PerfFrameFlipped);
#endif
#if defined(DEBUG) && !defined(_WIN64)
            extern int iFPSLog;
            if (iFPSLog) {
                static int FlipCounter;
                static DWORD time;
                FlipCounter++;

                if (0 == (FlipCounter % 60)) {

                    DWORD timeTaken = time;
                    time = timeGetTime();
                    timeTaken = time - timeTaken;

                    int f = (60 * 1000 * 1000) / timeTaken;

                    wsprintf(m_pFilter->m_WindowText,
                           TEXT("ActiveMovie Window: Flip Rate %d.%.3d / Sec"),
                           f / 1000, f % 1000 );

                    // Can't call SetWindowText on this thread
                    // because we would deadlock !!

                    PostMessage(m_pFilter->GetWindow(), WM_DISPLAY_WINDOW_TEXT, 0, 0);
                }
            }
#endif
            // do not wait for the flip to complete
            hr = m_pDirectDrawSurface->Flip(m_pBackBuffer, m_dwFlipFlag);
            m_bReallyFlipped = (hr == DD_OK || hr == DDERR_WASSTILLDRAWING);
        }

        hr = GetTypeSpecificFlagsFromMediaSample(pMediaSample, &dwTypeSpecificFlags);
        ASSERT(SUCCEEDED(hr));

        dwUpdateOverlayFlags = GetUpdateOverlayFlags(m_dwInterlaceFlags, dwTypeSpecificFlags);
        if (dwUpdateOverlayFlags != m_dwUpdateOverlayFlags)
        {
            m_dwUpdateOverlayFlags = dwUpdateOverlayFlags;
            // make sure that the video frame gets updated by redrawing everything
            EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        }
    }
    else if (m_RenderTransport == AM_OFFSCREEN)
    {
        LPDIRECTDRAWSURFACE pPrimarySurface = m_pFilter->GetPrimarySurface();
        LPDDCAPS pDirectCaps;

        if ( ! pPrimarySurface )
        {
            hr = E_FAIL;
            goto CleanUp;
        }
        pDirectCaps = m_pFilter->GetHardwareCaps();
        if ( ! pDirectCaps )
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        ASSERT(m_pDirectDrawSurface);

        // wait only if there is a sample
        if (pMediaSample)
            dwFlags = DDBLT_WAIT;

        // this is for those cards which do bilinear-filtering while doing a stretch blt.
        // We do source-colorkeying so that the hal resorts to pixel doubling.
        if ((pDirectCaps->dwSVBFXCaps) & DDFXCAPS_BLTARITHSTRETCHY)
            dwFlags |= DDBLT_KEYSRC;

        dwRetVal = GetRegionData(m_WinInfo.hClipRgn, 0, NULL);
        if (!dwRetVal)
            goto CleanUp;

        ASSERT(dwRetVal);
        dwBuffSize = dwRetVal;
        pBuffer = (LPRGNDATA) new char[dwBuffSize];
        ASSERT(pBuffer);

        dwRetVal = GetRegionData(m_WinInfo.hClipRgn, dwBuffSize, pBuffer);
        ASSERT(pBuffer->rdh.iType == RDH_RECTANGLES);


        // using offscreen surface
        for (dwTemp = 0; dwTemp < pBuffer->rdh.nCount; dwTemp++)
        {
            pDestRect = (LPRECT)((char*)pBuffer + pBuffer->rdh.dwSize + dwTemp*sizeof(RECT));
            ASSERT(pDestRect);

            if (IsRectEmpty(&m_WinInfo.DestClipRect))
            {
                continue;
            }

            CalcSrcClipRect(&m_WinInfo.SrcRect, &m_WinInfo.SrcClipRect,
                            &m_WinInfo.DestRect, pDestRect);

#if 0       //  Should do this later - right now we just see the
            //  old overlay contents instead of the key color which
            //  in many cases is worse

            //  We must draw the overlay now as this blt may contain
            //  lots of key color
            m_pFilter->m_apInput[0]->CheckOverlayHidden();
#endif

            // Draw the offscreen surface and wait for it to complete
            RECT TargetRect = *pDestRect;
            OffsetRect(&TargetRect,
                       -m_pFilter->m_lpCurrentMonitor->rcMonitor.left,
                       -m_pFilter->m_lpCurrentMonitor->rcMonitor.top);

            hr = pPrimarySurface->Blt(&TargetRect, m_pDirectDrawSurface,
                                      &m_WinInfo.SrcClipRect, dwFlags, NULL);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0,  TEXT("pPrimarySurface->Blt() failed, hr = %d"), hr & 0xffff));
                goto CleanUp;
            }
        }
    }
    else if (m_RenderTransport == AM_GDI)
    {
        hr = DoRenderGDISample(pMediaSample);
    }

    if (m_bOverlayHidden)
    {
        m_bOverlayHidden = FALSE;
        // make sure that the video frame gets updated by redrawing everything
        EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
    }

CleanUp:
    if (pBuffer)
    {
        delete [] pBuffer;
        pBuffer = NULL;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::DoRenderSample")));
    return hr;
}

// signals end of data stream on the input pin
STDMETHODIMP COMInputPin::EndOfStream(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::EndOfStream")));

    CAutoLock cLock(m_pFilterLock);
    if (m_hEndOfStream) {
        EXECUTE_ASSERT(SetEvent(m_hEndOfStream));
        return S_OK;
    }

    if (m_dwPinId == 0) {
        CancelFrameStepMode();
    }

    // Make sure we're streaming ok

    hr = CheckStreaming();
    if (hr != NOERROR)
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckStreaming() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY)
    {
        // Pass EOS to the filter graph
        hr = m_pFilter->EventNotify(m_dwPinId, EC_COMPLETE, S_OK, 0);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->EventNotify failed, hr = 0x%x"), hr));
        }
    }
    else
    {
        // call the sync object
        hr = m_pSyncObj->EndOfStream();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->EndOfStream() failed, hr = 0x%x"), hr));
        }
    }


CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::EndOfStream")));
    return hr;
}

// signals end of data stream on the input pin
HRESULT COMInputPin::EventNotify(long lEventCode, long lEventParam1, long lEventParam2)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::EventNotify")));

    CAutoLock cLock(m_pFilterLock);

    if (lEventCode == EC_OVMIXER_VP_CONNECTED)
    {
        m_mtNew.majortype = MEDIATYPE_Video;
        m_mtNew.formattype = FORMAT_VideoInfo2;
        m_mtNew.ReallocFormatBuffer(sizeof(VIDEOINFOHEADER2));

        hr = m_pIVPObject->CurrentMediaType(&m_mtNew);
        ASSERT(SUCCEEDED(hr));

        hr = UpdateMediaType();
        ASSERT(SUCCEEDED(hr));

        goto CleanUp;
    }

    if (lEventCode == EC_OVMIXER_REDRAW_ALL || lEventCode == EC_REPAINT)
    {
        m_pFilter->EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        goto CleanUp;
    }

    // WARNING : we are assuming here that the input pin will be the first pin to be created
    if (lEventCode == EC_COMPLETE && m_dwPinId == 0)
    {
        m_pFilter->EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        goto CleanUp;
    }

    if (lEventCode == EC_ERRORABORT)
    {
        m_pFilter->EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        m_bRuntimeNegotiationFailed = TRUE;
        goto CleanUp;
    }

    if (lEventCode == EC_STEP_COMPLETE) {
        m_pFilter->EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::EventNotify")));
    return hr;
}


/******************************Public*Routine******************************\
* GetCaptureInfo
*
*
*
* History:
* 3/12/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::GetCaptureInfo(
    BOOL *lpCapturing,
    DWORD *lpdwWidth,
    DWORD *lpdwHeight,
    BOOL *lpInterleave
    )

{
    AMTRACE((TEXT("COMInputPin::GetCaptureInfo")));

    HRESULT hr = NOERROR;
    IKsPropertySet *pIKsPropertySet = NULL;
    DWORD dwVal[2], dwBytesReturned = 0;

    *lpCapturing = FALSE;

    if (!m_Connected) {

        DbgLog((LOG_TRACE, 1, TEXT("Input pin not connected!!")));
        hr = E_FAIL;
        goto CleanUp;
    }

#if defined(DEBUG)
    else {
        PIN_INFO PinInfo;
        hr = m_Connected->QueryPinInfo(&PinInfo);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE, 1, TEXT("Up stream pin name %ls"), PinInfo.achName));
            PinInfo.pFilter->Release();
        }
    }
#endif

    hr = m_Connected->QueryInterface(IID_IKsPropertySet,
                                     (void**)&pIKsPropertySet);
    if (SUCCEEDED(hr))
    {
        ASSERT(pIKsPropertySet);

        hr = pIKsPropertySet->Set(
                    AM_KSPROPSETID_ALLOCATOR_CONTROL,
                    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
                    NULL, 0,
                    lpInterleave, sizeof(*lpInterleave));

        if (SUCCEEDED(hr)) {
            hr = pIKsPropertySet->Get(
                        AM_KSPROPSETID_ALLOCATOR_CONTROL,
                        AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE,
                        NULL, 0,
                        lpInterleave, sizeof(*lpInterleave), &dwBytesReturned);

            if (FAILED(hr) || dwBytesReturned != sizeof(*lpInterleave)) {
                *lpInterleave = FALSE;
            }
        }
        else {
            *lpInterleave = FALSE;
        }


        hr = pIKsPropertySet->Get(
                    AM_KSPROPSETID_ALLOCATOR_CONTROL,
                    AM_KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,
                    NULL, 0, dwVal, sizeof(dwVal), &dwBytesReturned);

        DbgLog((LOG_TRACE, 2,
                TEXT("pIKsPropertySet->Get(")
                TEXT("AM_KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE),\n")
                TEXT("\thr = 0x%x, dwVal[0] == %d, dwVal[1] == %d, ")
                TEXT("dwBytesReturned == %d"),
                hr, dwVal[0], dwVal[1], dwBytesReturned));


        // if the decoder supports this property then we are capturing
        // and the intended capturing is size is given by
        // dwVal[0] and dwVal[1]
        //
        if (SUCCEEDED(hr) && dwBytesReturned == sizeof(dwVal))
        {
            *lpCapturing = TRUE;
            *lpdwWidth = dwVal[0];
            *lpdwHeight = dwVal[1];

            DbgLog((LOG_TRACE, 1,
                    TEXT("We are CAPTURING, intended size (%d, %d) interleave = %d"),
                    dwVal[0], dwVal[1], *lpInterleave));
        }

        pIKsPropertySet->Release();
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* GetDecimationUsage
*
*
*
* History:
* Thu 07/15/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::GetDecimationUsage(
    DECIMATION_USAGE *lpdwUsage
    )
{
    return m_pFilter->QueryDecimationUsage(lpdwUsage);
}


// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT COMInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetAllocator")));

    if (!ppAllocator)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppAllocator is NULL")));
        hr = E_POINTER;
        goto CleanUp;
    }

    {
        CAutoLock cLock(m_pFilterLock);

        // if vp connection, don't return any allocator
        if (m_RenderTransport == AM_VIDEOPORT || m_RenderTransport == AM_IOVERLAY || m_RenderTransport == AM_VIDEOACCELERATOR)
        {
            *ppAllocator = NULL;
            hr = VFW_E_NO_ALLOCATOR;
            goto CleanUp;
        }

        // if we don't have an allocator create one
        if (!m_pAllocator)
        {
            m_pAllocator = new COMInputAllocator(this, m_pFilterLock, &hr);
            if (!m_pAllocator || FAILED(hr))
            {
                // did not fail inside the destructor, so must be out of memory
                if (!FAILED(hr))
                    hr = E_OUTOFMEMORY;
                delete m_pAllocator;
                m_pAllocator = NULL;
                *ppAllocator = NULL;
                DbgLog((LOG_ERROR, 1, TEXT("new COMInputAllocator failed, hr = 0x%x"), hr));
                goto CleanUp;
            }

            /*  We AddRef() our own allocator */
            m_pAllocator->AddRef();
        }

        ASSERT(m_pAllocator != NULL);
        *ppAllocator = m_pAllocator;
        m_pAllocator->AddRef();
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetAllocator")));
    return hr;
} // GetAllocator

// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT COMInputPin::NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::NotifyAllocator")));

    if (!pAllocator)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppAllocator is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        CAutoLock cLock(m_pFilterLock);

        // if vp connection, don't care
        if (m_RenderTransport == AM_VIDEOPORT ||
            m_RenderTransport == AM_IOVERLAY ||
            m_RenderTransport == AM_VIDEOACCELERATOR)
        {
            goto CleanUp;
        }


        if (pAllocator != m_pAllocator)
        {
            // in the ddraw case, we insist on our own allocator
            if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN)
            {
                DbgLog((LOG_ERROR, 1, TEXT("pAllocator != m_pAllocator, not accepting the allocator")));
                hr = E_FAIL;
                goto CleanUp;
            }

            // since we have already handled the vp, ioverlay and ddraw case, this
            // must be the gdi case
            ASSERT(m_RenderTransport == AM_GDI);

            m_bUsingOurAllocator = FALSE;

            DbgLog((LOG_ERROR, 1, TEXT("pAllocator != m_pAllocator")));
        }
        else
        {
            m_bUsingOurAllocator = TRUE;
        }

        if (!m_bConnected)
        {
            hr = FinalConnect();
            ASSERT(SUCCEEDED(hr));
        }

    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::NotifyAllocator")));
    return hr;
} // NotifyAllocator

HRESULT COMInputPin::OnAlloc(CDDrawMediaSample **ppSampleList, DWORD dwSampleCount)
{
    HRESULT hr = NOERROR;
    DWORD i;
    LPDIRECTDRAWSURFACE pDDrawSurface = NULL, pBackBuffer = NULL;
    DDSCAPS ddSurfaceCaps;
    DWORD dwDDrawSampleSize = 0;
    BITMAPINFOHEADER *pHeader = NULL;
    DIBDATA DibData;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::OnAlloc")));

    CAutoLock cLock(m_pFilterLock);

    ASSERT(IsConnected());

    // get the image size
    pHeader = GetbmiHeader(&m_mtNew);
    if ( ! pHeader )
    {
        hr = E_FAIL;
        goto CleanUp;
    }
    dwDDrawSampleSize = pHeader->biSizeImage;
    ASSERT(dwDDrawSampleSize > 0);

    if (!ppSampleList)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppSampleList is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (m_RenderTransport == AM_OVERLAY ||
        m_RenderTransport == AM_OFFSCREEN)
    {
        ASSERT(m_pDirectDrawSurface);
        pDDrawSurface = m_pDirectDrawSurface;
    }

    for (i = 0; i < dwSampleCount; i++)
    {
        if (!ppSampleList[i])
        {
            DbgLog((LOG_ERROR, 1, TEXT("ppSampleList[%d] is NULL"), i));
            hr = E_INVALIDARG;
            goto CleanUp;
        }

        hr = ppSampleList[i]->SetDDrawSampleSize(dwDDrawSampleSize);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,  TEXT("ppSampleList[%d]->SetSampleSize failed, hr = 0x%x"), i, hr));
            goto CleanUp;
        }

        if (m_RenderTransport == AM_OVERLAY && !m_bSyncOnFill)
        {
            if (i == 0)
            {
                memset((void*)&ddSurfaceCaps, 0, sizeof(DDSCAPS));
                ddSurfaceCaps.dwCaps = DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_OVERLAY;
            }
            // Get the back buffer surface
            hr = pDDrawSurface->GetAttachedSurface(&ddSurfaceCaps, &pBackBuffer);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0,  TEXT("Function pDDrawSurface->GetAttachedSurface failed, hr = 0x%x"), hr));
                goto CleanUp;
            }

            ppSampleList[i]->SetDDrawSurface(pBackBuffer);
            pDDrawSurface = pBackBuffer;
            //
            // Surfaces returned by GetAttachedSurface() are supposed to be
            // Release()-ed; otherwise we leak ref count.  Here doing Release()
            // doesn't actually let go of the surface as it has already been
            // AddRef()-ed on the SetDDrawSurface() method above.
            //
            pBackBuffer->Release() ;
        }
        else if ((m_RenderTransport == AM_OVERLAY && m_bSyncOnFill)  ||
                 (m_RenderTransport == AM_OFFSCREEN))

        {
            ppSampleList[i]->SetDDrawSurface(pDDrawSurface);
            ASSERT(dwSampleCount == 1);
        }
        else if (m_RenderTransport == AM_GDI)
        {
            hr = CreateDIB(dwDDrawSampleSize, (BITMAPINFO*)pHeader, &DibData);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CreateDIB(%d, DibData); failed, hr = 0x%x"), dwDDrawSampleSize, hr));
                goto CleanUp;
            }
            ppSampleList[i]->SetDIBData(&DibData);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("ppSampleList[%d]->SetDIBData(&DibData) failed, hr = 0x%x"), i, hr));
                goto CleanUp;
            }

        }
    }  // end of for (i < dwSampleCount) loop

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::OnAlloc")));
    return hr;
}

// sets the pointer to directdraw
HRESULT COMInputPin::OnGetBuffer(IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
                                 REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
    HRESULT hr = NOERROR;
    CDDrawMediaSample *pCDDrawMediaSample = NULL;
    LPDIRECTDRAWSURFACE pBackBuffer = NULL;
    DDSURFACEDESC ddSurfaceDesc;
    BOOL bWaitForDraw = FALSE;
    BOOL bPalettised = FALSE;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::OnGetBuffer")));

    ASSERT(m_RenderTransport != AM_VIDEOPORT);
    ASSERT(m_RenderTransport != AM_IOVERLAY);
    ASSERT(m_RenderTransport != AM_VIDEOACCELERATOR);

    pCDDrawMediaSample = (CDDrawMediaSample*)*ppSample;

    //
    // Check to see if we have moved FULLY onto another monitor.
    // If so, start the reconnection process.  We may want to check that
    // the new playback monitor actually supports an overlay before
    // we do this, otherwise all video playback will stop.
    //

    HMONITOR ID;

    if (m_dwPinId == 0 && m_pFilter->m_pOutput &&
        m_pFilter->IsWindowOnWrongMonitor(&ID)) {

        if (ID != 0 && !m_pFilter->m_fDisplayChangePosted) {

            CAutoLock l(&m_pFilter->m_csFilter);
            DbgLog((LOG_TRACE, 1, TEXT("Window is on a DIFFERENT MONITOR!\n")));
            DbgLog((LOG_TRACE, 1, TEXT("Reset the world!\n")));

            PostMessage(m_pFilter->GetWindow(), m_pFilter->m_MonitorChangeMsg, 0, 0);

            // once only, or performance suffers when switching
            m_pFilter->m_fDisplayChangePosted = TRUE;
        }
    }

    if (m_RenderTransport == AM_GDI &&
        m_pFilter->UsingWindowless() &&
        m_bUsingOurAllocator)
    {
        CAutoLock cLock(m_pFilterLock);

        // If the current sample requires the image from the previous sample
        // we have to copy it into the current sample.
        if (dwFlags & AM_GBF_NOTASYNCPOINT)
        {
            LONG lBytesToCopy = pCDDrawMediaSample->GetSize();
            DIBDATA DibTmp = *pCDDrawMediaSample->GetDIBData();

            if (m_BackingDib.pBase && DibTmp.pBase && lBytesToCopy)
            {
                CopyMemory(DibTmp.pBase, m_BackingDib.pBase, lBytesToCopy);
            }
        }

    }

    // we might have to do the synchronization right here
    {
        CAutoLock cLock(m_pFilterLock);
        CAutoLock cAllocatorLock(static_cast<CCritSec*>(static_cast<CBaseAllocator*>(m_pAllocator)));

        if (m_bSyncOnFill)
        {
            bWaitForDraw = m_pSyncObj->CheckReady();
            if (m_pSyncObj->GetRealState() == State_Running)
            {
                (*ppSample)->SetDiscontinuity((dwFlags & AM_GBF_PREVFRAMESKIPPED) != 0);
                (*ppSample)->SetTime(pStartTime,pEndTime);
                bWaitForDraw = m_pSyncObj->ScheduleSample(*ppSample);
                (*ppSample)->SetDiscontinuity(FALSE);
                (*ppSample)->SetTime(NULL,NULL);
            }

            // Store the interface if we wait
            if (bWaitForDraw == TRUE)
            {
                m_pSyncObj->SetCurrentSample(*ppSample);
            }
        }
    }

    // Have the sample scheduled for drawing. We might get blocked here, if
    // the state is paused and we have already got a sample
    if (bWaitForDraw)
    {
        hr = m_pSyncObj->WaitForRenderTime();
    }

    // we must wait for the rendering time without the objects locked so that
    // state changes can get in and release us in WaitForRenderTime. After we
    // return we must relock the objects.
    {
        CAutoLock cLock(m_pFilterLock);
        CAutoLock cAllocatorLock(static_cast<CCritSec*>(static_cast<CBaseAllocator*>(m_pAllocator)));

        m_pSyncObj->SetCurrentSample(NULL);
        // Did the state change while waiting
        if (hr == VFW_E_STATE_CHANGED)
        {
            DbgLog((LOG_TRACE, 5, TEXT("State has changed, exiting")));
            hr = VFW_E_STATE_CHANGED;
            goto CleanUp;
        }

        // the first sample must change formats
        if (m_bDynamicFormatNeeded)
        {
            hr = IsPalettised(&m_mtNew, &bPalettised);
            ASSERT(SUCCEEDED(hr));

            if (m_bNewPaletteSet && bPalettised && m_pFilter->GetDisplay()->IsPalettised())
            {
                if (m_pFilter->UsingWindowless()) {

                    RGBQUAD *pColours = NULL;
                    RGBQUAD *pColoursMT = NULL;

                    // get the palette entries from the Base Pin
                    // and copy them into the palette info in the mediatype
                    BITMAPINFOHEADER *pHeader = GetbmiHeader(&m_mt);
                    if (pHeader) {

                        pColours = (RGBQUAD *)GetColorInfo(&m_mtNew);
                        pColoursMT = (RGBQUAD *)GetColorInfo(&m_mt);

                        // Now copy the palette colours across
                        CopyMemory(pColours, pColoursMT,
                                   (pHeader->biClrUsed * sizeof(RGBQUAD)));
                    }
                    else hr = E_FAIL;
                }
                else {

                    RGBQUAD *pColours = NULL;
                    PALETTEENTRY *pPaletteEntries = NULL;
                    DWORD dwNumPaletteEntries = 0, dwCount = 0;

                    // get the palette entries from the filter
                    hr = m_pFilter->GetPaletteEntries(&dwNumPaletteEntries, &pPaletteEntries);
                    if (SUCCEEDED(hr))
                    {
                        ASSERT(dwNumPaletteEntries);
                        ASSERT(pPaletteEntries);

                        // get the pointer to the palette info in the mediatype
                        pColours = (RGBQUAD *)GetColorInfo(&m_mtNew);

                        // Now copy the palette colours across
                        for (dwCount = 0; dwCount < dwNumPaletteEntries; dwCount++)
                        {
                            pColours[dwCount].rgbRed = pPaletteEntries[dwCount].peRed;
                            pColours[dwCount].rgbGreen = pPaletteEntries[dwCount].peGreen;
                            pColours[dwCount].rgbBlue = pPaletteEntries[dwCount].peBlue;
                            pColours[dwCount].rgbReserved = 0;
                        }
                    }
                }
                m_bNewPaletteSet = FALSE;
            }

            SetMediaType(&m_mtNew);
            // store m_mtNew in m_mtNewAdjusted with the width of the mediatype adjusted
            CopyAndAdjustMediaType(&m_mtNewAdjusted, &m_mtNew);

            pCDDrawMediaSample->SetMediaType(&m_mtNew);
            m_bDynamicFormatNeeded = FALSE;
        }

        if (m_RenderTransport == AM_OVERLAY && !m_bSyncOnFill)
        {
            // if deocoder needs the last frame, copy it from the visible surface
            // to the back buffer
            if (dwFlags & AM_GBF_NOTASYNCPOINT)
            {
                hr = pCDDrawMediaSample->GetDDrawSurface(&pBackBuffer);
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 1, TEXT("pCDDrawMediaSample->LockMediaSamplePointer failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }

                // Finally copy the overlay to the back buffer
                if (!m_bDontFlip)   // if BltFast() hasn't already failed
                {
                    hr = pBackBuffer->BltFast((DWORD) 0, (DWORD) 0, m_pDirectDrawSurface, (RECT *) NULL,
                                              DDBLTFAST_WAIT |  DDBLTFAST_NOCOLORKEY) ;
                    if (FAILED(hr) && hr != DDERR_WASSTILLDRAWING)
                    {
                        DbgLog((LOG_ERROR, 1, TEXT("pBackBuffer->BltFast failed, hr = 0x%x"), hr));
                        // if BltFast fails, then stop using flipping, just use one overlay from now on
                        m_bSyncOnFill = FALSE;

                        //
                        // Make all the output go to the same overlay surface and stop flipping
                        //
                        m_bDontFlip = TRUE ;

                        CDDrawMediaSample  *pDDSample ;
                        for (pDDSample = (CDDrawMediaSample *)*ppSample ;
                             pDDSample ;
                             pDDSample = (CDDrawMediaSample *)pDDSample->Next())
                        {
                            hr = pDDSample->SetDDrawSurface(m_pDirectDrawSurface) ;
                            ASSERT(SUCCEEDED(hr)) ;
                        }
                    }

                    ASSERT(hr != DDERR_WASSTILLDRAWING);
                }  // end of if (!m_bDontFlip)
            }
        }

        if (m_RenderTransport == AM_OVERLAY || m_RenderTransport == AM_OFFSCREEN)
        {
            hr = pCDDrawMediaSample->LockMediaSamplePointer();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("pCDDrawMediaSample->LockMediaSamplePointer failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }

    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::OnGetBuffer")));
    return hr;
}

// In case of flipping surfaces, gets the back buffer
HRESULT COMInputPin::OnReleaseBuffer(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::OnReleaseBuffer")));

    CAutoLock cLock(m_pFilterLock);

    if (m_RenderTransport == AM_OVERLAY && !m_bSyncOnFill)
    {
        hr = ((CDDrawMediaSample*)pMediaSample)->GetDDrawSurface(&m_pBackBuffer);
        ASSERT(SUCCEEDED(hr));
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::OnReleaseBuffer")));
    return hr;
}

/*****************************Private*Routine******************************\
* GetUpstreamFilterName
*
*
*
* History:
* Tue 11/30/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::GetUpstreamFilterName(
    TCHAR* FilterName
    )
{
    PIN_INFO PinInfo;

    if (!m_Connected)
    {
        return VFW_E_NOT_CONNECTED;
    }

    HRESULT hr = m_Connected->QueryPinInfo(&PinInfo);
    if (SUCCEEDED(hr))
    {
        FILTER_INFO FilterInfo;
        hr = PinInfo.pFilter->QueryFilterInfo(&FilterInfo);
        if (SUCCEEDED(hr))
        {
            wsprintf(FilterName, TEXT("%ls"), FilterInfo.achName);
            if (FilterInfo.pGraph)
            {
                FilterInfo.pGraph->Release();
            }
        }
        PinInfo.pFilter->Release();
    }

    return hr;
}
HRESULT COMInputPin::CreateDDrawSurface(CMediaType *pMediaType, AM_RENDER_TRANSPORT amRenderTransport,
                                        DWORD *pdwMaxBufferCount, LPDIRECTDRAWSURFACE *ppDDrawSurface)
{
    HRESULT hr = NOERROR;
    DDSURFACEDESC SurfaceDesc;
    DWORD dwInterlaceFlags = 0, dwTotalBufferCount = 0, dwMinBufferCount = 0;
    DDSCAPS ddSurfaceCaps;
    BITMAPINFOHEADER *pHeader;
    FOURCCMap amFourCCMap(pMediaType->Subtype());
    LPDIRECTDRAW pDirectDraw = NULL;

    ASSERT(amRenderTransport != AM_VIDEOACCELERATOR);

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::CreateDDrawSurface")));

    CAutoLock cLock(m_pFilterLock);

    pDirectDraw = m_pFilter->GetDirectDraw();
    ASSERT(pDirectDraw);

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!ppDDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppDDrawSurface is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (amRenderTransport != AM_OFFSCREEN &&
        amRenderTransport != AM_OVERLAY)
    {
        DbgLog((LOG_ERROR, 1, TEXT("amRenderTransport = %d, not a valid value"),
            amRenderTransport));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pdwMaxBufferCount)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwMaxBufferCount is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    hr = GetInterlaceFlagsFromMediaType(pMediaType, &dwInterlaceFlags);
    ASSERT(SUCCEEDED(hr));

    // Set the surface description common to all kinds of surfaces
    INITDDSTRUCT(SurfaceDesc);
    SurfaceDesc.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    SurfaceDesc.dwWidth = abs(pHeader->biWidth);
    SurfaceDesc.dwHeight = abs(pHeader->biHeight);

//  if (DisplayingFields(dwInterlaceFlags))
//      SurfaceDesc.dwHeight = (DWORD)( ((float)(SurfaceDesc.dwHeight+1)) / 2.0 );

    if (amRenderTransport == AM_OFFSCREEN)
    {
        // store the caps and dimensions
        // try video memory first

        // It would be nice to use video memory because that way we can take
        // advantage of the h/w Blter, but Mediamatics ignore the stride
        // value when we QueryAccept them with this surface, resulting in unreadable
        // Sub-Pictures.  Therefore we restrict the usage to just the Teletext decoder.
        //
        hr = E_FAIL;
        TCHAR FilterName[MAX_FILTER_NAME];
        if (SUCCEEDED(GetUpstreamFilterName(FilterName)))
        {
            if (0 == lstrcmp(FilterName, TEXT("WST Decoder")))
            {
                LPDDCAPS pDirectCaps = m_pFilter->GetHardwareCaps();
                if (pDirectCaps->dwCaps & DDCAPS_BLTSTRETCH) {

                    SurfaceDesc.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                 DDSCAPS_VIDEOMEMORY;

                    hr = m_pFilter->GetDirectDraw()->CreateSurface(&SurfaceDesc,
                                                                   ppDDrawSurface,
                                                                   NULL);
                }
            }
        }

        if (FAILED(hr))
        {
            //
            // Can't get any video memory - try system memory
            //
            SurfaceDesc.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
            hr = m_pFilter->GetDirectDraw()->CreateSurface(&SurfaceDesc, ppDDrawSurface, NULL);

            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,1,
                        TEXT("Function CreateSurface type %4.4hs failed, hr = 0x%x"),
                        &pHeader->biCompression, hr));
                goto CleanUp;
            }
        }

    }
    else
    {
        ASSERT(amRenderTransport == AM_OVERLAY);

        SurfaceDesc.dwFlags |= DDSD_PIXELFORMAT;

        // store the caps and dimensions
        SurfaceDesc.ddsCaps.dwCaps = DDSCAPS_OVERLAY | DDSCAPS_VIDEOMEMORY;

        // define the pixel format
        SurfaceDesc.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);

        if (pHeader->biCompression <= BI_BITFIELDS &&
            m_pFilter->GetDisplay()->GetDisplayDepth() <= pHeader->biBitCount)
        {
            SurfaceDesc.ddpfPixelFormat.dwFourCC = BI_RGB;
            SurfaceDesc.ddpfPixelFormat.dwFlags = DDPF_RGB;
            SurfaceDesc.ddpfPixelFormat.dwRGBBitCount = pHeader->biBitCount;

            // Store the masks in the DDSURFACEDESC
            const DWORD *pBitMasks = GetBitMasks(pMediaType);
            ASSERT(pBitMasks);
            SurfaceDesc.ddpfPixelFormat.dwRBitMask = pBitMasks[0];
            SurfaceDesc.ddpfPixelFormat.dwGBitMask = pBitMasks[1];
            SurfaceDesc.ddpfPixelFormat.dwBBitMask = pBitMasks[2];
        }
        else if (pHeader->biCompression > BI_BITFIELDS &&
            pHeader->biCompression == amFourCCMap.GetFOURCC())
        {
            SurfaceDesc.ddpfPixelFormat.dwFourCC = pHeader->biCompression;
            SurfaceDesc.ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            SurfaceDesc.ddpfPixelFormat.dwYUVBitCount = pHeader->biBitCount;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("Supplied mediatype not suitable for either YUV or RGB surfaces")));
            hr = E_FAIL;
            goto CleanUp;
        }

        if (NeedToFlipOddEven(dwInterlaceFlags, 0, NULL))
            dwMinBufferCount = 1;
        else
            dwMinBufferCount = 0;

        // Create the overlay surface

        // Don't flip for motion compensation surfaces
        // This bypasses a bug in the current ATI Rage Pro driver
        if (pHeader->biCompression == MAKEFOURCC('M', 'C', '1', '2'))
        {
            NOTE("Don't flip for motion compensation surfaces");
            *pdwMaxBufferCount = 1;

            dwMinBufferCount = 0;
        }

        //  Initialize hr in case dwMinBufferCount >= *pdwMaxBufferCount (was
        //  for Zoran in the motion comp case)
        hr = E_OUTOFMEMORY;
        for (dwTotalBufferCount = *pdwMaxBufferCount; dwTotalBufferCount > dwMinBufferCount; dwTotalBufferCount--)
        {
            if (dwTotalBufferCount > 1)
            {
                SurfaceDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
                SurfaceDesc.ddsCaps.dwCaps &= ~DDSCAPS_NONLOCALVIDMEM;
                SurfaceDesc.ddsCaps.dwCaps |= DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_LOCALVIDMEM;
                SurfaceDesc.dwBackBufferCount = dwTotalBufferCount-1;
            }
            else
            {
                SurfaceDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
                SurfaceDesc.ddsCaps.dwCaps &= ~(DDSCAPS_FLIP | DDSCAPS_COMPLEX);
                SurfaceDesc.ddsCaps.dwCaps &= ~DDSCAPS_NONLOCALVIDMEM;
                SurfaceDesc.ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                SurfaceDesc.dwBackBufferCount = 0;
            }

            DbgLog((LOG_TRACE,2, TEXT("Creating surf with %#X DDObj"),pDirectDraw));
            hr = pDirectDraw->CreateSurface(&SurfaceDesc, ppDDrawSurface, NULL);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,1, TEXT("Function CreateSurface failed in Video memory, BackBufferCount = %d, hr = 0x%x"),
                    dwTotalBufferCount-1, hr));
            }
            if (SUCCEEDED(hr))
            {
                break;
            }

            SurfaceDesc.ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
            SurfaceDesc.ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;

            hr = pDirectDraw->CreateSurface(&SurfaceDesc, ppDDrawSurface, NULL);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,1, TEXT("Function CreateSurface failed in AGP memory, BackBufferCount = %d, hr = 0x%x"),
                    dwTotalBufferCount-1, hr));
            }
            if (SUCCEEDED(hr))
            {
                break;
            }
        }

        // if failed to create an overlay surface, bail out
        if (FAILED(hr))
        {
#if defined(DEBUG)
            if (pHeader->biCompression > BI_BITFIELDS) {
                DbgLog((LOG_ERROR, 0, TEXT("Failed to create an overlay surface %4.4s"), &pHeader->biCompression));
            }
            else {
                DbgLog((LOG_ERROR, 0, TEXT("Failed to create an overlay surface RGB")));
            }
#endif
            DbgLog((LOG_ERROR, 0, TEXT("Failed to create an overlay surface")));
            goto CleanUp;
        }

        ASSERT(dwTotalBufferCount > 0);
        m_dwBackBufferCount = dwTotalBufferCount-1;
        *pdwMaxBufferCount = dwTotalBufferCount;
    }
    m_dwDirectDrawSurfaceWidth = SurfaceDesc.dwWidth;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::CreateDDrawSurface")));
    return hr;
}

HRESULT COMInputPin::OnDisplayChange()
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::OnDisplayChange")));

    CAutoLock cLock(m_pFilterLock);

    if (m_RenderTransport != AM_VIDEOPORT && m_RenderTransport != AM_IOVERLAY)
    {
        // notify the sync object about the change
        hr = m_pSyncObj->OnDisplayChange();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pSyncObj->OnDisplayChange failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::OnDisplayChange")));
    return hr;
}


// this function is used to restore the ddraw surface. In the videoport case, we just recreate
// the whole thing from scratch.
HRESULT COMInputPin::RestoreDDrawSurface()
{
    HRESULT hr = NOERROR;

    if (m_RenderTransport == AM_VIDEOPORT)
    {
        // stop the video
        m_pIVPObject->Inactive();
        // don't have to give up the IVPConfig interface here
        m_pIVPObject->BreakConnect(TRUE);
        // redo the connection process
        hr = m_pIVPObject->CompleteConnect(NULL, TRUE);
        goto CleanUp;
    }

    if (!m_pDirectDrawSurface)
    {
        goto CleanUp;
    }

    if (m_pDirectDrawSurface->IsLost() == DDERR_SURFACELOST)
    {
        hr = m_pDirectDrawSurface->Restore();
        if (FAILED(hr))
        {
            goto CleanUp;
        }
        // paint the ddraw surface black
        hr = PaintDDrawSurfaceBlack(m_pDirectDrawSurface);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("PaintDDrawSurfaceBlack FAILED, hr = 0x%x"), hr));
            // not being able to paint the ddraw surface black is not a fatal error
            hr = NOERROR;
        }
    }

CleanUp:
    return hr;
}


// Both the Src and the Dest rects go throught a series of transformations the order of which is
// significant.
// Initial Rect ----> Compensation for IVideoWindow rects ---> Compensation for local pin coords (m_rRelPos)
// ----> Compensation for aspect ratio ----> Compensation for cropping rect specified in the mediatype ---->
// Compensation for the interlaced video (only for src rect)

// the rcSource and rcTarget specified in the mediatype have to be transformed into the scaling/cropping
// matrices. This is because the zoom done by IBasicVideo should be applied only to the scaling matrix and
// not the cropping one.

HRESULT COMInputPin::CalcSrcDestRect(
    const DRECT *prdRelativeSrcRect,  //  This is the subset of the source
                                      //  defined by the IVideoWindow source
                                      //  rect scaled to a subset of 10000x10000
                                      //  assuming the whole source is 10000x10000
    const DRECT *prdDestRect,         //  This is the dest rect
                                      //  defined by IVideoWindow in dest units
    RECT *prAdjustedSrcRect,          //  This is the new source rect in source rect units
    RECT *prAdjustedDestRect,         //  This is the new dest rect in dest rect units
    RECT *prUncroppedDestRect         //  This is the uncropped dest
)
{
    HRESULT hr = NOERROR;
    DRECT  rdLocalSrcRect, rdLocalDestRect, rdCropMediaTypeRect, rdRelativeSrcClipRect, rdOldLocalSrcRect, rdOldLocalDestRect, rdRelPos;
    double dImageWidth = 0, dImageHeight = 0;
    double dPixelAspectRatio = 0.0, dTransformRatio = 0.0;
    AM_ASPECT_RATIO_MODE amAdjustedARMode = AM_ARMODE_STRETCHED;
    DWORD dwAdjustedPARatioX = 0, dwAdjustedPARatioY = 0;

    DbgLog((LOG_TRACE, 5,TEXT("Entering COMInputPin::CalcSrcDestRect")));

    SetRect(&rdLocalSrcRect, 0, 0, 0, 0);
    SetRect(&rdLocalDestRect, 0, 0, 0, 0);
    SetRect(&rdCropMediaTypeRect, 0, 0, 0, 0);
    SetRect(&rdRelativeSrcClipRect, 0, 0, 0, 0);
    SetRect(&rdOldLocalSrcRect, 0, 0, 0, 0);
    SetRect(&rdOldLocalDestRect, 0, 0, 0, 0);


    DbgLog((LOG_TRACE, 2, TEXT("m_dwPinId = %d"), m_dwPinId));
    DbgLogRectMacro((2, TEXT("prdRelativeSrcRect = "), prdRelativeSrcRect));
    DbgLogRectMacro((2, TEXT("prdDestRect = "), prdDestRect));

    SetRect(&rdRelPos, m_rRelPos.left, m_rRelPos.top, m_rRelPos.right, m_rRelPos.bottom);

    DbgLogRectMacro((2, TEXT("rdRelPos = "), &rdRelPos));

    // get the scale and crop rects from the current mediatype
    hr = GetScaleCropRectsFromMediaType(&m_mtNewAdjusted, &rdLocalSrcRect, &rdCropMediaTypeRect);
    ASSERT(SUCCEEDED(hr));

    DbgLogRectMacro((2, TEXT("rdScaledSrcRect = "), &rdLocalSrcRect));
    DbgLogRectMacro((2, TEXT("rdCropMediaTypeRect = "), &rdCropMediaTypeRect));

    // call this function to get the adjusted aspect ratio mode and the adjusted picture aspect ratio numbers
    hr = GetAdjustedModeAndAspectRatio(&amAdjustedARMode, &dwAdjustedPARatioX, &dwAdjustedPARatioY);
    if ( FAILED(hr) )
        return hr;

    dImageWidth = GetWidth(&rdLocalSrcRect);
    dImageHeight = GetHeight(&rdLocalSrcRect);

    // compute the pixel aspect ratio
    dPixelAspectRatio = ((double)dwAdjustedPARatioX / (double)dwAdjustedPARatioY) /
        (dImageWidth / dImageHeight);

    // Both the src and the dest rect depends upon two things, which portion of the total
    // video does the user want to see (determined by pRelativeSrcRect) and which
    // subrect of the destination is this pin outputting to (determined by m_rRelPos).
    // Since both rects are relative and their "base" is MAX_REL_NUM, we can take
    // their intersection
    IntersectRect(&rdRelativeSrcClipRect, &rdRelPos, prdRelativeSrcRect);

    // Clip the src rect in the same proportion as the intersection of the
    // RelativeSrcRect and m_rRelPos clips m_rRelPos
    CalcSrcClipRect(&rdLocalSrcRect, &rdLocalSrcRect, &rdRelPos, &rdRelativeSrcClipRect);

    // Clip the dest rect in the same proportion as the intersection of the
    // RelativeSrcRect and m_rRelPos clips RelativeSrcRect
    // if pRelativeSrcRect = {0, 0, 10000, 10000} then this operation is equivalent to
    // rLocalDestRect = CalcSubRect(pDestRect, &m_rRelPos);
    CalcSrcClipRect(prdDestRect, &rdLocalDestRect, prdRelativeSrcRect, &rdRelativeSrcClipRect);

    DbgLogRectMacro((2, TEXT("rdLocalSrcRect = "), &rdLocalSrcRect));
    DbgLogRectMacro((2, TEXT("rdLocalDestRect = "), &rdLocalDestRect));

    // if one dimension is zero, might as well as make the whole rect
    // empty. Then the callee can just check for that
    if ((GetWidth(&rdLocalSrcRect) < 1) || (GetHeight(&rdLocalSrcRect) < 1))
        SetRect(&rdLocalSrcRect, 0, 0, 0, 0);
    if ((GetWidth(&rdLocalDestRect) < 1) || (GetHeight(&rdLocalDestRect) < 1))
        SetRect(&rdLocalSrcRect, 0, 0, 0, 0);

    if (!IsRectEmpty(&rdLocalSrcRect) && !IsRectEmpty(&rdLocalDestRect))
    {
        if (amAdjustedARMode == AM_ARMODE_LETTER_BOX)
        {
            // compute the transform ratio
	    dTransformRatio = (GetWidth(&rdLocalSrcRect)/GetHeight(&rdLocalSrcRect))*dPixelAspectRatio;

            // if we are in letter-box then shrink the destination rect appropriately
            // Note that essedntially the ratio of the WidthTOHeightRatio of dest rect to the
            // WidthTOHeightRatio of src rect must always be the pixel aspect ratio
            TransformRect(&rdLocalDestRect, dTransformRatio, AM_SHRINK);
        }
        else if (amAdjustedARMode == AM_ARMODE_CROP)
        {
            // compute the transform ratio
            dTransformRatio = (GetWidth(&rdLocalDestRect)/GetHeight(&rdLocalDestRect))/dPixelAspectRatio;

            // if we are cropping, then we must shrink the source rectangle appropriately.
            // Note that essedntially the ratio of the WidthTOHeightRatio of dest rect to the
            // WidthTOHeightRatio of src rect must always be the pixel aspect ratio
            TransformRect(&rdLocalSrcRect, dTransformRatio, AM_SHRINK);
        }



        rdOldLocalSrcRect = rdLocalSrcRect;
        rdOldLocalDestRect = rdLocalDestRect;

        // now intersect the local src rect with the cropping rect specified by the mediatype
        IntersectRect(&rdLocalSrcRect, &rdLocalSrcRect, &rdCropMediaTypeRect);

        // Clip the dest rect in the same proportion as the intersection of the
        // rLocalSrcRect and rCropMediaTypeRect clips rLocalSrcRect
        CalcSrcClipRect(&rdLocalDestRect, &rdLocalDestRect, &rdOldLocalSrcRect, &rdLocalSrcRect);

        DbgLogRectMacro((2, TEXT("rdLocalSrcRect = "), &rdLocalSrcRect));
        DbgLogRectMacro((2, TEXT("rdLocalDestRect = "), &rdLocalDestRect));
    }

    if (DisplayingFields(m_dwInterlaceFlags) && !IsRectEmpty(&rdLocalSrcRect))
    {
        ScaleRect(&rdLocalSrcRect, GetWidth(&rdLocalSrcRect), GetHeight(&rdLocalSrcRect),
            GetWidth(&rdLocalSrcRect), GetHeight(&rdLocalSrcRect)/2.0);
    }

    if (prAdjustedSrcRect)
    {
        *prAdjustedSrcRect = MakeRect(rdLocalSrcRect);
    }
    if (prAdjustedDestRect)
    {
        *prAdjustedDestRect = MakeRect(rdLocalDestRect);
    }
    if (prUncroppedDestRect)
    {
        *prUncroppedDestRect = MakeRect(rdOldLocalDestRect);
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::CalcSrcDestRect")));

    return hr;
}


// informs the pin that the window has been closed
HRESULT COMInputPin::OnClipChange(LPWININFO pWinInfo)
{
    HRESULT hr = NOERROR;
    BOOL bAdvisePending = FALSE;
    LPDIRECTDRAWSURFACE pPrimarySurface = NULL;
    LPDDCAPS pDirectCaps = NULL;
    COLORKEY *pColorKey = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::OnClipChange")));

    {
        CAutoLock cLock(m_pFilterLock);

        if (m_RenderTransport == AM_OVERLAY ||
            m_RenderTransport == AM_OFFSCREEN ||
            m_RenderTransport == AM_VIDEOPORT ||
            m_RenderTransport == AM_IOVERLAY ||
            m_RenderTransport == AM_VIDEOACCELERATOR)
        {
            pPrimarySurface = m_pFilter->GetPrimarySurface();
            if ( NULL == pPrimarySurface )
            {
                DbgLog((LOG_ERROR, 2, TEXT("Could not get primary")));
                hr = E_FAIL;
                goto CleanUp;
            }

            pDirectCaps = m_pFilter->GetHardwareCaps();
            if ( NULL == pDirectCaps )
            {
                DbgLog((LOG_ERROR, 2, TEXT("Could not get DirectDraw caps")));
                hr = E_FAIL;
                goto CleanUp;
            }

            pColorKey = m_pFilter->GetColorKeyPointer();
            if ( NULL == pColorKey )
            {
                DbgLog((LOG_ERROR, 2, TEXT("Could not get color key")));
                hr = E_FAIL;
                goto CleanUp;
            }
        }

        if (m_RenderTransport == AM_OFFSCREEN || m_RenderTransport == AM_GDI)
        {
            if (m_bOverlayHidden)
            {
                DbgLog((LOG_TRACE, 2, TEXT("m_bOverlayHidden is TRUE")));
                goto CleanUp;
            }
            // make a copy of the WININFO so that we can modify it
            m_WinInfo.TopLeftPoint = pWinInfo->TopLeftPoint;
            m_WinInfo.SrcRect = pWinInfo->SrcRect;
            m_WinInfo.DestRect = pWinInfo->DestRect;
            m_WinInfo.SrcClipRect = pWinInfo->SrcClipRect;
            m_WinInfo.DestClipRect = pWinInfo->DestClipRect;
            CombineRgn(m_WinInfo.hClipRgn, pWinInfo->hClipRgn, NULL, RGN_COPY);

            DoRenderSample(NULL);
        }
        else if (m_RenderTransport == AM_OVERLAY ||
                 m_RenderTransport == AM_VIDEOPORT ||
                 m_RenderTransport == AM_VIDEOACCELERATOR)
        {

            // do not show the overlay if we have not received a frame yet
            if (m_bOverlayHidden)
            {
                COLORKEY blackColorKey;
                // we will use black on the rest of the region left
                blackColorKey.KeyType = CK_INDEX | CK_RGB;
                blackColorKey.PaletteIndex = 0;
                blackColorKey.LowColorValue = blackColorKey.HighColorValue = RGB(0,0,0);
                hr = m_pFilter->PaintColorKey(pWinInfo->hClipRgn, &blackColorKey);

                DbgLog((LOG_TRACE, 2, TEXT("m_bOverlayHidden is TRUE")));
                goto CleanUp;

            }
            // paint the colorkey in the region
            DbgLog((LOG_TRACE, 2, TEXT("Painting color key")));
            hr = m_pFilter->PaintColorKey(pWinInfo->hClipRgn, pColorKey);
            ASSERT(SUCCEEDED(hr));


            if (m_RenderTransport == AM_VIDEOPORT)
            {
                // tell the videoport object
                hr = m_pIVPObject->OnClipChange(pWinInfo);
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->OnClipChange failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
                goto CleanUp;
            }

            if (!m_pDirectDrawSurface)
            {
                DbgLog((LOG_ERROR, 1, TEXT("OnClipChange, m_pDirectDrawSurface = NULL")));
                goto CleanUp;
            }

            // if the dest empty is empty just hide the overlay
            if (IsRectEmpty(&pWinInfo->DestClipRect))
            {
                hr = m_pFilter->CallUpdateOverlay(
                          m_pDirectDrawSurface,
                          NULL,
                          pPrimarySurface,
                          NULL,
                          DDOVER_HIDE);
                goto CleanUp;
            }

            // make a copy of the WININFO so that we can modify it
            m_WinInfo.SrcRect = pWinInfo->SrcRect;
            m_WinInfo.DestRect = pWinInfo->DestRect;
            m_WinInfo.SrcClipRect = pWinInfo->SrcClipRect;
            m_WinInfo.DestClipRect = pWinInfo->DestClipRect;
            CombineRgn(m_WinInfo.hClipRgn, pWinInfo->hClipRgn, NULL, RGN_COPY);

            //AdjustSourceSize(&m_WinInfo, m_dwMinCKStretchFactor);
            ApplyDecimation(&m_WinInfo);

            CalcSrcClipRect(&m_WinInfo.SrcRect, &m_WinInfo.SrcClipRect,
                            &m_WinInfo.DestRect, &m_WinInfo.DestClipRect,
                            TRUE);

            AlignOverlaySrcDestRects(pDirectCaps,
                                    &m_WinInfo.SrcClipRect,
                                    &m_WinInfo.DestClipRect);

            hr = m_pFilter->CallUpdateOverlay(
                                     m_pDirectDrawSurface,
                                     &m_WinInfo.SrcClipRect,
                                     pPrimarySurface,
                                     &m_WinInfo.DestClipRect,
                                     m_dwUpdateOverlayFlags,
                                     NULL);

        }
        else if (m_RenderTransport == AM_IOVERLAY)
        {
            BOOL bMaintainRatio = TRUE;

            // paint the colorkey in the region
            DbgLog((LOG_TRACE, 2, TEXT("Paint color key for IOverlay")));
            hr = m_pFilter->PaintColorKey(pWinInfo->hClipRgn, pColorKey);
            ASSERT(SUCCEEDED(hr));

            // make a copy of the WININFO so we can notify the client through IOverlayNotify
            m_WinInfo.SrcRect = pWinInfo->SrcRect;
            m_WinInfo.DestRect = pWinInfo->DestRect;
            m_WinInfo.SrcClipRect = pWinInfo->SrcClipRect;
            m_WinInfo.DestClipRect = pWinInfo->DestClipRect;
            CombineRgn(m_WinInfo.hClipRgn, pWinInfo->hClipRgn, NULL, RGN_COPY);

            CalcSrcClipRect(&m_WinInfo.SrcRect, &m_WinInfo.SrcClipRect,
                            &m_WinInfo.DestRect, &m_WinInfo.DestClipRect,
                            bMaintainRatio);

            bAdvisePending = TRUE;
        }
    }

    // make sure the call back happens without any filter lock
    if (bAdvisePending)
    {
        NotifyChange(ADVISE_POSITION | ADVISE_CLIPPING);
    }
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::OnClipChange")));
    return hr;
}

// this function sets the position of the stream in the display window, assuming
// that the window coordinates are {0, 0, 10000, 10000}. Thus giving arguments
// (0, 0, 5000, 5000) will put the stream in the top-left quarter. Any value greater
// than 10000 is invalid.
STDMETHODIMP COMInputPin::SetRelativePosition(DWORD dwLeft, DWORD dwTop, DWORD dwRight, DWORD dwBottom)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetRelativePosition")));

    if (dwLeft > MAX_REL_NUM || dwTop > MAX_REL_NUM || dwRight > MAX_REL_NUM || dwBottom > MAX_REL_NUM ||
        dwRight < dwLeft || dwBottom < dwTop)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid arguments, dwLeft = %d, dwTop = %d, dwRight = %d, dwBottom = %d"),
            dwLeft, dwTop, dwRight, dwBottom));

        hr = E_INVALIDARG;
        goto CleanUp;
    }


    {
        CAutoLock cLock(m_pFilterLock);
        if (m_rRelPos.left != (LONG)dwLeft || m_rRelPos.top != (LONG)dwTop || m_rRelPos.right != (LONG)dwRight || m_rRelPos.bottom != (LONG)dwBottom)
        {
            m_rRelPos.left = dwLeft;
            m_rRelPos.top = dwTop;
            m_rRelPos.right = dwRight;
            m_rRelPos.bottom = dwBottom;

            // make sure that the video frame gets updated by redrawing everything
            EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetRelativePosition")));
    return hr;
}

// this function sets the position of the stream in the display window, assuming
// that the window coordinates are {0, 0, 10000, 10000}. Thus giving arguments
// (0, 0, 5000, 5000) will put the stream in the top-left quarter. Any value greater
// than 10000 is invalid.
STDMETHODIMP COMInputPin::GetRelativePosition(DWORD *pdwLeft, DWORD *pdwTop, DWORD *pdwRight, DWORD *pdwBottom)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetRelativePosition")));

    if (!pdwLeft || !pdwTop || !pdwRight || !pdwBottom)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid arguments, pdwLeft = 0x%x, pdwTop = 0x%x, pdwRight = 0x%x, pdwBottom = 0x%x"),
            pdwLeft, pdwTop, pdwRight, pdwBottom));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        CAutoLock cLock(m_pFilterLock);
        *pdwLeft = m_rRelPos.left;
        *pdwTop = m_rRelPos.top;
        *pdwRight = m_rRelPos.right;
        *pdwBottom = m_rRelPos.bottom;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetRelativePosition")));
    return hr;
}

STDMETHODIMP COMInputPin::SetZOrder(DWORD dwZOrder)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetZOrder")));

    CAutoLock cLock(m_pFilterLock);

    if (dwZOrder != m_dwZOrder)
    {
        m_dwZOrder = dwZOrder;

        m_dwInternalZOrder = (m_dwZOrder << 24) | m_dwPinId;

        // make sure that the video frame gets updated by redrawing everything
        EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetZOrder")));
    return NOERROR;
}


STDMETHODIMP COMInputPin::GetZOrder(DWORD *pdwZOrder)
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetZOrder")));

    if (pdwZOrder == NULL)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid arguments, pdwZOrder = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        //  No need to lock - getting a DWORD is safe
        *pdwZOrder = m_dwZOrder;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetZOrder")));
    return hr;
}

STDMETHODIMP COMInputPin::SetColorKey(COLORKEY *pColorKey)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetColorKey")));

    CAutoLock cLock(m_pFilterLock);

    if (m_dwPinId != 0)
    {
        hr = E_NOTIMPL;
        DbgLog((LOG_ERROR, 1, TEXT("m_dwPinId != 0, returning E_NOTIMPL")));
        goto CleanUp;
    }

    // make sure the pin is connected
    if (!IsCompletelyConnected())
    {
        DbgLog((LOG_ERROR, 1, TEXT("pin not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // make sure that either the surface allocated is an overlay surface
    // or it is an IOverlay connection
    if (m_RenderTransport != AM_OVERLAY && m_RenderTransport != AM_VIDEOPORT &&
        m_RenderTransport != AM_IOVERLAY && m_RenderTransport != AM_VIDEOACCELERATOR)
    {
        DbgLog((LOG_ERROR, 1, TEXT("surface allocated not overlay && connection not videoport && connection not IOverlay, exiting")));
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

    if (!IsStopped())
    {
        hr = VFW_E_NOT_STOPPED;
        DbgLog((LOG_ERROR, 1, TEXT("not stopped, returning VFW_E_NOT_STOPPED")));
        goto CleanUp;
    }

    //  Filter method checks pointers etc
    hr = m_pFilter->SetColorKey(pColorKey);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->SetColorKey(pColorKey) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
    NotifyChange(ADVISE_COLORKEY);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetColorKey")));
    return hr;
}

STDMETHODIMP COMInputPin::GetColorKey(COLORKEY *pColorKey, DWORD *pColor)
{
    HRESULT hr = NOERROR;
    AM_RENDER_TRANSPORT amRenderTransport;
    COMInputPin *pPrimaryPin = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetColorKey")));

    CAutoLock cLock(m_pFilterLock);

    // make sure pointers are valid
    if (!pColorKey && !pColor) {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // make sure the pin is connected
    if (!IsCompletelyConnected())
    {
        DbgLog((LOG_ERROR, 1, TEXT("pin not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // if this stream is being set up as transparent then make sure we can hande it.
    // make sure that in the primary pin either the surface allocated is an overlay surface
    // or it is an IOverlay connection
    pPrimaryPin = (COMInputPin *)m_pFilter->GetPin(0);
    ASSERT(pPrimaryPin);

    // make sure the primary pin is connected
    if (!pPrimaryPin->IsCompletelyConnected())
    {
        DbgLog((LOG_ERROR, 1, TEXT("pin not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // get the Render Transport of the primary pin
    pPrimaryPin->GetRenderTransport(&amRenderTransport);

    // make sure gettting the colorkey makes sense
    if (amRenderTransport != AM_OVERLAY &&
        amRenderTransport != AM_VIDEOPORT &&
        amRenderTransport != AM_IOVERLAY &&
        amRenderTransport != AM_VIDEOACCELERATOR)
    {
        DbgLog((LOG_ERROR, 1, TEXT("primary pin: surface allocated not overlay && connection not videoport && connection not IOverlay, exiting")));
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

    hr = m_pFilter->GetColorKey(pColorKey, pColor);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->GetColorKey(pColorKey, pColor) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }


CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetColorKey")));
    return hr;
}


STDMETHODIMP COMInputPin::SetBlendingParameter(DWORD dwBlendingParameter)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetBlendingParameter")));

    CAutoLock cLock(m_pFilterLock);

    if (m_dwPinId == 0)
    {
        DbgLog((LOG_ERROR, 1, TEXT("this call not expected on the pin using the overlay surface")));
        hr = E_NOTIMPL;
        goto CleanUp;
    }

    if ( dwBlendingParameter > MAX_BLEND_VAL)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of dwBlendingParameteris invalid, dwBlendingParameter = %d"), dwBlendingParameter));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (dwBlendingParameter != 0 && dwBlendingParameter != MAX_BLEND_VAL)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of dwBlendingParameteris invalid, currently only valid values are 0 and MAX_BLEND_VAL, dwBlendingParameter = %d"), dwBlendingParameter));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (dwBlendingParameter != m_dwBlendingParameter)
    {
        m_dwBlendingParameter = dwBlendingParameter;
        // make sure that the video frame gets updated by redrawing everything
        EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetBlendingParameter")));
    return hr;
}

STDMETHODIMP COMInputPin::GetBlendingParameter(DWORD *pdwBlendingParameter)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetBlendingParameter")));

    if (!pdwBlendingParameter)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of pdwBlendingParameteris invalid, pdwBlendingParameter = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;

    }

    {
        CAutoLock cLock(m_pFilterLock);
        *pdwBlendingParameter = m_dwBlendingParameter;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetBlendingParameter")));
    return hr;
}

STDMETHODIMP COMInputPin::SetStreamTransparent(BOOL bStreamTransparent)
{
    HRESULT hr = NOERROR;
    AM_RENDER_TRANSPORT amRenderTransport;
    COMInputPin *pPrimaryPin = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetStreamTransparent")));

    CAutoLock cLock(m_pFilterLock);

    if (m_dwPinId == 0)
    {
        DbgLog((LOG_ERROR, 1, TEXT("this call not expected on the pin using the overlay surface")));
        hr = E_NOTIMPL;
        goto CleanUp;
    }

    // make sure the pin is connected
    if (!IsConnected())
    {
        DbgLog((LOG_ERROR, 1, TEXT("pin not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // if this stream is being set up as transparent then make sure we can hande it.
    // make sure that in the primary pin either the surface allocated is an overlay surface
    // or it is an IOverlay connection

    pPrimaryPin = (COMInputPin *)m_pFilter->GetPin(0);
    ASSERT(pPrimaryPin);

    // make sure the primary pin is connected
    if (!pPrimaryPin->IsCompletelyConnected())
    {
        DbgLog((LOG_ERROR, 1, TEXT("pin not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // get the Render Transport of the primary pin
    pPrimaryPin->GetRenderTransport(&amRenderTransport);

    // make sure we can handle transparent streams
    if (bStreamTransparent && amRenderTransport != AM_OVERLAY && amRenderTransport != AM_VIDEOPORT &&
        amRenderTransport != AM_IOVERLAY && amRenderTransport != AM_VIDEOACCELERATOR)
    {
        DbgLog((LOG_ERROR, 1, TEXT("primary pin: surface allocated not overlay && connection not videoport && connection not IOverlay, exiting")));
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

    if (bStreamTransparent != m_bStreamTransparent)
    {
        m_bStreamTransparent = bStreamTransparent;

        // make sure that the video frame gets updated by redrawing everything
        EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetBlendingParameter")));
    return hr;
}

STDMETHODIMP COMInputPin::GetStreamTransparent(BOOL *pbStreamTransparent)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetStreamTransparent")));

    if (!pbStreamTransparent)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of pbStreamTransparent invalid, pbStreamTransparent = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;

    }

    {
        CAutoLock cLock(m_pFilterLock);
        *pbStreamTransparent = m_bStreamTransparent;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetStreamTransparent")));
    return hr;
}


STDMETHODIMP COMInputPin::SetAspectRatioMode(AM_ASPECT_RATIO_MODE amAspectRatioMode)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetAspectRatioMode")));

    if (amAspectRatioMode != AM_ARMODE_STRETCHED &&
        amAspectRatioMode != AM_ARMODE_LETTER_BOX &&
        amAspectRatioMode != AM_ARMODE_CROP &&
        amAspectRatioMode != AM_ARMODE_STRETCHED_AS_PRIMARY)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of amAspectRatioMode invalid, amAspectRatioMode = %d"), amAspectRatioMode));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        CAutoLock cLock(m_pFilterLock);
        // can't set AM_ARMODE_STRETCHED_AS_PRIMARY on primary pin
        if (amAspectRatioMode == AM_ARMODE_STRETCHED_AS_PRIMARY &&
            m_dwPinId == 0)
        {
            DbgLog((LOG_ERROR, 1, TEXT("can't set AM_ARMODE_STRETCHED_AS_PRIMARY on primary pin")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }

        if (amAspectRatioMode != m_amAspectRatioMode)
        {
            m_amAspectRatioMode = amAspectRatioMode;

            // make sure that the video frame gets updated by redrawing everything
            EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetAspectRatioMode")));
    return hr;

}

HRESULT COMInputPin::GetAdjustedModeAndAspectRatio(AM_ASPECT_RATIO_MODE* pamAdjustedARMode, DWORD *pdwAdjustedPARatioX,
                                                        DWORD *pdwAdjustedPARatioY)
{
    HRESULT hr = NOERROR;
    COMInputPin *pPrimaryPin = NULL;
    AM_ASPECT_RATIO_MODE amAdjustedARMode = AM_ARMODE_STRETCHED;
    DWORD dwAdjustedPARatioX = 1, dwAdjustedPARatioY = 1;
    CMediaType CurrentMediaType;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetAdjustedModeAndAspectRatio")));

    CAutoLock cLock(m_pFilterLock);

    if (m_amAspectRatioMode == AM_ARMODE_STRETCHED_AS_PRIMARY)
    {
        pPrimaryPin = (COMInputPin *)m_pFilter->GetPin(0);
        ASSERT(pPrimaryPin);
        hr = pPrimaryPin->GetAspectRatioMode(&amAdjustedARMode);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("pPrimaryPin->GetAspectRatioMode failed, hr = 0x%x"), hr));
            hr = E_FAIL;
            goto CleanUp;
        }
        hr = pPrimaryPin->CurrentAdjustedMediaType(&CurrentMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("pPrimaryPin->CurrentAdjustedMediaType() failed, hr = 0x%x"), hr));
            hr = E_FAIL;
            goto CleanUp;
        }
    }
    else
    {
        amAdjustedARMode = m_amAspectRatioMode;
        hr = CurrentAdjustedMediaType(&CurrentMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("pPrimaryPin->CurrentAdjustedMediaType() failed, hr = 0x%x"), hr));
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }

    hr = GetPictAspectRatio(&CurrentMediaType, &dwAdjustedPARatioX, &dwAdjustedPARatioY);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetPictAspectRatio() failed, hr = 0x%x"), hr));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (pamAdjustedARMode)
        *pamAdjustedARMode = amAdjustedARMode;
    if (pdwAdjustedPARatioX)
        *pdwAdjustedPARatioX = dwAdjustedPARatioX;
    if (pdwAdjustedPARatioY)
        *pdwAdjustedPARatioY = dwAdjustedPARatioY;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetAdjustedModeAndAspectRatio")));
    return hr;
}

STDMETHODIMP COMInputPin::GetAspectRatioMode(AM_ASPECT_RATIO_MODE* pamAspectRatioMode)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetAspectRatioMode")));

    if (!pamAspectRatioMode)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of pamAspectRatioMode is invalid, pamAspectRatioMode = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;

    }

    {
        CAutoLock cLock(m_pFilterLock);
        *pamAspectRatioMode = m_amAspectRatioMode;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetAspectRatioMode")));
    return hr;
}


STDMETHODIMP COMInputPin::GetOverlaySurface(
    LPDIRECTDRAWSURFACE *pOverlaySurface
    )
{
    HRESULT hr = S_OK;

    *pOverlaySurface = NULL;

    // if not connected, this function does not make much sense since the
    // surface wouldn't even have been allocated as yet

    if (!IsCompletelyConnected())
    {
        DbgLog((LOG_ERROR, 1, TEXT("pin not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // make sure the surface allocated is an overlay surface
    if (m_RenderTransport != AM_OVERLAY && m_RenderTransport != AM_VIDEOPORT &&
        m_RenderTransport != AM_VIDEOACCELERATOR)
    {
        DbgLog((LOG_ERROR, 1, TEXT("surface allocated is not overlay, exiting")));
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

    // get the overlay surface
    if (m_RenderTransport == AM_VIDEOPORT)
    {
        ASSERT(m_pIVPObject);
        hr = m_pIVPObject->GetDirectDrawSurface(pOverlaySurface);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->GetDirectDrawSurface() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        *pOverlaySurface = m_pDirectDrawSurface;
    }

CleanUp:
    return hr;
}


STDMETHODIMP COMInputPin::SetOverlaySurfaceColorControls(LPDDCOLORCONTROL pColorControl)
{
    HRESULT hr = NOERROR;
    LPDIRECTDRAWSURFACE pOverlaySurface = NULL;
    LPDIRECTDRAWCOLORCONTROL pIDirectDrawControl = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetOverlaySurfaceColorControls")));

    CAutoLock cLock(m_pFilterLock);

    // make sure the argument is valid
    if (!pColorControl)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of pColorControl is invalid, pColorControl = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    hr = GetOverlaySurface(&pOverlaySurface);
    if (FAILED(hr)) {
        goto CleanUp;
    }

    // get the IDirectDrawColorControl interface
    hr = pOverlaySurface->QueryInterface(IID_IDirectDrawColorControl, (void**)&pIDirectDrawControl);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface->QueryInterface(IID_IDirectDrawColorControl) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // use the interface to set the color controls
    hr = pIDirectDrawControl->SetColorControls(pColorControl);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pIDirectDrawControl->SetColorControls failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    if (pIDirectDrawControl)
    {
        pIDirectDrawControl->Release();
        pIDirectDrawControl = NULL;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetOverlaySurfaceColorControls")));
    return hr;
}

STDMETHODIMP COMInputPin::GetOverlaySurfaceColorControls(LPDDCOLORCONTROL pColorControl)
{
    HRESULT hr = NOERROR;
    LPDIRECTDRAWSURFACE pOverlaySurface = NULL;
    LPDIRECTDRAWCOLORCONTROL pIDirectDrawControl = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetOverlaySurfaceColorControls")));

    CAutoLock cLock(m_pFilterLock);

    // make sure the argument is valid
    if (!pColorControl)
    {
        DbgLog((LOG_ERROR, 1, TEXT("value of pColorControl is invalid, pColorControl = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // if not connected, this function does not make much sense since the surface wouldn't even have been allocated
    // as yet
    if (!m_bConnected)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pin not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // make sure the surface allocated is an overlay surface
    if (m_RenderTransport != AM_OVERLAY && m_RenderTransport != AM_VIDEOPORT && m_RenderTransport != AM_VIDEOACCELERATOR)
    {
        DbgLog((LOG_ERROR, 1, TEXT("surface allocated is not overlay, exiting")));
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

    // get the overlay surface
    if (m_RenderTransport == AM_VIDEOPORT)
    {
        ASSERT(m_pIVPObject);
        hr = m_pIVPObject->GetDirectDrawSurface(&pOverlaySurface);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->GetDirectDrawSurface() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        pOverlaySurface = m_pDirectDrawSurface;
    }

    // get the IDirectDrawColorControl interface
    hr = pOverlaySurface->QueryInterface(IID_IDirectDrawColorControl, (void**)&pIDirectDrawControl);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface->QueryInterface(IID_IDirectDrawColorControl) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // use the interface to set the color controls
    hr = pIDirectDrawControl->GetColorControls(pColorControl);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pIDirectDrawControl->SetColorControls failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    if (pIDirectDrawControl)
    {
        pIDirectDrawControl->Release();
        pIDirectDrawControl = NULL;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetOverlaySurfaceColorControls")));
    return hr;
}

STDMETHODIMP COMInputPin::GetRenderTransport(AM_RENDER_TRANSPORT *pamRenderTransport)
{
    ASSERT(pamRenderTransport);
    *pamRenderTransport = m_RenderTransport;
    return NOERROR;
}


HRESULT COMInputPin::GetSourceAndDest(RECT *prcSource, RECT *prcDest, DWORD *dwWidth, DWORD *dwHeight)
{
    if (m_RenderTransport == AM_VIDEOPORT)
    {
        m_pIVPObject->GetRectangles(prcSource, prcDest);
    }
    else
    {
        *prcSource = m_WinInfo.SrcClipRect;
        *prcDest = m_WinInfo.DestClipRect;
    }

    CMediaType mt;
    HRESULT hr = CurrentAdjustedMediaType(&mt);

    if (SUCCEEDED(hr))
    {
        BITMAPINFOHEADER *pHeader = GetbmiHeader(&mt);
        if ( ! pHeader )
        {
            hr = E_FAIL;
        }
        else
        {
            *dwWidth = abs(pHeader->biWidth);
            *dwHeight = abs(pHeader->biHeight);
        }
    }

    return hr;
}

HRESULT COMInputPin::NotifyChange(DWORD dwAdviseChanges)
{
    HRESULT hr = NOERROR;
    IOverlayNotify *pIOverlayNotify = NULL;
    DWORD dwAdvisePending = ADVISE_NONE;
    RECT rcSource, rcDest;
    LPRGNDATA pBuffer = NULL;
    COLORKEY ColorKey;
    DWORD dwNumPaletteEntries = 0;
    PALETTEENTRY *pPaletteEntries = NULL;
    HMONITOR hMonitor = NULL;


    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::NotifyChange")));

    {
        CAutoLock cLock(m_pFilterLock);

        // Is there a notification client
        if (m_pIOverlayNotify == NULL)
        {
            DbgLog((LOG_TRACE, 2, TEXT("No client to Notify, m_pIOverlayNotify = NULL")));
            goto CleanUp;
        }

        ASSERT(m_RenderTransport == AM_IOVERLAY);

        // addref the interface pointer
        pIOverlayNotify = m_pIOverlayNotify;

        // do we need a position change notification
        if (dwAdviseChanges & m_dwAdviseNotify & ADVISE_POSITION)
        {
            rcSource = m_WinInfo.SrcRect;
            rcDest = m_WinInfo.DestRect;
            dwAdvisePending |= ADVISE_POSITION;
        }

        // do we need a clipping change notification
        if (dwAdviseChanges & m_dwAdviseNotify & ADVISE_CLIPPING)
        {
            DWORD dwRetVal = 0, dwBuffSize = 0;
            HRESULT hrLocal = NOERROR;

            rcSource = m_WinInfo.SrcRect;
            rcDest = m_WinInfo.DestRect;

            dwRetVal = GetRegionData(m_WinInfo.hClipRgn, 0, NULL);
            if (0 == dwRetVal)
            {
                        DbgLog((LOG_ERROR, 1, TEXT("GetRegionData failed")));
                        hrLocal = E_FAIL;
            }

            if (SUCCEEDED(hrLocal))
            {
                dwBuffSize = dwRetVal;
                pBuffer = (LPRGNDATA) CoTaskMemAlloc(dwBuffSize);
                if (NULL == pBuffer)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("CoTaskMemAlloc failed, pBuffer = NULL")));
                    hrLocal = E_OUTOFMEMORY;
                }
            }
            if (SUCCEEDED(hrLocal))
            {
                dwRetVal = GetRegionData(m_WinInfo.hClipRgn, dwBuffSize, pBuffer);
                ASSERT(dwRetVal  &&  pBuffer->rdh.iType == RDH_RECTANGLES);
                dwAdvisePending |= ADVISE_CLIPPING;
            }
            else
            {
                hr = hrLocal;
            }
        }

        // do we need a colorkey change notification
        if (dwAdviseChanges & m_dwAdviseNotify & ADVISE_COLORKEY)
        {
            HRESULT hrLocal = NOERROR;
            dwAdvisePending |= ADVISE_COLORKEY;
            hrLocal = m_pFilter->GetColorKey(&ColorKey, NULL);
            ASSERT(SUCCEEDED(hrLocal));
        }

        // do we need a palette change notification
        if (dwAdviseChanges & m_dwAdviseNotify & ADVISE_PALETTE)
        {
            PALETTEENTRY *pTemp = NULL;
            HRESULT hrLocal = NOERROR;

            // get the palette entries from the filter
            hrLocal = m_pFilter->GetPaletteEntries(&dwNumPaletteEntries, &pTemp);
            if (FAILED(hrLocal))
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->GetPaletteEntries failed, hr = 0x%x"), hr));
            }
            if (SUCCEEDED(hrLocal))
            {
                ASSERT(dwNumPaletteEntries);
                pPaletteEntries = (PALETTEENTRY*) CoTaskMemAlloc(dwNumPaletteEntries * sizeof(PALETTEENTRY));
                ASSERT(pPaletteEntries);
                if (!pPaletteEntries)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("CoTaskMemAlloc failed, pPaletteEntries = NULL")));
                    hrLocal = E_OUTOFMEMORY;
                }
            }
            if (SUCCEEDED(hrLocal))
            {
                memcpy(pPaletteEntries, pTemp, (dwNumPaletteEntries * sizeof(PALETTEENTRY)));
                dwAdvisePending |= ADVISE_PALETTE;
            }
            else
            {
                hr = hrLocal;
            }
        }

        if (dwAdviseChanges & m_dwAdviseNotify & ADVISE_DISPLAY_CHANGE)
        {
            HWND hwnd = NULL;
            HRESULT hrLocal = NOERROR;

            hwnd = m_pFilter->GetWindow();
            if (hwnd)
            {
                hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONULL);
                if (!hMonitor)
                {
                    hrLocal = AmHresultFromWin32(GetLastError());
                    DbgLog((LOG_ERROR, 1, TEXT("MonitorFromWindow failed: %x"), hrLocal));
                }
            }
            else
            {
                hrLocal = E_FAIL;
            }

            if (SUCCEEDED(hrLocal))
            {
                dwAdvisePending |= ADVISE_DISPLAY_CHANGE;
            }
        }
    }

    {
        DWORD dwFlags = IsRectEmpty(&rcDest) ? DDOVER_HIDE : DDOVER_SHOW;

        // make sure that all callbacks are made without holding any filter locks
        if (dwAdvisePending & ADVISE_POSITION)
        {
            m_pFilter->CallUpdateOverlay(NULL, &rcSource, NULL, &rcDest, dwFlags, pIOverlayNotify);
        }
        if (dwAdvisePending & ADVISE_CLIPPING)
        {
            ASSERT(pBuffer);
            //  Call back to our exclusive mode client if there is one
            m_pFilter->CallUpdateOverlay(NULL, &rcSource, NULL, &rcDest, dwFlags, pIOverlayNotify, pBuffer);
        }
    }
    if (dwAdvisePending & ADVISE_COLORKEY)
    {
        pIOverlayNotify->OnColorKeyChange(&ColorKey);
    }
    if (dwAdvisePending & ADVISE_PALETTE)
    {
        ASSERT(pPaletteEntries);
        pIOverlayNotify->OnPaletteChange(dwNumPaletteEntries, pPaletteEntries);
    }
    if (dwAdvisePending & ADVISE_DISPLAY_CHANGE)
    {
        reinterpret_cast<IOverlayNotify2*>(pIOverlayNotify)->OnDisplayChange(hMonitor);
    }


CleanUp:
    if (pBuffer)
    {
        CoTaskMemFree(pBuffer);
        pBuffer = NULL;
    }
    if (pPaletteEntries)
    {
        CoTaskMemFree(pPaletteEntries);
        pPaletteEntries = NULL;
    }
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::NotifyChange")));
    return hr;
}

STDMETHODIMP COMInputPin::GetWindowHandle(HWND *pHwnd)
{
    AMTRACE((TEXT("COMInputPin::GetWindowHandle")));

    HRESULT hr = NOERROR;
    if (pHwnd) {
        *pHwnd = m_pFilter->GetWindow();
    }
    else hr = E_POINTER;

    return hr;
}

STDMETHODIMP COMInputPin::GetClipList(RECT *pSourceRect, RECT *pDestinationRect, RGNDATA **ppRgnData)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetClipList")));

    if (!pSourceRect || !pDestinationRect || !ppRgnData)
    {
        DbgLog((LOG_ERROR, 1, TEXT("invalid argument, pSourceRect or pDestinationRect or ppRgnData = NULL")));
        hr =  E_POINTER;
        goto CleanUp;
    }

    {
        LPRGNDATA pBuffer = NULL;
        DWORD dwRetVal = 0, dwBuffSize = 0;

        CAutoLock cLock(m_pFilterLock);

        dwRetVal = GetRegionData(m_WinInfo.hClipRgn, 0, NULL);
        if (!dwRetVal)
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        dwBuffSize = dwRetVal;
        pBuffer = (LPRGNDATA) CoTaskMemAlloc(dwBuffSize);
        ASSERT(pBuffer);

        dwRetVal = GetRegionData(m_WinInfo.hClipRgn, dwBuffSize, pBuffer);
        ASSERT(pBuffer->rdh.iType == RDH_RECTANGLES);

        *pSourceRect = m_WinInfo.SrcRect;
        *pDestinationRect = m_WinInfo.DestRect;
        *ppRgnData = pBuffer;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetClipList")));
    return hr;
}


// This returns the current source and destination video rectangles. Source
// rectangles can be updated through this IBasicVideo interface as can the
// destination. The destination rectangle we store is in window coordinates
// and is typically updated when the window is sized. We provide a callback
// OnPositionChanged that notifies the source when either of these changes
STDMETHODIMP COMInputPin::GetVideoPosition(RECT *pSourceRect, RECT *pDestinationRect)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetVideoPosition")));

    if (!pSourceRect || !pDestinationRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("invalid argument, pSourceRect or pDestinationRect = NULL")));
        hr =  E_POINTER;
        goto CleanUp;
    }

    {
        CAutoLock cLock(m_pFilterLock);
        *pSourceRect = m_WinInfo.SrcRect;
        *pDestinationRect = m_WinInfo.DestRect;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetVideoPosition")));
    return hr;
}


// When we create a new advise link we must prime the newly connected object
// with the overlay information which includes the clipping information, any
// palette information for the current connection and the video colour key
// When we are handed the IOverlayNotify interface we hold a reference count
// on that object so that it won't go away until the advise link is stopped
STDMETHODIMP COMInputPin::Advise(IOverlayNotify *pOverlayNotify,DWORD dwAdviseNotify)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Advise")));

    {
        CAutoLock cLock(m_pFilterLock);

        if (!pOverlayNotify)
        {
            DbgLog((LOG_ERROR, 1, TEXT("invalid argument, pOverlayNotify = NULL")));
            hr =  E_POINTER;
            goto CleanUp;
        }

        // Is there an advise link already defined
        if (m_pIOverlayNotify)
        {
            DbgLog((LOG_ERROR, 1, TEXT("Advise link already set")));
            hr = VFW_E_ADVISE_ALREADY_SET;
            goto CleanUp;
        }

        // Check they want at least one kind of notification
        if ((dwAdviseNotify & ADVISE_ALL) == 0)
        {
            DbgLog((LOG_ERROR, 1, TEXT("ADVISE_ALL failed")));
            hr = E_INVALIDARG;
        }

        // Initialise our overlay notification state
        // if the advise bits contain ADVISE_DISPLAY_CHANGE, then make sure to
        // QI the sink for IOverlayNotify2
        if (dwAdviseNotify & ADVISE_DISPLAY_CHANGE)
        {
            hr = pOverlayNotify->QueryInterface(IID_IOverlayNotify2, reinterpret_cast<PVOID*>(&m_pIOverlayNotify));
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("pOverlayNotify->QueryInterface(IID_IOverlayNotify2) failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
        else
        {
            m_pIOverlayNotify = pOverlayNotify;
            m_pIOverlayNotify->AddRef();
        }
        m_dwAdviseNotify = dwAdviseNotify;
    }

    NotifyChange(ADVISE_ALL);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Advise")));
    return hr;
}


// Close the advise link. Remove the associated link with the source, we release
// the interface pointer the filter gave us during the advise link creation.
STDMETHODIMP COMInputPin::Unadvise()
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::Unadvise")));

    CAutoLock cLock(m_pFilterLock);

    // Do we already have an advise link setup
    if (m_pIOverlayNotify == NULL)
    {
        hr = VFW_E_NO_ADVISE_SET;
        goto CleanUp;
    }

    // Release the notification interface
    ASSERT(m_pIOverlayNotify);
    m_pIOverlayNotify->Release();
    m_pIOverlayNotify = NULL;
    m_dwAdviseNotify = ADVISE_NONE;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::Unadvise")));
    return hr;
}


STDMETHODIMP COMInputPin::GetDefaultColorKey(COLORKEY *pColorKey)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetDefaultColorKey")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetDefaultColorKey")));
    return E_NOTIMPL;
}

STDMETHODIMP COMInputPin::GetPalette(DWORD *pdwColors,PALETTEENTRY **ppPalette)
{
    HRESULT hr = NOERROR;
    PALETTEENTRY *pPaletteEntries = NULL;
    DWORD dwNumPaletteEntries = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::GetPalette")));

    if (!pdwColors || !ppPalette)
    {
        DbgLog((LOG_ERROR, 1, TEXT("invalid pointer, pdwColors or ppPalette == NULL")));
        hr = E_POINTER;
        goto CleanUp;
    }

    // get the palette entries from the filter
    hr = m_pFilter->GetPaletteEntries(&dwNumPaletteEntries, &pPaletteEntries);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->GetPaletteEntries, hr = 0x%x"), hr));
        hr = VFW_E_NO_PALETTE_AVAILABLE;
        goto CleanUp;
    }

    ASSERT(dwNumPaletteEntries);
    ASSERT(pPaletteEntries);

    *pdwColors = dwNumPaletteEntries;

    // Allocate the memory for the system palette NOTE because the memory for
    // the palette is being passed over an interface to another object which
    // may or may not have been written in C++ we must use CoTaskMemAlloc

    *ppPalette = (PALETTEENTRY *) QzTaskMemAlloc(*pdwColors * sizeof(RGBQUAD));
    if (*ppPalette == NULL)
    {
        DbgLog((LOG_ERROR, 1, TEXT("No memory")));
        *pdwColors = 0;
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    memcpy(*ppPalette, pPaletteEntries, (*pdwColors * sizeof(RGBQUAD)));

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::GetPalette")));
    return hr;
}

STDMETHODIMP COMInputPin::SetPalette(DWORD dwColors,PALETTEENTRY *pPaletteColors)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMInputPin::SetPalette")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMInputPin::SetPalette")));
    return E_NOTIMPL;
}


STDMETHODIMP COMInputPin::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData,
                              LPVOID pPropData, DWORD cbPropData)
{
    CAutoLock cLock(m_pFilterLock);

    if (AMPROPSETID_NotifyOwner == guidPropSet)
    {
        if (AMPROPERTY_OvMixerOwner != dwPropID)
            return E_PROP_ID_UNSUPPORTED ;

        m_OvMixerOwner = *(AMOVMIXEROWNER *)pPropData;
    }
    else if (AM_KSPROPSETID_CopyProt == guidPropSet)
    {
        if (0 != GetPinId()  ||                         // on first in pin and
            dwPropID != AM_PROPERTY_COPY_MACROVISION)   // Macrovision prop set id only
            return E_PROP_ID_UNSUPPORTED ;

        if (pPropData == NULL)
            return E_INVALIDARG ;

        if (cbPropData < sizeof(DWORD))
            return E_INVALIDARG ;

        // Apply the Macrovision bits ONLY IF Overlay Mixer is supposed to,
        // i.e, we are playing back DVD in DDraw exclusive mode. Otherwise
        // Video Renderer is supposed to set the MV bits (two sets can fail
        // causing no playback).
        // If MV setting fails, return error.
        if (m_pFilter->NeedCopyProtect())
        {
            DbgLog((LOG_TRACE, 5, TEXT("OverlayMixer needs to copy protect")));
            if (! m_pFilter->m_MacroVision.SetMacroVision(*((LPDWORD)pPropData)) )
                return VFW_E_COPYPROT_FAILED ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("OverlayMixer DOES NOT need to copy protect")));
        }
    }
    else
            return E_PROP_SET_UNSUPPORTED ;

    return S_OK ;
}


STDMETHODIMP COMInputPin::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData,
                              LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    CAutoLock cLock(m_pFilterLock);

    if (guidPropSet == AMPROPSETID_NotifyOwner)
    {
        if (dwPropID != AMPROPERTY_OvMixerOwner)
            return E_PROP_ID_UNSUPPORTED;

        if (pPropData == NULL)
            return E_POINTER;

        if (cbPropData < sizeof(AMOVMIXEROWNER))
            return E_UNEXPECTED;

        *(AMOVMIXEROWNER*)pPropData = m_OvMixerOwner;
        if (pcbReturned!=NULL)
            *pcbReturned = sizeof(AMOVMIXEROWNER);
        return S_OK;
    }

    if (guidPropSet != AMPROPSETID_Pin)
        return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY && dwPropID != AMPROPERTY_PIN_MEDIUM)
        return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
        return E_POINTER;

    if (pcbReturned)
        *pcbReturned = ((dwPropID == AMPROPERTY_PIN_CATEGORY) ? sizeof(GUID) : sizeof (KSPIN_MEDIUM));

    if (pPropData == NULL)
        return S_OK;

    if (cbPropData < sizeof(GUID))
        return E_UNEXPECTED;

    if (dwPropID == AMPROPERTY_PIN_CATEGORY)
    {
        *(GUID *)pPropData = m_CategoryGUID;
    }
    else if (dwPropID == AMPROPERTY_PIN_MEDIUM)
    {
        *(KSPIN_MEDIUM *)pPropData = m_Medium;
    }


    return S_OK;
}


STDMETHODIMP COMInputPin::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    CAutoLock cLock(m_pFilterLock);

    if (AMPROPSETID_Pin == guidPropSet)
    {
        if (AMPROPERTY_PIN_CATEGORY != dwPropID && AMPROPERTY_PIN_MEDIUM != dwPropID )
            return E_PROP_ID_UNSUPPORTED ;

        if (pTypeSupport)
                *pTypeSupport = KSPROPERTY_SUPPORT_GET ;
    }
    else if (AM_KSPROPSETID_CopyProt == guidPropSet)
    {
        if (0 != GetPinId()  ||                         // only first in pin...
            AM_PROPERTY_COPY_MACROVISION != dwPropID)   // only MV prop set id
            return E_PROP_ID_UNSUPPORTED ;

        if (pTypeSupport)
            *pTypeSupport = KSPROPERTY_SUPPORT_SET ;
    }
    else
        return E_PROP_SET_UNSUPPORTED ;

    return S_OK ;
}


STDMETHODIMP COMInputPin::KsQueryMediums(PKSMULTIPLE_ITEM* pMediumList)
{
    PKSPIN_MEDIUM pMedium;

    CAutoLock cLock(m_pFilterLock);

    *pMediumList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pMediumList) + sizeof(*pMedium)));
    if (!*pMediumList)
    {
        return E_OUTOFMEMORY;
    }
    (*pMediumList)->Count = 1;
    (*pMediumList)->Size = sizeof(**pMediumList) + sizeof(*pMedium);
    pMedium = reinterpret_cast<PKSPIN_MEDIUM>(*pMediumList + 1);
    pMedium->Set   = m_Medium.Set;
    pMedium->Id    = m_Medium.Id;
    pMedium->Flags = m_Medium.Flags;

    // The following special return code notifies the proxy that this pin is
    // not available as a kernel mode connection
    return S_FALSE;
}


STDMETHODIMP COMInputPin::KsQueryInterfaces(PKSMULTIPLE_ITEM* pInterfaceList)
{
    PKSPIN_INTERFACE    pInterface;

    CAutoLock cLock(m_pFilterLock);

    *pInterfaceList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pInterfaceList) + sizeof(*pInterface)));
    if (!*pInterfaceList)
    {
        return E_OUTOFMEMORY;
    }
    (*pInterfaceList)->Count = 1;
    (*pInterfaceList)->Size = sizeof(**pInterfaceList) + sizeof(*pInterface);
    pInterface = reinterpret_cast<PKSPIN_INTERFACE>(*pInterfaceList + 1);
    pInterface->Set = AM_INTERFACESETID_Standard;
    pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
    pInterface->Flags = 0;
    return NOERROR;
}

STDMETHODIMP COMInputPin::KsGetCurrentCommunication(KSPIN_COMMUNICATION* pCommunication, KSPIN_INTERFACE* pInterface, KSPIN_MEDIUM* pMedium)
{
    HRESULT hr = NOERROR;

    CAutoLock cLock(m_pFilterLock);

    if (!m_bStreamingInKernelMode)
        hr = S_FALSE;

    if (pCommunication != NULL)
    {
        *pCommunication = m_Communication;
    }
    if (pInterface != NULL)
    {
        pInterface->Set = AM_INTERFACESETID_Standard;
        pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
        pInterface->Flags = 0;
    }
    if (pMedium != NULL)
    {
        *pMedium = m_Medium;
    }
    return hr;
}

void COMInputPin::CheckOverlayHidden()
{
    if (m_bOverlayHidden)
    {
        m_bOverlayHidden = FALSE;
        // make sure that the video frame gets updated by redrawing everything
        EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
    }
}

/******************************Public*Routine******************************\
* DynamicQueryAccept
*
* Do you accept this type change in your current state?
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::DynamicQueryAccept(
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("COMInputPin::DynamicQueryAccept")));
    CheckPointer(pmt, E_POINTER);

    CAutoLock cLock(m_pFilterLock);

    //
    // I want CheckMedia type to behave as though we aren't connected to
    // anything yet - hence the messing about with m_bConnected.
    //
    CMediaType cmt(*pmt);
    BOOL bConnected = m_bConnected;
    m_bConnected = FALSE;
    HRESULT  hr = CheckMediaType(&cmt);
    m_bConnected = bConnected;

    return hr;
}

/******************************Public*Routine******************************\
* NotifyEndOfStream
*
*
* Set event when EndOfStream receive - do NOT pass it on
* This condition is cancelled by a flush or Stop
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::NotifyEndOfStream(
    HANDLE hNotifyEvent
    )
{
    AMTRACE((TEXT("COMInputPin::NotifyEndOfStream")));
    CAutoLock cLock(m_pFilterLock);
    m_hEndOfStream = hNotifyEvent;
    return S_OK;
}

/******************************Public*Routine******************************\
* IsEndPin
*
* Are you an 'end pin'
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::IsEndPin()
{
    AMTRACE((TEXT("COMInputPin::IsEndPin")));
    return S_OK;
}

/******************************Public*Routine******************************\
* DynamicDisconnect
*
* Disconnect while running
*
* History:
* Wed 2/7/1999 - SyonB - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::DynamicDisconnect()
{
    AMTRACE((TEXT("COMInputPin::DynamicDisconnect")));
    CAutoLock l(m_pLock);
    return CBaseInputPin::DisconnectInternal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\syncobj.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __SYNC_OBJECT__
#define __SYNC_OBJECT__

class COMInputPin;

class CFrameAvg
{
    enum { nFrames = 8 };
    int   m_tFrame[nFrames];
    int   m_tTotal;
    int   m_iCurrent;

public:

    CFrameAvg()
    {
        Init();
    }
    void Init()
    {
        m_tTotal   = 0;
        m_iCurrent = 0;
        ZeroMemory(m_tFrame, sizeof(m_tFrame));
    }

    void NewFrame(REFERENCE_TIME tFrameTime)
    {
        if (tFrameTime > UNITS) {
            tFrameTime = UNITS;
        }
        if (tFrameTime < 0) {
            tFrameTime = 0;
        }
        int iNext = m_iCurrent == nFrames - 1 ? 0 : m_iCurrent + 1;
        m_tTotal -= m_tFrame[iNext];
        m_tTotal += (int)tFrameTime;
        m_tFrame[iNext] = (int)tFrameTime;
        m_iCurrent = iNext;
    }

    int Avg()
    {
        return m_tTotal / nFrames;
    }
};

class CAMSyncObj

{
public:
    CAMSyncObj(COMInputPin *pPin, IReferenceClock **ppClock, CCritSec *pLock, HRESULT *phr);
    ~CAMSyncObj();

    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();
    HRESULT NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    HRESULT Active();
    HRESULT Inactive();
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT RunToPause();
    HRESULT BeginFlush();
    HRESULT EndFlush();

    HRESULT EndOfStream();
    HRESULT Receive(IMediaSample *pMediaSample);
    HRESULT WaitForRenderTime();
    BOOL ScheduleSample(IMediaSample *pMediaSample);
    void SendRepaint();
    void SetRepaintStatus(BOOL bRepaint);
    HRESULT OnDisplayChange();

    // Permit access to the transition state
    void Ready() { m_evComplete.Set(); }
    void NotReady() { m_evComplete.Reset(); }
    BOOL CheckReady() { return m_evComplete.Check(); }

    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *pState);
    FILTER_STATE GetRealState() { return m_State; }
    void SetCurrentSample(IMediaSample *pMediaSample);
    virtual IMediaSample *GetCurrentSample();
    HRESULT CompleteStateChange(FILTER_STATE OldState);
    HRESULT GetSampleTimes(IMediaSample *pMediaSample, REFERENCE_TIME *pStartTime,
	REFERENCE_TIME *pEndTime);

    static void CALLBACK CAMSyncObj::RenderSampleOnMMThread(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);
    HRESULT CAMSyncObj::ScheduleSampleUsingMMThread(IMediaSample *pMediaSample);

private:
    // Return internal information about this pin
    BOOL IsEndOfStream() { return m_bEOS; }
    BOOL IsEndOfStreamDelivered() { return m_bEOSDelivered; }
    BOOL IsFlushing() { return m_bFlushing; }
    BOOL IsConnected() { return m_bConnected; }
    BOOL IsStreaming() { return m_bStreaming; }
    void SetAbortSignal(BOOL bAbort) { m_bAbort = bAbort; }
    virtual void OnReceiveFirstSample(IMediaSample *pMediaSample);
    CAMEvent *GetRenderEvent() { return &m_RenderEvent; }
    void SignalTimerFired() { m_dwAdvise = 0; }

    // These look after the handling of data samples
    virtual HRESULT PrepareReceive(IMediaSample *pMediaSample);
    void WaitForReceiveToComplete();
    virtual BOOL HaveCurrentSample();

    HRESULT SourceThreadCanWait(BOOL bCanWait);

    // Lots of end of stream complexities
    void ResetEndOfStreamTimer();
    HRESULT NotifyEndOfStream();
    virtual HRESULT SendEndOfStream();
    virtual HRESULT ResetEndOfStream();
    friend void CALLBACK EndOfStreamTimer(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);
    void TimerCallback();

    // Rendering is based around the clock
    virtual HRESULT CancelNotification();
    virtual HRESULT ClearPendingSample();
    void CancelMMTimer();

#ifdef DEBUG
    // Debug only dump of the renderer state
    void DisplayRendererState();
#endif


private:
    COMInputPin         *m_pPin;
    IReferenceClock     **m_ppClock;		    // A pointer to the filter's clock
    CCritSec            *m_pFilterLock;		    // Critical section for interfaces
    CCritSec            m_SyncObjLock;		    // Controls access to internals

    // some state variables.
    FILTER_STATE        m_State;
    BOOL                m_bFlushing;
    BOOL                m_bConnected;
    BOOL                m_bTimerRunning;

    CRendererPosPassThru    *m_pPosition;		// Media seeking pass by object
    CAMEvent		    m_RenderEvent;		    // Used to signal timer events
    CAMEvent		    m_ThreadSignal;		    // Signalled to release worker thread
    CAMEvent		    m_evComplete;		    // Signalled when state complete

    DWORD               m_MMTimerId;		    // MMThread timer id
    DWORD_PTR           m_dwAdvise;			    // Timer advise cookie
    IMediaSample        *m_pMediaSample;		// Current image media sample
    IMediaSample        *m_pMediaSample2;		// Current image media sample for 2nd flip
    CRefTime            m_tStart;

    BOOL                m_bAbort;			    // Stop us from rendering more data
    BOOL                m_bStreaming;		    // Are we currently streaming
    BOOL                m_bRepaintStatus;		// Can we signal an EC_REPAINT
    BOOL                m_bInReceive;

    REFERENCE_TIME      m_SignalTime;		    // Time when we signal EC_COMPLETE
    BOOL                m_bEOS;			        // Any more samples in the stream
    BOOL                m_bEOSDelivered;		    // Have we delivered an EC_COMPLETE
    UINT                m_EndOfStreamTimer;		    // Used to signal end of stream

    CFrameAvg           m_AvgDuration;
#ifdef PERF
    // Performance logging identifiers
    int m_idTimeStamp;              // MSR_id for frame time stamp
    int m_idEarly;
    int m_idLate;
#endif

public:
    CFrameAvg           m_AvgDelivery;


// Added stuff to compute quality property page stats
private:
    // These member variables hold rendering statistics
    int m_cFramesDropped;           // cumulative frames dropped IN THE RENDERER
    int m_cFramesDrawn;             // Frames since streaming started seen BY THE
                                    // RENDERER (some may be dropped upstream)

    // Next two support average sync offset and standard deviation of sync offset.
    LONGLONG m_iTotAcc;                  // Sum of accuracies in mSec
    LONGLONG m_iSumSqAcc;           // Sum of squares of (accuracies in mSec)

    // Next two allow jitter calculation.  Jitter is std deviation of frame time.
    REFERENCE_TIME m_trLastDraw;    // Time of prev frame (for inter-frame times)
    LONGLONG m_iSumSqFrameTime;     // Sum of squares of (inter-frame time in mSec)
    LONGLONG m_iSumFrameTime;            // Sum of inter-frame times in mSec

    // To get performance statistics on frame rate, jitter etc, we need
    // to record the lateness and inter-frame time.  What we actually need are the
    // data above (sum, sum of squares and number of entries for each) but the data
    // is generated just ahead of time and only later do we discover whether the
    // frame was actually drawn or not.  So we have to hang on to the data
    int m_trLate;                   // hold onto frame lateness
    int m_trFrame;                  // hold onto inter-frame time

    int m_tStreamingStart;          // if streaming then time streaming started
                                    // else time of last streaming session
                                    // used for property page statistics
    // QualityProperty stats
    HRESULT GetStdDev(int nSamples, int *piResult, LONGLONG llSumSq, LONGLONG iTot);
    HRESULT OnStartStreaming();
    HRESULT OnStopStreaming();
    HRESULT ResetStreamingTimes();
    void OnRenderStart(IMediaSample *pMediaSample);
    void OnRenderEnd(IMediaSample *pMediaSample);
    void PreparePerformanceData(REFERENCE_TIME *ptrStart, REFERENCE_TIME *ptrEnd);
    void RecordFrameLateness(int trLate, int trFrame);

public:
    HRESULT get_FramesDroppedInRenderer(int *cFramesDropped);
    HRESULT get_FramesDrawn(int *pcFramesDrawn);
    HRESULT get_AvgFrameRate(int *piAvgFrameRate);
    HRESULT get_Jitter(int *piJitter);
    HRESULT get_AvgSyncOffset(int *piAvg);
    HRESULT get_DevSyncOffset(int *piDev);
};

#endif //__SYNC_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\syncobj.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include <macvis.h>
#include <ovmixer.h>

#include <measure.h>        // Used for time critical log functions

// constructor
CAMSyncObj::CAMSyncObj(COMInputPin *pPin, IReferenceClock **ppClock, CCritSec *pLock, HRESULT *phr) :
m_evComplete(TRUE),
m_ThreadSignal(TRUE),
m_bTimerRunning( FALSE )
{
#ifdef PERF
    m_idTimeStamp       = MSR_REGISTER(TEXT("Frame time stamp"));
    m_idEarly           = MSR_REGISTER(TEXT("Earliness"));
    m_idLate            = MSR_REGISTER(TEXT("Lateness"));
#endif
    ResetStreamingTimes();

    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::Constructor")));

    m_pPin = pPin;
    m_ppClock = ppClock;
    m_pFilterLock = pLock;

    // some state variables.
    m_State = State_Stopped;
    m_bFlushing = FALSE;
    m_bConnected = FALSE;

    m_pPosition = NULL;
    m_dwAdvise = 0;
    m_pMediaSample = NULL;
    m_pMediaSample2 = NULL;
    m_tStart = 0;

    m_bAbort = FALSE;
    m_bStreaming = FALSE;
    m_bRepaintStatus = TRUE;
    m_bInReceive = FALSE;

    m_SignalTime = 0;
    m_bEOS = FALSE;
    m_bEOSDelivered = FALSE;
    m_EndOfStreamTimer = 0;

    m_MMTimerId = 0;

    *phr = hr;
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::Constructor")));
    return;
}

// destructor
CAMSyncObj::~CAMSyncObj(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::Destructor")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::Destructor")));
    return;
}

// check that the mediatype is acceptable
// Complete Connect
HRESULT CAMSyncObj::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::CompleteConnect")));

    SetRepaintStatus(TRUE);
    m_bAbort = FALSE;

    // record the connection status using an internal variable
    m_bConnected = TRUE;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::CompleteConnect")));
    return hr;
}

HRESULT CAMSyncObj::BreakConnect(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::BreakConnect")));

    SetRepaintStatus(FALSE);
    ResetEndOfStream();
    ClearPendingSample();
    m_bAbort = FALSE;

    // record the connection status using an internal variable
    m_bConnected = FALSE;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::BreakConnect")));
    return hr;
}

// notifies us of the start/stop/rate applying to the data about to be received
HRESULT CAMSyncObj::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate)
{
    ASSERT(1);
    return NOERROR;
}

// transition from stop to pause state
HRESULT CAMSyncObj::Active(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::Active")));

    ASSERT(IsFlushing() == FALSE);

    // Enable EC_REPAINT events again
    SetRepaintStatus(TRUE);
    ASSERT(m_bStreaming == FALSE);
    SourceThreadCanWait(TRUE);
    CancelNotification();
    ResetEndOfStreamTimer();

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);
    ASSERT(IsFlushing() == FALSE);

    // When we come out of a stopped state we must clear any image we were
    // holding onto for frame refreshing. Since renderers see state changes
    // first we can reset ourselves ready to accept the source thread data
    // Paused or running after being stopped causes the current position to
    // be reset so we're not interested in passing end of stream signals
    m_bAbort = FALSE;
    ClearPendingSample();

    hr = CompleteStateChange(State_Stopped);

    // record the state using an internal variable
    m_State = State_Paused;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::Active")));
    return hr;
}

// transition from pause to stop state
HRESULT CAMSyncObj::Inactive(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::Inactive")));

    if (m_pPosition)
    {
        m_pPosition->ResetMediaTime();
    }

    // hold on to the sample if we are using our allocator
    if (!(m_pPin->UsingOurAllocator()))
    {
        ClearPendingSample();
    }

    // Cancel any scheduled rendering
    SetRepaintStatus(TRUE);
    m_bStreaming = FALSE;
    SourceThreadCanWait(FALSE);
    ResetEndOfStream();
    CancelNotification();

    // There should be no outstanding clock advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);

    Ready();
    WaitForReceiveToComplete();
    m_bAbort = FALSE;

    // record the state using an internal variable
    m_State = State_Stopped;
    m_bFlushing = FALSE;

    if ( m_bTimerRunning ) {
        timeEndPeriod(1);
        m_bTimerRunning = FALSE;
    }
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::Inactive")));
    return hr;
}

// transition from pause to run state
HRESULT CAMSyncObj::Run(REFERENCE_TIME tStart)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::Run")));

    Ready();


    // Allow the source thread to wait
    ASSERT(IsFlushing() == FALSE);
    SourceThreadCanWait(TRUE);
    SetRepaintStatus(FALSE);

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);
    ASSERT(IsFlushing() == FALSE);

    {
        CAutoLock cObjLock(&m_SyncObjLock);
        ASSERT(!m_bStreaming);

        // Reset the streaming times ready for running
        m_bStreaming = TRUE;
        OnStartStreaming();

        m_tStart = tStart;

        // record the state using an internal variable
        m_State = State_Running;

        if ( !m_bTimerRunning ) {
            timeBeginPeriod(1);
            m_bTimerRunning = TRUE;
        }

        // If we have an EOS and no data then deliver it now
        if (m_pMediaSample == NULL)
        {
            hr = SendEndOfStream();
            goto CleanUp;
        }

        // Have the data rendered
        ASSERT(m_pMediaSample);
        //m_RenderEvent.Set();
        ScheduleSample(m_pMediaSample);
}

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::Run")));
    return hr;
}

// transition from run to pause state
HRESULT CAMSyncObj::RunToPause(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::RunToPause")));

    ASSERT(IsFlushing() == FALSE);

    // Enable EC_REPAINT events again
    SetRepaintStatus(TRUE);
    m_bStreaming = FALSE;
    OnStopStreaming();

    SourceThreadCanWait(TRUE);
    CancelNotification();
    ResetEndOfStreamTimer();

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);
    ASSERT(IsFlushing() == FALSE);

    if( m_bTimerRunning ) {
        timeEndPeriod(1);
        m_bTimerRunning = FALSE;
    }

    hr = CompleteStateChange(State_Running);

    // record the state using an internal variable
    m_State = State_Paused;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::RunToPause")));
    return hr;
}


// Signals start of flushing on the input pin - we do the final reset end of
// stream with the renderer lock unlocked but with the interface lock locked
// We must do this because we call timeKillEvent, our timer callback method
// has to take the renderer lock to serialise our state. Therefore holding a
// renderer lock when calling timeKillEvent could cause a deadlock condition
HRESULT CAMSyncObj::BeginFlush(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::BeginFlush")));

    CAutoLock cLock(m_pFilterLock);
    {
        CancelNotification();
        CAutoLock cObjLock(&m_SyncObjLock);

        // If paused then report state intermediate until we get some data
        if (m_State == State_Paused)
        {
            NotReady();
        }

        SourceThreadCanWait(FALSE);
        ClearPendingSample();
        //  Wait for Receive to complete
        WaitForReceiveToComplete();
    }
    hr = ResetEndOfStream();

    // record the flusing status using an internal variable
    ASSERT(!m_bFlushing);
    m_bFlushing = TRUE;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::BeginFlush")));
    return hr;
}


// end flushing the data
HRESULT CAMSyncObj::EndFlush(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::EndFlush")));

    CAutoLock cLock(m_pFilterLock);
    CAutoLock cObjLock(&m_SyncObjLock);

    // Reset the current sample media time
    if (m_pPosition)
        m_pPosition->ResetMediaTime();

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    SourceThreadCanWait(TRUE);

    // record the flusing status using an internal variable
    ASSERT(m_bFlushing);
    m_bFlushing = FALSE;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::EndFlush")));
    return hr;
}


// tell the state
STDMETHODIMP CAMSyncObj::GetState(DWORD dwMSecs,FILTER_STATE *pState)
{
    CheckPointer(pState,E_POINTER);

    if ((m_State == State_Paused) && (WaitDispatchingMessages(m_evComplete, dwMSecs) == WAIT_TIMEOUT))
    {
        *pState = m_State;
        return VFW_S_STATE_INTERMEDIATE;
    }
    *pState = m_State;
    return NOERROR;
}

// called when we receive a sample
HRESULT CAMSyncObj::Receive(IMediaSample *pSample)
{
    HRESULT hr = NOERROR;
    CheckPointer(pSample,E_POINTER);
    AM_MEDIA_TYPE *pMediaType;
    HANDLE WaitObjects[] = { m_ThreadSignal, m_RenderEvent };
    DWORD Result = WAIT_TIMEOUT;
    BOOL bSampleRendered = FALSE;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::Receive")));

    // It may return VFW_E_SAMPLE_REJECTED code to say don't bother
    hr = PrepareReceive(pSample);
    ASSERT(m_bInReceive == SUCCEEDED(hr));
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("PrepareReceive failed, hr = 0x%x"), hr));
        if (hr == VFW_E_SAMPLE_REJECTED)
        {
            hr = NOERROR;
            goto CleanUp;
        }
        goto CleanUp;
    }

    // we might have to draw the first sample immediately
    if (m_State == State_Paused)
    {
        // no need to use InterlockedExchange
        m_bInReceive = FALSE;
        {
            // We must hold both these locks
            CAutoLock cLock(m_pFilterLock);
            if (m_State == State_Stopped)
                return NOERROR;
            m_bInReceive = TRUE;
            CAutoLock cObjLock(&m_SyncObjLock);
            OnReceiveFirstSample(pSample);
            bSampleRendered = TRUE;
        }
        Ready();
    }

    // Having set an advise link with the clock we sit and wait. We may be
    // awoken by the clock firing or by a state change. The rendering call
    // will lock the critical section and check we can still render the data
    hr = WaitForRenderTime();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,1, TEXT("WaitForRenderTime failed, hr = 0x%x"), hr));
        m_bInReceive = FALSE;
        hr = NOERROR;
        goto CleanUp;
    }

    //  Set this here and poll it until we work out the locking correctly
    //  It can't be right that the streaming stuff grabs the interface
    //  lock - after all we want to be able to wait for this stuff
    //  to complete
    m_bInReceive = FALSE;

    {
        // We must hold both these locks
        CAutoLock cLock(m_pFilterLock);
        {
            CAutoLock cObjLock(&m_SyncObjLock);

            // Deal with this sample

            if (m_bStreaming && !bSampleRendered && m_pMediaSample)
            {
                OnRenderStart(m_pMediaSample);
                m_pPin->DoRenderSample(m_pMediaSample);
                OnRenderEnd(m_pMediaSample);
            }

            ClearPendingSample();
            SendEndOfStream();
        }
        CancelNotification();
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::Receive")));
    return hr;
}



// just render the sample
void CAMSyncObj::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
    m_pPin->OnReceiveFirstSample(pMediaSample);
}

// Called when the source delivers us a sample. We go through a few checks to
// make sure the sample can be rendered. If we are running (streaming) then we
// have the sample scheduled with the reference clock, if we are not streaming
// then we have received an sample in paused mode so we can complete any state
// transition. On leaving this function everything will be unlocked so an app
// thread may get in and change our state to stopped (for example) in which
// case it will also signal the thread event so that our wait call is stopped

HRESULT CAMSyncObj::PrepareReceive(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;

    CAutoLock cLock(m_pFilterLock);
    CAutoLock cObjLock(&m_SyncObjLock);

    m_bInReceive = TRUE;

    if (m_State == State_Stopped)
    {
        m_bInReceive = FALSE;
        return E_FAIL;
    }

    ASSERT(m_State == State_Paused || m_State == State_Running);
//  ASSERT(IsFlushing() == FALSE);
    ASSERT(IsConnected() == TRUE);
    ASSERT(m_pMediaSample == NULL);

    // Return an error if we already have a sample waiting for rendering
    // source pins must serialise the Receive calls - we also check that
    // no data is being sent after the source signalled an end of stream
    if (m_pMediaSample || m_bEOS || m_bAbort)
    {
        Ready();
        m_bInReceive = FALSE;
        return E_UNEXPECTED;
    }

    // Store the media times from this sample
    if (m_pPosition)
        m_pPosition->RegisterMediaTime(pMediaSample);

    // Schedule the next sample if we are streaming
    if ((m_bStreaming == TRUE) && (ScheduleSample(pMediaSample) == FALSE))
    {
        ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
        ASSERT(CancelNotification() == S_FALSE);
        m_bInReceive = FALSE;
        return VFW_E_SAMPLE_REJECTED;
    }

    // Store the sample end time for EC_COMPLETE handling
    // m_SignalTime = m_pPin->SampleProps()->tStop;

    // BEWARE we sometimes keep the sample even after returning the thread to
    // the source filter such as when we go into a stopped state (we keep it
    // to refresh the device with) so we must AddRef it to keep it safely. If
    // we start flushing the source thread is released and any sample waiting
    // will be released otherwise GetBuffer may never return (see BeginFlush)
    m_pMediaSample = pMediaSample;
    m_pMediaSample->AddRef();

    if (m_bStreaming == FALSE)
    {
        SetRepaintStatus(TRUE);
    }
    return NOERROR;
}

// Wait until the clock sets the timer event or we're otherwise signalled. We
// set an arbitrary timeout for this wait and if it fires then we display the
// current renderer state on the debugger. It will often fire if the filter's
// left paused in an application however it may also fire during stress tests
// if the synchronisation with application seeks and state changes is faulty

#define RENDER_TIMEOUT 10000

HRESULT CAMSyncObj::WaitForRenderTime()
{
    HANDLE WaitObjects[] = { m_ThreadSignal, m_RenderEvent };
    DWORD Result = WAIT_TIMEOUT;

    // Wait for either the time to arrive or for us to be stopped

    while (Result == WAIT_TIMEOUT)
    {
    Result = WaitForMultipleObjects(2,WaitObjects,FALSE,RENDER_TIMEOUT);

#ifdef DEBUG
    if (Result == WAIT_TIMEOUT) DisplayRendererState();
#endif

    }

    // We may have been awoken without the timer firing

    if (Result == WAIT_OBJECT_0)
    {
    return VFW_E_STATE_CHANGED;
    }

    SignalTimerFired();
    return NOERROR;
}


// Poll waiting for Receive to complete.  This really matters when
// Receive may set the palette and cause window messages
// The problem is that if we don't really wait for a renderer to
// stop processing we can deadlock waiting for a transform which
// is calling the renderer's Receive() method because the transform's
// Stop method doesn't know to process window messages to unblock
// the renderer's Receive processing
void CAMSyncObj::WaitForReceiveToComplete()
{
    for (;;)
    {
        if (!m_bInReceive)
        {
            break;
        }

        MSG msg;
        //  Receive all interthread sendmessages
        PeekMessage(&msg, NULL, WM_NULL, WM_NULL, PM_NOREMOVE);

        Sleep(1);
    }

    // If the wakebit for QS_POSTMESSAGE is set, the PeekMessage call
    // above just cleared the changebit which will cause some messaging
    // calls to block (waitMessage, MsgWaitFor...) now.
    // Post a dummy message to set the QS_POSTMESSAGE bit again
    if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE)
    {
        //  Send dummy message
        PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
    }
}

void CALLBACK CAMSyncObj::RenderSampleOnMMThread(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
    CAMSyncObj *thisPtr = (CAMSyncObj*)dwUser;
    CAutoLock cObjLock(&thisPtr->m_SyncObjLock);

    //  Check this particular one is active (since timeKillEvent is broken)
    //  on Windows 9x
    if (thisPtr->m_pMediaSample2 && uID == thisPtr->m_MMTimerId) {
        // Deal with this sample
        if (thisPtr->m_bStreaming)
        {
            thisPtr->m_pPin->FlipOverlayToItself();
        }
        thisPtr->m_pMediaSample2->Release();
        thisPtr->m_pMediaSample2 = NULL;
    }

}

HRESULT CAMSyncObj::ScheduleSampleUsingMMThread(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR, hrFailure = NOERROR;
    REFERENCE_TIME StartSample, EndSample;
    LONG lDelay = 0, lResolution = 1;

    // Is someone pulling our leg
    if (pMediaSample == NULL)
    {
        hr = E_FAIL;
        hrFailure = hr;
        goto CleanUp;
    }

    // Get the next sample due up for rendering.  If there aren't any ready
    // then GetNextSampleTimes returns an error.  If there is one to be done
    // then it succeeds and yields the sample times. If it is due now then
    // it returns S_OK other if it's to be done when due it returns S_FALSE
    hr = GetSampleTimes(pMediaSample, &StartSample, &EndSample);
    if (FAILED(hr))
    {
        hr = E_FAIL;
    }

    // If we don't have a reference clock then we cannot set up the advise
    // time so we simply set the event indicating an image to render. This
    // will cause us to run flat out without any timing or synchronisation
    if (SUCCEEDED(hr) && (hr != S_OK))
    {
        lDelay = (LONG)ConvertToMilliseconds(EndSample - StartSample);
        DbgLog((LOG_ERROR, 1, TEXT("lDelay = %d"), lDelay));
    }

    // if delay is less than or equal to zero or for some reason we couldnot compute the delay
    // just draw the sample immediately
    if (lDelay > 0)
    {
        CancelMMTimer();

        m_pMediaSample2 = pMediaSample;
        m_pMediaSample2->AddRef();

        {
            //  Make sure the timer id is set before the callback looks at it
            CAutoLock cObjLock(&m_SyncObjLock);
            m_MMTimerId = CompatibleTimeSetEvent(lDelay, lResolution, RenderSampleOnMMThread, (DWORD_PTR)this, TIME_ONESHOT);
        }
        if (!m_MMTimerId)
        {
            ClearPendingSample();
            hr = E_FAIL;
            hrFailure = hr;
            goto CleanUp;
        }
    }
    else if (m_bStreaming)
    {
        m_pPin->FlipOverlayToItself();
        goto CleanUp;
    }

CleanUp:
    return hrFailure;
}

// Responsible for setting up one shot advise links with the clock
// Return FALSE if the sample is to be dropped (not drawn at all)
// Return TRUE if the sample is to be drawn and in this case also
// arrange for m_RenderEvent to be set at the appropriate time
BOOL CAMSyncObj::ScheduleSample(IMediaSample *pMediaSample)
{
    REFERENCE_TIME StartSample, EndSample;

    // Is someone pulling our leg
    if (pMediaSample == NULL)
    {
        return FALSE;
    }

    // Get the next sample due up for rendering.  If there aren't any ready
    // then GetNextSampleTimes returns an error.  If there is one to be done
    // then it succeeds and yields the sample times. If it is due now then
    // it returns S_OK other if it's to be done when due it returns S_FALSE
    HRESULT hr = GetSampleTimes(pMediaSample, &StartSample, &EndSample);
    if (FAILED(hr))
    {
        return FALSE;
    }

    // Log the duration
    m_AvgDuration.NewFrame(EndSample - StartSample);

    // If we don't have a reference clock then we cannot set up the advise
    // time so we simply set the event indicating an image to render. This
    // will cause us to run flat out without any timing or synchronisation
    if (hr == S_OK)
    {
        EXECUTE_ASSERT(SetEvent((HANDLE) m_RenderEvent));
        return TRUE;
    }

    ASSERT(m_dwAdvise == 0);
    ASSERT((*m_ppClock));
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));

    // Schedule immediately if we skipped a frame or the decoder
    // isn't decoding as fast as it needs to to keep up
    int AvgFrame = m_AvgDelivery.Avg();
    int AvgDuration = m_AvgDuration.Avg();
    DbgLog((LOG_TRACE, 4, TEXT("AvgFrame = %d, AvgDuration = %d"),
        AvgFrame / 10000, AvgDuration / 10000));
    int iEarly = 8 * 10000;
    if (S_OK == pMediaSample->IsDiscontinuity()) {
        iEarly = 60 * 10000;
    } else {
        if (AvgFrame > (AvgDuration + AvgDuration / 16)) {
            if (AvgFrame > (AvgDuration + AvgDuration / 2)) {
                iEarly = 60 * 10000;
            } else {
                iEarly = 40 * 10000;
            }
        }
    }

    // We do have a valid reference clock interface so we can ask it to
    // set an event when the image comes due for rendering. We pass in
    // the reference time we were told to start at and also the current
    // stream time which is the offset from the start reference time
#ifdef PERF
    Msr_Integer(m_idTimeStamp, (int)((StartSample)>>32));   // high order 32 bits
    Msr_Integer(m_idTimeStamp, (int)(StartSample));         // low order 32 bits
    Msr_Integer(m_idEarly,     (int)(iEarly));              // earliness
#endif

    hr = (*m_ppClock)->AdviseTime(
        (REFERENCE_TIME) m_tStart, StartSample - iEarly,
        (HEVENT)(HANDLE) m_RenderEvent, &m_dwAdvise);                       // Advise cookie
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }

    // We could not schedule the next sample for rendering despite the fact
    // we have a valid sample here. This is a fair indication that either
    // the system clock is wrong or the time stamp for the sample is duff

    ASSERT(m_dwAdvise == 0);
    return FALSE;
}

// Retrieves the sample times for this samples (note the sample times are
// passed in by reference not value). We return S_FALSE to say schedule this
// sample according to the times on the sample. We also return S_OK in
// which case the object should simply render the sample data immediately
HRESULT CAMSyncObj::GetSampleTimes(IMediaSample *pMediaSample, REFERENCE_TIME *pStartTime,
                                   REFERENCE_TIME *pEndTime)
{
    ASSERT(m_dwAdvise == 0);
    ASSERT(pMediaSample);

    // If the stop time for this sample is before or the same as start time,
    // then just ignore it (release it) and schedule the next one in line
    // Source filters should always fill in the start and end times properly!
    if (SUCCEEDED(pMediaSample->GetTime(pStartTime, pEndTime)))
    {
        if (*pEndTime < *pStartTime)
        {
            return VFW_E_START_TIME_AFTER_END;
        }
    }
    else
    {
        // no time set in the sample... draw it now?
        return S_OK;
    }

    // Can't synchronise without a clock so we return S_OK which tells the
    // caller that the sample should be rendered immediately without going
    // through the overhead of setting a timer advise link with the clock
    if ((*m_ppClock) == NULL)
    {
        return S_OK;
    }

    PreparePerformanceData(pStartTime, pEndTime);
    return S_FALSE;
}

// Cancel our MM timer
void CAMSyncObj::CancelMMTimer()
{
    // kill the MMthread timer as well
    if (m_MMTimerId)
    {
        timeKillEvent(m_MMTimerId);
        m_MMTimerId = 0;
        CAutoLock cObjLock(&m_SyncObjLock);
        if (m_pMediaSample2)
        {
            // timeKillEvent is broken in Windows 9x - it doesn't wait
            // for the callback to complete
            m_pMediaSample2->Release();
            m_pMediaSample2 = NULL;
        }
    }
}

// Cancel any notification currently scheduled. This is called by the owning
// window object when it is told to stop streaming. If there is no timer link
// outstanding then calling this is benign otherwise we go ahead and cancel
// We must always reset the render event as the quality management code can
// signal immediate rendering by setting the event without setting an advise
// link. If we're subsequently stopped and run the first attempt to setup an
// advise link with the reference clock will find the event still signalled

HRESULT CAMSyncObj::CancelNotification()
{
    ASSERT(m_dwAdvise == 0 || *m_ppClock);
    DWORD_PTR dwAdvise = m_dwAdvise;

    CancelMMTimer();

    // Have we a live advise link

    if (m_dwAdvise) {
        (*m_ppClock)->Unadvise(m_dwAdvise);
        SignalTimerFired();
        ASSERT(m_dwAdvise == 0);
    }

    // Clear the event and return our status

    m_RenderEvent.Reset();
    return (dwAdvise ? S_OK : S_FALSE);
}

// Checks if there is a sample waiting at the renderer
BOOL CAMSyncObj::HaveCurrentSample()
{
    CAutoLock cObjLock(&m_SyncObjLock);
    return (m_pMediaSample == NULL ? FALSE : TRUE);
}

// we may no longer be able to draw the current image type properly, so we
// set the abort flag to be true
HRESULT CAMSyncObj::OnDisplayChange()
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering CAMSyncObj::OnDisplayChange")));

    // Ignore if we are not connected yet
    CAutoLock cObjLock(&m_SyncObjLock);
    if (!m_pPin->IsConnected())
    {
        hr = S_FALSE;
        goto CleanUp;
    }

    m_bAbort = TRUE;
    ClearPendingSample();

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMSyncObj::OnDisplayChange")));
    return hr;
}

// If we're pausing and we have no samples we don't complete the transition
// to State_Paused and we return S_FALSE. However if the m_bAbort flag has
// been set then all samples are rejected so there is no point waiting for
// one. If we do have a sample then return NOERROR. We will only ever return
// VFW_S_STATE_INTERMEDIATE from GetState after being paused with no sample
// (calling GetState after either being stopped or Run will NOT return this)
HRESULT CAMSyncObj::CompleteStateChange(FILTER_STATE OldState)
{
    // Allow us to be paused when disconnected
    if (IsConnected() == FALSE)
    {
        Ready();
        return S_OK;
    }

    // Have we run off the end of stream
    if (IsEndOfStream() == TRUE)
    {
        Ready();
        return S_OK;
    }

    // Make sure we get fresh data after being stopped
    if (HaveCurrentSample() == TRUE)
    {
        if (OldState != State_Stopped)
        {
            Ready();
            return S_OK;
        }
    }
    NotReady();
    return S_FALSE;
}

// Returns the current sample waiting at the video renderer. We AddRef the
// sample before returning so that should it come due for rendering the
// person who called this method will hold the remaining reference count
// that will stop the sample being added back onto the allocator free list
IMediaSample *CAMSyncObj::GetCurrentSample()
{
    CAutoLock cObjLock(&m_SyncObjLock);
    if (m_pMediaSample)
    {
        m_pMediaSample->AddRef();
    }
    return m_pMediaSample;
}

void CAMSyncObj::SetCurrentSample(IMediaSample *pMediaSample)
{
    if (pMediaSample)
    {
        m_pMediaSample = pMediaSample;
        m_pMediaSample->AddRef();
    }
    else if (m_pMediaSample)
    {
        m_pMediaSample->Release();
        m_pMediaSample = NULL;
    }
}
// This is called when we stop or are inactivated to clear the pending sample
// We release the media sample interface so that they can be allocated to the
// source filter again, unless of course we are changing state to inactive in
// which case GetBuffer will return an error. We must also reset the current
// media sample to NULL so that we know we do not currently have an image
HRESULT CAMSyncObj::ClearPendingSample()
{
    CAutoLock cObjLock(&m_SyncObjLock);
    if (m_pMediaSample)
    {
        m_pMediaSample->Release();
        m_pMediaSample = NULL;
    }
    return NOERROR;
}


// This is called whenever we change states, we have a manual reset event that
// is signalled whenever we don't won't the source filter thread to wait in us
// (such as in a stopped state) and likewise is not signalled whenever it can
// wait (during paused and running) this function sets or resets the thread
// event. The event is used to stop source filter threads waiting in Receive
HRESULT CAMSyncObj::SourceThreadCanWait(BOOL bCanWait)
{
    if (bCanWait == TRUE)
    {
        m_ThreadSignal.Reset();
    }
    else
    {
        m_ThreadSignal.Set();
    }
    return NOERROR;
}

void CAMSyncObj::SetRepaintStatus(BOOL bRepaint)
{
    CAutoLock cObjLock(&m_SyncObjLock);
    m_bRepaintStatus = bRepaint;
}

// Signal an EC_REPAINT to the filter graph. This can be used to have data
// sent to us. For example when a video window is first displayed it may
// not have an image to display, at which point it signals EC_REPAINT. The
// filtergraph will either pause the graph if stopped or if already paused
// it will call put_CurrentPosition of the current position. Setting the
// current position to itself has the stream flushed and the image resent

#define RLOG(_x_) DbgLog((LOG_TRACE,1,TEXT(_x_)));

void CAMSyncObj::SendRepaint()
{
    CAutoLock cObjLock(&m_SyncObjLock);

    // We should not send repaint notifications when...
    //    - An end of stream has been notified
    //    - Our input pin is being flushed
    //    - The input pin is not connected
    //    - We have aborted a video playback
    //    - There is a repaint already sent

    if ((m_bAbort == FALSE) &&
        (IsConnected() == TRUE) &&
        (IsFlushing() == FALSE) &&
        (IsEndOfStream() == FALSE) &&
        (m_bRepaintStatus == TRUE))
    {
        m_pPin->EventNotify(EC_REPAINT,0,0);
        SetRepaintStatus(FALSE);
        RLOG("Sending repaint");
    }
}


// Called when the input pin receives an EndOfStream notification. If we have
// not got a sample, then notify EC_COMPLETE now. If we have samples, then set
// m_bEOS and check for this on completing samples. If we're waiting to pause
// then complete the transition to paused state by setting the state event
HRESULT CAMSyncObj::EndOfStream()
{
    HRESULT hr = NOERROR;

    CAutoLock cLock(m_pFilterLock);
    CAutoLock cObjLock(&m_SyncObjLock);

    // Ignore these calls if we are stopped
    if (m_State == State_Stopped)
    {
        return NOERROR;
    }

    // If we have a sample then wait for it to be rendered
    m_bEOS = TRUE;
    if (m_pMediaSample)
    {
        return NOERROR;
    }

    // If we are waiting for pause then we are now ready since we cannot now
    // carry on waiting for a sample to arrive since we are being told there
    // won't be any. This sets an event that the GetState function picks up
    Ready();

    // Only signal completion now if we are running otherwise queue it until
    // we do run in StartStreaming. This is used when we seek because a seek
    // causes a pause where early notification of completion is misleading
    if (m_bStreaming)
    {
        SendEndOfStream();
    }

    return hr;
}

// If we are at the end of the stream signal the filter graph but do not set
// the state flag back to FALSE. Once we drop off the end of the stream we
// leave the flag set (until a subsequent ResetEndOfStream). Each sample we
// get delivered will update m_SignalTime to be the last sample's end time.
// We must wait this long before signalling end of stream to the filtergraph

#define TIMEOUT_DELIVERYWAIT 50
#define TIMEOUT_RESOLUTION 10

HRESULT CAMSyncObj::SendEndOfStream()
{
    ASSERT(CritCheckIn(&m_SyncObjLock));
    if (m_bEOS == FALSE || m_bEOSDelivered || m_EndOfStreamTimer)
    {
        return NOERROR;
    }

    // If there is no clock then signal immediately
    if ((*m_ppClock) == NULL)
    {
        return NotifyEndOfStream();
    }

    // How long into the future is the delivery time
    REFERENCE_TIME Signal = m_tStart + m_SignalTime;
    REFERENCE_TIME CurrentTime;
    (*m_ppClock)->GetTime(&CurrentTime);
    LONG Delay = LONG((Signal - CurrentTime) / 10000);

    // Dump the timing information to the debugger
    NOTE1("Delay until end of stream delivery %d",Delay);
    NOTE1("Current %s",(LPCTSTR)CDisp((LONGLONG)CurrentTime));
    NOTE1("Signal %s",(LPCTSTR)CDisp((LONGLONG)Signal));

    // Wait for the delivery time to arrive
    if (Delay < TIMEOUT_DELIVERYWAIT)
    {
        return NotifyEndOfStream();
    }

    // Signal a timer callback on another worker thread
    m_EndOfStreamTimer = CompatibleTimeSetEvent((UINT) Delay,
                                                TIMEOUT_RESOLUTION, 
                                                EndOfStreamTimer,
                                                DWORD_PTR(this),
                                                TIME_ONESHOT);
    if (m_EndOfStreamTimer == 0)
    {
        return NotifyEndOfStream();
    }
    return NOERROR;
}

// uID is Timer identifier, uMsg is not cuurently used, dwUser is User
// information, dw1 and dw2 are windows reserved
void CALLBACK EndOfStreamTimer(UINT uID, UINT uMsg, DWORD_PTR dwUser,
                               DWORD_PTR dw1, DWORD_PTR dw2)
{
    CAMSyncObj *pAMSyncObj = (CAMSyncObj *) dwUser;
    NOTE1("EndOfStreamTimer called (%d)",uID);
    pAMSyncObj->TimerCallback();
}

//  Do the timer callback work
void CAMSyncObj::TimerCallback()
{
    //  Lock for synchronization (but don't hold this lock when calling
    //  timeKillEvent)
    CAutoLock cObjLock(&m_SyncObjLock);

    // See if we should signal end of stream now
    if (m_EndOfStreamTimer)
    {
        m_EndOfStreamTimer = 0;
        SendEndOfStream();
    }
}

// Signals EC_COMPLETE to the filtergraph manager
HRESULT CAMSyncObj::NotifyEndOfStream()
{
    CAutoLock cObjLock(&m_SyncObjLock);
    ASSERT(m_bEOS == TRUE);
    ASSERT(m_bEOSDelivered == FALSE);
    ASSERT(m_EndOfStreamTimer == 0);

    // Has the filter changed state
    if (m_bStreaming == FALSE)
    {
        ASSERT(m_EndOfStreamTimer == 0);
        return NOERROR;
    }

    // Reset the end of stream timer
    m_EndOfStreamTimer = 0;

    // If we've been using the IMediaPosition interface, set it's start
    // and end media "times" to the stop position by hand.  This ensures
    // that we actually get to the end, even if the MPEG guestimate has
    // been bad or if the quality management dropped the last few frames
    if (m_pPosition)
        m_pPosition->EOS();
    m_bEOSDelivered = TRUE;
    NOTE("Sending EC_COMPLETE...");
    m_pPin->EventNotify(EC_COMPLETE,S_OK,0);
    return NOERROR;
}


// Reset the end of stream flag, this is typically called when we transfer to
// stopped states since that resets the current position back to the start so
// we will receive more samples or another EndOfStream if there aren't any. We
// keep two separate flags one to say we have run off the end of the stream
// (this is the m_bEOS flag) and another to say we have delivered EC_COMPLETE
// to the filter graph. We need the latter otherwise we can end up sending an
// EC_COMPLETE every time the source changes state and calls our EndOfStream
HRESULT CAMSyncObj::ResetEndOfStream()
{
    ResetEndOfStreamTimer();
    CAutoLock cObjLock(&m_SyncObjLock);

    m_bEOS = FALSE;
    m_bEOSDelivered = FALSE;
    m_SignalTime = 0;

    return NOERROR;
}

// Kills any outstanding end of stream timer
void CAMSyncObj::ResetEndOfStreamTimer()
{
    ASSERT(CritCheckOut(&m_SyncObjLock));
    if (m_EndOfStreamTimer)
    {
        timeKillEvent(m_EndOfStreamTimer);
        m_EndOfStreamTimer = 0;
    }
}



#ifdef DEBUG
// Dump the current renderer state to the debug terminal. The hardest part of
// the renderer is the window where we unlock everything to wait for a clock
// to signal it is time to draw or for the application to cancel everything
// by stopping the filter. If we get things wrong we can leave the thread in
// WaitForRenderTime with no way for it to ever get out and we will deadlock

void CAMSyncObj::DisplayRendererState()
{
    TCHAR DebugString[128];
    wsprintf(DebugString,TEXT("\n\nTimed out in WaitForRenderTime\n"));
    OutputDebugString(DebugString);

    // No way should this be signalled at this point

    BOOL bSignalled = m_ThreadSignal.Check();
    wsprintf(DebugString,TEXT("Signal sanity check %d\n"),bSignalled);
    OutputDebugString(DebugString);

    // Now output the current renderer state variables

    wsprintf(DebugString,TEXT("Filter state %d\n"),m_State);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("Abort flag %d\n"),m_bAbort);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("Streaming flag %d\n"),m_bStreaming);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("Clock advise link %d\n"),m_dwAdvise);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("Current media sample %x\n"),m_pMediaSample);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("EOS signalled %d\n"),m_bEOS);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("EOS delivered %d\n"),m_bEOSDelivered);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("Repaint status %d\n"),m_bRepaintStatus);
    OutputDebugString(DebugString);

    // Output the delayed end of stream timer information

    wsprintf(DebugString,TEXT("End of stream timer %x\n"),m_EndOfStreamTimer);
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("Deliver time %s\n"),CDisp((LONGLONG)m_SignalTime));
    OutputDebugString(DebugString);

    // Should never timeout during a flushing state

    BOOL bFlushing = IsFlushing();
    wsprintf(DebugString,TEXT("Flushing sanity check %d\n"),bFlushing);
    OutputDebugString(DebugString);

    // Display the time we were told to start at
    wsprintf(DebugString,TEXT("Last run time %s\n"),CDisp((LONGLONG)m_tStart.m_time));
    OutputDebugString(DebugString);

    // Have we got a reference clock
    if ((*m_ppClock) == NULL)
        return;

    // Get the current time from the wall clock

    CRefTime CurrentTime,StartTime,EndTime;
    (*m_ppClock)->GetTime((REFERENCE_TIME*) &CurrentTime);
    CRefTime Offset = CurrentTime - m_tStart;

    // Display the current time from the clock

    wsprintf(DebugString,TEXT("Clock time %s\n"),CDisp((LONGLONG)CurrentTime.m_time));
    OutputDebugString(DebugString);
    wsprintf(DebugString,TEXT("Time difference %dms\n"),Offset.Millisecs());
    OutputDebugString(DebugString);

    // Do we have a sample ready to render
    if (m_pMediaSample == NULL) return;

    m_pMediaSample->GetTime((REFERENCE_TIME*)&StartTime, (REFERENCE_TIME*)&EndTime);
    wsprintf(DebugString,TEXT("Next sample stream times (Start %d End %d ms)\n"),
        StartTime.Millisecs(),EndTime.Millisecs());
    OutputDebugString(DebugString);

    // Calculate how long it is until it is due for rendering
    CRefTime Wait = (m_tStart + StartTime) - CurrentTime;
    wsprintf(DebugString,TEXT("Wait required %d ms\n"),Wait.Millisecs());
    OutputDebugString(DebugString);
}
#endif


// update the statistics:
// m_iTotAcc, m_iSumSqAcc, m_iSumSqFrameTime, m_iSumFrameTime, m_cFramesDrawn
// Note that because the properties page reports using these variables,
// 1. We need to be inside a critical section
// 2. They must all be updated together.  Updating the sums here and the count
// elsewhere can result in imaginary jitter (i.e. attempts to find square roots
// of negative numbers) in the property page code.

void CAMSyncObj::RecordFrameLateness(int trLate, int trFrame)
{
    // Record how timely we are.
    int tLate = trLate/10000;

    // This is a hack - we can get frames that are ridiculously late
    // especially (at start-up) and they sod up the statistics.
    // So ignore things that are more than 1 sec off.
    if (tLate>1000 || tLate<-1000) {
        if (m_cFramesDrawn<=1) {
            tLate = 0;
        } else if (tLate>0) {
            tLate = 1000;
        } else {
            tLate = -1000;
        }
    }
    // The very first frame often has a bogus time, so I'm just
    // not going to count it into the statistics.   ???
    if (m_cFramesDrawn>1) {
        m_iTotAcc += tLate;
        m_iSumSqAcc += (tLate*tLate);
    }

    // calculate inter-frame time.  Doesn't make sense for first frame
    // second frame suffers from bogus first frame stamp.
    if (m_cFramesDrawn>2) {
        int tFrame = trFrame/10000;    // convert to mSec else it overflows
        // This is a hack.  It can overflow anyway (a pause can cause
        // a very long inter-frame time) and it overflows at 2**31/10**7
        // or about 215 seconds i.e. 3min 35sec
        if (tFrame>1000||tFrame<0) tFrame = 1000;
        m_iSumSqFrameTime += tFrame*tFrame;
        ASSERT(m_iSumSqFrameTime>=0);
        m_iSumFrameTime += tFrame;
    }
    ++m_cFramesDrawn;

} // RecordFrameLateness


// Implementation of IQualProp interface needed to support the property page
// This is how the property page gets the data out of the scheduler. We are
// passed into the constructor the owning object in the COM sense, this will
// either be the video renderer or an external IUnknown if we're aggregated.
// We initialise our CUnknown base class with this interface pointer. Then
// all we have to do is to override NonDelegatingQueryInterface to expose
// our IQualProp interface. The AddRef and Release are handled automatically
// by the base class and will be passed on to the appropriate outer object

HRESULT CAMSyncObj::get_FramesDroppedInRenderer(int *pcFramesDropped)
{
    CheckPointer(pcFramesDropped,E_POINTER);
    CAutoLock cObjLock(&m_SyncObjLock);
    *pcFramesDropped = m_cFramesDropped;
    return NOERROR;
} // get_FramesDroppedInRenderer


// Set *pcFramesDrawn to the number of frames drawn since
// streaming started.

HRESULT CAMSyncObj::get_FramesDrawn( int *pcFramesDrawn)
{
    CheckPointer(pcFramesDrawn,E_POINTER);
    CAutoLock cObjLock(&m_SyncObjLock);
    *pcFramesDrawn = m_cFramesDrawn;
    return NOERROR;
} // get_FramesDrawn


// Set iAvgFrameRate to the frames per hundred secs since
// streaming started.  0 otherwise.

HRESULT CAMSyncObj::get_AvgFrameRate( int *piAvgFrameRate)
{
    CheckPointer(piAvgFrameRate,E_POINTER);
    CAutoLock cObjLock(&m_SyncObjLock);

    int t;
    if (m_bStreaming) {
	t = timeGetTime()-m_tStreamingStart;
    } else {
	t = m_tStreamingStart;
    }

    if (t<=0) {
	*piAvgFrameRate = 0;
	ASSERT(m_cFramesDrawn == 0);
    } else {
	// i is frames per hundred seconds
	*piAvgFrameRate = MulDiv(100000, m_cFramesDrawn, t);
    }
    return NOERROR;
} // get_AvgFrameRate


// Set *piAvg to the average sync offset since streaming started
// in mSec.  The sync offset is the time in mSec between when the frame
// should have been drawn and when the frame was actually drawn.

HRESULT CAMSyncObj::get_AvgSyncOffset( int *piAvg)
{
    CheckPointer(piAvg,E_POINTER);
    CAutoLock cObjLock(&m_SyncObjLock);

    if (NULL==*m_ppClock) {
	*piAvg = 0;
	return NOERROR;
    }

    // Note that we didn't gather the stats on the first frame
    // so we use m_cFramesDrawn-1 here
    if (m_cFramesDrawn<=1) {
	*piAvg = 0;
    } else {
	*piAvg = (int)(m_iTotAcc / (m_cFramesDrawn-1));
    }
    return NOERROR;
} // get_AvgSyncOffset


// To avoid dragging in the maths library - a cheap
// approximate integer square root.
// We do this by getting a starting guess which is between 1
// and 2 times too large, followed by THREE iterations of
// Newton Raphson.  (That will give accuracy to the nearest mSec
// for the range in question - roughly 0..1000)
//
// It would be faster to use a linear interpolation and ONE NR, but
// who cares.  If anyone does - the best linear interpolation is
// to approximates sqrt(x) by
// y = x * (sqrt(2)-1) + 1 - 1/sqrt(2) + 1/(8*(sqrt(2)-1))
// 0r y = x*0.41421 + 0.59467
// This minimises the maximal error in the range in question.
// (error is about +0.008883 and then one NR will give error .0000something
// (Of course these are integers, so you can't just multiply by 0.41421
// you'd have to do some sort of MulDiv).
// Anyone wanna check my maths?  (This is only for a property display!)

static int isqrt(int x)
{
    int s = 1;
    // Make s an initial guess for sqrt(x)
    if (x > 0x40000000) {
       s = 0x8000;     // prevent any conceivable closed loop
    } else {
	while (s*s<x) {    // loop cannot possible go more than 31 times
	    s = 2*s;       // normally it goes about 6 times
	}
	// Three NR iterations.
	if (x==0) {
	   s= 0; // Wouldn't it be tragic to divide by zero whenever our
		 // accuracy was perfect!
	} else {
	    s = (s*s+x)/(2*s);
	    if (s>=0) s = (s*s+x)/(2*s);
	    if (s>=0) s = (s*s+x)/(2*s);
	}
    }
    return s;
}

//
//  Do estimates for standard deviations for per-frame
//  statistics
//
HRESULT CAMSyncObj::GetStdDev(
    int nSamples,
    int *piResult,
    LONGLONG llSumSq,
    LONGLONG iTot
)
{
    CheckPointer(piResult,E_POINTER);
    CAutoLock cObjLock(&m_SyncObjLock);

    if (NULL==*m_ppClock) {
	*piResult = 0;
	return NOERROR;
    }

    // If S is the Sum of the Squares of observations and
    //    T the Total (i.e. sum) of the observations and there were
    //    N observations, then an estimate of the standard deviation is
    //      sqrt( (S - T**2/N) / (N-1) )

    if (nSamples<=1) {
	*piResult = 0;
    } else {
	LONGLONG x;
	// First frames have bogus stamps, so we get no stats for them
	// So we need 2 frames to get 1 datum, so N is cFramesDrawn-1

	// so we use m_cFramesDrawn-1 here
	x = llSumSq - llMulDiv(iTot, iTot, nSamples, 0);
	x = x / (nSamples-1);
	ASSERT(x>=0);
	*piResult = isqrt((LONG)x);
    }
    return NOERROR;
}

// Set *piDev to the standard deviation in mSec of the sync offset
// of each frame since streaming started.

HRESULT CAMSyncObj::get_DevSyncOffset( int *piDev)
{
    // First frames have bogus stamps, so we get no stats for them
    // So we need 2 frames to get 1 datum, so N is cFramesDrawn-1
    return GetStdDev(m_cFramesDrawn - 1,
		     piDev,
		     m_iSumSqAcc,
		     m_iTotAcc);
} // get_DevSyncOffset


// Set *piJitter to the standard deviation in mSec of the inter-frame time
// of frames since streaming started.

HRESULT CAMSyncObj::get_Jitter( int *piJitter)
{
    // First frames have bogus stamps, so we get no stats for them
    // So second frame gives bogus inter-frame time
    // So we need 3 frames to get 1 datum, so N is cFramesDrawn-2
    return GetStdDev(m_cFramesDrawn - 2,
		     piJitter,
		     m_iSumSqFrameTime,
		     m_iSumFrameTime);
} // get_Jitter


// Reset all times controlling streaming.

HRESULT CAMSyncObj::ResetStreamingTimes()
{
    m_trLastDraw = -1000;     // set up as first frame since ages (1 sec) ago
    m_tStreamingStart = timeGetTime();
    m_cFramesDrawn = 0;
    m_cFramesDropped = 0;
    m_iTotAcc = 0;
    m_iSumSqAcc = 0;
    m_iSumSqFrameTime = 0;
    m_trFrame = 0;          // hygeine - not really needed
    m_trLate = 0;           // hygeine - not really needed
    m_iSumFrameTime = 0;

    return NOERROR;
} // ResetStreamingTimes


// Reset all times controlling streaming. Note that we're now streaming. We
// don't need to set the rendering event to have the source filter released
// as it is done during the Run processing. When we are run we immediately
// release the source filter thread and draw any image waiting (that image
// may already have been drawn once as a poster frame while we were paused)

HRESULT CAMSyncObj::OnStartStreaming()
{
    ResetStreamingTimes();
    return NOERROR;
} // OnStartStreaming


// Called at end of streaming.  Fixes times for property page report

HRESULT CAMSyncObj::OnStopStreaming()
{
    m_tStreamingStart = timeGetTime()-m_tStreamingStart;
    return NOERROR;
} // OnStopStreaming


// Called just before we start drawing.  All we do is to get the current clock
// time (from the system) and return.  We have to store the start render time
// in a member variable because it isn't used until we complete the drawing
// The rest is just performance logging.

void CAMSyncObj::OnRenderStart(IMediaSample *pMediaSample)
{
    RecordFrameLateness(m_trLate, m_trFrame);

#ifdef PERF
    REFERENCE_TIME trStart, trEnd, m_trRenderStart;
    pMediaSample->GetTime(&trStart, &trEnd);

    (*m_ppClock)->GetTime(&m_trRenderStart);
    Msr_Integer(0, (int)m_trRenderStart);
    REFERENCE_TIME trStream;
    trStream = m_trRenderStart-m_tStart;     // convert reftime to stream time
    Msr_Integer(0,(int)trStream);

    const int trLate = (int)(trStream - trStart);
    Msr_Integer(m_idLate, trLate/10000);  // dump in mSec
#endif

} // OnRenderStart


// Called directly after drawing an image.  We calculate the time spent in the
// drawing code and if this doesn't appear to have any odd looking spikes in
// it then we add it to the current average draw time.  Measurement spikes may
// occur if the drawing thread is interrupted and switched to somewhere else.

void CAMSyncObj::OnRenderEnd(IMediaSample *pMediaSample)
{
} // OnRenderEnd


//  Helper function for clamping time differences
int inline TimeDiff(REFERENCE_TIME rt)
{
    if (rt < - (50 * UNITS)) {
        return -(50 * UNITS);
    } else
    if (rt > 50 * UNITS) {
        return 50 * UNITS;
    } else return (int)rt;
}


// We are called with a valid IMediaSample image to compute sample time
// and lateness.  There must be a reference clock in operation.

void CAMSyncObj::PreparePerformanceData(REFERENCE_TIME *ptrStart, REFERENCE_TIME *ptrEnd)
{

    // Don't call us unless there's a clock interface to synchronise with
    ASSERT(*m_ppClock);

    // Get reference times (current and late)
    REFERENCE_TIME trRealStream;    // the real time now expressed as stream time.
    (*m_ppClock)->GetTime(&trRealStream);
    trRealStream -= m_tStart;       // convert to stream time (this is a reftime)

    // trTrueLate>0 -- frame is late
    // trTrueLate<0 -- frame is early
    int trTrueLate = TimeDiff(trRealStream - *ptrStart);

    int trFrame;
    {
	REFERENCE_TIME tr = trRealStream - m_trLastDraw; // Cd be large - 4 min pause!
	if (tr>10000000) {
	    tr = 10000000;          // 1 second - arbitrarily.
	}
	trFrame = int(tr);
    }

    if (trTrueLate<=0) {
        // We are going to wait
        trFrame = TimeDiff(*ptrStart-m_trLastDraw);
        m_trLastDraw = *ptrStart;
    } else {
        // trFrame is already = trRealStream-m_trLastDraw;
        m_trLastDraw = trRealStream;
    }

    m_trLate = trTrueLate;
    m_trFrame = trFrame;

} // PreparePerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\vpobj.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <dvdmedia.h>
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <macvis.h>
#include <ovmixer.h>


/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new VPObject instances
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
CUnknown *CAMVideoPort::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    AMTRACE((TEXT("CAMVideoPort::CreateInstance")));
    *phr = NOERROR;

    CAMVideoPort *pVPObject = new CAMVideoPort(pUnk, phr);
    if (FAILED(*phr))
    {
        if (pVPObject)
        {
            delete pVPObject;
            pVPObject = NULL;
        }
    }

    return pVPObject;
}

/******************************Public*Routine******************************\
* CAMVideoPort
*
* constructor
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
CAMVideoPort::CAMVideoPort(LPUNKNOWN pUnk, HRESULT *phr)
    : CUnknown(NAME("VP Object"), pUnk)
{
    AMTRACE((TEXT("CAMVideoPort::Constructor")));

    m_bConnected = FALSE;
    m_pIVPConfig = NULL;

    m_bVPSyncMaster = FALSE;

    InitVariables();

    // if you are QIing the outer object then you must decrease the refcount of
    // your outer unknown.  This is to avoid a circular ref-count. We are
    // guaranteed that the lifetime of the inner object is entirely contained
    // within the outer object's lifetime.

    *phr = pUnk->QueryInterface(IID_IVPControl, (void**)&m_pIVPControl);
    if (SUCCEEDED(*phr))
    {
        pUnk->Release();
    }
    else {
        DbgLog((LOG_ERROR, 0,
                TEXT("pUnk->QueryInterface(IID_IVPControl) failed, hr = 0x%x"),
                *phr));
    }
}

/******************************Public*Routine******************************\
* ~CAMVideoPort
*
* destructor
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
CAMVideoPort::~CAMVideoPort()
{
    AMTRACE((TEXT("CAMVideoPort::Destructor")));

    if (m_bConnected)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("Destructor called without calling breakconnect")));
        BreakConnect();
    }

    m_pIVPControl = NULL;
}

/******************************Public*Routine******************************\
* CAMVideoPort::NonDelegatingQueryInterface
*
* overridden to expose IVPNotify and IVPObject
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CAMVideoPort::NonDelegatingQueryInterface")));

    if (riid == IID_IVPNotify)
    {
        hr = GetInterface((IVPNotify*)this, ppv);
#if defined(DEBUG)
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2,
                    TEXT("GetInterface(IVPNotify*) failed, hr = 0x%x"), hr));
        }
#endif
    }
    else if (riid == IID_IVPNotify2)
    {
        hr = GetInterface((IVPNotify2*)this, ppv);
#if defined(DEBUG)
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2,
                    TEXT("GetInterface(IVPNotify2*) failed, hr = 0x%x"), hr));
        }
#endif
    }
    else if (riid == IID_IVPObject)
    {
        hr = GetInterface((IVPObject*)this, ppv);
#if defined(DEBUG)
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2,
                    TEXT("GetInterface(IVPObject*) failed, hr = 0x%x"), hr));
        }
#endif
    }
    else if (riid == IID_IVPInfo)
    {
        hr = GetInterface((IVPInfo*)this, ppv);
#if defined(DEBUG)
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2,
                    TEXT("GetInterface(IVPInfo*) failed, hr = 0x%x"), hr));
        }
#endif
    }

    else
    {
        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
#if defined(DEBUG)
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2,
                    TEXT("CUnknown::NonDelegatingQueryInterface")
                    TEXT(" failed, hr = 0x%x"), hr));
        }
#endif
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::InitVariables
*
* this function only initializes those variables which are supposed to be reset
* on RecreateVideoport
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
void CAMVideoPort::InitVariables()
{
    AMTRACE((TEXT("CAMVideoPort::InitVariables")));
    ZeroMemory(&m_rcDest, sizeof(RECT));
    ZeroMemory(&m_rcSource, sizeof(RECT));

    // image dimensions
    m_lImageWidth = 0;
    m_lImageHeight = 0;
    m_lDecoderImageHeight = 0;
    m_lDecoderImageWidth = 0;

    // Capturing information
    m_fCapturing = FALSE;
    m_fCaptureInterleaved = FALSE;
    m_cxCapture = 0;
    m_cyCapture = 0;

    // overlay surface related stuff
    m_pOverlaySurface = NULL;       // DirectDraw overlay surface
    m_dwBackBufferCount = 0;
    m_dwOverlaySurfaceWidth = 0;
    m_dwOverlaySurfaceHeight = 0;
    m_dwOverlayFlags = 0;

    // vp variables to store flags, current state etc
    m_bStart = FALSE;
    m_VPState = AMVP_VIDEO_STOPPED; // current state: running, stopped
    m_CurrentMode = AMVP_MODE_WEAVE;
    m_StoredMode = m_CurrentMode;
    m_CropState = AMVP_NO_CROP;
    m_dwPixelsPerSecond = 0;
    m_bVSInterlaced = FALSE;
    m_bGarbageLine = FALSE;

    // vp data structures
    m_dwVideoPortId = 0;
    m_pDVP = NULL;
    m_pVideoPort = NULL;
    ZeroMemory(&m_svpInfo, sizeof(DDVIDEOPORTINFO));
    ZeroMemory(&m_sBandwidth, sizeof(DDVIDEOPORTBANDWIDTH));
    ZeroMemory(&m_vpCaps, sizeof(DDVIDEOPORTCAPS));
    ZeroMemory(&m_ddConnectInfo, sizeof(DDVIDEOPORTCONNECT));
    ZeroMemory(&m_VPDataInfo, sizeof(AMVPDATAINFO));

    // All the pixel formats (Video/VBI)
    m_pddVPInputVideoFormat = NULL;
    m_pddVPOutputVideoFormat = NULL;

    // can we support the different modes
    m_bCanWeave = FALSE;
    m_bCanBobInterleaved = FALSE;
    m_bCanBobNonInterleaved = FALSE;
    m_bCanSkipOdd = FALSE;
    m_bCanSkipEven = FALSE;
    m_bCantInterleaveHalfline = FALSE;

    // decimation parameters
    m_ulDeciStepX = 0;
    m_dwDeciNumX = m_dwDeciDenX = 1000;
    m_ulDeciStepY = 0;
    m_dwDeciNumY = m_dwDeciDenY = 1000;
    m_DecimationModeX = DECIMATE_NONE;
    m_DecimationModeY = DECIMATE_NONE;

    m_bVPDecimating = FALSE;
    m_bDecimating = FALSE;
    m_lWidth = 0;
    m_lHeight = 0;

    // variables to store the current aspect ratio
    m_dwPictAspectRatioX = 1;
    m_dwPictAspectRatioY = 1;
}

/******************************Public*Routine******************************\
* CAMVideoPort::GetDirectDrawSurface
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP
CAMVideoPort::GetDirectDrawSurface(LPDIRECTDRAWSURFACE *ppDirectDrawSurface)
{
    AMTRACE((TEXT("CAMVideoPort::SetVPSyncMaster")));
    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    if (!ppDirectDrawSurface || !m_bConnected)
    {
        // make sure the argument is valid
        if (!ppDirectDrawSurface) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("value of ppDirectDrawSurface is invalid,")
                    TEXT(" ppDirectDrawSurface = NULL")));
            hr = E_INVALIDARG;
        }
        else {
            // not connected, this function does not make much sense since the
            // surface wouldn't even have been allocated as yet
            DbgLog((LOG_ERROR, 1, TEXT("not connected, exiting")));
            hr = VFW_E_NOT_CONNECTED;
        }
    }
    else {
        *ppDirectDrawSurface = m_pOverlaySurface;
    }

    return hr;
}


/******************************Public*Routine******************************\
* CAMVideoPort::SetObjectLock
*
* sets the pointer to the lock, which would be used to synchronize calls
* to the object.  It is the callee's responsiblility to synchronize this call
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::SetObjectLock(CCritSec *pMainObjLock)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CAMVideoPort::SetObjectLock")));

    if (!pMainObjLock)
    {
        DbgLog((LOG_ERROR, 0, TEXT("pMainObjLock is NULL")));
        hr = E_INVALIDARG;
    }
    else {
        m_pMainObjLock = pMainObjLock;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::SetMediaType
*
* check that the mediatype is acceptable
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::SetMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CAMVideoPort::SetMediaType")));

    CAutoLock cObjectLock(m_pMainObjLock);
    HRESULT hr =  CheckMediaType(pmt);

#if defined(DEBUG)
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
    }
#endif

    return hr;
}


/******************************Public*Routine******************************\
* CAMVideoPort::CheckMediaType
*
* check that the mediatype is acceptable. No lock is taken here.
* It is the callee's responsibility to maintain integrity!
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::CheckMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CAMVideoPort::CheckMediaType")));

    // get the hardware caps
    LPDDCAPS pDirectCaps = m_pIVPControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;

    // the hardware must support overlay and also it must  support
    // videoports, otherwise fail checkmediatype

    if ((pDirectCaps->dwCaps & DDCAPS_OVERLAY) &&
        (pDirectCaps->dwCaps2 & DDCAPS2_VIDEOPORT))
    {
        // Make sure that the major and sub-types match

        if ((pmt->majortype == MEDIATYPE_Video) &&
            (pmt->subtype == MEDIASUBTYPE_VPVideo) &&
            (pmt->formattype == FORMAT_None))
        {
            hr = NOERROR;
        }

    }

#if defined(DEBUG)
    else {
        DbgLog((LOG_ERROR, 2,
                TEXT("no overlay or VPE support in hardware,")
                TEXT("so not accepting this mediatype")));
    }
#endif

    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::RecreateVideoPort
\**************************************************************************/
HRESULT CAMVideoPort::RecreateVideoPort()
{
    AMTRACE((TEXT("CAMVideoPort::RecreateVideoPort")));

    HRESULT hr = NOERROR;
    BOOL bCanWeave = FALSE;
    BOOL bCanBobInterleaved = FALSE;
    BOOL bCanBobNonInterleaved = FALSE;
    BOOL bTryDoubleHeight = FALSE, bPreferBuffers = FALSE;
    DWORD dwMaxOverlayBuffers;
    HRESULT hrFailure = VFW_E_VP_NEGOTIATION_FAILED;
    LPDIRECTDRAW pDirectDraw = NULL;
    LPDDCAPS pDirectCaps = NULL;
    int i = 0;

    CAutoLock cObjectLock(m_pMainObjLock);

    InitVariables();

    pDirectDraw = m_pIVPControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    pDirectCaps = m_pIVPControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    ASSERT(m_pIVPConfig);

    // allocate the necessary memory for input Video format
    m_pddVPInputVideoFormat = new DDPIXELFORMAT;
    if (m_pddVPInputVideoFormat == NULL)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pddVPInputVideoFormat == NULL : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // allocate the necessary memory for output Video format
    m_pddVPOutputVideoFormat = new DDPIXELFORMAT;
    if (m_pddVPOutputVideoFormat == NULL)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pddVPOutputVideoFormat == NULL : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // Init all of them to zero
    ZeroMemory(m_pddVPInputVideoFormat,  sizeof(DDPIXELFORMAT));
    ZeroMemory(m_pddVPOutputVideoFormat, sizeof(DDPIXELFORMAT));

    // create the VP container
    ASSERT(m_pDVP == NULL);
    ASSERT(pDirectDraw);

    hr = pDirectDraw->QueryInterface(IID_IDDVideoPortContainer, (LPVOID *)&m_pDVP);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR,0,
               TEXT("pDirectDraw->QueryInterface(IID_IDDVideoPortContainer)")
               TEXT(" failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }


    // Get the Video Port caps
    DDVIDEOPORTCAPS vpCaps;
    INITDDSTRUCT(vpCaps);
    hr = m_pDVP->EnumVideoPorts(0, &vpCaps, this, CAMVideoPort::EnumCallback);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->EnumVideoPorts failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    // negotiate the connection parameters
    // get/set connection info happens here
    hr = NegotiateConnectionParamaters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("NegotiateConnectionParamaters failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    //
    // Determine if we are capturing and if we are what the intended
    // capture image size is, first determine if the video port
    // supports interleaving interlaced fields in memory
    //

    BOOL fInterleave;
    if (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) {
        fInterleave = TRUE;
    }
    else {
        fInterleave = FALSE;
    }

    m_pIVPControl->GetCaptureInfo(&m_fCapturing, &m_cxCapture,
                                  &m_cyCapture, &fInterleave);

#if 0
    //
    // Until Marlene implements the AM_KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE
    // stuff I will read the same values from win.ini.
    //
    m_fCapturing = GetProfileIntA("OVMixer", "Capturing", 0);
    if (m_fCapturing) {
        m_cxCapture = GetProfileIntA("OVMixer", "cx", 320);
        m_cyCapture = GetProfileIntA("OVMixer", "cy", 240);

        if (m_cxCapture == 640 && m_cyCapture == 480) {
            fInterleave = GetProfileIntA("OVMixer", "interleave", 1);
        }

    }
#endif

    m_fCaptureInterleaved = fInterleave;

#if defined(DEBUG)
    if (m_fCapturing) {

        ASSERT(m_cxCapture > 0);
        ASSERT(m_cyCapture > 0);
        DbgLog((LOG_TRACE, 1,
                TEXT("We are CAPTURING, intended size (%d, %d)"),
                m_cxCapture, m_cyCapture));
    }
#endif


    for (i = 0; i < 2; i++)
    {
        AMVPSIZE amvpSize;
        DWORD dwNewWidth = 0;

        ZeroMemory(&amvpSize, sizeof(AMVPSIZE));

        // get the rest of the data parameters
        hr = GetDataParameters();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("GetDataParameters failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // create the video port
        hr = CreateVideoPort();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CreateVideoPort failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // check if we need to crop at videoport or overlay or neither
        hr = DetermineCroppingRestrictions();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("DetermineCroppingRestrictions FAILED, hr = 0x%x"),
                    hr));
            hr = hrFailure;
            goto CleanUp;
        }


        m_lImageWidth  = WIDTH(&m_VPDataInfo.amvpDimInfo.rcValidRegion);
        m_lImageHeight = HEIGHT(&m_VPDataInfo.amvpDimInfo.rcValidRegion);

        m_lDecoderImageWidth = m_lImageWidth;
        m_lDecoderImageHeight = m_lImageHeight;

        if (m_fCapturing) {

            if (m_lImageWidth != m_cxCapture ||
                m_lImageHeight != m_cyCapture) {

                DbgLog((LOG_TRACE, 1,
                        TEXT("Adjust Decoder Image size to CaptureSize")));
            }

            m_lImageWidth = m_cxCapture;
            m_lImageHeight = m_cyCapture;
        }

        m_dwPictAspectRatioX = m_VPDataInfo.dwPictAspectRatioX;
        m_dwPictAspectRatioY = m_VPDataInfo.dwPictAspectRatioY;

        // negotiate the pixel format
        hr = NegotiatePixelFormat();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // check the vp caps
        hr = CheckDDrawVPCaps();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CheckDDrawVPCaps FAILED, hr = 0x%x"), hr));
            // CheckDDrawVPCaps already returns a "proper" error code
            goto CleanUp;
        }

        if (i == 0)
        {
            dwNewWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
            if (m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE &&
                m_sBandwidth.dwYInterpAndColorkey < 900)
            {
                dwNewWidth = MulDiv(dwNewWidth,
                                    m_sBandwidth.dwYInterpAndColorkey, 1000);
            }
            else if (m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION &&
                     m_sBandwidth.dwYInterpAndColorkey > 1100)
            {
                dwNewWidth = MulDiv(dwNewWidth, 1000,
                                    m_sBandwidth.dwYInterpAndColorkey);
            }

            // VGA can't handle the bandwidth, ask decoder to down-scale
            if (dwNewWidth != m_VPDataInfo.amvpDimInfo.dwFieldWidth)
            {
                amvpSize.dwWidth = dwNewWidth;
                amvpSize.dwHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

                DbgLog((LOG_TRACE,1,
                        TEXT("SetScalingFactors to (%d, %d)"),
                        amvpSize.dwWidth, amvpSize.dwHeight));

                hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetScalingFactors")
                            TEXT("failed, hr = 0x%x"), hr));
                    break;
                }
                else
                {
                    // release the videoport
                    ASSERT(m_pVideoPort);
                    m_pVideoPort->Release();
                    m_pVideoPort = NULL;

                    // initialize relevant structs
                    ZeroMemory(&m_sBandwidth, sizeof(DDVIDEOPORTBANDWIDTH));
                    ZeroMemory(&m_VPDataInfo, sizeof(AMVPDATAINFO));
                    ZeroMemory(m_pddVPInputVideoFormat,  sizeof(DDPIXELFORMAT));
                    ZeroMemory(m_pddVPOutputVideoFormat, sizeof(DDPIXELFORMAT));

                    // initialize decimation parameters
                    m_ulDeciStepX = 0;
                    m_dwDeciNumX = m_dwDeciDenX = 1000;
                    m_DecimationModeX = DECIMATE_NONE;

                    m_ulDeciStepY = 0;
                    m_dwDeciNumY = m_dwDeciDenY = 1000;
                    m_DecimationModeY = DECIMATE_NONE;
                }
            }
            else
            {
                DbgLog((LOG_ERROR,0,TEXT("no need to scale at the decoder")));
                break;
            }
        }
    }



    // iniitalize the DDVideoPortInfo structure
    hr = InitializeVideoPortInfo();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("InitializeVideoPortInfo FAILED, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

#ifdef DEBUG
    if (m_bVSInterlaced)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_bVSInterlaced = TRUE")));
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_bVSInterlaced = FALSE")));
    }

    if (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP)
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP = TRUE")));
    }
    else
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP = FALSE")));
    }

    if (m_vpCaps.dwFX & DDVPFX_INTERLEAVE)
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_vpCaps.dwFX & DDVPFX_INTERLEAVE = TRUE")));
    }
    else
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_vpCaps.dwFX & DDVPFX_INTERLEAVE = FALSE")));
    }

    if (m_bCantInterleaveHalfline)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_bCantInterleaveHalfline = TRUE")));
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_bCantInterleaveHalfline = FALSE")));
    }

    if (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED)
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED = TRUE")));
    }
    else
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED")
                TEXT(" = FALSE")));
    }

    if (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED)
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED")
                TEXT(" = TRUE")));
    }
    else
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED")
                TEXT(" = FALSE")));
    }

#endif

    // can Weave only if content is non-interlaced (cause of motion
    // artifacts otherwise) and if videoport is capable of flipping and
    // supports interleaved data and if certain halfline scenarios do not
    // preclude interleaving
    //
    if ((!m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) &&
        (!m_bCantInterleaveHalfline))
    {
        bCanWeave = TRUE;
    }

    // can BobNonInterleaved only if content is interlaced and if videoport is
    // capable of flipping, is capable of bobing interleaved data and supports
    // interleaved data and if certain halfline scenarios do not preclude
    // interleaving
    //
    if ((m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED) &&
        (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) &&
        (!m_bCantInterleaveHalfline))
    {
        bCanBobInterleaved = TRUE;
    }

    // can BobInterleaved only if content is interlaced and if videoport is
    // capable of flipping and is capable of bobing non-interleaved data.
    //
    if ((m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED))
    {
        bCanBobNonInterleaved = TRUE;
    }

    // this just means that we would perfer higher number of
    // buffers instead of more height in the event of a conflict
    // (in cases like 2buffer, 1height versus 1buffer, 2height)
    //
    bPreferBuffers = TRUE;

    // we will try to allocate surface of double the field height only if
    // either mode weave or bob-interleaved are possible
    //
    bTryDoubleHeight = bCanWeave || bCanBobInterleaved;
    dwMaxOverlayBuffers = 1;

    // we will try to allocate multiple buffers only if either mode weave or
    // bob-interleaved or bob-non-interleaved are possible
    //
    if (bCanWeave || bCanBobInterleaved || bCanBobNonInterleaved)
    {
        //try to allocate min(m_vpCaps.dwNumAutoFlipSurfaces,
        // m_vpCaps.dwNumPreferredAutoflip) buffers
        //
        ASSERT(m_vpCaps.dwFlags & DDVPD_AUTOFLIP);
        if (m_vpCaps.dwFlags & DDVPD_PREFERREDAUTOFLIP)
        {
            dwMaxOverlayBuffers = min(m_vpCaps.dwNumAutoFlipSurfaces,
                                      m_vpCaps.dwNumPreferredAutoflip);
        }
        else
        {
            dwMaxOverlayBuffers = min(m_vpCaps.dwNumAutoFlipSurfaces, 3);
        }
    }

    // create the overlay surface
    hr = CreateVPOverlay(bTryDoubleHeight, dwMaxOverlayBuffers, bPreferBuffers);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CreateVPOverlay FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }

    // tell the upstream filter the valid data location on the ddraw surface
    hr = SetSurfaceParameters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetSurfaceParameters FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }

    // paint the overlay surface black
    hr = PaintDDrawSurfaceBlack(m_pOverlaySurface);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("PaintDDrawSurfaceBlack FAILED, hr = 0x%x"), hr));
        // not being able to paint the ddraw surface black is not a fatal error
        hr = NOERROR;
    }

    // attach the overlay surface to the videoport
    hr = m_pVideoPort->SetTargetSurface(m_pOverlaySurface, DDVPTARGET_VIDEO);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->SetTargetSurface failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    ASSERT(m_pddVPInputVideoFormat);
    ASSERT(m_pddVPOutputVideoFormat);
    if (!(EqualPixelFormats(m_pddVPInputVideoFormat, m_pddVPOutputVideoFormat)))
    {
        m_svpInfo.dwVPFlags |= DDVP_CONVERT;
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_CONVERT;
    }

    // determine which modes are possible now
    // depends upon the height, number of back buffers etc
    hr = DetermineModeRestrictions();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("DetermineModeRestrictions FAILED, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    // inform the decoder of the ddraw kernel handle, videoport id and surface
    // kernel handle
    hr = SetDDrawKernelHandles();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("SetDDrawKernelHandles failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    m_bConnected = TRUE;

    hr = m_pIVPControl->EventNotify(EC_OVMIXER_VP_CONNECTED, 0, 0);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPControl->EventNotify(EC_OVMIXER_VP_CONNECTED,")
                TEXT(" 0, 0) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::CompleteConnect
*
* supposed to be called when the host connects with the decoder
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP
CAMVideoPort::CompleteConnect(IPin *pReceivePin, BOOL bRenegotiating)
{
    AMTRACE((TEXT("CAMVideoPort::CompleteConnect")));

    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    if (!bRenegotiating)
    {
        InitVariables();

        ASSERT(m_pIVPConfig == NULL);
        hr = pReceivePin->QueryInterface(IID_IVPConfig, (void **)&m_pIVPConfig);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,  TEXT("QueryInterface(IID_IVPConfig) failed, hr = 0x%x"), hr));
            hr = VFW_E_NO_TRANSPORT;
            goto CleanUp;
        }
    }

    ASSERT(m_pIVPConfig);

    hr = RecreateVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("RecreateVideoPort failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

HRESULT CAMVideoPort::StopUsingVideoPort()
{
    AMTRACE((TEXT("CAMVideoPort::StopUsingVideoPort")));

    HRESULT hr = NOERROR;
    unsigned long ulCount;

    CAutoLock cObjectLock(m_pMainObjLock);

    // delete the input Video pixelformat
    if (m_pddVPInputVideoFormat)
    {
        delete [] m_pddVPInputVideoFormat;
        m_pddVPInputVideoFormat = NULL;
    }

    // delete the output Video pixelformat
    if (m_pddVPOutputVideoFormat)
    {
        delete [] m_pddVPOutputVideoFormat;
        m_pddVPOutputVideoFormat = NULL;
    }

    // release the videoport
    if (m_pVideoPort)
    {
        hr = m_pVideoPort->StopVideo();
        ulCount = m_pVideoPort->Release();
        m_pVideoPort = NULL;
    }

    // release the videoport container
    if (m_pDVP)
    {
        ulCount = m_pDVP->Release();
        m_pDVP = NULL;
    }

    // Release the DirectDraw overlay surface
    if (m_pOverlaySurface)
    {
        m_pOverlaySurface->Release();
        m_pOverlaySurface = NULL;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::BreakConnect
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP
CAMVideoPort::BreakConnect(BOOL bRenegotiating)
{
    AMTRACE((TEXT("CAMVideoPort::BreakConnect")));

    HRESULT hr = NOERROR;
    unsigned long ulCount;

    CAutoLock cObjectLock(m_pMainObjLock);

    hr = StopUsingVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("StopUsingVideoPort failed, hr = 0x%x"), hr));
    }
    if (!bRenegotiating)
    {
        // release the IVPConfig interface
        if (m_pIVPConfig)
        {
            m_pIVPConfig->Release();
            m_pIVPConfig = NULL;
        }
    }

    m_bConnected = FALSE;

    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::Active()
*
*
* transition from Stop to Pause.
* We do not need to to anything unless this is the very first time we are
* showing the overlay
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::Active()
{
    AMTRACE((TEXT("CAMVideoPort::Active")));

    CAutoLock cObjectLock(m_pMainObjLock);
    HRESULT hr = NOERROR;

    ASSERT(m_bConnected);
    ASSERT(m_VPState == AMVP_VIDEO_STOPPED);

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // make sure that a frame is visible by making an update overlay call
    m_bStart = TRUE;

    // make sure that the video frame gets updated by redrawing everything
    hr = m_pIVPControl->EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPControl->EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0)")
                TEXT(" failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // now stop the video, so the user will just see a still frame
    hr = m_pVideoPort->StopVideo();

#if defined(DEBUG)
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
#endif

CleanUp:
    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::Inactive()
*
* transition (from Pause or Run) to Stop
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::Inactive()
{

    AMTRACE((TEXT("CAMVideoPort::Inactive")));

    HRESULT hr = NOERROR;
    CAutoLock cObjectLock(m_pMainObjLock);

    if (m_bConnected) {

        // Inactive is also called when going from pause to stop, in which case the
        // VideoPort would have already been stopped in the function RunToPause

        if (m_VPState == AMVP_VIDEO_RUNNING) {

            // stop the VideoPort
            hr = m_pVideoPort->StopVideo();
            if (SUCCEEDED(hr)) {
                m_VPState = AMVP_VIDEO_STOPPED;
            }
            else {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
            }
        }
    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::Run
*
* transition from Pause to Run. We just start the VideoPort.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::Run(REFERENCE_TIME /* tStart */)
{
    AMTRACE((TEXT("CAMVideoPort::Run")));

    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_bConnected);
    ASSERT(m_VPState == AMVP_VIDEO_STOPPED);
    HRESULT hr;

    if (m_bConnected)
    {
        // An UpdateOverlay is needed here. One example is, when we are
        // clipping video in Stop/Pause state since we can't do scaling
        // on the videoport. As soon as the user hits play, we should stop
        // clipping the video.

        m_bStart = TRUE;

        // make sure that the video frame gets updated by redrawing everything
        hr = m_pIVPControl->EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        if (SUCCEEDED(hr))
        {
            m_VPState = AMVP_VIDEO_RUNNING;
        }
        else {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pIVPControl->EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0)")
                    TEXT(" failed, hr = 0x%x"), hr));
        }
    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}


/******************************Public*Routine******************************\
* CAMVideoPort::RunToPause()
*
* transition from Run to Pause. We just stop the VideoPort
* Note that transition from Run to Stop is caught by Inactive
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::RunToPause()
{

    AMTRACE((TEXT("CAMVideoPort::RunToPause")));

    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_bConnected);
    //ASSERT(m_VPState == AMVP_VIDEO_RUNNING);

    HRESULT hr;
    if (m_bConnected)
    {
        // stop the VideoPort
        hr = m_pVideoPort->StopVideo();
        if (SUCCEEDED(hr)) {

            m_VPState = AMVP_VIDEO_STOPPED;
        }
        else {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        }

    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::CurrentMediaType
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::CurrentMediaType(AM_MEDIA_TYPE *pMediaType)
{
    AMTRACE((TEXT("CAMVideoPort::CurrentMediaType")));

    CAutoLock cObjectLock(m_pMainObjLock);
    HRESULT hr;
    VIDEOINFOHEADER2 *pVideoInfoHeader2;
    BITMAPINFOHEADER *pHeader;

    if (m_bConnected) {

        if (pMediaType) {

            pVideoInfoHeader2 = (VIDEOINFOHEADER2*)(pMediaType->pbFormat);
            ZeroMemory(pVideoInfoHeader2, sizeof(VIDEOINFOHEADER2));

            pHeader = GetbmiHeader((CMediaType*)pMediaType);
            if (pHeader) {
                pHeader->biWidth = m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                                   m_VPDataInfo.amvpDimInfo.rcValidRegion.left;
                pHeader->biHeight = 2*(m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom -
                                       m_VPDataInfo.amvpDimInfo.rcValidRegion.top);


                pVideoInfoHeader2->dwPictAspectRatioX = m_VPDataInfo.dwPictAspectRatioX;
                pVideoInfoHeader2->dwPictAspectRatioY = m_VPDataInfo.dwPictAspectRatioY;
                hr = NOERROR;
            }
            else {
                hr = E_INVALIDARG;
                DbgLog((LOG_ERROR, 2, TEXT("pHeader is NULL")));
            }
        }
        else {
            hr = E_INVALIDARG;
            DbgLog((LOG_ERROR, 2, TEXT("pMediaType is NULL")));
        }
    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CAMVideoPort::GetRectangles
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::GetRectangles(RECT *prcSource, RECT *prcDest)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CAMVideoPort::GetRectangles")));

    if (prcSource && prcDest) {

        // adjust the source to be bigger to take into account the decimation
        // that's happening
        //
        prcSource->left   = MulDiv(m_rcSource.left,  m_dwDeciDenX, m_dwDeciNumX);
        prcSource->right  = MulDiv(m_rcSource.right, m_dwDeciDenX, m_dwDeciNumX);
        prcSource->top    = MulDiv(m_rcSource.top,   m_dwDeciDenY, m_dwDeciNumY);
        prcSource->bottom = MulDiv(m_rcSource.bottom,m_dwDeciDenY, m_dwDeciNumY);

        *prcDest = m_rcDest;
    }
    else {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR, 2, TEXT("prcSource or prcDest is NULL")));
    }

    return hr;
}


STDMETHODIMP CAMVideoPort::GetCropState(AMVP_CROP_STATE *pCropState)
{
    *pCropState = m_CropState;
    return NOERROR;
}

STDMETHODIMP CAMVideoPort::GetPixelsPerSecond(DWORD* pPixelPerSec)
{
    *pPixelPerSec = m_dwPixelsPerSecond;
    return NOERROR;
}

STDMETHODIMP CAMVideoPort::GetVPDataInfo(AMVPDATAINFO* pVPDataInfo)
{
    *pVPDataInfo = m_VPDataInfo;
    return NOERROR;
}

STDMETHODIMP CAMVideoPort::GetVPInfo(DDVIDEOPORTINFO* pVPInfo)
{
    *pVPInfo = m_svpInfo;
    return NOERROR;
}

STDMETHODIMP CAMVideoPort::GetVPBandwidth(DDVIDEOPORTBANDWIDTH* pVPBandwidth)
{
    *pVPBandwidth = m_sBandwidth;
    return NOERROR;
}

STDMETHODIMP CAMVideoPort::GetVPCaps(DDVIDEOPORTCAPS* pVPCaps)
{
    *pVPCaps = m_vpCaps;
    return NOERROR;
}

STDMETHODIMP CAMVideoPort::GetVPInputFormat(LPDDPIXELFORMAT* pVPFormat)
{
    *pVPFormat = m_pddVPInputVideoFormat;
    return NOERROR;
}

STDMETHODIMP CAMVideoPort::GetVPOutputFormat(LPDDPIXELFORMAT* pVPFormat)
{
    *pVPFormat = m_pddVPOutputVideoFormat;
    return NOERROR;
}


/******************************Public*Routine******************************\
* CAMVideoPort::OnClipChange
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::OnClipChange(LPWININFO pWinInfo)
{
    AMTRACE((TEXT("CAMVideoPort::OnClipChange")));

    HRESULT hr = NOERROR;
    LPVPDRAWFLAGS pvpDrawFlags = NULL;
    WININFO CopyWinInfo;
    AMVP_MODE tryMode;
    LPDIRECTDRAWSURFACE pPrimarySurface = NULL;


    CAutoLock cObjectLock(m_pMainObjLock);

    pPrimarySurface = m_pIVPControl->GetPrimarySurface();
    ASSERT(pPrimarySurface);

    if (!m_pOverlaySurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("OnClipChange, m_pOverlaySurface = NULL")));
        goto CleanUp;
    }

    // if the dest empty is empty just hide the overlay
    if (IsRectEmpty(&pWinInfo->DestClipRect))
    {
        hr = m_pIVPControl->CallUpdateOverlay(m_pOverlaySurface,
                                              NULL,
                                              pPrimarySurface,
                                              NULL,
                                              DDOVER_HIDE);
        goto CleanUp;
    }

    // make a copy of the WININFO so that we can modify it
    CopyWinInfo = *pWinInfo;

    // if there is no overlay surface, can't do anything!
    ASSERT(m_pOverlaySurface);

    // allocate the draw flags structure
    pvpDrawFlags = new VPDRAWFLAGS;
    if (pvpDrawFlags == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("pvpDrawFlags is NULL, Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // initialize the draw flags structure
    pvpDrawFlags->bUsingColorKey = TRUE;
    pvpDrawFlags->bDoUpdateVideoPort = FALSE;
    pvpDrawFlags->bDoTryAutoFlipping = TRUE;
    pvpDrawFlags->bDoTryDecimation = TRUE;

    // if the videoport is not running (the graph has been paused/stopped,
    // then we can't do any mode changes etc. We cannot really decimate video,
    // however we can just clip the video from the upper-left corner.
    if (m_VPState == AMVP_VIDEO_STOPPED && !m_bStart)
    {
        pvpDrawFlags->bDoUpdateVideoPort = FALSE;
        hr = DrawImage(&CopyWinInfo, m_StoredMode, pvpDrawFlags);

        // problem case, if we fail here there is really nothing more
        // we can do. We cannot try different modes for example.
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 1,
                    TEXT("DrawImage Failed, m_VPState = Stopped,")
                    TEXT(" mode = %d, hr = 0x%x"),
                    m_StoredMode, hr));
        }
        goto CleanUp;
    }


    if (m_StoredMode != m_CurrentMode)
    {
        pvpDrawFlags->bDoUpdateVideoPort = TRUE;
        m_StoredMode = m_CurrentMode;
    }

    tryMode = m_CurrentMode;

    if (tryMode == AMVP_MODE_WEAVE)
    {
        if (m_bCanWeave)
            hr = DrawImage(&CopyWinInfo, tryMode, pvpDrawFlags);
        if (!m_bCanWeave || FAILED(hr))
        {
            tryMode = AMVP_MODE_BOBINTERLEAVED;
            pvpDrawFlags->bDoUpdateVideoPort = TRUE;
        }
    }

    if (tryMode == AMVP_MODE_BOBINTERLEAVED)
    {
        if (m_bCanBobInterleaved)
            hr = DrawImage(&CopyWinInfo, tryMode, pvpDrawFlags);
        if (!m_bCanBobInterleaved || FAILED(hr))
        {
            tryMode = AMVP_MODE_BOBNONINTERLEAVED;
            pvpDrawFlags->bDoUpdateVideoPort = TRUE;
        }
    }

    if (tryMode == AMVP_MODE_BOBNONINTERLEAVED)
    {
        if (m_bCanBobNonInterleaved)
            hr = DrawImage(&CopyWinInfo, tryMode, pvpDrawFlags);
        if (!m_bCanBobNonInterleaved || FAILED(hr))
        {
            tryMode = AMVP_MODE_SKIPODD;
            pvpDrawFlags->bDoUpdateVideoPort = TRUE;
        }
    }

    if (tryMode == AMVP_MODE_SKIPODD)
    {
        if (m_bCanSkipOdd)
            hr = DrawImage(&CopyWinInfo, tryMode, pvpDrawFlags);
        if (!m_bCanSkipOdd || FAILED(hr))
        {
            tryMode = AMVP_MODE_SKIPEVEN;
            pvpDrawFlags->bDoUpdateVideoPort = TRUE;
        }
    }

    if (tryMode == AMVP_MODE_SKIPEVEN)
    {
        if (m_bCanSkipEven)
            hr = DrawImage(&CopyWinInfo, tryMode, pvpDrawFlags);
    }

    // save the last mode we tried
    m_StoredMode = tryMode;

    // change the current mode to somethig that succeeded
    if (SUCCEEDED(hr) && tryMode != m_CurrentMode)
    {
        m_CurrentMode = tryMode;
    }

    // problem case we have tried everything and it still fails!!!
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("DrawImage Failed, m_VPState = Stopped,")
                TEXT(" mode = %d, hr = 0x%x"),
                tryMode, hr));
    }

CleanUp:
    if (pvpDrawFlags)
    {
        delete pvpDrawFlags;
        pvpDrawFlags = NULL;
    }

    return hr;
}



/*****************************Private*Routine******************************\
* CAMVideoPort::NegotiateConnectionParamaters
*
* this functions negotiates the connection parameters with
* the decoder.
* Since this function might be called during renegotiation, the
* existing connection parameters are passed in as input and if
* possible, we try to use the same parameters.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::NegotiateConnectionParamaters()
{
    AMTRACE((TEXT("CAMVideoPort::NegotiateConnectionParamaters")));

    HRESULT hr = NOERROR;
    LPDDVIDEOPORTCONNECT lpddProposedConnect = NULL;
    DWORD dwNumProposedEntries = 0;
    DDVIDEOPORTSTATUS ddVPStatus = { sizeof(DDVIDEOPORTSTATUS)};
    LPDDVIDEOPORTCONNECT lpddVideoPortConnect = NULL;
    DWORD dwNumVideoPortEntries = 0;
    BOOL bIntersectionFound = FALSE;
    DWORD i, j;


    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_pIVPConfig);
    ASSERT(m_pDVP);

    // find the number of entries to be proposed
    hr = m_pIVPConfig->GetConnectInfo(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumProposedEntries);

    // allocate the necessary memory
    lpddProposedConnect = new DDVIDEOPORTCONNECT[dwNumProposedEntries];
    if (lpddProposedConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiateConnectionParamaters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroMemory(lpddProposedConnect,
               dwNumProposedEntries*sizeof(DDVIDEOPORTCONNECT));

    // set the right size in each of the structs.
    for (i = 0; i < dwNumProposedEntries; i++)
    {
        lpddProposedConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetConnectInfo(&dwNumProposedEntries, lpddProposedConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // get the status of the video port
    hr = m_pDVP->QueryVideoPortStatus(m_dwVideoPortId, &ddVPStatus);
    if (FAILED(hr))
    {
        //  Some cards don't implement this so just crash on
        ddVPStatus.bInUse = FALSE;
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->QueryVideoPortStatus failed, hr = 0x%x"), hr));
//	goto CleanUp;
    }

    // find the number of entries supported by the videoport
    hr = m_pDVP->GetVideoPortConnectInfo(m_dwVideoPortId, &dwNumVideoPortEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumVideoPortEntries);

    // allocate the necessary memory
    lpddVideoPortConnect = new DDVIDEOPORTCONNECT[dwNumVideoPortEntries];
    if (lpddVideoPortConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,
                TEXT("NegotiateConnectionParamaters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroMemory(lpddVideoPortConnect,
               dwNumVideoPortEntries*sizeof(DDVIDEOPORTCONNECT));

    // set the right size in each of the structs.
    for (i = 0; i < dwNumVideoPortEntries; i++)
    {
        lpddVideoPortConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries supported by the videoport
    hr = m_pDVP->GetVideoPortConnectInfo(0, &dwNumVideoPortEntries,
                                         lpddVideoPortConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pDVP->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }

    // check if the video port is not already in use
    if (!ddVPStatus.bInUse)
    {

        // take the first element of the intersection of the two lists and
        // set that value on the decoder
        for (i = 0; i < dwNumProposedEntries && !bIntersectionFound; i++)
        {
            for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
            {
                if ((lpddProposedConnect[i].dwPortWidth ==
                     lpddVideoPortConnect[j].dwPortWidth)
                  && IsEqualIID(lpddProposedConnect[i].guidTypeID,
                                lpddVideoPortConnect[j].guidTypeID))
                {
                    m_ddConnectInfo = lpddVideoPortConnect[j];
                    hr = m_pIVPConfig->SetConnectInfo(i);
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR,0,
                                TEXT("m_pIVPConfig->SetConnectInfo")
                                TEXT(" failed, hr = 0x%x"), hr));
                        goto CleanUp;
                    }

                    bIntersectionFound = TRUE;
                }
            }
        }
    }
    else
    {
        // take the first element of the list matching the current status
        for (i = 0; i < dwNumProposedEntries && !bIntersectionFound; i++)
        {
            if ((lpddProposedConnect[i].dwPortWidth ==
                 ddVPStatus.VideoPortType.dwPortWidth)
              && IsEqualIID(lpddProposedConnect[i].guidTypeID,
                            ddVPStatus.VideoPortType.guidTypeID))
            {

                for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
                {
                    if ((lpddProposedConnect[i].dwPortWidth ==
                         lpddVideoPortConnect[j].dwPortWidth)
                      && IsEqualIID(lpddProposedConnect[i].guidTypeID,
                                    lpddVideoPortConnect[j].guidTypeID))
                    {
                        m_ddConnectInfo = lpddVideoPortConnect[j];
                        bIntersectionFound = TRUE;
                    }
                }
                break;
            }
        }
    }

    if (!bIntersectionFound)
    {
        hr = E_FAIL;

        goto CleanUp;
    }

    // cleanup
CleanUp:
    delete [] lpddProposedConnect;
    delete [] lpddVideoPortConnect;
    return hr;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::EnumCallback
*
* This is a callback for the EnumVideoPorts method and saves the capabilites
* the video port.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CALLBACK
CAMVideoPort::EnumCallback(LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext )
{
    AMTRACE((TEXT("CAMVideoPort::EnumCallback")));
    HRESULT hr = NOERROR;
    CAMVideoPort* pAMVideoPort = (CAMVideoPort*)lpContext;


    if (pAMVideoPort) {
        if (lpCaps) {
            CopyMemory(&(pAMVideoPort->m_vpCaps), lpCaps, sizeof(DDVIDEOPORTCAPS));
        }
    }
    else
    {
        DbgLog((LOG_ERROR,0,
                TEXT("lpContext = NULL, THIS SHOULD NOT BE HAPPENING!!!")));
        hr = E_FAIL;
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::GetDataParameters
*
*
* this functions gets various data parameters from the decoder
* parameters include dimensions, double-clock, vact etc
* Also maximum pixel rate the decoder will output
* this happens after the connnection parameters have been set-up
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::GetDataParameters()
{
    AMTRACE((TEXT("CAMVideoPort::GetDataParameters")));

    HRESULT hr = NOERROR;
    DWORD dwMaxPixelsPerSecond = 0;
    AMVPSIZE amvpSize;

    CAutoLock cObjectLock(m_pMainObjLock);


    // set the size of the struct
    m_VPDataInfo.dwSize = sizeof(AMVPDATAINFO);

    // get the VideoPort data information
    hr = m_pIVPConfig->GetVPDataInfo(&m_VPDataInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVPDataInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    /*
    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom > m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom = m_VPDataInfo.amvpDimInfo.dwFieldHeight;
    */

    // if decoder says data is not interlaced
    if (!(m_VPDataInfo.bDataIsInterlaced))
    {
        // this flag does not mean anything
        if (m_VPDataInfo.bFieldPolarityInverted)
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        // these don't mean anything either
        if ((m_VPDataInfo.lHalfLinesOdd != 0) ||
            (m_VPDataInfo.lHalfLinesEven != 0))
        {
            hr = E_FAIL;
            goto CleanUp;
        }
    }

    amvpSize.dwWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    amvpSize.dwHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

    // get the maximum pixel rate the decoder will output
    hr = m_pIVPConfig->GetMaxPixelRate(&amvpSize, &dwMaxPixelsPerSecond);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetMaxPixelRate failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_dwPixelsPerSecond = dwMaxPixelsPerSecond;



    CleanUp:
    DbgLog((LOG_TRACE, 5,TEXT("Leaving CAMVideoPort::GetDataParameters")));
    return hr;
}

/*****************************Private*Routine******************************\
* CAMVideoPort::EqualPixelFormats
*
* this is just a helper function used by the "NegotiatePixelFormat"
* function. Just compares two pixel-formats to see if they are the
* same. We can't use a memcmp because of the fourcc codes.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
BOOL
CAMVideoPort::EqualPixelFormats(
    LPDDPIXELFORMAT lpFormat1,
    LPDDPIXELFORMAT lpFormat2)
{
    AMTRACE((TEXT("CAMVideoPort::EqualPixelFormats")));
    BOOL bRetVal = FALSE;

    CAutoLock cObjectLock(m_pMainObjLock);

    if (lpFormat1->dwFlags & lpFormat2->dwFlags & DDPF_RGB)
    {
        if (lpFormat1->dwRGBBitCount == lpFormat2->dwRGBBitCount &&
            lpFormat1->dwRBitMask == lpFormat2->dwRBitMask &&
            lpFormat1->dwGBitMask == lpFormat2->dwGBitMask &&
            lpFormat1->dwBBitMask == lpFormat2->dwBBitMask)
        {
            bRetVal = TRUE;
        }
    }
    else if (lpFormat1->dwFlags & lpFormat2->dwFlags & DDPF_FOURCC)
    {
        if (lpFormat1->dwFourCC == lpFormat2->dwFourCC)
        {
            bRetVal = TRUE;
        }
    }

    return bRetVal;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::GetBestFormat
*
* this function takes a list of inputformats and returns the
* "best" input and output format according to some criterion.
* It also checks if the output formats is suitable by trying
* to allocate a small surface and checking to see if the call
* succeeds. Since this is before the overlay surface has been
* created, that should be a ok. Right now the criterion just
* includes bestbendwidth, or if not that then just the first
* suitable one in the list.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT
CAMVideoPort::GetBestFormat(
    DWORD dwNumInputFormats,
    LPDDPIXELFORMAT lpddInputFormats,
    BOOL bGetBestBandwidth,
    LPDWORD lpdwBestEntry,
    LPDDPIXELFORMAT lpddBestOutputFormat)
{
    LPDDPIXELFORMAT lpddOutputFormats = NULL;
    DWORD dwNumOutputFormats = 0;
    HRESULT hr = NOERROR;

    DDVIDEOPORTBANDWIDTH sBandwidth;
    DWORD dwColorkey;
    DWORD dwOverlay;
    DWORD dwType;
    BOOL bOutputFormatSuitable = FALSE;
    DWORD i, j;

    AMTRACE((TEXT("CAMVideoPort::GetBestFormat")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // check all the pointers here
    ASSERT(dwNumInputFormats);
    CheckPointer(lpddInputFormats, E_INVALIDARG);
    CheckPointer(lpdwBestEntry, E_INVALIDARG);
    CheckPointer(lpddBestOutputFormat, E_INVALIDARG);

    // initialize dwType so that is different from DDVPBCAPS_SOURCE and
    // DDVPBCAPS_DESTINATION
    //
    if (DDVPBCAPS_SOURCE >= DDVPBCAPS_DESTINATION)
        dwType = DDVPBCAPS_SOURCE + 1;
    else
        dwType = DDVPBCAPS_DESTINATION + 1;

    for (i = 0; i < dwNumInputFormats; i++)
    {
        // no clean-up is neccesary at this point, so it is safe to use
        // this macro
        CheckPointer(lpddInputFormats+i, E_INVALIDARG);

        // find the number of entries supported by the videoport
        hr = m_pVideoPort->GetOutputFormats(lpddInputFormats + i,
                                            &dwNumOutputFormats,
                                            NULL, DDVPFORMAT_VIDEO);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            goto CleanUp;
        }
        ASSERT(dwNumOutputFormats);

        // allocate the necessary memory
        lpddOutputFormats = new DDPIXELFORMAT[dwNumOutputFormats];
        if (lpddOutputFormats == NULL)
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("new failed, failed to allocate memnory for ")
                    TEXT("lpddOutputFormats in NegotiatePixelFormat")));
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        // memset the allocated memory to zero
        ZeroMemory(lpddOutputFormats, dwNumOutputFormats*sizeof(DDPIXELFORMAT));

        // set the right size in each of the structs.
        for (j = 0; j < dwNumOutputFormats; j++)
        {
            lpddOutputFormats[j].dwSize = sizeof(DDPIXELFORMAT);
        }

        // get the entries supported by the videoport
        hr = m_pVideoPort->GetOutputFormats(lpddInputFormats + i,
                                            &dwNumOutputFormats,
                                            lpddOutputFormats,
                                            DDVPFORMAT_VIDEO);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            goto CleanUp;
        }


        for (j = 0; j < dwNumOutputFormats; j++)
        {
            bOutputFormatSuitable = FALSE;
            LPDDPIXELFORMAT lpTempOutFormat = lpddOutputFormats+j;

            // check if output format is suitable
            {
                DDSURFACEDESC ddsdDesc;
                ddsdDesc.dwSize = sizeof(DDSURFACEDESC);
                ddsdDesc.dwFlags = DDSD_CAPS | DDSD_HEIGHT |
                                   DDSD_WIDTH | DDSD_PIXELFORMAT;

                memcpy(&ddsdDesc.ddpfPixelFormat,
                       lpTempOutFormat, sizeof(DDPIXELFORMAT));

                ddsdDesc.ddsCaps.dwCaps = DDSCAPS_OVERLAY |
                                          DDSCAPS_VIDEOMEMORY |
                                          DDSCAPS_VIDEOPORT;

                // the actual overlay surface created might be of different
                // dimensions, however we are just testing the pixel format
                ddsdDesc.dwWidth = m_lImageWidth;
                ddsdDesc.dwHeight = m_lImageHeight;

                /*
                ASSERT(pDirectDraw);
                hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOverlaySurface, NULL);
                if (!FAILED(hr))
                {
                m_pOverlaySurface->Release();
                bOutputFormatSuitable = TRUE;
                }
                */
                m_pOverlaySurface = NULL;

                bOutputFormatSuitable = TRUE;
            }


            if (bOutputFormatSuitable)
            {
                if (!bGetBestBandwidth)
                {
                    if (dwType != DDVPBCAPS_SOURCE &&
                        dwType != DDVPBCAPS_DESTINATION)
                    {
                        sBandwidth.dwSize = sizeof(DDVIDEOPORTBANDWIDTH);

                        // do the first get_bandwidth just to get the type,
                        // can input 0 for the height and the width
                        hr = m_pVideoPort->GetBandwidthInfo(lpTempOutFormat,
                                                            0, 0, DDVPB_TYPE,
                                                            &sBandwidth);
                        if (FAILED(hr))
                        {
                            DbgLog((LOG_ERROR,0,
                            TEXT("m_pVideoPort->GetBandwidthInfo failed,")
                            TEXT(" hr = 0x%x"), hr));
                            //    goto CleanUp;
                        }
                        dwType = sBandwidth.dwCaps;

                        ASSERT(dwType == DDVPBCAPS_SOURCE ||
                               dwType == DDVPBCAPS_DESTINATION);

                        if (dwType == DDVPBCAPS_SOURCE)
                        {
                            dwOverlay = dwColorkey = (DWORD)0;
                        }
                        if (dwType == DDVPBCAPS_DESTINATION)
                        {
                            dwOverlay = dwColorkey = (DWORD) -1;
                        }
                    }
                    else if (dwType == DDVPBCAPS_SOURCE)
                    {
                        hr = m_pVideoPort->GetBandwidthInfo(lpTempOutFormat,
                                    m_VPDataInfo.amvpDimInfo.dwFieldWidth,
                                    m_VPDataInfo.amvpDimInfo.dwFieldHeight,
                                    DDVPB_OVERLAY, &sBandwidth);

                        if (FAILED(hr))
                        {
                            goto CleanUp;
                        }
                        if (dwOverlay < sBandwidth.dwOverlay ||
                            dwColorkey < sBandwidth.dwColorkey)
                        {
                            dwOverlay = sBandwidth.dwOverlay;
                            dwColorkey = sBandwidth.dwColorkey;
                            *lpdwBestEntry = i;

                            memcpy(lpddBestOutputFormat,
                                   lpTempOutFormat, sizeof(DDPIXELFORMAT));
                        }
                    }
                    else
                    {
                        ASSERT(dwType == DDVPBCAPS_DESTINATION);
                        hr = m_pVideoPort->GetBandwidthInfo(lpTempOutFormat,
                            m_VPDataInfo.amvpDimInfo.dwFieldWidth,
                            m_VPDataInfo.amvpDimInfo.dwFieldHeight,
                            DDVPB_VIDEOPORT, &sBandwidth);

                        if (FAILED(hr))
                        {
                            goto CleanUp;
                        }
                        if (dwOverlay > sBandwidth.dwOverlay ||
                            dwColorkey > sBandwidth.dwColorkey)
                        {
                            dwOverlay = sBandwidth.dwOverlay;
                            dwColorkey = sBandwidth.dwColorkey;
                            *lpdwBestEntry = i;
                            memcpy(lpddBestOutputFormat,
                                   lpTempOutFormat, sizeof(DDPIXELFORMAT));
                        }
                    }
                } // end of "if (bGetBestBandwidth)"
                else
                {
                    *lpdwBestEntry = i;
                    memcpy(lpddBestOutputFormat,
                           lpTempOutFormat, sizeof(DDPIXELFORMAT));
                    goto CleanUp;
                }
            } // end of "if (bOutputFormatSuitable)"

        } // end of the inner for loop


        // delete the mem allocated in the outer for loop
        delete [] lpddOutputFormats;
        lpddOutputFormats = NULL;

    } // end of outer for loop

    if (!FAILED(hr))
    {
        ASSERT(*lpdwBestEntry);
    }

    CleanUp:
    delete [] lpddOutputFormats;
    lpddOutputFormats = NULL;
    return hr;
}

/*****************************Private*Routine******************************\
* CAMVideoPort::NegotiatePixelFormat
*
* this function is used to negotiate the pixelformat with the decoder.
* It asks the decoder fot a list of input formats, intersects that list
* with the one the deocoder supports (while maintaining the order) and
* then calls "GetBestFormat" on that list to get the "best" input and
* output format. After that it calls "SetPixelFormat" on the decoder in
* order to inform the decoder of the decision.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::NegotiatePixelFormat()
{
    HRESULT hr = NOERROR;

    LPDDPIXELFORMAT lpddProposedFormats = NULL;
    DWORD dwNumProposedEntries = 0;
    LPDDPIXELFORMAT lpddVPInputFormats = NULL;
    DWORD dwNumVPInputEntries = 0;
    LPDDPIXELFORMAT lpddIntersectionFormats = NULL;
    DWORD dwNumIntersectionEntries = 0;
    DWORD dwBestEntry, dwMaxIntersectionEntries = 0;
    DWORD i = 0, j = 0;

    AMTRACE((TEXT("CAMVideoPort::NegotiatePixelFormat")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // find the number of entries to be proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumProposedEntries);

    // allocate the necessary memory
    lpddProposedFormats = new DDPIXELFORMAT[dwNumProposedEntries];
    if (lpddProposedFormats == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroMemory(lpddProposedFormats, dwNumProposedEntries*sizeof(DDPIXELFORMAT));

    // set the right size of all the structs
    for (i = 0; i < dwNumProposedEntries; i++)
    {
        lpddProposedFormats[i].dwSize = sizeof(DDPIXELFORMAT);
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, lpddProposedFormats);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // find the number of entries supported by the videoport
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries,
                                       NULL, DDVPFORMAT_VIDEO);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumVPInputEntries);

    // allocate the necessary memory
    lpddVPInputFormats = new DDPIXELFORMAT[dwNumVPInputEntries];
    if (lpddVPInputFormats == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroMemory(lpddVPInputFormats, dwNumVPInputEntries*sizeof(DDPIXELFORMAT));

    // set the right size of all the structs
    for (i = 0; i < dwNumVPInputEntries; i++)
    {
        lpddVPInputFormats[i].dwSize = sizeof(DDPIXELFORMAT);
    }

    // get the entries supported by the videoport
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries,
                                       lpddVPInputFormats, DDVPFORMAT_VIDEO);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }

    // calculate the maximum number of elements in the interesection
    dwMaxIntersectionEntries = (dwNumProposedEntries >= dwNumVPInputEntries) ?
                               (dwNumProposedEntries) : (dwNumVPInputEntries);

    // allocate the necessary memory
    lpddIntersectionFormats = new DDPIXELFORMAT[dwMaxIntersectionEntries];
    if (lpddIntersectionFormats == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    // no need to set the size of the structs here, as we will memcpy them anyway
    ZeroMemory(lpddIntersectionFormats, dwMaxIntersectionEntries*sizeof(DDPIXELFORMAT));

    // find the intersection of the two lists
    dwNumIntersectionEntries = 0;
    for (i = 0; i < dwNumProposedEntries; i++)
    {
        for (j = 0; j < dwNumVPInputEntries; j++)
        {
            if (EqualPixelFormats(lpddProposedFormats+i, lpddVPInputFormats+j))
            {
                memcpy((lpddIntersectionFormats+dwNumIntersectionEntries),
                       (lpddProposedFormats+i), sizeof(DDPIXELFORMAT));
                dwNumIntersectionEntries++;
                ASSERT(dwNumIntersectionEntries <= dwMaxIntersectionEntries);
            }
        }
    }

    // the number of entries in the intersection is zero!!
    // Return failure.
    if (dwNumIntersectionEntries == 0)
    {
        ASSERT(i == dwNumProposedEntries);
        ASSERT(j == dwNumVPInputEntries);
        hr = E_FAIL;
        goto CleanUp;
    }

    // call GetBestFormat with whatever search criterion you want
    hr = GetBestFormat(dwNumIntersectionEntries,
                       lpddIntersectionFormats, TRUE, &dwBestEntry,
                       m_pddVPOutputVideoFormat);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("GetBestFormat failed, hr = 0x%x"), hr));
        goto CleanUp;
    }


    // cache the input format
    memcpy(m_pddVPInputVideoFormat, lpddIntersectionFormats + dwBestEntry,
           sizeof(DDPIXELFORMAT));

    // set the format the decoder is supposed to be using
    for (i = 0; i < dwNumProposedEntries; i++)
    {
        if (EqualPixelFormats(lpddProposedFormats+i, m_pddVPInputVideoFormat))
        {
            hr = m_pIVPConfig->SetVideoFormat(i);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pIVPConfig->SetVideoFormat failed, hr = 0x%x"),
                        hr));
                goto CleanUp;
            }
            break;
        }
    }

    // we are sure that the chosen input format is in the input list
    ASSERT(i < dwNumProposedEntries);

CleanUp:
    // cleanup
    delete [] lpddProposedFormats;
    delete [] lpddVPInputFormats;
    delete [] lpddIntersectionFormats;
    return hr;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::CreateVideoPort
*
* Displays the Create Video Port dialog and calls DDRAW to actually
* create the port.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::CreateVideoPort()
{
    HRESULT hr = NOERROR;
    DDVIDEOPORTDESC svpDesc;
    DWORD dwTemp = 0, dwOldVal = 0;
    DWORD lHalfLinesOdd = 0, lHalfLinesEven = 0;
    AMTRACE((TEXT("CAMVideoPort::CreateVideoPort")));

    CAutoLock cObjectLock(m_pMainObjLock);

    INITDDSTRUCT(svpDesc);

    // if the decoder can send double clocked data and the videoport
    // supports it, then set that property. This field is only valid
    // with an external signal.
    if (m_VPDataInfo.bEnableDoubleClock &&
        m_ddConnectInfo.dwFlags & DDVPCONNECT_DOUBLECLOCK)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_DOUBLECLOCK;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_DOUBLECLOCK;
    }

    // if the decoder can give an external activation signal and the
    // videoport supports it, then set that property. This field is
    // only valid with an external signal.
    if (m_VPDataInfo.bEnableVACT &&
        m_ddConnectInfo.dwFlags & DDVPCONNECT_VACT)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_VACT;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_VACT;
    }

    // if the decoder can send interlaced data and the videoport
    // supports it, then set that property.
    if (m_VPDataInfo.bDataIsInterlaced)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INTERLACED;
        m_bVSInterlaced = TRUE;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_INTERLACED;
        m_bVSInterlaced = FALSE;
    }

    // handle the VREF stuff here
    if (m_ddConnectInfo.dwFlags & DDVPCONNECT_DISCARDSVREFDATA)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top -=
                m_VPDataInfo.dwNumLinesInVREF;

        if (m_VPDataInfo.amvpDimInfo.rcValidRegion.top < 0)
            m_VPDataInfo.amvpDimInfo.rcValidRegion.top = 0;
    }

    // handle the halfline stuff here
    lHalfLinesOdd = m_VPDataInfo.lHalfLinesOdd;
    lHalfLinesEven = m_VPDataInfo.lHalfLinesEven;

    // reset both the halfline and the invert polarity bits
    svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_HALFLINE;
    svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_INVERTPOLARITY;

    // if halflines are being reported assert that the data is interlaced
    if (lHalfLinesOdd != 0 || lHalfLinesEven != 0)
    {
        ASSERT(m_VPDataInfo.bDataIsInterlaced);
    }

    // whenever halflines exist, make sure to set the tell the hal
    if (((lHalfLinesOdd ==  1 || lHalfLinesEven ==  1) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) ||
        ((lHalfLinesOdd == -1 || lHalfLinesEven == -1) && (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))))
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_HALFLINE;
    }

    // In this case, the video is forced to move down one line
    // case 2 in scott's document
    if ((lHalfLinesOdd == 0) &&
        (lHalfLinesEven == 1) &&
        (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 1;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 2;
        m_bGarbageLine = TRUE;

        // if the deocder is already not inverting fields and if the VGA supports
        // inverting polarities, then ask the VGA to invert polarities othwise ask
        // decoder to invert polarities.
        if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
        {
            svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
        }
        else
        {
            hr = m_pIVPConfig->SetInvertPolarity();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pIVPConfig->SetInvertPolarity failed, hr = 0x%x"),
                        hr));
                goto CleanUp;
            }
        }
    }
    // case 3 and 5 in scott's document
    else if ((lHalfLinesOdd == 1) &&
             (lHalfLinesEven == 0))
    {
        // case 5 (just shift by one, do not reverse polarities
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 1;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 2;
        m_bGarbageLine = TRUE;
        m_bCantInterleaveHalfline = TRUE;


        // case 3 (shift by one and reverse polarities)
        if (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))
        {
            // if the deocder is already not inverting fields and if the
            // VGA supports inverting polarities, then ask the VGA to invert
            // polarities othwise ask decoder to invert polarities.
            //
            if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
            }
            else
            {
                hr = m_pIVPConfig->SetInvertPolarity();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetInvertPolarity failed,")
                            TEXT(" hr = 0x%x"),
                            hr));
                    goto CleanUp;
                }
            }
        }
    }
    // case 4 in scott's document
    else if ((lHalfLinesOdd == 0) &&
             (lHalfLinesEven == -1) &&
             (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)))
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 0;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 1;
        m_bGarbageLine = TRUE;
    }
    else if (((lHalfLinesOdd ==  0) && (lHalfLinesEven ==  0)) ||
             ((lHalfLinesOdd == -1) && (lHalfLinesEven ==  0) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) ||
             ((lHalfLinesOdd ==  0) && (lHalfLinesEven == -1) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) || // opposite of case 4
             ((lHalfLinesOdd ==  0) && (lHalfLinesEven ==  1) && (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)))) // opposite of case 2
    {
        // if the deocder is already inverting fields and if the VGA supports
        // inverting polarities, then ask the VGA to invert polarities
        // othwise ask decoder to invert polarities.
        if (m_VPDataInfo.bFieldPolarityInverted)
        {
            if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
            }
            else
            {
                hr = m_pIVPConfig->SetInvertPolarity();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetInvertPolarity failed,")
                            TEXT(" hr = 0x%x"), hr));
                    goto CleanUp;
                }
            }
        }
    }
    else
    {
        // Potential bug : workaround for current BPC driver
        // hr = E_FAIL; // we can't handle these cases, FAIL
        // goto CleanUp;
    }

    if (m_VPDataInfo.amvpDimInfo.dwFieldHeight <
        (DWORD)m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom)
    {
        m_VPDataInfo.amvpDimInfo.dwFieldHeight =
            m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom;
    }

    if ((m_vpCaps.dwFlags & DDVPD_WIDTH) &&
        (m_VPDataInfo.amvpDimInfo.dwFieldWidth > m_vpCaps.dwMaxWidth))
    {
        m_VPDataInfo.amvpDimInfo.dwFieldWidth = m_vpCaps.dwMaxWidth;
    }

    if ((m_vpCaps.dwFlags & DDVPD_WIDTH) &&
        (m_VPDataInfo.amvpDimInfo.dwVBIWidth > m_vpCaps.dwMaxVBIWidth))
    {
        m_VPDataInfo.amvpDimInfo.dwVBIWidth = m_vpCaps.dwMaxVBIWidth;
    }

    if ((m_vpCaps.dwFlags & DDVPD_HEIGHT) &&
        (m_VPDataInfo.amvpDimInfo.dwFieldHeight > m_vpCaps.dwMaxHeight))
    {
        m_VPDataInfo.amvpDimInfo.dwFieldHeight = m_vpCaps.dwMaxHeight;
    }

    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.right >
        (LONG)m_VPDataInfo.amvpDimInfo.dwFieldWidth)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.right =
                (LONG)m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    }

    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom >
        (LONG)m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom =
            (LONG)m_VPDataInfo.amvpDimInfo.dwFieldHeight;
    }

    // fill up the fields of the description struct
    svpDesc.dwFieldWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    svpDesc.dwVBIWidth = m_VPDataInfo.amvpDimInfo.dwVBIWidth;
    svpDesc.dwFieldHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

    svpDesc.dwMicrosecondsPerField = m_VPDataInfo.dwMicrosecondsPerField;
    svpDesc.dwMaxPixelsPerSecond = m_dwPixelsPerSecond;
    svpDesc.dwVideoPortID = m_dwVideoPortId;
    svpDesc.VideoPortType.dwSize = sizeof(DDVIDEOPORTCONNECT);
    svpDesc.VideoPortType.dwPortWidth = m_ddConnectInfo.dwPortWidth;
    memcpy(&svpDesc.VideoPortType.guidTypeID, &m_ddConnectInfo.guidTypeID, sizeof(GUID));

    DbgLog((LOG_TRACE, 3, TEXT("svpDesc")));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldWidth = %u"), svpDesc.dwFieldWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwVBIWidth   = %u"), svpDesc.dwVBIWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldHeight= %u"), svpDesc.dwFieldHeight));
    DbgLog((LOG_TRACE, 3, TEXT("dwMicrosecondsPerField= %u"), svpDesc.dwMicrosecondsPerField));
    DbgLog((LOG_TRACE, 3, TEXT("dwMaxPixelsPerSecond= %u"), svpDesc.dwMaxPixelsPerSecond));
    DbgLog((LOG_TRACE, 3, TEXT("dwVideoPortID= %u"), svpDesc.dwVideoPortID));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize= %u"), svpDesc.VideoPortType.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwPortWidth= %u"), svpDesc.VideoPortType.dwPortWidth));

    // create the videoport. The first parameter is dwFlags, reserved for
    // future use by ddraw. The last parameter is pUnkOuter, again must be
    // NULL.
    //
    // use the DDVPCREATE_VIDEOONLY flag only if the hal is capable of
    // streaming VBI on a seperate surface
    //
    if (m_vpCaps.dwCaps & DDVPCAPS_VBIANDVIDEOINDEPENDENT)
    {
        hr = m_pDVP->CreateVideoPort(DDVPCREATE_VIDEOONLY, &svpDesc,
                                     &m_pVideoPort, NULL);

        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pDVP->CreateVideoPort(DDVPCREATE_VIDEOONLY)")
                    TEXT(" failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else
    {
        hr = m_pDVP->CreateVideoPort(0, &svpDesc, &m_pVideoPort, NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pDVP->CreateVideoPort(0) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    CleanUp:
    return hr;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::DetermineCroppingRestrictions
*
*
* this function is used to check the cropping restrictions at the
* videoport and at the overlay. This function also decides where
* the cropping should be done (at videoport or at overlay).
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::DetermineCroppingRestrictions()
{
    AMTRACE((TEXT("CAMVideoPort::DetermineCroppingRestrictions")));
    HRESULT hr = NOERROR;

    BOOL bVideoPortCanCrop = TRUE, bOverlayCanCrop = TRUE;
    DWORD dwTemp = 0, dwOldVal = 0;
    DWORD dwCropOriginX = 0, dwCropOriginY = 0;
    DWORD dwCropWidth = 0, dwCropHeight=0;
    LPDDCAPS pDirectCaps = NULL;


    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectCaps = m_pIVPControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    // cache the cropping paramters
    dwCropOriginX = m_VPDataInfo.amvpDimInfo.rcValidRegion.left;
    dwCropOriginY = m_VPDataInfo.amvpDimInfo.rcValidRegion.top;
    dwCropWidth = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                          m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
    dwCropHeight = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom -
                           m_VPDataInfo.amvpDimInfo.rcValidRegion.top);


    // Align the left boundary
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_ALIGN))
    {
        dwTemp = dwCropOriginX & (m_vpCaps.dwAlignVideoPortCropBoundary-1);
        if (dwTemp != 0)
        {
            dwOldVal = dwCropOriginX;
            dwCropOriginX = dwCropOriginX +
                            m_vpCaps.dwAlignVideoPortCropBoundary - dwTemp;

            m_VPDataInfo.amvpDimInfo.rcValidRegion.left = dwCropOriginX;
            dwCropWidth = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                                  m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
            DbgLog((LOG_TRACE,2,
                    TEXT("Alligning the left cropping boundary from %d to %d"),
                    dwOldVal, dwCropOriginX));
        }
    }

    // Align the width
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_ALIGN))
    {
        dwTemp = dwCropWidth & (m_vpCaps.dwAlignVideoPortCropWidth-1);
        if (dwTemp != 0)
        {
            dwOldVal = dwCropOriginX;
            dwCropWidth = dwCropWidth - dwTemp;
            m_VPDataInfo.amvpDimInfo.rcValidRegion.right =
                dwCropWidth + (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
            DbgLog((LOG_TRACE,2,
                    TEXT("Alligning the width of cropping rect from %d to %d"),
                    dwOldVal, dwCropWidth));
        }
    }

    // determine if we can do without any cropping at all
    if (dwCropOriginX == 0 && dwCropOriginY == 0 &&
        dwCropWidth == m_VPDataInfo.amvpDimInfo.dwFieldWidth &&
        dwCropHeight == m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    {
        // hurray we are home free!!!
        DbgLog((LOG_TRACE,1, TEXT("No cropping necessary")));
        m_CropState = AMVP_NO_CROP;
        goto CleanUp;
    }

    // determine if the videoport can do the cropping for us

    // Can the videoport crop in the X direction
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_FX))
    {
        if (dwCropWidth != m_VPDataInfo.amvpDimInfo.dwFieldWidth &&
            (m_vpCaps.dwFX & DDVPFX_CROPX) == 0)
        {
            DbgLog((LOG_ERROR,1, TEXT("VideoPort can't crop, DDVPFX_CROPX == 0")));
            bVideoPortCanCrop = FALSE;
        }
    }

    // Can the videoport crop in the Y direction
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_FX))
    {
        if (dwCropHeight != m_VPDataInfo.amvpDimInfo.dwFieldHeight &&
            (m_vpCaps.dwFX & DDVPFX_CROPY) == 0 &&
            (m_vpCaps.dwFX & DDVPFX_CROPTOPDATA) == 0)
        {
            DbgLog((LOG_ERROR,1, TEXT("VideoPort can't crop, DDVPFX_CROPY == 0")));
            bVideoPortCanCrop = FALSE;
        }
    }


    // ok, so the videoport can crop for us. So no need to crop at the
    // overlay surface.
    if (bVideoPortCanCrop)
    {
        DbgLog((LOG_TRACE,2, TEXT("Cropping would be done at the videoport")));
        m_CropState = AMVP_CROP_AT_VIDEOPORT;
        goto CleanUp;
    }

    // determine if the overlay can do the cropping for us

    // Is left boundary alligned
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNBOUNDARYDEST))
    {
        dwTemp = dwCropOriginX & (pDirectCaps->dwAlignBoundaryDest-1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.left = %d"),
                    dwTemp, dwCropOriginX));
            bOverlayCanCrop = FALSE;
        }
    }
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNBOUNDARYSRC))
    {
        dwTemp = dwCropOriginX & (pDirectCaps->dwAlignBoundarySrc-1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.left = %d"),
                    dwTemp, dwCropOriginX));
            bOverlayCanCrop = FALSE;
        }
    }

    // Is Width alligned
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNSIZEDEST))
    {
        dwTemp = dwCropWidth & (pDirectCaps->dwAlignSizeDest -1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.Width = %d"),
                    dwTemp, dwCropWidth));
            bOverlayCanCrop = FALSE;
        }
    }
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNSIZESRC))
    {
        dwTemp = dwCropWidth & (pDirectCaps->dwAlignSizeSrc -1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.Width = %d"),
                    dwTemp, dwCropWidth));
            bOverlayCanCrop = FALSE;
        }
    }

    // ok, the videoport was unsuitable but the overlay came through
    // this means more pain for me, no!!!
    if (bOverlayCanCrop)
    {
        DbgLog((LOG_ERROR,1,
                TEXT("Cropping would be done at the overlay")));
        m_CropState = AMVP_CROP_AT_OVERLAY;
    }

    if (!bOverlayCanCrop && m_CropState == AMVP_CROP_AT_OVERLAY)
    {
        // neither the videoport nor the overlay is suitable, bail out
        hr = E_FAIL;
        goto CleanUp;
    }

    CleanUp:
    return hr;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::CreateVPOverlay
*
* this function is used to allocate an overlay surface to attach to the
* videoport.
* The allocation order it tries is just in decreasing amount of memory
* required. Theres is one ambiguity, which is resolved by bPreferBuffers
* (3 buffers, double height)
* (2 buffers, double height)
* (3 buffers, single height)
* (2 buffers, single height) OR (1 buffer , double height) (depends upon bPreferBuffers)
* (1 buffer , single height).
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/

HRESULT
CAMVideoPort::CreateVPOverlay(
    BOOL bTryDoubleHeight,
    DWORD dwMaxBuffers,
    BOOL bPreferBuffers)
{
    DDSURFACEDESC ddsdDesc;
    HRESULT hr = NOERROR;
    DWORD dwMaxHeight = 0, dwMinHeight = 0, dwCurHeight = 0, dwCurBuffers = 0;
    LPDIRECTDRAW pDirectDraw = NULL;

    AMTRACE((TEXT("CAMVideoPort::CreateVPOverlay")));

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectDraw = m_pIVPControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    // initialize the fields of ddsdDesc
    ddsdDesc.dwSize = sizeof(DDSURFACEDESC);
    ddsdDesc.dwFlags = DDSD_CAPS |
                       DDSD_HEIGHT |
                       DDSD_WIDTH |
                       DDSD_PIXELFORMAT;

    memcpy(&ddsdDesc.ddpfPixelFormat, m_pddVPOutputVideoFormat,
           sizeof(DDPIXELFORMAT));

    ddsdDesc.ddsCaps.dwCaps = DDSCAPS_OVERLAY |
                              DDSCAPS_VIDEOMEMORY |
                              DDSCAPS_VIDEOPORT;
    ddsdDesc.dwWidth = m_lImageWidth;

    dwMaxHeight = dwMinHeight = m_lImageHeight;

    // we will try to allocate double height surface, only if the decoder is
    // sending interlaced data, and the videoport supports interlaced data
    // and can interleave interlaced data in memory and bTryDoubleHeight is true
    if (bTryDoubleHeight)
    {
        dwMaxHeight = 2 * m_lImageHeight;
    }
    else
    {
        // make sure that bPreferBuffers is TRUE here, since it is a single
        // height case making it FALSE would not make any sense
        bPreferBuffers = TRUE;
    }

    // we will only try to allocate more than one buffer, if the videoport
    // is cabable of autoflipping
    if (dwMaxBuffers > 1)
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;

        for (dwCurHeight = dwMaxHeight;
             !m_pOverlaySurface && dwCurHeight >= dwMinHeight; dwCurHeight /= 2)
        {
            for (dwCurBuffers = dwMaxBuffers;
                 !m_pOverlaySurface &&  dwCurBuffers >= 2; dwCurBuffers--)
            {

                // if the case is (2 buffers, single height) but we prefer
                // more height rather than more buffers, then postpone this
                // case. We will come to it eventually, if the other cases fail.
                if (!bPreferBuffers &&
                    dwCurBuffers == 2 &&
                    dwCurHeight == m_lImageHeight)
                {
                    continue;
                }

                ddsdDesc.dwHeight = dwCurHeight;
                ddsdDesc.dwBackBufferCount = dwCurBuffers-1;

                hr = pDirectDraw->CreateSurface(&ddsdDesc,
                                                &m_pOverlaySurface, NULL);
                if (SUCCEEDED(hr))
                {
                    m_dwBackBufferCount = dwCurBuffers-1;
                    m_dwOverlaySurfaceHeight = ddsdDesc.dwHeight;
                    m_dwOverlaySurfaceWidth = ddsdDesc.dwWidth;
                    goto CleanUp;
                }
            }
        }
    }

    // we should only reach this point when attempt to allocate multiple buffers
    // failed or no autoflip available or bPreferBuffers is FALSE


    // case (1 buffer, double height)
    if (dwMaxHeight == 2*m_lImageHeight)
    {
        ddsdDesc.dwHeight = 2*m_lImageHeight;
        ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
        ddsdDesc.dwBackBufferCount = 0;

        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOverlaySurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 0;
            m_dwOverlaySurfaceHeight = ddsdDesc.dwHeight;
            m_dwOverlaySurfaceWidth = ddsdDesc.dwWidth;
            goto CleanUp;
        }
    }

    // case (2 buffer, single height) only if you prefer height to buffers
    if (bPreferBuffers && (dwMaxBuffers > 1) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP))
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;

        ddsdDesc.dwHeight = 2*m_lImageHeight;
        ddsdDesc.dwBackBufferCount = 1;

        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOverlaySurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 1;
            m_dwOverlaySurfaceHeight = ddsdDesc.dwHeight;
            m_dwOverlaySurfaceWidth = ddsdDesc.dwWidth;
            goto CleanUp;
        }
    }

    // case (1 buffer, single height)
    {
        ddsdDesc.dwHeight = m_lImageHeight;
        ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
        ddsdDesc.dwBackBufferCount = 0;
        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOverlaySurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 0;
            m_dwOverlaySurfaceHeight = ddsdDesc.dwHeight;
            m_dwOverlaySurfaceWidth = ddsdDesc.dwWidth;
            goto CleanUp;
        }
    }

    ASSERT(!m_pOverlaySurface);
    DbgLog((LOG_ERROR,0,  TEXT("Unable to create overlay surface")));

    CleanUp:
    if (SUCCEEDED(hr))
    {
        DbgLog((LOG_TRACE, 1,
                TEXT("Created an Overlay Surface of Width=%d,")
                TEXT(" Height=%d, Total-No-of-Buffers=%d"),
                m_dwOverlaySurfaceWidth, m_dwOverlaySurfaceHeight,
                m_dwBackBufferCount+1));
    }

    return hr;
}

/*****************************Private*Routine******************************\
* CAMVideoPort::SetSurfaceParameters
*
* SetSurfaceParameters used to tell the decoder where the
* valid data is on the surface
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::SetSurfaceParameters()
{
    HRESULT hr = NOERROR;
    DWORD dwPitch = 0;
    DDSURFACEDESC ddSurfaceDesc;

    AMTRACE((TEXT("CAMVideoPort::SetSurfaceParameters")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // get the surface description
    INITDDSTRUCT(ddSurfaceDesc);
    hr = m_pOverlaySurface->GetSurfaceDesc(&ddSurfaceDesc);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_pOverlaySurface->GetSurfaceDesc failed, hr = 0x%x"),
                hr));
    }
    else
    {
        ASSERT(ddSurfaceDesc.dwFlags & DDSD_PITCH);
        dwPitch = (ddSurfaceDesc.dwFlags & DDSD_PITCH) ?
                    ddSurfaceDesc.lPitch :
                    ddSurfaceDesc.dwWidth;
    }

    hr = m_pIVPConfig->SetSurfaceParameters(dwPitch, 0, 0);

    // right now the proxy maps ERROR_SET_NOT_FOUND to an HRESULT and
    // returns that failure code if the driver does not implement a function
    //
    if (hr == E_NOTIMPL || hr == (HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)))
    {
        hr = NOERROR;
        DbgLog((LOG_TRACE, 5,TEXT("SetSurfaceParamters not implemented")));
        goto CleanUp;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5,TEXT("SetSurfaceParamters failed, hr = 0x%x"), hr));
    }

CleanUp:
    return hr;
}



/*****************************Private*Routine******************************\
* CAMVideoPort::InitializeVideoPortInfo
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::InitializeVideoPortInfo()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CAMVideoPort::InitializeVideoPortInfo")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // initialize the DDVIDEOPORTINFO struct to be passed to start-video
    INITDDSTRUCT(m_svpInfo);
    m_svpInfo.lpddpfInputFormat = m_pddVPInputVideoFormat;

    if (m_CropState == AMVP_CROP_AT_VIDEOPORT)
    {
        m_svpInfo.rCrop = m_VPDataInfo.amvpDimInfo.rcValidRegion;
        m_svpInfo.dwVPFlags |= DDVP_CROP;

        // use the VBI height only if the hal is capable of streaming
        // VBI on a seperate surface
        if (m_vpCaps.dwCaps & DDVPCAPS_VBIANDVIDEOINDEPENDENT)
        {
            m_svpInfo.dwVBIHeight = m_VPDataInfo.amvpDimInfo.rcValidRegion.top;
        }
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_CROP;
    }

    if (m_bVPSyncMaster)
    {
        m_svpInfo.dwVPFlags |= DDVP_SYNCMASTER;
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_SYNCMASTER;
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CAMVideoPort::CheckDDrawVPCaps
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::CheckDDrawVPCaps()
{
    HRESULT hr = NOERROR;
    BOOL bAlwaysColorkey;

    AMTRACE((TEXT("CAMVideoPort::CheckDDrawVPCaps")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // Determine if we should always colorkey, or only when we need to.
    // At issue is the fact that some overlays cannot colorkey and Y
    // interpolate at the same time.  If not, we will only colorkey when
    // we have to.
    m_sBandwidth.dwSize = sizeof(DDVIDEOPORTBANDWIDTH);
    hr = m_pVideoPort->GetBandwidthInfo(m_pddVPOutputVideoFormat,
                                        m_lImageWidth, m_lImageHeight,
                                        DDVPB_TYPE, &m_sBandwidth);

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pVideoPort->GetBandwidthInfo FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE)
    {
        hr = m_pVideoPort->GetBandwidthInfo(m_pddVPOutputVideoFormat,
                                            m_lImageWidth, m_lImageHeight,
                                            DDVPB_OVERLAY, &m_sBandwidth);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pVideoPort->GetBandwidthInfo FAILED, hr = 0x%x"),
                    hr));
            goto CleanUp;
        }
        // store the caps info in this struct itself
        m_sBandwidth.dwCaps = DDVPBCAPS_SOURCE;
        if (m_sBandwidth.dwYInterpAndColorkey < m_sBandwidth.dwYInterpolate  &&
            m_sBandwidth.dwYInterpAndColorkey < m_sBandwidth.dwColorkey)
        {
            bAlwaysColorkey = FALSE;
        }
        else
        {
            bAlwaysColorkey = TRUE;
        }
    }
    else
    {
        ASSERT(m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION);


        DWORD dwImageHeight = m_lImageHeight;
        if (m_fCaptureInterleaved) {
            dwImageHeight /= 2;
        }

        hr = m_pVideoPort->GetBandwidthInfo(m_pddVPOutputVideoFormat,
                                            m_lImageWidth, dwImageHeight,
                                            DDVPB_VIDEOPORT, &m_sBandwidth);
        if (hr != DD_OK)
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("GetBandwidthInfo FAILED, hr = 0x%x"), hr));
            goto CleanUp;
        }
        // store the caps info in this struct itself
        m_sBandwidth.dwCaps = DDVPBCAPS_DESTINATION;
        if (m_sBandwidth.dwYInterpAndColorkey > m_sBandwidth.dwYInterpolate &&
            m_sBandwidth.dwYInterpAndColorkey > m_sBandwidth.dwColorkey)
        {
            bAlwaysColorkey = FALSE;
        }
        else
        {
            bAlwaysColorkey = TRUE;
        }
    }

    // determine the decimation properties in the x direction

    // Data can be arbitrarily shrunk
    if (m_vpCaps.dwFX & DDVPFX_PRESHRINKX) {

        m_DecimationModeX = DECIMATE_ARB;
    }

    // Data can be shrunk in increments of 1/x in the X direction
    // (where x is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKXS) {

        m_DecimationModeX = DECIMATE_INC;
        m_ulDeciStepX = m_vpCaps.dwPreshrinkXStep;

        DbgLog((LOG_TRACE, 1,
                TEXT("preshrink X increment %d"), m_vpCaps.dwPreshrinkXStep));
    }

    // Data can be binary shrunk (1/2, 1/4, 1/8, etc.)
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKXB) {

        m_DecimationModeX = DECIMATE_BIN;
    }

    // no scaling at all supported !!
    else {

        m_DecimationModeX = DECIMATE_NONE;
    }

    // determine the decimation properties in the y direction

    // Data can be arbitrarily shrunk
    if (m_vpCaps.dwFX & DDVPFX_PRESHRINKY)
    {
        m_DecimationModeY = DECIMATE_ARB;
    }

    // Data can be shrunk in increments of 1/x in the Y direction
    // (where x is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKYS)
    {
        m_DecimationModeY = DECIMATE_INC;
        m_ulDeciStepX = m_vpCaps.dwPreshrinkYStep;
    }

    // Data can be binary shrunk (1/2, 1/4, 1/8, etc.)
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKYB)
    {
        m_DecimationModeY = DECIMATE_BIN;
    }

    else {
        m_DecimationModeY = DECIMATE_NONE;
    }

CleanUp:
    return hr;
}




/*****************************Private*Routine******************************\
* CAMVideoPort::DetermineModeRestrictions
*
* Determine if we can bob(interleaved/non), weave, or skip fields
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::DetermineModeRestrictions()
{
    AMTRACE((TEXT("CAMVideoPort::DetermineModeRestrictions")));
    HRESULT hr = NOERROR;
    LPDDCAPS pDirectCaps = NULL;

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectCaps = m_pIVPControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    m_bCanWeave = FALSE;
    m_bCanBobInterleaved = FALSE;
    m_bCanBobNonInterleaved = FALSE;
    m_bCanSkipOdd = FALSE;
    m_bCanSkipEven = FALSE;

    // this is just a policy. Don't weave interlaced content cause of
    // motion artifacts
    if ((!m_bVSInterlaced) &&
        m_dwOverlaySurfaceHeight >= m_lImageHeight * 2 &&
        m_dwBackBufferCount > 0)
    {
        m_bCanWeave = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Weave")));
    }

    if (m_bVSInterlaced &&
        m_dwOverlaySurfaceHeight >= m_lImageHeight * 2 &&
        pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED)
    {
        m_bCanBobInterleaved = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Bob Interleaved")));
    }

    if (m_bVSInterlaced &&
        m_dwBackBufferCount > 0 &&
        pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED)
    {
        m_bCanBobNonInterleaved = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Bob NonInterleaved")));
    }

    if (m_vpCaps.dwCaps & DDVPCAPS_SKIPODDFIELDS)
    {
        m_bCanSkipOdd = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Skip Odd")));
    }

    if (m_vpCaps.dwCaps & DDVPCAPS_SKIPEVENFIELDS)
    {
        m_bCanSkipEven = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Skip Even")));
    }

    return hr;
}

/*****************************Private*Routine******************************\
* SurfaceCounter
*
* This routine is appropriate as a callback for
* IDirectDrawSurface2::EnumAttachedSurfaces()
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT WINAPI
SurfaceCounter(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    LPVOID lpContext
    )
{
    DWORD *dwCount = (DWORD *)lpContext;

    (*dwCount)++;

    return DDENUMRET_OK;
}

/*****************************Private*Routine******************************\
* SurfaceKernelHandle
*
*
* This routine is appropriate as a callback for
* IDirectDrawSurface2::EnumAttachedSurfaces().  The context parameter is a
* block of storage where the first DWORD element is the count of the remaining
* DWORD elements in the block.
*
* Each time this routine is called, it will increment the count, and put a
* kernel handle in the next available slot.
*
* It is assumed that the block of storage is large enough to hold the total
* number of kernel handles. The ::SurfaceCounter callback is one way to
* assure this (see above).
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT WINAPI
SurfaceKernelHandle(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    LPVOID lpContext
    )
{
    IDirectDrawSurfaceKernel *pDDSK = NULL;
    DWORD *pdwKernelHandleCount = (DWORD *)lpContext;
    ULONG_PTR *pKernelHandles = ((ULONG_PTR *)(pdwKernelHandleCount))+1;
    HRESULT hr;

    AMTRACE((TEXT("::SurfaceKernelHandle")));

    // get the IDirectDrawKernel interface
    hr = lpDDSurface->QueryInterface(IID_IDirectDrawSurfaceKernel,
                                     (LPVOID *)&pDDSK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("QueryInterface for IDirectDrawSurfaceKernel failed,")
                TEXT(" hr = 0x%x"), hr));
        goto CleanUp;
    }

    // get the kernel handle, using the first element of the context
    // as an index into the array
    ASSERT(pDDSK);
    hr = pDDSK->GetKernelHandle(pKernelHandles + *pdwKernelHandleCount);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("GetKernelHandle from IDirectDrawSurfaceKernel failed,")
                TEXT(" hr = 0x%x"), hr));
        goto CleanUp;
    }
    (*pdwKernelHandleCount)++;

    hr = DDENUMRET_OK;

    CleanUp:
    // release the kernel ddraw surface handle
    if (pDDSK)
    {
        pDDSK->Release();
        pDDSK = NULL;
    }

    return hr;
}

/*****************************Private*Routine******************************\
* CAMVideoPort::SetDDrawKernelHandles
*
* this function is used to inform the decoder of the various ddraw
* kernel handle using IVPConfig interface
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::SetDDrawKernelHandles()
{
    HRESULT hr = NOERROR, hrFailure = NOERROR;
    IDirectDrawKernel *pDDK = NULL;
    IDirectDrawSurfaceKernel *pDDSK = NULL;
    DWORD *pdwKernelHandleCount = 0;
    DWORD dwCount = 0;
    ULONG_PTR dwDDKernelHandle = 0;
    LPDIRECTDRAW pDirectDraw = NULL;

    AMTRACE((TEXT("CAMVideoPort::SetDDrawKernelHandles")));

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectDraw = m_pIVPControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    // get the IDirectDrawKernel interface
    hr = pDirectDraw->QueryInterface(IID_IDirectDrawKernel, (LPVOID *)&pDDK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("QueryInterface for IDirectDrawKernel failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // get the kernel handle
    ASSERT(pDDK);
    hr = pDDK->GetKernelHandle(&dwDDKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("GetKernelHandle from IDirectDrawKernel failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // set the kernel handle to directdraw using IVPConfig
    ASSERT(m_pIVPConfig);
    ASSERT(dwDDKernelHandle);
    hr = m_pIVPConfig->SetDirectDrawKernelHandle(dwDDKernelHandle);
    if (FAILED(hr))
    {
        hrFailure = hr;
        DbgLog((LOG_ERROR,0,
                TEXT("IVPConfig::SetDirectDrawKernelHandle failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // set the VidceoPort Id using IVPConfig
    ASSERT(m_pIVPConfig);
    hr = m_pIVPConfig->SetVideoPortID(m_dwVideoPortId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("IVPConfig::SetVideoPortID failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Count the attached surfaces
    dwCount = 1; // includes the surface we already have a pointer to
    hr = m_pOverlaySurface->EnumAttachedSurfaces((LPVOID)&dwCount,
                                                  SurfaceCounter);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("EnumAttachedSurfaces failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Allocate a buffer to hold the count and surface handles (count + array of handles)
    // pdwKernelHandleCount is also used as a pointer to the count followed by the array
    //
    pdwKernelHandleCount = (DWORD *)CoTaskMemAlloc(
            sizeof(ULONG_PTR) + dwCount*sizeof(ULONG_PTR));

    if (pdwKernelHandleCount == NULL)
    {
        DbgLog((LOG_ERROR,0,
                TEXT("Out of memory while retrieving surface kernel handles")));
        goto CleanUp;
    }

    {
        // handle array is right after the DWORD count
        ULONG_PTR *pKernelHandles = ((ULONG_PTR *)(pdwKernelHandleCount))+1;

        // Initialize the array with the handle for m_pOverlaySurface
        *pdwKernelHandleCount = 0;
        hr = SurfaceKernelHandle(m_pOverlaySurface, NULL,
                                (PVOID)pdwKernelHandleCount);
        if (hr != DDENUMRET_OK)
        {
            goto CleanUp;
        }

        hr = m_pOverlaySurface->EnumAttachedSurfaces(
                                    (LPVOID)pdwKernelHandleCount,
                                    SurfaceKernelHandle);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("EnumAttachedSurfaces failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // set the kernel handle to the overlay surface using IVPConfig
        ASSERT(m_pIVPConfig);
        hr = m_pIVPConfig->SetDDSurfaceKernelHandles(*pdwKernelHandleCount,
                                                     pKernelHandles);
        if (FAILED(hr))
        {
            hrFailure = hr;
            DbgLog((LOG_ERROR,0,
                    TEXT("IVPConfig::SetDirectDrawKernelHandles failed,")
                    TEXT(" hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    CleanUp:
    // release the kernel ddraw handle
    if (pDDK)
    {
        pDDK->Release();
        pDDK = NULL;
    }

    if (pdwKernelHandleCount)
    {
        CoTaskMemFree(pdwKernelHandleCount);
        pdwKernelHandleCount = NULL;
    }

    return hrFailure;
}



/*****************************Private*Routine******************************\
* CAMVideoPort::DrawImage
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::DrawImage(
    LPWININFO pWinInfo,
    AMVP_MODE mode,
    LPVPDRAWFLAGS pvpDrawFlags
    )
{
    HRESULT hr = NOERROR;
    BOOL bUpdateVideoReqd = FALSE;
    BOOL bYInterpolating = FALSE;
    WININFO CopyWinInfo;
    BOOL bMaintainRatio = TRUE;
    LPDIRECTDRAWSURFACE pPrimarySurface = NULL;
    LPDDCAPS pDirectCaps = NULL;

    AMTRACE((TEXT("CAMVideoPort::DrawImage")));

    CAutoLock cObjectLock(m_pMainObjLock);

    pPrimarySurface = m_pIVPControl->GetPrimarySurface();
    ASSERT(pPrimarySurface);

    pDirectCaps = m_pIVPControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    CopyWinInfo = *pWinInfo;

    if (mode == AMVP_MODE_BOBNONINTERLEAVED || mode == AMVP_MODE_BOBINTERLEAVED)
        bYInterpolating = TRUE;

    if (pvpDrawFlags->bDoTryAutoFlipping && m_dwBackBufferCount > 0)
        m_svpInfo.dwVPFlags |= DDVP_AUTOFLIP;
    else
        m_svpInfo.dwVPFlags &= ~DDVP_AUTOFLIP;

    if (pvpDrawFlags->bDoTryDecimation)
    {
        BOOL bSrcSizeChanged = FALSE;
        hr = SetUpMode(&CopyWinInfo, mode);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("SetUpMode failed, mode = %d, hr = 0x%x"), mode, hr));
            goto CleanUp;
        }

        bSrcSizeChanged = ApplyDecimation(&CopyWinInfo,
                                          pvpDrawFlags->bUsingColorKey,
                                          bYInterpolating);

        if (bSrcSizeChanged || pvpDrawFlags->bDoUpdateVideoPort)
            bUpdateVideoReqd = TRUE;
    }
    else
    {
        hr = SetUpMode(&CopyWinInfo, mode);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("SetUpMode failed, mode = %d, hr = 0x%x"), mode, hr));
            goto CleanUp;
        }
    }

    if (m_fCapturing) {
        if (m_fCaptureInterleaved) {
            m_svpInfo.dwVPFlags |= DDVP_INTERLEAVE;
            m_dwOverlayFlags &= ~DDOVER_BOB;
        }
        else {
            m_svpInfo.dwVPFlags &= ~DDVP_INTERLEAVE;
        }
    }

    // no point making any videoport calls, if the video is stopped
    if (m_VPState == AMVP_VIDEO_RUNNING || m_bStart)
    {
        if (m_bStart)
        {
            DWORD dwSignalStatus;

            hr = m_pVideoPort->StartVideo(&m_svpInfo);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0,
                        TEXT("StartVideo failed, mode = %d, hr = 0x%x"),
                        mode, hr));
                goto CleanUp;
            }
            DbgLog((LOG_ERROR,0, TEXT("StartVideo DONE!!!")));

            // check if the videoport is receiving a signal.
            hr = m_pVideoPort->GetVideoSignalStatus(&dwSignalStatus);
            if ((SUCCEEDED(hr)) && (dwSignalStatus == DDVPSQ_SIGNALOK))
            {
                m_pVideoPort->WaitForSync(DDVPWAIT_END, 0, 0);
            }
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pVideoPort->GetVideoSignalStatus() failed,")
                        TEXT(" hr = 0x%x"), hr));
                hr = NOERROR;
            }


            m_bStart = FALSE;
        }
        else if (bUpdateVideoReqd)
        {
            DbgLog((LOG_TRACE,1, TEXT("UpdateVideo (%d, %d)"),
                    m_svpInfo.dwPrescaleWidth, m_svpInfo.dwPrescaleHeight));

            hr = m_pVideoPort->UpdateVideo(&m_svpInfo);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("UpdateVideo failed, mode = %d, hr = 0x%x"),
                        mode, hr));
                goto CleanUp;
            }
        }
    }

    CalcSrcClipRect(&CopyWinInfo.SrcRect, &CopyWinInfo.SrcClipRect,
                    &CopyWinInfo.DestRect, &CopyWinInfo.DestClipRect,
                    bMaintainRatio);

    AlignOverlaySrcDestRects(pDirectCaps, &CopyWinInfo.SrcClipRect,
                             &CopyWinInfo.DestClipRect);

    // should we colour key ??
    if (pvpDrawFlags->bUsingColorKey)
        m_dwOverlayFlags |= DDOVER_KEYDEST;
    else
        m_dwOverlayFlags &= ~DDOVER_KEYDEST;

    m_rcSource = CopyWinInfo.SrcClipRect;


    if (!(m_svpInfo.dwVPFlags & DDVP_INTERLEAVE))
    {
        m_rcSource.top *= 2;
        m_rcSource.bottom *= 2;
    }

    m_rcDest = CopyWinInfo.DestClipRect;

    // Position the overlay with the current source and destination
    if (IsRectEmpty(&CopyWinInfo.DestClipRect))
    {
        hr = m_pIVPControl->CallUpdateOverlay(m_pOverlaySurface,
                                              NULL,
                                              pPrimarySurface,
                                              NULL,
                                              DDOVER_HIDE);
        goto CleanUp;
    }

    hr = m_pIVPControl->CallUpdateOverlay(m_pOverlaySurface,
                                          &CopyWinInfo.SrcClipRect,
                                          pPrimarySurface,
                                          &CopyWinInfo.DestClipRect,
                                          m_dwOverlayFlags);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pOverlaySurface->UpdateOverlay failed,")
                TEXT(" hr = 0x%x, mode = %d"),
                hr, mode));

        DbgLog((LOG_ERROR, 0, TEXT("SourceClipRect = %d, %d, %d, %d"),
                CopyWinInfo.SrcClipRect.left, CopyWinInfo.SrcClipRect.top,
                CopyWinInfo.SrcClipRect.right, CopyWinInfo.SrcClipRect.bottom));

        DbgLog((LOG_ERROR, 0, TEXT("DestinationClipRect = %d, %d, %d, %d"),
                CopyWinInfo.DestClipRect.left, CopyWinInfo.DestClipRect.top,
                CopyWinInfo.DestClipRect.right, CopyWinInfo.DestClipRect.bottom));

        goto CleanUp;
    }
    else
    {
        // spew some more debug info
        DbgLog((LOG_TRACE, 5, TEXT("UpdateOverlay succeeded, mode = %d"), mode));

        DbgLog((LOG_TRACE, 3, TEXT("Source Rect = %d, %d, %d, %d"),
                CopyWinInfo.SrcClipRect.left, CopyWinInfo.SrcClipRect.top,
                CopyWinInfo.SrcClipRect.right, CopyWinInfo.SrcClipRect.bottom));
        DbgLog((LOG_TRACE, 3, TEXT("Destination Rect = %d, %d, %d, %d"),
                CopyWinInfo.DestClipRect.left, CopyWinInfo.DestClipRect.top,
                CopyWinInfo.DestClipRect.right, CopyWinInfo.DestClipRect.bottom));

    }

    CleanUp:
    return hr;
}

/*****************************Private*Routine******************************\
* CAMVideoPort::SetUpMode
*
* This function is designed to be called everytime on an update-overlay call
* not just when the mode changes. This is basically to keep the code simple.
* Certain functions are supposed to be called in sequence,
* (SetUpMode, followedby AdjustSourceSize followedby SetDisplayRects).
* I just call them all everytime, eventhough it is possible to optimize on
* that. The logic is that since UpdateOverlay is so expensive, this is no
* performance hit.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CAMVideoPort::SetUpMode(LPWININFO pWinInfo, int mode)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CAMVideoPort::SetUpMode")));

    CAutoLock cObjectLock(m_pMainObjLock);

    CheckPointer(pWinInfo, E_INVALIDARG);

    if (mode != AMVP_MODE_WEAVE &&
        mode != AMVP_MODE_BOBINTERLEAVED &&
        mode != AMVP_MODE_BOBNONINTERLEAVED &&
        mode != AMVP_MODE_SKIPODD &&
        mode != AMVP_MODE_SKIPEVEN)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, mode value not valid, mode = %d"),
                mode));
        hr = E_FAIL;
        goto CleanUp;
    }

    if (mode == AMVP_MODE_WEAVE && !m_bCanWeave)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_WEAVE")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_BOBINTERLEAVED && !m_bCanBobInterleaved)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_BOBINTERLEAVED")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_BOBNONINTERLEAVED && !m_bCanBobNonInterleaved)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_BOBNONINTERLEAVED")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_SKIPODD && !m_bCanSkipOdd)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_SKIPODD")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_SKIPEVEN && !m_bCanSkipEven)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_SKIPEVEN")));
        hr = E_FAIL;
        goto CleanUp;
    }

    // Determine if we should interleave this or not.
    // If we are doing weave, we certainly need to interleave.
    // Bob doesn't really care one way or the other (since it only
    // displays one field at a time), but interleaved makes it much
    // easier to switch from bob to weave.
    if (mode == AMVP_MODE_BOBINTERLEAVED ||
        mode == AMVP_MODE_WEAVE)
    {
        m_svpInfo.dwVPFlags |= DDVP_INTERLEAVE;

        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag interleaved")));
    }
    else
    {
        pWinInfo->SrcRect.top /= 2;
        pWinInfo->SrcRect.bottom /= 2;
        m_svpInfo.dwVPFlags &= ~DDVP_INTERLEAVE;
    }

    // if there is a garbage line at the top, we must clip it.
    // At this point the source rect is set up for a frame, so increment by 2
    // since we incremented the cropping rect height by 1, decrement the bottom
    // as well
    if (m_bGarbageLine)
    {
        pWinInfo->SrcRect.top += 1;
        pWinInfo->SrcRect.bottom -= 1;
        DbgLog((LOG_TRACE, 3,
                TEXT("m_bGarbageLine is TRUE, incrementing SrcRect.top")));
    }

    DbgLog((LOG_TRACE, 3,
            TEXT("New Source Rect after garbage line and frame/")
            TEXT("field correction= {%d, %d, %d, %d}"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));


    if (mode == AMVP_MODE_SKIPODD)
    {
        m_svpInfo.dwVPFlags |= DDVP_SKIPODDFIELDS;
        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag SkipOddFields")));
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_SKIPODDFIELDS;
    }

    if (mode == AMVP_MODE_SKIPEVEN)
    {
        m_svpInfo.dwVPFlags |= DDVP_SKIPEVENFIELDS;
        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag SkipEvenFields")));
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_SKIPEVENFIELDS;
    }


    // set up the update-overlay flags
    m_dwOverlayFlags = DDOVER_SHOW;
    if ((mode == AMVP_MODE_BOBNONINTERLEAVED ||
         mode == AMVP_MODE_BOBINTERLEAVED)
      && (m_VPState == AMVP_VIDEO_RUNNING || m_bStart))
    {
        m_dwOverlayFlags |= DDOVER_BOB;
        DbgLog((LOG_TRACE,2, TEXT("setting overlay flag DDOVER_BOB")));
    }
    else
        m_dwOverlayFlags &= ~DDOVER_BOB;

    // set the autoflip flag only if the VideoPort is (or going to be) started
    if ((m_svpInfo.dwVPFlags & DDVP_AUTOFLIP) &&
        (m_VPState == AMVP_VIDEO_RUNNING || m_bStart))
    {
        m_dwOverlayFlags |= DDOVER_AUTOFLIP;
        DbgLog((LOG_TRACE,2, TEXT("setting overlay flag DDOVER_AUTOFLIP")));
    }
    else
        m_dwOverlayFlags &= ~DDOVER_AUTOFLIP;

    CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* CAMVideoPort::RenegotiateVPParameters
*
* this function is used to redo the whole videoport connect process,
* while the graph maybe be running.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::RenegotiateVPParameters()
{
    HRESULT hr = NOERROR;
    AMVP_STATE vpOldState;

    AMTRACE((TEXT("CAMVideoPort::RenegotiateVPParameters")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // don't return an error code if not connected
    if (!m_bConnected)
    {
        hr = NOERROR;
        goto CleanUp;
    }

    // store the old state, we will need to restore it later
    vpOldState = m_VPState;

    if (m_VPState == AMVP_VIDEO_RUNNING)
    {
        m_pIVPControl->CallUpdateOverlay(NULL, NULL, NULL, NULL, DDOVER_HIDE);

        // stop the VideoPort, however even we get an error here,
        // it is ok, just go on
        hr = m_pVideoPort->StopVideo();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
            hr = NOERROR;
        }

        m_VPState = AMVP_VIDEO_STOPPED;
    }

    // release everything
    BreakConnect(TRUE);

    // redo the connection process
    hr = CompleteConnect(NULL, TRUE);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if the video was previously running, make sure that a frame is
    // visible by making an update overlay call
    if (vpOldState == AMVP_VIDEO_RUNNING)
    {
        m_bStart = TRUE;

        // make sure that the video frame gets updated by redrawing everything
        hr = m_pIVPControl->EventNotify(EC_OVMIXER_REDRAW_ALL, 0, 0);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pIVPControl->EventNotify(EC_OVMIXER_REDRAW_ALL,")
                    TEXT(" 0, 0) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        m_VPState = AMVP_VIDEO_RUNNING;
        m_pIVPControl->CallUpdateOverlay(NULL, NULL, NULL, NULL, DDOVER_SHOW);
    }

CleanUp:
    if (FAILED(hr))
    {
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        if (m_pOverlaySurface)
        {
            LPDIRECTDRAWSURFACE pPrimarySurface = m_pIVPControl->GetPrimarySurface();
            ASSERT(pPrimarySurface);
            m_pIVPControl->CallUpdateOverlay(m_pOverlaySurface, NULL,
                                             pPrimarySurface, NULL,
                                             DDOVER_HIDE);
        }
        BreakConnect(TRUE);

        m_pIVPControl->EventNotify(EC_COMPLETE, S_OK, 0);
        m_pIVPControl->EventNotify(EC_ERRORABORT, hr, 0);
    }

    return hr;
}


/******************************Public*Routine******************************\
* CAMVideoPort::SetDeinterlaceMode
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::SetDeinterlaceMode(AMVP_MODE mode)
{
    AMTRACE((TEXT("CAMVideoPort::SetMode")));
    return E_NOTIMPL;
}

/******************************Public*Routine******************************\
* CAMVideoPort::GetDeinterlaceMode
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::GetDeinterlaceMode(AMVP_MODE *pMode)
{
    AMTRACE((TEXT("CAMVideoPort::GetMode")));
    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* CAMVideoPort::SetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::SetVPSyncMaster(BOOL bVPSyncMaster)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CAMVideoPort::SetVPSyncMaster")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // if value has not changed, no need to do anything
    if (m_bVPSyncMaster != bVPSyncMaster)
    {
        // store the new value
        m_bVPSyncMaster = bVPSyncMaster;

        // if not connected, connection process will take care of updating the
        // m_svpInfo struct
        if (!m_bConnected)
            goto CleanUp;

        // update the m_svpInfo struct
        if (m_bVPSyncMaster) {
            m_svpInfo.dwVPFlags |= DDVP_SYNCMASTER;
        }
        else {
            m_svpInfo.dwVPFlags &= ~DDVP_SYNCMASTER;
        }

        // if video is stopped currently, no need to do anything else
        if (m_VPState == AMVP_VIDEO_STOPPED)
            goto CleanUp;

        // Call UpdateVideo to make sure the change is reflected immediately
        hr = m_pVideoPort->UpdateVideo(&m_svpInfo);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0, TEXT("UpdateVideo failed, hr = 0x%x"), hr));
        }
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* CAMVideoPort::GetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CAMVideoPort::GetVPSyncMaster(BOOL *pbVPSyncMaster)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CAMVideoPort::SetVPSyncMaster")));

    CAutoLock cObjectLock(m_pMainObjLock);

    if (pbVPSyncMaster) {
        *pbVPSyncMaster = m_bVPSyncMaster;
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\ovmixer.h ===
//--------------------------------------------------------------------------;
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __OVMIXER__
#define __OVMIXER__

#include <mixerocx.h>
#include <videoacc.h>
#include <ddva.h>
#include <mpconfig3.h>
#include <ovmixpos2.h>
#include <ovmprop.h>
#include <ovmprop2.h>


#if defined(DEBUG) && !defined(_WIN64)

extern int  iOVMixerDump;
void WINAPI OVMixerDebugLog(DWORD Type,DWORD Level,const TCHAR *pFormat,...);

#undef DbgLog
#define DbgLog(_x_) if (iOVMixerDump) OVMixerDebugLog _x_ ; else DbgLogInfo _x_

#endif

#define VA_TRACE_LEVEL 2
#define VA_ERROR_LEVEL 2

extern const AMOVIESETUP_FILTER sudOverlayMixer;
extern const AMOVIESETUP_FILTER sudOverlayMixer2;

// Hack second CLSID - will only support VIDEOINFO2
DEFINE_GUID(CLSID_OverlayMixer2,
0xa0025e90, 0xe45b, 0x11d1, 0xab, 0xe9, 0x00, 0xa0, 0xc9,0x05, 0xf3, 0x75);

// a property set the decoders can support in order to ask the ovmixer not to
// overallocate buffers behinds the decoders back
// A503C5C0-1D1D-11d1-AD80-444553540000
DEFINE_GUID(AM_KSPROPSETID_ALLOCATOR_CONTROL,
0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba);


//  Debug helper
#ifdef DEBUG
class CDispPixelFormat : public CDispBasic
{
public:
    CDispPixelFormat(const DDPIXELFORMAT *pFormat)
    {
        wsprintf(m_String, TEXT("  Flags(0x%8.8X) bpp(%d) 4CC(%4.4hs)"),
                 pFormat->dwFlags,
                 pFormat->dwRGBBitCount,
                 pFormat->dwFlags & DDPF_FOURCC ?
                     (CHAR *)&pFormat->dwFourCC : "None");
    }
    //  Implement cast to (LPCTSTR) as parameter to logger
    operator LPCTSTR()
    {
        return (LPCTSTR)m_pString;
    };
};
#endif // DEBUG


typedef enum
{
    // R O (if value == 1, then ovmixer will allocate exactly the number
    //      of buffers, the decoder specifies)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT = 0,

    // R O (returns 2 DWORD (cx and cy), then ovmixer will allocate surfaces
    //      of this size and will scale the video at the video port to this size
    //      no other scaling at the video port will occur regardless of the
    //      scaling abilities of the VGA chip)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE = 1,

    // W I (informns a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS = 2,

    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE = 3

} AM_KSPROPERTY_ALLOCATOR_CONTROL;


#define INITDDSTRUCT(_x_) \
    ZeroMemory(&(_x_), sizeof(_x_)); \
    (_x_).dwSize = sizeof(_x_);

PVOID AllocateDDStructures(int iSize, int nNumber);

#define MAX_PIN_COUNT                       10
#define DEFAULT_WIDTH                       320
#define DEFAULT_HEIGHT                      240
#define MAX_REL_NUM                         10000
#define MAX_BLEND_VAL                       255

#define EXTRA_BUFFERS_TO_FLIP               2

#define DDGFS_FLIP_TIMEOUT                  1
#define MIN_CK_STETCH_FACTOR_LIMIT          3000
#define SOURCE_COLOR_REF                    (RGB(0, 128, 128))          // A shade of green, color used for source-colorkeying to force the card to use pixel-doubling instead of arithmatic stretching
#define DEFAULT_DEST_COLOR_KEY_INDEX        253                         // magenta
#define DEFAULT_DEST_COLOR_KEY_RGB          (RGB(255, 0, 255))          // magenta
#define PALETTE_VERSION                     1

// these values are used to do sanity checking mostly
#define MAX_COMPRESSED_TYPES    10
#define MAX_COMPRESSED_BUFFERS  20

typedef struct _tag_SURFACE_INFO
{
    LPDIRECTDRAWSURFACE4    pSurface;
    LPVOID                  pBuffer;    // NULL if not locked
} SURFACE_INFO, *LPSURFACE_INFO;

typedef struct _tag_COMP_SURFACE_INFO
{
    DWORD                   dwAllocated;
    LPSURFACE_INFO          pSurfInfo;
} COMP_SURFACE_INFO, *LPCOMP_SURFACE_INFO;


/* -------------------------------------------------------------------------
** DDraw & MultiMon structures and typedefs
** -------------------------------------------------------------------------
*/
typedef HRESULT (WINAPI *LPDIRECTDRAWCREATE)(IID *,LPDIRECTDRAW *,LPUNKNOWN);
typedef HRESULT (WINAPI *LPDIRECTDRAWENUMERATEA)(LPDDENUMCALLBACKA,LPVOID);

enum {ACTION_COUNT_GUID, ACTION_FILL_GUID};
struct DDRAWINFO {
    DWORD               dwAction;
    DWORD               dwUser;
    const GUID*         lpGUID;
    LPDIRECTDRAWCREATE  lpfnDDrawCreate;
    AMDDRAWMONITORINFO* pmi;
};

HRESULT
LoadDDrawLibrary(
    HINSTANCE& hDirectDraw,
    LPDIRECTDRAWCREATE& lpfnDDrawCreate,
    LPDIRECTDRAWENUMERATEA& lpfnDDrawEnum,
    LPDIRECTDRAWENUMERATEEXA& lpfnDDrawEnumEx
    );

HRESULT
CreateDirectDrawObject(
    const AMDDRAWGUID& GUID,
    LPDIRECTDRAW *ppDirectDraw,
    LPDIRECTDRAWCREATE lpfnDDrawCreate
    );

/* -------------------------------------------------------------------------
** Pre-declare out classes.
** -------------------------------------------------------------------------
*/
class COMFilter;
class COMInputPin;
class COMOutputPin;
class CBPCWrap;
class CDispMacroVision;


/* -------------------------------------------------------------------------
** COMFilter class declaration
** -------------------------------------------------------------------------
*/
class COMFilter :
    public CBaseFilter,
    public IAMOverlayMixerPosition2,
    public IOverlayNotify,
    public IMixerOCX,
    public IDDrawNonExclModeVideo,
    public ISpecifyPropertyPages,
    public IQualProp,
    public IEnumPinConfig,
    public IAMVideoDecimationProperties,
    public IAMOverlayFX,
    public IAMSpecifyDDrawConnectionDevice,
    public IKsPropertySet
{
public:

    // the base classes do this, so have to do it
    friend class COMInputPin;
    friend class COMOutputPin;
    // COM stuff
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    static CUnknown *CreateInstance2(LPUNKNOWN, HRESULT *);
    COMFilter(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *phr,
	      bool bSupportOnlyVIDEOINFO2);
    ~COMFilter();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    //
    // --- ISpecifyPropertyPages ---
    //
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IEnumPinConfig
    STDMETHODIMP Next(IMixerPinConfig3 **pPinConfig);

    // IQualProp property page support
    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate);
    STDMETHODIMP get_Jitter(int *piJitter);
    STDMETHODIMP get_AvgSyncOffset(int *piAvg);
    STDMETHODIMP get_DevSyncOffset(int *piDev);

    //
    // IKsPropertySet interface methods
    //
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);

    STDMETHODIMP Get(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
                     DWORD *pcbReturned);

    STDMETHODIMP QuerySupported(REFGUID guidPropSet,
                                DWORD PropID, DWORD *pTypeSupport);

    // IAMOverlayMixerPosition
    STDMETHODIMP GetScaledDest(RECT *prcSrc, RECT *prcDst);

    // IAMOverlayMixerPosition2
    STDMETHODIMP GetOverlayRects(RECT *src, RECT *dest);
    STDMETHODIMP GetVideoPortRects(RECT *src, RECT *dest);
    STDMETHODIMP GetBasicVideoRects(RECT *src, RECT *dest);

    // IsWindowOnWrongMonitor
    BOOL IsWindowOnWrongMonitor(HMONITOR *pID);

    virtual HRESULT SetMediaType(DWORD dwPinId, const CMediaType *pmt);
    virtual HRESULT CompleteConnect(DWORD dwPinId);
    virtual HRESULT BreakConnect(DWORD dwPinId);
    virtual HRESULT CheckMediaType(DWORD dwPinId, const CMediaType* mtIn) { return NOERROR; }
    virtual HRESULT EndOfStream(DWORD dwPinId) { return NOERROR; }
    int GetPinPosFromId(DWORD dwPinId);
    int GetPinCount();
    int GetInputPinCount() const { return m_dwInputPinCount; };
    CBasePin* GetPin(int n);
    COMOutputPin* GetOutputPin() {return m_pOutput;}
    STDMETHODIMP Pause();
    STDMETHODIMP Stop() ;
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *pState);
    HRESULT EventNotify(DWORD dwPinId, long lEventCode, long lEventParam1, long lEventParam2);
    HRESULT OnDisplayChangeBackEnd();
    HRESULT OnDisplayChange(BOOL fRealMsg);
    HRESULT OnTimer();
    HRESULT RecreatePrimarySurface(LPDIRECTDRAWSURFACE pDDrawSurface);
    HRESULT ConfirmPreConnectionState(DWORD dwExcludePinId = -1);
    HRESULT CanExclusiveMode();

    HRESULT GetPaletteEntries(DWORD *pdwNumPaletteEntries, PALETTEENTRY **ppPaletteEntries);
    HRESULT PaintColorKey(HRGN hPaintRgn, COLORKEY *pColorKey);
    HRESULT SetColorKey(COLORKEY *pColorKey);
    HRESULT GetColorKey(COLORKEY *pColorKey, DWORD *pColor);
    COLORKEY *GetColorKeyPointer() { return &m_ColorKey; }
    CImageDisplay* GetDisplay() { return &m_Display; }
    LPDIRECTDRAW GetDirectDraw();
    LPDIRECTDRAWSURFACE GetPrimarySurface();
    LPDDCAPS GetHardwareCaps();
    HRESULT OnShowWindow(HWND hwnd, BOOL fShow);
    HDC GetDestDC();
    HWND GetWindow();

    // currently being windowless is synonymous with having a pull-model, might change later
    BOOL UsingPullModel () { return m_bWindowless; }
    BOOL UsingWindowless() { return m_bWindowless; }

    void GetPinsInZOrder(DWORD *pdwZorder);
    HRESULT OnDrawAll();

    // IOverlayNotify methods
    STDMETHODIMP OnColorKeyChange(const COLORKEY *pColorKey);
    STDMETHODIMP OnPaletteChange(DWORD dwColors, const PALETTEENTRY *pPalette);
    STDMETHODIMP OnClipChange(const RECT *pSourceRect, const RECT *pDestinationRect, const RGNDATA *pRegionData);
    STDMETHODIMP OnPositionChange(const RECT *pSourceRect, const RECT *pDestinationRect);

    // IMixerOCX methods
    STDMETHODIMP OnDisplayChange(ULONG ulBitsPerPixel, ULONG ulScreenWidth, ULONG ulScreenHeight) { return E_NOTIMPL; }
    STDMETHODIMP GetAspectRatio(LPDWORD pdwPictAspectRatioX, LPDWORD pdwPictAspectRatioY) { return E_NOTIMPL; }
    STDMETHODIMP GetVideoSize(LPDWORD pdwVideoWidth, LPDWORD pdwVideoHeight);
    STDMETHODIMP GetStatus(LPDWORD *pdwStatus) { return E_NOTIMPL; }
    STDMETHODIMP OnDraw(HDC hdcDraw, LPCRECT prcDrawRect);
    STDMETHODIMP SetDrawRegion(LPPOINT lpptTopLeftSC, LPCRECT prcDrawCC, LPCRECT prcClipCC);
    STDMETHODIMP Advise(IMixerOCXNotify *pmdns);
    STDMETHODIMP UnAdvise();

    // IDDrawExclModeVideo interface methods
    STDMETHODIMP SetDDrawObject(LPDIRECTDRAW pDDrawObject);
    STDMETHODIMP GetDDrawObject(LPDIRECTDRAW *ppDDrawObject, LPBOOL pbUsingExternal);
    STDMETHODIMP SetDDrawSurface(LPDIRECTDRAWSURFACE pDDrawSurface);
    STDMETHODIMP GetDDrawSurface(LPDIRECTDRAWSURFACE *ppDDrawSurface, LPBOOL pbUsingExternal);
    STDMETHODIMP SetDrawParameters(LPCRECT prcSource, LPCRECT prcTarget);
    STDMETHODIMP GetNativeVideoProps(LPDWORD pdwVideoWidth, LPDWORD pdwVideoHeight, LPDWORD pdwPictAspectRatioX, LPDWORD pdwPictAspectRatioY);
    STDMETHODIMP SetCallbackInterface(IDDrawExclModeVideoCallback *pCallback, DWORD dwFlags);
    STDMETHODIMP GetCurrentImage(YUV_IMAGE** lplpImage);
    STDMETHODIMP IsImageCaptureSupported();
    STDMETHODIMP ChangeMonitor(HMONITOR hMonitor, LPDIRECTDRAW pDDrawObject, LPDIRECTDRAWSURFACE pDDrawSurface);
    STDMETHODIMP DisplayModeChanged(HMONITOR hMonitor, LPDIRECTDRAW pDDrawObject, LPDIRECTDRAWSURFACE pDDrawSurface);
    STDMETHODIMP RestoreSurfaces();

    // IAMVideoDecimationProperties
    STDMETHODIMP QueryDecimationUsage(DECIMATION_USAGE* lpUsage);
    STDMETHODIMP SetDecimationUsage(DECIMATION_USAGE Usage);

    // IAMOverlayFX interface methods
    STDMETHODIMP QueryOverlayFXCaps(DWORD *lpdwOverlayFXCaps);
    STDMETHODIMP SetOverlayFX(DWORD dwOveralyFX);
    STDMETHODIMP GetOverlayFX(DWORD *lpdwOverlayFX);

    // IAMPreferredDDrawDevice
    STDMETHODIMP SetDDrawGUID(const AMDDRAWGUID* lpGUID);
    STDMETHODIMP GetDDrawGUID(AMDDRAWGUID* lpGUID);
    STDMETHODIMP SetDefaultDDrawGUID(const AMDDRAWGUID* lpGUID);
    STDMETHODIMP GetDefaultDDrawGUID(AMDDRAWGUID* lpGUID);
    STDMETHODIMP GetDDrawGUIDs(LPDWORD lpdw, AMDDRAWMONITORINFO** lplpInfo);


    CBPCWrap    m_BPCWrap;

    bool OnlySupportVideoInfo2() const { return m_bOnlySupportVideoInfo2; }
    HMONITOR GetCurrentMonitor(BOOL fUpdate = TRUE);  // making public helps MV class

    BOOL ColorKeySet() const { return m_bColorKeySet; }

    BOOL OverlayVisible() const { return m_bOverlayVisible; }

    void CheckOverlayHidden();

    void      SetCopyProtect(BOOL bState)  { m_bCopyProtect = bState ; }
    BOOL      NeedCopyProtect(void)        { return m_bCopyProtect ; }

    DWORD KernelCaps() const { return m_dwKernelCaps;}
    BOOL    IsFaultyMMaticsMoComp();

private:
    // helper function to get IBaseVideo from outpun pin
    HRESULT GetBasicVideoFromOutPin(IBasicVideo** pBasicVideo);

    // override this if you want to supply your own pins
    virtual HRESULT CreatePins();
    virtual void DeletePins();
    HRESULT CreateInputPin(BOOL bVPSupported);
    void DeleteInputPin(COMInputPin *pPin);

    // ddraw related functions
    HRESULT InitDirectDraw(LPDIRECTDRAW pDirectDraw);

    DWORD ReleaseDirectDraw();
    HRESULT CreatePrimarySurface();
    DWORD ReleasePrimarySurface();
    HRESULT CheckSuitableVersion();
    HRESULT CheckCaps();

    HRESULT MatchGUID(const GUID* lpGUID, LPDWORD lpdwMatchID);
    HRESULT GetDDrawEnumFunction(LPDIRECTDRAWENUMERATEEXA* ppDrawEnumEx);

    // Wrapper for UpdateOverlay - tracks state and manages the color key
    HRESULT CallUpdateOverlay(IDirectDrawSurface *pSurface,
                              LPRECT prcSrc,
                              LPDIRECTDRAWSURFACE pDestSurface,
                              LPRECT prcDest,
                              DWORD dwFlags,
                              IOverlayNotify *pNotify = NULL,
                              LPRGNDATA pBuffer = NULL);


    CCritSec                m_csFilter;                         // filter wide lock
    DWORD                   m_dwInputPinCount;                  // number of input pins
    COMOutputPin            *m_pOutput;                         // output pin
    DWORD                   m_dwMaxPinId;                       // stores the id to be given to the pins
    IMixerOCXNotify         *m_pIMixerOCXNotify;
    BOOL                    m_bWindowless;

    // MultiMonitor stuff
    DWORD                   m_dwDDrawInfoArrayLen;
    AMDDRAWMONITORINFO*     m_lpDDrawInfo;
    AMDDRAWMONITORINFO*     m_lpCurrentMonitor;
    AMDDRAWGUID             m_ConnectionGUID;
    BOOL                    m_fDisplayChangePosted;
    BOOL                    m_fMonitorWarning;
    UINT                    m_MonitorChangeMsg;

    DWORD                   m_dwDDObjReleaseMask;
    LPDIRECTDRAW            m_pOldDDObj;            // Old DDraw object prior to a display change

    /*
    If an app calls IDDrawExclModeVideo::SetDdrawObject() on the filter in its PostConnection state, the
    filter just caches that ddraw object. m_pUpdatedDirectDraw represents the cached ddraw object. In
    PreConnection state, m_pDirectDraw and m_pUpdatedDirectDraw are always in sync. After all
    pins of the ovmixer have broken their connection, the filter checks to see if m_pUpdatedDirectDraw
    is different from m_pDirectDraw, and if they are, they are brought in sync again.

    Absolutely the same logic is used for m_pPrimarySurface and m_pUpdatedPrimarySurface
    */

    // ddraw stuff
    HINSTANCE                   m_hDirectDraw;      // Handle to the loaded library
    LPDIRECTDRAWCREATE          m_lpfnDDrawCreate;  // ptr to DirectDrawCreate
    LPDIRECTDRAWENUMERATEA      m_lpfnDDrawEnum;    // ptr to DirectDrawEnumA
    LPDIRECTDRAWENUMERATEEXA    m_lpfnDDrawEnumEx;  // ptr to DirectDrawEnumExA

    LPDIRECTDRAW            m_pDirectDraw;                      // DirectDraw service provider
    LPDIRECTDRAW            m_pUpdatedDirectDraw;               // Updated DirectDraw object
    DDCAPS                  m_DirectCaps;                       // Actual hardware capabilities
    DDCAPS                  m_DirectSoftCaps;                   // Emulted capabilities
    DWORD                   m_dwKernelCaps;                     // Kernel caps
    LPDIRECTDRAWSURFACE     m_pPrimarySurface;                  // primary surface
    LPDIRECTDRAWSURFACE     m_pUpdatedPrimarySurface;           // primary surface
    IDDrawExclModeVideoCallback *m_pExclModeCallback;           // callback to exclusive mode client
    bool                    m_UsingIDDrawNonExclModeVideo;
    bool                    m_UsingIDDrawExclModeVideo;

    // FX flags for the DDOVERLAYFX structure
    DWORD                   m_dwOverlayFX;

    // track overlay state
    BOOL                    m_bOverlayVisible;
    RECT                    m_rcOverlaySrc;
    RECT                    m_rcOverlayDest;

    //
    CImageDisplay           m_Display;
    COLORKEY                m_ColorKey;
    BOOL                    m_bColorKeySet;
    BOOL                    m_bNeedToRecreatePrimSurface;
    BOOL                    m_bUseGDI;
    BOOL                    m_bExternalPrimarySurface;
    BOOL                    m_bExternalDirectDraw;

    // IOverlayNotify and IMixerOCX related members
    WININFO                 m_WinInfo;
    BOOL                    m_bWinInfoStored;
    HDC                     m_hDC;
    DWORD                   m_dwNumPaletteEntries;

    // adjusted video size paramters
    DWORD                   m_dwAdjustedVideoWidth;
    DWORD                   m_dwAdjustedVideoHeight;

    // Pins
    COMInputPin            *m_apInput[MAX_PIN_COUNT];           // Array of input pin pointers

    // Space to store palette
    PALETTEENTRY            m_pPaletteEntries[iPALETTE_COLORS];

    // Hack - only support videoinfo2
    const bool              m_bOnlySupportVideoInfo2;

    CDispMacroVision        m_MacroVision ;  // MV support as an object
    BOOL                    m_bCopyProtect ; // Is MV support to be done in OvMixer?

    // Support IMediaSeeking
    IUnknown                *m_pPosition;

    // Support IEnumPinConfig
    DWORD                   m_dwPinConfigNext;


    // Support IAMVideoDecimationProperties
    DECIMATION_USAGE        m_dwDecimation;
#ifdef DEBUG
#define WM_DISPLAY_WINDOW_TEXT  (WM_USER+7837)
    TCHAR                   m_WindowText[80];
#endif
    // Hack for MMatics misused MoComp interfaces v38..v42
    BOOL                    m_bHaveCheckedMMatics;
    BOOL                    m_bIsFaultyMMatics;
};


class CDDrawMediaSample : public CMediaSample, public IDirectDrawMediaSample
{
public:

    CDDrawMediaSample(TCHAR *pName, CBaseAllocator *pAllocator, HRESULT *phr, LPBYTE pBuffer, LONG length,
                      bool bKernelLock);
    ~CDDrawMediaSample();

    /* Note the media sample does not delegate to its owner */
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef() { return CMediaSample::AddRef(); }
    STDMETHODIMP_(ULONG) Release() { return CMediaSample::Release(); }

    void SetDIBData(DIBDATA *pDibData);
    DIBDATA *GetDIBData();

    HRESULT SetDDrawSampleSize(DWORD dwDDrawSampleSize);
    HRESULT GetDDrawSampleSize(DWORD *pdwDDrawSampleSize);
    HRESULT SetDDrawSurface(LPDIRECTDRAWSURFACE pDirectDrawSurface);
    HRESULT GetDDrawSurface(LPDIRECTDRAWSURFACE *ppDirectDrawSurface);

    // methods belonging to IDirectDrawMediaSample
    STDMETHODIMP GetSurfaceAndReleaseLock(IDirectDrawSurface **ppDirectDrawSurface, RECT* pRect);
    STDMETHODIMP LockMediaSamplePointer(void);
	
    /*  Hack to get at the list */
    CMediaSample         * &Next() { return m_pNext; }
private:
    DIBDATA                 m_DibData;                      // Information about the DIBSECTION
    LPDIRECTDRAWSURFACE     m_pDirectDrawSurface;           // pointer to the direct draw surface
    DWORD                   m_dwDDrawSampleSize;            // ddraw sample size
    bool                    m_bInit;                        // Is the DIB information setup
    bool                    m_bSurfaceLocked;               // specifies whether surface is locked or not
    bool                    m_bKernelLock;                  // lock with no sys lock
    RECT                    m_SurfaceRect;                  // the part of the surface that is locked
};


class COMInputAllocator : public CBaseAllocator, public IDirectDrawMediaSampleAllocator
{
    friend class COMInputPin;
public:

    COMInputAllocator(COMInputPin *pPin, CCritSec *pLock, HRESULT *phr);             // Return code
#ifdef DEBUG
    ~COMInputAllocator();
#endif // DEBUG
    DECLARE_IUNKNOWN

    STDMETHODIMP COMInputAllocator::NonDelegatingQueryInterface(REFIID riid, void **ppv);

    STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
    STDMETHODIMP GetBuffer(IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
	REFERENCE_TIME *pEndTime, DWORD dwFlags);
    STDMETHODIMP ReleaseBuffer(IMediaSample *pMediaSample);

    // function to implement IDirectDrawMediaSampleAllocator
    STDMETHODIMP GetDirectDraw(IDirectDraw **ppDirectDraw);
	
    //  Check all samples are returned
    BOOL CanFree() const
    {
	return m_lFree.GetCount() == m_lAllocated;
    }
protected:
    void Free();
    HRESULT Alloc();

private:
    COMInputPin             *m_pPin;
    CCritSec                *m_pFilterLock;                 // Critical section for interfaces
};

class COMInputPin :
public CBaseInputPin,
public IMixerPinConfig3,
public IOverlay,
public IVPControl,
public IKsPin,
public IKsPropertySet,
public IAMVideoAccelerator,
public ISpecifyPropertyPages,
public IPinConnection
{
public:
    COMInputPin(TCHAR *pObjectName, COMFilter *pFilter, CCritSec *pLock,
	BOOL bVPSupported, HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo);
    ~COMInputPin();
    friend class COMInputAllocator;
    friend class COMFilter;

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //
    // --- ISpecifyPropertyPages ---
    //
    STDMETHODIMP GetPages(CAUUID *pPages);

    // Override ReceiveConnection to allow format changes while running
    STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);

    // connection related functions
    HRESULT CheckConnect(IPin * pReceivePin);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();
//  HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
    HRESULT CheckInterlaceFlags(DWORD dwInterlaceFlags);
    HRESULT DynamicCheckMediaType(const CMediaType* pmt);
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT FinalConnect();
    HRESULT UpdateMediaType();

    // streaming functions
    HRESULT Active();
    HRESULT Inactive();
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT RunToPause();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample *pMediaSample);
    STDMETHODIMP EndOfStream(void);
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *pState);
    HRESULT CompleteStateChange(FILTER_STATE OldState);
    HRESULT OnReceiveFirstSample(IMediaSample *pMediaSample);
    HRESULT DoRenderSample(IMediaSample *pMediaSample);
    HRESULT FlipOverlayToItself();
    HRESULT CalcSrcDestRect(const DRECT *prdRelativeSrcRect, const DRECT *prdDestRect, RECT *pAdjustedSrcRect, RECT *pAdjustedDestRect, RECT *prUncroppedDestRect);

    // allocator related functions
    BOOL UsingOurAllocator() { return m_bUsingOurAllocator; }
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly);
    HRESULT OnSetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
    HRESULT OnAlloc(CDDrawMediaSample **ppSampleList, DWORD dwSampleCount);
    HRESULT OnGetBuffer(IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
	REFERENCE_TIME *pEndTime, DWORD dwFlags);
    HRESULT OnReleaseBuffer(IMediaSample *pIMediaSample);
    HRESULT CreateDDrawSurface(CMediaType *pMediaType, AM_RENDER_TRANSPORT amRenderTransport,
	DWORD *dwMaxBufferCount, LPDIRECTDRAWSURFACE *ppDDrawSurface);

    // some helper fnctions
    BOOL IsCompletelyConnected() { return m_bConnected; }
    DWORD GetPinId() { return m_dwPinId; }
    DWORD GetInternalZOrder() { return m_dwInternalZOrder; }
    HRESULT CurrentAdjustedMediaType(CMediaType *pmt);
    HRESULT CopyAndAdjustMediaType(CMediaType *pmtTarget, CMediaType *pmtSource);
    IPin *CurrentPeer() { return m_Connected; }
    void DoQualityMessage();
    HRESULT GetAdjustedModeAndAspectRatio(AM_ASPECT_RATIO_MODE* pamAdjustedARMode,
	DWORD *pdwAdjustedPARatioX, DWORD *pdwAdjustedPARatioY);
    void SetRenderTransport(AM_RENDER_TRANSPORT amRenderTransport) { ASSERT(amRenderTransport != AM_VIDEOPORT); ASSERT(amRenderTransport != AM_IOVERLAY); m_RenderTransport = amRenderTransport; }
    void SetVPSupported(BOOL bVPSupported) { ASSERT(m_pIVPObject); m_bVPSupported = bVPSupported; }
    void SetIOverlaySupported(BOOL bIOverlaySupported) { m_bIOverlaySupported = bIOverlaySupported; }
    void SetVideoAcceleratorSupported(BOOL bVideoAcceleratorSupported) { m_bVideoAcceleratorSupported = bVideoAcceleratorSupported; }
    HRESULT NewPaletteSet() { m_bDynamicFormatNeeded = TRUE; m_bNewPaletteSet = TRUE; NotifyChange(ADVISE_PALETTE); return NOERROR; }
    HRESULT GetSourceAndDest(RECT *prcSource, RECT *prcDest, DWORD *dwWidth, DWORD *dwHeight);

    // functions used to handle window/display changes
    HRESULT OnClipChange(LPWININFO pWinInfo);
    HRESULT OnDisplayChange();
    HRESULT RestoreDDrawSurface();

    // functions belonging to IPinConnection
    // Do you accept this type change in your current state?
    STDMETHODIMP DynamicQueryAccept(const AM_MEDIA_TYPE *pmt);

    //  Set event when EndOfStream receive - do NOT pass it on
    //  This condition is cancelled by a flush or Stop
    STDMETHODIMP NotifyEndOfStream(HANDLE hNotifyEvent);

    //  Are you an 'end pin'
    STDMETHODIMP IsEndPin();
    STDMETHODIMP DynamicDisconnect();

    // functions belonging to IMixerPinConfig
    STDMETHODIMP SetRelativePosition(DWORD dwLeft, DWORD dwTop, DWORD dwRight, DWORD dwBottom);
    STDMETHODIMP GetRelativePosition(DWORD *pdwLeft, DWORD *pdwTop, DWORD *pdwRight, DWORD *pdwBottom);
    STDMETHODIMP SetZOrder(DWORD dwZOrder);
    STDMETHODIMP GetZOrder(DWORD *pdwZOrder);
    STDMETHODIMP SetColorKey(COLORKEY *pColorKey);
    STDMETHODIMP GetColorKey(COLORKEY *pColorKey, DWORD *pColor);
    STDMETHODIMP SetBlendingParameter(DWORD dwBlendingParameter);
    STDMETHODIMP GetBlendingParameter(DWORD *pdwBlendingParameter);
    STDMETHODIMP SetStreamTransparent(BOOL bStreamTransparent);
    STDMETHODIMP GetStreamTransparent(BOOL *pbStreamTransparent);
    STDMETHODIMP SetAspectRatioMode(AM_ASPECT_RATIO_MODE amAspectRatioMode);
    STDMETHODIMP GetAspectRatioMode(AM_ASPECT_RATIO_MODE* pamAspectRatioMode);

    // functions added in IMixerPinConfig2
    STDMETHODIMP SetOverlaySurfaceColorControls(LPDDCOLORCONTROL pColorControl);
    STDMETHODIMP GetOverlaySurfaceColorControls(LPDDCOLORCONTROL pColorControl);

    // Helper for GetOverlaySurfaceControls and GetCurrentImage;
    STDMETHODIMP GetOverlaySurface(LPDIRECTDRAWSURFACE *pOverlaySurface);

    // functions added in IMixerPinConfig3
    STDMETHODIMP GetRenderTransport(AM_RENDER_TRANSPORT *pamRenderTransport);

    // functions belonging to IOverlay
    STDMETHODIMP GetWindowHandle(HWND *pHwnd);
    STDMETHODIMP Advise(IOverlayNotify *pOverlayNotify, DWORD dwInterests);
    STDMETHODIMP Unadvise();
    STDMETHODIMP GetClipList(RECT *pSourceRect, RECT *pDestinationRect, RGNDATA **ppRgnData);
    STDMETHODIMP GetVideoPosition(RECT *pSourceRect, RECT *pDestinationRect);
    STDMETHODIMP GetDefaultColorKey(COLORKEY *pColorKey);
    STDMETHODIMP GetColorKey(COLORKEY *pColorKey) {
        if (!pColorKey) {
            return E_POINTER;
        }
        return m_pFilter->GetColorKey(pColorKey, NULL);
    }
    STDMETHODIMP GetPalette(DWORD *pdwColors,PALETTEENTRY **ppPalette);
    STDMETHODIMP SetPalette(DWORD dwColors, PALETTEENTRY *pPaletteColors);
    // helper function used in implementation of IOverlay
    HRESULT NotifyChange(DWORD dwAdviseChanges);

    // functions belonging to IVPControl
    STDMETHODIMP EventNotify(long lEventCode, long lEventParam1, long lEventParam2);
    STDMETHODIMP_(LPDIRECTDRAW) GetDirectDraw() { return m_pFilter->GetDirectDraw(); }
    STDMETHODIMP_(LPDIRECTDRAWSURFACE) GetPrimarySurface() { return m_pFilter->GetPrimarySurface(); }
    STDMETHODIMP_(LPDDCAPS) GetHardwareCaps() { return m_pFilter->GetHardwareCaps(); }
    STDMETHODIMP CallUpdateOverlay(IDirectDrawSurface *pSurface,
                              LPRECT prcSrc,
                              LPDIRECTDRAWSURFACE pDestSurface,
                              LPRECT prcDest,
                              DWORD dwFlags)
    {
        return m_pFilter->CallUpdateOverlay(pSurface,
                                            prcSrc,
                                            pDestSurface,
                                            prcDest,
                                            dwFlags);
    }

    STDMETHODIMP GetCaptureInfo(BOOL *lpCapturing,
                                DWORD *lpdwWidth,DWORD *lpdwHeight,
                                BOOL *lpInterleave);

    STDMETHODIMP GetVideoDecimation(IDecimateVideoImage** lplpDVI);
    STDMETHODIMP GetDecimationUsage(DECIMATION_USAGE *lpdwUsage);

    STDMETHODIMP CropSourceRect(LPWININFO pWinInfo,
                                DWORD dwMinZoomFactorX,
                                DWORD dwMinZoomFactorY);

    STDMETHODIMP SetFrameStepMode(DWORD dwFramesToStep);
    STDMETHODIMP CancelFrameStepMode();

    HRESULT ApplyOvlyFX()
    {
        return m_pFilter->CallUpdateOverlay(
                 m_pDirectDrawSurface,
                 &m_WinInfo.SrcClipRect,
                 m_pFilter->GetPrimarySurface(),
                 &m_WinInfo.DestClipRect,
                 DDOVER_KEYDEST);
    }

    // helper functions
    void SetKsMedium   (const KSPIN_MEDIUM *pMedium)    {m_Medium = *pMedium;}
    void SetKsCategory (const GUID *pCategory)  {m_CategoryGUID = *pCategory;}
    void SetStreamingInKernelMode (BOOL bStreamingInKernelMode)  {m_bStreamingInKernelMode = bStreamingInKernelMode;}

    // IKsPropertySet implementation
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport);

    // IKsPin implementation
    virtual STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM *pMediumList);
    virtual STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM *pInterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium)
	{ return E_UNEXPECTED; }
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION *pCommunication,
	KSPIN_INTERFACE *pInterface, KSPIN_MEDIUM *pMedium);
    STDMETHODIMP KsPropagateAcquire()
	{ return NOERROR; }
    STDMETHODIMP KsDeliver(IMediaSample *pSample, ULONG Flags)
	{ return E_UNEXPECTED; }
    STDMETHODIMP KsMediaSamplesCompleted(PKSSTREAM_SEGMENT StreamSegment)
	{ return E_UNEXPECTED; }
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation)
	{ return NULL; }
    STDMETHODIMP KsReceiveAllocator( IMemAllocator *pMemAllocator)
	{ return E_UNEXPECTED; }
    STDMETHODIMP KsRenegotiateAllocator()
	{ return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount()
	{ return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount()
	{ return E_UNEXPECTED; }
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta)
	{ return E_UNEXPECTED; }
    STDMETHODIMP_(REFERENCE_TIME) KsGetStartTime()
	{ return E_UNEXPECTED; }

    void CheckOverlayHidden();

    // helper functions to handle video accelerator comp
    HRESULT GetInfoFromCookie(DWORD dwCookie, LPCOMP_SURFACE_INFO *ppCompSurfInfo, LPSURFACE_INFO *ppSurfInfo);
    SURFACE_INFO *SurfaceInfoFromTypeAndIndex(DWORD dwTypeIndex, DWORD dwBufferIndex);
    BOOL IsSuitableVideoAcceleratorGuid(const GUID * pGuid);
    HRESULT InitializeUncompDataInfo(BITMAPINFOHEADER *pbmiHeader);
    HRESULT AllocateVACompSurfaces(LPDIRECTDRAW pDirectDraw, BITMAPINFOHEADER *pbmiHeader);
    HRESULT AllocateMCUncompSurfaces(LPDIRECTDRAW pDirectDraw, BITMAPINFOHEADER *pbmiHeader);
    HRESULT CreateVideoAcceleratorObject();
    HRESULT VACompleteConnect(IPin *pReceivePin, const CMediaType *pMediaType);
    HRESULT VABreakConnect();
    HRESULT CheckValidMCConnection();

    // IAMVideoAccelerator implementation
    STDMETHODIMP GetVideoAcceleratorGUIDs(LPDWORD pdwNumGuidsSupported, LPGUID pGuidsSupported);
    STDMETHODIMP GetUncompFormatsSupported(const GUID * pGuid, LPDWORD pdwNumFormatsSupported, LPDDPIXELFORMAT pFormatsSupported);
    STDMETHODIMP GetInternalMemInfo(const GUID * pGuid, const AMVAUncompDataInfo *pamvaUncompDataInfo, LPAMVAInternalMemInfo pamvaInternalMemInfo);
    STDMETHODIMP GetCompBufferInfo(const GUID * pGuid, const AMVAUncompDataInfo *pamvaUncompDataInfo, LPDWORD pdwNumTypesCompBuffers,  LPAMVACompBufferInfo pamvaCCompBufferInfo);
    STDMETHODIMP GetInternalCompBufferInfo(LPDWORD pdwNumTypesCompBuffers,  LPAMVACompBufferInfo pamvaCCompBufferInfo);
    STDMETHODIMP BeginFrame(const AMVABeginFrameInfo *pamvaBeginFrameInfo);
    STDMETHODIMP EndFrame(const AMVAEndFrameInfo *pEndFrameInfo);
    STDMETHODIMP GetBuffer(
        DWORD dwTypeIndex,
        DWORD dwBufferIndex,
        BOOL bReadOnly,
        LPVOID *ppBuffer,
        LPLONG lpStride);
    STDMETHODIMP ReleaseBuffer(DWORD dwTypeIndex, DWORD dwBufferIndex);
    STDMETHODIMP Execute(
        DWORD dwFunction,
        LPVOID lpPrivateInputData,
        DWORD cbPrivateInputData,
        LPVOID lpPrivateOutputData,
        DWORD cbPrivateOutputData,
        DWORD dwNumBuffers,
        const AMVABUFFERINFO *pAMVABufferInfo);
    STDMETHODIMP QueryRenderStatus(
        DWORD dwTypeIndex,
        DWORD dwBufferIndex,
        DWORD dwFlags);
    STDMETHODIMP DisplayFrame(DWORD dwFlipToIndex, IMediaSample *pMediaSample);

private:
    LONG                    m_cOurRef;                      // We maintain reference counting
    CCritSec                *m_pFilterLock;                 // Critical section for interfaces
    DWORD                   m_dwPinId;
    COMFilter               *m_pFilter;

    // VideoPort related stuff
    BOOL                    m_bVPSupported;
    LPUNKNOWN               m_pIVPUnknown;
    IVPObject               *m_pIVPObject;

    BOOL                    m_bIOverlaySupported;
    IOverlayNotify          *m_pIOverlayNotify;
    DWORD_PTR               m_dwAdviseNotify;

    // Synchronization stuff
    CAMSyncObj              *m_pSyncObj;

    // variables to implement IKsPin and IKsPropertySet
    KSPIN_MEDIUM           m_Medium;
    GUID                    m_CategoryGUID;
    KSPIN_COMMUNICATION    m_Communication;
    BOOL                    m_bStreamingInKernelMode;
    AMOVMIXEROWNER          m_OvMixerOwner;

#ifdef PERF
    int                     m_PerfFrameFlipped;
    int                     m_FrameReceived;
#endif

    // ddraw stuff
    LPDIRECTDRAWSURFACE     m_pDirectDrawSurface;
    LPDIRECTDRAWSURFACE     m_pBackBuffer;
    AM_RENDER_TRANSPORT     m_RenderTransport;
    DWORD                   m_dwBackBufferCount;
    DWORD                   m_dwDirectDrawSurfaceWidth;
    DWORD                   m_dwMinCKStretchFactor;
    BYTE                    m_bOverlayHidden;
    BYTE                    m_bSyncOnFill;
    BYTE                    m_bDontFlip ;
    BYTE                    m_bDynamicFormatNeeded;
    BYTE                    m_bNewPaletteSet;
    CMediaType              m_mtNew;
    CMediaType              m_mtNewAdjusted;
    DWORD                   m_dwUpdateOverlayFlags;
    DWORD                   m_dwInterlaceFlags;
    DWORD                   m_dwFlipFlag;
    DWORD                   m_dwFlipFlag2;
    BOOL                    m_bConnected;
    BOOL                    m_bUsingOurAllocator;
    HDC                     m_hMemoryDC;
    BOOL                    m_bCanOverAllocateBuffers;

    // window info related stuff
    WININFO                 m_WinInfo;
    RECT                    m_rRelPos;
    bool                    m_UpdateOverlayNeededAfterReceiveConnection;

    // variables to store the current aspect ratio and blending parameter
    DWORD                   m_dwZOrder;
    DWORD                   m_dwInternalZOrder;
    DWORD                   m_dwBlendingParameter;
    BOOL                    m_bStreamTransparent;
    AM_ASPECT_RATIO_MODE    m_amAspectRatioMode;
    BOOL                    m_bRuntimeNegotiationFailed;

    // Track frame delivery for QM
    REFERENCE_TIME          m_trLastFrame;

    // Backing DIB for Windowless renderer
    DIBDATA                 m_BackingDib;
    LONG                    m_BackingImageSize;


    HRESULT DrawGDISample(IMediaSample *pMediaSample);
    HRESULT DoRenderGDISample(IMediaSample *pMediaSample);

    // motion comp related variables
    BOOL                    m_bReallyFlipped;
    BOOL                    m_bVideoAcceleratorSupported;
    GUID                    m_mcGuid;
    DDVAUncompDataInfo      m_ddUncompDataInfo;
    DDVAInternalMemInfo     m_ddvaInternalMemInfo;
    DWORD                   m_dwCompSurfTypes;
    LPCOMP_SURFACE_INFO     m_pCompSurfInfo;
    IDDVideoAcceleratorContainer  *m_pIDDVAContainer;
    IDirectDrawVideoAccelerator   *m_pIDDVideoAccelerator;
    IAMVideoAcceleratorNotify     *m_pIVANotify;

    // Decimation related functions and variables
    HRESULT QueryDecimationOnPeer(long lWidth, long lHeight);

    enum {
        DECIMATION_NOT_SUPPORTED,   // decimation not supported
        DECIMATING_SIZE_SET,        // decimation image size changed
        DECIMATING_SIZE_NOTSET,     // decimation size didn't change
        DECIMATING_SIZE_RESET,      // decimation has been reset
    };

    HRESULT ResetDecimationIfSet();
    HRESULT TryDecoderDecimation(LPWININFO pWinInfo);
    BOOL    BeyondOverlayCaps(DWORD ScaleFactor);
    void    ApplyDecimation(LPWININFO pWinInfo);
    DWORD   GetOverlayStretchCaps();
    BOOL    Running();
    HRESULT GetUpstreamFilterName(TCHAR* FilterName);

    BOOL m_bDecimating;
    LONG m_lWidth, m_lHeight;
    LONG m_lSrcWidth, m_lSrcHeight;

    // Frame Step Stuff
    BOOL DoFrameStepAndReturnIfNeeded();
    HANDLE      m_StepEvent;		    // Used to signal timer events
    LONG        m_lFramesToStep;    // -ve == normal pb
                                    // +ve == frames to skips
                                    //   0 == time to block
    // IPinConnection stuff
    HANDLE      m_hEndOfStream;

};


class COMOutputPin : public CBaseOutputPin
{
public:
    COMOutputPin(TCHAR *pObjectName, COMFilter *pFilter, CCritSec *pLock,
	HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo);
    ~COMOutputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT GetMediaType(int iPosition,CMediaType *pmtOut);
    HRESULT SetMediaType(const CMediaType *pmt);

    HRESULT Active() { return NOERROR; }                                                                // override this as we don't have any allocator
    HRESULT Inactive() { return NOERROR; }                                                              // override this as we don't have any allocator
    HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * pProp);
    HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc) { return NOERROR; }           // override this as we don't have any allocator

    IPin *CurrentPeer() { return m_Connected; }
    DWORD GetPinId() { return m_dwPinId; }

    HWND GetWindow() { return m_hwnd; }
    HDC GetDC() { return m_hDC; }

    // functions related to subclassing and clipping to the renderer's window
    HRESULT SetNewWinProc();
    HRESULT SetOldWinProc();
    static LRESULT WINAPI NewWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT AttachWindowClipper();
    DWORD ReleaseWindowClipper();

private:
    CCritSec                *m_pFilterLock;
    IUnknown                *m_pPosition;
    DWORD                   m_dwPinId;
    COMFilter               *m_pFilter;
    IOverlay                *m_pIOverlay;
    BOOL                    m_bAdvise;

    // related to subclassing the renderer's window
    BOOL                    m_bWindowDestroyed;
    LONG_PTR                m_lOldWinUserData;
    WNDPROC                 m_hOldWinProc;

    LPDIRECTDRAWCLIPPER     m_pDrawClipper;                 // Used to handle the clipping
    HWND                    m_hwnd;
    HDC                     m_hDC;
    DWORD                   m_dwConnectWidth;
    DWORD                   m_dwConnectHeight;


};

BOOL
IsDecimationNeeded(
    DWORD ScaleFactor
    );

DWORD
GetCurrentScaleFactor(
    LPWININFO pWinInfo,
    DWORD* lpxScaleFactor = (DWORD*)NULL,
    DWORD* lpyScaleFactor = (DWORD*)NULL
    );

#endif //__OVMIXER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmprop\ovmprop.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Video renderer property pages, Anthony Phillips, January 1996

#ifndef __OVMPROP__
#define __OVMPROP__


// {565DCEF2-AFC5-11d2-8853-0000F80883E3}
DEFINE_GUID(CLSID_COMQualityProperties,
0x565dcef2, 0xafc5, 0x11d2, 0x88, 0x53, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

class COMQualityProperties : public CBasePropertyPage
{
public:

    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

private:

    COMQualityProperties(LPUNKNOWN lpUnk, HRESULT *phr);

    void SetEditFieldData();
    void Reset();
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();

    // IQualProp Interface
    IQualProp *m_pIQualProp;        // Interface held on the renderer

    // local data
    int m_iDropped;                 // Number of frames dropped
    int m_iDrawn;                   // Count of images drawn
    int m_iSyncAvg;                 // Average sync value
    int m_iSyncDev;                 // And standard deviation
    int m_iFrameRate;               // Total frame rate average
    int m_iFrameJitter;             // Measure of frame jitter

};  // class COMQualityProperties


// {0E681C52-CD03-11d2-8853-0000F80883E3}
DEFINE_GUID(CLSID_COMPositionProperties,
0xe681c52, 0xcd03, 0x11d2, 0x88, 0x53, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

class COMPositionProperties : public CBasePropertyPage
{
public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    COMPositionProperties(LPUNKNOWN lpunk, HRESULT *phr);

    void Reset();
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();

    // IMixerPinConfig3 interface
    IMixerPinConfig3* m_pIMixerPinConfig3;

    // IAMOverlayMixerPosition2 interface
    IAMOverlayMixerPosition2* m_pIAMOverlayMixerPosition2;

    // local data
    HWND m_hDlg;

};  // class COMPositionProperties


#if defined(DEBUG)
// f902b640-14b5-11d3-9eca-00104bde5
DEFINE_GUID(CLSID_COMDecimationProperties,
0xf902b640, 0x14b5, 0x11d3, 0x9e, 0xca, 0x00, 0x10, 0x4b, 0xde, 0x51, 0x6a);

class COMDecimationProperties : public CBasePropertyPage
{
public:
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    COMDecimationProperties(LPUNKNOWN lpunk, HRESULT *phr);

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnDestroy(HWND hwnd);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnApplyChanges();

    // IAMVideoDecimationProperties interface
    IAMVideoDecimationProperties* m_pIAMVDP;

    IAMSpecifyDDrawConnectionDevice* m_pIAMSDC;

    // local data
    HWND                m_hDlg;
    DECIMATION_USAGE    m_dwUsage;
    DWORD               m_dwCount;
    AMDDRAWMONITORINFO* m_lpMonInfo;
    AMDDRAWGUID         m_GUID;
    BOOL                m_MMonWarn;

};  // class COMDecimationProperties
#endif

#endif // __OVMPROP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmprop\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ovmprop.rc
//
#define IDD_Q1                          151
#define IDD_Q2                          152
#define IDD_Q4                          154
#define IDD_Q5                          155
#define IDD_Q6                          156
#define IDD_Q7                          157
#define FIRST_Q_BUTTON                  171
#define IDD_QDRAWN                      171
#define IDD_QDROPPED                    172
#define IDD_QAVGFRM                     174
#define IDD_QJITTER                     175
#define IDD_QSYNCAVG                    176
#define IDD_QSYNCDEV                    177
#define LAST_Q_BUTTON                   177
#define IDC_INPIN_RELPOS                1000
#define IDC_INPIN_DEST                  1001
#define IDC_INPIN_SRC                   1002
#define IDC_INPIN_SCALEDDEST            1003
#define IDC_BASIC_VID_DEST              1004
#define IDC_BASIC_VID_SRC               1005
#define IDC_BASIC_VID_SIZE              1006
#define IDC_VPINFO                      1080
#define IDC_VP_BANDWIDTH                1081
#define IDC_VP_CAPS                     1082
#define IDC_VP_FX                       1083
#define IDC_VP_INFO                     1084
#define IDC_VP_CONFIG                   1085
#define IDC_INPIN_RECTS                 1087
#define IDC_DECIMATION_OPTIONS          1088
#define IDC_DDRAW_DEVICE                1089
#define IDC_MAKE_DEFAULT                1090
#define IDC_DEFAULT_DECIMATION          1091
#define IDC_DECODER_CAPS                1092
#define IDC_MMWARNING                   1094
#define FIRST_PINCONFIG                 2004
#define IDC_POSITION_ZORDER             2004
#define IDC_BLENDING                    2005
#define IDC_TRANSPARENT                 2006
#define IDC_ASPECTRATIO_NONE            2007
#define IDC_ASPECTRATIO_ASPRIMARY       2008
#define IDC_ASPECTRATIO_LETTERBOX       2009
#define IDC_ASPECTRATIO_CROP            2010
#define IDD_DECIMATION_USAGE            2010
#define IDC_COLORKEY_R                  2011
#define IDC_COLORKEY_G                  2012
#define IDC_COLORKEY_B                  2013
#define IDC_COLORKEY                    2014
#define IDC_COLORKEY_NONE               2015
#define IDC_COLORKEY_INDEX              2016
#define IDC_COLORKEY_RGB                2017
#define IDC_COLORKEY_INDEXENTRY         2018
#define IDC_COLORKEY_TEXTR              2019
#define IDC_COLORKEY_TEXTG              2020
#define IDC_COLORKEY_TEXTB              2021
#define IDC_COLORKEY_TEXTINDEX          2022
#define LAST_PINCONFIG                  2022
#define IDC_PININFO                     2023
#define IDC_RESET                       2024
#define IDC_APPLY                       2025
#define IDD_IQUALITY                    3001
#define IDD_IMIXERPINCONFIG             3002
#define IDD_IOVMIXERPOS                 3003
#define IDD_IVPINFO                     3004
#define IDS_TITLE_MIXPOS                3005
#define IDS_TITLE_PINCFG                3006
#define IDS_TITLE_VPINFO                3007
#define IDS_TITLE_QUALITY               3008
#define IDS_DECIMATION_LEGACY           3009
#define IDS_DECIMATION_USE_DECODER_ONLY 3010
#define IDS_DECIMATION_USE_VIDEOPORT_ONLY 3011
#define IDS_DECIMATION_USE_OVERLAY_ONLY 3012
#define IDS_DEFAULT_DECIMATION          3013
#define IDS_TITLE_DECIMATION            3014
#define IDS_HW_LIMIT                    3015

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2011
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1095
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmprop\ovmprop2.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//

#include <streams.h>
#include <dvp.h>
#include <vptype.h>
#include <vpinfo.h>
#include <mpconfig3.h>
#include <ovmprop2.h>
#include <resource.h>
#include <atlbase.h>


extern void SetDlgItemRect(HWND hwnd, int id, const RECT& rect, BOOL valid);
extern HRESULT GetSrcRectFromMediaType(const CMediaType *pMediaType, RECT *pRect);
extern HRESULT GetDestRectFromMediaType(const CMediaType *pMediaType, RECT *pRect);

inline void SAFE_RELEASE(IUnknown **ppObj)
{
    if ( *ppObj != NULL )
    {
        ULONG cRef = (*ppObj)->Release();
        *ppObj = NULL;
    }
}


//
// CreateInstance
//
// Override CClassFactory method.
// Set lpUnk to point to an IUnknown interface on a new COMPinConfigProperties object
// Part of the COM object instantiation mechanism
//
CUnknown * WINAPI COMPinConfigProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new COMPinConfigProperties(lpunk, phr);
    if (punk == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
} // CreateInstance


//
// COMPinConfigProperties::Constructor
//
// Constructs and initialises an COMPinConfigProperties object
//
COMPinConfigProperties::COMPinConfigProperties(LPUNKNOWN pUnk, HRESULT *phr)
: CBasePropertyPage(NAME("Overlay Mixer Property Page"),pUnk,
                    IDD_IMIXERPINCONFIG, IDS_TITLE_PINCFG)
                    , m_pIMixerPinConfig3(NULL)
                    , m_pIPin(NULL)
                    , m_amAspectRatioMode(AM_ARMODE_STRETCHED)
                    , m_dwBlending(DWORD(-1))
                    , m_dwZOrder(DWORD(-1))
                    , m_fTransparent(FALSE)
                    , m_dwKeyType(DWORD(-1))
                    , m_dwPaletteIndex(DWORD(-1))
                    , m_LowColor(COLORREF(-1))
                    , m_HighColor(COLORREF(-1))
                    , m_hDlg(HWND(NULL))

{
    ASSERT(phr);

} // (constructor) COMPinConfigProperties


HRESULT COMPinConfigProperties::OnActivate()
{
    Reset();
    return NOERROR;
}


// Override CBasePropertyPage's GetPageInfo
STDMETHODIMP COMPinConfigProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{
    HRESULT hr = CBasePropertyPage::GetPageInfo(pPageInfo);

    // Figure out which input pin it is, and concat the pin number to
    // property page's title
    if ( S_OK == hr && m_pIPin)
    {
        PIN_INFO PinInfo;
        PinInfo.pFilter = NULL;
        hr = m_pIPin->QueryPinInfo( &PinInfo );
        SAFE_RELEASE( (LPUNKNOWN *) &PinInfo.pFilter );

        // Get the default page title
        WCHAR wszTitle[STR_MAX_LENGTH];
        WideStringFromResource(wszTitle,m_TitleId);

        // Put the original title and pin name together
        wsprintfWInternal(wszTitle+lstrlenWInternal(wszTitle), L"%ls", PinInfo.achName);

        // Allocate dynamic memory for the new property page title
        int Length = (lstrlenWInternal(wszTitle) + 1) * sizeof(WCHAR);
        LPOLESTR pszTitle = (LPOLESTR) QzTaskMemAlloc(Length);
        if (pszTitle == NULL) {
            NOTE("No caption memory");
            return E_OUTOFMEMORY;
        }
        CopyMemory(pszTitle,wszTitle,Length);

        // Free the memory of the old title string
        if (pPageInfo->pszTitle)
            QzTaskMemFree(pPageInfo->pszTitle);
        pPageInfo->pszTitle = pszTitle;

    }

    return hr;
}


BOOL MyChooseColor(LPCHOOSECOLOR lpcc)
{
    typedef BOOL (APIENTRY *LPFNCHOOSECOLOR)(LPCHOOSECOLOR);
    static LPFNCHOOSECOLOR lpfnChooseColor;
    static const TCHAR szComDlg32[] = TEXT("ComDlg32.dll");
#ifdef UNICODE
    static const char szChooseColor[] = "ChooseColorW";
#else
    static const char szChooseColor[] = "ChooseColorA";
#endif

    if (!lpfnChooseColor) {
        HINSTANCE hInst = LoadLibrary(szComDlg32);
        if (hInst) {
            lpfnChooseColor =
                (LPFNCHOOSECOLOR)GetProcAddress(hInst, szChooseColor);
        }
    }

    if (!lpfnChooseColor) {
        return FALSE;
    }

    return (*lpfnChooseColor)(lpcc);
}



void COMPinConfigProperties::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    static COLORREF CustColors[16];

    switch(id) {
    case IDC_COLORKEY:

        CHOOSECOLOR ColorRec;
        ZeroMemory( &ColorRec, sizeof(CHOOSECOLOR) );

        ColorRec.lStructSize = sizeof(CHOOSECOLOR);
        ColorRec.hwndOwner = hwnd;
        ColorRec.hInstance = NULL;
        ColorRec.rgbResult = m_LowColor;
        ColorRec.lpCustColors = (LPDWORD) CustColors;
        ColorRec.Flags =  CC_RGBINIT | CC_FULLOPEN;
        ColorRec.lCustData = NULL;
        ColorRec.lpfnHook = NULL;
        ColorRec.lpTemplateName = NULL;
        if ( MyChooseColor( &ColorRec ) )
        {
            m_HighColor = m_LowColor = ColorRec.rgbResult;
            SetDlgItemInt( hwnd, IDC_COLORKEY_R, GetRValue(m_LowColor), FALSE );
            SetDlgItemInt( hwnd, IDC_COLORKEY_G, GetGValue(m_LowColor), FALSE );
            SetDlgItemInt( hwnd, IDC_COLORKEY_B, GetBValue(m_LowColor), FALSE );

            SetDirty();
        }

    case IDC_COLORKEY_R:
        //if ( HIWORD( wParam ) == EN_KILLFOCUS )
        UpdateColorKey(IDC_COLORKEY_R);
        break;

    case IDC_COLORKEY_G:
        //if ( HIWORD( wParam ) == EN_KILLFOCUS )
        UpdateColorKey(IDC_COLORKEY_G);
        break;

    case IDC_COLORKEY_B:
        //if ( HIWORD( wParam ) == EN_KILLFOCUS )
        UpdateColorKey(IDC_COLORKEY_B);
        break;


    case IDC_COLORKEY_NONE:
    case IDC_COLORKEY_INDEX:
    case IDC_COLORKEY_RGB:
        {
            DWORD keyType;
            CheckRadioButton( hwnd, IDC_COLORKEY_NONE, IDC_COLORKEY_RGB, id);
            switch (id) {
            case IDC_COLORKEY_NONE:
                keyType = CK_NOCOLORKEY;
                break;
            case IDC_COLORKEY_INDEX:
                keyType = CK_INDEX;
                break;
            case IDC_COLORKEY_RGB:
            default:
                keyType = CK_RGB;
                break;

            }

            if (m_dwKeyType != keyType)
                SetDirty();
            m_dwKeyType = keyType;
            ShowColorKey();
        }
        break;

    case IDC_COLORKEY_INDEXENTRY:
        //if ( HIWORD( wParam ) == EN_KILLFOCUS )
        {
            BOOL fTranslated;
            DWORD dwTmp = GetDlgItemInt( hwnd, IDC_COLORKEY_INDEXENTRY, &fTranslated, FALSE);
            if ( fTranslated )
            {
                if ( m_dwPaletteIndex != dwTmp )
                {
                    SetDirty();
                    m_dwPaletteIndex = dwTmp;

                    HDC hDC = GetDC( NULL );
                    BOOL bPalette = (RC_PALETTE == (RC_PALETTE & GetDeviceCaps( hDC, RASTERCAPS )));

                    if ( bPalette )
                    {
                        PALETTEENTRY PaletteEntry;
                        UINT nTmp = GetSystemPaletteEntries( hDC, m_dwPaletteIndex, 1, &PaletteEntry );
                        if ( nTmp == 1 )
                        {
                            m_HighColor = m_LowColor = RGB( PaletteEntry.peRed, PaletteEntry.peGreen, PaletteEntry.peBlue );
                            SetDlgItemInt( hwnd, IDC_COLORKEY_R, GetRValue(m_LowColor), FALSE );
                            SetDlgItemInt( hwnd, IDC_COLORKEY_G, GetGValue(m_LowColor), FALSE );
                            SetDlgItemInt( hwnd, IDC_COLORKEY_B, GetBValue(m_LowColor), FALSE );
                        }
                    }
                    ReleaseDC( NULL, hDC );
                }
            }
        }
        break;

    case IDC_ASPECTRATIO_NONE:
        if ( m_amAspectRatioMode != AM_ARMODE_STRETCHED )
            SetDirty();
        m_amAspectRatioMode = AM_ARMODE_STRETCHED;
        break;
    case IDC_ASPECTRATIO_ASPRIMARY:
        if ( m_amAspectRatioMode != AM_ARMODE_STRETCHED_AS_PRIMARY )
            SetDirty();
        m_amAspectRatioMode = AM_ARMODE_STRETCHED_AS_PRIMARY;
        break;

    case IDC_ASPECTRATIO_LETTERBOX:
        if ( m_amAspectRatioMode != AM_ARMODE_LETTER_BOX )
            SetDirty();
        m_amAspectRatioMode = AM_ARMODE_LETTER_BOX;
        break;

    case IDC_ASPECTRATIO_CROP:
        if ( m_amAspectRatioMode != AM_ARMODE_CROP )
            SetDirty();
        m_amAspectRatioMode = AM_ARMODE_CROP;
        break;

    case IDC_BLENDING:
        //if ( HIWORD( wParam ) == EN_KILLFOCUS )
        UpdateItemInt(IDC_BLENDING, &m_dwBlending);
        break;

    case IDC_POSITION_ZORDER:
        //if ( HIWORD( wParam ) == EN_KILLFOCUS )
        UpdateItemInt(IDC_POSITION_ZORDER, &m_dwZOrder);
        break;

    case IDC_TRANSPARENT:
        {
            BOOL fChecked = IsDlgButtonChecked( hwnd, IDC_TRANSPARENT );
            if ( fChecked != m_fTransparent ) SetDirty();
            m_fTransparent = fChecked;
            break;
        }

    case IDC_RESET:
        Reset();
    }

}


BOOL COMPinConfigProperties::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // init local variables
    m_dwBlending = -1;
    m_dwZOrder = -1;
    m_fTransparent = FALSE;

    m_dwKeyType = -1;
    m_dwPaletteIndex = -1;
    m_LowColor = -1;
    m_HighColor = -1;

    m_hDlg = hwnd;

    ShowColorKey();
    return TRUE;
}


//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR COMPinConfigProperties::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_COMMAND,    OnCommand);
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
    } // switch

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} // OnReceiveMessage


//
// UpdateColorKey
//
// Compute Colorkey from the prop page entries,
// Update Colorkey and call SetDirty if changed
//
HRESULT COMPinConfigProperties::UpdateColorKey(int id)
{
    BOOL fTranslated;
    DWORD dwTmp;

    dwTmp = GetDlgItemInt( m_hDlg, id, &fTranslated, FALSE);
    if ( fTranslated )
    {
        switch (id) {
        case IDC_COLORKEY_R:
            m_LowColor = RGB( dwTmp, GetGValue(m_LowColor), GetBValue(m_LowColor) );
            break;
        case IDC_COLORKEY_G:
            m_LowColor = RGB( GetRValue(m_LowColor), dwTmp, GetBValue(m_LowColor) );
            break;
        case IDC_COLORKEY_B:
            m_LowColor = RGB( GetRValue(m_LowColor), GetGValue(m_LowColor), dwTmp );
            break;
        }
    }
    if ( m_LowColor != m_HighColor )
    {
        m_HighColor = m_LowColor;
        SetDirty();
    }
    return NOERROR;
}


//
// ShowColorKey
//
// Decide what dialog items to show depending on the colorkey type
//
HRESULT COMPinConfigProperties::ShowColorKey(void)
{
    BOOL bSet = (m_dwKeyType == CK_RGB? SW_SHOW : SW_HIDE);
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY ), bSet );
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_R ), bSet );
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_B ), bSet );
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_G ), bSet );
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_TEXTR ), bSet );
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_TEXTB ), bSet );
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_TEXTG ), bSet );
    bSet = (m_dwKeyType == CK_INDEX? SW_SHOW : SW_HIDE);
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_INDEXENTRY ), bSet );
    ShowWindow( GetDlgItem( m_hDlg, IDC_COLORKEY_TEXTINDEX ), bSet );
    return NOERROR;
}


//
// UpdateItemInt
//
// Get int from a DlgItem, if different from saved
// Update saved and call SetDirty
//
HRESULT COMPinConfigProperties::UpdateItemInt(int id, DWORD* saved)
{
    BOOL fTranslated;
    DWORD dwTmp = GetDlgItemInt( m_hDlg, id, &fTranslated, FALSE);
    if ( fTranslated )
    {
        if ( *saved != dwTmp ) SetDirty();
        *saved = dwTmp;
    }
    return NOERROR;
}


//
// Reset
//
// Reset all dialog entries
//
void COMPinConfigProperties::Reset(void)
{
    ASSERT(m_pIMixerPinConfig3);
    ASSERT(m_pIPin);

    HRESULT hr = S_OK;

    IPin *iPin = NULL;
    hr = m_pIPin->ConnectedTo(&iPin);
    if (FAILED(hr) || !iPin) {
        SetDlgItemText( m_hDlg, IDC_PININFO, TEXT("Pin Not Connected"));
        for (int i=FIRST_PINCONFIG; i<=LAST_PINCONFIG; i++)
            EnableWindow( GetDlgItem( m_hDlg, i ), FALSE );
        return;
    }
    iPin->Release();

    TCHAR szError[255];
    lstrcpy( szError, TEXT("") );

    if ( S_OK == hr )
    {
        IPin *		pNextPin = NULL;
        IEnumPins *	pPinEnum = NULL;
        PIN_INFO	PinInfo;
        ULONG		ulFetched;

        PinInfo.pFilter = NULL;
        hr = m_pIPin->QueryPinInfo( &PinInfo );

        if ( S_OK == hr )
        {
            hr = PinInfo.pFilter->EnumPins( &pPinEnum );
            SAFE_RELEASE( (LPUNKNOWN *) &PinInfo.pFilter );
        }

        if ( S_OK == hr )
            hr = pPinEnum->Reset();

        while ( S_OK == hr )
        {
            hr = pPinEnum->Next( 1, &pNextPin, &ulFetched );

            if ( S_OK == hr )
            {
                hr = pNextPin->QueryPinInfo( &PinInfo );
                SAFE_RELEASE( (LPUNKNOWN *) &PinInfo.pFilter );
            }

            if ( S_OK == hr && PinInfo.dir == PINDIR_INPUT )
            {
                if ( m_pIPin == pNextPin ) {
                    lstrcpy( szError, TEXT("Primary Input Pin - ") );
                    ShowWindow( GetDlgItem( m_hDlg, IDC_ASPECTRATIO_ASPRIMARY ), FALSE );

                    // Get Render Tranport Mode
                    hr = m_pIMixerPinConfig3->GetRenderTransport( &m_amRenderTransport);
                    if ( S_OK == hr) {
                        switch (m_amRenderTransport) {
                        case AM_OVERLAY:
                            lstrcat( szError, TEXT("Overlay\n"));
                            break;
                        case AM_VIDEOPORT:
                            lstrcat( szError, TEXT("Videoport\n"));
                            break;
                        case AM_OFFSCREEN:
                            lstrcat( szError, TEXT("Offscreen\n"));
                            break;
                        case AM_VIDEOACCELERATOR:
                            lstrcat( szError, TEXT("Video Accelerator\n"));
                            break;
                        case AM_GDI:
                            lstrcat( szError, TEXT("GDI\n"));
                            break;
                        default:
                            lstrcat( szError, TEXT("Error\n"));
                        }
                    }
                }
                else {
                    lstrcpy( szError, TEXT("Secondary Input Pin\n") );
                    ShowWindow( GetDlgItem( m_hDlg, IDC_ASPECTRATIO_ASPRIMARY ), TRUE );
                }

                SAFE_RELEASE( (LPUNKNOWN *) &pNextPin );
                break;
            }
            SAFE_RELEASE( (LPUNKNOWN *) &pNextPin );
        }

        SAFE_RELEASE( (LPUNKNOWN *) &pPinEnum );
    }

    // Get inpin relative position
    RECT rect;
    if ( S_OK == hr )
        hr = m_pIMixerPinConfig3->GetRelativePosition
        ( (DWORD*)&(rect.left), (DWORD*)&(rect.top), (DWORD*)&(rect.right), (DWORD*)&(rect.bottom) );
    SetDlgItemRect(m_hDlg, IDC_INPIN_RELPOS, rect, SUCCEEDED(hr));

    // Get inpin src rect from media type
    AM_MEDIA_TYPE mt;
    hr = m_pIPin->ConnectionMediaType(&mt);
    if ( S_OK == hr )
        hr = GetSrcRectFromMediaType(&CMediaType(mt), &rect);
    SetDlgItemRect(m_hDlg, IDC_INPIN_SRC, rect, SUCCEEDED(hr));

    // Get inpin dest rect from media type
    if ( S_OK == hr )
        hr = GetDestRectFromMediaType(&CMediaType(mt), &rect );
    SetDlgItemRect(m_hDlg, IDC_INPIN_DEST, rect, SUCCEEDED(hr));


    hr = m_pIMixerPinConfig3->GetStreamTransparent( &m_fTransparent );
    CheckDlgButton( m_hDlg, IDC_TRANSPARENT, m_fTransparent ? BST_CHECKED : BST_UNCHECKED );
    if ( S_OK != hr )
    {
        lstrcat( szError, TEXT("Error Getting Transparency\n") );
    }

    hr = m_pIMixerPinConfig3->GetZOrder( &m_dwZOrder );
    if ( S_OK == hr )
    {
        SetDlgItemInt( m_hDlg, IDC_POSITION_ZORDER, m_dwZOrder, FALSE );
    }
    else
    {
        SetDlgItemText( m_hDlg, IDC_POSITION_ZORDER, TEXT("") );
        lstrcat( szError, TEXT("Error Getting ZOrder\n") );
    }

    hr = m_pIMixerPinConfig3->GetBlendingParameter( &m_dwBlending );
    if ( S_OK == hr )
    {
        SetDlgItemInt( m_hDlg, IDC_BLENDING, m_dwBlending, FALSE );
    }
    else
    {
        SetDlgItemText( m_hDlg, IDC_BLENDING, TEXT("") );
        lstrcat( szError, TEXT("Error Getting Blending\n") );
    }

    hr = m_pIMixerPinConfig3->GetAspectRatioMode( &m_amAspectRatioMode );
    switch ( m_amAspectRatioMode )
    {
        case AM_ARMODE_STRETCHED_AS_PRIMARY:
            CheckRadioButton( m_hDlg, IDC_ASPECTRATIO_NONE, IDC_ASPECTRATIO_CROP, IDC_ASPECTRATIO_ASPRIMARY );
            break;
        case AM_ARMODE_STRETCHED:
            CheckRadioButton( m_hDlg, IDC_ASPECTRATIO_NONE, IDC_ASPECTRATIO_CROP, IDC_ASPECTRATIO_NONE );
            break;
        case AM_ARMODE_LETTER_BOX:
            CheckRadioButton( m_hDlg, IDC_ASPECTRATIO_NONE, IDC_ASPECTRATIO_CROP, IDC_ASPECTRATIO_LETTERBOX );
            break;
        case AM_ARMODE_CROP:
            CheckRadioButton( m_hDlg, IDC_ASPECTRATIO_NONE, IDC_ASPECTRATIO_CROP, IDC_ASPECTRATIO_CROP );
            break;
    }

    if ( S_OK != hr )
    {
        lstrcat( szError, TEXT("Error Getting Aspect Ratio\n") );
    }

    COLORKEY	ColorKey;
    DWORD		dwColor;
    hr = m_pIMixerPinConfig3->GetColorKey( &ColorKey, &dwColor );
    if ( S_OK == hr )
    {
        m_dwKeyType = ColorKey.KeyType;
        m_dwPaletteIndex = ColorKey.PaletteIndex;
        m_LowColor = C