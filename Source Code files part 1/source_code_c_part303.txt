;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("LpcSecurity","stub_ServerListen",Status);
        PrintToConsole("LpcSecurity : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("LpcSecurity","RpcServerUnregisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("LpcSecurity","RpcServerUnregisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("LpcSecurity : PASS\n");
}

void
TestObjectUuids (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("TestObjectUuids : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("TestObjectUuids","stub_RegisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("TestObjectUuids","stub_RegisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("TestObjectUuids","stub_ServerListen",Status);
        PrintToConsole("TestObjectUuids : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcServerUnregisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcServerUnregisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("TestObjectUuids : PASS\n");
}


void
SPipe (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("SPipe : Test Pipes\n");

    Status = RpcServerRegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("SPipe","RpcServerRegisterIf",Status);
        PrintToConsole("SPipe : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerRegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("SPipe","RpcServerRegisterIf",Status);
        PrintToConsole("SPipe : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SPIPE), 0);
    if (Status)
        {
        ApiError("SPipe","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("SPipe : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = RpcServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("SPipe","RpcServerListen",Status);
        PrintToConsole("SPipe : FAIL - RpcServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("SPipe : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("SPipe","RpcServerUnregisterIf",Status);
        PrintToConsole("SPipe : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    PrintToConsole("SPipe : PASS\n");
}


void
Grant (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Graham in uclnt.exe.

--*/
{
    PrintToConsole("Grant : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, (RPC_MGR_EPV PAPI *) 722);
    if (Status)
        {
        ApiError("Grant","stub_RegisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Grant","stub_RegisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(GRANT), 0);
    if (Status)
        {
        ApiError("Grant","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Grant : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    HelgaCheckManagerEpv = 1;
    HelgaManagerEpv = (RPC_MGR_EPV PAPI *) 722;
    if (DatagramFlag == 0)
        {
        HelgaCheckObject = 1;
        }
    HelgaMagicNumber = 106;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    HelgaCheckObject = 0;
    HelgaCheckManagerEpv = 0;
    if (Status)
        {
        ApiError("Grant","stub_ServerListen",Status);
        PrintToConsole("Grant : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Grant : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Grant : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Grant","RpcServerUnregisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Grant","RpcServerUnregisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Grant : PASS\n");
}


void
Elliot (
    )
/*++

Routine Description:

    This routine tests callbacks, multiple address, and multiple
    interfaces. It works with Edward in uclnt.exe.  We also test
    client side binding as well.  This test is named after a famous
    (at least in his mind) cat.

--*/
{
    PrintToConsole("Elliot : Verify Multiple Addresses and Interfaces, ");
    PrintToConsole("and Callbacks\n");

    Status = RpcImpersonateClient(0);
    if ( Status != RPC_S_NO_CALL_ACTIVE )
        {
        ApiError("Elliot", "RpcImpersonateClient", Status);
        PrintToConsole("Elliot : FAIL - RpcImpersonateClient\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ELLIOTMAXIMIZE), 0);
    if (Status)
        {
        ApiError("Elliot","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Elliot : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Elliot","stub_RegisterIf",Status);
        PrintToConsole("Elliot : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ELLIOTMINIMIZE), 0);
    if (Status)
        {
        ApiError("Elliot","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Elliot : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ELLIOTNORMAL), 0);
    if (Status)
        {
        ApiError("Elliot","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Elliot : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Elliot","stub_RegisterIf",Status);
        PrintToConsole("Elliot : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Elliot","stub_RegisterIf",Status);
        PrintToConsole("Elliot : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    PrintToConsole("Elliot: Start listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 1);
    if (Status)
        {
        ApiError("Elliot","stub_ServerListen",Status);
        PrintToConsole("Elliot : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (AutoListenFlag == 0)
        {
        PrintToConsole("Elliot: RpcMgmtWaitServerListen\n") ;
        Status = RpcMgmtWaitServerListen();
        if (Status)
            {
            ApiError("Elliot","RpcMgmtWaitServerListen",Status);
            PrintToConsole("Elliot : FAIL - RpcMgmtWaitServerListen Failed\n");
            return;
            }
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Elliot : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Elliot : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Elliot : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (AutoListenFlag)
        {
        // unregister the interfaces individually
        Status = RpcServerUnregisterIf(
         (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister Interface ");
            PrintToConsole("(Isabelle)\n");
            return;
            }

        Status = RpcServerUnregisterIf(
         (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister Interface ");
            PrintToConsole("(Sylvia)\n");
            return;
            }

        Status = RpcServerUnregisterIf(
         (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister Interface ");
            PrintToConsole("(Helga)\n");
            return;
            }
        }
    else
        {
        Status = RpcServerUnregisterIf(0, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister All Interfaces\n");
            return;
            }
        }

    PrintToConsole("Elliot : PASS\n");
}


void
Andromida (
    )
/*++

Routine Description:

    This routine is used to perform multithreaded client tests.  This
    test works with the Astro test in uclnt.exe.

--*/
{
    PrintToConsole("Andromida : Multithreaded Clients\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ANDROMIDA), 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Andromida : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Andromida","stub_RegisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Andromida","stub_RegisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Andromida","stub_RegisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Andromida","stub_ServerListen",Status);
        PrintToConsole("Andromida : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Andromida : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Andromida : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Andromida : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUnregisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUnregisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUnregisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    PrintToConsole("Andromida : PASS\n");
}


void
Fredrick (
    )
/*++

Routine Description:

    This routine is used to verify all client DCE rpc runtime APIs.  It
    works with Fitzgerald in uclnt.exe.

--*/
{
    PrintToConsole("Fredrick : Verify All Client APIs\n");

    if (TransportType == RPC_TRANSPORT_TCP)
        {
        struct hostent *he;
        WSADATA data;
        struct in_addr addr;
        u_long AddrAsLong;
        RPC_CHAR Buffer[50];
        RPC_POLICY Policy;

        if ( WSAStartup(2, &data) != NO_ERROR)
            {
            ApiError("Fredrick","WSAStartup",Status);
            PrintToConsole("Fredrick : FAIL - Unable to call WSAStartup\n");
            return;
            }

        // Get Dns hostname
        he = gethostbyname( "" );
        if (he == NULL)
            {
            ApiError("Fredrick","gethostbyname",Status);
            PrintToConsole("Fredrick : FAIL - Unable to call gethostbyname\n");
            return;
            }

//        AddrAsLong = ntohl(*(DWORD *)he->h_addr_list[0]);
        memcpy(&addr, (DWORD *)he->h_addr_list[0], sizeof(addr));
        swprintf(Buffer, L"%d.%d.%d.%d", addr.S_un.S_un_b.s_b1, addr.S_un.S_un_b.s_b2,
            addr.S_un.S_un_b.s_b3, addr.S_un.S_un_b.s_b4);

        Policy.Length = sizeof(RPC_POLICY);
        Policy.EndpointFlags = 0;
        Policy.NICFlags = 0;
        Status = I_RpcServerUseProtseqEp2(Buffer, L"ncacn_ip_tcp", 3, L"2500", NULL, &Policy);
        if (Status)
            {
            ApiError("Fredrick","I_RpcServerUseProtseqEp2",Status);
            PrintToConsole("Fredrick : FAIL - Unable to Use Protseq Endpoint\n");
            return;
            }
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(FREDRICK), 0);
    if (Status)
        {
        ApiError("Fredrick","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Fredrick","stub_RegisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Fredrick","stub_RegisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Fredrick","stub_ServerListen",Status);
        PrintToConsole("Fredrick : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fredrick : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Fredrick : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    PauseExecution(10000L);

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Fredrick","RpcServerUnregisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Fredrick","RpcServerUnregisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Fredrick : PASS\n");
}


void
GenerateUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to generate a value for a uuid.  The magic
    number argument is used in mysterious and wonderful ways to
    generate a uuid (which is not necessarily correct).

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        generate a uuid.

    Uuid - Returns the generated uuid.

--*/
{
    Uuid->Data1 = ((unsigned long) MagicNumber)
        * ((unsigned long) MagicNumber);
    Uuid->Data2 = MagicNumber;
    Uuid->Data3 = MagicNumber / 2;
    Uuid->Data4[0] = MagicNumber % 256;
    Uuid->Data4[1] = MagicNumber % 257;
    Uuid->Data4[2] = MagicNumber % 258;
    Uuid->Data4[3] = MagicNumber % 259;
    Uuid->Data4[4] = MagicNumber % 260;
    Uuid->Data4[5] = MagicNumber % 261;
    Uuid->Data4[6] = MagicNumber % 262;
    Uuid->Data4[7] = MagicNumber % 263;
}


int
ChristopherObjectSetType (
    IN unsigned short ObjectMagicNumber,
    IN unsigned short TypeMagicNumber,
    IN unsigned int MustFailFlag
    )
/*++

Routine Description:

    This routine calls the RpcObjectSetType routine.  The object uuid
    is generated using the object magic number argument, and the type
    uuid uses the type magic number argument.

Arguments:

    ObjectMagicNumber - Supplies the magic number to be used to generate
        the object uuid to be passed to RpcObjectSetType.

    TypeMagicNumber - Supplies the magic number to use to generate the
        type uuid.

    MustFailFlag - Supplies a flag indicating whether or not the call
        to RpcObjectSetType must succeed or fail.  If this flag is
        zero, then RpcObjectSetType must return RPC_S_OK, otherwise,
        the test fails.  If the flag is non-zero, then RpcObjectSetType
        must return RPC_S_ALREADY_REGISTERED.

Return Value:

    Zero will be returned if the test completes successfully; otherise,
    non-zero will be returned.

--*/
{
    UUID ObjectUuid;
    UUID TypeUuid;

    GenerateUuidValue(ObjectMagicNumber,&ObjectUuid);
    GenerateUuidValue(TypeMagicNumber,&TypeUuid);

    Status = RpcObjectSetType(&ObjectUuid,&TypeUuid);
    if (MustFailFlag == 0)
        {
        if (Status)
            {
            ApiError("Christopher","RpcObjectSetType",Status);
            PrintToConsole("Christopher : FAIL - Can not Set Object Type\n");
            return(1);
            }
        }
    else
        {
        if (Status != RPC_S_ALREADY_REGISTERED)
            {
            PrintToConsole("Christopher : FAIL - RpcObjectSetType did not");
            PrintToConsole(" fail as expected\n");
            return(1);
            }
        }

    return(0);
}


int
ChristopherObjectSetNullType (
    IN unsigned short ObjectMagicNumber,
    IN unsigned int UseNullUuidFlag,
    IN unsigned int MustFailFlag
    )
/*++

Routine Description:

    This routine calls the RpcObjectSetType routine.  The object uuid
    is generated using the object magic number argument, and the type
    uuid is either not specified, or is the null uuid.

Arguments:

    ObjectMagicNumber - Supplies the magic number to be used to generate
        the object uuid to be passed to RpcObjectSetType.

    UseNullUuidFlag - Supplies a flag indicating whether to specify
        the null uuid for the type uuid or nothing.  If this flag is
        non-zero the null uuid will be specified as the type uuid;
        otherwise, the type uuid will not be specified.

    MustFailFlag - Supplies a flag indicating whether or not the call
        to RpcObjectSetType must succeed or fail.  If this flag is
        zero, then RpcObjectSetType must return RPC_S_OK, otherwise,
        the test fails.  If the flag is non-zero, then RpcObjectSetType
        must return RPC_S_OBJECT_NOT_FOUND.

Return Value:

    Zero will be returned if the test completes successfully; otherise,
    non-zero will be returned.

--*/
{
    UUID ObjectUuid;
    UUID TypeUuid;

    GenerateUuidValue(ObjectMagicNumber,&ObjectUuid);
    memset(&TypeUuid,0,sizeof(UUID));

    if (UseNullUuidFlag == 0)
        Status = RpcObjectSetType(&ObjectUuid,&TypeUuid);
    else
        Status = RpcObjectSetType(&ObjectUuid,0);
    if (MustFailFlag == 0)
        {
        if (Status)
            {
            ApiError("Christopher","RpcObjectSetType",Status);
            PrintToConsole("Christopher : FAIL - Can not Set Object Type\n");
            return(1);
            }
        }
    else
        {
        if (Status != RPC_S_OK)
            {
            PrintToConsole("Christopher : FAIL - RpcObjectSetType did not");
            PrintToConsole(" fail as expected\n");
            return(1);
            }
        }

    return(0);
}


int
ChristopherObjectInqType (
    IN unsigned short ObjectMagicNumber,
    IN unsigned short TypeMagicNumber,
    IN unsigned int MustFailFlag
    )
/*++

Routine Description:

    This routine calls the RpcObjectInqType routine.  The object uuid
    is generated using the object magic number argument, and the type
    uuid uses the type magic number argument.

Arguments:

    ObjectMagicNumber - Supplies the magic number to be used to generate
        the object uuid to be passed to RpcObjectInqType.

    TypeMagicNumber - Supplies the magic number to use to generate the
        expected type uuid.

    MustFailFlag - Supplies a flag indicating whether or not the call
        to RpcObjectInqType must fail or succeed.  If this flag is
        non-zero, RpcObjectInqType must return RPC_S_OBJECT_NOT_FOUND,
        otherwise the test fails.  If the flag is zero, then
        RpcObjectInqType must succeed.

Return Value:

    Zero will be returned if the test completes successfully; otherise,
    non-zero will be returned.

--*/
{
    UUID ObjectUuid;
    UUID TypeUuid;
    UUID ExpectedTypeUuid;

    GenerateUuidValue(ObjectMagicNumber,&ObjectUuid);
    GenerateUuidValue(TypeMagicNumber,&ExpectedTypeUuid);

    Status = RpcObjectInqType(&ObjectUuid,&TypeUuid);
    if (MustFailFlag == 0)
        {
        if (Status)
            {
            ApiError("Christopher","RpcObjectInqType",Status);
            PrintToConsole("Christopher : FAIL - Can not Inquire");
            PrintToConsole(" Object Type\n");
            return(1);
            }

        if (memcmp(&ExpectedTypeUuid,&TypeUuid,sizeof(UUID)) != 0)
            {
            PrintToConsole("Christopher : FAIL - TypeUuid != ");
            PrintToConsole("ExpectedTypeUuid\n");
            return(1);
            }
        }
    else
        {
        if (Status != RPC_S_OBJECT_NOT_FOUND)
            {
            PrintToConsole("Christopher : FAIL - RpcObjectInqType ");
            PrintToConsole("succeeded\n");
            return(1);
            }
        }

    return(0);
}

static UUID ChristopherObjectUuid;
static UUID ChristopherTypeUuid;


void
ChristopherRpcObjectInqFn (
    IN UUID PAPI * ObjectUuid,
    OUT UUID PAPI * TypeUuid,
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This routine is the object inquiry function we will pass to the
    runtime.  If the object uuid specified is equal to the global
    object uuid, we will return the global type uuid and RPC_S_OK;
    otherwise, we will return RPC_S_OBJECT_NOT_FOUND.

Arguments:

    ObjectUuid - Supplies the object uuid to compare with the global
        object uuid.

    TypeUuid - Returns the type uuid if the object uuid is found.

    Status - Returns the status of the operations.  This will be
        either RPC_S_OK or RPC_S_OBJECT_NOT_FOUND.

--*/
{
    if (memcmp(ObjectUuid,&ChristopherObjectUuid,sizeof(UUID)) != 0)
        {
        *Status = RPC_S_OBJECT_NOT_FOUND;
        return;
        }

    memcpy(TypeUuid,&ChristopherTypeUuid,sizeof(UUID));
    *Status = RPC_S_OK;
    return;
}


int
ChristopherTestObject (
    )
/*++

Routine Description:

    This routine is used by Christopher to test RpcObjectInqType,
    RpcObjectSetInqFn, and RpcObjectSetType.

Return Value:

    Zero will be returned if all of the tests complete successfully,
    otherwise, non-zero will be returned.

--*/
{
    if (ChristopherObjectSetType(12345,2987,0))
        return(1);

    if (ChristopherObjectInqType(12345,2987,0))
        return(1);

    if (ChristopherObjectInqType(5421,2987,1))
        return(1);

    if (ChristopherObjectSetType(12345,2987,1))
        return(1);

    if (ChristopherObjectSetType(12,2987,0))
        return(1);

    if (ChristopherObjectSetType(123,2987,0))
        return(1);

    if (ChristopherObjectSetType(1234,2987,0))
        return(1);

    if (ChristopherObjectInqType(12,2987,0))
        return(1);

    if (ChristopherObjectInqType(123,2987,0))
        return(1);

    if (ChristopherObjectInqType(1234,2987,0))
        return(1);

    if (ChristopherObjectInqType(12345,2987,0))
        return(1);

    if (ChristopherObjectSetNullType(123,0,0))
        return(1);

    if (ChristopherObjectSetNullType(1234,1,0))
        return(1);

    if (ChristopherObjectInqType(123,2987,1))
        return(1);

    if (ChristopherObjectInqType(1234,2987,1))
        return(1);

    if (ChristopherObjectSetNullType(5421,0,1))
        return(1);

    if (ChristopherObjectSetNullType(421,0,1))
        return(1);

    Status = RpcObjectSetInqFn(&ChristopherRpcObjectInqFn);
    if (Status)
        {
        ApiError("Christopher","RpcObjectSetInqFn",Status);
        PrintToConsole("Christopher : FAIL - RpcObjectSetInqFn ");
        PrintToConsole("(ChristopherRpcObjectInqFn)\n");
        return(1);
        }

    GenerateUuidValue(10666,&ChristopherObjectUuid);
    GenerateUuidValue(8466,&ChristopherTypeUuid);

    if (ChristopherObjectInqType(96,2987,1))
        return(1);

    if (ChristopherObjectInqType(10666,8466,0))
        return(1);

    Status = RpcObjectSetInqFn(0);
    if (Status)
        {
        ApiError("Christopher","RpcObjectSetInqFn",Status);
        PrintToConsole("Christopher : FAIL - RpcObjectSetInqFn (0)\n");
        return(1);
        }

    if (ChristopherObjectInqType(10666,8466,1))
        return(1);

    return(0);
}


int
ChristopherTestInquire (
    )
/*++

Routine Description:

    Christopher uses this routine to test RpcServerInqIf and RpcIfInqId.

Return Value:

    Zero will be returned if all of the test successfully pass.  Otherwise,
    non-zero will be returned.

--*/
{
    RPC_IF_ID RpcIfId;
    UUID TypeUuid;
    RPC_MGR_EPV PAPI * ManagerEpv;

    Status = RpcIfInqId((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
        &RpcIfId);
    if (Status)
        {
        ApiError("Christopher","RpcIfInqId",Status);
        PrintToConsole("Christopher : FAIL - Error in RpcIfInqId\n");
        return(1);
        }

    if (   (RpcIfId.VersMajor != 1)
        || (RpcIfId.VersMinor != 1)
        || (RpcIfId.Uuid.Data1 != 9)
        || (RpcIfId.Uuid.Data2 != 8)
        || (RpcIfId.Uuid.Data3 != 8)
        || (RpcIfId.Uuid.Data4[0] != 7)
        || (RpcIfId.Uuid.Data4[1] != 7)
        || (RpcIfId.Uuid.Data4[2] != 7)
        || (RpcIfId.Uuid.Data4[3] != 7)
        || (RpcIfId.Uuid.Data4[4] != 7)
        || (RpcIfId.Uuid.Data4[5] != 7)
        || (RpcIfId.Uuid.Data4[6] != 7)
        || (RpcIfId.Uuid.Data4[7] != 7))
        {
        PrintToConsole("Christopher : FAIL - Wrong RpcIfId\n");
        return(1);
        }

    TypeUuid.Data1 = 0x12345678;
    TypeUuid.Data2 = 0x9ABC;
    TypeUuid.Data3 = 0xDEF0;
    TypeUuid.Data4[0] = 0x12;
    TypeUuid.Data4[1] = 0x34;
    TypeUuid.Data4[2] = 0x56;
    TypeUuid.Data4[3] = 0x78;
    TypeUuid.Data4[4] = 0x9A;
    TypeUuid.Data4[5] = 0xBC;
    TypeUuid.Data4[6] = 0xDE;
    TypeUuid.Data4[7] = 0xF0;

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 38756);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return(1);
        }

    Status = RpcServerInqIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            &TypeUuid,&ManagerEpv);
    if (Status)
        {
        ApiError("Christopher","RpcServerInqIf",Status);
        PrintToConsole("Christopher : FAIL - RpcServerInqIf\n");
        return(1);
        }

    if (ManagerEpv != (RPC_MGR_EPV PAPI *) 38756)
        {
        PrintToConsole("Christopher : FAIL - ManagerEpv != 38756\n");
        return(1);
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Isabelle)\n");
        return(1);
        }

    return(0);
}


void
Christopher (
    )
/*++

Routine Description:

    We verify all server side APIs in this routine.  The idea is to
    emphasize complete coverage, rather than indepth coverage.  Actually,
    by all server side APIs, I really mean all server side APIs except
    for security and name service.  The following list is the APIs
    which will be tested by this routine.

    RpcBindingInqObject [SCONNECTION]
    RpcBindingToStringBinding [SCONNECTION]
    RpcBindingToStringBinding [SVR_BINDING_HANDLE]
    RpcBindingVectorFree
    RpcIfInqId
    RpcNetworkInqProtseqs
    RpcObjectInqType
    RpcObjectSetInqFn
    RpcObjectSetType
    RpcProtseqVectorFree
    RpcServerInqBindings
    RpcServerInqIf
    RpcServerListen
    stub_RegisterIf
    RpcServerUnregisterIf
    RpcServerUseAllProtseqs
    RpcServerUseAllProtseqsIf
    RpcServerUseProtseq
    RpcServerUseProtseqEpWrapper
    RpcServerUseProtseqIf
    RpcMgmtStopServerListening
    RpcMgmtInqIfIds
    RpcIfIdVectorFree

--*/
{
    RPC_PROTSEQ_VECTORA * RpcProtseqVector;
    unsigned int Index;
    UUID TypeUuid;
    UUID ObjectUuid;
    RPC_IF_ID_VECTOR * InterfaceIdVector;
    unsigned char * String;

    PrintToConsole("Christopher : Verify All Server APIs\n");

    Status = RpcNetworkInqProtseqsA(&RpcProtseqVector);
    if (Status)
        {
        ApiError("Christopher","RpcNetworkInqProtseqs",Status);
        PrintToConsole("Christopher : FAIL - RpcNetworkInqProtseqs\n");
        return;
        }

    PrintToConsole("Christopher : (RpcNetworkInqProtseqs)\n");
    for (Index = 0; Index < RpcProtseqVector->Count; Index++)
        {
        PrintToConsole("    ");
        PrintToConsole((char *) RpcProtseqVector->Protseq[Index]);
        PrintToConsole("\n");
        }

    Status = RpcProtseqVectorFreeA(&RpcProtseqVector);
    if (Status)
        {
        ApiError("Christopher","RpcProtseqVectorFree",Status);
        PrintToConsole("Christopher : FAIL - RpcProtseqVectorFree\n");
        return;
        }

    Status = RpcProtseqVectorFreeA(&RpcProtseqVector);
    if (Status)
        {
        ApiError("Christopher","RpcProtseqVectorFree",Status);
        PrintToConsole("Christopher : FAIL - RpcProtseqVectorFree\n");
        return;
        }

    ChristopherIsabelleError = 0;

    // This routine will test RpcServerInqIf and RpcIfInqId for us.

    if (ChristopherTestInquire() != 0)
        return;

    // We test RpcObjectInqType, RpcObjectSetInqFn, and RpcObjectSetType
    // in this routine.

    if (ChristopherTestObject() != 0)
        return;

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHER), 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use Protseq ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHER), 0);
    if (Status != RPC_S_DUPLICATE_ENDPOINT)
        {
        ApiError("Christopher","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Christopher : FAIL - Able to Add Duplicate ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // added for synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    GenerateUuidValue(3010, &TypeUuid);
    Status = RpcObjectSetType(&ObjectUuid, &TypeUuid);
    if (Status)
        {
        ApiError("Christopher","RpcObjectSetType",Status);
        PrintToConsole("Christopher : FAIL - Unable to Set Object Type\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 9814);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 9814);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseAllProtseqsIfWrapper(1,
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseAllProtseqsIfWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use All Protseqs ");
        PrintToConsole("from Interface\n");
        return;
        }

    Status = RpcServerUseProtseqIfWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseProtseqIfWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use Protseq From ");
        PrintToConsole("Interface\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 9814);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    if (AutoListenFlag == 0)
        {
        Status = stub_ServerListen(123, 122, 0);
        if ( Status != RPC_S_MAX_CALLS_TOO_SMALL )
            {
            ApiError("Christopher", "stub_ServerListen", Status);
            PrintToConsole("Christopher : FAIL - stub_ServerListen\n");
            return;
            }
        }

    PrintToConsole("Christopher : Start Listening\n") ;
    HelgaManagerEpv = (RPC_MGR_EPV PAPI *) 9814;
    HelgaCheckManagerEpv = 1;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    HelgaCheckManagerEpv = 0;
    if (Status)
        {
        ApiError("Christopher","stub_ServerListen",Status);
        PrintToConsole("Christopher : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (ChristopherIsabelleError != 0)
        {
        ChristopherIsabelleError = 0;
        return;
        }

    Status = RpcMgmtInqIfIds(0, &InterfaceIdVector);
    if ( Status != RPC_S_OK )
        {
        ApiError("Christopher", "RpcMgmtInqIfIds", Status);
        PrintToConsole("Christopher : FAIL - Unable to Inquire Interface Ids\n");
        return;
        }

    for (Index = 0; Index < InterfaceIdVector->Count; Index++)
        {
        PrintToConsole("    ");
        UuidToStringA(&(InterfaceIdVector->IfId[Index]->Uuid), &String);
        PrintToConsole((char *) String);
        RpcStringFreeA(&String);
        PrintToConsole(" %d.%d\n", InterfaceIdVector->IfId[Index]->VersMajor,
                InterfaceIdVector->IfId[Index]->VersMinor);
        }

    Status = RpcIfIdVectorFree(&InterfaceIdVector);
    if (   ( Status != RPC_S_OK )
        || ( InterfaceIdVector != 0 ) )
        {
        ApiError("Christopher", "RpcIfIdVectorFree", Status);
        PrintToConsole("Christopher : FAIL - Unable to Free IfIdVector\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Christopher : FAIL - Error(s) in Helga");
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 1);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Helga)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Christopher : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 1);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Isabelle)\n");
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Christopher : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 1);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Sylvia)\n");
        return;
        }

    Status = RpcServerUseProtseqWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseProtseq",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use Protseq\n");
        return;
        }

    Status = RpcServerUseAllProtseqsWrapper(1, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseAllProtseqsWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use All Protseqs\n");
        return;
        }

    if (InquireBindings("Christopher") != 0)
        return;

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHERMUSTFAILONE), 0);
    if (Status != RPC_S_INVALID_ENDPOINT_FORMAT)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_INVALID_ENDPOINT_FORMAT");
        PrintToConsole(" (ChristopherMustFailOne)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHERMUSTFAILTWO), 0);
    if (Status != RPC_S_INVALID_ENDPOINT_FORMAT)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_INVALID_ENDPOINT_FORMAT");
        PrintToConsole(" (ChristopherMustFailTwo)\n");
        return;
        }

// SkipInvalidEndpointFormat:

    Status = RpcServerUseProtseqEpWrapper((unsigned char *) "ncacn_bad",
            MAX_CALL_REQUESTS, GetEndpoint(CHRISTOPHERMUSTFAILONE), 0);
    if (Status != RPC_S_PROTSEQ_NOT_SUPPORTED)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_PROTSEQ_NOT_SUPPORTED (ncacn_bad)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper((unsigned char *) "mkm_np",
            MAX_CALL_REQUESTS, GetEndpoint(CHRISTOPHERMUSTFAILONE), 0);
    if (Status != RPC_S_PROTSEQ_NOT_SUPPORTED)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_PROTSEQ_NOT_SUPPORTED (bad_np)\n");
        return;
        }

    PrintToConsole("Christopher : PASS\n");
}


void
David (
    )
/*++

Routine Description:

    This routine is used to test association context rundown support;
    it works with Daniel in uclnt.exe.

--*/
{
    PrintToConsole("David : Association Context and Rundown\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(DAVIDFIRST), 0);
    if (Status)
        {
        ApiError("David","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("David : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(DAVIDSECOND), 0);
    if (Status)
        {
        ApiError("David","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("David : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("David","stub_RegisterIf",Status);
        PrintToConsole("David : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("David","stub_RegisterIf",Status);
        PrintToConsole("David : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("David: Start Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("David","stub_ServerListen",Status);
        PrintToConsole("David : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("David : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("David","RpcServerUnregisterIf",Status);
        PrintToConsole("David : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // we don't unregister helga, as a method of isabelle should have
    // been called to do that

    PrintToConsole("David : PASS\n");
}


void
Tyler ( // Perform security tests.  This particular test works with
        // Thomas which lives in uclnt.cxx.
    )
/*++

Routine Description:

    Tyler works with Thomas, which lives in uclnt.exe, to perform build
    verification tests of security.

--*/
{
    SECURITY_DESCRIPTOR sd, *psd;

    PrintToConsole("Tyler : Test Security\n");

    if (TransportType == RPC_LRPC)
        {
        // ncalrpc needs a security descriptor.

        psd = &sd;

        InitializeSecurityDescriptor(
                        psd,
                        SECURITY_DESCRIPTOR_REVISION
                        );

        if ( FALSE == SetSecurityDescriptorDacl (
                            psd,
                            TRUE,                 // Dacl present
                            NULL,                 // NULL Dacl
                            FALSE                 // Not defaulted
                            ) )
            {
            ApiError("Tyler","SetSecurityDescriptorDacl",0);
            return;
            }
        }
    else
        {
        psd = 0;
        }


    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(TYLER), psd);
    if (Status)
        {
        ApiError("Tyler","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Tyler : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Tyler","stub_RegisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Tyler","stub_RegisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = RpcServerRegisterAuthInfoA((unsigned char PAPI *)
            "ServerPrincipal", ulSecurityPackage, 0, 0); //hack
    if (Status)
        {
        ApiError("Tyler", "RpcServerRegisterAuthInfo", Status);
        PrintToConsole("Tyler : FAIL - Unable to Register AuthInfo\n");
        return;
        }

    PrintToConsole("Tyler : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Tyler","stub_ServerListen",Status);
        PrintToConsole("Tyler : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Tyler : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Tyler : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Tyler","RpcServerUnregisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Tyler","RpcServerUnregisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Tyler : PASS\n");
}


void
Terry ( // Perform security tests.  This particular test works with
        // Tim which lives in uclnt.cxx.
    )
/*++

Routine Description:

    Terry works with Tim, which lives in uclnt.exe, to perform build
    verification tests of NT security.

--*/
{
    PrintToConsole("Terry : Test Security\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(TYLER), 0);
    if (Status)
        {
        ApiError("Terry","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Terry : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Terry","stub_RegisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Terry","stub_RegisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = RpcServerRegisterAuthInfoA((unsigned char PAPI *)
            "ServerPrincipal", ulSecurityPackage, 0, 0);
    if (Status)
        {
        ApiError("Terry", "RpcServerRegisterAuthInfo", Status);
        PrintToConsole("Terry : FAIL - Unable to Register AuthInfo\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Terry","stub_ServerListen",Status);
        PrintToConsole("Terry : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Terry : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Terry : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Terry","RpcServerUnregisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Terry","RpcServerUnregisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Terry : PASS\n");
}


void
RichardHelper (
    )
/*++

Routine Description:

    This routine will be used as a helper by Richard.  The description
    of Richard will explain how it is used.

--*/
{

    PrintToConsole("Richard : RichardHelper Executed\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(RICHARDHELPER), 0);
    if (Status)
        {
        ApiError("RichardHelper", "RpcServerUseProtseqEpWrapper", Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Use Protseq ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("RichardHelper","stub_RegisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("RichardHelper","stub_RegisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("RichardHelper","stub_ServerListen",Status);
        PrintToConsole("RichardHelper : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("RichardHelper : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("RichardHelper","RpcServerUnregisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Isabelle)\n");
        return;
        }

   Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("RichardHelper","RpcServerUnregisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Helga)\n");
        return;
        }
}


void
Richard (
    )
/*++

Description:

    Richard works with Robert (in uclnt.cxx) to test call and callback
    failures.  In particular, we want to test that a call failing does
    not invalidate the binding handle.  We will do this using the
    RichardHelper routine.

--*/
{
    PrintToConsole("Richard : Test Call and Callback Failures\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(RICHARD), 0);
    if (Status)
        {
        ApiError("Richard","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Richard : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Richard","stub_RegisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Richard","stub_RegisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }


    PrintToConsole("Richard : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Richard","stub_ServerListen",Status);
        PrintToConsole("Richard : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Richard : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Richard","RpcServerUnregisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Richard","RpcServerUnregisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Richard : PASS\n");
}

void
Kenneth (
    )
/*++

Description:

    Kenneth works with Keith (in uclnt.cxx) to auto reconnect.

--*/
{
    PrintToConsole("Kenneth : Test Auto Reconnect\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(KENNETH), 0);
    if (Status)
        {
        ApiError("Kenneth","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Kenneth","stub_RegisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Kenneth","stub_RegisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Kenneth : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Kenneth","stub_ServerListen",Status);
        PrintToConsole("Kenneth : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Kenneth : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Kenneth","RpcServerUnregisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // synchro support
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Kenneth","RpcServerUnregisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Kenneth : PASS\n");
}


void
BartholomewHelper (
    )
/*++

Routine Description:

    Bartholomew will use this routine to help with testing resolving
    endpoints.  We just need to use some protocol sequences and then
    register with the endpoint mapper before returning (and exiting).

--*/
{
    PrintToConsole("Bartholomew : BartholomewHelper Executed\n");

    Status = RpcServerUseAllProtseqsWrapper(1, 0);
    if (Status)
        {
        ApiError("BartholomewHelper","RpcServerUseAllProtseqsWrapper",Status);
        PrintToConsole("BartholomewHelper : FAIL - Unable to Use All Protseqs\n");
        return;
        }

    Status = RpcServerInqBindings(&BartholomewRpcBindingVector);
    if (Status)
        {
        ApiError("BartholomewHelper", "RpcServerInqBindings", Status);
        PrintToConsole("BartholomewHelper : FAIL - RpcServerInqBindings\n");
        return;
        }

    Status = RpcEpRegisterA((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            BartholomewRpcBindingVector, 0,
            (unsigned char PAPI *) "usvr.exe");
    if (Status)
        {
        ApiError("BartholomewHelper", "RpcEpRegister", Status);
        PrintToConsole("BartholomewHelper : FAIL - RpcEpRegister Failed\n");
        return;
        }

    Status = RpcEpRegisterNoReplaceA(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            BartholomewRpcBindingVector, 0,
            (unsigned char PAPI *) "usvr.exe");
    if (Status)
        {
        ApiError("BartholomewHelper", "RpcEpRegisterNoReplace", Status);
        PrintToConsole("BartholomewHelper : FAIL - RpcEpRegister Failed\n");
        return;
        }

    PrintToConsole("Bartholomew : BartholomewHelper Exiting\n");
}


void
Bartholomew (
    )
/*++

Routine Description:

    This routine works with Benjamin in uclnt.exe to test that dynamic
    endpoints work.  What we actually do is inquire all bindings supported
    by this server, and then have the client bind to each of them, and
    make a call.

--*/
{
    PrintToConsole("Bartholomew : Test Dynamic Endpoints\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(BARTHOLOMEW), 0);
    if (Status)
        {
        ApiError("Bartholomew", "RpcServerUseProtseqEpWrapper", Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Use Protseq ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_RegisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_RegisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_RegisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = RpcServerUseProtseqWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUseProtseq",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Use Protseq\n");
        return;
        }

    Status = RpcServerUseAllProtseqsWrapper(1, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUseAllProtseqsWrapper",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Use All Protseqs\n");
        return;
        }

    if ( InquireBindings("Bartholomew") != 0 )
        {
        return;
        }

    Status = RpcServerInqBindings(&BartholomewRpcBindingVector);
    if (Status)
        {
        ApiError("Bartholomew", "RpcServerInqBindings", Status);
        PrintToConsole("Bartholomew : FAIL - RpcServerInqBindings\n");
        return;
        }

    BartholomewIndex = 0;

    if ( UseEndpointMapperFlag != 0 )
        {
        Status = RpcEpRegisterA((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
                BartholomewRpcBindingVector, 0,
                (unsigned char PAPI *) "usvr.exe");
        if (Status)
            {
            ApiError("Bartholomew", "RpcEpRegister", Status);
            PrintToConsole("Bartholomew : FAIL - RpcEpRegister Failed\n");
            return;
            }

        Status = RpcEpRegisterNoReplaceA(
                (RPC_IF_HANDLE) &SylviaInterfaceInformation,
                BartholomewRpcBindingVector, 0,
                (unsigned char PAPI *) "usvr.exe");
        if (Status)
            {
            ApiError("Bartholomew", "RpcEpRegisterNoReplace", Status);
            PrintToConsole("Bartholomew : FAIL - RpcEpRegister Failed\n");
            return;
            }

#ifdef WIN32RPC

        PROCESS_INFORMATION ProcessInformation;
        STARTUPINFOA StartupInfo;

        StartupInfo.cb = sizeof(STARTUPINFOA);
        StartupInfo.lpReserved = 0;
        StartupInfo.lpDesktop = 0;
        StartupInfo.lpTitle = 0;
        StartupInfo.dwX = 0;
        StartupInfo.dwY = 0;
        StartupInfo.dwXSize = 0;
        StartupInfo.dwYSize = 0;
        StartupInfo.dwFlags = 0;
        StartupInfo.wShowWindow = 0;
        StartupInfo.cbReserved2 = 0;
        StartupInfo.lpReserved2 = 0;

        char CommandLine[200];

        strcpy(CommandLine, "usvr ");
        strcat(CommandLine, TransportOption);

        strcat(CommandLine, " -bartholomewhelper");

        if (CreateProcessA(0, CommandLine, 0, 0, FALSE,
                0, 0, 0, &StartupInfo, &ProcessInformation) == FALSE)
            {
            OtherError("Bartholomew","CreateProcessA Failed");
            PrintToConsole("Bartholomew : FAIL - CreateProcess Failed\n");
            return;
            }

#endif // WIN32RPC

        PauseExecution(2000L);
        }

    PrintToConsole("Bartholomew : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_ServerListen",Status);
        PrintToConsole("Bartholomew : FAIL - stub_ServerListen Failed\n");
        return;
        }

    Status = RpcBindingVectorFree(&BartholomewRpcBindingVector);
    if (Status)
        {
        ApiError("Bartholomew", "RpcBindingVectorFree", Status);
        PrintToConsole("Bartholomew : FAIL - RpcBindingVectorFree\n");
        return;
        }

    if (BartholomewRpcBindingVector != 0)
        {
        PrintToConsole("Bartholomew : FAIL - ");
        PrintToConsole("BartholomewRpcBindingVector != 0\n");
        return;
        }

    // Synchro support
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUnregisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Helga)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Bartholomew : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUnregisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Isabelle)\n");
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Bartholomew : FAIL - Error(s) in Sylvia");
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUnregisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Sylvia)\n");
        return;
        }

    PrintToConsole("Bartholomew : PASS\n");
}

void
TestYield (
    )
/*++

Routine Description:

    This routine works with Harold in uclnt.exe to test that idle
    connections get cleaned up properly, and that context is maintained.

--*/
{
    PrintToConsole("TestYeild : Test Yielding\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(TESTYIELD), 0);
    if (Status)
        {
        ApiError("TestYield","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("TestYield: FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("TestYield","stub_RegisterIf",Status);
        PrintToConsole("TestYield: FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("TestYield","stub_ServerListen",Status);
        PrintToConsole("TestYield: FAIL - stub_ServerListen Failed\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUnregisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("TestYield: PASS\n");
}


void
Herman (
    )
/*++

Routine Description:

    This routine works with Harold in uclnt.exe to test that idle
    connections get cleaned up properly, and that context is maintained.

--*/
{
    PrintToConsole("Herman : Test Idle Connection Cleanup and Context\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(HERMAN), 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Herman : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Herman","stub_RegisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Herman","stub_RegisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Herman","stub_ServerListen",Status);
        PrintToConsole("Herman : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Herman : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUnregisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUnregisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Herman : PASS\n");
}


void
Ivan (
    )
/*++

Routine Description:

    This routine stress tests the runtime.  It works with Isaac in uclnt.exe.

--*/
{
    PrintToConsole("Ivan : Stress Test\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(IVAN), 0);
    if (Status)
        {
        ApiError("Ivan","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Ivan : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Ivan","stub_RegisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Ivan","stub_RegisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Ivan","stub_ServerListen",Status);
        PrintToConsole("Ivan : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Ivan : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Ivan","RpcServerUnregisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Ivan : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Ivan","RpcServerUnregisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Ivan : PASS\n");
}


void
Jason (
    )
/*++

Routine Description:

    This routine helps perform performance tests of the runtime.  It works
    with James in uclnt.exe.

--*/
{
    PrintToConsole("Jason : Timing Tests With %d Listen Threads\n",
            MinimumListenThreads);

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(JASON), 0);
    if (Status)
        {
        ApiError("Jason","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Jason : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Jason","stub_RegisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Jason","stub_RegisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Jason","stub_ServerListen",Status);
        PrintToConsole("Jason : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Jason : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Jason","RpcServerUnregisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Jason : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Jason","RpcServerUnregisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Jason : PASS\n");
}

void
WaitForAddressListChange (
    IN void *Ignore
    )
{
    OVERLAPPED ol;
    SOCKET sock;
    HANDLE hEvent;
    SOCKADDR_IN sockaddr;
    DWORD           byteRet;

    hEvent = CreateEvent(0, FALSE, FALSE, 0);
    if (hEvent == 0)
        {
        ApiError("WaitForAddressListChange", "CreateEventW", 0);
        return ;
        }

    sock = WSASocket(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);
    if (sock == INVALID_SOCKET)
        {
        ApiError("WaitForAddressListChange", "WSASocketW", GetLastError());
        return;
        }

    sockaddr.sin_addr.s_addr = INADDR_ANY;
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = 0;

    if (bind(sock,(struct sockaddr *) &sockaddr, sizeof(SOCKADDR_IN)))
        {
        closesocket(sock);
        return;
        }

    if(listen(sock, 10) == SOCKET_ERROR)
        {
        closesocket(sock);
        return;
        }

    while (1)
        {
        ol.hEvent = hEvent;
        ol.Offset = 0;
        ol.OffsetHigh = 0;

        if (WSAIoctl(sock,
                     SIO_ADDRESS_LIST_CHANGE,
                     0, 0, 0, 0, &byteRet, &ol, 0) == SOCKET_ERROR)
            {
            if (WSAGetLastError() != ERROR_IO_PENDING)
                {
                ApiError("WaitForAddressListChange", "DeviceIoControl",
                         GetLastError());
                return;
                }

            //
            // Wait for the IO to complete
            //
            WaitForSingleObject(hEvent,INFINITE);
            }
        //
        // figure out the new address list
        //

        //
        // First find out how big a buffer do we need.
        //
        byteRet = 0;
        if (WSAIoctl(sock,
                    SIO_ADDRESS_LIST_QUERY,
                    0, 0, 0, 0, &byteRet, NULL, NULL) == 0)
            {
            I_RpcRequestMutex(&PrintMutex);
            PrintToConsole("The Address list has changed, it is now empty\n");
            I_RpcClearMutex(PrintMutex);
            continue;
            }
        else
            {
            if (WSAGetLastError() != WSAEFAULT || byteRet == 0 )
                {
                ApiError("WaitForAddressListChange", "SIO_ADDRESS_LIST_QUERY",
                         WSAGetLastError());
                return;
                }
            }

        LPSOCKET_ADDRESS_LIST  interfaceList =
            (LPSOCKET_ADDRESS_LIST) I_RpcAllocate(byteRet);
        if( interfaceList == NULL )
            {
            ApiError("WaitForAddressListChange", "I_RpcAllocate", 0);
            return;
            }


        if (WSAIoctl(sock,
                    SIO_ADDRESS_LIST_QUERY,
                    0, 0, interfaceList, byteRet,&byteRet,NULL, NULL) != ERROR_SUCCESS)
            {
            ApiError("WaitForAddressListChange", "SIO_ADDRESS_LIST_QUERY",
                     WSAGetLastError());
            return;
            }

        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("The Address list has changed:\n");
        int i;
        for (i = 0; i < interfaceList->iAddressCount; i++)
            {
            PrintToConsole("AF: %d, Address: ",
                           interfaceList->Address[i].lpSockaddr->sa_family);
            int j;
            for (j = 0; j<14; j++)
                {
                PrintToConsole("%u ",
                               (unsigned char) interfaceList->Address[i].lpSockaddr->sa_data[j]);
                }
            PrintToConsole("\n");
            }
        PrintToConsole("\n");
        I_RpcClearMutex(PrintMutex);
        }


}
static unsigned long DefaultThreadStackSize = 0;

int
TestPNP (
    )
{
    unsigned long ThreadIdentifier;
    HANDLE NotificationHandle = 0;
    WSAOVERLAPPED Overlapped;
    unsigned long bytes;
    HANDLE hEvent;
    WSADATA data;
    int retval ;

    if (WSAStartup(2, &data) != NO_ERROR)
        {
        return -1;
        }

    //
    // Create another thread to go off and wait on address list
    // changes
    //
    if (CreateThread(0,
                     DefaultThreadStackSize,
                     (LPTHREAD_START_ROUTINE) WaitForAddressListChange,
                     0,
                     0,
                     &ThreadIdentifier) == 0)
        {
        ApiError("TestPNP", "CreateThread", GetLastError());
        return -1;
        }

    hEvent = CreateEvent(0, FALSE, FALSE, 0);
    if (hEvent == 0)
        {
        ApiError("TestPNP", "CreateEventW", 0);
        return -1;
        }

    retval = WSAProviderConfigChange(
                    &NotificationHandle,
                    &Overlapped,
                    0
                    );

    if (retval != 0 || NotificationHandle == 0)
        {
        ApiError("TestPNP", "WSAProviderConfigChange", retval);
        return -1;
        }

    while (1)
        {
        Overlapped.hEvent = hEvent;
        Overlapped.Offset = 0;
        Overlapped.OffsetHigh = 0;

        retval = WSAProviderConfigChange(
                        &NotificationHandle,
                        &Overlapped,
                        0
                        );

        if (retval != 0)
            {
            if (GetLastError() == WSA_IO_PENDING)
                {
                WaitForSingleObject(hEvent,INFINITE);
                }
            else
                {
                ApiError("TestPNP", "WSAProviderConfigChange", retval);
                return -1;
                }
            }

        WSAPROTOCOL_INFO *lpProtocolBuffer;
        DWORD dwBufferLength = 1;
        int ProtocolCount;

        while (1)
            {
            lpProtocolBuffer = (WSAPROTOCOL_INFO *) I_RpcAllocate(dwBufferLength);
            if (lpProtocolBuffer == 0)
                {
                ApiError("TestPNP", "I_RpcAllocate", 0);
                return -1;
                }

            ProtocolCount = WSAEnumProtocols(
                                      0,
                                      lpProtocolBuffer,
                                      &dwBufferLength
                                      );
            if (ProtocolCount != SOCKET_ERROR)
                {
                break;
                }

            I_RpcFree(lpProtocolBuffer);

            if (GetLastError() != WSAENOBUFS)
                {
                return -1;
                }
            }

        int i;
        //
        // take the print mutex for the entire output, so we don't
        // garble it with the other thread
        //
        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("LoadedProtocols:\n");
        for (i = 0; i < ProtocolCount; i++)
            {
            PrintToConsole("SocketType: %d, Protocol:%d, Address Family: %d\n",
                           lpProtocolBuffer[i].iSocketType,
                           lpProtocolBuffer[i].iProtocol,
                           lpProtocolBuffer[i].iAddressFamily);

            }
        PrintToConsole("\n");
        I_RpcClearMutex(PrintMutex);
        }
}

void
RpcYield()
{
    RpcServerYield();
}

void FireWall (
    )
{
    PMIB_IFTABLE pMib;
    DWORD Size = 20*sizeof(MIB_IFROW)+sizeof(DWORD);
    UINT i, j;

    for (i = 0; i < 2; i++)
        {
        pMib = (PMIB_IFTABLE) I_RpcAllocate(Size);
        if (pMib == 0)
            {
            return;
            }

        RpcpMemorySet(pMib, 0, Size);

        Status = GetIfTable(pMib, &Size, 0);
        if (Status == 0)
            {
            break;
            }
        }

    if (Status != RPC_S_OK)
        {
        return;
        }

    for (i = 1; i < pMib->dwNumEntries+1; i++)
        {
        for (j = 0; j < pMib->dwNumEntries; j++)
            {
            if (pMib->table[j].dwIndex == i)
                {
                PrintToConsole("IF[%d]: Ethernet: %s\n", i,
                               (char *) pMib->table[j].bDescr);
                break;
                }
            }
        }
}


extern void
Async (
    ) ;

int __cdecl
main (
    int argc,
    char * argv[]
    )

/*
Transports:

    Update this to add a new transport.
*/

{
    int argscan, testflag = 0;
    RPC_STATS_VECTOR * Statistics;
    char *option ;

    TransportType = RPC_TRANSPORT_NAMEPIPE;

    for (argscan = 1; argscan < argc; argscan++)
        {
        if (strcmp(argv[argscan], "-p") == 0)
        {
            ulSecurityPackage = (unsigned long) atol(argv[argscan+1]);
            argscan++;
        }
        else if (strcmp(argv[argscan],"-warn") == 0)
            WarnFlag = 1;
        else if (strcmp(argv[argscan],"-error") == 0)
            ErrorFlag = 1;
        else if (strcmp(argv[argscan],"-v") == 0)
            Verbose = 1;
        else if (strcmp(argv[argscan],"-verbose") == 0)
            Verbose = 1;
        else if (strcmp(argv[argscan],"-rpcss") == 0)
            {
            UseEndpointMapperFlag = 1;
            }
        else if (strcmp(argv[argscan],"-nosecuritytests") == 0)
            {
            NoSecurityTests = 1;
            }
        else if (strcmp(argv[argscan],"-sigfried") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Sigfried();
           }
       else if (strcmp(argv[argscan],"-hybrid") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime Hybrid Server Test\n");
           Hybrid();
           }
       else if (strcmp(argv[argscan],"-lpcsecurity") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime Lpc Security Test\n");
           LpcSecurity();
           }
       else if (strcmp(argv[argscan],"-objuuid") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Obj Uuid test\n");
           TestObjectUuids();
           }
       else if (strcmp(argv[argscan],"-connid") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Conn Id test\n");
           TestObjectUuids();
           }
       else if (strcmp(argv[argscan],"-async") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime Async RPC Tests\n");
           Async();
           }
       else if (strcmp(argv[argscan],"-ee") == 0)
           {
           PrintToConsole("enabling extended errors\n");
           fExtendedError = TRUE;
           }
       else if (strcmp(argv[argscan],"-dgtransport") == 0)
           {
           testflag = 1;
           PrintToConsole("datagram transport tests \n");
           DgTransport();
           }
       else if (strcmp(argv[argscan],"-sendack") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime datagram delayed-ack Tests\n");
           SendAck();
           }
       else if (strcmp(argv[argscan],"-securityerror") == 0)
           {
           int testnum;

           testflag = 1;
           PrintToConsole("security provider error tests \n");

           argscan++ ;

           if (argscan == argc)
               {
               PrintToConsole("-securityerror: you must specify a test #, or zero for all, or '?' for help\n");
               return 1;
               }

           if (strcmp(argv[argscan], "?") == 0)
               {
               testnum = 100 ;
               }
           else
               {
               testnum = atoi(argv[argscan]) ;
               }
           SecurityErrorWrapper(testnum);
           }
        else if (strcmp(argv[argscan],"-grant") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Grant();
            }
        else if (strcmp(argv[argscan],"-elliot") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Elliot();
            }
        else if (strcmp(argv[argscan],"-andromida") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Andromida();
            }
        else if (strcmp(argv[argscan],"-fredrick") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Fredrick();
            }
        else if (strcmp(argv[argscan],"-christopher") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Christopher();
            }
        else if (strcmp(argv[argscan],"-david") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            David();
            }
        else if (strcmp(argv[argscan],"-tyler") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Tyler();
            }
        else if (strcmp(argv[argscan],"-terry") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Terry();
            }
        else if (strcmp(argv[argscan],"-richardhelper") == 0)
            {
            testflag = 1;
            RichardHelper();
            return(0);
            }
        else if (strcmp(argv[argscan],"-bartholomewhelper") == 0)
            {
            testflag = 1;
            BartholomewHelper();
            return(0);
            }
        else if (strcmp(argv[argscan],"-richard") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Richard();
            }
        else if (strcmp(argv[argscan],"-bartholomew") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Bartholomew();
            }
        else if (strcmp(argv[argscan],"-herman") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Herman();
            }
        else if (strcmp(argv[argscan],"-ivan") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Ivan();
            }
        else if (strcmp(argv[argscan],"-jason") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Jason();
            }
        else if (strcmp(argv[argscan],"-kenneth") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Kenneth();
            }
        else if (strcmp(argv[argscan],"-pipe") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            SPipe();
            }
        else if (strcmp(argv[argscan],"-testyield") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            TestYield();
            }
        else if (strcmp(argv[argscan],"-yield") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            RpcYield();
            }
        else if (strcmp(argv[argscan],"-pnp") == 0)
            {
            testflag = 1;
            PrintToConsole("Test PNP stuff\n");
            TestPNP();
            }
        else if (strcmp(argv[argscan],"-namepipe") == 0)
            {
            TransportType = RPC_TRANSPORT_NAMEPIPE;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-lrpc") == 0)
            {
            TransportType = RPC_LRPC;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-tcp") == 0)
            {
            TransportType = RPC_TRANSPORT_TCP;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-udp") == 0)
            {
            DatagramFlag = 1;
            TransportType = RPC_TRANSPORT_UDP;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-dnet") == 0)
            {
            TransportType = RPC_TRANSPORT_DNET;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-spx") == 0)
            {
            TransportType = RPC_TRANSPORT_SPX;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-ipx") == 0)
            {
            DatagramFlag = 1;
            TransportType = RPC_TRANSPORT_IPX;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-vns") == 0)
            {
            TransportType = RPC_TRANSPORT_VNS;
            TransportOption = argv[argscan];
            }

        else if (strcmp(argv[argscan], "-dsp") == 0)
            {
            TransportType = RPC_TRANSPORT_DSP ;
            TransportOption = argv[argscan] ;
            }

        else if (strcmp(argv[argscan], "-msmq") == 0)
            {
            DatagramFlag = 1;
            TransportType = RPC_TRANSPORT_MSMQ ;
            TransportOption = argv[argscan] ;
            }

        else if (strcmp(argv[argscan], "-autolisten") == 0)
            {
            AutoListenFlag = 1 ;
            }
        else if (strcmp(argv[argscan], "-ifsecurity") == 0)
            {
            IFSecurity = 1;
            }
        else if (strcmp(argv[argscan], "-firewall") == 0)
            {
            testflag = 1;
            FireWallFlag = 1 ;
            FireWall();
            }

        else if (strcmp(argv[argscan],"-protocol") == 0)
            {
            strcpy(NetBiosProtocol+sizeof("ncacn_nb_")-1, argv[argscan+1]);
            argscan++;
            }
        else if (strcmp(argv[argscan],"-netbios") == 0)
            {
            TransportType = RPC_TRANSPORT_NETBIOS;
            TransportOption = argv[argscan];
            }
        else if (strncmp(argv[argscan], "-listen:", strlen("-listen:"))
                    == 0 )
            {
            MinimumListenThreads = atoi(argv[argscan] + strlen("-listen:"));
            if ( MinimumListenThreads == 0 )
                {
                MinimumListenThreads = 1;
                }
            }
        else if (strncmp(argv[argscan], "-rpcsize:", strlen("-rpcsize:"))
                    == 0 )
            {
            MaxRpcSize = atoi(argv[argscan] + strlen("-rpcsize:"));
            }
        else if (argv[argscan][0] == '-')
            {
            PrintToConsole("unknown option '%s'\n", argv[argscan]);
            return 1;
            }
        else
            {
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            PrintToConsole("Usage : usvr\n");
            PrintToConsole("        -warn : turn on warning messages\n");
            PrintToConsole("        -error : turn on error messages\n");
            PrintToConsole("        -sigfried\n");
            PrintToConsole("        -grant\n");
            PrintToConsole("        -elliot\n");
            PrintToConsole("        -andromida\n");
            PrintToConsole("        -fredrick\n");
            PrintToConsole("        -christopher\n");
            PrintToConsole("        -david\n");
            PrintToConsole("        -tyler\n");
            PrintToConsole("        -terry\n");
            PrintToConsole("        -richard\n");
            PrintToConsole("        -bartholomew\n");
            PrintToConsole("        -herman\n");
            PrintToConsole("        -ivan\n");
            PrintToConsole("        -jason\n");
            PrintToConsole("        -kenneth\n");
            PrintToConsole("        -namepipe\n");
            PrintToConsole("        -lrpc\n");
            PrintToConsole("        -tcp\n");
            PrintToConsole("        -udp\n");
            PrintToConsole("        -dnet\n");
            PrintToConsole("        -netbios\n");
            PrintToConsole("        -spx\n");
            PrintToConsole("        -dsp\n") ;
            PrintToConsole("        -vns\n") ;
            PrintToConsole("        -msmq\n") ;
            PrintToConsole("        -listen:<listen threads>\n");
            PrintToConsole("        -rpcss\n");
            PrintToConsole("        -p <security provider #>\n");
            PrintToConsole("        -nosecuritytests") ;
            return(1);
            }
        }


    if (!testflag)
        {
        PrintToConsole("RPC Runtime Server Build Verification Test\n");
    PrintToConsole("Sigfried\n") ;
        Sigfried();
    PrintToConsole("Grant\n") ;
        Grant();
    PrintToConsole("Elliot\n") ;
        Elliot();
    PrintToConsole("Andromida\n") ;
        Andromida();
    PrintToConsole("Fredrick\n") ;
        Fredrick();
    PrintToConsole("Christopher\n") ;
        Christopher();
    PrintToConsole("David\n") ;
        David();
        if ( NoSecurityTests == 0)
            {
        PrintToConsole("Tyler\n") ;
            Tyler();
            }
        if ( TransportType != RPC_LRPC )
            {
        PrintToConsole("Richard\n") ;
            Richard();
            }
    PrintToConsole("Kenneth\n") ;
        Kenneth();
    PrintToConsole("Bartholomew\n") ;
        Bartholomew();
    PrintToConsole("Async\n") ;
        Async();
        }

    Status = RpcMgmtInqStats(0,&Statistics);
    if (Status)
        {
        ApiError("main", "RpcMgmtInqStats", Status);
        return(0);
        }

    PrintToConsole("\nCalls (and Callbacks) Received : %lu",
            Statistics->Stats[RPC_C_STATS_CALLS_IN]);
    PrintToConsole("\nCallbacks Sent : %lu",
            Statistics->Stats[RPC_C_STATS_CALLS_OUT]);
    PrintToConsole("\nPackets Received : %lu\nPackets Sent : %lu\n",
            Statistics->Stats[RPC_C_STATS_PKTS_IN],
            Statistics->Stats[RPC_C_STATS_PKTS_OUT]);

    Status = RpcMgmtStatsVectorFree(&Statistics);
    if (Status)
        ApiError("main", "RpcMgmtStatsVectorFree", Status);

    return(0); // To keep the compiler happy.
}


//
// BVT for Async RPC
//

//
// Server side code
//

//
// the following routines outline the server side code for a simple async function.
//

#define TRACE(_x) { \
    if (Verbose) \
        {\
        PrintToConsole _x;\
        }\
    }

#if 0
//
// Begin, Approximate idl file
//
interface FooInterface {
    int Foo (handle_t hBinding, [in] int sizein, [in] int *bufferin,
                [in, out] int *sizeout, [out] int **bufferout) ;
    }
// End, idl file

//
// Begin, Corresponding ACF file
//
interface FooInterface {
    [async] Foo () ;
    }
// End, acf file

//
// look at asyncstub.h for the generated header
// file for function Foo
//
#endif

////////////////////////////////////////////////////////////
// Begin, stubs for Foo                                                      //
////////////////////////////////////////////////////////////

RPC_STATUS RPC_ENTRY
MyRpcAbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++

Routine Description:


Arguments:
 pAsync - the async handle being registered

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.

--*/

{
    return I_RpcAsyncAbortCall(pAsync, ExceptionCode);
}


typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    RPC_ASYNC_STATE AsyncState ;
    void *state ;
    int sizeout ;
    int *bufferout ;
    } FOO_ASYNC_SERVER_STATE;


RPC_STATUS
FooComplete (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:
    This is a generated stub. It is the completion routine for the function
    Foo. When the server app is done with processing a particular call to
    Foo, It calls Foo_complete to complete the call.

Arguments:

 pAsync - The async handle. This handle is always the first parameter of every
    Foo_complete routine.
--*/

{
    int *Ptr ;
    RPC_MESSAGE Message ;
    RPC_STATUS RpcStatus ;
    FOO_ASYNC_SERVER_STATE *StubInfo =
            (FOO_ASYNC_SERVER_STATE *) pAsync->StubInfo ;

    TRACE(("FooComplete called: %d\n", *((int *) Reply))) ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.BufferLength = 8 + StubInfo->sizeout  ;
    Message.Handle = StubInfo->StubState.CallHandle ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    Ptr = (int *) Message.Buffer ;
    *Ptr++ = *((int *) Reply) ;
    *Ptr++ = StubInfo->sizeout ;
    RpcpMemoryCopy(Ptr, StubInfo->bufferout, StubInfo->sizeout) ;

    I_RpcFree(StubInfo->bufferout) ;

    // send the async reply
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    I_RpcFree(pAsync->StubInfo) ;

    return RPC_S_OK ;
}


void
Foo_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

 Generated stub for Foo.

--*/

{
    int sizein ;
    int *bufferin ;
    int *Ptr ;
    FOO_ASYNC_SERVER_STATE *StubInfo;
    RPC_STATUS RpcStatus ;

    if ((Message->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Message->RpcFlags = RPC_BUFFER_EXTRA;
        RpcStatus = I_RpcReceive (Message, 0) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    StubInfo = (FOO_ASYNC_SERVER_STATE *)
               I_RpcAllocate(sizeof(FOO_ASYNC_SERVER_STATE)) ;

    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    StubInfo->AsyncState.Size = sizeof(RPC_ASYNC_STATE) ;
    StubInfo->AsyncState.StubInfo = (void *) StubInfo ;
    StubInfo->AsyncState.Flags = 0;
    StubInfo->AsyncState.NotificationType = RpcNotificationTypeNone;

    StubInfo->StubState.CallHandle = Message->Handle ;
    StubInfo->StubState.Flags = 0;
    StubInfo->StubState.CompletionRoutine = FooComplete ;

    RpcStatus = I_RpcAsyncSetHandle(
                        Message,
                        (PRPC_ASYNC_STATE) &(StubInfo->AsyncState)) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // unmarshall the received data
    Ptr = (int *) Message->Buffer ;
    sizein = *Ptr++ ;
    bufferin = Ptr ;

    Ptr += (sizein+3)/sizeof(int) ;
    StubInfo->sizeout = *Ptr ;

    Foo ((PRPC_ASYNC_STATE) &(StubInfo->AsyncState),
            Message->Handle,
            sizein,
            bufferin,
            &(StubInfo->sizeout),
            &(StubInfo->bufferout)) ;

}

////////////////////////////////////////////////////////////
// End, stubs for Foo                                                         //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    PRPC_ASYNC_STATE pAsync ;
    RPC_BINDING_HANDLE hBinding ;
    int *sizeout ;
    int **bufferout ;
    } CALL_COOKIE ;


void
ThreadProc(
    CALL_COOKIE *Cookie
    )
/*++

Routine Description:

    The thread that calls Foo_complete. Foo_complete is being called
    in a separate thread to show that it infact can be.

Arguments:
    pAsync - the async handle on which Foo_complete needs to be called.

--*/

{
    int retval = 1;
    UUID ObjectUuid;

    TRACE(("Foo: Sending back async reply\n"));

    Status = RpcBindingInqObject(Cookie->hBinding, &ObjectUuid);
    if (Status)
        {
        goto Cleanup;
        }

    if (CheckUuidValue(UUID_ASYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        MyRpcAbortAsyncCall(Cookie->pAsync, ASYNC_EXCEPT) ;
        return ;
        }

    *(Cookie->bufferout) = (int *) I_RpcAllocate(*(Cookie->sizeout)) ;
    if (*(Cookie->bufferout) == 0)
        {
        goto Cleanup;
        }

    if (CheckUuidValue(UUID_SLEEP_1000, &ObjectUuid) == 0)
        {
        Sleep(1000);
        }
    if (CheckUuidValue(UUID_SLEEP_2000, &ObjectUuid) == 0)
        {
        Sleep(2000);
        }
    else if (CheckUuidValue(UUID_TEST_CANCEL, &ObjectUuid) == 0)
        {
        if (RpcServerTestCancel(RpcAsyncGetCallHandle(Cookie->pAsync)) == RPC_S_OK)
            {
            PrintToConsole("Async: Call was cancelled\n");
            MyRpcAbortAsyncCall(Cookie->pAsync, ASYNC_EXCEPT) ;
            return;
            }
        }
    else if (CheckUuidValue(UUID_EXTENDED_ERROR, &ObjectUuid) == 0)
        {
        RPC_EXTENDED_ERROR_INFO ErrorInfo;

        ErrorInfo.Version = RPC_EEINFO_VERSION;
        ErrorInfo.ComputerName = NULL;
        ErrorInfo.Flags = 0;
        ErrorInfo.NumberOfParameters = 1;
        ErrorInfo.DetectionLocation = 0;
        ErrorInfo.GeneratingComponent = 0;
        ErrorInfo.ProcessID = 0;
        ErrorInfo.Status = EXTENDED_ERROR_EXCEPTION;
        ErrorInfo.Parameters[0].ParameterType = eeptAnsiString;

        ErrorInfo.Parameters[0].u.AnsiString = "first element of three generated by usvr in ThreadProc()";
        RpcErrorAddRecord(&ErrorInfo);

        ErrorInfo.Parameters[0].u.AnsiString = "second element of three generated by usvr in ThreadProc()";
        RpcErrorAddRecord(&ErrorInfo);

        ErrorInfo.Parameters[0].u.AnsiString = "third element of three generated by usvr in ThreadProc()";
        RpcErrorAddRecord(&ErrorInfo);
        MyRpcAbortAsyncCall(Cookie->pAsync, EXTENDED_ERROR_EXCEPTION);
        return;
        }

    Status = MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;
    if (Status != RPC_S_OK)
        {
        PrintToConsole("Async: RpcCompleteAsyncCall return: %d\n",
                       Status);
        }

    Sleep(100);
    return;

Cleanup:

    PrintToConsole("ThreadProc: an unknown error occurred; returning out-of-memory\n");

    MyRpcAbortAsyncCall(Cookie->pAsync, RPC_S_OUT_OF_MEMORY) ;
    IsabelleError() ;
}

int Count = 0;


void
Foo (
    IN PRPC_ASYNC_STATE pAsync,
    IN RPC_BINDING_HANDLE hBinding,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    )
/*++

Routine Description:

    This is a actual manager routine. It can spawn off an async operation
    (a thread in this case) to do the rest of the work, and send back the
    reply when it is done.

Arguments:
    pAsync - Async handle. This is always the first parameter of every async
    handle.
--*/

{
  unsigned long ThreadIdentifier;
  HANDLE HandleToThread ;
  CALL_COOKIE *CallCookie ;
  UUID ObjectUuid;

  Status = RpcBindingInqObject(hBinding, &ObjectUuid);
  if (Status)
      {
      PrintToConsole("Foo: can't inq object uuid, error = %d\n", Status);
      RpcRaiseException(Status);
      }

  if (CheckUuidValue(UUID_SYNC_EXCEPTION, &ObjectUuid) == 0)
      {
      RpcRaiseException(SYNC_EXCEPT) ;
      }

  Count++ ;
  TRACE(("Foo: Count %d\n", Count)) ;
  if ((Count % 7) == 0)
      {
      Sleep(100) ;
      }

  CallCookie = new CALL_COOKIE ;
  if (CallCookie == 0)
      {
      RpcRaiseException(APP_ERROR) ;
      }

  CallCookie->pAsync = pAsync ;
  CallCookie->sizeout = sizeout ;
  CallCookie->bufferout = bufferout ;
  CallCookie->hBinding = hBinding;

  if (*sizeout > 100000)
      {
      DebugBreak();
      }

  if (RpcServerTestCancel(RpcAsyncGetCallHandle(pAsync)) == RPC_S_OK)
      {
      PrintToConsole("Async: Call was cancelled\n");
      }

  if ((Count % 3) == 0)
      {
      ThreadProc(CallCookie);
      }
  else
      {
      HandleToThread = CreateThread(
                                0,
                                DefaultThreadStackSize,
                                (LPTHREAD_START_ROUTINE) ThreadProc,
                                CallCookie,
                                0,
                                &ThreadIdentifier);

      if (HandleToThread == 0)
        {
        PrintToConsole("Foo: Error, could not create thread\n") ;
        return ;
        }

       CloseHandle(HandleToThread);
      }

  // return to the server stub.
}

///////////////////////////////////////////////////////////
// End, Application                                                          //
//////////////////////////////////////////////////////////

//
// the following function outline the server side code for a simple async
// function using pipes.
//


////////////////////////////////////////////////////////////
// Begin, stubs for FooPipe                                                 //
////////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    RPC_ASYNC_STATE AsyncState ;
    void *state ;
    async_intpipe inpipe ;
    async_intpipe outpipe ;
    int checksum_out ;
    } FOOPIPE_ASYNC_SERVER_STATE;

#define ASYNC_CHUNK_SIZE 1000
#define ASYNC_NUM_CHUNKS 20



RPC_STATUS
PipeSendFunction (
    PRPC_ASYNC_STATE pAsync,
    void *context,
    int *buffer,
    int num_elements
    )
/*++

Routine Description:

 this function is always implemented by the stubs. This routine is called by
 the application, to send pipe data.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    unsigned int Flags = 0;
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo =
        (FOOPIPE_ASYNC_SERVER_STATE *) pAsync->StubInfo ;
    int calculated_length = num_elements * sizeof(int) + sizeof(int) ;
    char *ptr ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.Handle = StubInfo->StubState.CallHandle ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        calculated_length += StubInfo->StubState.BufferLength ;
        }

    if (StubInfo->StubState.Buffer == 0)
        {
        Message.RpcFlags = RPC_BUFFER_ASYNC | RPC_BUFFER_PARTIAL ;
        Message.BufferLength = calculated_length ;

        RpcStatus = I_RpcGetBuffer(&Message) ;
        if (RpcStatus != RPC_S_OK)
            {
            return RpcStatus;
            }
        }
    else
        {
        Message.RpcFlags = RPC_BUFFER_ASYNC ;
        Message.Buffer = StubInfo->StubState.Buffer ;
        Message.BufferLength = StubInfo->StubState.BufferLength;

        RpcStatus = I_RpcReallocPipeBuffer(&Message, calculated_length) ;
        if (RpcStatus != RPC_S_OK)
            {
            return RpcStatus;
            }
        }

    ptr = (char *) Message.Buffer ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        ptr += StubInfo->StubState.BufferLength ;
        }

    *((int *) ptr) = num_elements ;
    RpcpMemoryCopy(ptr+sizeof(int), buffer, num_elements *sizeof(int)) ;

    Message.RpcFlags = RPC_BUFFER_PARTIAL | RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus == RPC_S_OK)
        {
        StubInfo->StubState.State = SEND_COMPLETE ;
        }
    else if (RpcStatus == RPC_S_SEND_INCOMPLETE)
        {
        StubInfo->StubState.State = SEND_INCOMPLETE ;
        }
    else
        {
        return RpcStatus;
        }

    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;

    return RPC_S_OK;
}


RPC_STATUS
PipeReceiveFunction (
    PRPC_ASYNC_STATE pAsync,
    int *buffer,
    int requested_count,
    int *actual_count
    )
/*++
Function Name:PipeReceiveFunction

Parameters:

Description:

Returns:

--*/
{
    int num_elements = 0;
    RPC_MESSAGE Callee ;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo =
        (FOOPIPE_ASYNC_SERVER_STATE *) pAsync->StubInfo ;
    PIPE_STATE *state = &(StubInfo->StubState.PipeState);
    DWORD size = (DWORD) requested_count * state->PipeElementSize ;

    *actual_count = 0 ;

    if (state->EndOfPipe)
        {
        return RPC_S_OK;
        }

    I_RpcReadPipeElementsFromBuffer(
                                    state,
                                    (char *) buffer,
                                    size,
                                    &num_elements) ;

    *actual_count += num_elements ;
    size -= num_elements * state->PipeElementSize ;

    if (state->EndOfPipe == 0 &&
        num_elements < requested_count)
        {
        Callee.ProcNum = RPC_FLAGS_VALID_BIT ;
        Callee.Handle = StubInfo->StubState.CallHandle ;

        Callee.RpcFlags = RPC_BUFFER_PARTIAL | RPC_BUFFER_ASYNC ;
        if (num_elements)
            {
            Callee.RpcFlags |= RPC_BUFFER_NONOTIFY;
            }

        Callee.Buffer = 0 ;
        Callee.BufferLength = 0 ;

        Status = I_RpcReceive(&Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;

            if (Status == RPC_S_ASYNC_CALL_PENDING)
                {
                if (num_elements)
                    {
                    Status = RPC_S_OK;
                    }
                }
            else
                {
                num_elements = 0 ;
                }

            return Status;
            }

        state->Buffer = Callee.Buffer ;
        state->BufferLength = Callee.BufferLength ;
        state->CurPointer = (char *) Callee.Buffer ;
        state->BytesRemaining = Callee.BufferLength ;

        buffer = (pipe_element_t *)
                    ((char *) buffer + num_elements * state->PipeElementSize) ;

        num_elements = 0 ;
        I_RpcReadPipeElementsFromBuffer(
                                        state,
                                        (char *) buffer,
                                        size,
                                        &num_elements) ;

        *actual_count += num_elements ;
        }

    return RPC_S_OK;
}



RPC_STATUS
FooPipeComplete (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:
    Stub for the completion routine of FooPipe.

Arguments:

 pAsync - async handle
--*/

{
    RPC_MESSAGE Message ;
    RPC_STATUS RpcStatus ;
    char *ptr ;
    int calculated_length = 8 ;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo =
        (FOOPIPE_ASYNC_SERVER_STATE *) pAsync->StubInfo ;

    TRACE(("FooPipeComplete called: %d\n", *((int *) Reply))) ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        calculated_length += StubInfo->StubState.BufferLength ;
        }

    // if we had [out] pipes, I_RpcGetBuffer must have
    // been called
    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcReallocPipeBuffer(&Message, calculated_length) ;
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus ;
        }

    ptr = (char *) Message.Buffer ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        ptr += StubInfo->StubState.BufferLength ;
        }

    *((int *) ptr) = *((int *) Reply);
    *(((int *) ptr)+1) = StubInfo->checksum_out ;

    // send the async reply
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}

int tempint ;


void
FooPipe_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

    server stub for the FooPipe function.

--*/

{
    int checksum_in;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo ;
    RPC_STATUS RpcStatus ;
    unsigned long non_pipe_size = sizeof(int) ;

    if (Message->BufferLength < non_pipe_size)
        {
        Message->RpcFlags = RPC_BUFFER_PARTIAL
                                        | RPC_BUFFER_EXTRA;

              RpcStatus = I_RpcReceive(
                                 Message,
                                 non_pipe_size - Message->BufferLength) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    //
    // allocate a handle on the heap, initialize it
    // and register it with the RPC runtime.
    //

    StubInfo = (FOOPIPE_ASYNC_SERVER_STATE *)
                I_RpcAllocate(sizeof(FOOPIPE_ASYNC_SERVER_STATE)) ;

    StubInfo->AsyncState.Size = sizeof(RPC_ASYNC_STATE) ;
    StubInfo->AsyncState.Flags = 0;
    StubInfo->AsyncState.StubInfo = (void *) StubInfo ;
    StubInfo->AsyncState.NotificationType = RpcNotificationTypeNone;

    StubInfo->StubState.Length = sizeof(FOOPIPE_ASYNC_SERVER_STATE) ;
    StubInfo->StubState.CallHandle = Message->Handle ;

    StubInfo->StubState.PipeState.Buffer = 0;
    StubInfo->StubState.PipeState.CurrentState = start;
    StubInfo->StubState.PipeState.EndOfPipe = 0;
    StubInfo->StubState.PipeState.PipeElementSize = sizeof(int);
    StubInfo->StubState.PipeState.PartialPipeElement = &tempint;
    StubInfo->StubState.PipeState.PreviousBuffer = 0;
    StubInfo->StubState.Buffer = 0;

    if (Message->BufferLength > non_pipe_size)
        {
        StubInfo->StubState.PipeState.CurPointer = (char *) Message->Buffer + sizeof(int);
        StubInfo->StubState.PipeState.BytesRemaining =
                    Message->BufferLength - non_pipe_size;
        }
    else
        {
        StubInfo->StubState.PipeState.CurPointer = 0;
        StubInfo->StubState.PipeState.BytesRemaining = 0;
        }

    RpcStatus = I_RpcAsyncSetHandle(
                            Message,
                            (PRPC_ASYNC_STATE) &(StubInfo->AsyncState)) ;
    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // unmarshall the received data
    checksum_in = *((int *) Message->Buffer) ;

    StubInfo->StubState.CompletionRoutine = FooPipeComplete ;
    StubInfo->inpipe.PipeReceive = PipeReceiveFunction;
    StubInfo->outpipe.PipeSend = PipeSendFunction ;

    FooPipe ((PRPC_ASYNC_STATE) &(StubInfo->AsyncState),
                Message->Handle,
                checksum_in,
                &(StubInfo->inpipe),
                &(StubInfo->outpipe),
                &(StubInfo->checksum_out)) ;
}

////////////////////////////////////////////////////////////
// End, stubs for FooPipe                                                   //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    PRPC_ASYNC_STATE pAsync ;
    int checksum_in ;
    async_intpipe *inpipe ;
    async_intpipe *outpipe ;
    int *checksum_out ;
    int i ;
    int PipeChecksum ;
    int ExpectedValue;
    int PipeBuffer[ASYNC_CHUNK_SIZE] ;
    } PIPE_CALL_COOKIE ;


int PipeCount = 0;

void
FooPipeAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:


--*/

{
    RPC_STATUS Status;
    PIPE_CALL_COOKIE *Cookie = (PIPE_CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcSendComplete:
            if (Cookie->i <ASYNC_NUM_CHUNKS)
                {
                Cookie->i++ ;
                Status = Cookie->outpipe->PipeSend(
                             pAsync,
                             0,
                             (int *) Cookie->PipeBuffer,
                             ASYNC_CHUNK_SIZE) ;
                }
            else
                {
                ASSERT(Cookie->i == ASYNC_NUM_CHUNKS);

                Cookie->i++ ;
                pAsync->Flags = 0;
                Status = Cookie->outpipe->PipeSend(
                            pAsync,
                            0, 0, 0) ;
                }

            if (Status != RPC_S_OK)
                {
                PrintToConsole("PipeSend failed\n");
                }
            break;

        case RpcCallComplete:
#if DBG
            PrintToConsole("usvr: call complete APC !!\n");
#endif
            break;
        }
}


void
ThreadProcPipes(
    IN PIPE_CALL_COOKIE  *Cookie
    )
/*++

Routine Description:

    The thread that calls FooPipe_complete. FooPipe_complete is being called
    in a separate thread to show that it infact can be.

Arguments:
    pAsync - the async handle on which Foo_complete needs to be called.

--*/

{
    int *ptr ;
    int  i ;
    int retval ;
    int Checksum = 0;
    RPC_STATUS Status ;
    int num_elements;
    BOOL fDone = 0;

    RpcTryExcept
        {
        TRACE(("FooPipe: sending pipe data\n")) ;

        while (!fDone)
            {
            Status = Cookie->inpipe->PipeReceive(
                                                  Cookie->pAsync,
                                                  (int *) Cookie->PipeBuffer,
                                                  ASYNC_CHUNK_SIZE,
                                                  &num_elements);

            switch (Status)
                {
                case RPC_S_ASYNC_CALL_PENDING:
                    if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                        {
                        RpcRaiseException(APP_ERROR) ;
                        }
                    break;

                case RPC_S_OK:
                    if (num_elements == 0)
                        {
                        fDone = 1;
                        }
                    else
                        {
                        for (i = 0; i <num_elements; i++)
                            {
                            if (Cookie->PipeBuffer[i] != Cookie->ExpectedValue)
                                {
                                printf("pipe recv fn: elt %d contains %lx, expected %lx\n",
                                       i, Cookie->PipeBuffer[i], Cookie->ExpectedValue);
                                DebugBreak();
                                }

                            Cookie->ExpectedValue =
                                (Cookie->PipeBuffer[i]+1) % ASYNC_CHUNK_SIZE;
                            Cookie->PipeChecksum += Cookie->PipeBuffer[i] ;
                            }
                        }
                    break;

                default:
                    fDone = 1;
                    break;
                }

            //
            // This code is for testing flow control
            //
            PipeCount++;
            if ((PipeCount % 3) == 0)
                {
                Sleep(100);
                }
            }

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        TRACE(("FooPipe: sending pipe data\n")) ;

        ptr = (int *) Cookie->PipeBuffer ;
        for (i = 0; i <ASYNC_CHUNK_SIZE; i++)
            {
            *ptr++ = i;
            Checksum += i ;
            }

        TRACE(("FooPipe: [out] Block checksum: %d\n", Checksum)) ;
        Checksum *= ASYNC_NUM_CHUNKS ;

        TRACE(("FooPipe: [out] Total checksum: %d\n", Checksum)) ;


        Cookie->i = 1;

        Status = Cookie->outpipe->PipeSend(
                     Cookie->pAsync,
                     0,
                     Cookie->PipeBuffer,
                     ASYNC_CHUNK_SIZE) ;

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        while (Cookie->i < ASYNC_NUM_CHUNKS+1)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        TRACE(("FooPipe: sending non pipe reply\n")) ;

        *(Cookie->checksum_out) = Checksum ;

        if (Cookie->checksum_in != Cookie->PipeChecksum)
            {
            PrintToConsole("FooPipe: Checksum Error, expected: %d, checksum: %d\n",
                    Cookie->checksum_in, Cookie->PipeChecksum) ;
            IsabelleError() ;
            retval = 0;
            }
        else
            {
            retval = 1;
            }

        Status = MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        IsabelleError() ;
        MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;

        PrintToConsole("FooPipe: Exception : 0x%lX\n", GetExceptionCode()) ;
        }
    RpcEndExcept

    Sleep(100);
}


void
FooPipe (
    IN PRPC_ASYNC_STATE pAsync,
    IN RPC_BINDING_HANDLE hBinding,
    IN int checksum_in,
    IN async_intpipe *inpipe,
    OUT async_intpipe *outpipe,
    OUT int *checksum_out
    )
/*++

Routine Description:

    The manager routine that implements FooPipe. It sets up the receive
    and alloc function pointer for each of the pipes on which data is to
    be received, and call RpcRegisterAsycnHandle on the async handle.
    It then spawns off an async operation (creates a thread in this case),
    to process the async call.
Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.
--*/

{
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    RPC_STATUS RpcStatus ;
    PIPE_CALL_COOKIE *PipeCallCookie ;

    PipeCallCookie = new PIPE_CALL_COOKIE ;
    if (PipeCallCookie == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    PipeCallCookie->pAsync = pAsync ;
    PipeCallCookie->inpipe = inpipe ;
    PipeCallCookie->outpipe = outpipe ;
    PipeCallCookie->checksum_in = checksum_in ;
    PipeCallCookie->checksum_out = checksum_out ;
    PipeCallCookie->PipeChecksum = 0;
    PipeCallCookie->ExpectedValue = 0;

    HandleToThread = CreateThread(0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) ThreadProcPipes,
                                    PipeCallCookie,
                                    0,
                                    &ThreadIdentifier);

    if (HandleToThread == 0)
        {
        PrintToConsole("FooPipe: Can't create thread\n") ;
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->Flags = RPC_C_NOTIFY_ON_SEND_COMPLETE ;
    pAsync->UserInfo = (void *) PipeCallCookie ;
    pAsync->NotificationType = RpcNotificationTypeApc ;
    pAsync->u.APC.NotificationRoutine = FooPipeAPCRoutine ;
    pAsync->u.APC.hThread = HandleToThread ;

    RpcStatus = RpcAsyncRegisterInfo(pAsync) ;
    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }
}

///////////////////
// misc stuff       ///
///////////////////

int
FooBar (
    IN RPC_BINDING_HANDLE hBinding,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    )
{
    UUID ObjectUuid;

    Status = RpcBindingInqObject(hBinding, &ObjectUuid);
    if (Status)
        {
        PrintToConsole("FooBar: can't inq object uuid, error = %d\n", Status);
        RpcRaiseException(Status);
        }

    if (CheckUuidValue(UUID_SYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        RpcRaiseException(SYNC_EXCEPT) ;
        }

    *bufferout = (int *) I_RpcAllocate(*sizeout) ;
    if (*bufferout == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    return 1;
}


void
FooBar_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

 Generated stub for FooBar.

--*/

{
    int *bufferin ;
    int *bufferout ;
    int sizein, sizeout ;
    int *Ptr ;
    int retval ;
    RPC_STATUS RpcStatus ;

    if ((Message->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Message->RpcFlags = RPC_BUFFER_EXTRA;
        RpcStatus = I_RpcReceive (Message, 0) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    // unmarshall the received data
    Ptr = (int *) Message->Buffer ;
    sizein = *Ptr++ ;
    bufferin = Ptr ;

    Ptr += (sizein+3)/sizeof(int) ;

    sizeout = *Ptr ;

    retval = FooBar (Message->Handle, sizein, bufferin, &sizeout, &bufferout) ;

    Message->BufferLength = sizeout+8;

    RpcStatus = I_RpcGetBuffer(Message) ;
    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }

    Ptr = (int *) Message->Buffer ;
    *Ptr++ = retval ;
    *Ptr++ = sizeout ;
    RpcpMemoryCopy(Ptr, bufferout, sizeout) ;

    I_RpcFree(bufferout) ;
}

////////////////////////////////////////////////////////////
// Begin, stubs for FooCH                                                      //
////////////////////////////////////////////////////////////
void
FooCH (
    IN PRPC_ASYNC_STATE pAsync,
    IN RPC_BINDING_HANDLE hBinding,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    ) ;

typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    RPC_ASYNC_STATE AsyncState ;
    void *state ;
    int sizeout ;
    int *bufferout ;
    } FOOCH_ASYNC_SERVER_STATE;


RPC_STATUS
FooCHComplete (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:
    This is a generated stub. It is the completion routine for the function
    FooCH. When the server app is done with processing a particular call to
    FooCH, It calls FooCH_complete to complete the call.

Arguments:

 pAsync - The async handle. This handle is always the first parameter of every
    FooCH_complete routine.
--*/

{
    int *Ptr ;
    RPC_MESSAGE Message ;
    RPC_STATUS RpcStatus ;
    FOOCH_ASYNC_SERVER_STATE *StubInfo =
            (FOOCH_ASYNC_SERVER_STATE *) pAsync->StubInfo ;

    TRACE(("FooCHComplete called: %d\n", *((int *) Reply))) ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.BufferLength = 8 + StubInfo->sizeout  ;
    Message.Handle = StubInfo->StubState.CallHandle ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    Ptr = (int *) Message.Buffer ;
    *Ptr++ = *((int *) Reply) ;
    *Ptr++ = StubInfo->sizeout ;
    RpcpMemoryCopy(Ptr, StubInfo->bufferout, StubInfo->sizeout) ;

    I_RpcFree(StubInfo->bufferout) ;

    // send the async reply
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    I_RpcFree(pAsync->StubInfo) ;

    return RPC_S_OK ;
}


void
FooCH_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

 Generated stub for FooCH.

--*/

{
    int sizein ;
    int *bufferin ;
    int *Ptr ;
    FOOCH_ASYNC_SERVER_STATE *StubInfo;
    RPC_STATUS RpcStatus ;
    NDR_SCONTEXT Context ;

    if ((Message->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Message->RpcFlags = RPC_BUFFER_EXTRA;
        RpcStatus = I_RpcReceive (Message, 0) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    // allocate a handle and tell the runtime about it
    StubInfo = (FOOCH_ASYNC_SERVER_STATE *)
                   I_RpcAllocate(sizeof(FOOCH_ASYNC_SERVER_STATE)) ;

    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    StubInfo->AsyncState.Size = sizeof(RPC_ASYNC_STATE) ;
    StubInfo->AsyncState.StubInfo = (void *) StubInfo ;
    StubInfo->AsyncState.Flags = 0;
    StubInfo->AsyncState.NotificationType = RpcNotificationTypeNone;

    StubInfo->StubState.CompletionRoutine = FooCHComplete ;
    StubInfo->StubState.CallHandle = Message->Handle ;
    StubInfo->StubState.Flags = 0;

    RpcStatus = I_RpcAsyncSetHandle(
                            Message,
                            (PRPC_ASYNC_STATE) &(StubInfo->AsyncState)) ;

    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }


    // unmarshall the received data
    Ptr = (int *) Message->Buffer ;
    Context = NDRSContextUnmarshallEx (
                  Message->Handle,
                  0,
                  Message->DataRepresentation );
    if (Context == 0)
        {
        RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH) ;
        }

    Ptr += 20/sizeof(int) ;

    sizein = *Ptr++ ;
    bufferin = Ptr ;

    Ptr += (sizein+3)/sizeof(int) ;
    StubInfo->sizeout = *Ptr ;

    {
    RPC_STATUS Status = 0;
    UUID ObjectUuid;

    Status = RpcBindingInqObject(Message->Handle, &ObjectUuid);
    if (Status)
        {
        PrintToConsole("FooBar: can't inq object uuid, error = %d\n", Status);
        RpcRaiseException(Status);
        }

    if (CheckUuidValue(UUID_SYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        RpcRaiseException(SYNC_EXCEPT) ;
        }

    if (CheckUuidValue(UUID_ASYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        StubInfo->sizeout = SIZEOUT_ASYNC_EXCEPTION;
        }
    }

    FooCH ((PRPC_ASYNC_STATE) &(StubInfo->AsyncState),
            (void PAPI *) *NDRSContextValue(Context),
            sizein,
            bufferin,
            &(StubInfo->sizeout),
            &(StubInfo->bufferout)) ;

}

////////////////////////////////////////////////////////////
// End, stubs for FooCH                                                         //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    PRPC_ASYNC_STATE pAsync ;
    int *sizeout ;
    int **bufferout ;
    BOOL fException;
    } FOOCH_CALL_COOKIE ;


void
FooCHThreadProc(
    FOOCH_CALL_COOKIE *Cookie
    )
/*++

Routine Description:

    The thread that calls FooCH_complete. FooCH_complete is being called
    in a separate thread to show that it infact can be.

Arguments:
    pAsync - the async handle on which FooCH_complete needs to be called.

--*/

{
    int retval = 1;

    TRACE(("FOOCH: Sending back aync reply\n")) ;

    if (Cookie->fException)
        {
        MyRpcAbortAsyncCall(Cookie->pAsync, ASYNC_EXCEPT) ;
        return ;
        }

    *(Cookie->bufferout) = (int *) I_RpcAllocate(*(Cookie->sizeout)) ;
    if (*(Cookie->bufferout) == 0)
        {
        MyRpcAbortAsyncCall(Cookie->pAsync, RPC_S_OUT_OF_MEMORY) ;
        IsabelleError() ;
        return ;
        }

    Status = MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;
    if (Status != RPC_S_OK)
        {
        IsabelleError() ;
        }
}


void
FooCH (
    IN PRPC_ASYNC_STATE pAsync,
    IN void PAPI *ContextHandle,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    )
/*++

Routine Description:

    This is a actual manager routine. It can spawn off an async operation
    (a thread in this case) to do the rest of the work, and send back the
    reply when it is done.

Arguments:
    pAsync - Async handle. This is always the first parameter of every async
    handle.
--*/

{
  unsigned long ThreadIdentifier;
  HANDLE HandleToThread ;
  FOOCH_CALL_COOKIE *CallCookie ;

  CallCookie = new FOOCH_CALL_COOKIE ;
  if (CallCookie == 0)
      {
      RpcRaiseException(APP_ERROR) ;
      }

  CallCookie->pAsync = pAsync ;
  CallCookie->sizeout = sizeout ;
  CallCookie->bufferout = bufferout ;
  CallCookie->fException = FALSE;

  if (*sizeout == SIZEOUT_ASYNC_EXCEPTION)
      {
      CallCookie->fException = TRUE;
      }

  HandleToThread = CreateThread(
                                0,
                                DefaultThreadStackSize,
                                (LPTHREAD_START_ROUTINE) FooCHThreadProc,
                                CallCookie,
                                0,
                                &ThreadIdentifier);

  if (HandleToThread == 0)
      {
      PrintToConsole("FooCH: Error, could not create thread\n") ;
      return ;
      }

  // return to the server stub.
}

///////////////////////////////////////////////////////////
// End, Application                                                          //
//////////////////////////////////////////////////////////


void
Async (
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
{
    PrintToConsole("Async : Test Async RPC\n");

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Async","stub_RegisterIf",Status);
        PrintToConsole("Async : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    //
    // synchronous listen blocks inside GenericServerListen
    //
    Status = GenericServerListen( "Async", BARTHOLOMEW );
    if (Status)
        {
        return;
        }

    Status = GenericServerUnlisten( "Async" );
    if (Status)
        {
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Async","RpcServerUnregisterIf",Status);
        PrintToConsole("Async : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Sylvia)\n");
        return;
        }

    PrintToConsole("Async : PASS\n");
}



void
SendAck (
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
        {
    PrintToConsole("SendAck : Test datagram delayed ACK\n");

    Status = GenericServerListen( "SendAck", BARTHOLOMEW );
        if (Status)
            {
        return;
        }

    Status = GenericServerUnlisten( "SendAck" );
    if (Status)
        {
            return;
            }
        }


void
DgTransport (
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
{
    PrintToConsole("DgTransport : Test datagram transport\n");

    Status = GenericServerListen( "DgTransport", BARTHOLOMEW );
    if (Status)
        {
        return;
        }

    Status = GenericServerUnlisten( "DgTransport" );
    if (Status)
        {
        return;
        }
        }

PVOID LastConnectionCreated = 0;

PVOID MySecurityContext = 0;

DWORD ChosenErrorCode = 0;

void
ShutdownHookFn(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    switch (id)
        {
        case TH_RPC_LOG_EVENT:
            {
            RPC_EVENT * event = (RPC_EVENT *) subject;

//            TRACE(("  hook: %c %c %p %p\n", event->Subject, event->Verb, event->SubjectPointer, event->ObjectPointer));

            //
            // Record sconnection creation.
            //
            if (event->Subject == SU_SCONN &&
                event->Verb    == EV_CREATE)
                {
                TRACE(("  hook: created connection %p\n", event->SubjectPointer));
                LastConnectionCreated = event->SubjectPointer;
                }

            break;
            }

        case TH_RPC_SECURITY_SERVER_CONTEXT_CREATED:
            {
            if (object == LastConnectionCreated)
                {
                TRACE(("  hook: connection %p created security context %p\n", LastConnectionCreated, subject));
                MySecurityContext = subject;
                }

            break;
            }

        default:
            {
            break;
            }
        }
}

void
SecurityContextHook(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    if (subject == MySecurityContext)
        {
        TRACE(("  hook executed: context %p, hook ID %x, error code is 0x%x\n", subject, id, ChosenErrorCode));

        DWORD * pStatus = (DWORD *) object;

        *pStatus = ChosenErrorCode;
        }
    else
        {
        TRACE(("  hook: ignoring notification, my cxt = %p, context %p, hook ID %x, error code is 0x%x\n",
               MySecurityContext, subject, id, ChosenErrorCode));
        }
}

void
TestSecurityError (
    RPC_TEST_HOOK_ID id,
    DWORD error
    );

void
SecurityErrorWrapper(
    int subtest
    )
{
    //
    // Set up the test hook.
    //
    {
    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("","GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        }
    }

    switch (subtest)
        {
        default:
            {
            PrintToConsole("unknown security-error case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n"
                           "\n"
                           "    1 - AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           "    2 - AcceptThirdLeg  returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           );
            return;
            }

        case 0:
            {
            PrintToConsole("running all sub tests\n");
            }

        case 1:
            {
            PrintToConsole("subtest 1: AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            TestSecurityError( TH_SECURITY_FN_ACCEPT1, SEC_E_SHUTDOWN_IN_PROGRESS );

            if (subtest)
                {
                break;
                }
            }

        case 2:
            {
            PrintToConsole("subtest 1: AcceptThirdLeg returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            TestSecurityError( TH_SECURITY_FN_ACCEPT3, SEC_E_SHUTDOWN_IN_PROGRESS );

            if (subtest)
                {
                break;
                }
            }
        }
}


void
TestSecurityError (
    RPC_TEST_HOOK_ID id,
    DWORD error
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
{

    //
    // Set test hooks.
    //
    (*SetTestHookFn)( TH_RPC_LOG_EVENT, ShutdownHookFn );
    (*SetTestHookFn)( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, ShutdownHookFn );

    ChosenErrorCode = error;

    (*SetTestHookFn)( id, SecurityContextHook );

    //
    // Wait for the client to make the call.
    //
    Status = GenericServerListen( "SecurityShutdown", SECURITY_ERROR );
    if (Status)
        {
        return;
        }

    //
    // Remove test hooks.
    //
    (*SetTestHookFn)( TH_RPC_LOG_EVENT, 0 );
    (*SetTestHookFn)( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, 0 );

    (*SetTestHookFn)( id, 0 );

    //
    // Clean up.
    //
    Status = GenericServerUnlisten( "SecurityShutdown" );
    if (Status)
        {
        return;
        }
}


DWORD
GenericServerUnlisten(
    char * name
    )
{
    // Synchro support
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError(name,"RpcServerUnregisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Unregister ", name);
        PrintToConsole("Interface (Helga)\n");
        return Status;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("%s : FAIL - Error(s) in Isabelle", name);
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return Status;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError(name,"RpcServerUnregisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Unregister ", name);
        PrintToConsole("Interface (Isabelle)\n");
        return Status;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("%s : FAIL - Error(s) in Sylvia", name);
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return Status;
        }

    return 0;
}


DWORD
GenericServerListen(
    char * name,
    int endpoint
    )
{
    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(endpoint), 0);
    if (Status)
        {
        ApiError(name, "RpcServerUseProtseqEpWrapper", Status);
        PrintToConsole("%s : FAIL - Unable to Use Protseq endpoint \n", name);
        return Status;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError(name,"stub_RegisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Register Interface ", name);
        PrintToConsole("(Isabelle)\n");
        return Status;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError(name,"stub_RegisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Register Interface ", name);
        PrintToConsole("(Helga)\n");
        return Status;
        }

    if (!NoSecurityTests)
        {
        Status = RpcServerRegisterAuthInfoA((unsigned char PAPI *) "ServerPrincipal", 10, 0, 0);
        if (Status)
            {
            ApiError(name, "RpcServerRegisterAuthInfo", Status);
            PrintToConsole("%s : FAIL - Unable to Register AuthInfo\n", name);
            return Status;
            }
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError(name,"stub_ServerListen",Status);
        PrintToConsole("%s : FAIL - stub_ServerListen Failed\n", name);
        return Status;
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\uuidsup.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    uuidsup.cxx

Abstract:

    Implements system dependent functions used in creating Uuids.

    This file is for Win32 (NT and Chicago) systems.

    External functions are:
        UuidGlobalMutexRequest
        UuidGlobalMutexClear
        GetNodeId
        UuidGetValues

Note:

    WARNING:

    Everything in this file is only called from within UuidCreate()
    which is already holding the global mutex.  Therefore none of
    this code is multithread safe.  For example, access to the global
    Uuid HKEY's is not protected.

Author:

   Mario Goertzel   (MarioGo)  May 23, 1994

Revision History:

--*/

#include <precomp.hxx>
#include <uuidsup.hxx>


RPC_STATUS __RPC_API
UuidGetValues(
    OUT UUID_CACHED_VALUES_STRUCT __RPC_FAR *Values
    )
/*++

Routine Description:

    This routine allocates a block of uuids for UuidCreate to handout.

Arguments:

    Values - Set to contain everything needed to allocate a block of uuids.
             The following fields will be updated here:

    NextTimeLow -   Together with LastTimeLow, this denotes the boundaries
                    of a block of Uuids. The values between NextTimeLow
                    and LastTimeLow are used in a sequence of Uuids returned
                    by UuidCreate().

    LastTimeLow -   See NextTimeLow.

    ClockSequence - Clock sequence field in the uuid.  This is changed
                    when the clock is set backward.

Return Value:

    RPC_S_OK - We successfully allocated a block of uuids.

    RPC_S_OUT_OF_MEMORY - As needed.
--*/
{
    NTSTATUS NtStatus;
    ULARGE_INTEGER Time;
    ULONG Range;
    ULONG Sequence;
    int Tries = 0;

    do {
        NtStatus = NtAllocateUuids(&Time, &Range, &Sequence, (char *) &Values->NodeId[0]);

        if (NtStatus == STATUS_RETRY)
            {
            Sleep(1);
            }

        Tries++;

        if (Tries == 20)
            {
#ifdef DEBUGRPC
            PrintToDebugger("Rpc: NtAllocateUuids retried 20 times!\n");
            ASSERT(Tries < 20);
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
            }

        } while(NtStatus == STATUS_RETRY);

    if (!NT_SUCCESS(NtStatus))
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    // NtAllocateUuids keeps time in SYSTEM_TIME format which is 100ns ticks since
    // Jan 1, 1601.  UUIDs use time in 100ns ticks since Oct 15, 1582.

    // 17 Days in Oct + 30 (Nov) + 31 (Dec) + 18 years and 5 leap days.

    Time.QuadPart +=   (unsigned __int64) (1000*1000*10)       // seconds
                     * (unsigned __int64) (60 * 60 * 24)       // days
                     * (unsigned __int64) (17+30+31+365*18+5); // # of days

    ASSERT(Range);

    Values->ClockSeqHiAndReserved =
        RPC_UUID_RESERVED | (((unsigned char) (Sequence >> 8))
        & (unsigned char) RPC_UUID_CLOCK_SEQ_HI_MASK);

    Values->ClockSeqLow = (unsigned char) (Sequence & 0x00FF);

    // The order of these assignments is important

    Values->Time.QuadPart = Time.QuadPart + (Range - 1);
    Values->AllocatedCount = Range;

    if ((Values->NodeId[0] & 0x80) == 0)
        {
        return(RPC_S_OK);
        }

    return (RPC_S_UUID_LOCAL_ONLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\util.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    util.c

Abstract:

    Various helper and debug functions shared between platforms.

Author:

    Mario Goertzel    [MarioGo]


Revision History:

    MarioGo     95/10/21        Bits 'n pieces

--*/

#include <precomp.hxx>
#include <stdarg.h>
#include <osfpcket.hxx>

#ifdef DEBUGRPC
BOOL ValidateError(
    IN unsigned int Status,
    IN unsigned int Count,
    IN const int ErrorList[])
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            // more error codes here
            } END_VALIDATE;

     This function is called with the RpcStatus and expected errors codes
     as parameters.  If RpcStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.
    Count - number of variable length arguments

    ... - One or more expected status codes.  Terminated with 0 (RPC_S_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    unsigned i;

    for (i = 0; i < Count; i++)
        {
        if (ErrorList[i] == (int) Status)
            {
            return TRUE;
            }
        }

    PrintToDebugger("RPC Assertion: unexpected failure %lu (0lx%08x)\n",
                    (unsigned long)Status, (unsigned long)Status);

    return(FALSE);
}

#endif // DEBUGRPC

//------------------------------------------------------------------------

#ifdef RPC_ENABLE_WMI_TRACE

#include <wmistr.h>
#include <evntrace.h>
#include "wmlum.h"              // private header from clustering

extern "C"
{
DWORD __stdcall
I_RpcEnableWmiTrace(
    PWML_TRACE fn,
    WMILIB_REG_STRUCT ** pHandle
    );
}

typedef DWORD (*WMI_TRACE_FN)();

PWML_TRACE WmiTraceFn = 0;

WMILIB_REG_STRUCT WmiTraceData;

GUID WmiMessageGuid = { /* 41de81c0-aa28-460b-a455-c23809e7c170 */
    0x41de81c0,
    0xaa28,
    0x460b,
    {0xa4, 0x55, 0xc2, 0x38, 0x09, 0xe7, 0xc1, 0x70}
  };


DWORD __stdcall
I_RpcEnableWmiTrace(
    PWML_TRACE fn,
    WMILIB_REG_STRUCT ** pHandle
    )
{
    WmiTraceFn = fn;

    *pHandle = &WmiTraceData;

    return 0;
}

#endif

BOOL fEnableLog = TRUE;

C_ASSERT(sizeof(LUID) == sizeof(__int64));

struct RPC_EVENT * RpcEvents;

long EventArrayLength = MAX_RPC_EVENT;
long NextEvent  = 0;

BOOL    DisableEvents = 0;

/*
boolean SubjectExceptions[256];
boolean VerbExceptions[256];
*/

#define LOG_VAR( x ) &(x), sizeof(x)

HANDLE hLogFile = 0;

struct RPC_EVENT_LOG
{
    DWORD           Thread;
    union
        {
        struct
            {
            unsigned char   Subject;
            unsigned char   Verb;
            };
        DWORD ZeroSet;
        };

    void *          SubjectPointer;
    void *          ObjectPointer;

    ULONG_PTR       Data;
    void *          EventStackTrace[STACKTRACE_DEPTH];
};

void
TrulyLogEvent(
    IN unsigned char   Subject,
    IN unsigned char   Verb,
    IN void *   SubjectPointer,
    IN void *   ObjectPointer,
    IN ULONG_PTR  Data,
    IN BOOL fCaptureStackTrace,
    IN int    AdditionalFramesToSkip
    )
{
    /*
    if (DisableEvents != SubjectExceptions[Subject] ||
        DisableEvents != VerbExceptions[Verb])
        {
        return;
        }
    */

    //
    // Allocate the event table if it isn't already there.
    //
    if (!RpcEvents)
        {
        struct RPC_EVENT * Temp = (struct RPC_EVENT *) HeapAlloc( GetProcessHeap(),
                                                                  HEAP_ZERO_MEMORY,
                                                                  EventArrayLength * sizeof(RPC_EVENT) );
        HANDLE LocalFile;
        if (!Temp)
            {
            return;
            }

        if (InterlockedCompareExchangePointer((void **) &RpcEvents, Temp, 0) != 0)
            {
            HeapFree(GetProcessHeap(), 0, Temp);
            }

        /*
        if (wcsstr(GetCommandLine(), L"fs.exe") != NULL)
            {
            LocalFile = CreateFile(L"d:\\rpcclnt.log", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL);

            if (LocalFile != INVALID_HANDLE_VALUE)
                {
                hLogFile = LocalFile;
                }
            else
                {
                if (hLogFile == 0)
                    {
                    DbgPrint("ERROR: Could not create RPC log file: %d\n", GetLastError());
                    }
                // else
                // somebody already set it - ignore
                }
            }
        else if (wcsstr(GetCommandLine(), L"fssvr.exe") != NULL)
            {
            LocalFile = CreateFile(L"d:\\rpcsvr.log", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL);

            if (LocalFile != INVALID_HANDLE_VALUE)
                {
                hLogFile = LocalFile;
                }
            else
                {
                if (hLogFile == 0)
                    {
                    DbgPrint("ERROR: Could not create RPC log file: %d\n", GetLastError());
                    }
                // else
                // somebody already set it - ignore
                }
            }
            */

        /*
        DisableEvents = TRUE;
        SubjectExceptions[SU_ADDRESS] = TRUE;
        VerbExceptions[EV_CREATE] = TRUE;
        VerbExceptions[EV_DELETE] = TRUE;
        */
        /*
        SubjectExceptions[SU_HEAP] = TRUE;
        SubjectExceptions[SU_EVENT] = TRUE;
        SubjectExceptions[SU_BCACHE] = TRUE;
        */
        /*
        DisableEvents = TRUE;
        SubjectExceptions['a'] = TRUE;
        SubjectExceptions['g'] = TRUE;
        SubjectExceptions['G'] = TRUE;
        SubjectExceptions['W'] = TRUE;
        SubjectExceptions['X'] = TRUE;
        SubjectExceptions['Y'] = TRUE;
        SubjectExceptions['Z'] = TRUE;
        SubjectExceptions['w'] = TRUE;
        SubjectExceptions['x'] = TRUE;
        SubjectExceptions['y'] = TRUE;
        SubjectExceptions['z'] = TRUE;
        VerbExceptions['t'] = TRUE;
        VerbExceptions['G'] = TRUE;
        VerbExceptions['g'] = TRUE;
        VerbExceptions['w'] = TRUE;
        VerbExceptions['x'] = TRUE;
        VerbExceptions['y'] = TRUE;
        VerbExceptions['z'] = TRUE;
        VerbExceptions['W'] = TRUE;
        VerbExceptions['X'] = TRUE;
        VerbExceptions['Y'] = TRUE;
        VerbExceptions['Z'] = TRUE;
        */
        }

    unsigned index = InterlockedIncrement(&NextEvent);

    index %= EventArrayLength;

    RpcEvents[index].Time            = GetTickCount();
    RpcEvents[index].Verb            = Verb;
    RpcEvents[index].Subject         = Subject;
    RpcEvents[index].Thread          = (short) GetCurrentThreadId();
    RpcEvents[index].SubjectPointer  = SubjectPointer;
    RpcEvents[index].ObjectPointer   = ObjectPointer;
    RpcEvents[index].Data            = Data;
    RpcEvents[index].EventStackTrace[0] = NULL;
    RpcEvents[index].EventStackTrace[1] = NULL;
    RpcEvents[index].EventStackTrace[2] = NULL;
    RpcEvents[index].EventStackTrace[3] = NULL;

    CallTestHook( TH_RPC_LOG_EVENT, &RpcEvents[index], 0 );

#ifdef RPC_ENABLE_WMI_TRACE
    if (WmiTraceData.EnableFlags)
        {
        TraceMessage(
                      WmiTraceData.LoggerHandle,
                      TRACE_MESSAGE_SEQUENCE   | TRACE_MESSAGE_GUID | TRACE_MESSAGE_SYSTEMINFO | TRACE_MESSAGE_TIMESTAMP,
                      &WmiMessageGuid,
                      Verb,
                      LOG_VAR(Subject),
                      LOG_VAR(SubjectPointer),
                      LOG_VAR(ObjectPointer),
                      LOG_VAR(Data),
                      0
                      );
        }
#endif

    if (fCaptureStackTrace)
        {
        ULONG ignore;

        RtlCaptureStackBackTrace(
                                 1 + AdditionalFramesToSkip,
                                 STACKTRACE_DEPTH,
                                 (void **) &RpcEvents[index].EventStackTrace,
                                 &ignore);
        }
    else
        {
        RpcEvents[index].EventStackTrace[0] = 0;
        }

    if (hLogFile)
        {
        DWORD BytesWritten;

        /*
        RPC_EVENT_LOG logEntry;
        RPC_EVENT *CurrentEvent = &RpcEvents[index];
        logEntry.Thread = CurrentEvent->Thread;
        logEntry.ZeroSet = 0;
        logEntry.Subject = CurrentEvent->Subject;
        logEntry.Verb = CurrentEvent->Verb;
        logEntry.Data = CurrentEvent->Data;
        logEntry.ObjectPointer = CurrentEvent->ObjectPointer;
        logEntry.SubjectPointer = CurrentEvent->SubjectPointer;
        memcpy(logEntry.EventStackTrace, CurrentEvent->EventStackTrace, sizeof(logEntry.EventStackTrace));
        WriteFile(hLogFile, &logEntry, sizeof(logEntry), &BytesWritten, NULL);
        */
        WriteFile(hLogFile, &RpcEvents[index], sizeof(RpcEvents[index]), &BytesWritten, NULL);
        }
}

void RPC_ENTRY
I_RpcLogEvent (
    IN unsigned char Subject,
    IN unsigned char Verb,
    IN void *        SubjectPointer,
    IN void *        ObjectPointer,
    IN unsigned      Data,
    IN BOOL          fCaptureStackTrace,
    IN int           AdditionalFramesToSkip
    )
{
    LogEvent(Subject, Verb, SubjectPointer, ObjectPointer, Data,
             fCaptureStackTrace, AdditionalFramesToSkip);
}

#if 0

BOOL
IsLoggingEnabled()
{
    RPC_CHAR ModulePath[ MAX_PATH ];
    RPC_CHAR * ModuleName;

    //
    // Find out the .EXE name.
    //
    if (!GetModuleFileName( NULL, ModulePath, sizeof(ModulePath)))
        {
        return FALSE;
        }

    signed i;
    for (i=RpcpStringLength(ModulePath)-1; i >= 0; --i)
        {
        if (ModulePath[i] == '\\')
            {
            break;
            }
        }

    ModuleName = ModulePath + i + 1;

    //
    // See whether logging should be enabled.
    //
    HANDLE hImeo;
    HANDLE hMyProcessOptions;
    DWORD Error;
    DWORD Value;
    DWORD Length = sizeof(Value);
    DWORD Type;

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          RPC_CONST_STRING("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options"),
                          0,
                          KEY_READ,
                          &hImeo
                          );
    if (Error)
        {
        return FALSE;
        }

    Error = RegOpenKeyEx( hImeo,
                          ModuleName,
                          0,
                          KEY_READ,
                          &hMyProcessOptions
                          );
    RegCloseKey( hImeo );

    if (Error)
        {
        return FALSE;
        }

    Error = RegQueryValueEx( hMyProcessOptions,
                             RPC_CONST_STRING("Enable RPC Logging"),
                             0,
                             &Type,
                             &Value,
                             &Length
                             );

    RegCloseKey( hMyProcessOptions );

    if (Error)
        {
        return FALSE;
        }

    if (Type == REG_DWORD && Value)
        {
        return TRUE;
        }

    if (Type == REG_SZ && 0 == RpcpStringCompare((RPC_CHAR *) Value, RPC_CONST_CHAR('Y')))
        {
        return TRUE;
        }

    return FALSE;
}

#endif

extern "C" int __cdecl _purecall(void)
{
#ifdef DEBUGRPC
    ASSERT(!"PureVirtualCalled");
#endif
    return 0;
}

PUNICODE_STRING
FastGetImageBaseNameUnicodeString (
    void
    )
/*++
Routine Description

    Retrieves the image base name with touching minimal amount of
    other memory.  Returns a UNICODE_STRING structure.

Arguments:


Return Value:

    A pointer to LDR private UNICODE_STRING  string with the image name.
    Don't write or delete it!

--*/
{
    PLIST_ENTRY Module;
    PLDR_DATA_TABLE_ENTRY Entry;

    Module = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink;
    Entry = CONTAINING_RECORD(Module,
                                LDR_DATA_TABLE_ENTRY,
                                InLoadOrderLinks);

    return &(Entry->BaseDllName);
}

const RPC_CHAR *
FastGetImageBaseName (
    void
    )
/*++
Routine Description

    Retrieves the image base name with touching minimal amount of
    other memory.

Arguments:


Return Value:

    A pointer to LDR private string with the image name. Don't write or
    delete it!

--*/
{
    return (FastGetImageBaseNameUnicodeString())->Buffer;
}

//
// RPC Verifier utility functions
//

unsigned int
RndInteger (
    void
    )
/*++

Routine Description:

    A private fast implementation of a congruential random
    number generator.  We do not really care about its being
    "good" and use the results for fault injeciton.

Return Value:

    A "random" integer between 0 and UINT_MAX

--*/
{
    static BOOL fInit;
    static unsigned short nCalls;
    static unsigned long seed;
    RPC_STATUS Status;

    if (fInit == false || nCalls > 1000)
        {
        fInit = true;
        nCalls = 0;

        // Get a seed as a "true" random number.
        Status = GenerateRandomNumber((unsigned char *)&seed, sizeof(unsigned long));
        if (Status != RPC_S_OK)
            {
            // On failure, still try to get some entropy.
            ASSERT(Status == RPC_S_OUT_OF_MEMORY);
            seed = GetTickCount();
            }
        }

    // Use a simple Pi-enspired congruence f-la.
    seed = 3141592653 * seed + 2718281829;

    VERIFIER_DBG_PRINT_1("RndInteger() returned 0x%x\n", seed);

    return seed;
}

inline BOOL
RndBool(
    unsigned int Prob
    )
/*++

Routine Description:

    Generates a boolean with probability of True Prob/10000

Return Value:

    A boolean with the given probability of truth

--*/
{
    BOOL ret = RndInteger() < Prob*(0xffffffff/10000);
    VERIFIER_DBG_PRINT_1("RndBool() returned %d\n", ret);
    return (ret);
}

// Rounding of an unsigned float.
#define URound(f) (unsigned int)(f+0.5)

inline unsigned int RndIntegerInRange(
    unsigned int min,
    unsigned int max
    )
/*++

Routine Description:

    Returns a random integer from min to max.
    The distribution of the possible value is uniform.

Return Value:

    A random integer within a given range

--*/
{
    unsigned int ret = min + URound( (float)(max-min) * ((float)RndInteger() / (float)0xffffffff) );
    VERIFIER_DBG_PRINT_3("RndIntegerInRange(0x%x, 0x%x) returned 0x%x\n", min, max, ret);
    return (ret);
}

#define BitFlip(arg,pos) ((arg) ^ (1L << (pos)))

inline void
RndBitFlip(
    unsigned char *addr,
    unsigned int len
    )
/*++

Routine Description:

    Flips one bit in each of len bytes starting at addr

Return Value:

    None

--*/
{
    for (unsigned int d = 0; d<len; d++)
        {
        unsigned char bit = (unsigned char)RndIntegerInRange(1,8);
        VERIFIER_DBG_PRINT_2("RndBitFlip() flipping bit %u at address 0x%x\n", bit, &(addr[d]));
        addr[d] = BitFlip(addr[d], bit);
        }
}

inline void
RndIncDec(
    unsigned char *addr,
    unsigned int len
    )
/*++

Routine Description:

    Flips one bit in each of len bytes starting at addr

Return Value:

    None

--*/
{
    for (unsigned int d = 0; d<len; d++)
        {
        if (RndBool(5000))
            {
            addr[d]++;
            VERIFIER_DBG_PRINT_1("RndIncDec() inc byte at address 0x%x\n", &(addr[d]));
            }
        else
            {
            addr[d]--;
            VERIFIER_DBG_PRINT_1("RndIncDec() dec byte at address 0x%x\n", &(addr[d]));
            }
        }
}

void
CorruptBuffer(
    unsigned int BufferLength,
    unsigned char *Buffer
    )
/*++

Routine Description:

    Corrupts the buffer in accordance with the RPC verifier settings.

Return Value:

    none

--*/
{
    unsigned int Size;
    unsigned int Start;

    VERIFIER_DBG_PRINT_2("CorruptBuffer() length=%d buffer=0x%x\n",
                         BufferLength, Buffer);

    // Determine the size of the corruption.
    if (pRpcVerifierSettings->CorruptionSizeType == FixedSize)
        {
        Size = pRpcVerifierSettings->CorruptionSize;
        }
    else if (pRpcVerifierSettings->CorruptionSizeType == RandomSize)
        {
        Size = RndIntegerInRange(1, min(pRpcVerifierSettings->CorruptionSize,BufferLength));
        }
    else
        {
        ASSERT(0 && "Unexpected CorruptionSizeType\n");
        }

    // Determine the start of the corruption.
    Start = RndIntegerInRange(0, BufferLength-Size);

    VERIFIER_DBG_PRINT_2("CorruptBuffer() Size=%d Start=%d\n",
                         Size, Start);

    if (pRpcVerifierSettings->CorruptionPattern == ZeroOut)
        {
        // For localized corruption, zero out random block of size Size.
        if (pRpcVerifierSettings->CorruptionDistributionType == LocalizedDistribution)
            {
            RtlZeroMemory((PVOID)(Buffer+Start), Size);
            }
        // For randomized corruption, zero out Size random bytes from the buffer.
        else
            {
            for (unsigned int i=0; i<Size; i++)
                {
                Buffer[RndIntegerInRange(0, BufferLength-1)] = 0;
                }
            }
        }
    else if (pRpcVerifierSettings->CorruptionPattern == Negate)
        {
        // For localized corruption, negate random block of size Size.
        if (pRpcVerifierSettings->CorruptionDistributionType == LocalizedDistribution)
            {
            for (unsigned int i = 0; i<Size; i++)
                {
                Buffer[Start+i] = 0xff;
                }
            }
        // For randomized corruption, negate Size random bytes from the buffer.
        else
            {
            for (unsigned int i=0; i<Size; i++)
                {
                Buffer[RndIntegerInRange(0, BufferLength-1)] = 0xff;
                }
            }
        }
    else if (pRpcVerifierSettings->CorruptionPattern == BitFlip)
        {
        // For localized corruption, flip bits on Size consecutive bytes.
        if (pRpcVerifierSettings->CorruptionDistributionType == LocalizedDistribution)
            {
            RndBitFlip(Buffer+Start, Size);
            }
        // For randomized corruption, flip random bits in Size bytes all over the buffer.
        else
            {
            for (unsigned int i=0; i<Size; i++)
                {
                RndBitFlip(Buffer + RndIntegerInRange(0, BufferLength-1),1);
                }
            }
        }
    else if (pRpcVerifierSettings->CorruptionPattern == IncDec)
        {
        // For localized corruption, increment or decrement Size consecutive bytes.
        if (pRpcVerifierSettings->CorruptionDistributionType == LocalizedDistribution)
            {
            RndIncDec(Buffer+Start, Size);
            }
        // For randomized corruption, inc/dec Size bytes all over the buffer.
        else
            {
            for (unsigned int i=0; i<Size; i++)
                {
                RndIncDec(Buffer + RndIntegerInRange(0, BufferLength-1),1);
                }
            }
        }
    else if (pRpcVerifierSettings->CorruptionPattern == Randomize)
        {
        // For localized corruption distribution, randomize block of size Size.
        if (pRpcVerifierSettings->CorruptionDistributionType == LocalizedDistribution)
            {
            for (unsigned int i = 0; i<Size; i++)
                {
                Buffer[Start+i] = (unsigned char) RndInteger();
                }
            }
        // For randomized corruption distribution, randomize Size bytes all over the buffer.
        else
            {
            for (unsigned int i=0; i<Size; i++)
                {
                Buffer[RndIntegerInRange(0, BufferLength-1)] = (unsigned char) RndInteger();
                }
            }
        }
    else if (pRpcVerifierSettings->CorruptionPattern == AllPatterns)
        {
        // Choose a random pattern of corrupion only for the duration of this call.
        // This may affect other corruptions taking place, but it's OK since the overal
        // bahavior is correct.
        pRpcVerifierSettings->CorruptionPattern = (tCorruptionPattern)RndIntegerInRange(MIN_CORRUPTION_PATTERN_ID,
                                                                                        MAX_CORRUPTION_PATTERN_ID);
        CorruptBuffer(BufferLength, Buffer);
        pRpcVerifierSettings->CorruptionPattern = AllPatterns;
        }
    else
        {
        ASSERT(0 && "Unexpected CorruptionPattern\n");
        }
}

void
CorruptionInject(
    tBufferType BufferType,
    unsigned int *pBufferLength,
    void **pBuffer
    )
/*++

Routine Description:

    Injects corruption into a buffer if necesssary.
    Injection is done according to the RPC verifier settings for this buffer type.

Return Value:

    none

--*/
{
    BOOL fSecure = false;
    void *Buffer = *pBuffer;
    unsigned int BufferLength = *pBufferLength;

    VERIFIER_DBG_PRINT_3("CorruptionInject() type=%d length=%d buffer=0x%x\n",
                         BufferType, *pBufferLength, *pBuffer);

    // Check if there is a buffer to corrupt and if
    // this type of buffer should have corruption injected into it.
    if (*pBuffer
        && ((BufferType == ServerReceive && pRpcVerifierSettings->fCorruptionInjectServerReceives) ||
            (BufferType == ClientReceive && pRpcVerifierSettings->fCorruptionInjectClientReceives)))
        {
        // If yes, corrupt the buffer if necessary.

        // First, we will try to truncate the buffer.
        if (pRpcVerifierSettings->ProbBufferTruncation &&
            RndBool(pRpcVerifierSettings->ProbBufferTruncation))
            {
            VERIFIER_DBG_PRINT_0("CorruptionInject() - truncating the buffer\n");

            // We truncate OSF buffers only.  The scenario is not interesting
            // for DG.  The way we can tell the difference between the two types of packets
            // is by the header.
            // For OSF the packet header will look like:
            //  rpcconn_common
            //      +0x000 rpc_vers         : 5
            //      +0x001 rpc_vers_minor   : 0
            // For DG it will be:
            //  NCA_PACKET_HEADER
            //      +0x000 RpcVersion       : 0x4
            //      +0x001 PacketType       : 0
            // So we just want the first 2 bytes to be 5,0.
            if (BufferLength >= sizeof(rpcconn_common) &&
                ((unsigned short)*((unsigned char*)Buffer + 0x0) == 5 &&
                 (unsigned short)*((unsigned char*)Buffer + 0x1) == 0
                )
               )
                {
                unsigned short NewBufferLength = BufferLength - RndIntegerInRange(1, pRpcVerifierSettings->MaxBufferTruncationSize);
                NewBufferLength = max(NewBufferLength, sizeof(rpcconn_common));

                // We have a connection-oriented buffer - truncate it.
                I_RpcTransConnectionReallocPacket(
                    NULL, // The connection argument is ignored by the realloc routine.
                    pBuffer,
                    *pBufferLength,
                    NewBufferLength);

                VERIFIER_DBG_PRINT_3("CorruptionInject() - truncated buffer 0x%x from 0x%x to 0x%x\n",
                                     *pBuffer,
                                     *pBufferLength,
                                     NewBufferLength);

                // Update the buffer size so that the right value is seen by the caller.
                Buffer = *pBuffer;
                *pBufferLength = NewBufferLength;
                BufferLength = NewBufferLength;

                // Adjust the frag_length so that it is equal to the new packetlength.
                // We need to do this since the runtime relies on these being in agreement and the
                // transports guarantee it.
                *((unsigned int*)((unsigned char*)Buffer + 0x8)) = BufferLength;
                }
            }

        // After the buffer has been truncated, we may corrupt it.

        // Check if we can corrupt the RPC header section.
        if (RndBool(pRpcVerifierSettings->ProbRpcHeaderCorruption))
            {
            // Corrupt it if we can.
            CorruptBuffer(
                min(sizeof(rpcconn_common),BufferLength), // This will mostly whack the common RPC header.
                (unsigned char *)Buffer);
            }

        //
        // Determine whether this is a secure buffer.
        // The way we tell is by looking for the signature of rpcconn_common.auth_length != 0.
        // We will query this field directly, using the following offsets:
        //
        // rpcconn_common
        //  +0x000 rpc_vers         : UChar
        //  ...
        //  +0x008 frag_length      : Uint2B
        //  +0x00a auth_length      : Uint2B
        //  +0x00c call_id          : Uint4B
        //
        // This may falsely count some packets as secure occasionally,
        // say in the case of fragmentation, but we can take this downside and the benefits of
        // a compact check outweigh it.
        //
        fSecure = ( (BufferLength > sizeof(rpcconn_common)) &&
                    ((unsigned short)*((unsigned char*)Buffer + 0xa) != 0) );

        VERIFIER_DBG_PRINT_1("CorruptionInject() fSecure=%d\n", fSecure);

        // Check if we can corrupt the Data section.
        if ((!fSecure && RndBool(pRpcVerifierSettings->ProbDataCorruption)) ||
            (fSecure && RndBool(pRpcVerifierSettings->ProbSecureDataCorruption)))
            {
            // Corrupt it if we can.
            CorruptBuffer(
                BufferLength,
                (unsigned char *)Buffer);
            }
        }
}

#define MAX_STACK_TRACE 8

PVOID LastEventStackTrace[MAX_STACK_TRACE];

void
PrintCurrentStackTrace(
    unsigned int FramesToSkip,
    unsigned int Size
    )
/*++

Routine Description:

    Prints a stack trace of Size frames after the first FramesToSkip frames.
    Only the addresses are printed since there is no way to get to the
    symbolic information from here.

Return Value:

    none

--*/
{
    Size = min (Size, MAX_STACK_TRACE);
    PVOID *EventStackTrace = (PVOID *)alloca(Size*sizeof(PVOID));

    // Capture and print the stack trace.
    RtlCaptureStackBackTrace(FramesToSkip,
                             Size,
                             EventStackTrace,
                             NULL);

    for (unsigned int i=0; i<Size; i++)
        {
        DbgPrint("\t0x%x\n", EventStackTrace[i]);
        }

    // To simplify debugging, save the local stack trace into a global variable.
    memcpy(LastEventStackTrace, EventStackTrace, Size*sizeof(PVOID));
}

void
PrintUUID(
    GUID *Uuid
    )
/*++

Routine Description:

    Prints a UUID

Return Value:

    none

--*/
{
    unsigned long *Data = (unsigned long *)Uuid;

    if ((Data[0] == 0) &&
        (Data[1] == 0) &&
        (Data[2] == 0) &&
        (Data[3] == 0))
        {
        DbgPrint("(Null Uuid)");
        }
    else
        {
        DbgPrint("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                 Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1],
                 Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5],
                 Uuid->Data4[6], Uuid->Data4[7] );
        }
}

//
// Per-interface security check exemption settings.
//

// The structure mapping an interface onto a flag.
// An array of these defines interfaces exempt from some of the rpc verifier checks.
typedef struct _tRpcVerifierIfExemption
    {
    GUID IfUuid; // An interface UUID.
    DWORD ExemptionFlags; // Which security checks are to be disabled.
    } tRpcVerifierIfExemption;

//
// This is a list of interface UUID's exempt from some or all checks.
// We match the interfaces by their syntax GUIDs.
//
const tRpcVerifierIfExemption RpcVerifierExemptInterfaces[] = {
    // 000001A0-0000-0000-C000-000000000046
    // ok to be remotely accessible, not secured, clear text traffic and no mutual authentication.
    {{0x000001A0, 0x0000, 0x0000, {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46}}, ALLOW_EVERYTHING},
    // 12345678-1234-ABCD-EF00-01234567CFFB
    // Netlogon implements its own authentication protocol via the NetrServerReqChallenge 
    // and NetrServerAuthenticate3 rpc calls.  These rpc calls happen without packet privacy and result
    // in the servers being mutually authenticated and a key exchange between client and server.
    // After that all calls use privacy via the netlogon package.
    {{0x12345678, 0x1234, 0xABCD, {0xEF, 0x00, 0x01, 0x23, 0x45, 0x67, 0xCF, 0xFB}}, ALLOW_NO_MUTUAL_AUTH_REMOTE_ACCESS|ALLOW_UNENCRYPTED_REMOTE_ACCESS},
    // 338cd001-2244-31f1-aaaa-900038001003
    // ok to be remotely accessible, not secured. It uses an access check in the server routine instead
    // of a callback because it must support downlevel clients which used native named pipes transport security.
    {{0x338cd001, 0x2244, 0x31f1, {0xaa, 0xaa, 0x90, 0x00, 0x38, 0x00, 0x10, 0x03}}, ALLOW_EVERYTHING},
    // 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
    // ok to be remotely accessible, not secured, clear text traffic and no mutual authentication.
    {{0x4d9f4ab8, 0x7d1c, 0x11cf, {0x86, 0x1e, 0x00, 0x20, 0xaf, 0x6e, 0x7c, 0x57}}, ALLOW_EVERYTHING},
    // 99fcfec4-5260-101b-bbcb-00aa0021347a
    // ok to be remotely accessible, not secured, clear text traffic and no mutual authentication.
    {{0x99fcfec4, 0x5260, 0x101b, {0xbb, 0xcb, 0x00, 0xaa, 0x00, 0x21, 0x34, 0x7a}}, ALLOW_EVERYTHING},
    // e1af8308-5d1f-11c9-91a4-08002b14a0fa
    // ok to be remotely accessible, not secured, clear text traffic and no mutual authentication.
    {{0xe1af8308, 0x5d1f, 0x11c9, {0x91, 0xa4, 0x08, 0x00, 0x2b, 0x14, 0xa0, 0xfa}}, ALLOW_EVERYTHING},
    // e60c73e6-88f9-11cf-9af1-0020af6e72f4
    // ok to be remotely accessible, not secured, clear text traffic and no mutual authentication.
    {{0xe60c73e6, 0x88f9, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}}, ALLOW_EVERYTHING},

    // We make all of the locator interfaces exempt.  There will be a message
    // on locator start-up giving a warning for the service as a whole.
    // Also, the locator server manager routines will be protected in the user code.
    // e33c0cc4-0482-101a-bc0c-02608c6ba218 - LocToLoc
    {{0xe33c0cc4, 0x0482, 0x101a, {0xbc, 0x0c, 0x02, 0x60, 0x8c, 0x6b, 0xa2, 0x18}}, ALLOW_EVERYTHING},
    // d3fbb514-0e3b-11cb-8fad-08002b1d29c3 - NsiC
    {{0xd3fbb514, 0x0e3b, 0x11cb, {0x8f, 0xad, 0x08, 0x00, 0x2b, 0x1d, 0x29, 0xc3}}, ALLOW_EVERYTHING},
    // d6d70ef0-0e3b-11cb-acc3-08002b1d29c4 - NsiM
    {{0xd6d70ef0, 0x0e3b, 0x11cb, {0xac, 0xc3, 0x08, 0x00, 0x2b, 0x1d, 0x29, 0xc4}}, ALLOW_EVERYTHING},
    // d6d70ef0-0e3b-11cb-acc3-08002b1d29c3 - NsiS
    {{0xd6d70ef0, 0x0e3b, 0x11cb, {0xac, 0xc3, 0x08, 0x00, 0x2b, 0x1d, 0x29, 0xc3}}, ALLOW_EVERYTHING},

    // The following lsa and sam interfaces are secure in virtue of using a well-known
    // endpoint and relying on the transport np security.
    // They can't use RPC security because of backward compatibility.
    // 12345778-1234-ABCD-EF00-0123456789AC - SAM
    {{0x12345778, 0x1234, 0xABCD, {0xEF, 0x00, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAC}}, ALLOW_EVERYTHING},
    // 12345778-1234-ABCD-EF00-0123456789AB - LSA
    {{0x12345778, 0x1234, 0xABCD, {0xEF, 0x00, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB}}, ALLOW_EVERYTHING},
    // 3919286a-b10c-11d0-9ba8-00c04fd92ef5 - dsrole.
    {{0x3919286a, 0xb10c, 0x11d0, {0x9b, 0xa8, 0x00, 0xc0, 0x4f, 0xd9, 0x2e, 0xf5}}, ALLOW_EVERYTHING},

    // The DFS interface can't use RPC security because of the compatibility considerations.
    // 4fc742e0-4a10-11cf-8273-00aa004ae673 - DFS
    {{0x4fc742e0, 0x4a10, 0x11cf, {0x82, 0x73, 0x00, 0xaa, 0x00, 0x4a, 0xe6, 0x73}}, ALLOW_EVERYTHING},

    // The licensing server is listening on the following interface.
    // This is a temp fix to be removed after .NET RC1 after which point the underlying bug will be fixed.
    // 2f59a331-bf7d-48cb-9e5c-7c090d76e8b8
    {{0x2f59a331, 0xbf7d, 0x48cb, {0x9e, 0x5c, 0x7c, 0x09, 0x0d, 0x76, 0xe8, 0xb8}}, ALLOW_EVERYTHING},

    // srvsvc.dll has backwards compatibility reasons preventing it from using encryption.
    // 4B324FC8-1670-01D3-1278-5A47BF6EE188
    {{0x4B324FC8, 0x1670, 0x01D3, {0x12, 0x78, 0x5A, 0x47, 0xBF, 0x6E, 0xE1, 0x88}}, ALLOW_UNENCRYPTED_REMOTE_ACCESS},

    // EFS has backwards compatibility considerations and were not able to fix the code on time.
    // c681d488-d850-11d0-8c52-00c04fd90f7e
    {{0xc681d488, 0xd850, 0x11d0, {0x8c, 0x52, 0x00, 0xc0, 0x4f, 0xd9, 0x0f, 0x7e}}, ALLOW_EVERYTHING}
};

BOOL
IsInterfaceExempt (
    IN GUID *IfUuid,
    IN DWORD CheckFlag
    )
/*++

Function Name: IsInterfaceExempt

Parameters:
    If - A UUID for the interface for which we want to look-up the exemption.
    CheckFlag - Flag for the check being tested for exemption.

Description:
    Verifies whether an interface is exempt from a particular security check.

Returns:
    TRUE - If an interface is exempt from a given check.
    FALSE - Otherwise.

--*/
{
    // Go through all exempt interfaces.
    for (int i=0; i<sizeof(RpcVerifierExemptInterfaces)/sizeof(tRpcVerifierIfExemption); i++)
        {
        // Check if one of them matches the provided UUID.
        if (RpcpMemoryCompare(&(RpcVerifierExemptInterfaces[i].IfUuid), IfUuid, sizeof(UUID)) == 0)
            {
            // If it does, check whether the exemption is enabled for the flag being queried.
            if (RpcVerifierExemptInterfaces[i].ExemptionFlags & CheckFlag)
                {
                return true;
                }
            else
                {
                return false;
                }
            }
        }
    // If we could not find the interface then it is not exempt from the check.
    return false;
}

//
// Unsafe protseqs detection.
//

// List of protocol sequences that are not actively used and are unsafe as a result.
const RPC_CHAR *RpcVerifierUnsafeProtseqs[] = {
    RPC_CONST_STRING("ncadg_ip_udp"),
    RPC_CONST_STRING("ncacn_spx"),
    RPC_CONST_STRING("ncacn_at_dsp")
};

BOOL
IsProtseqUnsafe (
    IN RPC_CHAR *ProtocolSequence
    )
/*++

Function Name: IsProtseqUnsafe

Parameters:
    ProtocolSequence - A string specifying the protseq to be checked for safety.

Description:
    Verifies whether a protseq is one of the rarely used and unsafe ones.

Returns:
    TRUE - The protseq specified is unsafe.
    FALSE - Otherwise.

--*/
{
    // Go through all the unsafe protseqs.
    for (int i=0; i<sizeof(RpcVerifierUnsafeProtseqs)/sizeof(const RPC_CHAR *); i++)
        {
        // Check if one of them matches the provided protocol.
        if (RpcpStringNCompare(RpcVerifierUnsafeProtseqs[i],
                               ProtocolSequence,
                               RpcpStringLength(RpcVerifierUnsafeProtseqs[i])) == 0)
            {
            return true;
            }
        }
    // If none match, the protseq is safe.
    return false;
}

//
// Security-related utility functions
//

RPC_STATUS
IsCurrentUserAdmin(
    void
    )
/*++

Routine Description:

    Checks if the current thread's or process' token is that of an admin.

Return Value:

    RPC_S_OK - if the token is that of an admin.
    RPC_S_ACESS_DENIED - the user is not an admin or a failure occurred.

--*/
{
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID psidAdministrators = NULL;
    BOOL b;
    RPC_STATUS Status = RPC_S_OK;
    BOOL fIsMember = false;

    b = AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            );

    if(b)
        {
        // When TokenHandle is NULL, CheckTokenMembership uses
        // the impersonation token of the calling thread.
        // If the thread is not impersonating, the function duplicates
        // the thread's primary token to create an impersonation token. 
        b = CheckTokenMembership(NULL, psidAdministrators, &fIsMember);

        // Token is not that of an admin or token membership could
        // not be verified.
        if(!b || !fIsMember)
            {
            Status = RPC_S_ACCESS_DENIED;
            }
        }
    // We could not allocate a SID.
    else
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    if(psidAdministrators)
        FreeSid(psidAdministrators);

    return Status;
}

const SID LocalSystem = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID};
const SID LocalService = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SERVICE_RID};
const SID NetworkService = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_NETWORK_SERVICE_RID};
const RPC_SID2 Admin1 = { 1, 2, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\rtifs\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

NBASE_HDR =$(O)\nbase.h

MGMT_HDR  =$(O)\mgmt.h
MGMT_CSTUB=$(O)\mgmt_c.c
MGMT_SSTUB=$(O)\mgmt_s.c

CONV_HDR  =$(O)\conv.h
CONV_CSTUB=$(O)\conv_c.c
CONV_SSTUB=$(O)\conv_s.c

CONVC_HDR  =$(O)\convc.h
CONVC_CSTUB=$(O)\convc_c.c
CONVC_SSTUB=$(O)\convc_s.c

MQMGR_HDR  =$(O)\mqmgr.h
MQMGR_CSTUB=$(O)\mqmgr_c.c
MQMGR_SSTUB=..\epmap\$(O)\mqmgr_s.c

EPMP_HDR  =$(O)\epmp.h
EPMP_CSTUB=$(O)\epmp_c.c
EPMP_SSTUB=..\epmap\$(O)\epmp_s.c

DBGIDL_HDR  =$(O)\DbgIdl.h
DBGIDL_CSTUB=$(O)\DbgIdl_c.c
DBGIDL_SSTUB=..\epmap\$(O)\DbgIdl_s.c

EEINFO_HDR  =$(O)\EEInfo.h
EEINFO_CSTUB=$(O)\EEInfo_c.c

CPP_CMD = -cpp_cmd "$(MIDL_CPP)"
CPP_OPT = $(MIDL_FLAGS)

COMMON_FLAGS= $(MIDL_OPTIMIZATION_NT5) -no_stamp -c_ext -ms_ext -I..\mtrt;$(BASEDIR)\public\sdk\inc -oldnames -DNTENV $(CPP_CMD) $(CPP_OPT)

EPMP_FLAGS= $(COMMON_FLAGS:-protocol all=) 

clean: delsrc allidl

delsrc:
    -del $(MGMT_HDR)  $(MGMT_CSTUB)  $(MGMT_SSTUB)  \
         $(CONV_HDR)  $(CONV_CSTUB)  $(CONV_SSTUB)  \
         $(EPMP_HDR)  $(EPMP_CSTUB)  $(EPMP_SSTUB)  \
         $(MQMGR_HDR) $(MQMGR_CSTUB) $(MQMGR_SSTUB) \
         $(EEINFO_HDR) $(EEINFO_CSTUB) \
         $(DBGIDL_HDR) $(DBGIDL_CSTUB) $(DBGIDL_SSTUB) >nul 2>&1

allidl: dirs nbase mgmt epmp conv mqmgr convc dbgidl eeinfo

dirs: ..\epmap\$(O) $(O)

$(O):
    md $@
    
..\epmap\$(O):
    md $@

#
# Common DCE types, imported into all the other .idls
#

nbase: $(NBASE_HDR)

$(NBASE_HDR): nbase.idl
        midl $(COMMON_FLAGS) -server none -client none -header $(NBASE_HDR)\
        nbase.idl

#
# Remote RPC Management APIs
#
mgmt: $(MGMT_HDR) $(MGMT_CSTUB) $(MGMT_SSTUB)

$(MGMT_HDR) $(MGMT_CSTUB) $(MGMT_SSTUB) : mgmt.idl mgmt.acf nbase.idl
        midl $(COMMON_FLAGS) -prefix client _ \
         -cstub $(MGMT_CSTUB) -sstub $(MGMT_SSTUB) -header $(MGMT_HDR) mgmt.idl

#
# Conversation interface - datagram callback to verify client id.
#
conv: $(CONV_HDR) $(CONV_CSTUB) $(CONV_SSTUB)

$(CONV_HDR) $(CONV_CSTUB) $(CONV_SSTUB) : conv.idl nbase.idl
        midl $(COMMON_FLAGS) -prefix client _ \
         -cstub $(CONV_CSTUB) -sstub $(CONV_SSTUB) -header $(CONV_HDR) conv.idl

#
# Client Conversation interface - datagram context handle keep-alives.
#
convc: $(CONVC_HDR) $(CONVC_CSTUB) $(CONVC_SSTUB)

$(CONVC_HDR) $(CONVC_CSTUB) $(CONVC_SSTUB) : convc.idl nbase.idl
        midl $(COMMON_FLAGS) -prefix client _ \
         -cstub $(CONVC_CSTUB) -sstub $(CONVC_SSTUB) -header $(CONVC_HDR) convc.idl

#
# Endpoint mapper interface
#
epmp: $(EPMP_HDR) $(EPMP_CSTUB) $(EPMP_SSTUB)

$(EPMP_HDR) $(EPMP_CSTUB) : epmp.idl epmp.acf nbase.idl
        midl $(EPMP_FLAGS) -header $(EPMP_HDR) -cstub $(EPMP_CSTUB) -server none -D_CLIENT_PASS_ epmp.idl

$(EPMP_SSTUB) : $(EPMP_HDR)
        midl $(EPMP_FLAGS) -header $(EPMP_HDR) -sstub $(EPMP_SSTUB) -client none -D_SERVER_PASS_ epmp.idl

#
# MQ Management Interface (for temporary queues):
#
mqmgr: $(MQMGR_HDR) $(MQMGR_CSTUB) $(MQMGR_SSTUB)

$(MQMGR_HDR) $(MQMGR_CSTUB) $(MQMGR_SSTUB) : mqmgr.idl mqmgr.acf nbase.idl
        midl $(COMMON_FLAGS) \
        -cstub $(MQMGR_CSTUB) -sstub $(MQMGR_SSTUB) -header $(MQMGR_HDR) mqmgr.idl

#
# DbgIdl interface (for enhanced debugging):
#
dbgidl: $(DBGIDL_HDR) $(DBGIDL_CSTUB) $(DBGIDL_SSTUB)

$(DBGIDL_HDR) $(DBGIDL_CSTUB) $(DBGIDL_SSTUB) : DbgIdl.idl nbase.idl
        midl $(COMMON_FLAGS) \
        -cstub $(DBGIDL_CSTUB) -sstub $(DBGIDL_SSTUB) -header $(DBGIDL_HDR) DbgIdl.idl

#
# EEInfo interface (for extended error information):
#
eeinfo: $(EEINFO_HDR) $(EEINFO_CSTUB)

$(EEINFO_HDR) $(EEINFO_CSTUB) : EEInfo.idl nbase.idl
        midl $(COMMON_FLAGS) \
        -cstub $(EEINFO_CSTUB) -server none -header $(EEINFO_HDR) EEInfo.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\wmlum.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlum.h

Abstract:

    User mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved


--*/
#ifndef WMLUM_H
#define WMLUM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WMILIB_REG_STRUCT
{
    TRACEHANDLE LoggerHandle;
    ULONG EnableFlags;
    ULONG EnableLevel;

    struct _WMILIB_REG_STRUCT* Next;
    TRACEHANDLE RegistrationHandle;
} WMILIB_REG_STRUCT, *PWMILIB_REG_STRUCT;

typedef PWMILIB_REG_STRUCT WMILIB_REG_HANDLE;

typedef void (*WMILIBPRINTFUNC)(UINT Level, PCHAR String);

ULONG
WmlInitialize(
    IN LPWSTR ProductName,
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*,
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT
    );

VOID
WmlUninitialize(
    IN WMILIB_REG_HANDLE
    );

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

typedef
ULONG
(*PWML_INITIALIZE)(
    IN LPWSTR ProductName,
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*,
    ...
    );

typedef
VOID
(*PWML_UNINITIALIZE)(
    IN WMILIB_REG_HANDLE);

typedef
ULONG
(*PWML_TRACE)(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ...
    );

typedef
struct _WML_DATA {

    PWML_TRACE        Trace;
    PWML_INITIALIZE   Initialize;
    PWML_UNINITIALIZE Uninitialize;

    WMILIB_REG_HANDLE WmiRegHandle;
    HINSTANCE         WmlDllInstance;

} WML_DATA;


#define LOADWML(status, wml) \
    do \
    { \
        HINSTANCE hInst = LoadLibrary(L"wmlum.dll"); \
        (wml).WmlDllInstance = hInst; \
        if (!hInst) { \
            status = GetLastError(); \
        } else { \
            (wml).Trace        =        (PWML_TRACE) GetProcAddress(hInst, "WmlTrace"); \
            (wml).Initialize   =   (PWML_INITIALIZE) GetProcAddress(hInst, "WmlInitialize"); \
            (wml).Uninitialize = (PWML_UNINITIALIZE) GetProcAddress(hInst, "WmlUninitialize"); \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
        } \
    } \
    while(0)

#define UNLOADWML(wml) \
    do \
    { \
        if ( (wml).Uninitialize ) { \
            (wml).Uninitialize( (wml).WmiRegHandle ); \
        } \
        if ( (wml).WmlDllInstance ) { \
            FreeLibrary( (wml).WmlDllInstance ); \
        } \
        RtlZeroMemory( &(wml) , sizeof(WML_DATA) ); \
    } \
    while(0)

#ifdef __cplusplus
};
#endif

#endif // WMLUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\uclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 2000


Module Name:

    uclnt.cxx

Abstract:

    This module is half of the build verification for the RPC runtime;
    the other half can be found in the file usvr.cxx.  These two
    executables (uclnt.exe and usvr.exe) work together to test all
    runtime APIs.

Author:

    Michael Montague (mikemon) 01-Jan-1990

Revision History:

--*/

#include <precomp.hxx>
#include <osfpcket.hxx>
#include <ntsecapi.h>
#include <lm.h>

#include "pipe.h"
#include "astub.h"

#define UCLNT

#define swaplong(Value)

#define swapshort(Value)

#define EXPORT

#include <sysinc.h>

#include <rpc.h>
#include <rpcdcep.h>

#include <rpcndr.h>

BOOL  IsWMSG = FALSE ;

extern RPC_CLIENT_INTERFACE HelgaInterfaceInformation ;


/*
Transports:

    Update this to add a new transport.
*/

#define RPC_TRANSPORT_NAMEPIPE  1
#define RPC_LRPC                2
#define RPC_TRANSPORT_TCP       3
#define RPC_TRANSPORT_DNET      4
#define RPC_TRANSPORT_NETBIOS   5
#define RPC_TRANSPORT_SPX       6
#define RPC_TRANSPORT_UDP       7
#define RPC_TRANSPORT_IPX       8
#define RPC_TRANSPORT_DSP       9
#define RPC_TRANSPORT_VNS       10
#define RPC_WMSG                11
#define RPC_TRANSPORT_MSMQ      12

//
// constants
//

#define RETRYCOUNT 10
#define RETRYDELAY 500L

#define LONG_TESTDELAY 10000L

#define EXTENDED_ERROR_EXCEPTION 77777

//
// global variables
//

long TestDelay = 3000L;
int  NumberOfTestsRun = 0;
static unsigned long DefaultThreadStackSize = 0;
BOOL fNonCausal = 0;

unsigned long HelgaMaxSize = 0xffffffff;

unsigned int NoCallBacksFlag = 0;
unsigned int UseEndpointMapperFlag = 0;
unsigned int MaybeTests      = 0;
unsigned int IdempotentTests = 0;
unsigned int BroadcastTests  = 0;
unsigned int NoSecurityTests = 0;
unsigned int HackForOldStubs = 0;
unsigned int DatagramTests   = 0;
unsigned int fUniqueBinding  = 0;

int Subtest = 0;
int Verbose = 0;
int IFSecurityFlag = 0;

int AutoListenFlag = 1;

char *SecurityUser     = NULL;
char *SecurityDomain   = NULL;
char *SecurityPassword = NULL;
char *gPrincName = NULL;

unsigned long ulSecurityPackage = 10 ;
unsigned long TransportType;
unsigned int WarnFlag = 0; // Flag for warning messages.
unsigned int ErrorFlag = 1; // Flag for error messages.

char NetBiosProtocol[20] = "ncacn_nb_nb";  // NetBios transport protocol

char * Server ;

RPC_STATUS Status; // Contains the status of the last RPC API call.

/* volatile */ int fShutdown; // Flag indicating that shutdown should occur.

#define CHUNK_SIZE   50
#define NUM_CHUNKS 100
#define BUFF_SIZE 100

// if you change the type of the pipe element
// make sure you change the pull and push routines
// to correctly initialize the pipe element
typedef int pipe_element_t ;

typedef struct {
    void (PAPI *Pull) (
        char PAPI *state,
        pipe_element_t PAPI *buffer,
        int max_buf,
        int PAPI *size_to_send
        ) ;

    void (PAPI *Push) (
        char PAPI *state,
        pipe_element_t PAPI *input_buffer,
        int ecount
        ) ;

    void (PAPI *Alloc) (
        char PAPI *state,
        int requested_size,
        pipe_element_t PAPI * PAPI *allocate_buf,
        int PAPI *allocated_size
        ) ;

    char PAPI *state ;
    } pipe_t ;


static CRITICAL_SECTION TestMutex;

//
// forward declarations
//

void
DgTransport (
    int testnum
    );

void
SecurityErrorWrapper(
    int subtest
    );

DWORD
DumpEeInfo(
    int indentlevel
    );

DWORD
HelgaSendReceiveFailure (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                       // remote procedure call.
    int ProcNum
    );

int
FooSync (
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    );

//
// function definitions
//

void
TestMutexRequest (
    void
    )
{
    EnterCriticalSection(&TestMutex);
}

void
TestMutexClear (
    void
    )
{
    LeaveCriticalSection(&TestMutex);
}

void
ApiError ( // An API error occured; we just print a message.
    IN char * Routine, // The routine which called the API.
    IN char * API,
    IN RPC_STATUS status
    )
{
    if (ErrorFlag)
        {
        TestMutexRequest();
        PrintToConsole("    ApiError in %s (%s = %u)\n",Routine,API,status);
        TestMutexClear();
        }

   // _asm {int 3} ;
}

void
PauseExecution (
    unsigned long milliseconds
    )
{
    Sleep(milliseconds);
}

void
OtherError ( // Some other error occured; again, we just print a message.
    IN char * Routine, // The routine where the error occured.
    IN char * Message
    )
{
    if (ErrorFlag)
        {
        TestMutexRequest();
        PrintToConsole("    Error in %s (%s)\n",Routine,Message);
        TestMutexClear();
        }
}

unsigned int IsabelleErrors = 0;
unsigned int HelgaErrors = 0;
unsigned int SylviaErrors = 0;

void IsabelleError (
    )
{
    IsabelleErrors += 1 ;
}

void HelgaError (
    )
{
    HelgaErrors += 1 ;
}

void SylviaError (
    )
{
    SylviaErrors += 1 ;
}

#define SIGFRIED 0
#define ELLIOTMINIMIZE 1
#define ELLIOTMAXIMIZE 2
#define ELLIOTNORMAL 3
#define ANDROMIDA 4
#define FREDRICK 7
#define ISABELLENORMAL 10
#define ISABELLEMINIMIZE 11
#define ISABELLEMAXIMIZE 12
#define CHRISTOPHER 13
#define CHRISTOPHERHELGA 14
#define CHRISTOPHERISABELLE 15
#define TYLER 17
#define RICHARD 18
#define RICHARDHELPER 19
#define NOENDPOINT 20
#define DAVIDFIRST 21
#define DAVIDSECOND 22
#define BARTHOLOMEW 23
#define GRANT 24
#define HERMAN 25
#define IVAN 26
#define JASON 27
#define KENNETH 28
#define TESTYIELD 29
#define SPIPE TESTYIELD
#define SECURITY_ERROR TESTYIELD

/*
Transports:

    Update this to add a new transport.
*/

char * NamepipeAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    0,
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * DspAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    0,
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * TCPDefaultServer =
    "serverhost";
char * UDPDefaultServer =
    "serverhost";

char * NetBiosAddresses [] =
{
    "201",    // sigfried
    "202",    // elliotmi
    "203",    // elliotma
    "204",    // elliotno
    "205",    // andromno
    0,
    0,
    "206",    // fredrick
    0,
    0,
    "207",    // isabelno
    "208",    // isabelmi
    "209",    // isabelma
    "210",    // christ
    "211",    // zippyhe
    "212",    // zippyis
    0,
    "214",     // tyler
    "215",    // richard
    "216",    // richardh
    0,
    "217",    // david1
    "218",    // david2
    "219",    // bart
    "220",    // grant
    "221",    // herman
    "222",    // ivan
    "223",    // jason
    "224",     // kenneth
    "225"     // testyield
};

char * TCPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    0,
    "2045", //D1
    "2046", //D2
    "2047", // Bartholomew
    "2048", // Grant
    "2049", // Herman
    "2050", // Ivan
    "2051", // Jason
    "2052",  // Kenneth
    "2053"   // TestYield
};

char * UDPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    0,
    "2045", //D1
    "2046", //D2
    "2047", // Bartholomew
    "2048", // Grant
    "2049", // Herman
    "2050", // Ivan
    "2051", // Jason
    "2052",  // Kenneth
    "2053"  // TestYield
};

char * SPCAddresses [] =
{
    "sigfried",
    "elliotminimize",
    "elliotmaximize",
    "elliotnormal",
    "andromida",
    0,
    0,
    "fredrick",
    0,
    0,
    "isabellenormal",
    "isabelleminimize",
    "isabellemaximize",
    "christopher",
    "christopherhelga",
    "christopherisabelle",
    0,
    "tyler",
    "richard",
    "richardhelper",
     0,
    "davidfirst",
    "davidsecond",
    "bartholomew",
    "grant",
    "herman",
    "ivan",
    "jason",
    "kenneth",
    "testyield"
};

char * SPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "5020",    // richard
    "5021",    // richardh
    0,
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};

char * IPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "5020",    // richard
    "5021",    // richardh
    0,
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};

char * VNSAddresses [] =
{
    "250",    // sigfried
    "251",    // elliotmi
    "252",    // elliotma
    "253",    // elliotno
    "254",    // andromno
    "255",
    "256",
    "257",    // fredrick
    "258",
    "259",
    "260",    // isabelno
    "261",    // isabelmi
    "262",    // isabelma
    "263",    // christ
    "264",    // zippyhe
    "265",    // zippyis
    "266",
    "267",    // tyler
    "270",    // richard
    "271",    // richardh
    0,
    "272",    // david1
    "273",    // david2
    "274",    // bart
    "275",    // grant
    "276",    // herman
    "277",    // ivan
    "278",    // jason
    "279",     // kenneth
    "280"     // testyield
};

char * MSMQAddresses [] =
{
    "SIGFRIED",
    "ELLIOTMINIMIZE",
    "ELLIOTMAXIMIZE",
    "ELLIOTNORMAL",
    "ANDROMIDA",
    0,
    0,
    "FREDRICK",
    0,
    0,
    "ISABELLENORMAL",
    "ISABELLEMINIMIZE",
    "ISABELLEMAXIMIZE",
    "CHRISTOPHER",
    "CHRISTOPHERHELGA",
    "CHRISTOPHERISABELLE",
    0,
    "TYLER",
    "RICHARD",
    "RICHARDHELPER",
    0,
    "D1",
    "D2",
    "Bartholomew",
    "Grant",
    "Herman",
    "Ivan",
    "Jason",
    "Kenneth",
    "TestYield"
};


unsigned char PAPI *
GetStringBinding (
    IN unsigned int Address,
    IN char PAPI * ObjectUuid, OPTIONAL
    IN unsigned char PAPI * NetworkOptions OPTIONAL
    )
/*++

Routine Description:

    A string binding for the desired address is constructed.

Arguments:

    Address - Supplies an index into a table of endpoints.

    ObjectUuid - Optionally supplies the string representation of a UUID
        to be specified as the object uuid in the string binding.

    NetworkOptions - Optionally supplies the network options for this
        string binding.

Return Value:

    The constructed string binding will be returned.

Transports:

    Update this to add a new transport.

--*/
{
    unsigned char PAPI * StringBinding;

    if (TransportType == RPC_TRANSPORT_NAMEPIPE)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_np",
#ifdef WIN32RPC
                (unsigned char PAPI *) ((Server)? Server: "\\\\."),
#else
                (unsigned char PAPI *) Server,
#endif
                (unsigned char PAPI *) NamepipeAddresses[Address],
                NetworkOptions, &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_NETBIOS)
        {

        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) NetBiosProtocol,
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) NetBiosAddresses[Address],
                NetworkOptions, &StringBinding);
        }

    if (TransportType == RPC_LRPC)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncalrpc", NULL,
                (unsigned char PAPI *) SPCAddresses[Address], NetworkOptions,
                &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_TCP)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_ip_tcp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) TCPAddresses[Address],
                NetworkOptions,
                &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_UDP)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncadg_ip_udp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) UDPAddresses[Address],
                NetworkOptions,
                &StringBinding);
        }


    if (TransportType == RPC_TRANSPORT_SPX)
        {

        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_spx",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) SPXAddresses[Address],
                NetworkOptions, &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_IPX)
        {

        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncadg_ipx",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) IPXAddresses[Address],
                NetworkOptions, &StringBinding);
        }

   if (TransportType == RPC_TRANSPORT_DSP)
    {
    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_at_dsp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) DspAddresses[Address],
                NetworkOptions, &StringBinding);
    }
    if (TransportType == RPC_TRANSPORT_VNS)
    {
    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_vns_spp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) VNSAddresses[Address],
                NetworkOptions, &StringBinding);
    }

    if (TransportType == RPC_TRANSPORT_MSMQ)
    {
    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncadg_mq",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) MSMQAddresses[Address],
                NetworkOptions, &StringBinding);
    }

   if (Status)
        {
        ApiError("GetStringBinding","RpcStringBindingCompose",Status);
        PrintToConsole("GetStringBinding failed in ");
        PrintToConsole("RpcStringBindingCompose\n");
        return(0);
        }

   return(StringBinding);
}


RPC_STATUS
GetBinding (
    IN unsigned int Address,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description:

    A binding for the desired address is constructed.  This is a wrapper
    around GetStringBinding and RpcBindingFromStringBinding.

Arguments:

    Address - Supplies an index into a table of endpoints.

    Binding - A pointer to the location to store the returned binding
    handle.

Return Value:

    The status code from RpcBindingFromStringBinding is returned.

--*/
{
    unsigned char PAPI * StringBinding;
    RPC_STATUS FreeStatus;

    StringBinding = GetStringBinding(Address, 0, 0);

    Status = RpcBindingFromStringBindingA(StringBinding, Binding);

    if (Status)
            ApiError("GetBinding","RpcBindingFromStringBinding",Status);

    if (IFSecurityFlag)
        {
        Status = RpcBindingSetAuthInfo(
                          *Binding, NULL,
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          NULL);
        if (Status != RPC_S_OK)
            {
            ApiError("GetBinding","RpcBindingSetAuthInfo",Status);
            return Status;
            }
        }

    if (StringBinding)
     {
     FreeStatus = RpcStringFreeA(&StringBinding);

     if (FreeStatus)
          {
              ApiError("GetBinding","RpcStringFree",FreeStatus);
              PrintToConsole("GetBinding failed in ");
                  PrintToConsole("RpcStringFree\n");
          }
     }

    if (fUniqueBinding)
        {
        Status = RpcBindingSetOption( *Binding, RPC_C_OPT_UNIQUE_BINDING, TRUE );
        if (Status != RPC_S_OK)
            {
            ApiError("GetBinding","RpcBindingSetOption",Status);
            return Status;
            }
        }

    return(Status);
}


RPC_STATUS
UclntSendReceive (
    IN OUT PRPC_MESSAGE RpcMessage
    )
/*++

Routine Description:

    This routine takes care of retrying to send the remote procedure
    call.

Arguments:

    RpcMessage - Supplies and returns the message for I_RpcSendReceive.

Return Value:

    The result of I_RpcSendReceive will be returned.

--*/
{
    Status = I_RpcSendReceive(RpcMessage);

    return(Status);
}


RPC_STATUS
UclntGetBuffer (
    IN OUT PRPC_MESSAGE RpcMessage
    )
/*++

Routine Description:

    This routine takes care of retrying to getting a buffer.

Arguments:

    RpcMessage - Supplies and returns the message for I_RpcGetBuffer.

Return Value:

    The result of I_RpcGetBuffer will be returned.

--*/
{
    unsigned int RetryCount;
    RPC_BINDING_HANDLE Handle = RpcMessage->Handle;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        RpcMessage->Handle = Handle;
        Status = I_RpcGetBuffer(RpcMessage);
        if (   (Status != RPC_S_SERVER_TOO_BUSY)
            && (Status != RPC_S_CALL_FAILED_DNE))
            break;
        PauseExecution(RETRYDELAY);
        }
    return(Status);
}

/* --------------------------------------------------------------------

Isabelle Interface

-------------------------------------------------------------------- */


RPC_PROTSEQ_ENDPOINT IsabelleRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyis"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherisabelle"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp",(unsigned char *) "2040"}
    ,{(unsigned char *) "ncadg_ip_udp",(unsigned char *) "2040"}
    ,{(unsigned char *) "ncalrpc",(unsigned char *) "christopherisabelle"}
    ,{(unsigned char *) "ncacn_nb_nb",(unsigned char *) "212"}
    ,{(unsigned char *) "ncacn_spx",(unsigned char *) "5015"}
    ,{(unsigned char *) "ncadg_ipx",(unsigned char *) "5015"}
    ,{(unsigned char *) "ncacn_vns_spp", (unsigned char *) "265"}
    ,{(unsigned char *) "ncacn_at_dsp", (unsigned char *) "\\pipe\\zippyis"}
    ,{(unsigned char *) "ncadg_mq", (unsigned char *) "christopherisabelle"}
};

RPC_CLIENT_INTERFACE IsabelleInterfaceInformation =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{9,8,8,{7,7,7,7,7,7,7,7}},
     {1,1}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},
     {2,0}}, /* {4,5}}, */
    0,
    sizeof(IsabelleRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    IsabelleRpcProtseqEndpoint,
    0,
    NULL,
    RPC_INTERFACE_HAS_PIPES
};

void
IsabelleShutdown (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleShutdown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleShutdown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleShutdown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleShutdown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void
IsabelleNtSecurity (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                        // remote procedure call.
    unsigned int BufferLength,
    void PAPI * Buffer
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = BufferLength;
    Caller.ProcNum = 1 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleNtSecurity","I_RpcGetBuffer",Status);
        IsabelleError();
        return;
        }
    RpcpMemoryCopy(Caller.Buffer,Buffer,BufferLength);

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleNtSecurity","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleNtSecurity","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleNtSecurity","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void
IsabelleToStringBinding (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 2 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleToStringBinding", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleToStringBinding","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleToStringBinding","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleToStringBinding","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

#define RICHARDHELPER_EXIT 1
#define RICHARDHELPER_EXECUTE 2
#define RICHARDHELPER_IGNORE 3
#define RICHARDHELPER_DELAY_EXIT 4


RPC_STATUS
IsabelleRichardHelper (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned /*long*/ char Command
    )
/*++

Routine Description:

    This routine is the caller stub for the IsabelleRichardHelper routine
    on the server side.  We marshall the command, and use the supplied
    binding handle to direct the call.

Arguments:

    Binding - Supplies a binding to direct the call.

    Command - Supplies a command for IsabelleRichardHelper to execute
        on the server side.  Command must be one of the following
        values.

        RICHARDHELPER_EXIT - This value will cause the server to exit.

        RICHARDHELPER_EXECUTE - The server will execute usvr.exe with
            this the -richardhelper flag.

        RICHARDHELPER_IGNORE - The server will do nothing except return.

Return Value:

    The status of the operation will be returned.  This will be the
    status codes returned from RpcGetBuffer and/or RpcSendReceive.

--*/
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char PAPI * plScan;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned /*long*/ char);
    Caller.ProcNum = 3 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status != RPC_S_OK)
        return(Status);

    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    *plScan = Command;

    Status = UclntSendReceive(&Caller);

    if (Status != RPC_S_OK)
        return(Status);

    return(I_RpcFreeBuffer(&Caller));
}


RPC_STATUS
IsabelleRaiseException (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned /*long*/ char Exception
    )
/*++

Routine Description:

    This routine is the caller stub for the IsabelleRaiseException routine
    on the server side.  We marshall the exception code, and use the supplied
    binding handle to direct the call.

Arguments:

    Binding - Supplies a binding to direct the call.

    Exception - Supplies the exception to be raised by IsabelleRaiseException.

Return Value:

    The exception raised will be returned.

--*/
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char PAPI * plScan;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned /*long*/ char);
    Caller.ProcNum = 4 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status != RPC_S_OK)
        return(Status);

    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    *plScan = Exception;

    Status = UclntSendReceive(&Caller);

    return(Status);
}


void
IsabelleSetRundown (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server set
    a rundown routine for the association over which the call came.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 5 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleSetRundown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleSetRundown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleSetRundown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleSetRundown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}


void
IsabelleCheckRundown (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server check
    that the rundown routine actually got called.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckRundown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckRundown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleCheckRundown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleCheckRundown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void
IsabelleMustFail (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        return;
        }

    PrintToConsole("IsabelleMustFail: This call is supposed to fail\n") ;
    IsabelleError();
}


void
IsabelleCheckContext (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server check
    the association context for this association (the one the call comes
    in other), and then to set a new association context.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 7 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckContext", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckContext","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleCheckContext","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleCheckContext","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}


unsigned char *
IsabelleGetStringBinding (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server return
    the next string binding from the list of bindings supported by the
    server.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

Return Value:

    A copy of the string binding will be returned.  This can be freed
    using the delete operator.  If there are no more string bindings,
    or an error occurs, zero will be returned.

--*/
{
    RPC_MESSAGE Caller;
    unsigned char * StringBinding;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 8 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleGetStringBinding", "I_RpcGetBuffer", Status);
        IsabelleError();
        return(0);
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleGetStringBinding","I_RpcSendReceive",Status);
        IsabelleError();
        return(0);
        }

    if (Caller.BufferLength != 0)
        {
        StringBinding = new unsigned char[Caller.BufferLength];
        RpcpMemoryCopy(StringBinding,Caller.Buffer,Caller.BufferLength);
        }
    else
        StringBinding = 0;

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsabelleGetStringBinding","I_RpcFreeBuffer",Status);
        IsabelleError();
        return(0);
        }
    return(StringBinding);
}


void
IsabelleCheckNoRundown (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server check
    that the rundown routine did not get called.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 9| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckNoRundown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckNoRundown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleCheckNoRundown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleCheckNoRundown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}


void
IsabelleUnregisterInterfaces (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 11| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleUnregisterInterfaces", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleUnregisterInterfaces","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsabelleUnregisterInterfaces","I_RpcFreeBuffer",Status);
        IsabelleError();
        return;
        }
}


void
IsabelleRegisterInterfaces (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:


Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 12| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleRegisterInterfaces", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleRegisterInterfaces","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsabelleRegisterInterfaces","I_RpcFreeBuffer",Status);
        IsabelleError();
        return;
        }
}

void PipeAlloc(
    char PAPI *state,
    int requested_size,
    pipe_element_t PAPI * PAPI *allocated_buf,
    int PAPI * allocated_size)
{
    static int size = 0;
    static void PAPI *buffer = NULL;

    if (size < requested_size)
        {
        if (buffer)
            {
            I_RpcFree(buffer) ;
            }

        buffer =  I_RpcAllocate(requested_size) ;
        if (buffer == 0)
            {
            *allocated_size = 0 ;
            size = 0 ;
            }
        else
            {
            *allocated_size = requested_size ;
            size = requested_size ;
            }

        *allocated_buf = (pipe_element_t PAPI *) buffer ;
        }
    else
        {
        *allocated_buf = (pipe_element_t PAPI *) buffer ;
        *allocated_size = size ;
        }
}

void PipePull(
    char PAPI *state,
    pipe_element_t PAPI *buffer,
    int num_buf_elem,
    int PAPI *size_to_send
    )
{
    int i ;
    char j = 0;

    if (*((int PAPI *)state) <= 0)
        {
        *size_to_send = 0 ;
        return ;
        }

    // fill pipe elements
    for (i = 0; i<num_buf_elem; i++, j++)
        {
        buffer[i] = i ;
        }

    *size_to_send = num_buf_elem ;
    --*((int PAPI *) state) ;
}

int localchecksum ;

void  PipePush(
    char PAPI *state,
    pipe_element_t PAPI *input_buffer,
    int ecount
    )
{
    char PAPI *temp = (char PAPI *) input_buffer ;
    int i, j ;

    for (i = 0; i < ecount; i++)
        {
        localchecksum += input_buffer[i] ;
        }
}

void
IsabellePipeIN (
    RPC_BINDING_HANDLE Binding,
    pipe_t PAPI *pipe,
    int chunksize,
    int numchunks,
    long checksum,
    int buffsize,
    char PAPI *buffer
    )
{
    RPC_MESSAGE Caller, TempBuf;
    pipe_element_t PAPI *buf ;
    int num_buf_bytes ;
    int count ;
    int num_buf_elem ;
    DWORD size = 0 ;
    char PAPI *Temp ;
    int BufferOffset = 0 ;
    int LengthToSend ;

    Caller.Handle = Binding;
    Caller.BufferLength = 3 * sizeof(int) + buffsize;
    Caller.ProcNum = 13 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabellePipeIN", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    // marshal the fixed parameters
    Temp = (char PAPI *) Caller.Buffer ;
    *((int PAPI *) Temp) = chunksize ;
    Temp += sizeof(int) ;

    *((int PAPI *) Temp) = numchunks ;
    Temp += sizeof(int) ;

    *((long PAPI *) Temp) = checksum ;
    Temp += sizeof(long) ;

    *((int PAPI *) Temp) = buffsize ;
    Temp += sizeof(int) ;


    RpcpMemoryCopy(Temp, buffer, buffsize) ;

    // send the marshalled parameters
    Status = I_RpcSend(&Caller);

    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        BufferOffset = Caller.BufferLength ;
        }
    else if (Status)
        {
        ApiError("IsabellePipeIN","I_RpcSend",Status);
        IsabelleError();
        return;
        }

    do
        {
        pipe->Alloc(pipe->state,
                        chunksize * sizeof(pipe_element_t) + sizeof(DWORD),
                        &buf,
                        &num_buf_bytes
                        ) ;

        num_buf_elem = (num_buf_bytes -sizeof(DWORD)) / sizeof(pipe_element_t) ;

        pipe->Pull(pipe->state,
                       (pipe_element_t PAPI *) ((char PAPI *) buf+sizeof(DWORD)),
                       num_buf_elem,
                       &count
                       ) ;

        *((DWORD PAPI *) buf) = count ;
        LengthToSend = (count * sizeof(pipe_element_t)) + sizeof(DWORD) ;

        Status = I_RpcReallocPipeBuffer(&Caller, LengthToSend+BufferOffset) ;

        if (Status)
            {
            ApiError("IsabellePipeIN","I_RpcReallocPipeBuffer",Status);
            IsabelleError();
            return;
            }

        if (count == 0)
            {
            Caller.RpcFlags = 0 ;
            }

        RpcpMemoryCopy((char PAPI *) Caller.Buffer+BufferOffset, buf, LengthToSend) ;

        Status = I_RpcSend(&Caller) ;
        if (Status == RPC_S_SEND_INCOMPLETE)
            {
            BufferOffset = Caller.BufferLength ;
            }
        else if (Status)
            {
            ApiError("IsabellePipeIN","I_RpcSend",Status);
            IsabelleError();
            return;
            }
        else
            {
            BufferOffset = 0 ;
            }
        }
    while (count > 0) ;

    size = 0 ;
    Caller.RpcFlags = 0 ;

    Status = I_RpcReceive(&Caller, size) ;

    if (Status == RPC_S_OK)
       {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabellePipeIN","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabellePipeIN","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void LocalPipePull(
    PIPE_STATE PAPI *state,
    void PAPI *buffer,
    int max_buf,
    int PAPI *actual_transfer_count
    )
{
    unsigned num_elements = 0 ;
    DWORD size = (DWORD) max_buf;
    int bytescopied ;
    RPC_MESSAGE Caller ;

    *actual_transfer_count = 0 ;

    if (state->EndOfPipe)
        {
        return ;
        }

    I_RpcReadPipeElementsFromBuffer(state, (char PAPI *) buffer, max_buf, (int *) &num_elements) ;
    *actual_transfer_count += num_elements ;
    bytescopied = num_elements * sizeof(pipe_element_t) ;

    if (state->EndOfPipe == 0 &&
        num_elements < (max_buf / sizeof(pipe_element_t)))
        {
        Caller.RpcFlags = RPC_BUFFER_PARTIAL ;
        Caller.Buffer = state->Buffer ;
        Caller.BufferLength = state->BufferLength ;

        Status = I_RpcReceive(&Caller, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }

        num_elements = 0 ;
        state->Buffer = Caller.Buffer ;
        state->BufferLength = Caller.BufferLength ;

        state->CurPointer = (char PAPI *) Caller.Buffer ;
        state->BytesRemaining = Caller.BufferLength ;

        I_RpcReadPipeElementsFromBuffer(
                        (PIPE_STATE PAPI *) state,
                        (char PAPI *) buffer+bytescopied,
                        max_buf - bytescopied, (int *) &num_elements) ;

        *actual_transfer_count += num_elements ;
        }
}

void
IsabellePipeOUT (
    RPC_BINDING_HANDLE Binding,
    pipe_t PAPI *pipe,
    int chunksize
    )
{
    RPC_MESSAGE Caller;
    int num_elements ;
    int count ;
    DWORD size = chunksize * sizeof(pipe_element_t) + sizeof(DWORD) *2;
    int max_buf ;
    PIPE_STATE localstate ;
    pipe_element_t PAPI *buf ;
    pipe_element_t pipe_element ;
    int rchunksize, rnumchunks, rbuffsize, rchecksum ;
    char PAPI *temp, PAPI *cur ;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 14 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = I_RpcGetBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Caller.RpcFlags = 0;
    Status = I_RpcSend(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Caller.RpcFlags |= RPC_BUFFER_PARTIAL ;

    Status = I_RpcReceive(&Caller, size) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT", "I_RpcReceive", Status) ;
        IsabelleError() ;
        return ;
        }

    localstate.Buffer = Caller.Buffer ;
    localstate.BufferLength = Caller.BufferLength ;
    localstate.CurrentState = start ;
    localstate.CurPointer = (char PAPI *) Caller.Buffer ;
    localstate.BytesRemaining = Caller.BufferLength ;
    localstate.EndOfPipe = 0 ;
    localstate.PipeElementSize = sizeof(pipe_element_t) ;
    localstate.PartialPipeElement = &pipe_element ;
    localchecksum = 0;

    do
        {
        pipe->Alloc(pipe->state,
                        size,
                        &buf,
                        &max_buf
                        ) ;

        LocalPipePull(&localstate, buf, max_buf, &num_elements) ;

        pipe->Push(pipe->state,
                        buf,
                        num_elements) ;
        }
    while (num_elements > 0);

    if (!(Caller.RpcFlags & RPC_BUFFER_COMPLETE))
        {
        Caller.RpcFlags = 0 ;
        Status = I_RpcReceive(&Caller, size) ;
        if (Status)
            {
            ApiError("IsabellePipeOUT", "I_RpcReceive", Status) ;
            IsabelleError() ;
            return ;
            }
        }

    if (localstate.BytesRemaining > 0)
        {
        // this might be quite inefficient... need to improve
        // Also, CurPointer may be a pointer in Caller.Buffer
        // need to keep track of this in the state.

        temp = (char PAPI *) I_RpcAllocate(Caller.BufferLength + localstate.BytesRemaining) ;
        RpcpMemoryCopy(temp, localstate.CurPointer, localstate.BytesRemaining) ;
        RpcpMemoryCopy(temp+localstate.BytesRemaining,
                                  Caller.Buffer, Caller.BufferLength) ;
        cur = temp ;
        }
    else
        {
        temp = 0;
        cur = (char PAPI *) Caller.Buffer ;
        }

    rchunksize = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    rnumchunks = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    rchecksum = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    rbuffsize = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    PrintToConsole("IsabellePipeOUT: chunksize = %d\n", rchunksize)  ;
    PrintToConsole("IsabellePipeOUT: numchunks = %d\n", rnumchunks)  ;
    PrintToConsole("IsabellePipeOUT: buffsize = %d\n", rbuffsize)  ;
    PrintToConsole("IsabellePipeOUT: checksum = %d\n", rchecksum) ;

    if (temp)
        {
        I_RpcFree(temp) ;
        }

    Status = I_RpcFreeBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT","I_RpcSendReceive",Status);
        IsabelleError() ;
        return;
        }

    if (rchecksum != localchecksum)
        {
        IsabelleError() ;
        }
}

void
IsabellePipeINOUT (
    RPC_BINDING_HANDLE Binding,
    pipe_t PAPI *pipe,
    int chunksize,
    int checksum
    )
{
    RPC_MESSAGE Caller, TempBuf;
    pipe_element_t PAPI *buf ;
    int num_buf_bytes ;
    int count ;
    int num_buf_elem ;
    DWORD size = chunksize * sizeof(pipe_element_t) + sizeof(DWORD) * 2;
    PIPE_STATE localstate ;
    int max_buf ;
    int num_elements ;
    pipe_element_t pipe_element ;
    int BufferOffset = 0 ;
    int LengthToSend ;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 15 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = UclntGetBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeINOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    // send the marshalled parameters
    Status = I_RpcSend(&Caller);

    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        BufferOffset = Caller.BufferLength ;
        }
    else if (Status)
        {
        ApiError("IsabellePipeINOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    do
        {
        pipe->Alloc(pipe->state,
                         size,
                         &buf,
                         &num_buf_bytes
                         ) ;

        num_buf_elem = (num_buf_bytes -sizeof(DWORD)) / sizeof(pipe_element_t) ;

        pipe->Pull(pipe->state,
                       (pipe_element_t PAPI *) ((char PAPI *) buf+sizeof(DWORD)),
                       num_buf_elem,
                       &count
                       ) ;

        *((DWORD PAPI *) buf) = count ;

        LengthToSend = (count * sizeof(pipe_element_t)) + sizeof(DWORD) ;

        Status = I_RpcReallocPipeBuffer(&Caller, LengthToSend+BufferOffset) ;

        if (Status)
            {
            ApiError("IsabellePipeINOUT","I_RpcGetBuffer",Status);
            IsabelleError();
            return;
            }

        if (count == 0)
            {
            Caller.RpcFlags = 0 ;
            }

        RpcpMemoryCopy((char PAPI *) Caller.Buffer+BufferOffset, buf, LengthToSend) ;

        Status = I_RpcSend(&Caller) ;
        if (Status == RPC_S_SEND_INCOMPLETE)
            {
            BufferOffset = Caller.BufferLength ;
            }
        else if (Status)
            {
            ApiError("IsabellePipeINOUT","I_RpcSend",Status);
            IsabelleError();
            return;
            }
        else
            {
            BufferOffset = 0 ;
            }
        }
    while (count > 0) ;

    Caller.RpcFlags |= RPC_BUFFER_PARTIAL ;

    Status = I_RpcReceive(&Caller, size) ;
    if (Status)
        {
        ApiError("IsabellePipeINOUT", "I_RpcReceive", Status) ;
        IsabelleError() ;
        return ;
        }

    PrintToConsole("IsabellePipeINOUT: checksum (IN) = %d\n",
                                checksum) ;

    localstate.Buffer = Caller.Buffer ;
    localstate.CurrentState = start ;
    localstate.CurPointer = (char PAPI *) Caller.Buffer ;
    localstate.BytesRemaining = Caller.BufferLength ;
    localstate.EndOfPipe = 0 ;
    localstate.PipeElementSize = sizeof(pipe_element_t) ;
    localstate.PartialPipeElement = &pipe_element ;
    localchecksum = 0;

    do
        {
        pipe->Alloc(pipe->state,
                        size,
                        &buf,
                        &max_buf
                        ) ;

        LocalPipePull(&localstate, buf, max_buf, &num_elements) ;

        pipe->Push(pipe->state,
                         buf,
                         num_elements
                         ) ;
        }
    while (num_elements > 0);

    if (!(Caller.RpcFlags & RPC_BUFFER_COMPLETE))
        {
        Status = I_RpcReceive(&Caller, size) ;
        if (Status)
            {
            ApiError("IsabellePipeINOUT", "I_RpcReceive", Status) ;
            IsabelleError() ;
            return ;
            }
        }

    Status = I_RpcFreeBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeINOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    PrintToConsole("IsabellePipeINOUT: checksum (OUT) = %d\n", localchecksum) ;
}

BOOL IsServerNTSystem(RPC_BINDING_HANDLE Binding)
{
    OSVERSIONINFO *pOsVer;
    BOOL fResult;
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 20| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsServerNTSystem", "I_RpcGetBuffer", Status);
        IsabelleError();
        return TRUE;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsServerNTSystem","I_RpcSendReceive",Status);
        IsabelleError();
        return TRUE;
        }

    pOsVer = (OSVERSIONINFO *)Caller.Buffer;
    if (pOsVer->dwPlatformId == VER_PLATFORM_WIN32_NT)
        fResult = TRUE;
    else
        fResult = FALSE;

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsServerNTSystem","I_RpcFreeBuffer",Status);
        IsabelleError();
        }

    return fResult;
}

typedef struct _WIRE_CONTEXT
{
    unsigned long ContextType;
    UUID ContextUuid;
} WIRE_CONTEXT;

typedef struct _CCONTEXT {

    RPC_BINDING_HANDLE hRPC;    // binding handle assoicated with context

    unsigned long MagicValue;
    WIRE_CONTEXT NDR;

} CCONTEXT, *PCCONTEXT;

const ULONG CONTEXT_MAGIC_VALUE = 0xFEDCBA98;

void
UnregisterHelgaEx (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 22| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("UnregisterHelgaEx", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("UnregisterHelgaEx","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("UnregisterHelgaEx","I_RpcFreeBuffer",Status);
        IsabelleError();
        }
}

void OpenContextHandle(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_CLIENT_INTERFACE *If,
    OUT CCONTEXT *ContextHandle
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(WIRE_CONTEXT);
    if (If == &IsabelleInterfaceInformation)
        Caller.ProcNum = 21| HackForOldStubs ;
    else if (If == &HelgaInterfaceInformation)
        Caller.ProcNum = 10| HackForOldStubs ;
    else
        {
        ASSERT(0);
        }
    Caller.RpcInterfaceInformation = If;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("OpenContextHandle", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    memset(Caller.Buffer, 0, sizeof(WIRE_CONTEXT));

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("OpenContextHandle","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    if (ContextHandle)
        {
        Status = RpcBindingCopy(Binding, &ContextHandle->hRPC);
        if (Status)
            {
            ApiError("OpenContextHandle","RpcBindingCopy", Status);
            IsabelleError();
            }

        ContextHandle->MagicValue = CONTEXT_MAGIC_VALUE;
        memcpy(&ContextHandle->NDR, Caller.Buffer, sizeof(WIRE_CONTEXT));
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("OpenContextHandle","I_RpcFreeBuffer",Status);
        IsabelleError();
        }
}

/* -----------------------------------------------------------------

Synchronize Routine

--------------------------------------------------------------------*/
void Synchro(
     unsigned int Address // Specifies the binding to use in making the call
    )
{
    RPC_BINDING_HANDLE Binding ;
    int fPrint = 0;
    RPC_MESSAGE Caller;

    if (AutoListenFlag)
        {
        Caller.BufferLength = 0;
        Caller.ProcNum = 4 | HackForOldStubs ;
        Caller.RpcInterfaceInformation = &HelgaInterfaceInformation ;
        Caller.RpcFlags = 0;
        }

    Status = GetBinding(Address, &Binding);
    if (Status)
        {
        ApiError("Synchro","GetBinding",Status);
        PrintToConsole("Synchro : FAIL - Unable to Bind\n");

        return;
        }

#ifdef __RPC_WIN32__
    if (AutoListenFlag)
        {
        Caller.Handle = Binding;

        while(1)
            {
            while(UclntGetBuffer(&Caller))
                {
                Caller.Handle = Binding;
                PrintToConsole(".");
                fPrint = 1;
                PauseExecution(100);
                }

            if( UclntSendReceive(&Caller) == 0)
                {
                PrintToConsole("\n");
                break ;
                }

            PauseExecution(100) ;
            PrintToConsole(".");
            fPrint = 1;
            Caller.Handle = Binding ;
            }


       // SendReceive okay, free buffer now.
       Status = I_RpcFreeBuffer(&Caller);
       if (Status)
           ApiError("Synchro","I_RpcFreeBuffer",Status);
        }
    else
        {
        while(RpcMgmtIsServerListening(Binding) != RPC_S_OK)
            {
            PrintToConsole(".");
            fPrint = 1;
            PauseExecution(100) ;
            }
        }

#else
    Caller.Handle = Binding;

    while(1)
        {
        while(UclntGetBuffer(&Caller))
            {
            Caller.Handle = Binding;
            PrintToConsole(".");
            fPrint = 1;
            PauseExecution(100);
            }

        if( UclntSendReceive(&Caller) == 0)
            {
            PrintToConsole("\n");
            break ;
            }

        PauseExecution(100) ;
        PrintToConsole(".");
        fPrint = 1;
        }


   // SendReceive okay, free buffer now.
   Status = I_RpcFreeBuffer(&Caller);
   if (Status)
       ApiError("Synchro","I_RpcFreeBuffer",Status);
#endif

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Synchro","RpcBindingFree",Status);
        PrintToConsole("Synchro : FAIL - Unable to Free Binding");
        return;
        }

    if (fPrint)
        {
        PrintToConsole("\n");
        }
}

/* --------------------------------------------------------------------

Helga Interface

-------------------------------------------------------------------- */

void
InitializeBuffer (
    IN OUT void PAPI * Buffer,
    IN unsigned int BufferLength
    )
/*++

Routine Description:

    This routine is used to initialize the buffer; the first long in the
    buffer is set to be the length of the buffer.  The rest of the buffer
    is initialized with a pattern which will be checked by the receiver.

Arguments:

    Buffer - Supplies the buffer to be initialized.

    BufferLength - Supplies the length of the buffer.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    static unsigned char InitialValue = 96;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;
    *Length = BufferLength;
    swaplong(*Length) ;

    Value = InitialValue;
    InitialValue += 1;

    for (BufferScan = (unsigned char PAPI *) (Length + 1), BufferLength -= 4;
        BufferLength > 0; BufferLength--, BufferScan++, Value++)
        *BufferScan = Value;
}


int
CheckBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value = 0;

    Length = (unsigned long PAPI *) Buffer;
    swaplong(*Length) ;

    for (BufferScan = (unsigned char PAPI *) (Length + 1),
                Value = *BufferScan, BufferLength -= 4;
                BufferLength > 0; BufferLength--, BufferScan++, Value++)
        if (*BufferScan != Value)
            return(1);

    return(0);
}


RPC_PROTSEQ_ENDPOINT HelgaRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyhe"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherhelga"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp", (unsigned char *) "2039"}
   ,{(unsigned char *) "ncadg_ip_udp", (unsigned char *) "2039"}
   ,{(unsigned char *) "ncalrpc",(unsigned char *) "christopherhelga"}
   ,{(unsigned char *) "ncacn_nb_nb",(unsigned char *) "211"}
   ,{(unsigned char *) "ncacn_spx", (unsigned char *) "5014"}
   ,{(unsigned char *) "ncadg_ipx", (unsigned char *) "5014"}
   ,{(unsigned char *) "ncacn_vns_spp", (unsigned char *) "264"}
   ,{(unsigned char *) "ncacn_at_dsp", (unsigned char *) "\\pipe\\zippyhe"}
   ,{(unsigned char *) "ncadg_mq", (unsigned char *) "christopherhelga"}
};

RPC_CLIENT_INTERFACE HelgaInterfaceInformation =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    0,
    sizeof(HelgaRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    HelgaRpcProtseqEndpoint,
    0,
    NULL,
    RPC_INTERFACE_HAS_PIPES
};

// Send a 0 length packet and expect a 0 length one in reply

void
Helga (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("Helga","BufferLength != 0");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("Helga","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}
// Send a 0 length packet and expect a 0 length one in reply

DWORD
HelgaSendReceiveFailure (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                       // remote procedure call.
    int ProcNum
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = ProcNum | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return -1;
        }

    Status = UclntSendReceive(&Caller);
    if (!Status)
        {
        ApiError("HelgaSendReceiveFailure","I_RpcSendReceive",Status);
        HelgaError();

        I_RpcFreeBuffer(&Caller);
        return -1;
        }

    return Status;
}

void
HelgaSyncLpcSecurity (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    if (Caller.BufferLength != 0)
        {
        OtherError("HelgaLpcSecurity","BufferLength != 0");
        HelgaError();
        return;
        }
    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}

void
HelgaAsyncLpcSecurity (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;
    RPC_ASYNC_STATE Async;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_ASYNC;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (Async.u.hEvent == 0)
        {
        HelgaError();
        return;
        }

    Async.NotificationType = RpcNotificationTypeEvent ;

    Status = I_RpcAsyncSetHandle(&Caller, (PRPC_ASYNC_STATE) &Async);
    if (Status)
        {
        HelgaError();
        return;
        }

    Caller.RpcFlags = RPC_BUFFER_ASYNC;
    Status = I_RpcSend(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcSend",Status);
        HelgaError();
        return;
        }

    if (Caller.BufferLength != 0)
        {
        OtherError("HelgaLpcSecurity","BufferLength != 0");
        HelgaError();
        return;
        }

    WaitForSingleObject(Async.u.hEvent, INFINITE);

    Caller.RpcFlags = RPC_BUFFER_ASYNC;
    Status = I_RpcReceive(&Caller, 0);
    if (Status)
        {
        HelgaError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}


void
HelgaLpcSecurity (
    RPC_BINDING_HANDLE Binding,
    BOOL fAsync
    )
{
    if (fAsync)
        {
        HelgaAsyncLpcSecurity(Binding);
        }
    else
        {
        HelgaSyncLpcSecurity(Binding);
        }
}

void
HelgaMustFail (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        PrintToConsole("HelgaMustFail: I_RpcGetBuffer: %d\n", Status) ;
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        PrintToConsole("HelgaMustFail: I_RpcSendReceive: %d\n", Status) ;
        return;
        }

    PrintToConsole("HelgaMustFail: This call is supposed to fail\n") ;
    HelgaError();
}

void
HelgaUsingContextHandle (
    void PAPI * ContextHandle
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = NDRCContextBinding(ContextHandle);
    Caller.BufferLength = 0;
    Caller.ProcNum = 0| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("Helga","BufferLength != 0");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("Helga","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

// Send a packet of a requested size, the expected reply is 0 length
// The first long of the packet is the expected size on the server size

void
HelgaIN (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                        // remote procedure call.
    unsigned long BufferLength // Specifies the length of the buffer.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = BufferLength;
    Caller.ProcNum = 1 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaIN","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    InitializeBuffer(Caller.Buffer, BufferLength);

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("HelgaIN","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("HelgaIN","BufferLength != 0");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("HelgaIN","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

// Send a packet which contains a single long, which is the size
// of the packet the server will send in reply

void
HelgaOUT (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                       // remote procedure call.
    unsigned long BufferLength // Specifies the length of the buffer.
    )
{
    RPC_MESSAGE Caller;
    unsigned long PAPI * Length;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned long);
    Caller.ProcNum = 2 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaOUT","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Length = (unsigned long PAPI *) Caller.Buffer;
    *Length = BufferLength;
    swaplong(*Length) ;

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("HelgaOUT","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        Length = (unsigned long PAPI *) Caller.Buffer;
            swaplong(*Length) ;
        if (Caller.BufferLength != *Length)
            {
            OtherError("HelgaOUT","BufferLength != *Length");
            HelgaError();
            return;
            }
        if (CheckBuffer(Caller.Buffer, Caller.BufferLength) != 0)
            {
            OtherError("HelgaOUT","CheckBuffer Failed");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("HelgaOUT","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

// Send a packet, which the first long is the size of the packet, whoes
// reply should be a packet of the same size

void
HelgaINOUT (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                            // remote procedure call.
    unsigned long BufferLength  // Specifies the length of the buffer.
    )
{
    RPC_MESSAGE Caller;
    unsigned long PAPI * Length;

    Caller.Handle = Binding;
    Caller.BufferLength = BufferLength;
    Caller.ProcNum = 3 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }

    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaINOUT","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    InitializeBuffer(Caller.Buffer, BufferLength);

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("HelgaINOUT","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        Length = (unsigned long PAPI *) Caller.Buffer;
            swaplong(*Length) ;
        if (Caller.BufferLength != *Length)
            {
            OtherError("HelgaINOUT","BufferLength != *Length");
            HelgaError();
            return;
            }
        if (CheckBuffer(Caller.Buffer, Caller.BufferLength) != 0)
            {
            OtherError("HelgaINOUT","CheckBuffer Failed");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("HelgaINOUT","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

unsigned long
HelgaSizes[] =
{
    128, 256, 512, 1024, 1024*2, 1024*4, 1024*8,
    10000, 15000, 20000, 60000, 30000, 40000, 100000, 1024*82,
    0
};

#if 0
unsigned long
HelgaSizes[] =
{
    128, 128,
    0
};
#endif

void
TestHelgaInterface (
    RPC_BINDING_HANDLE HelgaBinding,
    unsigned long SizeUpperBound
    )
/*++

Routine Description:

    The various tests uses this routine to test the Helga interface in
    different scenarios.  We run each of the routines for a variety of
    input and output buffer sizes.  This is controlled by the array,
    HelgaSizes.

Arguments:

    HelgaBinding - Supplies the binding handle to use when calling each
        of the Helga caller stubs.

--*/
{
    int Count;

    Helga(HelgaBinding);

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] <= SizeUpperBound)
            {
            HelgaIN(HelgaBinding,HelgaSizes[Count]);
            }
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] <= SizeUpperBound)
            {
            HelgaOUT(HelgaBinding,HelgaSizes[Count]);
            }
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] <= SizeUpperBound)
            {
            HelgaINOUT(HelgaBinding,HelgaSizes[Count]);
            }
        }
}

RPC_CLIENT_INTERFACE HelgaInterfaceWrongTransferSyntax =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0xb4537da9, 0x3d03, 0x4f6b, {0xb5, 0x94, 0x52, 0xb2, 0x87, 0x4e, 0xe9, 0xd0}},
     {1, 0}},
    0,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};

RPC_CLIENT_INTERFACE HelgaInterfaceWrongGuid =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{1,2,4,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2,0}},
    0,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};


int
HelgaWrongInterfaceGuid (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine makes a remote procedure call using the wrong interface
    GUID (not supported by the server).  The call must fail, otherwise,
    there is a bug in the runtime. (Otherwise there are no bugs in the
    runtime -- I wish.)

Arguments:

    Binding - Supplies the binding handle to use in trying to make the
        remote procedure call.

Return Value:

    Zero will be returned in the call fails as expected.  Otherwise,
    non-zero will be returned.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceWrongGuid;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);
    if (Status == RPC_S_UNKNOWN_IF)
        return(0);

    Status = UclntSendReceive(&Caller);
    if (Status == RPC_S_UNKNOWN_IF)
        return(0);

    return(1);
}


int
HelgaWrongTransferSyntax (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine makes a remote procedure call using the wrong transfer
    syntax (not supported by the server).  The call must fail, otherwise,
    there is a bug in the runtime. (Otherwise there are no bugs in the
    runtime -- I wish.)

Arguments:

    Binding - Supplies the binding handle to use in trying to make the
        remote procedure call.

Return Value:

    Zero will be returned in the call fails as expected.  Otherwise,
    non-zero will be returned.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceWrongTransferSyntax;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);
    if (Status == RPC_S_UNSUPPORTED_TRANS_SYN)
        return(0);

    Status = UclntSendReceive(&Caller);
    if (Status == RPC_S_UNSUPPORTED_TRANS_SYN)
        return(0);

    return(1);
}

/* --------------------------------------------------------------------

Sylvia Interface

-------------------------------------------------------------------- */

extern RPC_DISPATCH_TABLE SylviaDispatchTable;

RPC_CLIENT_INTERFACE SylviaInterfaceInformation =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{3,2,2,{1,1,1,1,1,1,1,1}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &SylviaDispatchTable,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};

unsigned int
LocalSylviaCall (
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    )
{
    if (Depth > 0)
        {
        if (Depth == Breadth)
            {
            Count = (unsigned char) LocalSylviaCall(Depth-1,Breadth,Count);
            }
        else
            Count = (unsigned char) LocalSylviaCall(Depth-1,Breadth,Count);
        }
    return(Count+1);
}


unsigned /*long*/ char // Specifies the new count of calls.
SylviaCall (
    RPC_BINDING_HANDLE Binding,
    unsigned /*long*/ char Depth, // Specifies the depth of recursion desired.
    unsigned /*long*/ char Breadth, // Specifies the breadth desired.
    unsigned /*long*/ char Count // Specifies the count of calls up to this point.
    )
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char PAPI * plScan, ReturnValue ;

    if ( NoCallBacksFlag != 0 )
        {
        return((unsigned char) LocalSylviaCall(Depth, Breadth, Count));
        }

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned /*long*/ char) *4+10240;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &SylviaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("SylviaCall","I_RpcGetBuffer",Status);
        SylviaError();
        return(0);
        }
    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    plScan[0] = (unsigned char) Depth;
    plScan[1] = (unsigned char) Breadth;
    plScan[2] = (unsigned char) Count;

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("SylviaCall","I_RpcSendReceive",Status);
        SylviaError();
        return(0);
        }

    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    ReturnValue = *plScan;
    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("SylviaCall","I_RpcFreeBuffer",Status);
        SylviaError();
        return(0);
        }
    return(ReturnValue);
}

RPC_BINDING_HANDLE SylviaBinding;

unsigned int
SylviaCallbackUserCode (
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    ); // Prototype to keep the compiler happy because we recursively call
       // this routine.

unsigned int
SylviaCallbackUserCode ( // The user code for SylviaCallback.
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    )
{
    if (Depth > 0)
        {
        if (Depth == Breadth)
            {
            Count = (unsigned char) SylviaCallbackUserCode(Depth-1,Breadth,Count);
            }
        else
            Count = SylviaCall(SylviaBinding,Depth-1,Breadth,Count);
        }
    return(Count+1);
}

void __RPC_STUB
SylviaCallback (
    PRPC_MESSAGE Callee
    )
{
    unsigned /*long*/ char ReturnValue, PAPI *plScan;

    if ( Callee->ProcNum != 0 )
        {
        OtherError("SylviaCallback", "Callee->ProcNum != 0");
        SylviaError();
        }

    if ( RpcpMemoryCompare(Callee->RpcInterfaceInformation,
                &SylviaInterfaceInformation,
                sizeof(SylviaInterfaceInformation)) != 0 )
        {
        OtherError("SylviaCallback",
                "Callee->RpcInteraceInformation != &SylviaInterfaceInformation");
        SylviaError();
        }

    if (Callee->BufferLength != sizeof(unsigned /*long*/ char)*4+10240)
        {
        OtherError("SylviaCallback",
                "Callee->BufferLength != sizeof(unsigned int)*4");
        SylviaError();
        }

    plScan = (unsigned /*long*/ char PAPI *) Callee->Buffer;

    ReturnValue = (unsigned char) SylviaCallbackUserCode(plScan[0],plScan[1],plScan[2]);

    Callee->BufferLength = sizeof(unsigned char /*long*/);
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("SylviaCallback","I_RpcGetBuffer",Status);
        SylviaError();
        }
    plScan = (unsigned /*long*/ char PAPI *) Callee->Buffer;
    *plScan = ReturnValue;
}

RPC_DISPATCH_FUNCTION SylviaDispatchFunction[] = {SylviaCallback};

RPC_DISPATCH_TABLE SylviaDispatchTable =
{
    1, SylviaDispatchFunction
};


void
GenerateUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to generate a value for a uuid.  The magic
    number argument is used in mysterious and wonderful ways to
    generate a uuid (which is not necessarily correct).

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        generate a uuid.

    Uuid - Returns the generated uuid.

--*/
{

    Uuid->Data1= (unsigned long) MagicNumber * (unsigned long) MagicNumber ;
    //swaplong(Uuid->Data1) ;

    Uuid->Data2 = MagicNumber;
    Uuid->Data3 = MagicNumber / 2;

    //swapshort(Uuid->Data2) ;
    //swapshort(Uuid->Data3) ;

    Uuid->Data4[0] = MagicNumber % 256;
    Uuid->Data4[1] = MagicNumber % 257;
    Uuid->Data4[2] = MagicNumber % 258;
    Uuid->Data4[3] = MagicNumber % 259;
    Uuid->Data4[4] = MagicNumber % 260;
    Uuid->Data4[5] = MagicNumber % 261;
    Uuid->Data4[6] = MagicNumber % 262;
    Uuid->Data4[7] = MagicNumber % 263;
}


int
CheckUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to check that a generated uuid value is correct.

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        check a generated uuid.

    Uuid - Supplies a generated uuid to check.

Return Value:

    Zero will be returned if the uuid value is correct; otherwise, non-zero
    will be returned.

--*/
{
 //   swaplong(Uuid->Data1) ;
    if ( Uuid->Data1 != ((unsigned long) MagicNumber)
                * ((unsigned long) MagicNumber))
        return(1);

//    swapshort(Uuid->Data2) ;
    if ( Uuid->Data2 != MagicNumber )
        return(1);

//    swapshort(Uuid->Data3) ;
    if ( Uuid->Data3 != MagicNumber / 2 )
        return(1);
    if ( Uuid->Data4[0] != MagicNumber % 256 )
        return(1);
    if ( Uuid->Data4[1] != MagicNumber % 257 )
        return(1);
    if ( Uuid->Data4[2] != MagicNumber % 258 )
        return(1);
    if ( Uuid->Data4[3] != MagicNumber % 259 )
        return(1);
    if ( Uuid->Data4[4] != MagicNumber % 260 )
        return(1);
    if ( Uuid->Data4[5] != MagicNumber % 261 )
        return(1);
    if ( Uuid->Data4[6] != MagicNumber % 262 )
        return(1);
    if ( Uuid->Data4[7] != MagicNumber % 263 )
        return(1);
    return(0);
}

static unsigned int TryFinallyCount;
static unsigned int TryFinallyFailed;

void
TheodoreTryFinally (
    unsigned int count,
    unsigned int raise
    )
{
    if (count == 0)
        {
        if (raise)
            RpcRaiseException(437);
        return;
        }

    RpcTryFinally
        {
        TryFinallyCount += 1;
        TheodoreTryFinally(count-1,raise);
        }
    RpcFinally
        {
        TryFinallyCount -= 1;
        if (   (RpcAbnormalTermination() && !raise)
            || (!RpcAbnormalTermination() && raise))
            TryFinallyFailed += 1;
        }
    RpcEndFinally
}

void
Theodore ( // This test checks the exception handling support provided
           // by the RPC runtime.  No remote procedure calls occur.
    )
{
    unsigned int TryFinallyPass = 0;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Theodore : Verify exception handling support\n");

    TryFinallyCount = 0;
    TryFinallyFailed = 0;

    RpcTryExcept
        {
        RpcTryExcept
            {
            TheodoreTryFinally(20,1);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            if (   (RpcExceptionCode() == 437)
                && (TryFinallyCount == 0))
                TryFinallyPass = 1;
            }
        RpcEndExcept
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Theodore : FAIL in RpcTryExcept (%u)\n",TryFinallyCount);
        return;
        }
    RpcEndExcept

    if (!TryFinallyPass)
        {
        PrintToConsole("Theodore : FAIL in RpcTryFinally\n");
        return;
        }

    if (TryFinallyFailed)
        {
        PrintToConsole("Theodore : FAIL in RpcTryFinally\n");
        return;
        }

    TryFinallyCount = 0;
    TryFinallyFailed = 0;

    RpcTryExcept
        {
        TheodoreTryFinally(20,0);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Theodore : FAIL in RpcTryExcept\n");
        return;
        }
    RpcEndExcept

    if (TryFinallyFailed)
        {
        PrintToConsole("Theodore : FAIL in RpcTryFinally\n");
        return;
        }


    PrintToConsole("Theodore : PASS\n");
}


void
Sebastian (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Sebastian : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("Sebastian","GetBinding",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("Sebastian","GetBinding",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    for (HelgaCount = 0; HelgaCount < 100; HelgaCount++)
        {
        Status = RpcBindingFree(&HelgaBinding);
        if (Status)
            {
            ApiError("Sebastian","RpcBindingFree",Status);
            PrintToConsole("Sebastian : FAIL - Unable to Free Binding");
            PrintToConsole(" (HelgaBinding)\n");
            return;
            }

        Status = GetBinding(SIGFRIED, &HelgaBinding);
        if (Status)
            {
            ApiError("Sebastian","GetBinding",Status);
            PrintToConsole("Sebastian : FAIL - Unable to Bind (Sigfried)\n");
            return;
            }

        Helga(HelgaBinding);
        }

    TestHelgaInterface(HelgaBinding, HelgaMaxSize);


    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("Sebastian : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Sebastian","RpcBindingFree",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Sebastian : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Sebastian","RpcBindingFree",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Sebastian : PASS\n");
}

void
Pipe (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    pipe_t pipe ;
    int state ;
    int local_buf[BUFF_SIZE] ;
    int i ;
    long checksum ;

    Synchro(SPIPE) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("PIPE : Verify Basic Client Functionality\n");

    Status = GetBinding(SPIPE, &IsabelleBinding);
    if (Status)
        {
        ApiError("PIPE","GetBinding",Status);
        PrintToConsole("PIPE : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    pipe.Alloc = PipeAlloc ;
    pipe.Pull = PipePull ;
    pipe.Push = PipePush ;
    pipe.state = (char PAPI *) &state ;

    for (i = 0; i < BUFF_SIZE; i++)
        {
        local_buf[i] = i ;
        }

    state = NUM_CHUNKS ;
    checksum = (long) (CHUNK_SIZE-1) * (long) CHUNK_SIZE /2  *
                        (long) NUM_CHUNKS ;
    IsabellePipeIN(IsabelleBinding, &pipe,
                        CHUNK_SIZE, NUM_CHUNKS, checksum,
                        BUFF_SIZE * sizeof(int), (char PAPI *) local_buf) ;

    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    IsabellePipeOUT(IsabelleBinding, &pipe, CHUNK_SIZE) ;
    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    state = NUM_CHUNKS ;
    IsabellePipeINOUT(IsabelleBinding, &pipe, CHUNK_SIZE, checksum) ;
    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("PIPE","RpcBindingFree",Status);
        PrintToConsole("PIPE : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("PIPE : PASS\n");
}

void
LpcSecurityHelper (
    BOOL fAsync,
    BOOL fDynamic
    )
{
    RPC_SECURITY_QOS QOS;
    RPC_BINDING_HANDLE HelgaBinding;

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;

    if (fDynamic)
        {
        QOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        }
    else
        {
        QOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        }

    Status = RpcBindingSetAuthInfoEx(
                          HelgaBinding,
                          RPC_STRING_LITERAL("ServerPrincipal"),
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("LpcSecurity","RpcBindingSetAuthInfoEx",Status);
        goto Cleanup;
        }


    //
    // Logon as local administrator and call again
    //
    HANDLE hToken;

    if (LogonUser(
              RPC_T("Administrator"),
              NULL,
              RPC_T(""),
              LOGON32_LOGON_BATCH,
              LOGON32_PROVIDER_DEFAULT,
              &hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    if (ImpersonateLoggedOnUser(hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    if (fDynamic)
        {
        PrintToConsole("LpcSecurity: Expected: Administrator\n");
        }
    else
        {
        PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
        }

    HelgaLpcSecurity(HelgaBinding, fAsync) ;

    RevertToSelf();

    PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
    HelgaLpcSecurity(HelgaBinding, fAsync) ;

    CloseHandle(hToken);

Cleanup:
    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }
}

void
LpcSecurityTwoHandles (
    BOOL fAsync
    )
{
    RPC_SECURITY_QOS QOS;
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE HelgaBinding1;

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    Status = GetBinding(SIGFRIED, &HelgaBinding1);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    QOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;

    Status = RpcBindingSetAuthInfoExA(
                          HelgaBinding,
                          (unsigned char *) "ServerPrincipal",
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("LpcSecurity","RpcBindingSetAuthInfoEx",Status);
        goto Cleanup;
        }

    //
    // Logon as local administrator and call again
    //
    HANDLE hToken;

    if (LogonUserA(
              "Administrator",
              NULL,
              "",
              LOGON32_LOGON_BATCH,
              LOGON32_PROVIDER_DEFAULT,
              &hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    if (ImpersonateLoggedOnUser(hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    QOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;

    Status = RpcBindingSetAuthInfoExA(
                          HelgaBinding1,
                          (unsigned char *) "ServerPrincipal",
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("LpcSecurity","RpcBindingSetAuthInfoEx",Status);
        goto Cleanup;
        }

    PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
    HelgaLpcSecurity(HelgaBinding, fAsync);


    PrintToConsole("LpcSecurity: Expected: Administrator\n");
    HelgaLpcSecurity(HelgaBinding1, fAsync);

    RevertToSelf();

    PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
    HelgaLpcSecurity(HelgaBinding, fAsync) ;


    PrintToConsole("LpcSecurity: Expected: Administrator\n");
    HelgaLpcSecurity(HelgaBinding1, fAsync);

    CloseHandle(hToken);

Cleanup:
    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }
    Status = RpcBindingFree(&HelgaBinding1);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }
}

void
LpcSecurity (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("LpcSecurity : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

#if 0
    //
    // Sync call with static
    //
    PrintToConsole("LpcSecurity: Sync call with static tracking\n");
    LpcSecurityHelper(0, 0);
#endif

    //
    // Sync call with dynamic binding
    //
    PrintToConsole("LpcSecurity: Sync call with dynamic tracking\n");
    LpcSecurityHelper(0, 1);

#if 0
    //
    // Async call with static binding
    //
    PrintToConsole("LpcSecurity: Async call with static tracking \n");
    LpcSecurityHelper(1, 0);
#endif

    //
    // Async call with dynamic binding
    //
    PrintToConsole("LpcSecurity: Async call with dynamic tracking \n");

    LpcSecurityHelper(1, 1);

#if 0
    //
    // Async call with static,using two handles
    //
    LpcSecurityTwoHandles(1);

    //
    // Sync call with static using two handle
    //
    LpcSecurityTwoHandles(0);
#endif

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("LpcSecurity : PASS\n");
}


RPC_STATUS
UclntGetBufferWithObject (
    IN OUT PRPC_MESSAGE RpcMessage,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This routine takes care of retrying to getting a buffer.

Arguments:

    RpcMessage - Supplies and returns the message for I_RpcGetBuffer.

Return Value:

    The result of I_RpcGetBuffer will be returned.

--*/
{
    unsigned int RetryCount;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        Status = I_RpcGetBufferWithObject(RpcMessage, ObjectUuid);
        if (   (Status != RPC_S_SERVER_TOO_BUSY)
            && (Status != RPC_S_CALL_FAILED_DNE))
            break;
        PauseExecution(RETRYDELAY);
        }
    return(Status);
}


void
HelgaObjectUuids (
    RPC_BINDING_HANDLE HelgaBinding,
    UUID *ObjectUuid
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = HelgaBinding;
    Caller.BufferLength = sizeof(BOOL)+sizeof(UUID);
    Caller.ProcNum = 8 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }

    if (ObjectUuid)
        {
        Status = UclntGetBufferWithObject(&Caller, ObjectUuid);
        }
    else
        {
        Status = UclntGetBuffer(&Caller);
        }

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    char *Ptr = (char *) Caller.Buffer;
    if (ObjectUuid)
        {
        *((LONG *) Ptr) = 1;
        Ptr += sizeof(BOOL);
        RpcpMemoryCopy(Ptr, ObjectUuid, sizeof(UUID));
        }
    else
        {
        *((LONG *) Ptr) = 0;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }

    if (Caller.BufferLength != 0)
        {
        OtherError("Helga","BufferLength != 0");
        HelgaError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}

void
TestObjectUuids (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("TestObjectUuids : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","GetBinding",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","GetBinding",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    HelgaObjectUuids(HelgaBinding, 0);

    UUID MyUuid;

    RpcpMemorySet(&MyUuid, 'M', sizeof(UUID));
    HelgaObjectUuids(HelgaBinding, &MyUuid);

    HelgaObjectUuids(HelgaBinding, 0);

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcBindingFree",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcBindingFree",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("TestObjectUuids : PASS\n");
}

void
HelgaConnId (
    RPC_BINDING_HANDLE HelgaBinding,
    BOOL fNewConnExpected
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = HelgaBinding;
    Caller.BufferLength = sizeof(BOOL)+sizeof(UUID);
    Caller.ProcNum = 9 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }

    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    char *Ptr = (char *) Caller.Buffer;
    *((BOOL *) Ptr) = fNewConnExpected;

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }

    if (Caller.BufferLength != 0)
        {
        OtherError("Helga","BufferLength != 0");
        HelgaError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}

void
TestConnId (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("TestConnId : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("TestConnId","GetBinding",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("TestConnId","GetBinding",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    HelgaConnId(HelgaBinding, 1);
    HelgaConnId(HelgaBinding, 0);

    RpcBindingFree(&HelgaBinding);

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("TestConnId","GetBinding",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    HelgaConnId(HelgaBinding, 1);
    HelgaConnId(HelgaBinding, 0);

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("TestConnId : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("TestConnId","RpcBindingFree",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("TestConnId : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("TestConnId","RpcBindingFree",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("TestConnId : PASS\n");
}

void
Hybrid (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Hybrid in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Hybrid : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("Hybrid","GetBinding",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("Hybrid","GetBinding",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    for (HelgaCount = 0; HelgaCount < 30; HelgaCount++)
        {
        Helga(HelgaBinding);

        IsabelleUnregisterInterfaces(IsabelleBinding) ;

        HelgaMustFail(HelgaBinding) ;

        IsabelleRegisterInterfaces(IsabelleBinding) ;
        }

    for (HelgaCount = 0; HelgaCount < 5; HelgaCount++)
        {
        TestHelgaInterface(HelgaBinding, HelgaMaxSize);

        IsabelleUnregisterInterfaces(IsabelleBinding) ;

        HelgaMustFail(HelgaBinding) ;

        IsabelleRegisterInterfaces(IsabelleBinding) ;
        }

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Hybrid","RpcBindingFree",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Hybrid","RpcBindingFree",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Hybrid : PASS\n");
}

void
Graham (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Grant in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    UUID ObjectUuid;
    unsigned short MagicValue;
    unsigned int Count;

    Synchro(GRANT) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Graham : Verify Basic Client Functionality\n");

    Status = GetBinding(GRANT, &HelgaBinding);
    if (Status)
        {
        ApiError("Graham","GetBinding",Status);
        PrintToConsole("Graham : FAIL - Unable to Bind (Grant)\n");
        return;
        }


    Status = GetBinding(GRANT, &IsabelleBinding);
    if (Status)
        {
        ApiError("Graham","GetBinding",Status);
        PrintToConsole("Graham : FAIL - Unable to Bind (Grant)\n");
        return;
        }

    MagicValue = 106;

    GenerateUuidValue(MagicValue, &ObjectUuid);
    Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Graham", "RpcBindingSetObject", Status);
        PrintToConsole("Graham : FAIL - Unable to Set Object\n");
        return;
        }
    MagicValue += 1;

    Helga(HelgaBinding);

    GenerateUuidValue(MagicValue, &ObjectUuid);
    Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Graham", "RpcBindingSetObject", Status);
        PrintToConsole("Graham : FAIL - Unable to Set Object\n");
        return;
        }
    MagicValue += 1;

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] > HelgaMaxSize)
            continue;

        HelgaIN(HelgaBinding,HelgaSizes[Count]);

        GenerateUuidValue(MagicValue, &ObjectUuid);
        Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
        if (Status)
            {
            ApiError("Graham", "RpcBindingSetObject", Status);
            PrintToConsole("Graham : FAIL - Unable to Set Object\n");
            return;
            }
        MagicValue += 1;
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] > HelgaMaxSize)
            continue;

        HelgaOUT(HelgaBinding,HelgaSizes[Count]);

        GenerateUuidValue(MagicValue, &ObjectUuid);
        Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
        if (Status)
            {
            ApiError("Graham", "RpcBindingSetObject", Status);
            PrintToConsole("Graham : FAIL - Unable to Set Object\n");
            return;
            }
        MagicValue += 1;
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] > HelgaMaxSize)
            continue;

        HelgaINOUT(HelgaBinding,HelgaSizes[Count]);

        GenerateUuidValue(MagicValue, &ObjectUuid);
        Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
        if (Status)
            {
            ApiError("Graham", "RpcBindingSetObject", Status);
            PrintToConsole("Graham : FAIL - Unable to Set Object\n");
            return;
            }
        MagicValue += 1;
        }

    IsabelleShutdown(IsabelleBinding);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Graham : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Graham","RpcBindingFree",Status);
        PrintToConsole("Graham : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Graham : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Graham","RpcBindingFree",Status);
        PrintToConsole("Graham : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Graham : PASS\n");
}


void
Edward (
    )
/*++

Routine Description:

    This routine verifies server support of multiple addresses and
    interfaces, as well as callbacks.  In addition, we test binding
    here as well.  This test works with Elliot in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    RPC_BINDING_HANDLE SylviaMinimize;
    RPC_BINDING_HANDLE SylviaMaximize;
    RPC_BINDING_HANDLE HelgaMinimize;
    RPC_BINDING_HANDLE HelgaMaximize;
    RPC_BINDING_HANDLE EdwardMinimize;
    RPC_BINDING_HANDLE EdwardNormal;
    RPC_BINDING_HANDLE EdwardMaximize;

    Synchro(ELLIOTMINIMIZE) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Edward : Verify Callbacks, Multiple Addresses");
    PrintToConsole(", and Multiple Interfaces\n");

    Status = GetBinding(ELLIOTMINIMIZE, &SylviaMinimize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Minimize)\n");
        return;
        }


    Status = GetBinding(ELLIOTMAXIMIZE, &SylviaMaximize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Maximize)\n");
        return;
        }

    Status = GetBinding(ELLIOTMINIMIZE, &HelgaMinimize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Minimize)\n");
        return;
        }


    Status = GetBinding(ELLIOTMAXIMIZE, &HelgaMaximize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (ElliotMaximize)\n");
        return;
        }

    Status = GetBinding(ELLIOTMAXIMIZE, &IsabelleBinding);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Maximize)\n");
        return;
        }

    // First, we will test callbacks.

    SylviaBinding = SylviaMinimize;

    if (SylviaCall(SylviaBinding,5,0,0) != LocalSylviaCall(5,0,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(5,0,0)\n");
        return;
        }


    if (SylviaCall(SylviaBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(10,5,0)\n");
        return;
        }

    // And then we will test callbacks again using the maximize address.

    SylviaBinding = SylviaMaximize;

    if (SylviaCall(SylviaBinding,5,0,0) != LocalSylviaCall(5,0,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(5,0,0)\n");
        return;
        }

    if (SylviaCall(SylviaBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(10,5,0)\n");
        return;
        }

    // Ok, now we will insure that the Helga interface works.

    Helga(HelgaMinimize);
    HelgaIN(HelgaMinimize,1024*4);
    HelgaOUT(HelgaMinimize,1024*8);
    HelgaINOUT(HelgaMinimize,1024*16);

    Helga(HelgaMaximize);
    HelgaIN(HelgaMaximize,1024*4);
    HelgaOUT(HelgaMaximize,1024*8);
    HelgaINOUT(HelgaMaximize,1024*16);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    // Now we want to unbind both Sylvia binding handles, and then try
    // the Helga interface again.

    if (SylviaErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&SylviaMinimize);
    if (Status)
        {
        ApiError("Edward","RpcBindingFree",Status);
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(SylviaMinimize)\n");
        return;
        }

    Status = RpcBindingFree(&SylviaMaximize);
    if (Status)
        {
        ApiError("Edward","RpcBindingFree",Status);
        PrintToConsole("Edward : FAIL - Unable to Free Binding");
        PrintToConsole(" (SylviaMaximize)\n");
        return;
        }

    // Ok, now we will insure that the Helga interface still works.

    Helga(HelgaMinimize);
    HelgaIN(HelgaMinimize,1024*2);
    HelgaOUT(HelgaMinimize,1024*4);
    HelgaINOUT(HelgaMinimize,1024*8);

    Helga(HelgaMaximize);
    HelgaIN(HelgaMaximize,1024*2);
    HelgaOUT(HelgaMaximize,1024*4);
    HelgaINOUT(HelgaMaximize,1024*8);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    // Now we need to test the binding stuff.

    Status = GetBinding(ELLIOTMINIMIZE, &EdwardMinimize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Minimize)\n");
        return;
        }

    Status = GetBinding(ELLIOTNORMAL, &EdwardNormal);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Normal)\n");
        return;
        }

    Status = GetBinding(ELLIOTMAXIMIZE, &EdwardMaximize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Maximize)\n");
        return;
        }

    if (HelgaWrongInterfaceGuid(EdwardMinimize))
        {
        PrintToConsole("Edward : FAIL - HelgaWrongInterfaceGuid Succeeded\n");
        return;
        }

    if (HelgaWrongInterfaceGuid(EdwardNormal))
        {
        PrintToConsole("Edward : FAIL - HelgaWrongInterfaceGuid Succeeded\n");
        return;
        }

    if (HelgaWrongInterfaceGuid(EdwardMaximize))
        {
        PrintToConsole("Edward : FAIL - HelgaWrongInterfaceGuid Succeeded\n");
        return;
        }

    //Skip over the WrongTransfer Syntax tests for Datagram
    //Datagram doesnt req. any checks on Transfer syntaxes

    if (DatagramTests == 0)
        {
        if (HelgaWrongTransferSyntax(EdwardMinimize))
           {
           PrintToConsole("Edward : FAIL - HelgaWrongTransferSyntax");
           PrintToConsole(" Succeeded\n");
           return;
           }

        if (HelgaWrongTransferSyntax(EdwardNormal))
           {
           PrintToConsole("Edward : FAIL - HelgaWrongTransferSyntax");
           PrintToConsole(" Succeeded\n");
           return;
           }

        if (HelgaWrongTransferSyntax(EdwardMaximize))
           {
           PrintToConsole("Edward : FAIL - HelgaWrongTransferSyntax");
           PrintToConsole(" Succeeded\n");
           return;
           }
        }
    Status = RpcBindingFree(&EdwardMinimize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(EdwardMinimize)\n");
        return;
        }

    Status = RpcBindingFree(&EdwardNormal);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(EdwardNormal)\n");
        return;
        }

    Status = RpcBindingFree(&EdwardMaximize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(EdwardMaximize)\n");
        return;
        }

    // Finally, we will tell the server to shutdown, and then we will
    // unbind the Helga bindings.

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    Status = RpcBindingFree(&HelgaMaximize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(HelgaMaximize)\n");
        return;
        }

    Status = RpcBindingFree(&HelgaMinimize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaMinimize)\n");
        return;
        }

    PrintToConsole("Edward : PASS\n");
}

#ifdef NOVELL_NP
unsigned int AstroThreads = 1;
#else   // NOVELL_NP
unsigned int AstroThreads = 2;
#endif // NOVELL


#ifndef NOTHREADS

unsigned int AstroThreadCount;
/* volatile */ int fAstroResume;


void
AstroSylvia (
    IN void * Ignore
    )
/*++

Routine Description:

    This routine will be called by each thread created by the Astro
    test to make calls against the Sylvia interface.

Arguments:

    Ignore - Supplies an argument which we do not use.  The thread class
        takes a single argument, which we ignore.

--*/
{
    UNUSED(Ignore);

    if (SylviaCall(SylviaBinding,5,0,0) != LocalSylviaCall(5,0,0))
        {
        PrintToConsole("AstroSylvia : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(5,0,0)\n");
        return;
        }

    if (SylviaCall(SylviaBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("AstroSylvia : FAIL - Incorrect result from");
    PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    TestMutexRequest();
    AstroThreadCount -= 1;
    if (AstroThreadCount == 0)
        {
        TestMutexClear();
        fAstroResume = 1;
        }
    else
        TestMutexClear();
}

MUTEX2 Mutex2(&Status);


void
AstroMutex (
   RPC_BINDING_HANDLE Dontcare
   )
{
    int i;

    while (1)
        {
        for (i = 0; i < 10; i++)
            {
            Mutex2.Request();
            PrintToConsole("Thread %d in the mutex\n", GetCurrentThreadId());
            Mutex2.Clear();
            PauseExecution(30*i);
            }
        }
}


void
AstroHelga (
    RPC_BINDING_HANDLE HelgaBinding
    )
/*++

Routine Description:

    This routine will be used by the Astro test to perform a test against
    the Helga interface.  More that one thread will execute this routine
    at a time.

Arguments:

    HelgaBinding - Supplies the binding handle to use in make calls using
        the Helga interface.

--*/
{

    TestHelgaInterface(HelgaBinding,
            ( HelgaMaxSize < 8*1024L ? HelgaMaxSize : 8*1024L ));

    TestMutexRequest();
    AstroThreadCount -= 1;
    if (AstroThreadCount == 0)
        {
        TestMutexClear();
        fAstroResume = 1;
        }
    else
        TestMutexClear();
}


void
AstroHelgaAndUnbind ( // Perform the a test using the Helga interface.  When
                      // done, unbind the binding handle.
    RPC_BINDING_HANDLE HelgaBinding // Binding to use to the Helga interface.
    )
/*++

Routine Description:

    This routine is the same as AstroHelga, except that we free the binding
    handle when we are done using it.

Arguments:

    HelgaBinding - Supplies the binding handle to use in making calls
        using the Helga interface.  When we are done with it, we free
        it.

--*/
{
    TestHelgaInterface(HelgaBinding,
        ( HelgaMaxSize < 8*1024L ? HelgaMaxSize : 8*1024L ));

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Astro","RpcBindingFree",Status);
        PrintToConsole("Astro : FAIL - Unable to Free Binding ");
        PrintToConsole("(HelgaBinding)\n");
        return;
        }

    TestMutexRequest();
    AstroThreadCount -= 1;
    if (AstroThreadCount == 0)
        {
        TestMutexClear();
        fAstroResume = 1;
        }
    else
        TestMutexClear();
}

typedef enum _ASTRO_BIND_OPTION
{
    AstroBindOnce,
    AstroBindThread,
    AstroBindSylvia,
    AstroDontBind
} ASTRO_BIND_OPTION;


int
PerformMultiThreadAstroTest (
    ASTRO_BIND_OPTION AstroBindOption,
    void (*AstroTestRoutine)(RPC_BINDING_HANDLE),
    unsigned int Address
    )
/*++

Routine Description:

    This routine takes care of performing all of the multi-threaded Astro
    tests.  We create the binding handles as well as creating the threads
    to perform each test.  We also wait around for all of the threads to
    complete.

Arguments:

    AstroBindOption - Supplies information indicating how the binding
        for this particular test should be done.

    AstroTestRoutine - Supplies the test routine to be executed by each
        thread performing the test.

    Address - Supplies the address index to be passed to GetStringBinding
        used to get a string binding.  The string binding is passed to
        RpcBindingFromStringBinding.

Return Value:

    A return value of zero indicates that the test succeeded.  Otherwise,
    the test failed.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_BINDING_HANDLE BindingHandle;
    unsigned int ThreadCount;

    if (AstroBindOption == AstroBindOnce)
        {
        Status = GetBinding(Address, &BindingHandle);
        if (Status)
            {
            ApiError("Astro","GetBinding",Status);
            PrintToConsole("Astro : FAIL - Unable to Bind\n");
            return(1);
            }
        }
    else if (AstroBindOption == AstroBindSylvia)
        {
        Status = GetBinding(Address, &BindingHandle);
        SylviaBinding = BindingHandle;
        if (Status)
            {
            ApiError("Astro","GetBinding",Status);
            PrintToConsole("Astro : FAIL - Unable to Bind\n");
            return(1);
            }
        }

    AstroThreadCount = AstroThreads;
    fAstroResume = 0;

    for (ThreadCount = 0; ThreadCount < AstroThreads; ThreadCount++)
        {

        if (AstroBindOption == AstroBindThread)
            {
            Status = GetBinding(Address, &BindingHandle);
            if (Status)
                {
                ApiError("Astro","GetBinding",Status);
                PrintToConsole("Astro : FAIL - Unable to Bind\n");
                return(1);
                }
            }
        RpcStatus = RPC_S_OK;
        HANDLE HandleToThread;
        unsigned long ThreadId;

        HandleToThread = CreateThread(
                                      0,
                                      DefaultThreadStackSize,
                                      (LPTHREAD_START_ROUTINE) AstroTestRoutine,
                                      BindingHandle,
                                      0,
                                      &ThreadId);

        if (HandleToThread == 0)
            {
            OtherError("Astro", "CreateThread failed");
            PrintToConsole("Astro : FAIL - Unable to create thread\n");
            return(1);
            }
        }

    while (!fAstroResume)
        PauseExecution(200L);

    if (AstroThreadCount != 0)
        {
        PrintToConsole("Astro : FAIL - AstroThreadCount != 0\n");
        return(1);
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Astro : FAIL - Error(s) in Helga Interface\n");
        return(1);
        }

    if (   (AstroBindOption == AstroBindOnce)
        || (AstroBindOption == AstroBindSylvia))
        {
        Status = RpcBindingFree(&BindingHandle);
        if (Status)
            {
            ApiError("Astro","RpcBindingFree",Status);
            PrintToConsole("Astro : FAIL - Unable to Free Binding ");
            PrintToConsole("(BindingHandle)\n");
            return(1);
            }
        }

    return(0);
}

#endif


void
Astro (
    )
/*++

Routine Description:

    This routine tests the runtime by having more than one thread
    simultaneously perform remote procedure calls.  This test works with
    the Andromida test in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    RPC_STATUS RpcStatus = RPC_S_OK;

    Synchro(ANDROMIDA) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Astro : Multithreaded Clients (%d)\n", AstroThreads);

    Status = GetBinding(ANDROMIDA, &IsabelleBinding);
    if (Status)
        {
        ApiError("Astro","GetBinding",Status);
        PrintToConsole("Astro : FAIL - Unable to Bind (Andromida)\n");
        return;
        }



#ifndef NOTHREADS

    if (PerformMultiThreadAstroTest(AstroBindOnce,AstroHelga,
            ANDROMIDA))
        return;

    if (PerformMultiThreadAstroTest(AstroBindThread, AstroHelgaAndUnbind,
            ANDROMIDA))
        return;

    if ( PerformMultiThreadAstroTest(AstroBindSylvia, AstroSylvia,
            ANDROMIDA) != 0 )
        {
        return;
        }

#endif

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Astro : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Astro","RpcBindingFree",Status);
        PrintToConsole("Astro : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Astro : PASS\n");
}


int
FitzgeraldCompose (
    IN char PAPI * ObjUuid OPTIONAL,
    IN char PAPI * Protseq,
    IN char PAPI * NetworkAddr,
    IN char PAPI * Endpoint OPTIONAL,
    IN char PAPI * NetworkOptions OPTIONAL,
    IN char PAPI * ExpectedStringBinding
    )
/*++

Routine Description:

    This routine is used by Fitzgerald to test the RpcStringBindingCompose
    API.

Arguments:

    ObjUuid - Optionally supplies the object UUID field to pass to
        RpcStringBindingCompose.

    Protseq - Supplies the RPC protocol sequence field to pass to
        RpcStringBindingCompose.

    NetworkAddr - Supplies the network address field to pass to
        RpcStringBindingCompose.

    Endpoint - Optionally supplies the endpoint field to pass to
        RpcStringBindingCompose.

    NetworkOptions - Optionally supplies the network options field to
        pass to RpcStringBindingCompose.

    ExpectedStringBinding - Supplies the expected string binding which
        should be obtained from RpcStringBindingCompose.

Return Value:

    0 - The test passed successfully.

    1 - The test failed.

--*/
{
    unsigned char PAPI * StringBinding;
    RPC_STATUS Status;

    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjUuid,
            (unsigned char PAPI *) Protseq,
            (unsigned char PAPI *) NetworkAddr,
            (unsigned char PAPI *) Endpoint,
            (unsigned char PAPI *) NetworkOptions,&StringBinding);
    if (Status)
        {
        ApiError("FitzgeraldCompose","RpcStringBindingCompose",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in");
        PrintToConsole(" RpcStringBindingCompose\n");
        return(1);
        }

    if (strcmp((char PAPI *) StringBinding,
            (char PAPI *) ExpectedStringBinding) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - StringBinding");
        PrintToConsole(" != ExpectedStringBinding\n");
        return(1);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("FitzgeraldCompose","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldParse (
    IN char PAPI * StringBinding,
    IN char PAPI * ExpectedObjUuid OPTIONAL,
    IN char PAPI * ExpectedProtseq OPTIONAL,
    IN char PAPI * ExpectedNetworkAddr OPTIONAL,
    IN char PAPI * ExpectedEndpoint OPTIONAL,
    IN char PAPI * ExpectedOptions OPTIONAL
    )
/*++

Routine Description:

    This routine is used by Fitzgerald to test the RpcStringBindingParse
    API.

Arguments:

    StringBinding - Supplies the string binding to be parsed.

    ExpectedObjUuid - Supplies a string containing the expected object
        UUID field.

    ExpectedProtseq - Supplies the expected RPC protocol sequence field.

    ExpectedNetworkAddr - Supplies the expected network address field.

    ExpectedEndpoint - Supplies the expected endpoint field.

    ExpectedOptions - Supplies the expected options field.

Return Value:

    0 - The test passed successfully.

    1 - The test failed.

--*/
{
    unsigned char PAPI * ObjUuid = 0;
    unsigned char PAPI * Protseq = 0;
    unsigned char PAPI * NetworkAddr = 0;
    unsigned char PAPI * Endpoint = 0;
    unsigned char PAPI * Options = 0;
    RPC_STATUS Status;

    Status = RpcStringBindingParseA((unsigned char PAPI *) StringBinding,
        (ARGUMENT_PRESENT(ExpectedObjUuid) ? (unsigned char PAPI * PAPI *) &ObjUuid : 0),
        (ARGUMENT_PRESENT(ExpectedProtseq) ? (unsigned char PAPI * PAPI *) &Protseq : 0),
        (ARGUMENT_PRESENT(ExpectedNetworkAddr) ? (unsigned char PAPI * PAPI *) &NetworkAddr : 0),
        (ARGUMENT_PRESENT(ExpectedEndpoint) ? (unsigned char PAPI * PAPI *) &Endpoint : 0),
        (ARGUMENT_PRESENT(ExpectedOptions) ? (unsigned char PAPI * PAPI *) &Options : 0));
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringBindingParse",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in");
        PrintToConsole(" RpcStringBindingParse\n");
        return(1);
        }

    if (strcmp(ExpectedObjUuid,(char PAPI *) ObjUuid) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedObjUuid != ObjUuid");
        return(1);
        }

    if (strcmp(ExpectedProtseq,(char PAPI *) Protseq) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedProtseq != Protseq");
        return(1);
        }

    if (strcmp(ExpectedNetworkAddr,(char PAPI *) NetworkAddr) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedNetworkAddr");
        PrintToConsole(" != NetworkAddr");
        return(1);
        }

    if (strcmp(ExpectedEndpoint,(char PAPI *) Endpoint) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedEndpoint != Endpoint");
        return(1);
        }

    if (strcmp(ExpectedOptions,(char PAPI *) Options) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedOptions != Options");
        return(1);
        }

    Status = RpcStringFreeA(&ObjUuid);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&Protseq);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&NetworkAddr);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&Endpoint);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&Options);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    return(0);
}


int
FitzgeraldComposeAndParse (
    void
    )
/*++

Routine Description:

    This routine tests that the string binding (RpcStringBindingCompose and
    RpcStringBindingParse) and string (RpcStringFree) APIs are working
    correctly.  This is a build verification test; hence it focuses on
    testing that all functionality is there, testing error cases are
    not quite as important.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    unsigned char PAPI * StringBinding;

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server","\\pipe\\endpoint",0,
            "ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint]"))
        return(1);

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server",0,0,
            "ncacn_np:\\\\\\\\server"))
        return(1);

    Status = RpcStringBindingComposeA(
            (unsigned char PAPI *) "12345678-9012-B456-8001-08002B033D7AA",
            (unsigned char PAPI *) "ncacn_np",
            (unsigned char PAPI *) "\\\\server", 0,0, &StringBinding);
    if ( Status != RPC_S_INVALID_STRING_UUID )
        {
        ApiError("FitzgeraldComposeAndParse", "RpcStringBindingCompose",
                Status);
        PrintToConsole("Fitzgerald : FAIL - Error ");
        PrintToConsole("in RpcStringBindingCompose\n");
        return(1);
        }

    if (FitzgeraldCompose("12345678-9012-B456-8001-08002B033D7A",
            "ncacn_np","\\\\server","\\pipe\\endpoint",0,
            "12345678-9012-b456-8001-08002b033d7a@ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint]"))
        return(1);

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server","\\pipe\\endpoint",
            "security=identify",
            "ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint,security=identify]"))
        return(1);

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server",0,"option=value",
            "ncacn_np:\\\\\\\\server[,option=value]"))
        return(1);

    if (FitzgeraldParse("12345678-9012-b456-8001-08002b033d7a@ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint,security=identify]",
            "12345678-9012-b456-8001-08002b033d7a",
            "ncacn_np","\\\\server","\\pipe\\endpoint",
            "security=identify"))
        return(1);

    if (FitzgeraldParse("ncacn_np:\\\\\\\\server",
            "","ncacn_np","\\\\server","",""))
        return(1);

    if (FitzgeraldParse("ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint]",
            "","ncacn_np","\\\\server","\\pipe\\endpoint",""))
        return(1);

    return(0);
}


int
FitzgeraldBindingCopy (
    )
/*++

Routine Description:

    Fitzgerald uses this routine to test the RpcBindingCopy API (we also
    use RpcBindingFromStringBinding and RpcBindingFree).

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    RPC_BINDING_HANDLE CopiedBeforeRpc;
    RPC_BINDING_HANDLE CopiedAfterRpc;

    Status = GetBinding(FREDRICK, &BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }

    Status = RpcBindingCopy(BindingHandle,&CopiedBeforeRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Copy Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    Helga(BindingHandle);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Helga(CopiedBeforeRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingCopy(CopiedBeforeRpc,&CopiedAfterRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Copy Binding");
        PrintToConsole(" (CopiedBeforeRpc)\n");
        return(1);
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    Helga(CopiedBeforeRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Helga(CopiedAfterRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&CopiedBeforeRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (CopiedBeforeRpc)\n");
        return(1);
        }

    Helga(CopiedAfterRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&CopiedAfterRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (CopiedAfterRpc)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldToStringBinding (
    IN unsigned char PAPI * UseThisStringBinding,
    IN unsigned char PAPI * ExpectedStringBinding,
    IN UUID PAPI * ObjectUuid OPTIONAL
    )
/*++

Routine Description:

    This routine tests the RpcBindingToStringBinding API.

Arguments:

    UseThisStringBinding - Supplies the string binding to used in
        making the binding handle.

    ExpectedStringBinding - Supplies the expected string binding to be
        obtained from RpcBindingToStringBinding.

    ObjectUuid - Optionally supplies an object uuid which should be
        set in the binding handle.

Return Value:

    Zero will be returned if the test passes, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned char PAPI * StringBinding;

    Status = RpcBindingFromStringBindingA(UseThisStringBinding,&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFromStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)\n");
        return(1);
        }

    if (ARGUMENT_PRESENT(ObjectUuid))
        {
        Status = RpcBindingSetObject(BindingHandle,ObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingSetObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingSetObject\n");
            return(1);
            }
        }

    Status = RpcBindingToStringBindingA(BindingHandle,&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingToStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Create String Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    if (strcmp((char *) ExpectedStringBinding,(char *) StringBinding) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedStringBinding");
        PrintToConsole(" != StringBinding\n");
        return(1);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }

    Helga(BindingHandle);

    Status = RpcBindingToStringBindingA(BindingHandle,&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingToStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Create String Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    if (strcmp((char *) ExpectedStringBinding,(char *) StringBinding) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedStringBinding");
        PrintToConsole(" != StringBinding\n");
        return(1);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldInqSetObjectUuid (
    IN unsigned int SetObjectBeforeRpcFlag,
    IN unsigned int InqObjectBeforeRpcFlag,
    IN UUID PAPI * ObjectUuid,
    IN unsigned char PAPI * StringBinding
    )
/*++

Routine Description:

    This routine tests the RpcBindingInqObject and RpcBindingSetObject
    APIs.

Arguments:

    SetObjectBeforeRpcFlag - Supplies a flag that specifies when the
        object uuid in the binding handle should be set: one means
        the object uuid should be set before making a remote procedure
        call, and zero means afterward.

    InqObjectBeforeRpcFlag - Supplies a flag which is the same as the
        SetObjectBeforeRpcFlag, but it applies to inquiring the object
        uuid.

    ObjectUuid - Supplies the uuid to set in the binding handle.

    StringBinding - Supplies the string binding to use.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    UUID InqObjectUuid;
    RPC_BINDING_HANDLE BindingHandle;

    Status = RpcBindingFromStringBindingA(StringBinding,&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFromStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)\n");
        return(1);
        }

    if (SetObjectBeforeRpcFlag == 1)
        {
        Status = RpcBindingSetObject(BindingHandle,ObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingSetObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingSetObject\n");
            return(1);
            }
        }

    if (InqObjectBeforeRpcFlag == 1)
        {
        Status = RpcBindingInqObject(BindingHandle,&InqObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingInqObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingInqObject\n");
            return(1);
            }

        if (   (InqObjectUuid.Data1 != ObjectUuid->Data1)
            || (InqObjectUuid.Data2 != ObjectUuid->Data2)
            || (InqObjectUuid.Data3 != ObjectUuid->Data3)
            || (InqObjectUuid.Data4[0] != ObjectUuid->Data4[0])
            || (InqObjectUuid.Data4[1] != ObjectUuid->Data4[1])
            || (InqObjectUuid.Data4[2] != ObjectUuid->Data4[2])
            || (InqObjectUuid.Data4[3] != ObjectUuid->Data4[3])
            || (InqObjectUuid.Data4[4] != ObjectUuid->Data4[4])
            || (InqObjectUuid.Data4[5] != ObjectUuid->Data4[5])
            || (InqObjectUuid.Data4[6] != ObjectUuid->Data4[6])
            || (InqObjectUuid.Data4[7] != ObjectUuid->Data4[7]))
            {
            PrintToConsole("Fitzgerald : FAIL - InqObjectUuid !=");
            PrintToConsole(" SetObjectUuid\n");
            return(1);
            }
        }

    Helga(BindingHandle);

    if (SetObjectBeforeRpcFlag == 0)
        {
        Status = RpcBindingSetObject(BindingHandle,ObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingSetObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingSetObject\n");
            return(1);
            }
        }

    if (InqObjectBeforeRpcFlag == 0)
        {
        Status = RpcBindingInqObject(BindingHandle,&InqObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingInqObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingInqObject\n");
            return(1);
            }

        if (   (InqObjectUuid.Data1 != ObjectUuid->Data1)
            || (InqObjectUuid.Data2 != ObjectUuid->Data2)
            || (InqObjectUuid.Data3 != ObjectUuid->Data3)
            || (InqObjectUuid.Data4[0] != ObjectUuid->Data4[0])
            || (InqObjectUuid.Data4[1] != ObjectUuid->Data4[1])
            || (InqObjectUuid.Data4[2] != ObjectUuid->Data4[2])
            || (InqObjectUuid.Data4[3] != ObjectUuid->Data4[3])
            || (InqObjectUuid.Data4[4] != ObjectUuid->Data4[4])
            || (InqObjectUuid.Data4[5] != ObjectUuid->Data4[5])
            || (InqObjectUuid.Data4[6] != ObjectUuid->Data4[6])
            || (InqObjectUuid.Data4[7] != ObjectUuid->Data4[7]))
            {
            PrintToConsole("Fitzgerald : FAIL - InqObjectUuid !=");
            PrintToConsole(" SetObjectUuid\n");
            return(1);
            }
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
    }
    return(0);
}


int
FitzgeraldStringBindingAndObject (
    )
/*++

Routine Description:

    Fitzgerald uses this routine to test the RpcBindingToStringBinding,
    RpcBindingInqObject, and RpcBindingSetObject APIs.  We need to test
    them together because we need to check that the object uuid gets
    placed into the string binding.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    UUID ObjectUuid;
    unsigned char PAPI * StringBinding1;
    unsigned char PAPI * StringBinding2;

    if (FitzgeraldToStringBinding(GetStringBinding(FREDRICK,0,0),
            GetStringBinding(FREDRICK,0,0), 0))
        return(1);

    if (FitzgeraldToStringBinding(GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0),
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0), 0))
        return(1);

    ObjectUuid.Data1 = 0x12345678;
    ObjectUuid.Data2 = 0x9012;
    ObjectUuid.Data3 = 0xB456;
    ObjectUuid.Data4[0] = 0x80;
    ObjectUuid.Data4[1] = 0x01;
    ObjectUuid.Data4[2] = 0x08;
    ObjectUuid.Data4[3] = 0x00;
    ObjectUuid.Data4[4] = 0x2B;
    ObjectUuid.Data4[5] = 0x03;
    ObjectUuid.Data4[6] = 0x3D;
    ObjectUuid.Data4[7] = 0x7A;

    StringBinding1 = GetStringBinding(FREDRICK, 0, 0) ;
    StringBinding2 = GetStringBinding(FREDRICK,
                            "12345678-9012-B456-8001-08002B033D7A",0) ;

    if (FitzgeraldToStringBinding(StringBinding1, StringBinding2, &ObjectUuid))
        return(1);

#if 0
    if (FitzgeraldToStringBinding(GetStringBinding(FREDRICK,0,0),
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0), &ObjectUuid))
        return(1);
#endif

    if (FitzgeraldInqSetObjectUuid(1,1,&ObjectUuid,
            GetStringBinding(FREDRICK,0,0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(1,0,&ObjectUuid,
            GetStringBinding(FREDRICK,0,0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(0,0,&ObjectUuid,
            GetStringBinding(FREDRICK,0,0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(2,1,&ObjectUuid,
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(2,0,&ObjectUuid,
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0)))
        return(1);

    return(0);
}


int
FitzgeraldComTimeout (
    IN unsigned int SetBeforeRpc,
    IN unsigned int SetBeforeRpcTimeout,
    IN unsigned int InqBeforeRpc,
    IN unsigned int InqBeforeRpcTimeout,
    IN unsigned int SetAfterRpc,
    IN unsigned int SetAfterRpcTimeout,
    IN unsigned int InqAfterRpc,
    IN unsigned int InqAfterRpcTimeout
    )
/*++

Routine Description:

    Fitzgerald uses this routine to test the communications timeout
    management routines, RpcMgmtInqComTimeout and RpcMgmtSetComTimeout.

Arguments:

    SetBeforeRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be set before making a remote
        procedure call.

    SetBeforeRpcTimeout - Supplies the timeout value to be set before
        making a remote procedure call.

    InqBeforeRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be inquired before making a
        remote procedure call.

    InqBeforeRpcTimeout - Supplies the expected timeout value to be
        inquired before making a remote procedure call.

    SetAfterRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be set after making a remote
        procedure call.

    SetAfterRpcTimeout - Supplies the timeout value to be set after
        making a remote procedure call.

    InqAfterRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be inquired after making a
        remote procedure call.

    InqAfterRpcTimeout - Supplies the expected timeout value to be
        inquired after making a remote procedure call.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned int Timeout;

    Status = GetBinding(FREDRICK, &BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }

    if (SetBeforeRpc != 0)
        {
        Status = RpcMgmtSetComTimeout(BindingHandle,SetBeforeRpcTimeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtSetComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtSetComTimeout\n");
            return(1);
            }
        }

    if (InqBeforeRpc != 0)
        {
        Status = RpcMgmtInqComTimeout(BindingHandle,&Timeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtInqComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtInqComTimeout\n");
            return(1);
            }

        if (Timeout != InqBeforeRpcTimeout)
            {
            PrintToConsole("Fitzgerald : FAIL - Timeout != ");
            PrintToConsole("InqBeforeRpcTimeout\n");
            return(1);
            }
        }

    Helga(BindingHandle);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    if (SetAfterRpc != 0)
        {
        Status = RpcMgmtSetComTimeout(BindingHandle,SetAfterRpcTimeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtSetComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtSetComTimeout\n");
            return(1);
            }
        }

    if (InqAfterRpc != 0)
        {
        Status = RpcMgmtInqComTimeout(BindingHandle,&Timeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtInqComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtInqComTimeout\n");
            return(1);
            }

        if (Timeout != InqAfterRpcTimeout)
            {
            PrintToConsole("Fitzgerald : FAIL - Timeout != ");
            PrintToConsole("InqAfterRpcTimeout\n");
            return(1);
            }
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldTestFault (
    void
    )
/*++

Routine Description:

    This routine will test that faults get propogated correctly from the
    server back to the client.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE ExceptionBinding;

    Status = GetBinding(FREDRICK, &ExceptionBinding);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }

    Helga(ExceptionBinding);

    if (IsabelleRaiseException(ExceptionBinding, (unsigned char) ulSecurityPackage) != (unsigned char) ulSecurityPackage)
        {
        PrintToConsole("Fitzgerald : FAIL - Exception Not Raised\n");
        return(1);
        }

    Helga(ExceptionBinding);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&ExceptionBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (ExceptionBinding)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldContextHandle (
    )
{
    void PAPI * ContextHandle = 0;
    RPC_BINDING_HANDLE BindingHandle;
    unsigned long ContextUuid[5];


    Status = GetBinding(FREDRICK, &BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }


    Helga(BindingHandle);

    ContextUuid[0] = 0;
    ContextUuid[1] = 1;
    ContextUuid[2] = 2;
    ContextUuid[3] = 3;
    ContextUuid[4] = 4;

    NDRCContextUnmarshall(&ContextHandle, BindingHandle, ContextUuid,
            0x00L | 0x10L | 0x0000L);

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    HelgaUsingContextHandle(ContextHandle);
    RpcSsDestroyClientContext(&ContextHandle);
    if ( ContextHandle != 0 )
        {
        PrintToConsole("Fitzgerald : FAIL - ContextHandle != 0\n");
        return(1);
        }
    return(0);
}


void
Fitzgerald (
    )
/*++

Routine Description:

    We verify all client side APIs in this routine.  The idea is to
    emphasize complete coverage, rather than indepth coverage.  Actually,
    when I say all client side APIs, I really mean all client side APIs
    except for security and name service.  The following list is the
    APIs which will be tested by this routine.

    RpcBindingCopy
    RpcBindingFree
    RpcBindingFromStringBinding
    RpcBindingInqObject
    RpcBindingSetObject
    RpcBindingToStringBinding
    RpcStringBindingCompose
    RpcStringBindingParse
    RpcIfInqId
    RpcNetworkIsProtseqValid
    RpcMgmtInqComTimeout
    RpcMgmtSetComTimeout
    RpcStringFree

    UuidToString
    UuidFromString

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    RPC_IF_ID RpcIfId;
    UUID Uuid;
    unsigned char PAPI * String;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    Synchro(FREDRICK) ;

    PrintToConsole("Fitzgerald : Verify All Client APIs\n");

    if ( FitzgeraldContextHandle() != 0 )
        {
        return;
        }

    // Test that the routines to convert UUIDs to and from strings work
    // correctly.

    GenerateUuidValue(3768,&Uuid);
    Status = UuidToStringA(&Uuid, &String);
    if (Status)
        {
        ApiError("Fitzgerald", "UuidToString", Status);
        PrintToConsole("Fitzgerald : FAIL - UuidToString\n");
        return;
        }

    Status = UuidFromStringA(String, &Uuid);
    if (Status)
        {
        ApiError("Fitzgerald", "UuidFromString", Status);
        PrintToConsole("Fitzgerald : FAIL - UuidFromString\n");
        return;
        }

    Status = RpcStringFreeA(&String);
    if (Status)
        {
        ApiError("Fitzgerald", "RpcStringFree", Status);
        PrintToConsole("Fitzgerald : FAIL - RpcStringFree\n");
        return;
        }

    if ( CheckUuidValue(3768,&Uuid) != 0 )
        {
        OtherError("Fitzgerald", "CheckUuidValue() != 0");
        PrintToConsole("Fitzgerald : FAIL - CheckUuidValue() != 0\n");
        return;
        }

    Status = UuidFromString(0, &Uuid);
    if (Status)
        {
        ApiError("Fitzgerald", "UuidFromString", Status);
        PrintToConsole("Fitzgerald : FAIL - UuidFromString\n");
        return;
        }

    if (   ( Uuid.Data1 != 0 )
        || ( Uuid.Data2 != 0 )
        || ( Uuid.Data3 != 0 )
        || ( Uuid.Data4[0] != 0 )
        || ( Uuid.Data4[1] != 0 )
        || ( Uuid.Data4[2] != 0 )
        || ( Uuid.Data4[3] != 0 )
        || ( Uuid.Data4[4] != 0 )
        || ( Uuid.Data4[5] != 0 )
        || ( Uuid.Data4[6] != 0 )
        || ( Uuid.Data4[7] != 0 ) )
        {
        OtherError("Fitzgerald", "Uuid != NIL UUID");
        PrintToConsole("Fitzgerald : FAIL - Uuid != NIL UUID\n");
        return;
        }

    // Test that a null protocol sequence causes RPC_S_INVALID_RPC_PROTSEQ
    // to be returned rather than RPC_S_PROTSEQ_NOT_SUPPORTED.

    Status = RpcBindingFromStringBindingA(
            (unsigned char PAPI *) ":[\\\\pipe\\\\endpoint]",
            &IsabelleBinding);
    if (Status != RPC_S_INVALID_RPC_PROTSEQ)
        {
        ApiError("Fitzgerald","RpcBindingFromStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - RpcBindingFromStringBinding");
        PrintToConsole(" did not fail with RPC_S_INVALID_RPC_PROTSEQ\n");
        return;
        }

    Status = GetBinding(FREDRICK, &IsabelleBinding);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return;
        }

    Status = RpcNsBindingInqEntryNameA(IsabelleBinding, RPC_C_NS_SYNTAX_DCE,
            &String);
    if ( Status != RPC_S_NO_ENTRY_NAME )
        {
        ApiError("Fitzgerald","RpcNsBindingInqEntryName",Status);
        PrintToConsole("Fitzgerald : FAIL - RpcNsBindingInqEntryName");
        PrintToConsole(" Did Not Fail");
        return;
        }

    // This routine will test RpcStringBindingCompose,
    // RpcStringBindingParse, RpcStringFree for us.

    if (FitzgeraldComposeAndParse())
        return;

    // We test RpcBindingCopy here.

    if (FitzgeraldBindingCopy())
        return;

    // This particular routine gets to test RpcBindingToStringBinding,
    // RpcBindingInqObject, and RpcBindingSetObject.

    if (FitzgeraldStringBindingAndObject())
        return;

    if (FitzgeraldComTimeout(0,0,1,RPC_C_BINDING_DEFAULT_TIMEOUT,
            0,0,1,RPC_C_BINDING_DEFAULT_TIMEOUT))
        return;

    if (FitzgeraldComTimeout(1,RPC_C_BINDING_MAX_TIMEOUT,
            1,RPC_C_BINDING_MAX_TIMEOUT,0,0,1,RPC_C_BINDING_MAX_TIMEOUT))
        return;

    if (FitzgeraldComTimeout(0,0,0,0,1,RPC_C_BINDING_MAX_TIMEOUT,
            1,RPC_C_BINDING_MAX_TIMEOUT))
        return;

    // We need to test faults.  This is done by this routine.

    if (FitzgeraldTestFault())
        return;

    Status = RpcBindingSetObject(IsabelleBinding, 0);
    if (Status)
        {
        ApiError("Fitzgerald", "RpcBindingSetObject", Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Set Object\n");
        return;
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    Status = RpcIfInqId((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
        &RpcIfId);
    if (Status)
        {
        ApiError("Fitzgerald","RpcIfInqId",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcIfInqId\n");
        return;
        }

    if (   (RpcIfId.VersMajor != 1)
        || (RpcIfId.VersMinor != 1)
        || (RpcIfId.Uuid.Data1 != 9)
        || (RpcIfId.Uuid.Data2 != 8)
        || (RpcIfId.Uuid.Data3 != 8)
        || (RpcIfId.Uuid.Data4[0] != 7)
        || (RpcIfId.Uuid.Data4[1] != 7)
        || (RpcIfId.Uuid.Data4[2] != 7)
        || (RpcIfId.Uuid.Data4[3] != 7)
        || (RpcIfId.Uuid.Data4[4] != 7)
        || (RpcIfId.Uuid.Data4[5] != 7)
        || (RpcIfId.Uuid.Data4[6] != 7)
        || (RpcIfId.Uuid.Data4[7] != 7))
        {
        PrintToConsole("Fitzgerald : FAIL - Wrong RpcIfId\n");
        return;
        }
    Status = RpcNetworkIsProtseqValidA((unsigned char *) "ncacn_np");
    if (Status)
        {
        ApiError("Fitzgerald","RpcNetworkIsProtseqValid",Status);
        PrintToConsole("Fitzgerald : FAIL - RpcNetworkIsProtseqValid");
        PrintToConsole(" Failed\n");
        return;
        }

    Status = RpcNetworkIsProtseqValidA((unsigned char *) "nope_np");
    if (Status != RPC_S_INVALID_RPC_PROTSEQ)
        {
        PrintToConsole("Fitzgerald : FAIL - RpcNetworkIsProtseqValid");
        PrintToConsole(" != RPC_S_INVALID_RPC_PROTSEQ\n");
        return;
        }

    Status = RpcNetworkIsProtseqValidA((unsigned char *) "ncacn_fail");
    if (Status != RPC_S_PROTSEQ_NOT_SUPPORTED)
        {
        PrintToConsole("Fitzgerald : FAIL - RpcNetworkIsProtseqValid");
        PrintToConsole(" != RPC_S_PROTSEQ_NOT_SUPPORTED\n");
        return;
        }

    PrintToConsole("Fitzgerald : PASS\n");
}


void
Charles (
    )
/*++

Routine Description:

    This routine works with Christopher in usvr.exe to test all
    server APIs (all except security and name service APIs).

--*/
{
    RPC_BINDING_HANDLE ChristopherBinding;
    RPC_BINDING_HANDLE ChristopherHelgaBinding;
    RPC_BINDING_HANDLE ChristopherIsabelleBinding;
    RPC_BINDING_HANDLE ChristopherHelgaNoEndpoint;
    UUID ObjectUuid;

   if ( NumberOfTestsRun++ )
        {
        PauseExecution(30000);
        }

    Synchro(CHRISTOPHER) ;


    PrintToConsole("Charles : Verify All Server APIs\n");

    Status = GetBinding(CHRISTOPHER, &ChristopherBinding);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(Christopher)\n");
        return;
        }


    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    Status = GetBinding(CHRISTOPHERHELGA, &ChristopherHelgaBinding);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(ChristopherHelga)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherHelgaBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    Status = GetBinding(CHRISTOPHERISABELLE, &ChristopherIsabelleBinding);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(ChristopherIsabelle)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherIsabelleBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    Status = GetBinding(NOENDPOINT, &ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(ChristopherHelgaNoEndpoint)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherHelgaNoEndpoint, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    SylviaBinding = ChristopherBinding;
    if (SylviaCall(ChristopherBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Charles : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    SylviaBinding = ChristopherHelgaBinding;
    if (SylviaCall(ChristopherHelgaBinding,10,5,0)
            != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Charles : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    SylviaBinding = ChristopherIsabelleBinding;
    if (SylviaCall(ChristopherIsabelleBinding,10,5,0)
            != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Charles : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    IsabelleToStringBinding(ChristopherBinding);
    IsabelleToStringBinding(ChristopherIsabelleBinding);
    IsabelleToStringBinding(ChristopherHelgaBinding);

    TestHelgaInterface(ChristopherHelgaNoEndpoint, HelgaMaxSize);

    Status = RpcBindingReset(ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles", "RpcBindingReset", Status);
        PrintToConsole("Charles : FAIL - Unable to Reset");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    Helga(ChristopherHelgaNoEndpoint);

    Status = RpcBindingReset(ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles", "RpcBindingReset", Status);
        PrintToConsole("Charles : FAIL - Unable to Reset");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    Helga(ChristopherHelgaNoEndpoint);

    Status = RpcBindingReset(ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles", "RpcBindingReset", Status);
        PrintToConsole("Charles : FAIL - Unable to Reset");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    IsabelleShutdown(ChristopherBinding);

    // We need an extra delay in here because Christopher performs some
    // other tests after RpcServerListen returns.

    PauseExecution(LONG_TESTDELAY);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Charles : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Charles : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Charles : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&ChristopherHelgaBinding);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherHelgaBinding)\n");
        return;
        }

    Status = RpcBindingFree(&ChristopherBinding);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherBinding)\n");
        return;
        }

    Status = RpcBindingFree(&ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    Status = RpcBindingFree(&ChristopherIsabelleBinding);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherIsabelleBinding)\n");
        return;
        }

    PrintToConsole("Charles : PASS\n");
}


int
ThomasNtSecurity
(
    IN char * NetworkOptions
    )
/*++

Routine Description:

    Thomas uses this routine to test NT security and RPC.

Arguments:

    NetworkOptions - Supplies the network options to be used for the
        binding.

Return Value:

    Zero will be returned if the test completes successfully, otherwise,
    non-zero will be returned.

--*/
{
    RPC_BINDING_HANDLE ThomasNormalBinding;

    Status = RpcBindingFromStringBindingA(
            GetStringBinding(TYLER,0,(unsigned char *) NetworkOptions),
                    &ThomasNormalBinding);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFromStringBinding",Status);
        PrintToConsole("Thomas : FAIL - Unable to Bind (Tyler)\n");
        return(1);
        }

    IsabelleNtSecurity(ThomasNormalBinding,
            strlen((char *) NetworkOptions) + 1, NetworkOptions);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Thomas : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&ThomasNormalBinding);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFree",Status);
        PrintToConsole("Thomas : FAIL - Unable to Free Binding");
        PrintToConsole(" (ThomasNormalBinding)\n");
        return(1);
        }

    return(0);
}


int
ThomasTestNtSecurity (
    )
/*++

Routine Description:

    This helper routine tests NT security (such as over named pipes and
    lpc).

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{
    if (ThomasNtSecurity("") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Dynamic True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Static True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Dynamic False") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Static False") != 0)
        return(1);


    if (ThomasNtSecurity("Security=Anonymous Dynamic True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Anonymous Static True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Anonymous Dynamic False") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Anonymous Static False") != 0)
        return(1);


    if (ThomasNtSecurity("Security=Impersonation Dynamic True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Impersonation Static True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Impersonation Dynamic False") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Impersonation Static False") != 0)
        return(1);

    return(0);
}


int
ThomasInqSetAuthInfo (
    IN unsigned char PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN unsigned long AuthzSvc,
    IN RPC_STATUS ExpectedResult,
    IN unsigned long ExpectedAuthnLevel
    )
/*++

Routine Description:

    We test RpcBindingSetAuthInfo and RpcBindingInqAuthInfo in this
    routine.

Arguments:

    ServerPrincName - Supplies the server principal name to use.

    AuthnLevel - Supplies the authentication level to use.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentity - Supplies the security context to use.

    AuthzSvc - Supplies the authorization service to use.

    ExpectedResult - Supplies the result expected from RpcBindingSetAuthInfo.

    ExpectedAuthnLevel - Supplies the expected authentication level to
        be obtained from RpcBindingSetAuthInfo.

Return Value:

    A non-zero result indicates that the test failed.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    unsigned long AuthorizationService;
    unsigned char IgnoreString[4];

    Status = GetBinding(TYLER, &BindingHandle);
    if (Status)
        {
        ApiError("Thomas", "GetBinding", Status);
        PrintToConsole("Thomas : FAIL - Unable to Bind (Tyler)\n");
        return(1);
        }

    if (gPrincName)
        {
        ServerPrincName = (unsigned char *)gPrincName;
        }

    Status = RpcBindingSetAuthInfoA(BindingHandle, ServerPrincName, AuthnLevel,
            AuthnSvc, AuthIdentity, AuthzSvc);
    if ( Status != ExpectedResult )
        {
        ApiError("Thomas", "RpcBindingSetAuthInfo", Status);
        PrintToConsole("Thomas : FAIL - RpcBindingSetAuthInfo, Unexpected");
        PrintToConsole(" Result\n");
        return(1);
        }

    if (Status)
        {
        return(0);
        }

    Status = RpcBindingInqAuthInfo(BindingHandle, 0, &AuthenticationLevel,
            &AuthenticationService, 0, &AuthorizationService);
    if (Status)
        {
        ApiError("Thomas", "RpcBindingInqAuthInfo", Status);
        PrintToConsole("Thomas : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthenticationLevel != ExpectedAuthnLevel )
        {
        PrintToConsole("Thomas : WARNING - ");
        PrintToConsole("AuthenticationLevel != ExpectedAuthnLevel\n");
        }

    if ( AuthenticationService != AuthnSvc )
        {
        OtherError("Thomas", "AuthenticationService != AuthnSvc");
        PrintToConsole("Thomas : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthorizationService != AuthzSvc )
        {
        OtherError("Thomas", "AuthorizationService != AuthzSvc");
        PrintToConsole("Thomas : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    TestHelgaInterface(BindingHandle, HelgaMaxSize);
    IsabelleNtSecurity(BindingHandle, 1, IgnoreString);

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFree",Status);
        PrintToConsole("Thomas : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
ThomasTestRpcSecurity (BOOL fServerIsNTSystem
    )
/*++

Routine Description:

    This routine exercises rpc protocol level security support in the
    runtime.

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{
    RPC_AUTH_IDENTITY_HANDLE AuthId = NULL;
    OSVERSIONINFO versionInfo;

    if(ulSecurityPackage == 123)
        AuthId = 0 ;

    // if platform is Win98 and transport is MSMQ, no point of doing security tests
    // Falcon will try to upgrade connection level authentication to packet, which in turn
    // will be rejected by the security system. The only possible connection is not authenticated
    if (TransportType == RPC_TRANSPORT_MSMQ)
        {
        memset(&versionInfo, 0, sizeof(versionInfo));
        versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
        GetVersionEx(&versionInfo);
        if (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            return 0;
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }
    }

    if (!fServerIsNTSystem)
        return 0;

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }
    }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }
    }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) != 0 )
        {
        return(1);
        }
    }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }
    }

    return(0);
}


#ifdef WIN32RPC
int
ThomasTestLRpcSecurity (
    )
/*++

Routine Description:

    This routine exercises rpc protocol level security support in the
    runtime.

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{

    SEC_WINNT_AUTH_IDENTITY  ntssp;
    RPC_AUTH_IDENTITY_HANDLE AuthId = &ntssp;

    ntssp.User     = (RPC_CHAR *) SecurityUser;
    if (ntssp.User)
        {
        ntssp.UserLength = lstrlen((const RPC_SCHAR *) SecurityUser);
        }
    else
        {
        ntssp.UserLength = 0;
        }

    ntssp.Domain   = (RPC_CHAR *) SecurityDomain;
    if (ntssp.Domain)
        {
        ntssp.DomainLength = lstrlen((const RPC_SCHAR *) SecurityDomain);
        }
    else
        {
        ntssp.DomainLength = 0;
        }

    ntssp.Password = (RPC_CHAR *) SecurityPassword;
    if (ntssp.Password)
        {
        ntssp.PasswordLength = lstrlen((const RPC_SCHAR *) SecurityPassword);
        }
    else
        {
        ntssp.PasswordLength = 0;
        }

    ntssp.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // LRPC can only use 10
    ulSecurityPackage = 10 ;
    unsigned long size = 256;
    char UserName[256];
    char Tmp[256];

    //
    // hack
    //
    strcpy(UserName, "redmond\\");

    if (GetUserNameA(Tmp, &size) == 0)
        {
        return (1);
        }

    strcat(UserName, Tmp);

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    return(0);
}
#endif



void
Thomas (
    )
/*++

Routine Description:

    This routine is used to test security, both at the transport level,
    and at the RPC level.  We work with Tyler in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    BOOL fServerIsNTSystem;

    Synchro(TYLER) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Thomas : Test Security\n");

    Status = GetBinding(TYLER, &IsabelleBinding);
    if (Status)
        {
        ApiError("Thomas","GetBinding",Status);
        PrintToConsole("Thomas : FAIL - Unable to Bind (Tyler)\n");
        return;
        }

    fServerIsNTSystem = IsServerNTSystem(IsabelleBinding);

    // change here to test rpc security for LRPC also

    if(TransportType != RPC_LRPC)
        {
        if ( ThomasTestRpcSecurity(fServerIsNTSystem) != 0 )
            {
            return;
            }
        }

    if ( TransportType == RPC_TRANSPORT_NAMEPIPE || TransportType == RPC_LRPC )
        {
        if ( ThomasTestNtSecurity() != 0 )
            {
            return;
            }
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Thomas : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFree",Status);
        PrintToConsole("Thomas : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Thomas : PASS\n");
}


int
TimInqSetAuthInfo (
    IN unsigned char PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN unsigned long AuthzSvc,
    IN RPC_STATUS ExpectedResult,
    IN unsigned long ExpectedAuthnLevel
    )
/*++

Routine Description:

    We test RpcBindingSetAuthInfo and RpcBindingInqAuthInfo in this
    routine.

Arguments:

    ServerPrincName - Supplies the server principal name to use.

    AuthnLevel - Supplies the authentication level to use.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentity - Supplies the security context to use.

    AuthzSvc - Supplies the authorization service to use.

    ExpectedResult - Supplies the result expected from RpcBindingSetAuthInfo.

    ExpectedAuthnLevel - Supplies the expected authentication level to
        be obtained from RpcBindingSetAuthInfo.

Return Value:

    A non-zero result indicates that the test failed.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    unsigned long AuthorizationService;
    unsigned char IgnoreString[4];

    Status = GetBinding(TYLER, &BindingHandle);
    if (Status)
        {
        ApiError("Tim", "GetBinding", Status);
        PrintToConsole("Tim : FAIL - Unable to Bind (Tyler)\n");
        return(1);
        }

    Status = RpcBindingSetAuthInfoA(BindingHandle, ServerPrincName, AuthnLevel,
            AuthnSvc, AuthIdentity, AuthzSvc);
    if ( Status != ExpectedResult )
        {
        ApiError("Tim", "RpcBindingSetAuthInfo", Status);
        PrintToConsole("Tim : FAIL - RpcBindingSetAuthInfo, Unexpected");
        PrintToConsole(" Result\n");
        return(1);
        }

    if (Status)
        {
        return(0);
        }

    Status = RpcBindingInqAuthInfo(BindingHandle, 0, &AuthenticationLevel,
            &AuthenticationService, 0, &AuthorizationService);
    if (Status)
        {
        ApiError("Tim", "RpcBindingInqAuthInfo", Status);
        PrintToConsole("Tim : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthenticationLevel != ExpectedAuthnLevel )
        {
        PrintToConsole("Tim : WARNING - ");
        PrintToConsole("AuthenticationLevel != ExpectedAuthnLevel\n");
        }

    if ( AuthenticationService != AuthnSvc )
        {
        OtherError("Tim", "AuthenticationService != AuthnSvc");
        PrintToConsole("Tim : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthorizationService != AuthzSvc )
        {
        OtherError("Tim", "AuthorizationService != AuthzSvc");
        PrintToConsole("Tim : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    TestHelgaInterface(BindingHandle, HelgaMaxSize);
    IsabelleNtSecurity(BindingHandle, 1, IgnoreString);

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Tim","RpcBindingFree",Status);
        PrintToConsole("Tim : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
TimTestRpcSecurity (
    )
/*++

Routine Description:

    This routine exercises rpc protocol level security support in the
    runtime.

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{

    RPC_AUTH_IDENTITY_HANDLE AuthId = NULL;

    // RPC_C_AUTHN_WINNT to ulSecurityPackage in the intrest of generality
    if ( TimInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }

    // RPC_C_AUTHN_WINNT to ulSecurityPackage in the intrest of generality
    if ( TimInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage,
                              AuthId,
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }

    return(0);
}


void
Tim (
    )
/*++

Routine Description:

    This routine is used to test security, both at the transport level,
    and at the RPC level.  We work with Terry in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;

    Synchro(TYLER) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Tim : Test Security\n");

    Status = GetBinding(TYLER, &IsabelleBinding);
    if (Status)
        {
        ApiError("Tim","GetBinding",Status);
        PrintToConsole("Tim : FAIL - Unable to Bind (Tyler)\n");
        return;
        }


    if ( TransportType != RPC_LRPC )
        {
        if ( TimTestRpcSecurity() != 0 )
            {
            return;
            }
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Tim : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Tim","RpcBindingFree",Status);
        PrintToConsole("Tim : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Tim : PASS\n");
}


void
Robert (
    )
/*++

Routine Description:

    Robert works with Richard (in usvr.cxx) to test call and callback
    failures.

--*/
{
    RPC_BINDING_HANDLE RichardBinding;
    RPC_BINDING_HANDLE RichardHelperBinding;
    unsigned int RetryCount;

    Synchro(RICHARD) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Robert : Test Call and Callback Failures\n");

    Status = GetBinding(RICHARD, &RichardBinding);
    if (Status)
        {
        ApiError("Robert","GetBinding",Status);
        PrintToConsole("Robert : FAIL - Unable to Bind (Richard)\n");
        return;
        }


    Status = GetBinding(RICHARDHELPER, &RichardHelperBinding);
    if (Status)
        {
        ApiError("Robert","GetBinding",Status);
        PrintToConsole("Robert : FAIL - Unable to Bind (RichardHelper)\n");
        return;
        }

    Status = IsabelleRichardHelper(RichardBinding,RICHARDHELPER_EXECUTE);
    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

  //  PauseExecution(30000L);
   Synchro(RICHARDHELPER) ;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        Status = IsabelleRichardHelper(RichardHelperBinding,
                RICHARDHELPER_IGNORE);
        if (Status == RPC_S_OK)
            break;
        PauseExecution(RETRYDELAY);
        }

    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    Status = IsabelleRichardHelper(RichardHelperBinding, RICHARDHELPER_EXIT);
    if (Status == RPC_S_OK)
        {
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXIT) ");
        PrintToConsole("Succeeded\n");
        return;
        }

    if (Status != RPC_S_CALL_FAILED)
        {
        PrintToConsole("Robert : WARN - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXIT) != ");
        PrintToConsole("RPC_S_CALL_FAILED\n");
        }

    PauseExecution(TestDelay);

    Status = IsabelleRichardHelper(RichardHelperBinding,RICHARDHELPER_IGNORE);

    if (Status == RPC_S_OK)
        {
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE) ");
        PrintToConsole("Succeeded\n");
        return;
        }

    PrintToConsole("Robert : Spawning RichardHelper again\n") ;
    Status = IsabelleRichardHelper(RichardBinding,RICHARDHELPER_EXECUTE);

    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

 //   PauseExecution(30000L);
   Synchro(RICHARDHELPER) ;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        Status = IsabelleRichardHelper(RichardHelperBinding,
                RICHARDHELPER_IGNORE);
        if (Status == RPC_S_OK)
            break;
        PauseExecution(RETRYDELAY);
        }

    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    IsabelleShutdown(RichardHelperBinding);
    IsabelleShutdown(RichardBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Robert : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&RichardBinding);
    if (Status)
        {
        ApiError("Robert","RpcBindingFree",Status);
        PrintToConsole("Robert : FAIL - Unable to Free Binding");
        PrintToConsole(" (RichardBinding)\n");
        return;
        }

    Status = RpcBindingFree(&RichardHelperBinding);
    if (Status)
        {
        ApiError("Robert","RpcBindingFree",Status);
        PrintToConsole("Robert : FAIL - Unable to Free Binding");
        PrintToConsole(" (RichardHelperBinding)\n");
        return;
        }

    PrintToConsole("Robert : PASS\n");
}


void
Keith (
    )
/*++

Routine Description:

    Keith works with Kenneth (in usvr.cxx) to test auto-reconnect.

--*/
{
    RPC_BINDING_HANDLE KennethBinding;
    RPC_BINDING_HANDLE KennethHelperBinding;

    Synchro(KENNETH) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Keith : Test Auto Reconnect\n");

    Status = GetBinding(KENNETH, &KennethBinding);
    if (Status)
        {
        ApiError("Keith","GetBinding",Status);
        PrintToConsole("Keith : FAIL - Unable to Bind (Kenneth)\n");
        return;
        }

    Status = GetBinding(RICHARDHELPER, &KennethHelperBinding);
    if (Status)
        {
        ApiError("Keith","GetBinding",Status);
        PrintToConsole("Keith : FAIL - Unable to Bind (KennethHelper)\n");
        return;
        }

    Status = IsabelleRichardHelper(KennethBinding, RICHARDHELPER_EXECUTE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

    PauseExecution(20000L);

    Status = IsabelleRichardHelper(KennethHelperBinding, RICHARDHELPER_IGNORE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    Status = IsabelleRichardHelper(KennethHelperBinding,
            RICHARDHELPER_DELAY_EXIT);
    if (Status != RPC_S_OK)
        {
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_DELAY_EXIT) ");
        PrintToConsole("Failed\n");
        return;
        }

    PauseExecution(30000L);

    Status = IsabelleRichardHelper(KennethBinding, RICHARDHELPER_EXECUTE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

    PauseExecution(40000L);

    Status = IsabelleRichardHelper(KennethHelperBinding, RICHARDHELPER_IGNORE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    IsabelleShutdown(KennethHelperBinding);
    IsabelleShutdown(KennethBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Keith : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&KennethBinding);
    if (Status)
        {
        ApiError("Keith","RpcBindingFree",Status);
        PrintToConsole("Keith : FAIL - Unable to Free Binding");
        PrintToConsole(" (KennethBinding)\n");
        return;
        }

    Status = RpcBindingFree(&KennethHelperBinding);
    if (Status)
        {
        ApiError("Keith","RpcBindingFree",Status);
        PrintToConsole("Keith : FAIL - Unable to Free Binding");
        PrintToConsole(" (KennethHelperBinding)\n");
        return;
        }

    PrintToConsole("Keith : PASS\n");
}


void
Daniel (
    )
/*++

Routine Description:

    This routine is used to test association context rundown support;
    it works with David in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE DanielFirst;;
    RPC_BINDING_HANDLE DanielSecond;
    CCONTEXT *ContextHandle, *ContextHandle2;

    Synchro(DAVIDFIRST) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Daniel : Association Context and Rundown\n");

    Status = GetBinding(DAVIDFIRST, &DanielFirst);
    if (Status)
        {
        ApiError("Daniel","GetBinding",Status);
        PrintToConsole("Daniel : FAIL - Unable to Bind (DavidFirst)\n");
        return;
        }


    Status = GetBinding(DAVIDSECOND, &DanielSecond);
    if (Status)
        {
        ApiError("Daniel","GetBinding",Status);
        PrintToConsole("Daniel : FAIL - Unable to Bind (DavidSecond)\n");
        return;
        }

    IsabelleSetRundown(DanielSecond);
    IsabelleCheckContext(DanielSecond);

    #ifdef DEBUGRPC
    PrintToDebugger("\n\n\n\nUCLNT: Calling RpcBindingFree\n");
    #endif

    Status = RpcBindingFree(&DanielSecond);
    if (Status)
        {
        ApiError("Daniel","RpcBindingFree",Status);
        PrintToConsole("Daniel : FAIL - Unable to Free Binding");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    PauseExecution(3000L);

    IsabelleCheckRundown(DanielFirst);

    ContextHandle = (CCONTEXT *)I_RpcAllocate(sizeof(CCONTEXT));
    if (!ContextHandle)
        {
        ApiError("Daniel","I_RpcAllocate",Status);
        PrintToConsole("Daniel : FAIL - Unable to I_RpcAllocate");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    OpenContextHandle(DanielFirst, &IsabelleInterfaceInformation, NULL);

    OpenContextHandle(DanielFirst, &IsabelleInterfaceInformation, ContextHandle);

    Status = RpcBindingCopy(ContextHandle, (RPC_BINDING_HANDLE *)&ContextHandle2);
    if (Status)
        {
        ApiError("Daniel","RpcBindingCopy",Status);
        PrintToConsole("Daniel : FAIL - Unable to copy context handle");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    Status = RpcBindingSetOption(ContextHandle2, RPC_C_OPT_DONT_LINGER, TRUE);
    if (Status)
        {
        ApiError("Daniel","RpcBindingSetOption",Status);
        PrintToConsole("Daniel : FAIL - Unable to set context handle options");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    RpcSsDestroyClientContext((void **)&ContextHandle);
    RpcSsDestroyClientContext((void **)&ContextHandle2);

    OpenContextHandle(DanielFirst, &HelgaInterfaceInformation, NULL);
    OpenContextHandle(DanielFirst, &HelgaInterfaceInformation, NULL);

    UnregisterHelgaEx(DanielFirst);

    IsabelleShutdown(DanielFirst);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Daniel : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&DanielFirst);
    if (Status)
        {
        ApiError("Daniel","RpcBindingFree",Status);
        PrintToConsole("Daniel : FAIL - Unable to Free Binding");
        PrintToConsole(" (DanielFirst)\n");
        return;
        }

    PrintToConsole("Daniel : PASS\n");
}


int
BenjaminTestBinding (
    IN unsigned char PAPI * StringBinding
    )
/*++

Routine Description:

    This helper routine will take and convert the string binding into
    a binding, use the binding to make a remote procedure call, and
    then free the binding.

Arguments:

    StringBinding - Supplies the string binding to use to convert into
        a binding.

Return Value:

    If the test passes, zero will be returned; otherwise, non-zero will
    be returned.

--*/
{
    RPC_BINDING_HANDLE Binding;
    unsigned char PAPI * ObjUuid;
    unsigned char PAPI * Protseq;
    unsigned char PAPI * NetworkAddr;
    unsigned char PAPI * NetworkOptions;
    int OldCallbacksFlag = 0;
    unsigned int TransportType;

    if ( UseEndpointMapperFlag != 0 )
        {
        Status = RpcStringBindingParseA(StringBinding, &ObjUuid, &Protseq,
                &NetworkAddr, 0, &NetworkOptions);
        if (Status)
            {
            ApiError("Benjamin", "RpcStringBindingParse", Status);
            PrintToConsole("Benjamin : RpcStringBindingParse Failed\n");
            return(1);
            }

        Status = RpcStringBindingComposeA(ObjUuid, Protseq, NetworkAddr, 0,
                NetworkOptions, &StringBinding);
        if (Status)
            {
            ApiError("Benjamin", "RpcStringBindingCompose", Status);
            PrintToConsole("Benjamin : RpcStringBindingCompose Failed\n");
            return(1);
            }

        Status = RpcStringFreeA(&Protseq);
        if (!Status)
              RpcStringFreeA(&NetworkOptions);
        if (!Status)
              RpcStringFreeA(&ObjUuid);
        if (Status)
           {
            ApiError("Benjamin", "RpcStringFree", Status);
            PrintToConsole("Benjamin : RpcStringFree Failed\n");
            return(1);
           }

        }

    PrintToConsole("Benjamin : ");
    PrintToConsole("%s - ", StringBinding);

    Status = RpcBindingFromStringBindingA(StringBinding, &Binding);
    if (Status)
        {
        if (Status == RPC_S_PROTSEQ_NOT_SUPPORTED)
            {
            return(0);
            }
        ApiError("Benjamin", "RpcBindingFromStringBinding", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Binding");
        PrintToConsole(" (StringBinding)\n");
        return(1);
        }

    SylviaBinding = Binding;

    Status = I_RpcBindingInqTransportType(SylviaBinding, &TransportType);

    if (Status)
        {
        ApiError("Benjamin", "I_RpcBindingInqTransportType", Status);
        PrintToConsole("Benjamin : I_RpcBindingInqTransportType Failed\n");
        return(1);
        }

    switch(TransportType)
        {
        case TRANSPORT_TYPE_CN:
            PrintToConsole("( cn )\n");
            break;
        case TRANSPORT_TYPE_DG:
            PrintToConsole(" ( dg )\n");
            break;
        case TRANSPORT_TYPE_LPC:
            PrintToConsole("( lpc )\n");
            break;
        default:
            {
            PrintToConsole("Benjamin : FAIL - Incorrect result");
            PrintToConsole("Benjamin : I_RpcBindingInqTransportType Failed\n");
            return(1);
            }
        }

    //This is a temporary workaround till dg implements callbacks
    //What we want to do is if the transport type is datagram, set the no
    //callback flag even if user didnt specify. Then unset it again!

    if (TransportType == TRANSPORT_TYPE_DG)
        {
        OldCallbacksFlag = NoCallBacksFlag;
        NoCallBacksFlag = 1;
        }

    if ( SylviaCall(SylviaBinding, 5, 0, 0) != LocalSylviaCall(5, 0, 0) )
        {
        PrintToConsole("Benjamin : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(5,0,0)\n");
        return(1);
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Benjamin : FAIL - Error(s) in Sylvia");
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    if (TransportType == TRANSPORT_TYPE_DG)
       {
         NoCallBacksFlag = OldCallbacksFlag;
       }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Benjamin", "RpcBindingFree", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return(1);
        }


    return(0);
}


void
Benjamin (
    )
/*++

Routine Description:

    This routine works with Bartholomew in usvr.exe to test that
    dynamic endpoints work.  What we actually do is inquire all bindings
    supported by the server, and then this client binds to each of
    them, and makes a call.

--*/
{
    RPC_BINDING_HANDLE Bartholomew;
    unsigned char * StringBinding;

    Synchro(BARTHOLOMEW) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(4*LONG_TESTDELAY);
        }

    PrintToConsole("Benjamin : Test Dynamic Endpoints\n");

    Status = GetBinding(BARTHOLOMEW, &Bartholomew);
    if (Status)
        {
        ApiError("Benjamin", "GetBinding", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Bind (Bartholomew)\n");
        return;
        }


    while ((StringBinding = IsabelleGetStringBinding(Bartholomew)) != 0)
        {
        if (0 != strstr("http", (char *) StringBinding))
            {
            delete StringBinding;
            continue;
            }

        if (BenjaminTestBinding(StringBinding) != 0)
            return;
        delete StringBinding;
        }

    IsabelleShutdown(Bartholomew);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Benjamin : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Bartholomew);
    if (Status)
        {
        ApiError("Benjamin", "RpcBindingFree", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Free Binding");
        PrintToConsole(" (Bartholomew)\n");
        return;
        }

    PrintToConsole("Benjamin : PASS\n");
}


void
Harold (
    )
/*++

Routine Description:

    This routine works with Herman in usvr.exe to test that idle
    connections get cleaned up properly, and that context is maintained.

--*/
{
    RPC_BINDING_HANDLE Binding, ContextBinding;
    int seconds;

    PrintToConsole("Harold : Test Idle Connection Cleanup and Context\n");
    Synchro(HERMAN) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    Status = RpcMgmtEnableIdleCleanup();
    if (Status)
        {
        ApiError("Harold","RpcMgmtEnableIdleCleanup",Status);
        PrintToConsole("Harold : FAIL - RpcMgmtEnableIdleCleanup\n");
        return;
        }

    Status = GetBinding(HERMAN, &Binding);
    if (Status)
        {
        ApiError("Harold","GetBinding",Status);
        PrintToConsole("Harold : FAIL - Unable to Bind (Herman)\n");
        return;
        }


    IsabelleSetRundown(Binding);
    IsabelleCheckContext(Binding);

    // We want to wait for eight minutes.  This will give enough time for
    // the cleanup code to get run to cleanup the idle connection.

    PrintToConsole("Harold : Waiting");
    for (seconds = 0; seconds < 30; seconds++)
        {
        PauseExecution(1000L);
        PrintToConsole(".");
        }
    PrintToConsole("\n");

    IsabelleCheckRundown(Binding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Harold : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = I_RpcBindingCopy(Binding, &ContextBinding);
    if (Status)
        {
        ApiError("Harold", "I_RpcBindingCopy", Status);
        PrintToConsole("Harold : FAIL - I_RpcBindingCopy Failed\n");
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Harold","RpcBindingFree",Status);
        PrintToConsole("Harold : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    IsabelleSetRundown(ContextBinding);
    IsabelleCheckContext(ContextBinding);

    // We want to wait for eight minutes.  This will give enough time for
    // the cleanup code to get run to cleanup the idle connection, but this
    // time the connection should not be cleaned up because we have got
    // context open.

    PrintToConsole("Harold : Waiting");
    for (seconds = 0; seconds < 30; seconds++)
        {
        PauseExecution(1000L);
        PrintToConsole(".");
        }
    PrintToConsole("\n");

    IsabelleCheckNoRundown(ContextBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Harold : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }


    IsabelleShutdown(ContextBinding);

    Status = RpcBindingFree(&ContextBinding);
    if (Status)
        {
        ApiError("Harold","RpcBindingFree",Status);
        PrintToConsole("Harold : FAIL - Unable to Free Binding");
        PrintToConsole(" (ContextBinding)\n");
        return;
        }

    PrintToConsole("Harold : PASS\n");
}


unsigned int JamesSize = 128;
unsigned int JamesCount = 100;


void
James (
    )
/*++

Routine Description:

    This routine works with Jason in usvr.exe to perform timing tests
    of the runtime.

--*/
{
    RPC_BINDING_HANDLE Binding;
    unsigned int Count;
    unsigned long StartingTime, EndingTime;
    unsigned char PAPI * StringBinding;
    UUID ObjectUuid;

    PrintToConsole("James : Timing Test (%d) %d times\n", JamesSize,
            JamesCount);

    Synchro(JASON) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    //
    // Bind, NullCall, Free
    //

    StringBinding = GetStringBinding(JASON,0,0);
    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        Status = RpcBindingFromStringBindingA(StringBinding,&Binding);
        if (Status)
            {
            ApiError("James","RpcBindingFromStringBinding",Status);
            PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
            return;
            }

        if (fUniqueBinding)
            {
            Status = RpcBindingSetOption( Binding, RPC_C_OPT_UNIQUE_BINDING, TRUE );
            if (Status != RPC_S_OK)
                {
                ApiError("James","RpcBindingSetOption",Status);
                return;
                }
            }

        Helga(Binding);

        if (HelgaErrors != 0)
            {
            PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
            HelgaErrors = 0;
            return;
            }

        Status = RpcBindingFree(&Binding);
        if (Status)
            {
            ApiError("James","RpcBindingFree",Status);
            PrintToConsole("James : FAIL - Unable to Free Binding");
            PrintToConsole(" (Binding)\n");
            return;
            }
        }

    EndingTime = GetCurrentTime();
    PrintToConsole("    Bind, NullCall, Free : %d.%d ms [%d in %d milliseconds]\n",
            (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // NullCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        Helga(Binding);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    NullCall : %d.%d ms [%d in %d milliseconds]\n",
            (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // InCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaIN(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    InCall(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));


    //
    // InCall w/Binding Object UUID
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }
    GenerateUuidValue(8179, &ObjectUuid);
    Status = RpcBindingSetObject(Binding, &ObjectUuid);
    if (Status)
        {
        ApiError("Graham", "RpcBindingSetObject", Status);
        PrintToConsole("Graham : FAIL - Unable to Set Object\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaIN(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("  InCall/WUUID(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // OUTCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaOUT(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    OutCall(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // InOutCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaINOUT(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    InOutCall(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    IsabelleShutdown(Binding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("James : PASS\n");
}


int
IsaacStressTest (
    IN unsigned int Iteration,
    IN unsigned int InitialSize,
    IN unsigned int MaximumSize,
    IN unsigned int Increment
    )
/*++

Routine Description:

    This routine performs one iteration of the stress test.  We bind with
    the server, perform one or more remote procedure calls, and then
    unbind.

Arguments:

    Iteration - Supplies an indication of which iteration of the test is
        being performed.  We will use that information to print out the
        buffer sizes the first time.

    InitialSize - Supplies the initial buffer size to use.

    MaximumSize - Supplies the maximum buffer size to use; when this size
        is reach, the test will return.

    Increment - Supplies the amount to increment the buffer size each
        time.

Return Value:

    Zero will be returned if the test completes successfully; otherwise,
    non-zero will be returned.

--*/
{
    RPC_BINDING_HANDLE Binding;

    Status = GetBinding(IVAN, &Binding);
    if (Status)
        {
        ApiError("Isaac","GetBinding",Status);
        PrintToConsole("Isaac : FAIL - Unable to Bind (Ivan)\n");
        return(1);
        }

    for (; InitialSize < MaximumSize; InitialSize += Increment)
        {
        if (Iteration == 0)
            {
            PrintToConsole("%d ",InitialSize);
            }
        Helga(Binding);
        HelgaIN(Binding, InitialSize);
        HelgaOUT(Binding, InitialSize);
        HelgaINOUT(Binding, InitialSize);
        }

    if (Iteration == 0)
        {
        PrintToConsole("\n");
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Isaac : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Isaac","RpcBindingFree",Status);
        PrintToConsole("Isaac : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return(1);
        }

    return(0);
}

unsigned int IsaacIterations = 100;
unsigned int IsaacInitialSize = 128;
unsigned int IsaacMaximumSize = 4096;
unsigned int IsaacIncrement = 512;


void
Isaac (
    )
/*++

Routine Description:

    This routine works to Ivan in usvr.exe to stress test the runtime.

--*/
{
    RPC_BINDING_HANDLE Binding;
    unsigned int Count;

    PrintToConsole("Isaac : Stress Test (%d to %d by %d) %d times\n",
            IsaacInitialSize, IsaacMaximumSize, IsaacIncrement,
            IsaacIterations);
    Synchro(IVAN) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    for (Count = 0; Count < IsaacIterations ; Count++)
        {
        if ( IsaacStressTest(Count, IsaacInitialSize, IsaacMaximumSize,
                    IsaacIncrement) != 0 )
            {
            return;
            }
        PrintToConsole(".");
        }
    PrintToConsole("\n");

       // this piece of code was below the loop
    Status = GetBinding(IVAN, &Binding);
    if (Status)
        {
        ApiError("Isaac","GetBinding",Status);
        PrintToConsole("Isaac : FAIL - Unable to Bind (Ivan)\n");
        return;
        }



    IsabelleShutdown(Binding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Isaac : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Isaac","RpcBindingFree",Status);
        PrintToConsole("Isaac : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("Isaac : PASS\n");
}

void
ExtendedError (
    )
{
    RPC_BINDING_HANDLE Binding ;
    RPC_SECURITY_QOS QOS;
    UUID ObjectUuid;

    Status = GetBinding(TYLER, &Binding);
    if (Status)
        {
        ApiError("ExtendedError", "GetBinding", Status);
        PrintToConsole("ExtendedError : FAIL - Unable to Bind (Tyler)\n");
        return;
        }

    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    QOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;

    Status = RpcBindingSetAuthInfoEx(
                          Binding,
                          (RPC_CHAR  *) L"ServerPrincipal",
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("ExtendedError","RpcBindingSetAuthInfoEx",Status);
        return;
        }

    Helga(Binding);
    if (HelgaErrors)
        {
        PrintToConsole("RPC extended error: %d",
                        I_RpcGetExtendedError());
        }
    else
        {
        PrintToConsole("RPC call passed\n");
        }

    RpcBindingFree( &Binding );

    //
    // check propagation of extended-error packets
    //
    Status = GetBinding(TYLER, &Binding);
    if (Status)
        {
        ApiError("Async", "GetBinding", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

    //
    // see usvr.cxx: activates the extended error info in "ThreadProc"
    //
    GenerateUuidValue(UUID_EXTENDED_ERROR, &ObjectUuid);
    Status = RpcBindingSetObject(Binding, &ObjectUuid);
    if (Status)
        {
        ApiError("Async", "BindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

    int i;
    //
    // make a few calls on the helga interface
    // this should cause an alter context
    //
    for (i=0; i<3; i++)
        {
        __try
        {
            int inbuf[1];

            int sizeout = 0;
            int * bufferout;

            //
            // FooSync will force an exception on the server if the in-size is zero.
            //
            FooSync( Binding, sizeof(int), inbuf, &sizeout, &bufferout);
        }
        __except(1)
        {
            Status = GetExceptionCode();
        }

        if (Status != EXTENDED_ERROR_EXCEPTION)
            {
            PrintToConsole("eeinfo: call returned status %d instead of %d\n", Status, EXTENDED_ERROR_EXCEPTION);
            }

        DumpEeInfo(1);
        }
}

void  TestYield(void)
{
    RPC_BINDING_HANDLE Binding ;
    RPC_MESSAGE Caller;

    Synchro(TESTYIELD) ;

    Caller.BufferLength = 0;
    Caller.ProcNum = 5 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation ;
    Caller.RpcFlags = 0;

    Status = GetBinding(TESTYIELD, &Binding);
    if (Status)
        {
        ApiError("TestYield","GetBinding",Status);
        PrintToConsole("TestYield: FAIL - Unable to Bind\n");

        return;
        }

    // new code end
    Caller.Handle = Binding;

    while(UclntGetBuffer(&Caller))
    {
       Caller.Handle = Binding ;
       PauseExecution(1000) ;
    }

    if(UclntSendReceive(&Caller) != 0)
    {
        ApiError("TestYield","GetBinding",Status);
        PrintToConsole("TestYield: FAIL - Unable to Bind\n");

        return;
    }

   Status = I_RpcFreeBuffer(&Caller);
   if (Status)
       ApiError("TestYield","I_RpcFreeBuffer",Status);

   Status = RpcBindingFree(&Binding);
   if (Status)
        {
        ApiError("TestYield","RpcBindingFree",Status);
        PrintToConsole("TestYield: FAIL - Unable to Free Binding");
        return;
        }
}

char *GetNextCard (
    char **Ptr
    )
{
    char *Card = *Ptr ;
    if (*Card == 0)
        {
        return NULL ;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    ASSERT(*Card == '\\') ;
    Card++ ;
    while (*Card != '\\') Card++ ;
    Card++ ;

    return Card ;
}

char *GetNextIPAddress(
    char **Ptr
    )
{
    char *Address = *Ptr ;
    if (*Address == 0)
        {
        return NULL ;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    return Address ;
}

void PrintAddresses(
    char *Card
    )
{
    char szBuf[512] ;
    HKEY hKey;
    RPC_STATUS Status;
    char Buffer[512] ;
    DWORD Size = 512;
    char *address ;
    char *temp1 ;
    DWORD Type;

    // Create the key string
    sprintf(szBuf,
             "System\\CurrentControlSet\\Services\\%s\\Parameters\\Tcpip",
             Card) ;

    Status =
    RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        szBuf,
        0,
        KEY_READ,
        &hKey);

    if (   Status != ERROR_SUCCESS
    && Status != ERROR_FILE_NOT_FOUND )
    {
    ASSERT(0);
    return;
    }

    // Get DHCP Address
    if (Status == ERROR_SUCCESS)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "DhcpIPAddress",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        }

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return ;
        }

    PrintToConsole("\tDHCP: %s\n", Buffer) ;
    Status =
    RegQueryValueExA(
        hKey,
        "IPAddress",
        0,
        &Type,
        (unsigned char *) Buffer,
        &Size);

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return ;
        }

    int i ;
    for (i =0, temp1 = Buffer; address = GetNextIPAddress(&temp1); i++)
        {
        PrintToConsole("\tStatic IP Address [%d]: %s\n", i, address) ;
        }
}

void RegLookup()
{
    char *temp ;
    char *Card ;
    char Buffer[512] ;
    RPC_STATUS Status;
    HKEY hKey;
    DWORD Size = 512;
    DWORD Type;

    PrintToConsole("RegLookup\n") ;
    NumberOfTestsRun++ ;

    Status =
    RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Services\\Rpc\\Linkage",
        0,
        KEY_READ,
        &hKey);

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return;
        }

    if (Status == ERROR_SUCCESS)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "Bind",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        }

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return ;
        }

    char *temp1;
    char *address;

    PrintToConsole("Cards:") ;
    for (temp = Buffer; Card = GetNextCard(&temp);)
        {
        PrintToConsole("%s:\n", Card) ;
        PrintAddresses(Card) ;
        }
}

void
Except()
{
    int i ;

    for  (i =0; i <100; i++)
        {
        RpcTryExcept
        {
        RpcRaiseException(10) ;
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("exception raised!") ;
        }
        RpcEndExcept
        }
}

char *osf_ptype[]  =
{
    "rpc_request",
    "bad packet",
    "rpc_response",
    "rpc_fault",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "rpc_bind",
    "rpc_bind_ack",
    "rpc_bind_nak",
    "rpc_alter_context",
    "rpc_alter_context_resp",
    "rpc_auth_3",
    "rpc_shutdown",
    "rpc_cancel",
    "rpc_orphaned"
};

void
PrintUuid(UUID *Uuid)
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;
    if (   (Vector[0] == 0)
         && (Vector[1] == 0)
         && (Vector[2] == 0)
         && (Vector[3] == 0))
    {
        PrintToConsole("(Null Uuid)");
    }
    else
    {
        PrintToConsole("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                       Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1],
                       Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5],
                       Uuid->Data4[6], Uuid->Data4[7] );
    }
    return;
}

void do_copacket (
    rpcconn_common *Packet
    )
{
    sec_trailer *SecurityTrailer;

    //
    // Dump the common header first
    //
    PrintToConsole("\n");
    PrintToConsole ("rpc_vers\t\t- 0x%x\n", Packet->rpc_vers);
    PrintToConsole ("rpc_vers_minor\t\t- 0x%x\n", Packet->rpc_vers_minor);
    PrintToConsole ("PTYPE\t\t\t- 0x%x, %s\n",
             Packet->PTYPE, osf_ptype[Packet->PTYPE]);
    PrintToConsole ("pfc_flags\t\t- 0x%x\n", Packet->pfc_flags);
    PrintToConsole ("drep\t\t\t- 0x%x\n", (DWORD) *((DWORD *) &(Packet->drep)));
    PrintToConsole ("frag_length\t\t- 0x%x\n", Packet->frag_length);
    PrintToConsole ("auth_length\t\t- 0x%x\n", Packet->auth_length);
    PrintToConsole ("call_id\t\t\t- 0x%x\n", Packet->call_id);


    //
    //
    // Dump the packet specific stuff
    //
    switch (Packet->PTYPE)
        {
        case rpc_request:
            PrintToConsole ("alloc_hint\t\t- 0x%x\n", ((rpcconn_request *) Packet)->alloc_hint);
            PrintToConsole ("p_cont_id\t\t- 0x%x\n", ((rpcconn_request *) Packet)->p_cont_id);
            PrintToConsole ("opnum\t\t\t- 0x%x\n", ((rpcconn_request *) Packet)->opnum);
            if (Packet->pfc_flags & PFC_OBJECT_UUID)
                {
                PrintToConsole("UUID\t\t -\n");
                PrintUuid((UUID *) (((char *)Packet)+sizeof(rpcconn_common)));
                PrintToConsole("\n");
                PrintToConsole ("Stub Data\t\t- 0x%p\n",
                         (char *) Packet+sizeof(rpcconn_request)+sizeof(UUID));
                }
            else
                {
                PrintToConsole ("Stub Data\t\t- 0x%p\n", (char *) Packet+sizeof(rpcconn_request));
                }
            break;

        case rpc_response:
            PrintToConsole ("alloc_hint\t\t- 0x%x\n", ((rpcconn_response *) Packet)->alloc_hint);
            PrintToConsole ("p_cont_id\t\t- 0x%x\n", ((rpcconn_response *) Packet)->p_cont_id);
            PrintToConsole ("alert_count\t\t- 0x%x\n", ((rpcconn_response *) Packet)->alert_count);
            PrintToConsole ("reserved\t\t- 0x%x\n", ((rpcconn_response *) Packet)->reserved);
            PrintToConsole ("Stub Data\t\t- 0x%p\n", (char *) Packet+sizeof(rpcconn_response));
            break;

        case rpc_fault:
            PrintToConsole ("alloc_hint\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->alloc_hint);
            PrintToConsole ("p_cont_id\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->p_cont_id);
            PrintToConsole ("alert_count\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->alert_count);
            PrintToConsole ("reserved\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->reserved);
            PrintToConsole ("status\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->status);
            PrintToConsole ("reserved2\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->reserved2);
            break;

        case rpc_bind:
        case rpc_alter_context:
            PrintToConsole ("max_xmit_frag\t\t- 0x%x\n", ((rpcconn_bind *) Packet)->max_xmit_frag);
            PrintToConsole ("max_recv_frag\t\t- 0x%x\n", ((rpcconn_bind *) Packet)->max_recv_frag);
            PrintToConsole ("assoc_group_id\t\t- 0x%x\n", ((rpcconn_bind *) Packet)->assoc_group_id);
            break;

        case rpc_bind_ack:
            PrintToConsole ("max_xmit_frag\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->max_xmit_frag);
            PrintToConsole ("max_recv_frag\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->max_recv_frag);
            PrintToConsole ("assoc_group_id\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->assoc_group_id);
            PrintToConsole ("sec_addr_length\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->sec_addr_length);
            break;

        case rpc_bind_nak:
            PrintToConsole ("provider_reject_reason\t\t- 0x%x\n", ((rpcconn_bind_nak *) Packet)->provider_reject_reason);
            PrintToConsole ("versions\t\t- 0x%x\n", ((rpcconn_bind_nak *) Packet)->versions);
            break;

        case rpc_alter_context_resp:
            PrintToConsole ("max_xmit_frag\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->max_xmit_frag);
            PrintToConsole ("max_recv_frag\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->max_recv_frag);
            PrintToConsole ("assoc_group_id\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->assoc_group_id);
            PrintToConsole ("sec_addr_length\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->sec_addr_length);
            PrintToConsole ("pad\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->pad);
            break;

        case rpc_auth_3:
        case rpc_shutdown:
        case rpc_cancel:
        case rpc_orphaned:
            break;

        default:
            PrintToConsole ("Bad Packet\n");
            break;
        }

    //
    // Dump the security trailer
    //
    if (Packet->auth_length)
        {
        SecurityTrailer = (sec_trailer *) ((char *) Packet+Packet->frag_length
            -Packet->auth_length - sizeof(sec_trailer));
        PrintToConsole("Security trailer: 0x%p\n", SecurityTrailer);
        PrintToConsole ("auth_type\t\t- 0x%x\n", SecurityTrailer->auth_type);
        PrintToConsole ("auth_level\t\t- 0x%x\n", SecurityTrailer->auth_level);
        PrintToConsole ("auth_pad_length\t\t- 0x%x\n", SecurityTrailer->auth_pad_length);
        PrintToConsole ("auth_reserved\t\t- 0x%x\n", SecurityTrailer->auth_reserved);
        PrintToConsole ("auth_context_id\t\t- 0x%x\n", SecurityTrailer->auth_context_id);
        PrintToConsole ("trailer\t\t-0x%p\n", SecurityTrailer+1);
        }
}

void
RpcPduFilter (
    IN void *Buffer,
    IN unsigned int BufferLength,
    IN BOOL fDatagram
    )
{
    if (fDatagram == 0)
        {
        do_copacket((rpcconn_common *) Buffer);
        }
    else
        {
        PrintToConsole("UCNT: Datagram PDU\n");
        }
}

void
SetPDUFilter (
    )
{
    HMODULE hLibrary;
    RPC_SETFILTER_FUNC pSetFilterFunc;

    hLibrary = LoadLibraryA("rpcrt4.dll");
    if (hLibrary == 0)
        {
        PrintToConsole("UCLNT: Cannot set PDU filter\n");
        return;
        }

    pSetFilterFunc = (RPC_SETFILTER_FUNC) GetProcAddress(
                            hLibrary, "I_RpcltDebugSetPDUFilter");
    if (pSetFilterFunc == 0)
        {
        PrintToConsole("UCLNT: Cannot set PDU filter\n");
        return;
        }

    (*pSetFilterFunc) (RpcPduFilter);
}

extern void
Async (
    int testnum
    ) ;

extern void
SendAck (
    int testnum
    ) ;

extern void
AsyncAll (
        void
        ) ;


int __cdecl
main (
    int argc,
    char * argv[]
    )

/*
Transports:

    Update this to add a new transport.
*/

{
    int argscan;
    RPC_STATUS RpcStatus = RPC_S_OK;
    char *option ;
    int testnum = 0;
    DWORD dwTickCount;

    dwTickCount = GetTickCount();

    InitializeCriticalSection(&TestMutex);

    // Normally, this routine will be called by the DLL initialization
    // routine.  However, we are linking in our own copy of the threads
    // package, so we need to call this to initialize it.

    RpcMgmtSetCancelTimeout(20) ;

    ASSERT( RpcStatus == RPC_S_OK );

    PrintToConsole("RPC Runtime Client Build Verification Test\n");

    TransportType = RPC_TRANSPORT_NAMEPIPE;

    for (argscan = 1; argscan < argc; argscan++)
        {

        if (strcmp(argv[argscan], "-p") == 0)
        {
            ulSecurityPackage = (unsigned long) atol(argv[argscan+1]);
            argscan++;
        }
        else if (strcmp(argv[argscan],"-princ") == 0)
            {
            gPrincName = argv[argscan + 1];
            argscan ++;
            }
        else if (strcmp(argv[argscan],"-warn") == 0)
            {
            WarnFlag = 1;
            }
        else if (strcmp(argv[argscan],"-noncausal") == 0)
            {
            fNonCausal = 1;
            }
        else if (strcmp(argv[argscan],"-unique") == 0)
            {
            fUniqueBinding = 1;
            }
        else if (strcmp(argv[argscan],"-v") == 0)
            {
            Verbose = 1;
            }
        else if (strcmp(argv[argscan],"-verbose") == 0)
            {
            Verbose = 1;
            }
        else if (strcmp(argv[argscan],"-error") == 0)
            {
            ErrorFlag = 1;
            }
        else if (strcmp(argv[argscan],"-rpcss") == 0)
            {
            UseEndpointMapperFlag = 1;
            }
        else if (strcmp(argv[argscan],"-nosecuritytests") == 0)
            {
            NoSecurityTests = 1;
            }
        else if (strcmp(argv[argscan],"-nocallbacks") == 0)
            {
            NoCallBacksFlag = 1;
            }
        else if (strcmp(argv[argscan],"-small") == 0)
            {
            HelgaMaxSize = 1024;
            }
        else if (strcmp(argv[argscan],"-medium") == 0)
            {
            HelgaMaxSize = 8*1024;
            }
        else if (strcmp(argv[argscan],"-exceptfail") == 0)
            {
            RpcRaiseException(437);
            }
        else if (strcmp(argv[argscan],"-idempotent") == 0)
            {
            HackForOldStubs = RPC_FLAGS_VALID_BIT;
            }
        else if (strcmp(argv[argscan],"-theodore") == 0)
            {
            Theodore();
            }
        else if (strcmp(argv[argscan],"-sebastian") == 0)
            {
            Sebastian();
            }
        else if (strcmp(argv[argscan],"-hybrid") == 0)
            {
            Hybrid();
            }
        else if (strcmp(argv[argscan],"-lpcsecurity") == 0)
            {
            LpcSecurity();
            }
        else if (strcmp(argv[argscan],"-objuuid") == 0)
            {
            TestObjectUuids();
            }
        else if (strcmp(argv[argscan],"-connid") == 0)
            {
            TestConnId();
            }
        else if (strcmp(argv[argscan],"-graham") == 0)
            {
            Graham();
            }
        else if (strcmp(argv[argscan],"-edward") == 0)
            {
            Edward();
            }
        else if (strcmp(argv[argscan],"-astro") == 0)
            {
            Astro();
            }
        else if (strcmp(argv[argscan],"-fitzgerald") == 0)
            {
            Fitzgerald();
            }
        else if (strcmp(argv[argscan],"-charles") == 0)
            {
            Charles();
            }
        else if (strcmp(argv[argscan],"-daniel") == 0)
            {
            Daniel();
            }
        else if (strcmp(argv[argscan],"-thomas") == 0)
            {
            Thomas();
            }
        else if (strcmp(argv[argscan],"-tim") == 0)
            {
            Tim();
            }
        else if (strcmp(argv[argscan],"-robert") == 0)
            {
            Robert();
            }
        else if (strcmp(argv[argscan],"-benjamin") == 0)
            {
            Benjamin();
            }
        else if (strcmp(argv[argscan],"-harold") == 0)
            {
            Harold();
            }
        else if (strcmp(argv[argscan],"-isaac") == 0)
            {
            Isaac();
            }
        else if (strcmp(argv[argscan],"-james") == 0)
            {
            James();
            }
        else if (strcmp(argv[argscan],"-keith") == 0)
            {
            Keith();
            }
        else if (strcmp(argv[argscan],"-exerror") == 0)
            {
            ExtendedError();
            }
        else if (strcmp(argv[argscan],"-eeinfo") == 0)
            {
            ExtendedErrorInfo();
            }
        else if (strcmp(argv[argscan],"-async") == 0)
            {
            Async(testnum);
            }
        else if (strcmp(argv[argscan],"-mutextest") == 0)
            {
            PerformMultiThreadAstroTest(AstroDontBind, AstroMutex, 0);
            }
        else if (strcmp(argv[argscan],"-asynctest") == 0)
            {
            argscan++ ;
            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }
            }
        else if (strcmp(argv[argscan],"-sendack") == 0)
            {
            argscan++ ;

            if (argscan == argc)
                {
                PrintToConsole("-sendack: you must specify a test #, or zero for all, or '?' for help\n");
                return 1;
                }

            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }

            SendAck( testnum );
            }
        else if (strcmp(argv[argscan],"-dgtransport") == 0)
            {
            argscan++ ;

            if (argscan == argc)
                {
                PrintToConsole("-dgtransport: you must specify a test #, or zero for all, or '?' for help\n");
                return 1;
                }

            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }

            DgTransport( testnum );
            }
        else if (strcmp(argv[argscan],"-securityerror") == 0)
            {
            PrintToConsole("security provider error tests \n");

            argscan++ ;

            if (argscan == argc)
                {
                PrintToConsole("-securityerror: you must specify a test #, or zero for all, or '?' for help\n");
                return 1;
                }

            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }
            SecurityErrorWrapper(testnum);
            }
        else if (strcmp(argv[argscan],"-reg") == 0)
            {
            RegLookup() ;
            }
        else if (strcmp(argv[argscan],"-pipe") == 0)
            {
            Pipe() ;
            }
        else if (strcmp(argv[argscan],"-except") == 0)
            {
            Except();
            }
        else if (strcmp(argv[argscan],"-namepipe") == 0)
            {
            TransportType = RPC_TRANSPORT_NAMEPIPE;
            }
        else if (strcmp(argv[argscan],"-lrpc") == 0)
            {
            TransportType = RPC_LRPC;
            }
        else if (strcmp(argv[argscan],"-tcp") == 0)
            {
            TransportType = RPC_TRANSPORT_TCP;
            }
        else if (strcmp(argv[argscan],"-udp") == 0)
            {
            DatagramTests   = 1;
            NoCallBacksFlag = 1;
            TransportType = RPC_TRANSPORT_UDP;
            }
        else if (strcmp(argv[argscan],"-dnet") == 0)
            {
            TransportType = RPC_TRANSPORT_DNET;
            }
        else if (strcmp(argv[argscan],"-netbios") == 0)
            {
            TestDelay = LONG_TESTDELAY;
            TransportType = RPC_TRANSPORT_NETBIOS;
            }
        else if (strcmp(argv[argscan],"-spx") == 0)
            {
            TransportType = RPC_TRANSPORT_SPX;
            }
        else if (strcmp(argv[argscan], "-dsp") == 0)
            {
            TransportType = RPC_TRANSPORT_DSP ;
            }
        else if (strcmp(argv[argscan], "-autolisten") == 0)
            {
            AutoListenFlag = 1 ;
            }
        else if (strcmp(argv[argscan], "-ifsecurity") == 0)
            {
            IFSecurityFlag = 1 ;
            }
        else if (strcmp(argv[argscan],"-ipx") == 0)
            {
            DatagramTests   = 1;
            NoCallBacksFlag = 1;
            TransportType = RPC_TRANSPORT_IPX;
            }
        else if (strcmp(argv[argscan],"-vns") == 0)
            {
            TransportType = RPC_TRANSPORT_VNS;
            }
        else if (strcmp(argv[argscan],"-msmq") == 0)
            {
            DatagramTests   = 1;
            NoCallBacksFlag = 1;
            TransportType = RPC_TRANSPORT_MSMQ;
            }
        else if (strcmp(argv[argscan],"-pdufilter") == 0)
            {
            SetPDUFilter();
            }
        else if (strcmp(argv[argscan],"-protocol") == 0)
            {
            strcpy(NetBiosProtocol+sizeof("ncacn_nb_")-1, argv[argscan+1]);
            argscan++;
            }

        else if (strncmp(argv[argscan],"-server:",strlen("-server:")) == 0)
            {
            Server = argv[argscan] + strlen("-server:");
            }
        else if (strncmp(argv[argscan],"-su:",
                         strlen("-su:")) == 0)
            {
            SecurityUser = (char *)(argv[argscan] + strlen("-su:"));
            }
        else if (strncmp(argv[argscan],"-sd:",
                         strlen("-sd:")) == 0)
            {
            SecurityDomain = (char *) (argv[argscan] + strlen("-sd:"));
            }
        else if (strncmp(argv[argscan],"-sp:",
                         strlen("-sp:")) == 0)
            {
            SecurityPassword = (char *) (argv[argscan] + strlen("-sp:"));
            }
            else if (strncmp(argv[argscan],"-threads:",strlen("-threads:")) == 0)
            {
            AstroThreads = atoi(argv[argscan] + strlen("-threads:"));
            if (AstroThreads == 0)
                {
                AstroThreads = 1;
                }
            }
        else if (strncmp(argv[argscan],"-iterations:",strlen("-iterations:"))
                    == 0)
            {
            IsaacIterations = atoi(argv[argscan] + strlen("-iterations:"));
            if (IsaacIterations == 0)
                {
                IsaacIterations = 100;
                }
            }
        else if (strncmp(argv[argscan],"-initial:",strlen("-initial:"))
                    == 0)
            {
            IsaacInitialSize = atoi(argv[argscan] + strlen("-initial:"));
            if (IsaacInitialSize < 4)
                {
                IsaacInitialSize = 128;
                }
            }
        else if (strncmp(argv[argscan],"-maximum:",strlen("-maximum:"))
                    == 0)
            {
            IsaacMaximumSize = atoi(argv[argscan] + strlen("-maximum:"));
            if (IsaacMaximumSize < IsaacInitialSize)
                {
                IsaacMaximumSize = 4096;
                }
            }
        else if (strncmp(argv[argscan],"-increment:",strlen("-increment:"))
                    == 0)
            {
            IsaacIncrement = atoi(argv[argscan] + strlen("-increment:"));
            if (IsaacIncrement == 0)
                {
                IsaacIncrement = 512;
                }
            }
        else if (strncmp(argv[argscan],"-size:",strlen("-size:"))
                    == 0)
            {
            JamesSize = atoi(argv[argscan] + strlen("-size:"));
            if (JamesSize <4)
                {
                JamesSize = 4;
                }
            }
        else if (strncmp(argv[argscan],"-count:",strlen("-count:"))
                    == 0)
            {
            JamesCount = atoi(argv[argscan] + strlen("-count:"));
            if (JamesCount == 0)
                {
                JamesCount = 100;
                }
            }

        else if (   (strcmp(argv[argscan],"-usage") == 0)
                 || (strcmp(argv[argscan],"-?") == 0))
            {
            PrintToConsole("Usage : uclnt\n");
            PrintToConsole("        -warn : turn on warning messages\n");
            PrintToConsole("        -error : turn on error messages\n");
            PrintToConsole("        -nocallbacks\n");
            PrintToConsole("        -nosecuritytests\n");
            PrintToConsole("        -theodore\n");
            PrintToConsole("        -exceptfail\n");
            PrintToConsole("        -sebastian\n");
            PrintToConsole("        -graham\n");
            PrintToConsole("        -edward\n");
            PrintToConsole("        -astro\n");
            PrintToConsole("        -fitzgerald\n");
            PrintToConsole("        -charles\n");
            PrintToConsole("        -daniel\n");
            PrintToConsole("        -thomas\n");
            PrintToConsole("        -tim\n");
            PrintToConsole("        -robert\n");
            PrintToConsole("        -benjamin\n");
            PrintToConsole("        -harold\n");
            PrintToConsole("        -isaac\n");
            PrintToConsole("        -james\n");
            PrintToConsole("        -keith\n");
            PrintToConsole("        -hybrid\n");
            PrintToConsole("        -connid\n");
            PrintToConsole("        -pipe\n") ;
            PrintToConsole("        -namepipe\n");
            PrintToConsole("        -lrpc\n");
            PrintToConsole("        -tcp\n");
            PrintToConsole("        -udp [-idempotent -maybe -broadcast]\n");
            PrintToConsole("        -dnet\n");
            PrintToConsole("        -netbios\n");
            PrintToConsole("        -server:<server>\n");
            PrintToConsole("        -spx\n");
            PrintToConsole("        -ipx\n");
            PrintToConsole("        -dsp\n") ;
            PrintToConsole("        -msmq\n") ;
            PrintToConsole("        -threads:<astro threads>\n");
            PrintToConsole("        -iterations:<isaac iterations>\n");
            PrintToConsole("        -initial:<isaac initial size>\n");
            PrintToConsole("        -maximum:<isaac maximum size>\n");
            PrintToConsole("        -increment:<isaac increment>\n");
            PrintToConsole("        -size:<james size>\n");
            PrintToConsole("        -count:<james count>\n");
            PrintToConsole("        -rpcss\n");
            PrintToConsole("        -p <security provider #>\n");
            PrintToConsole("        -su:<tim user>\n");
            PrintToConsole("        -sd:<tim domain>\n");
            PrintToConsole("        -sp:<tim password>\n");
            PrintToConsole("        -unique             (enables RPC_C_OPT_UNIQUE_BINDING)\n");
            PrintToConsole("        -noncausal          (enables RPC_C_OPT_BINDING_NONCAUSAL)\n");
            return(1);
            }
        else if (argv[argscan][0] == '-')
            {
            PrintToConsole("unknown option '%s'\n", argv[argscan]);
            return 1;
            }
        else
            Server = argv[argscan];
        }

    if ( NumberOfTestsRun == 0 )
        {
        Theodore();
        Sebastian();
        Graham();
        Edward();
        Astro();
        Fitzgerald();
        Charles();
        Daniel();
        if ( NoSecurityTests == 0)
            {
            Thomas();
            }
        if ( TransportType != RPC_LRPC )
            {
            Robert();
            }
        Keith();
        Benjamin();
        Async(0);
        }

    return(0); // To keep the compiler happy.
}


//
// BVT for Async RPC
//

//
// Client side code
//

//
// the following routines outline the client side code for a simple async
// function
//

#define TRACE(_x) { \
    if (Verbose) \
        {\
        PrintToConsole _x;\
        }\
    }

int OutstandingCalls ;
int FooProcnum = 16 ;
int FooPipeProcnum = 17 ;
void * FooInterface = &IsabelleInterfaceInformation;

#if 0
//
// Begin, Approximate idl file
//
interface FooInterface {
    int Foo (handle_t hBinding, [in] int sizein, [in] int *bufferin,
                [in, out] int *sizeout, [out] int **bufferout) ;
    }
// End, idl file

//
// Begin, Corresponding ACF file
//
interface FooInterface {
    [async] Foo () ;
    }
// End, acf file

//
// look at asyncstub.h for the generated header
// file for function Foo
//
#endif

////////////////////////////////////////////////////////////
// Begin, stubs for Foo                                                      //
////////////////////////////////////////////////////////////

HANDLE SyncEvent ;
typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    void *state ;
    int *sizeout ;
    int **bufferout ;
    } FOO_ASYNC_CLIENT_STATE;


RPC_STATUS
FooComplete(
    IN PRPC_ASYNC_STATE pAsync,
    OUT void *Reply
    )
/*++

Routine Description:

    The completion routine corresponding to the function Foo. This routine
    is called to get the out parameters from an async function.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    RPC_STATUS Status ;
    RPC_MESSAGE Message ;
    int *ptr ;
    FOO_ASYNC_CLIENT_STATE *StubInfo =
               (FOO_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;

    Message.RpcInterfaceInformation = FooInterface ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength ;
    Status = I_RpcReceive(&Message, 0) ;
    if (Status)
        {
        return Status ;
        }

    ptr = (int *) Message.Buffer ;

    *((int *) Reply) = *ptr++ ;
    *(StubInfo->sizeout) = *ptr++ ;

    *(StubInfo->bufferout) = (int *) I_RpcAllocate(*(StubInfo->sizeout)) ;
    if (*(StubInfo->bufferout) == 0)
        {
        return RPC_S_OUT_OF_MEMORY ;
        }

    RpcpMemoryCopy(*(StubInfo->bufferout), ptr, *(StubInfo->sizeout)) ;

    I_RpcFreeBuffer(&Message) ;
    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}


void
Foo (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    )
/*++

Routine Description:

    Client stub for function Foo.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOO_ASYNC_CLIENT_STATE *StubInfo ;
    int *Ptr ;

    StubInfo = (FOO_ASYNC_CLIENT_STATE *) I_RpcAllocate (
                        sizeof(FOO_ASYNC_CLIENT_STATE)) ;
    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->StubInfo = (void *) StubInfo ;

    StubInfo->StubState.CallHandle = hBinding ;

    Message.Handle = hBinding ;
    Message.BufferLength = 8+sizein+(sizein%4) ;
    Message.ProcNum = FooProcnum | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = FooInterface ;
    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // marshal ;-)
    Ptr = (int *) Message.Buffer ;
    *Ptr++ = sizein ;

    RpcpMemoryCopy(Ptr, bufferin, sizein) ;

    Ptr += (sizein+3)/sizeof(int) ;

    *Ptr = *sizeout ;

    StubInfo->StubState.Flags = 0;
    StubInfo->sizeout = sizeout ;
    StubInfo->bufferout = bufferout ;

    RpcStatus = I_RpcAsyncSetHandle(&Message, (PRPC_ASYNC_STATE) pAsync) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CompletionRoutine = FooComplete ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CallHandle = Message.Handle ;
    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;
    // return to the app
}



int
FooSync (
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    )
/*++

Routine Description:

    Client stub for function Foo.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    int *Ptr ;
    int retval ;

    Message.Handle = hBinding ;
    Message.BufferLength = 8+sizein+(sizein%4) ;
    Message.ProcNum = FooProcnum | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = 0;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    Ptr = (int *) Message.Buffer ;
    *Ptr++ = sizein ;

    RpcpMemoryCopy(Ptr, bufferin, sizein) ;

    Ptr += (sizein+3)/sizeof(int) ;

    *Ptr = *sizeout ;

    Message.RpcFlags = 0;

    RpcStatus = I_RpcSendReceive(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    *bufferout = (int *) I_RpcAllocate(*sizeout) ;
    if (*bufferout == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    Ptr = (int *) Message.Buffer ;
    retval = *Ptr++ ;
    *sizeout = *Ptr++;

    RpcpMemoryCopy(*bufferout, Ptr, *sizeout) ;

    I_RpcFreeBuffer(&Message) ;

    return retval ;
}

////////////////////////////////////////////////////////////
// End, stubs for Foo                                                        //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STATE Async ;
    int SizeOut ;
    int *BufferOut ;
    BOOL CallFinished ;
    } CALL_COOKIE ;


void
ThreadProc(
    IN CALL_COOKIE *Cookie
    )
/*++

Routine Description:

    completion routine is called in another thread. To prove that it can be.

Arguments:

     pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    int retval ;

    TRACE(("Foo: waiting for aync reply\n")) ;

    RpcTryExcept
        {
        WaitForSingleObject(Cookie->Async.u.hEvent, INFINITE) ;

        Status = MyRpcCompleteAsyncCall(&Cookie->Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie->BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    SetEvent(SyncEvent) ;
}

void
WaitForReply (
    IN BOOL *pfCallFinished
    )
{
    do
        {
        if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
            {
            RpcRaiseException(APP_ERROR);
            }
        } while (*pfCallFinished == 0);
}

void
FooAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    CALL_COOKIE *Cookie = (CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcCallComplete:
            Cookie->CallFinished = 1;
            OutstandingCalls--;
            break;
        }
}



void
CallFoo (
    RPC_BINDING_HANDLE Binding,
    CALL_COOKIE *Cookie,
    RPC_NOTIFICATION_TYPES NotificationType,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int *BufferIn ;

    BufferIn = (int *) new char[SizeIn] ;
    if (BufferIn == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    Cookie->SizeOut = SizeOut ;
    Cookie->Async.Size = sizeof(RPC_ASYNC_STATE) ;
    Cookie->Async.Flags = 0;
    Cookie->Async.Lock = 0;
    Cookie->Async.NotificationType = NotificationType ;

    switch (NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeEvent:
            Cookie->Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
            if (Cookie->Async.u.hEvent == 0)
                {
                RpcRaiseException(APP_ERROR) ;
                }

            Cookie->Async.NotificationType = RpcNotificationTypeEvent ;
            break;

        case RpcNotificationTypeApc:
            Cookie->Async.NotificationType = RpcNotificationTypeApc ;
            Cookie->Async.u.APC.NotificationRoutine = FooAPCRoutine ;
            Cookie->Async.u.APC.hThread = 0;
            Cookie->CallFinished = 0;
            break;

        default:
            PrintToConsole("Async: bad notification type\n") ;
            break;
        }

    Cookie->Async.UserInfo = (void *) Cookie ;

    // call the async function
    // the buffers supplied for the [out] and the [in, out] params
    // should be valid until the logical RPC call has completed.
    Foo(&Cookie->Async,
          Binding,
          SizeIn,
          BufferIn,
          &Cookie->SizeOut,
          &Cookie->BufferOut) ;

    delete BufferIn ;
}


void
AsyncUsingEvent(
    IN RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    int userstate = 10;
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    CALL_COOKIE *Cookie = 0;


    RpcTryExcept
        {
        Cookie =new CALL_COOKIE ;

        if (Cookie == 0)
            {
            RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
            }

        CallFoo (Binding, Cookie, RpcNotificationTypeEvent, SizeIn, SizeOut) ;

        HandleToThread = CreateThread(
                                    0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) ThreadProc,
                                    Cookie,
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            PrintToConsole("Foo: Error, couldn't create thread\n") ;
            RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
            }

        // wait for the other guy to finish
        TRACE(("Foo: Waiting...\n")) ;
        WaitForSingleObject(SyncEvent, INFINITE) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    if (Cookie && Cookie->Async.u.hEvent)
        {
        CloseHandle(Cookie->Async.u.hEvent) ;
        }
}


void
AsyncUsingAPC(
    RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    CALL_COOKIE Cookie ;
    int retval ;


    RpcTryExcept
        {
        CallFoo(Binding, &Cookie, RpcNotificationTypeApc, SizeIn, SizeOut) ;

        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie.BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}


void
AsyncUsingPolling(
    RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    CALL_COOKIE Cookie ;
    int retval ;


    RpcTryExcept
        {
        CallFoo(Binding, &Cookie, RpcNotificationTypeNone, SizeIn, SizeOut) ;

        while ((Status = RpcAsyncGetCallStatus(&Cookie.Async))
                    == RPC_S_ASYNC_CALL_PENDING)
            {
            Sleep(1) ;
            }

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie.BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}

///////////////////////////////////////////////////////////
// End, Application                                                         //
//////////////////////////////////////////////////////////

//
// The following routines outline the client side code for a simple async function
// using pipes.
//

#if 0
//
// Begin, Approximate idl file
//
interface FooInterface {
    typedef pipe int aysnc_intpipe ;

    int FooPipe (handle_t hBinding, [in] int checksum_in, [in] async_intpipe *inpipe,
                      [out] async_intpipe *outpipe, [out] int *checksum_out) ;
    } ;
// End, idl file

//
// Begin, corresponding acf file
//
interface FooInterface {
    [async] Foo () ;
    } ;
//
// End, acf file
//

//
// look at asyncstub.h for generated header
// file for function FooPipe
//
#endif

////////////////////////////////////////////////////////////
// Begin, stubs for FooPipe                                                //
////////////////////////////////////////////////////////////

// declare the async handle
typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    void *state ;
    async_intpipe outpipe ;
    int *checksum_out;
    } FOOPIPE_ASYNC_CLIENT_STATE, *FOOPIPE_ASYNC_CLIENT_HANDLE ;


#define ASYNC_CHUNK_SIZE 1000
#define ASYNC_NUM_CHUNKS 20


RPC_STATUS
PipeReceiveFunction (
    IN PRPC_ASYNC_STATE pAsync,
    IN int *buffer,
    IN int requested_count,
    IN int *actual_count
    )
/*++
Function Name:PipeReceiveFunction

Parameters:

Description:

Returns:

--*/
{
    int num_elements = 0;
    RPC_MESSAGE Callee ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo =
        (FOOPIPE_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;
    PIPE_STATE *state = &(StubInfo->StubState.PipeState);
    DWORD size = (DWORD) requested_count * state->PipeElementSize ;

    *actual_count = 0 ;

    if (state->EndOfPipe)
        {
        return RPC_S_OK;
        }

    I_RpcReadPipeElementsFromBuffer(
                                    state,
                                    (char *) buffer,
                                    size,
                                    &num_elements) ;
    *actual_count += num_elements ;
    size -= num_elements * state->PipeElementSize ;

    if (state->EndOfPipe == 0 &&
        num_elements < requested_count)
        {
        Callee.ProcNum = RPC_FLAGS_VALID_BIT ;
        Callee.Handle = StubInfo->StubState.CallHandle ;

        Callee.RpcFlags = RPC_BUFFER_PARTIAL | RPC_BUFFER_ASYNC ;
        if (num_elements)
            {
            Callee.RpcFlags |= RPC_BUFFER_NONOTIFY;
            }

        Callee.Buffer = 0 ;
        Callee.BufferLength = 0 ;

        Status = I_RpcReceive(&Callee, size) ;
        if (Status)
            {
            if (num_elements && Status == RPC_S_ASYNC_CALL_PENDING)
                {
                num_elements = 0 ;
                return RPC_S_OK;
                }

            if (Status != RPC_S_ASYNC_CALL_PENDING)
                {
                ApiError("PipePull", "I_RpcReceive", Status) ;
                }

            num_elements = 0 ;
            return Status;
            }

        state->Buffer = Callee.Buffer ;
        state->BufferLength = Callee.BufferLength ;
        state->CurPointer = (char *) Callee.Buffer ;
        state->BytesRemaining = Callee.BufferLength ;

        buffer = (pipe_element_t *)
                    ((char *) buffer + num_elements * state->PipeElementSize) ;

        num_elements = 0 ;
        I_RpcReadPipeElementsFromBuffer(
                                        state,
                                        (char *) buffer,
                                        size,
                                        &num_elements) ;
        *actual_count += num_elements ;
        }

    return RPC_S_OK;
}


RPC_STATUS
PipeSendFunction (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *context,
    IN int *buffer,
    IN int num_elements
    )
/*++

Routine Description:

 this function is always implemented by the stubs. This routine is called by
 the application, to send pipe data.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    unsigned int Flags = 0;
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo =
        (FOOPIPE_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;
    int calculated_length = num_elements * sizeof(int) + sizeof(int);
    char *ptr ;

    Message.ProcNum = FooPipeProcnum | HackForOldStubs;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        calculated_length += StubInfo->StubState.BufferLength ;
        }

    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcReallocPipeBuffer (&Message, calculated_length) ;
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    ptr = (char *) Message.Buffer ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        ptr += StubInfo->StubState.BufferLength ;
        }

    *((int *) ptr) = num_elements ;
    RpcpMemoryCopy(ptr+sizeof(int), buffer, num_elements *sizeof(int)) ;

    if (num_elements) // || !lastpipe
        {
        Message.RpcFlags = RPC_BUFFER_PARTIAL ;
        }
    else
        {
        // we are making a simplifying assumption
        // that there is a single [in] pipe.
        Message.RpcFlags = 0;
        }

    Message.RpcFlags |= RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus == RPC_S_OK)
        {
        StubInfo->StubState.State = SEND_COMPLETE ;
        }
    else if (RpcStatus == RPC_S_SEND_INCOMPLETE)
        {
        StubInfo->StubState.State = SEND_INCOMPLETE ;
        }
    else
        {
        return RpcStatus;
        }

    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;

    return RPC_S_OK;
}


RPC_STATUS
FooPipeComplete(
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:

    Stub for the completion routine of FooPipe

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS Status ;
    RPC_MESSAGE Message ;
    void *ptr ;
    int retval;
    UINT_PTR offset ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo =
        (FOOPIPE_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;

    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.PipeState.Buffer;
    Message.BufferLength = 0;

    if (StubInfo->StubState.PipeState.BytesRemaining < 8)
        {
        Message.RpcFlags = RPC_BUFFER_ASYNC|RPC_BUFFER_EXTRA;
        Status = I_RpcReceive(&Message, 8) ;
        if (Status)
            {
            return Status ;
            }
        // just being paranoid here. I didn't want an overflow.
        offset = StubInfo->StubState.PipeState.CurPointer
                - (char *) StubInfo->StubState.PipeState.Buffer ;
        ptr = (char *) Message.Buffer + offset ;
        }
    else
        {
        ptr = StubInfo->StubState.PipeState.CurPointer ;
        if (!ptr)
            {
            return RPC_S_OUT_OF_MEMORY ;
            }
        }


    *((int *) Reply) =  *((int *) ptr) ;
    *(StubInfo->checksum_out) = *(((int *) ptr)+1) ;

    I_RpcFreeBuffer(&Message) ;
    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}

int tempint ;


void
FooPipe (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int checksum_in,
    /* [in] */ async_intpipe *inpipe,
    /* [out] */ async_intpipe *outpipe,
    /* [out] */ int *checksum_out
    )
/*++

Routine Description:

    The stub routine for FooPipe function.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo ;

    StubInfo = (FOOPIPE_ASYNC_CLIENT_STATE *) I_RpcAllocate (
                        sizeof(FOOPIPE_ASYNC_CLIENT_STATE)) ;
    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->StubInfo = (void *) StubInfo ;

    StubInfo->StubState.CallHandle = hBinding ;

    Message.Handle = hBinding ;
    Message.BufferLength = 4 ;
    Message.ProcNum = FooPipeProcnum | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = RPC_BUFFER_ASYNC | RPC_BUFFER_PARTIAL ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // initialize the async handle and register it with the
    // RPC runtime.

    StubInfo->StubState.PipeState.Buffer = 0;
    StubInfo->StubState.PipeState.CurrentState = start;
    StubInfo->StubState.PipeState.CurPointer = 0;
    StubInfo->StubState.PipeState.BytesRemaining = 0;
    StubInfo->StubState.PipeState.EndOfPipe = 0;
    StubInfo->StubState.PipeState.PipeElementSize = sizeof(int);
    StubInfo->StubState.PipeState.PartialPipeElement = &tempint;
    StubInfo->StubState.PipeState.PreviousBuffer = 0;

    RpcStatus = I_RpcAsyncSetHandle(&Message, pAsync) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    *((int *) Message.Buffer) = checksum_in ;
    inpipe->PipeSend = PipeSendFunction ;
    outpipe->PipeReceive = PipeReceiveFunction;


    StubInfo->StubState.CompletionRoutine = FooPipeComplete ;
    StubInfo->checksum_out = checksum_out ;
    Message.RpcFlags = RPC_BUFFER_PARTIAL| RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus == RPC_S_OK)
        {
        StubInfo->StubState.State = SEND_COMPLETE ;
        }
    else if (RpcStatus == RPC_S_SEND_INCOMPLETE)
        {
        StubInfo->StubState.State = SEND_INCOMPLETE ;
        }
    else
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CallHandle = Message.Handle ;
    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;
}

////////////////////////////////////////////////////////////
// End, stubs for FooPipe                                                   //
////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
// Begin, Application                                                          //
////////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STATE Async ;
    async_intpipe inpipe ;
    async_intpipe outpipe ;
    BOOL CallFinished ;
    BOOL PipeDataSent;
    int checksum_out;
    int PipeChecksum ;
    int PipeBuffer[ASYNC_CHUNK_SIZE] ;
    int ExpectedValue;
    int i ;
    } PIPE_CALL_COOKIE ;


int PipeCount = 0;


void
FooPipeAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description
--*/

{
    PIPE_CALL_COOKIE *Cookie = (PIPE_CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcSendComplete:
            if (Cookie->i % 7)
                {
                Sleep(10);
                }

            if (Cookie->i <ASYNC_NUM_CHUNKS)
                {
                Cookie->i++ ;
                Status = Cookie->inpipe.PipeSend(
                                                 pAsync,
                                                 0,
                                                 (int *) Cookie->PipeBuffer,
                                                 ASYNC_CHUNK_SIZE) ;
                }
            else
                {
                ASSERT(Cookie->PipeDataSent == 0);

                pAsync->Flags = 0;
                Status = Cookie->inpipe.PipeSend(
                                                 pAsync,
                                                 0, 0, 0) ;
                Cookie->PipeDataSent = 1;
                }

            if (Status != RPC_S_OK)
                {
                PrintToConsole("FooPipeAPCRoutine: PipeSend failed\n");
                IsabelleError();
                }
            break;

        case RpcCallComplete:
            Cookie->CallFinished = 1;
            OutstandingCalls-- ;
            break;
        }
}



void
CallFooPipe (
    RPC_BINDING_HANDLE Binding,
    PIPE_CALL_COOKIE *Cookie,
    RPC_NOTIFICATION_TYPES NotificationType
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int Checksum = 0;
    int n ;
    int *ptr ;

    Cookie->Async.Size = sizeof(RPC_ASYNC_STATE) ;
    Cookie->Async.UserInfo = (void *) Cookie ;

    Cookie->outpipe.state = 0;
    Cookie->inpipe.state = 0;

    Cookie->PipeChecksum = 0;
    Cookie->CallFinished = 0;
    Cookie->i = 0;
    Cookie->PipeDataSent = 0;
    Cookie->Async.Flags = 0;
    Cookie->Async.Lock = 0;
    Cookie->ExpectedValue = 0;

    switch (NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeEvent:
            Cookie->Async.NotificationType = RpcNotificationTypeEvent ;

            Cookie->Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;

            if (Cookie->Async.u.hEvent == 0)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            break;

        case RpcNotificationTypeApc:
            Cookie->Async.Flags = RPC_C_NOTIFY_ON_SEND_COMPLETE;
            Cookie->Async.NotificationType = RpcNotificationTypeApc ;
            Cookie->Async.u.APC.NotificationRoutine = FooPipeAPCRoutine ;
            Cookie->Async.u.APC.hThread = 0 ;
            break;

        default:
            PrintToConsole("Async: bad notification type\n") ;
            break;
        }

    ptr =  Cookie->PipeBuffer ;
    for (n = 0; n <ASYNC_CHUNK_SIZE; n++)
        {
        *ptr++ = n;
        Checksum += n ;
        }

    TRACE(("FooPipe: [in] Block checksum: %d\n", Checksum)) ;
    Checksum *= ASYNC_NUM_CHUNKS ;

    TRACE(("FooPipe: [in] Total checksum: %d\n", Checksum)) ;

    FooPipe(&(Cookie->Async),
                Binding,
                Checksum,
                &(Cookie->inpipe),
                &(Cookie->outpipe),
                &(Cookie->checksum_out)) ;
}


void
AsyncPipesUsingAPC(
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    Call the async function.

Arguments:

    Binding - Binding handle.
--*/

{
    RPC_STATUS Status ;
    PIPE_CALL_COOKIE *Cookie;
    int retval ;
    BOOL fDone = 0;
    int num_elements;
    int i;

    RpcTryExcept
        {
        Cookie = new PIPE_CALL_COOKIE ;

        if (Cookie == 0)
            {
            RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
            }

        CallFooPipe (Binding, Cookie, RpcNotificationTypeApc) ;

        while (Cookie->PipeDataSent == 0)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        while (!fDone)
            {
            Status = Cookie->outpipe.PipeReceive(
                                                  &(Cookie->Async),
                                                  (int *) Cookie->PipeBuffer,
                                                  ASYNC_CHUNK_SIZE,
                                                  &num_elements);
            switch (Status)
                {
                case RPC_S_ASYNC_CALL_PENDING:
                    if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                        {
                        RpcRaiseException(APP_ERROR) ;
                        }
                    break;

                case RPC_S_OK:
                    if (num_elements == 0)
                        {
                        fDone = 1;
                        }
                    else
                        {
                        for (i = 0; i <num_elements; i++)
                            {
                            Cookie->PipeChecksum += Cookie->PipeBuffer[i] ;
                            if (Cookie->PipeBuffer[i] != Cookie->ExpectedValue)
                                {
                                printf("pipe recv fn: elt %d contains %lx, expected %lx\n",
                                       i, Cookie->PipeBuffer[i], Cookie->ExpectedValue);
                                DebugBreak();
                                }

                            Cookie->ExpectedValue =
                                (Cookie->PipeBuffer[i]+1) % ASYNC_CHUNK_SIZE;
                            }
                        }
                    break;

                default:
                    fDone = 1;
                    break;
                }

            //
            // This code is for testing flow control
            //
            PipeCount++;
            if (PipeCount % 3)
                {
                Sleep(100);
                }
            }

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        while (Cookie->CallFinished == 0)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        Status = MyRpcCompleteAsyncCall(&Cookie->Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        if (Cookie->PipeChecksum != Cookie->checksum_out)
            {
            PrintToConsole("FooPipe: Checksum Error, expected: %d, checksum: %d\n",
                    Cookie->checksum_out, Cookie->PipeChecksum) ;
            RpcRaiseException(APP_ERROR) ;
            }
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("FooPipe: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    if (Cookie)
        {
        delete Cookie ;
        }
}


void
MultipleOutstandingCalls (
    IN RPC_BINDING_HANDLE Binding,
    IN int NumCalls
    )
/*++

Routine Description:

tests multiple outstanding calls and causal ordering

Arguments:

 Binding - Binding on which to make the calls
 NumCalls - Number of outstanding calls

--*/

{
    RPC_STATUS Status ;
    PIPE_CALL_COOKIE *PipeCookies;
    CALL_COOKIE *Cookies ;
    int retval ;
    int i ;
    int SizeIn, SizeOut ;

    RpcTryExcept
        {
        Cookies = new CALL_COOKIE[NumCalls] ;
        if (Cookies == 0)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        PipeCookies = new PIPE_CALL_COOKIE[NumCalls] ;

        if (PipeCookies == 0)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        OutstandingCalls = 0;

        SizeIn = 10;
        SizeOut = 10 ;

        for (i = 0; i < NumCalls; i++)
            {
            CallFoo(Binding, &Cookies[i], RpcNotificationTypeApc, SizeIn, SizeOut) ;

            SizeIn += 100 ;
            SizeOut+= 100 ;

            OutstandingCalls++ ;

            }

        while (OutstandingCalls)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        for (i = 0; i < NumCalls; i++)
            {
            Status = MyRpcCompleteAsyncCall(&Cookies[i].Async, &retval) ;
            if (Status != RPC_S_OK)
                {
                PrintToConsole("Call %d on handle %p returned %d\n",
                               i, &Cookies[i].Async, Status);
                continue;
                }

            TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

            if (retval != 1)
                {
                RpcRaiseException(APP_ERROR) ;
                }

            I_RpcFree(Cookies[i].BufferOut) ;
            }
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("MultipeOutstandingCalls: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    if (Cookies)
        {
        delete Cookies ;
        }

    if (PipeCookies)
        {
        delete PipeCookies ;
        }
}


void
SyncAsyncInterop (
    IN RPC_BINDING_HANDLE Binding,
    IN int SizeIn,
    IN int SizeOut
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int retval ;
    int *bufferout ;
    int *bufferin ;

    RpcTryExcept
        {
        bufferin = (int *) I_RpcAllocate(SizeIn) ;
        if (bufferin == 0)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        // sync client,  async server
        retval = FooSync (Binding, SizeIn, bufferin, &SizeOut, &bufferout) ;
        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(bufferout) ;

        // ugly hack alert
        FooProcnum = 18 ;

        // async client, sync server (calling FooBar)
        AsyncUsingAPC(Binding, SizeIn, SizeOut) ;

        FooProcnum = 16 ;

        // sync client, async server using pipes

        // async client, sync server using pipes
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("SyncAsyncInterop: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept
}

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    } else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}


DWORD
AddServicePrivToAccount(
    LPWSTR MachineName,
    LPWSTR pAccount
)
/*++

Routine Description:

    Enables the appropriate privileges for the cluster account and
    sets up the cluster service to run in the specified account.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LSA_HANDLE PolicyHandle;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    NTSTATUS Status;

    WCHAR domain[MAX_PATH];

    PSID         pSid;
    SID_NAME_USE sidType;
    DWORD        nBytes;
    DWORD        maxDomain;


    if (MachineName != NULL) {
        InitLsaString(&ServerString, MachineName);
        Server = &ServerString;
    }

    PrintToConsole("Machine: %ls, Account: %ls.\n",MachineName,pAccount);

    nBytes=0;
    maxDomain=MAX_PATH*sizeof(WCHAR);

    if (LookupAccountName(MachineName,pAccount,NULL,&nBytes,
                          domain,&maxDomain,&sidType))
    {
        PrintToConsole("AddServicePrivToAccount: LookupAccountName(NULL) failed.\n");
        return ERROR_INVALID_PARAMETER;
    }

    pSid=LocalAlloc(LPTR,nBytes);
    if (NULL == pSid)
    {
        PrintToConsole("AddServicePrivToAccount: LocalAlloc failed.\n");
        return GetLastError();
    }

    if (!LookupAccountName(MachineName,pAccount,pSid,&nBytes,
                           domain,&maxDomain,&sidType))
    {
        PrintToConsole(
                  "AddServicePrivToAccount: LookupAccountName(%ls) failed.\n",
                  pAccount);
        return GetLastError();
    }

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    //
    // Attempt to open the local policy.
    //
    Status = LsaOpenPolicy(Server,
                           &ObjectAttributes,
                           POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                           &PolicyHandle);
    if (MachineName != NULL) {
        if (!NT_SUCCESS(Status)) {
            //
            // We could not contact the PDC to configure the service account.
            // Put up a nice informative popup and let the user run setup
            // again when the PDC is back.
            //
            PrintToConsole("AddServicePrivToAccount: LsaOpenPolicy failed.\n");
            return(Status);
        }
    } else {
        if (!NT_SUCCESS(Status)) {
            PrintToConsole(
                      "AddServicePrivToAccount: LsaOpenPolicy failed 2.\n");
            return(Status);
        }
    }

    //
    // Add the SeTcbPriviledge
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_TCB_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(tcb).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the SeServiceLogonRight
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_SERVICE_LOGON_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(logon).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the SeBackupPrivilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_BACKUP_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(backup).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the SeRestorePrivilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_RESTORE_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(restore).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the lock memory privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_LOCK_MEMORY_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(memory).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the increase quota privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_INCREASE_QUOTA_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(quota).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the load driver privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_LOAD_DRIVER_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(driver).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the increase base priority privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_INC_BASE_PRIORITY_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(priority)\n");
        goto AddServicePrivToAccount_Bail;
    }


    Status=ERROR_SUCCESS;

AddServicePrivToAccount_Bail:

    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    return(Status);
}


void
AsyncSecurity (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    HANDLE hToken;
    WCHAR FullName[512];

    wsprintf((PWSTR) &FullName[0], L"%hs\\%hs", SecurityDomain, SecurityUser);

    AddServicePrivToAccount(L"", &FullName[0]);

    while (1)
        {
        if (LogonUserA(SecurityUser, SecurityDomain, SecurityPassword,
                   LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &hToken) == 0)
            {
            PrintToConsole("LogonUser failed: %d\n", GetLastError());
            break;
            }

        ImpersonateLoggedOnUser(hToken);
        // set auth info to various levels
        // and impersonate on the server
        Status = RpcBindingSetAuthInfo(Binding, NULL, RPC_C_AUTHN_DEFAULT,
                                       RPC_C_AUTHN_WINNT, NULL, NULL);

        AsyncUsingAPC(Binding, 20, 20);
        CloseHandle(hToken);
        }
}

void
AsyncSecurityThreads()
{
    int i;
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    RPC_BINDING_HANDLE Binding;
    UUID ObjectUuid;
    GenerateUuidValue(UUID_TEST_CANCEL, &ObjectUuid);

    for (i = 0; i<3; i++)
        {
        Status = GetBinding(BARTHOLOMEW, &Binding);
        if (Status)
            {
            ApiError("Async", "GetBinding", Status);
            PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
            return;
            }

        Status = RpcBindingSetObject(Binding, &ObjectUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        HandleToThread = CreateThread(
                                    0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) AsyncSecurity,
                                    Binding,
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            PrintToConsole("AsyncSecurity: Error, couldn't create thread\n") ;
            IsabelleError();
            return;
            }
        CloseHandle(HandleToThread);
        }

    Status = GetBinding(BARTHOLOMEW, &Binding);
    if (Status)
        {
        ApiError("Async", "GetBinding", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

    Status = RpcBindingSetObject(Binding, &ObjectUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to Set Object\n");
        return;
        }

    AsyncSecurity(Binding);
}




void
AsyncExceptions (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    BOOL ExceptionOccured ;
    int ExceptionCode ;
    UUID SavedUuid;
    UUID ExceptionUuid;

    //
    // object UUID is used to control server-side exceptions: save the original one.
    //
    Status = RpcBindingInqObject(Binding, &SavedUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingInqObject", Status);
        PrintToConsole("Async : FAIL - Unable to save original object UUID\n");
        return;
        }

    // test sync exceptions (async server)
    RpcTryExcept
        {
        ExceptionOccured = 0;
        ExceptionCode = 0;

        GenerateUuidValue(UUID_SYNC_EXCEPTION, &ExceptionUuid);
        Status = RpcBindingSetObject(Binding, &ExceptionUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        AsyncUsingAPC(Binding, 0, 10) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionOccured = 1;
        ExceptionCode = GetExceptionCode() ;
        }
    RpcEndExcept

    if (ExceptionOccured == 0
        || ExceptionCode != SYNC_EXCEPT)
        {
        PrintToConsole("Async: wrong exception value 0x%x\n", ExceptionCode );
        IsabelleError() ;

        Status = RpcBindingSetObject(Binding, &SavedUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to restore original object UUID\n");
            }

        return ;
        }

    // test sync exceptions (sync server)
    RpcTryExcept
        {
        ExceptionOccured = 0;
        ExceptionCode = 0;

        // ugly hack alert
        FooProcnum = 18 ;

        GenerateUuidValue(UUID_SYNC_EXCEPTION, &ExceptionUuid);
        Status = RpcBindingSetObject(Binding, &ExceptionUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        // async client, sync server (calling FooBar)
        AsyncUsingAPC(Binding, 0, 10) ;

        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionOccured = 1;
        ExceptionCode = GetExceptionCode() ;
        }
    RpcEndExcept

    FooProcnum = 16 ;

    if (ExceptionOccured == 0
        || ExceptionCode != SYNC_EXCEPT)
        {
        PrintToConsole("Async: wrong exception value 0x%x\n", ExceptionCode );
        IsabelleError() ;

        Status = RpcBindingSetObject(Binding, &SavedUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to restore original object UUID\n");
            }

        return ;
        }

    // test async exceptions
    RpcTryExcept
        {
        ExceptionOccured = 0;
        ExceptionCode = 0;

        GenerateUuidValue(UUID_ASYNC_EXCEPTION, &ExceptionUuid);
        Status = RpcBindingSetObject(Binding, &ExceptionUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        AsyncUsingAPC(Binding, 10, 0) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionOccured = 1;
        ExceptionCode = GetExceptionCode() ;
        }
    RpcEndExcept

    if (ExceptionOccured == 0
        || ExceptionCode != ASYNC_EXCEPT)
        {
        PrintToConsole("Async: wrong exception value 0x%x\n", ExceptionCode );
        IsabelleError() ;
        }

    Status = RpcBindingSetObject(Binding, &SavedUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to restore original object UUID\n");
        }
}

////////////////////////////////////////////////////////////
// Begin, stubs for FooCH                                                      //
////////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    void *state ;
    int *sizeout ;
    int **bufferout ;
    } FOOCH_ASYNC_CLIENT_STATE;


RPC_STATUS
FooCHComplete(
    IN PRPC_ASYNC_STATE pAsync,
    OUT void *Reply
    )
/*++

Routine Description:

    The completion routine corresponding to the function Foo. This routine
    is called to get the out parameters from an async function.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    RPC_STATUS Status ;
    RPC_MESSAGE Message ;
    int *ptr ;
    FOOCH_ASYNC_CLIENT_STATE *StubInfo =
               (FOOCH_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;

    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength ;
    Status = I_RpcReceive(&Message, 0) ;
    if (Status)
        {
        return Status ;
        }

    ptr = (int *) Message.Buffer ;

    *((int *) Reply) = *ptr++ ;
    *(StubInfo->sizeout) = *ptr++ ;

    *(StubInfo->bufferout) = (int *) I_RpcAllocate(*(StubInfo->sizeout)) ;
    if (*(StubInfo->bufferout) == 0)
        {
        return RPC_S_OUT_OF_MEMORY ;
        }

    RpcpMemoryCopy(*(StubInfo->bufferout), ptr, *(StubInfo->sizeout)) ;

    I_RpcFreeBuffer(&Message) ;
    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}


void
FooCH (
    PRPC_ASYNC_STATE pAsync,
    /* [in] */ void PAPI *ContextHandle,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    )
/*++

Routine Description:

    Client stub for function FooCH.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOCH_ASYNC_CLIENT_STATE *StubInfo ;
    int *Ptr ;

    StubInfo = (FOOCH_ASYNC_CLIENT_STATE *) I_RpcAllocate (
                        sizeof(FOOCH_ASYNC_CLIENT_STATE)) ;
    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->StubInfo = (void *) StubInfo ;

    StubInfo->StubState.CallHandle = NDRCContextBinding(ContextHandle) ;

    Message.Handle =  StubInfo->StubState.CallHandle;
    Message.BufferLength = 20+8+sizein+(sizein%4) ;
    Message.ProcNum = 19 | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // marshal ;-)
    Ptr = (int *) Message.Buffer ;

    NDRCContextMarshall(ContextHandle, Ptr) ;

    Ptr += 20 / sizeof(int) ;

    *Ptr++ = sizein ;

    RpcpMemoryCopy(Ptr, bufferin, sizein) ;

    Ptr += (sizein+3)/sizeof(int) ;

    *Ptr = *sizeout ;

    StubInfo->StubState.Flags = 0;
    StubInfo->sizeout = sizeout ;
    StubInfo->bufferout = bufferout ;

    RpcStatus = I_RpcAsyncSetHandle(&Message, (PRPC_ASYNC_STATE) pAsync) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CompletionRoutine = FooCHComplete ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CallHandle = Message.Handle ;
    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;
    // return to the app
}

typedef struct {
    RPC_ASYNC_STATE Async ;
    int SizeOut ;
    int *BufferOut ;
    BOOL CallFinished ;
    void PAPI *ContextHandle ;
    } FOOCH_CALL_COOKIE ;

void
FooCHAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    FOOCH_CALL_COOKIE *Cookie = (FOOCH_CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcCallComplete:
            Cookie->CallFinished = 1;
            OutstandingCalls--;
            break;
        }
}



void
CallFooCH (
    RPC_BINDING_HANDLE BindingHandle,
    FOOCH_CALL_COOKIE *Cookie,
    RPC_NOTIFICATION_TYPES NotificationType,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int *BufferIn ;
    unsigned long ContextUuid[5];

    Cookie->ContextHandle = 0;
    ContextUuid[0] = 0;
    ContextUuid[1] = 1;
    ContextUuid[2] = 2;
    ContextUuid[3] = 3;
    ContextUuid[4] = 4;

    NDRCContextUnmarshall(&(Cookie->ContextHandle),
                                       BindingHandle,
                                       ContextUuid,
                                       0x00L | 0x10L | 0x0000L);

    BufferIn = (int *) new char[SizeIn] ;
    if (BufferIn == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    Cookie->SizeOut = SizeOut ;
    Cookie->Async.Size = sizeof(RPC_ASYNC_STATE) ;
    Cookie->Async.Flags = 0;
    Cookie->Async.Lock = 0;
    Cookie->Async.NotificationType = NotificationType ;

    switch (NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeEvent:
            Cookie->Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
            if (Cookie->Async.u.hEvent == 0)
                {
                RpcRaiseException(APP_ERROR) ;
                }

            Cookie->Async.NotificationType = RpcNotificationTypeEvent ;
            break;

        case RpcNotificationTypeApc:
            Cookie->Async.NotificationType = RpcNotificationTypeApc ;
            Cookie->Async.u.APC.NotificationRoutine = FooCHAPCRoutine ;
            Cookie->Async.u.APC.hThread = 0;
            Cookie->CallFinished = 0;
            break;

        default:
            PrintToConsole("Async: bad notification type\n") ;
            break;
        }

    Cookie->Async.UserInfo = (void *) Cookie ;

    // call the async function
    // the buffers supplied for the [out] and the [in, out] params
    // should be valid until the logical RPC call has completed.
    FooCH(&Cookie->Async,
          Cookie->ContextHandle,
          SizeIn,
          BufferIn,
          &Cookie->SizeOut,
          &Cookie->BufferOut) ;

    delete BufferIn ;
}


void
ContextHandles(
    RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    FOOCH_CALL_COOKIE Cookie ;
    int retval ;

    RpcTryExcept
        {
        CallFooCH(Binding, &Cookie, RpcNotificationTypeApc, SizeIn, SizeOut) ;

        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        RpcSsDestroyClientContext(&(Cookie.ContextHandle));
        if ( Cookie.ContextHandle != 0 )
            {
            PrintToConsole("Async : ContextHandle != 0\n");
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie.BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("FooCH: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}

int AsyncSizes[] =
 {
 20, 100, 256, 1024, 10000, 100000
 } ;

#define CHECK_ERRORS \
    if (IsabelleErrors != 0)\
        {\
        PrintToConsole("Async : FAIL - Error(s) in Isabelle");\
        PrintToConsole(" Interface\n");\
        IsabelleShutdown(Async);\
        IsabelleErrors = 0;\
        return;\
        }

void
PingServer (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 4 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation ;
    Caller.RpcFlags = 0;

    if (UclntGetBuffer(&Caller) != RPC_S_OK)
        {
        IsabelleError();
        return ;
        }

    if (UclntSendReceive(&Caller) != RPC_S_OK)
        {
        IsabelleError();
        return;
        }

    if (I_RpcFreeBuffer(&Caller) != RPC_S_OK)
        {
        IsabelleError();
        }
}

long PendingCalls;

void
AsyncPingProc(
    IN PRPC_MESSAGE Message
    )
{
    if (UclntSendReceive(Message) != RPC_S_OK)
        {
        IsabelleError();
        InterlockedDecrement(&PendingCalls);

        return;
        }

    InterlockedDecrement(&PendingCalls);
}

void
AsyncPingServer (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller[20];
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    int i;

    for (i = 0; i <20; i++)
        {
        Caller[i].Handle = Binding;
        Caller[i].BufferLength = 0;
        Caller[i].ProcNum = 4 | HackForOldStubs ;
        Caller[i].RpcInterfaceInformation = &HelgaInterfaceInformation ;
        Caller[i].RpcFlags = 0;

        if (UclntGetBuffer(&Caller[i]) != RPC_S_OK)
            {
            IsabelleError();
            return ;
            }
        }

    PendingCalls = 20;
    for (i = 0; i<20; i++)
        {
        HandleToThread = CreateThread(
                                    0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) AsyncPingProc,
                                    &Caller[i],
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            PrintToConsole("AsyncPingServer: Error, couldn't create thread\n") ;
            IsabelleError();
            return;
            }
        }

    while (PendingCalls)
        {
        Sleep(1000);
        }

    for (i = 0; i < 20; i++)
        {
        if (I_RpcFreeBuffer(&Caller[i]) != RPC_S_OK)
            {
            IsabelleError();
            }
        }
}


void
AsyncCancels (
    IN RPC_BINDING_HANDLE Binding
    )
{
    RPC_STATUS Status ;
    CALL_COOKIE Cookie ;
    int retval ;


    RpcTryExcept
        {
        //
        // Test non abortive cancels
        //
        CallFoo(Binding, &Cookie, RpcNotificationTypeApc, 20, 20) ;

        Sleep(10);

        //
        // non abortive cancel
        //
        Status = RpcAsyncCancelCall(&Cookie.Async, 0);
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }


        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        //
        // Test abortive cancels
        //
        CallFoo(Binding, &Cookie, RpcNotificationTypeApc, 20, 20) ;

        Sleep(10);

        //
        // Abortive cancel
        //
        Status = RpcAsyncCancelCall(&Cookie.Async, 1);
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_CALL_CANCELLED)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}

#define LAST 15

extern void
AsyncAll (
        void
        )
/*++

Routine Description:
    Loop through all Async tests.

--*/
{
        int i;
        for( i = 0; i < LAST; i ++)
                {
                Async(i);
                }
}


void
Async (
    int testnum
    )
/*++

Routine Description:
    Invoke the tests.

--*/
{
    int i ;
    UUID ObjectUuid;
    UUID CancelUuid;
    RPC_BINDING_HANDLE Async;
    RPC_BINDING_HANDLE AsyncBind;

    if (testnum > LAST)
        {
        PrintToConsole("Async tests:\n") ;
        PrintToConsole("0: Run all the tests\n") ;
        PrintToConsole("1: Async using APCs, events and polling\n") ;
        PrintToConsole("2: Async pipes using events\n") ;
        PrintToConsole("3: Async pipes using APC, and flow control\n") ;
        PrintToConsole("4: Async with security\n") ;
        PrintToConsole("5: Sync and async exceptions\n") ;
        PrintToConsole("6: Multiple outstanding calls and causal ordering\n") ;
        PrintToConsole("7: Context handles\n") ;
        PrintToConsole("8: Sync/Async interop\n") ;
        PrintToConsole("9: Async ping server") ;
        PrintToConsole("10: Alter context during async calls\n") ;
        PrintToConsole("11: Async cancels\n") ;
        PrintToConsole("12: Multiple outstanding non causal calls\n") ;
        PrintToConsole("13: Rebinds on secure calls with uuids\n") ;
        NumberOfTestsRun++ ;
        return ;
        }

    Synchro(BARTHOLOMEW) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Async : Test Async RPC\n");

    Status = GetBinding(BARTHOLOMEW, &Async);
    if (Status)
        {
        ApiError("Async", "GetBinding", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

#if 0
    PingServer(Async);
    CHECK_ERRORS;
#endif

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError("Async", "CreateEvent", Status);
        return;
        }

    GenerateUuidValue(UUID_TEST_CANCEL, &ObjectUuid);
    Status = RpcBindingSetObject(Async, &ObjectUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to Set Object\n");
        return;
        }

    if (fNonCausal)
        {
        Status = RpcBindingSetOption(Async,
                                 RPC_C_OPT_BINDING_NONCAUSAL,
                                 1);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetOption", Status);
            PrintToConsole("Async : FAIL - Unable to Set Option\n");
            return;
            }
        }

    switch (testnum)
        {
        case 0:
        case 1:
            PrintToConsole("Async: Testing async using APCs, events and polling\n") ;
            for (i = 0; i < sizeof(AsyncSizes)/sizeof(int); i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;

                AsyncUsingEvent(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;

                AsyncUsingPolling(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }
            if (testnum != 0)
                {
                break;
                }

        case 2:
            PrintToConsole("Async: Testing async pipes using events\n") ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 3:
            PrintToConsole("Async: Testing async async pipes using APC, and flow control\n") ;
            AsyncPipesUsingAPC(Async) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 4:
            if (testnum != 0)
                {
                PrintToConsole("Async: Testing security\n") ;
                AsyncSecurityThreads() ;
                CHECK_ERRORS;
                break;
                }

        case 5:
            PrintToConsole("Async: Testing sync and async exceptions\n") ;
            AsyncExceptions(Async) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 6:
            PrintToConsole("Async: Testing multiple outstanding calls and causal ordering\n") ;
            MultipleOutstandingCalls(Async, 20) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 7:
            PrintToConsole("Async: Testing context handles\n") ;
            ContextHandles(Async, 20, 20) ;
            if (testnum != 0)
                {
                break;
                }

        case 8:
            PrintToConsole("Async: Testing Sync/Async interop\n") ;
            for (i = 0; i < sizeof(AsyncSizes)/sizeof(int); i++)
                {
                SyncAsyncInterop(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }
            if (testnum != 0)
                {
                break;
                }

        case 9:
            AsyncPingServer(Async);

            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 10:
            //
            // make a few calls on the Isabelle interface
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }

            FooProcnum = 7;
            FooInterface = &HelgaInterfaceInformation;

            //
            // make a few calls on the helga interface
            // this should cause an alter context
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }


            FooProcnum = 16;
            FooInterface = &IsabelleInterfaceInformation;
            //
            // make a few calls on the Isabelle interface
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }

            if (testnum != 0)
                {
                break;
                }

        case 11:
            PrintToConsole("Async: Test async cancels\n");

            GenerateUuidValue(UUID_SLEEP_1000, &ObjectUuid);
            Status = RpcBindingSetObject(Async, &ObjectUuid);
            if (Status)
                {
                ApiError("Async", "RpcBindingSetObject", Status);
                PrintToConsole("Async : FAIL - Unable to Set Object\n");
                return;
                }

            AsyncCancels(Async);
            CHECK_ERRORS;

            if (testnum != 0)
                {
                break;
                }

        case 12:
            PrintToConsole("Async: Testing multiple outstanding calls and causal ordering\n") ;

            Status = RpcBindingSetOption(Async, RPC_C_OPT_BINDING_NONCAUSAL, TRUE);
            if (Status)
              {
              ApiError("Async", "RpcBindingSetOption", Status);
              return;
              }

            MultipleOutstandingCalls(Async, 20) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 13:
            RpcBindingFree(&Async);
            Status = GetBinding(BARTHOLOMEW, &Async);
            if (Status)
                {
                ApiError("Async", "GetBinding", Status);
                PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
                return;
                }

            PrintToConsole("Async: Bind and async calls\n") ;
            for (i = 0; i < 10; i++)
                {
                Status = GetBinding(BARTHOLOMEW, &AsyncBind);
                if (Status)
                    {
                    ApiError("Async", "GetBinding", Status);
                    PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
                    return;
                    }

                Status = RpcBindingSetObject(AsyncBind, &ObjectUuid);
                if (Status)
                    {
                    ApiError("Async", "RpcBindingSetObject", Status);
                    PrintToConsole("Async : FAIL - Unable to Set Object\n");
                    return;
                    }

                Status = RpcBindingSetAuthInfoA(AsyncBind,
                                               (unsigned char *) "ServerPrincipal",
                                               RPC_C_AUTHN_LEVEL_CONNECT,
                                               10,
                                               NULL,
                                               0);
                if (Status)
                    {
                    ApiError("Async", "RpcBindingSetAuthInfo", Status);
                    PrintToConsole("Async : FAIL - Unable to Set AuthInfo\n");
                    return;
                    }

                AsyncUsingAPC(AsyncBind, 10, 10) ;
                CHECK_ERRORS;
                RpcBindingFree(&AsyncBind);
                }
            if (testnum != 0)
                {
                break;
                }

        case 14:

            Status = GetBinding(BARTHOLOMEW, &Async);
            if (Status)
                {
                ApiError("Async", "GetBinding", Status);
                PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
                return;
                }

            FooProcnum = 7;
            FooInterface = &HelgaInterfaceInformation;

            //
            // make a few calls on the helga interface
            // this should cause an alter context
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }
            if (testnum != 0)
                {
                break;
                }
        case LAST:
            PrintToConsole("hacked-up test\n");

            GenerateUuidValue(UUID_SLEEP_2000, &ObjectUuid);
            Status = RpcBindingSetObject(Async, &ObjectUuid);
            if (Status)
                {
                ApiError("Async", "RpcBindingSetObject", Status);
                PrintToConsole("Async : FAIL - Unable to Set Object\n");
                return;
                }

            AsyncUsingEvent( Async, 100, 100 );

            if (testnum != 0)
                {
                break;
                }

        default:
            PrintToConsole("Async tests:\n") ;
            PrintToConsole("0: Run all the tests\n") ;
            PrintToConsole("1: Async using APCs, events and polling\n") ;
            PrintToConsole("2: Async pipes using events\n") ;
            PrintToConsole("3: Async pipes using APC, and flow control\n") ;
            PrintToConsole("4: Async with security\n") ;
            PrintToConsole("5: Sync and async exceptions\n") ;
            PrintToConsole("6: Multiple outstanding calls and causal ordering\n") ;
            PrintToConsole("7: Context handles\n") ;
            PrintToConsole("8: Sync/Async interop\n") ;
            PrintToConsole("9: Async ping server") ;
            PrintToConsole("10: Alter context during async calls\n") ;
            PrintToConsole("11: Async cancels\n") ;
            PrintToConsole("12: Multiple outstanding non causal calls\n") ;
            PrintToConsole("13: Rebinds on secure calls with uuids\n") ;
            NumberOfTestsRun++ ;
            return ;
            break;
        }

    if (Async)
        {
        IsabelleShutdown(Async);
        }

    CHECK_ERRORS;

    CloseHandle(SyncEvent) ;

    RpcBindingFree(&Async);

    PrintToConsole("Async : PASS\n");
}

//
// datagram SendAck test data
//
#include "dgpkt.hxx"


typedef DWORD
(RPCRTAPI RPC_ENTRY *SET_TEST_HOOK_FN)(
                    RPC_TEST_HOOK_ID id,
                    RPC_TEST_HOOK_FN fn
                    );

SET_TEST_HOOK_FN SetTestHookFn;

PVOID ChosenConnection;

RPC_TEST_HOOK_ID BasicHookId;

void
BasicPokeEventFn(
    RPC_TEST_HOOK_ID id,
    PVOID arg1,
    PVOID arg2
    )
{
    PrintToConsole("PokeEventFn: conn = %p, setting the sync event\n", arg1);
    SetEvent( SyncEvent );
}

void BasicSendAckTest(
    int Hook
    )
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    ChosenConnection = 0;

    Status = GetBinding(BARTHOLOMEW, &binding);
    if (Status)
        {
        ApiError("SendAck", "GetBinding", Status);
        PrintToConsole("SetAsync : FAIL - Unable to Bind \n");
        return;
        }

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError("SendAck", "CreateEvent", Status);
        return;
        }

    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("SendAck","GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("SendAck", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        if (GetLastError() == ERROR_PROC_NOT_FOUND)
            {
            PrintToConsole("you need to recompile with -DRPC_ENABLE_TEST_HOOKS\n");
            }
        return;
        }

    BasicHookId = MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, Hook );

    (*SetTestHookFn)( BasicHookId, BasicPokeEventFn );

    // make first call
    //
    PrintToConsole("SendAck: first call...\n") ;
    Helga( binding );

    // wait for the ACK to complete
    //
    TRACE(("SendAck: Waiting...\n")) ;
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // make second call
    //
    PrintToConsole("SendAck: second call...\n") ;
    Helga( binding );

    // clear the hook
    //
    (*SetTestHookFn)( BasicHookId, 0 );

    PrintToConsole("PASS\n");
}


void
Test5EventFn(
    RPC_TEST_HOOK_ID id,
    PVOID arg1,
    PVOID arg2
    )
{
    // release the app thread to make calls
    //
    PrintToConsole("PokeEventFn: conn = %p, setting the sync event\n", arg1);
    SetEvent( SyncEvent );

    // wait for it to finish
    //
    WaitForSingleObject(SyncEvent, INFINITE);
    PrintToConsole("PokeEventFn: signalled\n");
}

void AckTest5()
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    ChosenConnection = 0;

    Status = GetBinding(BARTHOLOMEW, &binding);
    if (Status)
        {
        ApiError("SendAck", "GetBinding", Status);
        PrintToConsole("SetAsync : FAIL - Unable to Bind \n");
        return;
        }

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError("SendAck", "CreateEvent", Status);
        return;
        }

    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("SendAck","GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("SendAck", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        if (GetLastError() == ERROR_PROC_NOT_FOUND)
            {
            PrintToConsole("you need to recompile with -DRPC_ENABLE_TEST_HOOKS\n");
            }
        return;
        }

    // set hook for beginning of procedure
    //
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 1 ), Test5EventFn );

    // make first call
    //
    PrintToConsole("SendAck: first call, will cause a delayed ACK\n") ;
    Helga( binding );

    // wait for the ACK to start
    //
    TRACE(("SendAck: Waiting...\n")) ;
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // make a couple of calls
    //
    PrintToConsole("SendAck: second call, completes quickly\n") ;
    Helga( binding );

    PrintToConsole("SendAck: third call, completes quickly\n") ;
    Helga( binding );

    // clear the hook and add one for the end of the ACK proc.
    //
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 1 ), 0 );
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 6 ), BasicPokeEventFn );

    // release the ACK thread
    PrintToConsole("SendAck: releasing orphaned delayed-ACK call and waiting for completion\n") ;
    SetEvent( SyncEvent );
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // make a couple of calls
    //
    PrintToConsole("SendAck: first post-ACK call...\n") ;
    Helga( binding );

    PrintToConsole("SendAck: second post-ACK call...\n") ;
    Helga( binding );

    // wait for the ACK to finish
    //
    TRACE(("SendAck: waiting for delayed ACK to complete\n")) ;
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // clear the hook.
    //
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 6 ), 0 );

    PrintToConsole("PASS\n");
}


void
SendAck (
    int testnum
    )
{
    switch (testnum)
        {
        default:
            {
            PrintToConsole("unknown send-ack case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n"
                           "\n"
                           "    1 - make 2nd call after delayed-ACK proc has finished\n"
                           "    2 - make 2nd call before ACK proc can take connection mutex\n"
                           "    3 - make 2nd call just after ACK proc takes conn mutex\n"
                           "    4 - make 2nd call after ACK proc decrements AckPending\n"
                           "    5 - ACK proc blocks just before taking mutex - other calls proceed.\n"
                           );
            return;
            }

        case 0:
            {
            PrintToConsole("SendAck: testing each case\n");

            // no break here
            }

        case 1:
            {
            //
            // 1. thread makes one call
            // 2. ACK is sent
            // 3. thread makes second call
            //
            PrintToConsole("case 1 - make 2nd call after delayed-ACK proc has finished\n");

            BasicSendAckTest( 6 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 2:
            {
            // 1. thread makes a call
            // 2. ACK proc is launched but has not yet taken mutex
            // 3. thread makes second call
            PrintToConsole("case 2 - make 2nd call before ACK proc can take connection mutex\n");

            BasicSendAckTest( 1 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 3:
            {
            // 1. thread makes a call
            // 2. ACK proc is launched, takes connection mutex
            // 3. thread makes second call
            PrintToConsole("case 3 - make 2nd call just after ACK proc takes conn mutex\n");

            BasicSendAckTest( 2 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 4:
            {
            // 1. thread makes a call
            // 2. ACK proc is launched, sends ACK, decrements AckPending
            // 3. thread makes second call
            PrintToConsole("case 4 - make 2nd call after ACK proc decrements AckPending\n");

            BasicSendAckTest( 4 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 5:
            {
            // 1. make a call, and wait for the ACK.
            // 3, ACK proc runs in delayed-proc thread , and signals the first thread
            // 4. first thread makes a couple of calls, calling CancelDelayedAck several times.
            // 5. ACK proc finishes.
            // 6. Make anther call, and wait for the ACK.
            // 6. Make anther call, and wait for the ACK.
            PrintToConsole("case 5 - test orphaned ACK proc handling");

            AckTest5();

            if (testnum != 0)
                {
                break;
                }
            }
        }
}

void
SendErrorHook(
    RPC_TEST_HOOK_ID id,
    PVOID arg1,
    PVOID arg2
    )
{
    ASSERT( id == TH_X_DG_SEND );

    NCA_PACKET_HEADER * header = (NCA_PACKET_HEADER *) arg1;
    DWORD * pStatus = (DWORD *) arg2;

    TRACE(("SendErrorHook called: pkt type %d, serial %d\n", header->PacketType, header->SerialLo));

    switch (Subtest)
        {
        case 1:
            {
            // first request is dropped with RPC_P_SEND_FAILED
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = RPC_P_SEND_FAILED;
                }
            break;
            }
        case 2:
            {
            // first request is dropped with RPC_S_OUT_OF_RESOURCES
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = RPC_S_OUT_OF_RESOURCES;
                }
            break;
            }
        case 3:
            {
            // first request is dropped with ERROR_NOT_ENOUGH_MEMORY
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            break;
            }
        case 4:
            {
            // first request is dropped with RPC_P_HOST_DOWN
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = RPC_P_HOST_DOWN;
                }
            break;
            }
        default:
            {
            PrintToConsole("SendErrorHook: subtest %d is not defined\n", Subtest);
            }
        }

    TRACE(("status is %d (0x%x)\n", *pStatus, *pStatus));
}



void
DgTransport (
    int testnum
    )
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    char * name = "DgTransport";

    ChosenConnection = 0;

    Status = GetBinding(BARTHOLOMEW, &binding);
    if (Status)
        {
        ApiError(name, "GetBinding", Status);
        PrintToConsole("%s : FAIL - Unable to Bind \n", name);
        return;
        }

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError(name, "CreateEvent", Status);
        return;
        }

    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError(name, "GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        PrintToConsole("%s: can't find rpcrt4!I_RpcSetTestHook.\nRecompile RPCRT4.DLL with MSC_OPTIMIZATION=-DRPC_ENABLE_TEST_HOOKS\n");
        ApiError(name, "GetProcAddress: I_RpcSetTestHook", GetLastError());
        return;
        }

    switch (testnum)
        {
        default:
            {
            PrintToConsole("unknown DG transport case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n");
            PrintToConsole("case 1 - first request dropped with RPC_P_SEND_FAILED \n");
            PrintToConsole("case 2 - first request dropped with RPC_S_OUT_OF_RESOURCES \n");
            PrintToConsole("case 3 - first request dropped with ERROR_NOT_ENOUGH_MEMORY \n");
            PrintToConsole("case 4 - first request dropped with RPC_P_HOST_DOWN \n");
            PrintToConsole("case 5 - simulate ICMP reject on first request \n");
            return;
            }

        case 0:
            {
            PrintToConsole("DgTransport: testing each case\n");

            // no break here
            }

        case 1:
            {
            PrintToConsole("case 1 - first request dropped with RPC_P_SEND_FAILED \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Helga( binding );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            PrintToConsole("PASS\n");

            if (testnum != 0)
                {
                break;
                }
            }
        case 2:
            {
            PrintToConsole("case 2 - first request dropped with RPC_S_OUT_OF_RESOURCES \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Helga( binding );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            PrintToConsole("PASS\n");

            if (testnum != 0)
                {
                break;
                }
            }
        case 3:
            {
            PrintToConsole("case 3 - first request dropped with ERROR_NOT_ENOUGH_MEMORY \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Helga( binding );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            PrintToConsole("PASS\n");

            if (testnum != 0)
                {
                break;
                }
            }
        case 4:
            {
            PrintToConsole("case 4 - first request dropped with RPC_P_HOST_DOWN \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            if (Status != RPC_S_SERVER_UNAVAILABLE)
                {
                PrintToConsole("FAIL: wrong error code %d (0x%x)\n", Status, Status);
                }
            else
            {
                PrintToConsole("PASS\n");
                }

            if (testnum != 0)
                {
                break;
                }
            }
        case 5:
            {
            PrintToConsole("case 4 - first request dropped with RPC_P_HOST_DOWN \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            if (Status != RPC_S_SERVER_UNAVAILABLE)
                {
                PrintToConsole("FAIL: wrong error code %d (0x%x)\n", Status, Status);
                }
            else
                {
                PrintToConsole("PASS\n");
                }

            if (testnum != 0)
                {
                break;
                }
            }
        }
}


PVOID LastConnectionCreated = 0;

PVOID MySecurityContext = 0;

DWORD ChosenErrorCode = 0;

void
ShutdownHookFn(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    switch (id)
        {
        case TH_RPC_LOG_EVENT:
            {
            RPC_EVENT * event = (RPC_EVENT *) subject;

//            TRACE(("  hook: %c %c %p %p\n", event->Subject, event->Verb, event->SubjectPointer, event->ObjectPointer));

            //
            // Record sconnection creation.
            //
            if (event->Subject == SU_CCONN &&
                event->Verb    == EV_CREATE)
                {
                TRACE(("  hook: created connection %p\n", event->SubjectPointer));



                LastConnectionCreated = event->SubjectPointer;
                }

                break;
            }

        default:
            {
            break;
            }
        }
}

void
SecurityContextHook(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    if (subject == MySecurityContext)
        {
        TRACE(("  hook executed: context %p, hook ID %x, error code is 0x%x\n", subject, id, ChosenErrorCode));

        DWORD * pStatus = (DWORD *) object;

        *pStatus = ChosenErrorCode;
                }
    else
        {
        TRACE(("  hook: ignoring notification, my cxt = %p, context %p, hook ID %x, error code is 0x%x\n",
               MySecurityContext, subject, id, ChosenErrorCode));
        }
}



void
SecurityErrorWrapper(
    int subtest
    )
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    char * name = "security error test";

    ChosenConnection = 0;

    Status = GetBinding(SECURITY_ERROR, &binding);
    if (Status)
        {
        ApiError(name, "GetBinding", Status);
        PrintToConsole("%s : FAIL - Unable to Bind \n", name);
        return;
            }

    Status = RpcBindingSetAuthInfo( binding,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    ulSecurityPackage,
                                    NULL,
                                    RPC_C_AUTHZ_NONE
                                    );
    if (Status)
        {
        ApiError(name, "SetAuthInfo", Status);
        PrintToConsole("%s : FAIL\n", name);
        return;
        }

    //
    // Set up the test hook.
    //
    {
    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("","GetModuleHandle",GetLastError());
        return;
}

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        }
    }

    switch (subtest)
        {
        default:
            {
            PrintToConsole("unknown security-error case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n"
                           "\n"
                           "    1 - AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           "    2 - AcceptThirdLeg  returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           );
            return;
            }

        case 0:
            {
            PrintToConsole("running all sub tests\n");
            }

        case 1:
            {
            PrintToConsole("subtest 1: AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            Synchro(SECURITY_ERROR);

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            DWORD ExpectedStatus;

            if (TransportType == RPC_TRANSPORT_UDP ||
                TransportType == RPC_TRANSPORT_IPX)
                {
                ExpectedStatus = RPC_S_SERVER_UNAVAILABLE;
                }
            else
                {
                ExpectedStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
                }

            if (Status != ExpectedStatus)
                {
                PrintToConsole("FAIL: expected error %d, received error code %d (0x%x)\n", ExpectedStatus, Status, Status);
                }
            else
                {
                PrintToConsole("PASS\n");
                }

            IsabelleShutdown(binding);

            if (subtest)
                {
                break;
                }
            }

        case 2:
            {
            PrintToConsole("subtest 2: AcceptThirdLeg returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            Synchro(SECURITY_ERROR);

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            DWORD ExpectedStatus;

            if (TransportType == RPC_TRANSPORT_UDP ||
                TransportType == RPC_TRANSPORT_IPX)
                {
                ExpectedStatus = RPC_S_SERVER_UNAVAILABLE;
                }
            else
                {
                ExpectedStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
                }

            if (Status != ExpectedStatus)
                {
                PrintToConsole("FAIL: expected error %d, received error code %d (0x%x)\n", ExpectedStatus, Status, Status);
                }
            else
                {
                PrintToConsole("PASS\n");
                }

            IsabelleShutdown(binding);

            if (subtest)
                {
                break;
                }
            }
        }
}


EVENT::EVENT (
    IN OUT RPC_STATUS PAPI * RpcStatus,
    IN int ManualReset,
    IN BOOL fDelayInit
    )
{
    EventHandle = NULL;

    // DelayInit events are auto reset
    ASSERT(ManualReset == FALSE || fDelayInit == FALSE);

    if (!fDelayInit && *RpcStatus == RPC_S_OK )
        {
        EventHandle = CreateEvent(NULL, ManualReset, 0, NULL);
        if ( EventHandle != NULL )
            {
            *RpcStatus = RPC_S_OK;
            }
        else
            {
            *RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        }
}


EVENT::~EVENT (
    )
{

    if ( EventHandle )
        {
        BOOL bResult;
        bResult = CloseHandle(EventHandle);
        ASSERT(bResult != 0);
        }
}

int
EVENT::Wait (
    long timeout
    )
{
    DWORD result;

    if (NULL == EventHandle)
        {
        InitializeEvent();
        }

    result = WaitForSingleObject(EventHandle, timeout);

    if (result == WAIT_TIMEOUT)
        return(1);
    return(0);
}


void
EVENT::InitializeEvent (
    )
// Used when fDelayInit is TRUE in the c'tor.
{
    if (EventHandle)
        {
        return;
        }


    HANDLE event = CreateEvent(0, FALSE, FALSE, 0);

    if (event)
        {
        if (InterlockedCompareExchangePointer(&EventHandle, event, 0) != 0)
            {
            CloseHandle(event);
            }
        return;
        }

    // Can't allocate an event.
    RpcRaiseException(RPC_S_OUT_OF_RESOURCES);
}

void
Indent(
    int indentlevel
    )
{
    const int SPACES_PER_INDENT = 4;

    int i;
    for (i=0; i < SPACES_PER_INDENT * indentlevel; ++i)
        {
        PrintToConsole(" ");
        }
}

DWORD
DumpEeInfo(
    int indentlevel
    )
{
    RPC_STATUS Status2;
    RPC_ERROR_ENUM_HANDLE EnumHandle;

    Status2 = RpcErrorStartEnumeration(&EnumHandle);
    if (Status2 == RPC_S_ENTRY_NOT_FOUND)
        {
        PrintToConsole("eeinfo: no extended error info available\n");
        }
    else if (Status2 != RPC_S_OK)
        {
        PrintToConsole("Couldn't get EEInfo: %d\n", Status2);
        }
    else
        {
        RPC_EXTENDED_ERROR_INFO ErrorInfo;
        int Records;
        BOOL Result;
        BOOL CopyStrings = TRUE;
        PVOID Blob;
        size_t BlobSize;
        BOOL fUseFileTime = TRUE;
        SYSTEMTIME *SystemTimeToUse;
        SYSTEMTIME SystemTimeBuffer;

        Status2 = RpcErrorGetNumberOfRecords(&EnumHandle, &Records);
        if (Status2 == RPC_S_OK)
            {
            Indent(indentlevel);
            PrintToConsole("Number of records is: %d\n", Records);
            }

        while (Status2 == RPC_S_OK)
            {
            ErrorInfo.Version = RPC_EEINFO_VERSION;
            ErrorInfo.Flags = 0;
            ErrorInfo.NumberOfParameters = 4;
            if (fUseFileTime)
                {
                ErrorInfo.Flags |= EEInfoUseFileTime;
                }

            Status2 = RpcErrorGetNextRecord(&EnumHandle, CopyStrings, &ErrorInfo);
            if (Status2 == RPC_S_ENTRY_NOT_FOUND)
                {
                RpcErrorResetEnumeration(&EnumHandle);
                break;
                }
            else if (Status2 != RPC_S_OK)
                {
                PrintToConsole("Couldn't finish enumeration: %d\n", Status2);
                break;
                }
            else
                {
                int i;

                if (ErrorInfo.ComputerName)
                    {
                    Indent(indentlevel+1);
                    PrintToConsole("ComputerName is %S\n", ErrorInfo.ComputerName);
                    if (CopyStrings)
                        {
                        Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.ComputerName);
                        ASSERT(Result);
                        }
                    }

                Indent(indentlevel+1);
                PrintToConsole("ProcessID is %d\n", ErrorInfo.ProcessID);
                if (fUseFileTime)
                    {
                    Result = FileTimeToSystemTime(&ErrorInfo.u.FileTime, &SystemTimeBuffer);
                    ASSERT(Result);
                    SystemTimeToUse = &SystemTimeBuffer;
                    }
                else
                    SystemTimeToUse = &ErrorInfo.u.SystemTime;

                Indent(indentlevel+1);
                PrintToConsole("System Time is: %d/%d/%d %d:%d:%d:%d\n",
                    SystemTimeToUse->wMonth,
                    SystemTimeToUse->wDay,
                    SystemTimeToUse->wYear,
                    SystemTimeToUse->wHour,
                    SystemTimeToUse->wMinute,
                    SystemTimeToUse->wSecond,
                    SystemTimeToUse->wMilliseconds);

                Indent(indentlevel+1);
                PrintToConsole("Generating component is %d\n", ErrorInfo.GeneratingComponent);
                Indent(indentlevel+1);
                PrintToConsole("Status is %d\n", ErrorInfo.Status);
                Indent(indentlevel+1);
                PrintToConsole("Detection location is %d\n", (int)ErrorInfo.DetectionLocation);
                Indent(indentlevel+1);
                PrintToConsole("Flags is %d\n", ErrorInfo.Flags);
                Indent(indentlevel+1);
                PrintToConsole("NumberOfParameters is %d\n", ErrorInfo.NumberOfParameters);

                for (i = 0; i < ErrorInfo.NumberOfParameters; i ++)
                    {
                    switch(ErrorInfo.Parameters[i].ParameterType)
                        {
                        case eeptAnsiString:
                            Indent(indentlevel+1);
                            PrintToConsole("Ansi string: %s\n", ErrorInfo.Parameters[i].u.AnsiString);
                            if (CopyStrings)
                                {
                                Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.Parameters[i].u.AnsiString);
                                ASSERT(Result);
                                }
                            break;

                        case eeptUnicodeString:
                            Indent(indentlevel+1);
                            PrintToConsole("Unicode string: %S\n", ErrorInfo.Parameters[i].u.UnicodeString);
                            if (CopyStrings)
                                {
                                Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.Parameters[i].u.UnicodeString);
                                ASSERT(Result);
                                }
                            break;

                        case eeptLongVal:
                            Indent(indentlevel+1);
                            PrintToConsole("Long val: %d\n", ErrorInfo.Parameters[i].u.LVal);
                            break;

                        case eeptShortVal:
                            Indent(indentlevel+1);
                            PrintToConsole("Short val: %d\n", (int)ErrorInfo.Parameters[i].u.SVal);
                            break;

                        case eeptPointerVal:
                            Indent(indentlevel+1);
                            PrintToConsole("Pointer val: %d\n", ErrorInfo.Parameters[i].u.PVal);
                            break;

                        case eeptNone:
                            Indent(indentlevel+1);
                            PrintToConsole("Truncated\n");
                            break;

                        default:
                            Indent(indentlevel+1);
                            PrintToConsole("Invalid type: %d\n", ErrorInfo.Parameters[i].ParameterType);
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                }
            }

        Status2 = RpcErrorSaveErrorInfo(&EnumHandle, &Blob, &BlobSize);
        if (Status2)
            {
            PrintToConsole("RpcErrorSaveErrorInfo: %d", Status2);
            }

        RpcErrorClearInformation();
        RpcErrorEndEnumeration(&EnumHandle);
        Status2 = RpcErrorLoadErrorInfo(Blob, BlobSize, &EnumHandle);
        if (Status2)
            {
            PrintToConsole("RpcErrorLoadErrorInfo: %d", Status2);
            }
        }

    return Status2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\afd.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

    Module Name:

        Afd.cxx

    Abstract:

        Wrappers to simulate winsock API directly on top of AFD IOCTLS.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     4/4/1997    Based on NT 4 DG code.

--*/

#include <precomp.hxx>
#include <tdi.h>
#include <clustdi.h>
#include <afd.h>

void
InitializeRawAddress(
    IN WS_SOCKADDR *pSockAddr,
    OUT PVOID pRawAddress,
    OUT DWORD *pdwRawAddressSize
    )
/*++

Routine Description:

    Converts from a winsock sockaddr to a TDI format address.

Arguments:

    pSockAddr - The address to convert from, must be either a
        AF_INET (IP), AF_IPX, or AF_CLUSTER family address.

    pRawAddress - The buffer to store the TDI format address.
    pdwRawAddressSize - On return, the size of the TDI format address.

Return Value:

    None

--*/

{
#ifdef IPX_ON
    ASSERT(   pSockAddr->generic.sa_family == AF_INET
           || pSockAddr->generic.sa_family == AF_IPX
           || pSockAddr->generic.sa_family == AF_CLUSTER);
#else
    ASSERT(   pSockAddr->generic.sa_family == AF_INET
           || pSockAddr->generic.sa_family == AF_CLUSTER);
#endif

    switch (pSockAddr->generic.sa_family) {
    case AF_INET:
        {
        // UDP

        TA_IP_ADDRESS *pra = (TA_IP_ADDRESS *)pRawAddress;

        pra->TAAddressCount = 1;
        pra->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pra->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        pra->Address[0].Address[0].sin_port = pSockAddr->inetaddr.sin_port;
        pra->Address[0].Address[0].in_addr = pSockAddr->inetaddr.sin_addr.s_addr;
        memset(pra->Address[0].Address[0].sin_zero, 0, 8);

        *pdwRawAddressSize = sizeof(TA_IP_ADDRESS);
        break;
        }

#ifdef IPX_ON
    case AF_IPX:
        {
        // IPX

        TA_IPX_ADDRESS *pra = (TA_IPX_ADDRESS *)pRawAddress;

        pra->TAAddressCount = 1;
        pra->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IPX;
        pra->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
        memcpy(&pra->Address[0].Address[0].NetworkAddress, pSockAddr->ipxaddr.sa_netnum, 4);
        memcpy(&pra->Address[0].Address[0].NodeAddress, pSockAddr->ipxaddr.sa_nodenum, 6);
        pra->Address[0].Address[0].Socket = pSockAddr->ipxaddr.sa_socket;

        *pdwRawAddressSize = sizeof(TA_IPX_ADDRESS);
        break;
        }
#endif

    case AF_CLUSTER:
        {
        // Clusters

        TA_CLUSTER_ADDRESS *pra = (TA_CLUSTER_ADDRESS *)pRawAddress;

        pra->TAAddressCount = 1;
        pra->Address[0].AddressLength = TDI_ADDRESS_LENGTH_CLUSTER;
        pra->Address[0].AddressType = TDI_ADDRESS_TYPE_CLUSTER;
        pra->Address[0].Address[0].Port = pSockAddr->clusaddr.sac_port;
        pra->Address[0].Address[0].Node = pSockAddr->clusaddr.sac_node;
        pra->Address[0].Address[0].ReservedMBZ = 0;

        *pdwRawAddressSize = sizeof(TA_CLUSTER_ADDRESS);
        }
    }

    return;
}


int
WSAAPI
AFD_SendTo(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++

Routine Description:

    Implement's a wrapper around the AFD recv IOCTL which looks like WSASendTo.
    RPC uses this when MSAFD is the network provider.

Note:

    Try reading private\net\sockets\winsock2\wsp\msafd\send.c if you want
    more information.

Arguments:

    WSASendTo arguments

Return Value:

    0 - success
    ERROR_IO_PENDING - IO submitted

    non-zero - error

--*/

{
    PIO_STATUS_BLOCK pIoStatus = (PIO_STATUS_BLOCK)&lpOverlapped->Internal;
    AFD_SEND_DATAGRAM_INFO sendInfo;
    UCHAR abRawAddress[max(sizeof(TA_IP_ADDRESS),sizeof(TA_IPX_ADDRESS))];
    DWORD dwRawAddressSize;
    int status;
    NTSTATUS NtStatus;

    ASSERT(lpCompletionRoutine == 0);
    ASSERT(lpOverlapped);

    InitializeRawAddress((WS_SOCKADDR *)lpTo, abRawAddress, &dwRawAddressSize);

    sendInfo.AfdFlags = AFD_OVERLAPPED;
    sendInfo.BufferArray = lpBuffers;
    sendInfo.BufferCount = dwBufferCount;
    sendInfo.TdiRequest.SendDatagramInformation = &sendInfo.TdiConnInfo;
    sendInfo.TdiConnInfo.UserDataLength = 0;
    sendInfo.TdiConnInfo.UserData = 0;
    sendInfo.TdiConnInfo.OptionsLength = 0;
    sendInfo.TdiConnInfo.Options = 0;
    sendInfo.TdiConnInfo.RemoteAddressLength = dwRawAddressSize;
    sendInfo.TdiConnInfo.RemoteAddress = abRawAddress;

    lpOverlapped->Internal = STATUS_PENDING;

    NtStatus = NtDeviceIoControlFile(
                                     (HANDLE)s,
                                     lpOverlapped->hEvent,
                                     NULL,
                                     ( PtrToUlong(lpOverlapped->hEvent) & 1 ) ? NULL : lpOverlapped,
                                     pIoStatus,
                                     IOCTL_AFD_SEND_DATAGRAM,
                                     &sendInfo,
                                     sizeof(sendInfo),
                                     NULL,
                                     0
                                     );

    if (NtStatus == STATUS_PENDING)
        {
        SetLastError(WSA_IO_PENDING);
        *lpNumberOfBytesSent = 0;
        return(-1);
        }

    if (NtStatus == STATUS_HOST_DOWN)
        {
        SetLastError(WSAEHOSTDOWN);
        return(-1);
        }

    if (!NT_SUCCESS(NtStatus))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Afd send failed: 0x%x\n",
                       NtStatus));

        SetLastError(RtlNtStatusToDosError(NtStatus));
        return(-1);
        }

    *lpNumberOfBytesSent = ULONG(pIoStatus->Information);

    ASSERT(*lpNumberOfBytesSent);

    return 0;
}

int
WSAAPI
AFD_RecvFrom(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++

Routine Description:

    Implement's a wrapper around the AFD recv IOCTL which looks like WSARecvFrom.
    RPC uses this when MSAFD is the network provider.

Notes:

    Try reading private\net\sockets\winsock2\wsp\msafd\recv.c if you want
    more information.

Arguments:

    WSARecvFrom arguments

Return Value:

    0 - success
    ERROR_IO_PENDING - IO submitted

    non-zero - error

--*/

{
    PIO_STATUS_BLOCK pIoStatus = (PIO_STATUS_BLOCK )&lpOverlapped->Internal;
    AFD_RECV_DATAGRAM_INFO recvInfo;
    int status;
    NTSTATUS NtStatus;

    ASSERT(lpCompletionRoutine == 0);
    ASSERT(lpOverlapped);

    recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
    recvInfo.AfdFlags = AFD_OVERLAPPED;
    recvInfo.BufferArray = lpBuffers;
    recvInfo.BufferCount = dwBufferCount;
    recvInfo.Address = lpFrom;
    recvInfo.AddressLength = (PULONG)lpFromlen;

    lpOverlapped->Internal = STATUS_PENDING;

    NtStatus = NtDeviceIoControlFile((HANDLE)s,
                                     lpOverlapped->hEvent,
                                     0,
                                     ( PtrToUlong(lpOverlapped->hEvent) & 1 ) ? NULL : lpOverlapped,
                                     pIoStatus,
                                     IOCTL_AFD_RECEIVE_DATAGRAM,
                                     &recvInfo,
                                     sizeof(recvInfo),
                                     NULL,
                                     0);

    if (NtStatus == STATUS_PENDING)
        {
        SetLastError(ERROR_IO_PENDING);
        return(ERROR_IO_PENDING);
        }

    if (!NT_SUCCESS(NtStatus))
        {
        switch (NtStatus)
            {
            case STATUS_PORT_UNREACHABLE:       status = WSAECONNRESET;   break;
            case STATUS_HOST_UNREACHABLE:       status = WSAEHOSTUNREACH; break;
            case STATUS_NETWORK_UNREACHABLE:    status = WSAENETUNREACH;  break;

            case STATUS_BUFFER_OVERFLOW:
            case STATUS_RECEIVE_PARTIAL:
                {
                *lpNumberOfBytesRecvd = -1 * ULONG(pIoStatus->Information);
                status = WSAEMSGSIZE;
                break;
                }

            default:
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "Afd recv failed: 0x%x\n",
                               NtStatus));

                status = RPC_S_OUT_OF_RESOURCES;
                break;
                }
            }

        SetLastError( status );
        }
    else
        {
        *lpNumberOfBytesRecvd = ULONG(pIoStatus->Information);
        status = NO_ERROR;
        }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\cotrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CoTrans.cxx

Abstract:

    Common connection-oriented helper functions

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo    11/11/1996    Async RPC

--*/

#include <precomp.hxx>
#include <trans.hxx>
#include <cotrans.hxx>


RPC_STATUS
RPC_ENTRY
CO_Send(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Length,
    BUFFER Buffer,
    PVOID SendContext
    )
/*++

Routine Description:

    Submits a send of the buffer on the connection.  Will complete with
    ConnectionServerSend or ConnectionClientSend event either when
    the data has been sent on the network or when the send fails.

Arguments:

    ThisConnection - The connection to send the data on.
    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer to use as the CO_SEND_CONTEXT for
        this operation.

Return Value:

    RPC_S_OK

    RPC_P_SEND_FAILED - Connection aborted

--*/
{
    PCONNECTION pConnection = (PCONNECTION)ThisConnection;
    CO_SEND_CONTEXT *pSend = (CO_SEND_CONTEXT *)SendContext;
    BOOL b;
    DWORD ignored;
    RPC_STATUS status;

    pConnection->StartingWriteIO();

    if (pConnection->fAborted)
        {
        pConnection->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    pSend->maxWriteBuffer = Length;
    pSend->pWriteBuffer = Buffer;
    pSend->Write.pAsyncObject = pConnection;
    pSend->Write.ol.hEvent = 0;
    pSend->Write.ol.Offset = 0;
    pSend->Write.ol.OffsetHigh = 0;
    pSend->Write.thread = I_RpcTransProtectThread();

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (Buffer, Length, 0);
        }
#endif

    status = pConnection->Send(
                            pConnection->Conn.Handle,
                            Buffer,
                            Length,
                            &ignored,
                            &pSend->Write.ol
                            );

    pConnection->WriteIOFinished();

    if (   (status != RPC_S_OK)
        && (status != ERROR_IO_PENDING) )
        {
        RpcpErrorAddRecord(EEInfoGCIO,
            status, 
            EEInfoDLCOSend10,
            (ULONGLONG)pConnection,
            (ULONGLONG)Buffer,
            Length);

        VALIDATE(status)
            {
            ERROR_NETNAME_DELETED,
            ERROR_BROKEN_PIPE,
            ERROR_GRACEFUL_DISCONNECT,
            ERROR_NO_DATA,
            ERROR_NO_SYSTEM_RESOURCES,
            ERROR_WORKING_SET_QUOTA,
            ERROR_BAD_COMMAND,
            ERROR_OPERATION_ABORTED,
            ERROR_WORKING_SET_QUOTA,
            ERROR_PIPE_NOT_CONNECTED,
            WSAECONNABORTED,
            WSAECONNRESET,
            WSAENOBUFS,
            WSASYSCALLFAILURE
            } END_VALIDATE;

        I_RpcTransUnprotectThread(pSend->Write.thread);

        pConnection->Abort();

        return(RPC_P_SEND_FAILED);
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
CO_SubmitRead(
    PCONNECTION pConnection
    )
/*++

Routine Description:

    Generic routine to submit an async read on an existing connection.

Arguments:

    pConnection - The connection to submit the read on.
        pConnection->pReadBuffer - valid buffer to receive into or null.
        pConnection->maxReadBuffer - size of pReadBuffer or null.
        pConnection->iLastRead is an offset into pReadBuffer of
            data already read.

Return Value:

    RPC_S_OK - Read pending

    RPC_P_RECEIVE_FAILED - Connection aborted

--*/
{
    BOOL b;
    DWORD ignored;
    RPC_STATUS status;

    if (pConnection->pReadBuffer == 0)
        {
        ASSERT(pConnection->iLastRead == 0);

        pConnection->pReadBuffer = TransConnectionAllocatePacket(pConnection,
                                                                 pConnection->iPostSize);
        if (pConnection->pReadBuffer == 0)
            {
            pConnection->Abort();
            return(RPC_P_RECEIVE_FAILED);
            }

        pConnection->maxReadBuffer = pConnection->iPostSize;
        }
    else
        {
        ASSERT(pConnection->iLastRead < pConnection->maxReadBuffer);
        }

    pConnection->StartingReadIO();
    if (pConnection->fAborted)
        {
        pConnection->ReadIOFinished();
        return(RPC_P_RECEIVE_FAILED);
        }

    pConnection->Read.thread = I_RpcTransProtectThread();
    pConnection->Read.ol.hEvent = 0;

    ASSERT(pConnection->Read.ol.Internal != STATUS_PENDING);

    status = pConnection->Receive(
                           pConnection->Conn.Handle,
                           pConnection->pReadBuffer + pConnection->iLastRead,
                           pConnection->maxReadBuffer - pConnection->iLastRead,
                           &ignored,
                           &pConnection->Read.ol
                           );

    pConnection->ReadIOFinished();

    if (   (status != RPC_S_OK)
        && (status != ERROR_IO_PENDING)
        && (status != ERROR_MORE_DATA) )
        {
        if (   status != ERROR_NETNAME_DELETED
            && status != ERROR_BROKEN_PIPE
            && status != ERROR_GRACEFUL_DISCONNECT)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "UTIL_ReadFile failed %d on %p\n",
                           status,
                           pConnection));
            }

        RpcpErrorAddRecord(EEInfoGCIO,
            status, 
            EEInfoDLCOSubmitRead10);

        // the IO system does not necessarily reset the Internal on sync failure.
        // Reset it because in HTTP when we encounted a sync failure on RTS receive 
        // we may submit a second receive after a failed receive and this will 
        // trigger the ASSERT above
        pConnection->Read.ol.Internal = status;

        I_RpcTransUnprotectThread(pConnection->Read.thread);

        pConnection->Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    // Even if the read completed here, it will also be posted to the
    // completion port.  This means we don't need to handle the read here.

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
CO_Recv(
    RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    Called be the runtime on a connection without a currently
    pending recv.

Arguments:

    ThisConnection - A connection without a read pending on it.

Return Value:

    RPC_S_OK
    RPC_P_RECEIVE_FAILED

--*/
{
    PCONNECTION p = (PCONNECTION)ThisConnection;

    if (   p->iLastRead
        && p->iLastRead == p->maxReadBuffer)
        {
        ASSERT(p->pReadBuffer);

        // This means we received a coalesced read of a complete
        // message. (Or that we received a coalesced read < header size)
        // We should complete that as it's own IO. This is very
        // rare.

        TransDbgDetail((DPFLTR_RPCPROXY_ID,
                        DPFLTR_INFO_LEVEL,
                        RPCTRANS "Posted coalesced data in %p of %d byte\n",
                        p,
                        p->iLastRead));

        UINT bytes;

        bytes = p->iLastRead;
        p->iLastRead = 0;
        p->Read.thread = I_RpcTransProtectThread();

        // This means we want to process this as a new receive
        BOOL b = PostQueuedCompletionStatus(RpcCompletionPort,
                                            bytes,
                                            TRANSPORT_POSTED_KEY,
                                            &p->Read.ol);

        ASSERT(b); // See complete.cxx - we can handle it here if needed.

        return(RPC_S_OK);
        }

    ASSERT(p->iLastRead == 0 || (p->iLastRead < p->maxReadBuffer));

    return(CO_SubmitRead(p));
}


RPC_STATUS BASE_CONNECTION::ProcessRead(IN  DWORD bytes, OUT BUFFER *pBuffer,
                                        OUT PUINT pBufferLength)
/*++

Routine Description:

    Receives a message from a message or byte mode protocol.

Arguments:

    bytes - The number of read (not including those in iLastRead).
    pBuffer - When returning RPC_S_OK will contain the message.
    pBufferLength - When return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK - A complete message has been returned.

    RPC_P_RECEIVE_FAILED - something failed.

    RPC_P_PARTIAL_RECEIVE - Partial message recv'd, need to submit another recv.

--*/
{
    DWORD message_size;
    RPC_STATUS status;

    bytes += iLastRead;

    if (bytes < sizeof(CONN_RPC_HEADER))
        {
        // Not a whole header, resubmit the read and continue.

        iLastRead = bytes;

        return(RPC_P_PARTIAL_RECEIVE);
        }

    message_size = MessageLength((PCONN_RPC_HEADER)pReadBuffer);

    if (message_size < sizeof(CONN_RPC_HEADER))
        {
        ASSERT(message_size >= sizeof(CONN_RPC_HEADER));
        Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    if (bytes == message_size)
        {
        // All set, have a complete request.
        *pBuffer = pReadBuffer;
        *pBufferLength = message_size;

        iLastRead = 0;
        pReadBuffer = 0;
        return(RPC_S_OK);
        }
    else if (message_size > bytes)
        {
        // Don't have a complete message, realloc if needed and
        // resubmit a read for the remaining bytes.

        if (maxReadBuffer < message_size)
            {
            // Buffer too small for the message.
            status = TransConnectionReallocPacket(this,
                                                  &pReadBuffer,
                                                  bytes,
                                                  message_size);

            if (status != RPC_S_OK)
                {
                ASSERT(status == RPC_S_OUT_OF_MEMORY);
                Abort();
                return(RPC_P_RECEIVE_FAILED);
                }

            // increase the post size, but not if we are in direct
            // buffer mode.
            if (gBCacheMode == BCacheModeCached)
                iPostSize = message_size;
            }

        // Setup to receive exactly the remaining bytes of the message.
        iLastRead = bytes;
        maxReadBuffer = message_size;

        return(RPC_P_PARTIAL_RECEIVE);
        }

    // Coalesced read, save extra data.  Very uncommon, impossible for
    // message mode protocols.

    ASSERT(bytes > message_size);

#ifdef SPX_ON
    ASSERT((id == TCP) || (id == SPX) || (id == HTTP) || (id == TCP_IPv6) || (id == HTTPv2));
#else
    ASSERT((id == TCP) || (id == HTTP) || (id == TCP_IPv6) || (id == HTTPv2));
#endif

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "Coalesced read of %d bytes, connection %p\n",
                   bytes - message_size,
                   this));

    // The first message and size will be returned

    *pBuffer = pReadBuffer;
    *pBufferLength = message_size;

    UINT extra = bytes - message_size;
    UINT alloc_size;

    // Try to find a good size of the extra PDU(s)
    if (extra < sizeof(CONN_RPC_HEADER))
        {
        // Not a whole header, we'll assume iPostSize;

        alloc_size = iPostSize;
        }
    else
        {
#ifdef _M_IA64
        // The first packet may not contain a number of bytes
        // that align the second on an 8-byte boundary.  Hence, the
        // structure may end up unaligned. 
        alloc_size = MessageLengthUnaligned((PCONN_RPC_HEADER)(pReadBuffer
                                                               + message_size));
#else
        alloc_size = MessageLength((PCONN_RPC_HEADER)(pReadBuffer
                                                      + message_size));
#endif
        }

    if (alloc_size < extra)
        {
        // This can happen if there are more than two PDUs coalesced together
        // in the buffer.  Or if the PDU is invalid. Or if the iPostSize is
        // smaller than the next PDU.
        alloc_size = extra;
        }

    // Allocate a new buffer to save the extra data for the next read.
    PBYTE pNewBuffer;

    pNewBuffer = TransConnectionAllocatePacket(this,
                                               alloc_size);

    if (0 == pNewBuffer)
        {
        // We have a complete request.  We could process the request and
        // close the connection only after trying to send the reply.

        *pBuffer = 0;
        *pBufferLength = 0;

        Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    ASSERT(*pBuffer);

    // Save away extra data for the next receive
    RpcpMemoryCopy(pNewBuffer,
                   pReadBuffer + *pBufferLength,
                   extra);
    pReadBuffer = pNewBuffer;
    iLastRead = extra;
    maxReadBuffer = alloc_size;

    ASSERT(iLastRead <= maxReadBuffer);

    ASSERT(pReadBuffer != *pBuffer);

    return(RPC_S_OK);
}


RPC_STATUS
CO_SubmitSyncRead(
    IN PCONNECTION pConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pMessageLength
    )
/*++

Routine Description:

    Called in the synchronous receive path when more data is needed
    in to complete the message.  This function is non-blocking but
    it will try to read as much data as it can and may return a
    completed PDU.

Arguments:

    pConnection - The connection to receive from.
            ->pReadBuffer
            ->maxReadBuffer
            ->iLastRead

Return Value:

    RPC_S_OK - Ok and a complete PDU has arrived

    RPC_P_IO_PENDING - A receive is now outstanding on the connection.
        Wait for it to complete..

    RPC_P_RECEIVE_FAILED - Failure
    RPC_P_CONNECTION_SHUTDOWN - Failure - graceful close received.

--*/
{
    RPC_STATUS status;

    ASSERT(pConnection->pReadBuffer);

    if (pConnection->maxReadBuffer == pConnection->iLastRead)
        {
        // Coalesced receive and we've got one (or more) PDUs
        status = pConnection->ProcessRead(0, pBuffer, pMessageLength);

        ASSERT(status != RPC_P_PARTIAL_RECEIVE);

        return(status);
        }

    DWORD bytes;
    DWORD readbytes;

    ASSERT_READ_EVENT_IS_THERE(pConnection);

    do
        {
        BOOL b;

        readbytes = pConnection->maxReadBuffer - pConnection->iLastRead;

        pConnection->StartingReadIO();
        if (pConnection->fAborted)
            {
            pConnection->ReadIOFinished();
            return(RPC_P_RECEIVE_FAILED);
            }

        status = pConnection->Receive(pConnection->Conn.Handle,
                               pConnection->pReadBuffer + pConnection->iLastRead,
                               readbytes,
                               &bytes,
                               &pConnection->Read.ol);

        pConnection->ReadIOFinished();

        if ((status == ERROR_IO_PENDING) || (status == ERROR_IO_INCOMPLETE))
            {
            // The most common path
            return(RPC_P_IO_PENDING);
            }

        if (status != RPC_S_OK)
            {
            switch (status)
                {
                case ERROR_MORE_DATA:
                    // Treat as success

                    // Note: ReadFile doesn't return the number of bytes read in this
                    // case even though the data is available...
                    // It should still be right, but this double checks it.

                    ASSERT(pConnection->Read.ol.InternalHigh == readbytes);

                    ASSERT(MessageLength((PCONN_RPC_HEADER)pConnection->pReadBuffer) >
                           pConnection->maxReadBuffer);

                    bytes = readbytes;

                    status = RPC_S_OK;
                    break;

                case ERROR_GRACEFUL_DISCONNECT:
                    RpcpErrorAddRecord(EEInfoGCIO,
                        status, 
                        EEInfoDLCOSubmitSyncRead10);
                    status = RPC_P_CONNECTION_SHUTDOWN;
                    break;

                default:
                    RpcpErrorAddRecord(EEInfoGCIO,
                        status, 
                        EEInfoDLCOSubmitSyncRead20);
                    VALIDATE(status)
                        {
                        STATUS_TIME_DIFFERENCE_AT_DC,
                        ERROR_NETNAME_DELETED,
                        ERROR_BROKEN_PIPE,
                        ERROR_PIPE_NOT_CONNECTED,
                        ERROR_NO_SYSTEM_RESOURCES,
                        ERROR_COMMITMENT_LIMIT,
                        WSAECONNRESET,
                        WSAESHUTDOWN,
                        WSAECONNABORTED,
                        ERROR_UNEXP_NET_ERR,
                        ERROR_WORKING_SET_QUOTA,
                        ERROR_NO_DATA
                        } END_VALIDATE;
                    status = RPC_P_RECEIVE_FAILED;
                    break;
                }
            }

        if (bytes == 0)
            {
            status = RPC_P_CONNECTION_SHUTDOWN;
            }

        if (status != RPC_S_OK)
            {
            pConnection->Abort();
            return(status);
            }

        // Read completed, process the data now..
        status = pConnection->ProcessRead(bytes, pBuffer, pMessageLength);
        }
    while (status == RPC_P_PARTIAL_RECEIVE );

    return(status);
}

RPC_STATUS
RPC_ENTRY
CO_SyncRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Receive the next PDU to arrive at the connection.

Arguments:

    ThisConnection - The connection to read from.

    pBuffer - If successful, points to a buffer containing the next PDU.
    pBufferLength -  If successful, contains the length of the message.

Return Value:

    RPC_S_OK

    RPC_P_RECEIVE_FAILED - Connection aborted.
    RPC_S_CALL_CANCELLED - Connection aborted.

--*/
{
    PCONNECTION p = (PCONNECTION)ThisConnection;
    DWORD bytes;
    RPC_STATUS status;
    HANDLE hEvent;

    ASSERT((p->type & TYPE_MASK) == CLIENT);

    ASSERT(p->pReadBuffer == 0);

    p->pReadBuffer = TransConnectionAllocatePacket(p, p->iPostSize);

    hEvent = I_RpcTransGetThreadEvent();

    if (p->pReadBuffer == 0)
        {
        p->Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    p->maxReadBuffer = p->iPostSize;
    p->iLastRead = 0;
    p->Read.ol.hEvent = (HANDLE)((ULONG_PTR)hEvent | 0x01);

    do
        {
        status = CO_SubmitSyncRead(p, pBuffer, pBufferLength);

        if (status != RPC_P_IO_PENDING)
            {
            ASSERT(status != RPC_S_CALL_CANCELLED);
            break;
            }

        status = UTIL_GetOverlappedResultEx(ThisConnection,
                                            &p->Read.ol,
                                            &bytes,
                                            TRUE, // Alertable
                                            dwTimeout);

        if (status != RPC_S_OK)
            {
            if (status != ERROR_MORE_DATA)
                {
                RpcpErrorAddRecord(EEInfoGCIO,
                    status, 
                    EEInfoDLCOSyncRecv10);
                if ((status != RPC_S_CALL_CANCELLED) && (status != RPC_P_TIMEOUT))
                    {
                    status = RPC_P_RECEIVE_FAILED;
                    }

                break;
                }

            // ERROR_MORE_DATA is success
            }


        status = p->ProcessRead(bytes, pBuffer, pBufferLength);

        }
    while (status == RPC_P_PARTIAL_RECEIVE);

    if (status == RPC_S_OK)
        {
        ASSERT(p->pReadBuffer == 0);

        return(RPC_S_OK);
        }

    p->Abort();

    if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
        {
        // Wait for the read to complete.  Since the connection has
        // just been closed this won't take very long.
        UTIL_WaitForSyncIO(&p->Read.ol,
                           FALSE,
                           INFINITE);
        }

    return(status);
}

RPC_STATUS
RPC_ENTRY
CO_SyncRecv_Avrf(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Wrapper for CO_SyncRecv implementing corruption injection
    under the RPC verifier.

    SyncRecv member of the transport interface may only be called
    by the cliet, hence we inject the corruption for a client receive.

Arguments:

Return Value:

--*/
{
    RPC_STATUS Status;

    Status = CO_SyncRecv(
        ThisConnection,
        pBuffer,
        pBufferLength,
        dwTimeout);

    if (!Status)
        {
        if (gfRPCVerifierEnabled)
            {
            CorruptionInject(ClientReceive,
                             pBufferLength,
                             (void **)pBuffer);
            }
        }

    return Status;
}

void 
BASE_CONNECTION::Initialize (
    void
    )
/*++

Routine Description:

    Initializes a base connection. Prior initialization
    ensures orderly cleanup.

Arguments:

Return Value:

--*/
{
    type = CLIENT | CONNECTION;
    pReadBuffer = 0;
    Conn.Handle = 0;
    fAborted = FALSE;
    pReadBuffer = 0;
    maxReadBuffer = 0;
    iPostSize = gPostSize;
    iLastRead = 0;
    RpcpMemorySet(&Read.ol, 0, sizeof(Read.ol));
    Read.pAsyncObject = this;
    Read.thread       = 0;
    InitIoCounter();    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\dgtrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    dgtrans.cxx

Abstract:

    Common code for winsock-based datagram transports.

Author:

    Dave Steckler (davidst)   15-Mar-1993
    Jeff Roberts (jroberts)   02-Dec-1994
    Mario Goertzel (mariogo)  10-Apr-1996
    Michael Burton (t-mburt)  05-Sep-1997
    Charlie Wickham (charlwi) 01-Oct-1997

Revision History:

    Dave wrote a version.
    Connie changed it but forgot to add her name.
    Jeff made it work.
    Mario rewrote most of it for NT and io completion ports.

    MarioGo    12/10/1996  Changes for async support, added client
    t-mburt    09/05/1997  Added prelim support for clusters
    charlwi    10/01/1997  Finished cluster work

--*/
#include <precomp.hxx>
#include <trans.hxx>
#include <dgtrans.hxx>
#include <wswrap.hxx>

#ifdef NCADG_MQ_ON
#include "mqtrans.hxx"
#endif

//
// If a datagram send doesn't complete within 5 seconds, abort it.
//
#define DG_SEND_TIMEOUT (5000)

// Cluster SOCKADDR_CLUSTER initialization routine
inline void
CDP_InitLocalAddress(
    SOCKADDR_CLUSTER *Address,
    unsigned short Endpoint
    )
{
    Address->sac_family       = AF_CLUSTER;
    Address->sac_node         = CLUSADDR_ANY;
    Address->sac_port         = Endpoint;
    Address->sac_zero         = 0;
}

extern RPC_STATUS CDP_InitializeSockAddr(char *Endpoint, WS_SOCKADDR *, DG_TRANSPORT_ENDPOINT ThisEndpoint = NULL);
extern RPC_STATUS UDP_InitializeSockAddr(char *Endpoint, WS_SOCKADDR *, DG_TRANSPORT_ENDPOINT ThisEndpoint = NULL);

#ifdef IPX_ON
extern RPC_STATUS IPX_InitializeSockAddr(char *Endpoint, WS_SOCKADDR *);
#endif

const DG_TRANS_INFO DgTransportTable[] =
{
    // UDP
    {
    AF_INET,
    SOCK_DGRAM,
    IPPROTO_UDP,
    0x40000,
    0x10000,
    UDP_InitializeSockAddr
    },

#ifdef IPX_ON
    // IPX
    {
    AF_IPX,
    SOCK_DGRAM,
    NSPROTO_IPX,
    0x40000,
    0x10000,
    IPX_InitializeSockAddr
    },
#else
    // IPX
    {
    0,
    0,
    0,
    0,
    0,
    0
    },
#endif

    // CDP
    {
    AF_CLUSTER,
    SOCK_DGRAM,
    CLUSPROTO_CDP,
    0x40000,
    0x10000,
    CDP_InitializeSockAddr
    }

};

inline const DG_TRANS_INFO *GetDgTransportInfo(PROTOCOL_ID id)
{
#ifdef IPX_ON
    ASSERT(id == UDP || id == IPX || id == CDP);
#else
    ASSERT(id == UDP || id == CDP);
#endif

    return &DgTransportTable[id - UDP];
}

typedef const DG_TRANS_INFO *PDG_TRANS_INFO;

// may be TRUE only for rpcss. For all others it's FALSE
BOOL fWSARecvMsgFnPtrInitialized = FALSE;
const UUID WSARecvMsgFnPtrUuid = WSAID_WSARECVMSG;


////////////////////////////////////////////////////////////////////////
//
// Generic datagram (winsock and NT based) routines.
//

RPC_STATUS
DG_SubmitReceive(IN PWS_DATAGRAM_ENDPOINT pEndpoint,
                 IN PWS_DATAGRAM pDatagram)
/*++

Arguments:

    pEndpoint - The endpoint on which the receive should be posted.
    pDatagram - The datagram object to manage the receive.

Return Value:

    RPC_P_IO_PENDING - OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/

{
    RPC_STATUS status;
    NTSTATUS NtStatus;
    DWORD bytes, flags;
    int err;

    if (pDatagram->Packet.buf == 0)
        {
        status = I_RpcTransDatagramAllocate(pEndpoint,
                                            (BUFFER *)&pDatagram->Packet.buf,
                                            (PUINT)   &pDatagram->Packet.len,
                                            &pDatagram->AddressPair);

        if (status != RPC_S_OK)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        pDatagram->AddressPair->LocalAddress
            = WSA_CMSG_DATA(&pDatagram->MessageAncillaryData)
              + FIELD_OFFSET(in_pktinfo, ipi_addr);

        ASSERT( pDatagram->Packet.buf );
        }

    ASSERT(*(PDWORD)pDatagram->Packet.buf = 0xDEADF00D);
    bytes = flags = 0;

    if (!fWSARecvMsgFnPtrInitialized)
        {
        pDatagram->cRecvAddr = sizeof(WS_SOCKADDR);

        err = WSARecvFrom(((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket,
                              &pDatagram->Packet,
                              1,
                              &bytes,
                              &flags,
                              &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic,
                              &pDatagram->cRecvAddr,
                              &pDatagram->Read.ol,
                              0);
        }
    else
        {
        pDatagram->Msg.lpBuffers = &pDatagram->Packet;
        pDatagram->Msg.name = &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic;
        pDatagram->Msg.namelen = sizeof(WS_SOCKADDR);
        pDatagram->Msg.dwBufferCount = 1;
        pDatagram->Msg.Control.buf = (char *)pDatagram->MessageAncillaryData;
        pDatagram->Msg.Control.len = sizeof(pDatagram->MessageAncillaryData);
        pDatagram->Msg.dwFlags = 0;
        err = WSARecvMsg(((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket,
                              &pDatagram->Msg,
                              &bytes,
                              &pDatagram->Read.ol,
                              0);
        }
    #if 0
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "ERROR: RecvFrom: %p buf %p (%d bytes) status %d\n",
                   pDatagram,
                   pDatagram->Packet.buf,
                   pDatagram->Packet.len,
                   err == 0 ? 0 : GetLastError()));
    #endif

    if (err == NO_ERROR)
        {
        return(RPC_P_IO_PENDING);
        }

    status = GetLastError();
    if (   status == ERROR_IO_PENDING
        || status == WSAEMSGSIZE )
        {
        // WSAEMSGSIZE will be handled in complete.cxx.  This is like "NO_ERROR"
        return(RPC_P_IO_PENDING);
        }

    RpcpErrorAddRecord( EEInfoGCWinsock,
                        status,
                        EEInfoDLWinsockDatagramSubmitReceive10,
                        ((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket
                        );

    if (WSAECONNRESET == status)
        {
        return RPC_P_PORT_DOWN;
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "WSARecvFrom failed %p\n",
                   GetLastError()));

    return(RPC_S_OUT_OF_RESOURCES);
}


void
DG_SubmitReceives(
    BASE_ADDRESS *ThisEndpoint
    )
/*++

Routine Description:

    Helper function called when the pending IO count
    on an address is too low.

Arguments:

    ThisEndpoint - The address to submit IOs on.

Return Value:

    None

--*/
{
    PWS_DATAGRAM pDg;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;

    if (pEndpoint->Socket == 0)
        {
        //
        // The address is currently deactivated, don't submit more I/O
        //
        return;
        }

    do
        {
        BOOL fIoSubmitted;

        fIoSubmitted = FALSE;

        // Only one thread should be trying to submit IOs at a time.
        // This saves locking each DATAGRAM object.

        // Simple lock - but requires a loop. See the comment at the end
        // of the loop.

        if (pEndpoint->fSubmittingIos != 0)
            break;

        if (InterlockedIncrement(&pEndpoint->fSubmittingIos) != 1)
            break;

        // Submit new IOs on all the idle datagram objects

        for (int i = 0; i < pEndpoint->cMaximumIos; i++)
            {
            pDg = &pEndpoint->aDatagrams[i];

            if (pDg->Busy)
                {
                continue;
                }

            // Must be all set for the IO to complete before trying
            // to submit the IO.
            InterlockedIncrement(&pEndpoint->cPendingIos);
            pDg->Busy = TRUE;

            if (DG_SubmitReceive(pEndpoint, pDg) == RPC_P_IO_PENDING)
                {
                fIoSubmitted = TRUE;
                }
            else
                {
                pDg->Busy = FALSE;
                InterlockedDecrement(&pEndpoint->cPendingIos);
                break;
                }
            }

        // Release the "lock" on the endpoint object.
        //
        // Xeon processors have eratta G40:
        // Potential Loss of Data Coherency Duaring MP Data Ownership Transfer.
        // To work around it, it is necessary to use InterlockedExchange rather then an assignment
        // to force cache coherency.
        InterlockedExchange(&pEndpoint->fSubmittingIos, 0);

        if (!fIoSubmitted && pEndpoint->cPendingIos == 0)
            {
            // It appears that no IO is pending on the endpoint.
            COMMON_AddressManager(pEndpoint);
            return;
            }

        // Even if we submitted new IOs, they may all have completed
        // already.  Which means we may need to loop and submit more
        // IOs.  This is needed since the thread which completed the
        // last IO may have run into our lock and returned.
        }
    while (pEndpoint->cPendingIos == 0);

    return;
}

NETWORK_ADDRESS_VECTOR *
DG_GetNetworkAddressVector(
    IN RPC_TRANSPORT_ADDRESS pAddress
    )
{
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT) pAddress;
    ASSERT(pEndpoint->pAddressVector);
    return pEndpoint->pAddressVector;
}

RPC_STATUS RPC_ENTRY
DG_SendPacket(
    IN DG_TRANSPORT_ENDPOINT        ThisEndpoint,
    IN DG_TRANSPORT_ADDRESS         pAddress,
    IN BUFFER                       pHeader,
    IN unsigned                     cHeader,
    IN BUFFER                       pBody,
    IN unsigned                     cBody,
    IN BUFFER                       pTrailer,
    IN unsigned                     cTrailer
    )
/*++

Routine Description:

    Sends a packet to an address.

    The routine will send a packet built out of the three buffers supplied.
    All the buffers are optional, the actual packet sent will be built from
    all the buffers actually supplied.  In each call at least buffer should
    NOT be null.

Arguments:

    ThisEndpoint  - Endpoint to send from.
    pAddress      - Address to send to.

    pHeader       - First data buffer
    cHeader       - Size of the first data buffer or 0.

    pBody         - Second data buffer
    cBody         - Size of the second data buffer or 0.

    pTrailer      - Third data buffer.
    cTrailer      - Size of the first data buffer or 0.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_P_SEND_FAILED

--*/
{
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR* pSockAddr = (WS_SOCKADDR *)pAddress;
    WSABUF buffers[3];
    int cBuffers;
    HANDLE hIoEvent;

    DWORD Status = 0;

    if (pHeader)
        {
        CallTestHook( TH_X_DG_SEND, pHeader, &Status );
        }
    else
        {
        CallTestHook( TH_X_DG_SEND, pBody, &Status );
        }

    if (Status)
        {
        return Status;
        }

    hIoEvent = I_RpcTransGetThreadEvent();

    cBuffers = 0;
    if (cHeader)
        {
        buffers[cBuffers].len = cHeader;
        buffers[cBuffers].buf = (PCHAR) pHeader;
        cBuffers++;
        }
    if (cBody)
        {
        buffers[cBuffers].len = cBody;
        buffers[cBuffers].buf = (PCHAR) pBody;
        cBuffers++;
        }
    if (cTrailer)
        {
        buffers[cBuffers].len = cTrailer;
        buffers[cBuffers].buf = (PCHAR) pTrailer;
        cBuffers++;
        }
    ASSERT(cBuffers);

    // All RPC packets have version 4.
    //
    ASSERT( buffers[0].buf[0] == 4 );


    OVERLAPPED ol;
    ol.hEvent = (HANDLE)(ULONG_PTR(hIoEvent) | 1);
    DWORD bytes;

    if ( WSASendTo(pEndpoint->Socket,
                   buffers,
                   cBuffers,
                   &bytes,
                   0,
                   &pSockAddr->generic,
                   WsTransportTable[pEndpoint->id].SockAddrSize,
                   &ol,
                   0) != 0)
        {
        DWORD Status = GetLastError();

        RpcpErrorAddRecord( EEInfoGCWinsock,
                            Status,
                            EEInfoDLWinsockDatagramSend10,
                            PULONG(&pSockAddr->generic)[0],
                            PULONG(&pSockAddr->generic)[1]
                            );

        if (WSAENETUNREACH == Status)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "WSASendTo failed with net unreachable\n",
                            GetLastError()));

            return RPC_P_PORT_DOWN;
            }

        if (WSAEHOSTDOWN == Status)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "WSASendTo failed with host down\n",
                            GetLastError()));
            return RPC_P_HOST_DOWN;
            }

        if (Status != WSA_IO_PENDING)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "WSASendTo failed %d\n",
                            GetLastError()));

            return(RPC_P_SEND_FAILED);
            }

        if (WAIT_OBJECT_0 != WaitForSingleObject( hIoEvent, DG_SEND_TIMEOUT ))
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "Dg Send timed out\n"));

            //
            // Cancel the send and wait for it to complete.
            //
            CancelIo( (HANDLE)pEndpoint->Socket );

            GetOverlappedResult((HANDLE)pEndpoint->Socket,
                                     &ol,
                                     &bytes,
                                     TRUE);

            return(RPC_P_SEND_FAILED);
            }

        BOOL b = GetOverlappedResult((HANDLE)pEndpoint->Socket,
                                     &ol,
                                     &bytes,
                                     TRUE);

        if (!b)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "Dg Send wait failed %d\n",
                            GetLastError()));

            return(RPC_P_SEND_FAILED);
            }
        }

    ASSERT(bytes == cHeader + cBody + cTrailer);

    if (pEndpoint->cMinimumIos &&
        pEndpoint->cPendingIos <= pEndpoint->cMinimumIos)
        {
        // It's ok if this fails, this is just a performance optimization.
        // Right after a send there often "idle" time waiting for the response
        // so this is a good time to submit receives.

        DG_SubmitReceives(pEndpoint);
        }

    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
DG_ForwardPacket(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BUFFER                pHeader,
    IN unsigned              cHeader,
    IN BUFFER                pBody,
    IN unsigned              cBody,
    IN BUFFER                pTrailer,
    IN unsigned              cTrailer,
    IN CHAR *                pszPort
    )

/*++

Routine Description:

    Sends a packet to the server it was originally destined for (that
    is, the client had a dynamic endpoint it wished the enpoint mapper
    to resolve and forward the packet to).

Arguments:

    ThisEndpoint      - The endpoint to forward the packet from.

    // Buffer like DG_SendPacket

    pszPort           - Pointer to the server port num to forward to.
                        This is in an Ansi string.

Return Value:

    RPC_S_CANT_CREATE_ENDPOINT - pEndpoint invalid.

    results of SendPacket().

--*/

{
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR  SockAddr;
    PDG_TRANS_INFO pInfo = GetDgTransportInfo(pEndpoint->id);
    DG_TRANSPORT_ENDPOINT EndpointWithAddressToForwardTo;

    ASSERT(pEndpoint->type | SERVER);

    // If selective bindings are enabled, forward the packet to the
    // interface that the current endpoint is listening on
    // rather then to the loopback address.  Otherwise, forward to
    // the loopback address by default.
    if (pFirewallTable != NULL)
        EndpointWithAddressToForwardTo = ThisEndpoint;
    else
        EndpointWithAddressToForwardTo = NULL;

    if (pInfo->EndpointToAddr(pszPort, &SockAddr, EndpointWithAddressToForwardTo) != RPC_S_OK)
        {
        return RPC_S_CANT_CREATE_ENDPOINT;
        }

    return ( DG_SendPacket(ThisEndpoint,
                           (PVOID)&SockAddr,
                           pHeader,
                           cHeader,
                           pBody,
                           cBody,
                           pTrailer,
                           cTrailer) );
}

RPC_STATUS
RPC_ENTRY
DG_ReceivePacket(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_TRANSPORT_ADDRESS *pReplyAddress,
    OUT PUINT pBufferLength,
    OUT BUFFER *pBuffer,
    IN LONG Timeout
    )
/*++

Routine Description:

    Used to wait for a datagram from a server.  Returns the data
    returned and the address of the machine which replied.

    This is a blocking API. It should only be called during sync
    client RPC threads.

Arguments:

    Endpoint - The endpoint to receive from.
    ReplyAddress - Contain the source address of the datagram if
        successful.
    BufferLength - The size of Buffer on input, the size of the
        datagram received on output.
    Timeout - Milliseconds to wait for a datagram.

Return Value:

    RPC_S_OK

    RPC_P_OVERSIZE_PACKET - Datagram > BufferLength arrived,
        first BufferLength bytes of Buffer contain the partial datagram.

    RPC_P_RECEIVE_FAILED

    RPC_P_TIMEOUT
--*/
{
    RPC_STATUS status;
    BOOL b;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    PWS_DATAGRAM pDatagram = &pEndpoint->aDatagrams[0];
    DWORD bytes;
    DWORD flags;
    int err;

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->aDatagrams[0].Read.ol.hEvent);

    DWORD Status = 0;

    CallTestHook( TH_X_DG_SYNC_RECV, ThisEndpoint, &Status );

    if (Status)
        {
        return Status;
        }

    if (pDatagram->Busy == 0)
        {
        if (pEndpoint->aDatagrams[0].Packet.buf == 0)
            {
            status = I_RpcTransDatagramAllocate(pEndpoint,
                                                (BUFFER *)&pDatagram->Packet.buf,
                                                (PUINT)   &pDatagram->Packet.len,
                                                &pDatagram->AddressPair);

            if (status != RPC_S_OK)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }

            pDatagram->cRecvAddr = sizeof(WS_SOCKADDR);
            pDatagram->AddressPair->LocalAddress
                = WSA_CMSG_DATA(&pDatagram->MessageAncillaryData)
                  + FIELD_OFFSET(in_pktinfo, ipi_addr);

            ASSERT( pDatagram->Packet.buf );
            }

        bytes = flags = 0;

        if (!fWSARecvMsgFnPtrInitialized)
            {
            err = WSARecvFrom(pEndpoint->Socket,
                         &pDatagram->Packet,
                         1,
                         &bytes,
                         &flags,
                         &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic,
                         &pDatagram->cRecvAddr,
                         &pDatagram->Read.ol,
                         0);
            }
        else
            {
            pDatagram->Msg.lpBuffers = &pDatagram->Packet;
            pDatagram->Msg.name = &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic;
            pDatagram->Msg.namelen = sizeof(WS_SOCKADDR);
            pDatagram->Msg.dwBufferCount = 1;
            pDatagram->Msg.Control.buf = (char *)&pDatagram->MessageAncillaryData;
            pDatagram->Msg.Control.len = sizeof(pDatagram->MessageAncillaryData);
            pDatagram->Msg.dwFlags = 0;

            err = WSARecvMsg(((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket,
                                  &pDatagram->Msg,
                                  &bytes,
                                  &pDatagram->Read.ol,
                                  0);
            }

        if ( err != 0)
            {

            status = GetLastError();

            if (status != WSA_IO_PENDING)
                {
                RpcpErrorAddRecord( EEInfoGCWinsock,
                                    status,
                                    EEInfoDLWinsockDatagramReceive10,
                                    pEndpoint->Socket
                                    );

                if (status == WSAEMSGSIZE)
                    {
                    status = RPC_P_OVERSIZE_PACKET;
                    }
                else if (status == WSAECONNRESET)
                    {
                    return RPC_P_PORT_DOWN;
                    }
                else
                    {
                    // No need to free the packet now.
                    TransDbgDetail((DPFLTR_RPCPROXY_ID,
                                    DPFLTR_INFO_LEVEL,
                                    RPCTRANS "WSARecvFrom failed %d\n",
                                    status));

                    ASSERT(pDatagram->Busy == 0);
                    return(RPC_P_RECEIVE_FAILED);
                    }
                }
            else
                {
                status = RPC_P_IO_PENDING;
                }
            }
        else
            {
            status = RPC_S_OK;
            }

        pDatagram->Busy = TRUE;
        }
    else
        {
        ASSERT(pDatagram->Busy);
        ASSERT(pDatagram->Packet.buf);

        status = RPC_P_IO_PENDING;
        }

    // Wait for IO to complete or timeout

    if (status == RPC_P_IO_PENDING)
        {
        status = WaitForSingleObjectEx(pDatagram->Read.ol.hEvent,
                                       Timeout,
                                       TRUE);

        if (status != STATUS_WAIT_0)
            {
            // In the timeout case we just want to return and
            // leave.  We'll finish the receive on the next call.
            if (status == WAIT_IO_COMPLETION)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "DG received cancelled (%p)\n",
                               pDatagram));
                }
            else
                {
                ASSERT(status == STATUS_TIMEOUT);
                }

            ASSERT(pDatagram->Busy);

            return(RPC_P_TIMEOUT);
            }

        BOOL b = GetOverlappedResult((HANDLE)pEndpoint->Socket,
                                     &pDatagram->Read.ol,
                                     &bytes,
                                     FALSE);

        if (!b)
            {
            RpcpErrorAddRecord( EEInfoGCWinsock,
                                GetLastError(),
                                EEInfoDLWinsockDatagramSend20,
                                pEndpoint->Socket
                                );

            switch (GetLastError())
                {
                case WSAEMSGSIZE:
                case ERROR_MORE_DATA:
                    ASSERT(bytes == pDatagram->Packet.len);
                    status = RPC_P_OVERSIZE_PACKET;
                    break;

                case ERROR_PORT_UNREACHABLE:
                    pDatagram->Busy = 0;
                    return RPC_P_PORT_DOWN;
                    break;

                case STATUS_TIMEOUT:
                    ASSERT(0);

                case ERROR_OPERATION_ABORTED:
                    // ERROR_OPERATION_ABORTED can occur if one thread
                    // tried to make a call and failed, leaving a pending
                    // receive.  That thread dies.  Then the endpoint is
                    // reused by a different thread and the IO is aborted.
                    // Returning receive failed will cause the runtime to
                    // retransmit which will do the right thing.
                default:
                    TransDbgDetail((DPFLTR_RPCPROXY_ID,
                                    DPFLTR_INFO_LEVEL,
                                    RPCTRANS "DG sync recv failed %d\n",
                                    GetLastError()));

                    pDatagram->Busy = 0;
                    return(RPC_P_RECEIVE_FAILED);
                    break;
                }
            }
        else
            {
            status = RPC_S_OK;
            }
        }

    ASSERT(   status == RPC_S_OK
           || status == RPC_P_OVERSIZE_PACKET);

    ASSERT(pDatagram->Busy);
    ASSERT(pDatagram->Packet.buf);
    ASSERT(bytes <= pDatagram->Packet.len);

    *pBuffer = (BUFFER)pDatagram->Packet.buf;
    *pBufferLength = bytes;
    *pReplyAddress = pDatagram->AddressPair->RemoteAddress;

    pDatagram->Packet.buf = 0;
    pDatagram->Busy = 0;

    return(status);
}

RPC_STATUS
RPC_ENTRY
DG_ReceivePacket_Avrf(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_TRANSPORT_ADDRESS *pReplyAddress,
    OUT PUINT pBufferLength,
    OUT BUFFER *pBuffer,
    IN LONG Timeout
    )
/*++

Routine Description:

    Wrapper for DG_ReceivePacket implementing corruption injection
    under the RPC verifier.

    SyncRecv member of the transport interface may only be called
    by the cliet, hence we inject the corruption for a client receive.

Arguments:

Return Value:

--*/
{
    RPC_STATUS Status;

    Status = DG_ReceivePacket(
        ThisEndpoint,
        pReplyAddress,
        pBufferLength,
        pBuffer,
        Timeout
    );

    if (!Status)
        {
        if (gfRPCVerifierEnabled)
            {
            CorruptionInject(ClientReceive,
                             pBufferLength,
                             (void **)pBuffer);
            }
        }

    return Status;
}

RPC_STATUS
DG_CreateEndpoint(
    OUT WS_DATAGRAM_ENDPOINT *pEndpoint
    )
/*++

Routine Description:

    Creates a new endpoint.

Arguments:

    pEndpoint - The runtime allocated endpoint structure to
        filled in.

    pSockAddr - An initialized sockaddr with the correct
        (or no) endpoint.

    id - The id of the protocol to use in creating the address.

    fClient - If TRUE this is a client endpoint

    fAsync  - If TRUE this endpoint is "async" which means that
        a) It should be added to the IO completion port and
        b) that the transport should pend a number of receives
        on the endpoint automatically.

    EndpointFlags - used in allocation IP ports.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_DATAGRAM pDatagram;
    int i, err;
    int length;
    RPC_STATUS status = RPC_S_OK;
    SOCKET sock = 0;
    PDG_TRANS_INFO pInfo = GetDgTransportInfo(pEndpoint->id);
    BOOL fClient = pEndpoint->fClient;
    BOOL fAsync = pEndpoint->fAsync;
    LPFN_WSARECVMSG WSARecvMsgFnPtr;
    DWORD dwBytesReturned;

    // Common stuff

    pEndpoint->type = DATAGRAM | ADDRESS;
    pEndpoint->Socket = 0;
    pEndpoint->Endpoint = 0;
    pEndpoint->pAddressVector = 0;
    pEndpoint->SubmitListen = DG_SubmitReceives;
    pEndpoint->InAddressList = NotInList;
    pEndpoint->pNext = 0;
    pEndpoint->fSubmittingIos = 0;
    pEndpoint->cPendingIos = 0;
    pEndpoint->cMinimumIos = 0;
    pEndpoint->cMaximumIos = 0;
    pEndpoint->aDatagrams  = 0;
    pEndpoint->pFirstAddress = pEndpoint;
    pEndpoint->pNextAddress = 0;
    pEndpoint->fAborted = 0;

    if (fClient)
        {
        pEndpoint->type |= CLIENT;
        }
    else
        {
        pEndpoint->type |= SERVER;
        }

    //
    // Check if we can use a wrapper around the AFD send/recv
    // IOCTLs instead WSASendTo.
    //
    TryUsingAfd();

    //
    // Create the socket.
    //
    sock = WSASocketT(pInfo->AddressFamily,
                      pInfo->SocketType,
                      pInfo->Protocol,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);

    if (sock == INVALID_SOCKET)
        {
        RpcpErrorAddRecord( EEInfoGCWinsock,
                            GetLastError(),
                            EEInfoDLWinsockDatagramCreate10,
                            (ULONG) pInfo->AddressFamily,
                            (ULONG) pInfo->Protocol
                            );

        switch(GetLastError())
            {
            case WSAEAFNOSUPPORT:
            case WSAEPROTONOSUPPORT:
            case WSAENETDOWN:
            case WSAEINVAL:
            case WSAEPROTOTYPE:
            case WSAENOPROTOOPT:
            case WSAESOCKTNOSUPPORT:
            case WSAEPFNOSUPPORT:
            case WSAEADDRNOTAVAIL:
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            case WSAENOBUFS:
            case WSAEMFILE:
            case WSA_NOT_ENOUGH_MEMORY:
            // This failure is possible in low memory conditions
            // or due to fault injection during registry read or
            // notification creation.
            case WSASYSCALLFAILURE:
                status = RPC_S_OUT_OF_MEMORY;
                break;

            default:
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "DG socket() returned 0x%lx\n",
                               GetLastError()));

                ASSERT(0);
                // no break

            case WSAEPROVIDERFAILEDINIT:
                status = RPC_S_OUT_OF_RESOURCES;
                break;
            }

        return(status);
        }

    if (fWSARecvMsgFnPtrInitialized == FALSE)
        {
        // if the AddressChangeFn is non-default (i.e. we are in RPCSS),
        // use WSARecvMsg so that we can retrieve the local address as
        // well
        if (AddressChangeFn && (AddressChangeFn != NullAddressChangeFn))
            {
            // retrieve the WSARecvMsg function pointer
            err = WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, (void *) &WSARecvMsgFnPtrUuid,
                sizeof(UUID), (void *) &WSARecvMsgFnPtr, sizeof(void *), &dwBytesReturned,
                NULL, NULL);

            if (err == SOCKET_ERROR)
                {
                closesocket(sock);
                return RPC_S_PROTSEQ_NOT_SUPPORTED;
                }

            WFT.pWSARecvMsg = WSARecvMsgFnPtr;
            fWSARecvMsgFnPtrInitialized = TRUE;
            }
        }


    //
    // Make the handle non-inheritable so it goes away when we close it.
    //
    if (FALSE == SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0))
        {
        closesocket(sock);
        return RPC_S_OUT_OF_RESOURCES;
        }

    //
    // Protect the socket to prevent another server from using our port.
    //

    WS_ProtectListeningSocket(sock, TRUE);

    //
    // Bind the socket to the endpoint (or to a dynamic endpoint)
    //

    status = WS_Bind(sock,
                     &pEndpoint->ListenAddr,
                     (pEndpoint->id == UDP),
                     pEndpoint->EndpointFlags);

    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return(status);
        }

    pEndpoint->Socket = sock;

    //
    // Turn on ring buffering for server- and client-side async endpoints.
    // Any error is ignored.
    //
    if (fAsync || !fClient)
        {
        DWORD BytesReturned;
        if (0 != WSAIoctl( sock, SIO_ENABLE_CIRCULAR_QUEUEING, 0, 0, 0, 0, &BytesReturned, 0, 0 ))
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG couldn't enable circular queueing 0x%lx\n",
                           GetLastError()));
            }
        }

    if (!fClient)
        {
        //
        // Set server socket recv buffer size..
        //

        int size;
        int PacketInfoOn = TRUE;

        if (gfServerPlatform == TRUE && gPhysicalMemorySize >= 40)
            {
            size = pInfo->ServerBufferSize;
            }
        else
            {
            size = pInfo->WorkstationBufferSize;
            }

        if (fWSARecvMsgFnPtrInitialized)
            {
            err = setsockopt(sock,
                             IPPROTO_IP,
                             IP_PKTINFO,
                             (char *)&PacketInfoOn,
                             sizeof(PacketInfoOn)
                             );
            if (err != 0)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "DG couldn't set packet info %d\n",
                               GetLastError()));

                closesocket(sock);
                return(RPC_S_OUT_OF_MEMORY);
                }
            }

        err = setsockopt(sock,
                         SOL_SOCKET,
                         SO_RCVBUF,
                         (char *) &size,
                          sizeof(size)
                          );
        #if DBG
        if (err != 0)
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG couldn't set buffer size %d\n",
                           GetLastError()));
        #endif
        }
    else
        {
        // Enable broadcast send on the client

        DWORD option = TRUE;

        err = setsockopt(sock,
                         SOL_SOCKET,
                         SO_BROADCAST,
                         (PCHAR)&option,
                         sizeof(option));

        ASSERT(err == 0);
        }

    //
    // If the endpoint is going to async initialize async part
    // and add the socket to the IO completion port.
    //

    if (status == RPC_S_OK)
        {
        int cMaxIos;
        int cMinIos;

        ASSERT(fAsync || fClient);

        // Step one, figure out the high and low mark for ios.

        if (fAsync)
            {
            cMinIos = 1;
            cMaxIos = 2;

            if (gPhysicalMemorySize >= 40)    // megabytes
                {
                cMaxIos = 2
                          + (gfServerPlatform == TRUE) * 2
                          + (fClient == FALSE) * gNumberOfProcessors;

                // This should be larger than zero so that we'll generally submit new
                // recvs during idle time rather then just after receiving a datagram.
                cMinIos = 1 + (fClient == FALSE ) * (gNumberOfProcessors/2);
                }
            }
        else
            {
            // For sync endpoints we need to allocate a single datagram
            // object for the receive.
            cMinIos = 0;
            cMaxIos = 1;
            }

        ASSERT(cMinIos < cMaxIos);

        pEndpoint->cMinimumIos = cMinIos;
        pEndpoint->cMaximumIos = cMaxIos;

        // Allocate a chunk on memory to hold the array of datagrams

        // PERF: For clients, allocate larger array but don't submit all
        // the IOs unless we determine that the port is "really" active.

        pEndpoint->aDatagrams = new WS_DATAGRAM[cMaxIos];

        if (pEndpoint->aDatagrams)
            {
            UINT type;
            type = DATAGRAM | RECEIVE;
            type |= (fClient) ? CLIENT : SERVER;

            for (i = 0; i < cMaxIos; i++)
                {
                pDatagram = &pEndpoint->aDatagrams[i];

                pDatagram->id = pEndpoint->id;
                pDatagram->type = type;
                pDatagram->pEndpoint = pEndpoint;
                pDatagram->Busy = 0;
                pDatagram->Packet.buf = 0;
                memset(&pDatagram->Read, 0, sizeof(pDatagram->Read));
                pDatagram->Read.pAsyncObject = pDatagram;
                }

            if (fAsync)
                {
                status = COMMON_PrepareNewHandle((HANDLE)sock);
                }
            else
                {
                // The receive operation on sync endpoints will may span
                // several receives.  This means it can't use the thread
                // event, so allocate an event for the receive.
                HANDLE hEvent = CreateEventW(0, TRUE, FALSE, 0);
                if (!hEvent)
                    {
                    status = RPC_S_OUT_OF_RESOURCES;
                    }
                else
                    {
                    ASSERT(pDatagram == &pEndpoint->aDatagrams[0]);
                    pDatagram->Read.ol.hEvent = hEvent;
                    }
                }
            }
        else
            {
            status = RPC_S_OUT_OF_MEMORY;
            }
        }

    // If adding a new failure case here, add code to close the sync receive event.

    if (status != RPC_S_OK)
        {
        closesocket(sock);

        delete pEndpoint->aDatagrams;

        return(status);
        }

    TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) pEndpoint);

    if (!fClient)
        {
        TransportProtocol::FunctionalProtocolDetected(pEndpoint->id);
        }

    return(RPC_S_OK);
}


VOID
DG_DeactivateAddress (
    IN WS_DATAGRAM_ENDPOINT *pEndpoint
    )
/*++
Function Name:DG_DeactivateAddress

Parameters:

Description:

Returns:

--*/
{
    if (InterlockedIncrement(&pEndpoint->fAborted) != 1)
        {
        return;
        }

    if (pEndpoint->Socket)
        {
        closesocket(pEndpoint->Socket);
        pEndpoint->Socket = 0;
        }
}


RPC_STATUS
DG_ReactivateAddress (
    IN WS_DATAGRAM_ENDPOINT *pEndpoint
    )
/*++
Function Name:DG_DeactivateAddress

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    //
    // If the endpoint is dynamic, clear out the endpoint
    //
    if (pEndpoint->fDynamicEndpoint)
        {
        //
        // Clear out the listenaddr
        //
        switch (pEndpoint->id)
            {
#ifdef IPX_ON
            case IPX:
                addr->ipxaddr.sa_socket = 0;
                break;
#endif

            case CDP:
                CDP_InitLocalAddress(&addr->clusaddr, 0);
                break;

            case UDP:
                addr->inetaddr.sin_port = 0;
                break;

            default:
                ASSERT(0);
            }
        }

    Status = DG_CreateEndpoint(pEndpoint);
    if (Status == RPC_S_OK)
        {
        pEndpoint->fAborted = 0;
        DG_SubmitReceives(pEndpoint);
        }

    return Status;
}


void RPC_ENTRY
DG_ServerAbortListen(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Callback after DG_CreateEndpoint has completed successfully
    but the runtime for some reason is not going to be able to
    listen on the endpoint.

--*/
{
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;

    ASSERT(pEndpoint->cPendingIos == 0);
    ASSERT(pEndpoint->Socket);
    ASSERT(pEndpoint->pNext == 0);
    ASSERT(pEndpoint->type & SERVER);

    delete pEndpoint->pAddressVector;
    delete pEndpoint->aDatagrams;
    closesocket(pEndpoint->Socket);

    return;
}

RPC_STATUS RPC_ENTRY
DG_ClientCloseEndpoint(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Called on sync client endpoints when they are no longer needed.

Arguments:

    ThisEndpoint

Return Value:

    RPC_S_OK

--*/
{
    BOOL b;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    PWS_DATAGRAM pDatagram = &pEndpoint->aDatagrams[0];

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->Socket);  // Open must have worked
    ASSERT(pEndpoint->cMinimumIos == 0);
    ASSERT(pEndpoint->cMaximumIos == 1); // Must not be async!
    ASSERT(pEndpoint->aDatagrams);
    ASSERT(pEndpoint->aDatagrams[0].Read.ol.hEvent);
    ASSERT(pEndpoint->Endpoint == 0);
    ASSERT(pEndpoint->pAddressVector == 0);
    ASSERT(pEndpoint->pNext == 0);

    // If there is a pending receive, closing the socket will cancel the IO.
    closesocket(pEndpoint->Socket);

    // Wait for the pending receive to actually complete.

    if (pDatagram->Busy)
        {
        DWORD bytes;
        ASSERT(pDatagram->Busy);
        ASSERT(pDatagram->Packet.buf);

        GetOverlappedResult((HANDLE)pEndpoint->Socket,
                            &pDatagram->Read.ol,
                            &bytes,
                            TRUE);

        if (GetLastError() != ERROR_OPERATION_ABORTED)
            {
            // Overactive output, the receive may have completed normally..
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG receive completed %d on %p after closed\n",
                           GetLastError(),
                           pDatagram));
            }
        }

    b = CloseHandle(pEndpoint->aDatagrams[0].Read.ol.hEvent);
    ASSERT(b);

    TransportProtocol::RemoveObjectFromProtocolList(pEndpoint);

    // Free the receive buffer if allocated

    if (pDatagram->Packet.buf)
        {
        I_RpcTransDatagramFree(pEndpoint,
                               (BUFFER)pDatagram->Packet.buf
                               );
        }

    delete pDatagram;

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
DG_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    DWORD Status;
    DWORD Data;
    int   Length;
    BOOL  Ok;

    PWS_DATAGRAM_ENDPOINT Endpoint = (PWS_DATAGRAM_ENDPOINT) ThisEndpoint;

    Length = sizeof(DWORD);

    Status = getsockopt(Endpoint->Socket, SOL_SOCKET, SO_MAX_MSG_SIZE, (char *) &Data, &Length);
    if (Status)
        {
        return GetLastError();
        }

    //
    // jroberts, 10-Jan-2001 : I believe that getsockopt is returning 0xffffffff occasionally.
    // This is an attempt to catch it.
    //
    if (Endpoint->id == UDP)
        {
        ASSERT( Data < 0x10000 );
        }

    Data &= ~7UL;

    pStats->MaxPduSize = Data;

    Length = sizeof(DWORD);

    Status = getsockopt(Endpoint->Socket, SOL_SOCKET, SO_RCVBUF, (char *) &Data, &Length);
    if (Status)
        {
        return GetLastError();
        }

    Data &= ~7UL;
    pStats->ReceiveBufferSize = Data;

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////
//
// CDP/IP specific functions.
//

RPC_STATUS RPC_ENTRY
CDP_ServerListen(
    IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
    IN RPC_CHAR      *NetworkAddress,
    IN OUT RPC_CHAR **pPort,
    IN     void      *pSecurityDescriptor,
    IN     ULONG      EndpointFlags,
    IN     ULONG      NICFlags
    )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    pPort - The endpoint to listen on or a pointer to 0 if
        the transport should choose the address.
        Contains the endpoint listened to on output.  The
        caller should free this.
    pSecurityDiscriptor - Security to attach to this endpoint (not
        used by this transport).
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS      status;
    NTSTATUS        NtStatus;
    USHORT          port;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AsciiString;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;
    NETWORK_ADDRESS_VECTOR * ServerAddress;

    // Figure out the port to listen on.

    if (*pPort)
        {
        status = EndpointToPortNumber(*pPort, port);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        pEndpoint->fDynamicEndpoint = 0;

        CDP_InitLocalAddress( &addr->clusaddr, port );
        }
    else
        {
        return RPC_S_INVALID_ENDPOINT_FORMAT;
        }

    pEndpoint->id = CDP;
    pEndpoint->fClient = FALSE;
    pEndpoint->fAsync = TRUE;
    pEndpoint->EndpointFlags = 0;

    //
    // Actually create the endpoint
    //
    status = DG_CreateEndpoint(pEndpoint);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    // Figure out the network addresses.
    // The only way we can determine our cluster
    // address is to read it out of the registry

    status = CDP_BuildAddressVector(&pEndpoint->pAddressVector);

    if (status != RPC_S_OK)
        {
        DG_ServerAbortListen(ThisEndpoint);
        return(status);
        }

    return RPC_S_OK;
}

RPC_STATUS
CDP_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    WS_SOCKADDR * pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    unsigned NativeSocket = pSockAddr->clusaddr.sac_port;
    char AnsiBuffer[CDP_MAXIMUM_ENDPOINT];

    char * pAnsi = AnsiBuffer;
    RPC_CHAR * pUni = pClientEndpoint;

    //
    // Convert endpoint to an ASCII string, and thence to Unicode.
    //
    _ultoa(NativeSocket, AnsiBuffer, 10);

    while ( *pUni++ = *pAnsi++ );

    return RPC_S_OK;
}


RPC_STATUS
CDP_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientAddress
    )
{
    PSOCKADDR_CLUSTER pSockAddr = (PSOCKADDR_CLUSTER) pOriginalEndpoint;

    _ultow(pSockAddr->sac_node, pClientAddress, 10);

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
CDP_ClientInitializeAddress
    (
     OUT DG_TRANSPORT_ADDRESS Address,
     IN RPC_CHAR *NetworkAddress,
     IN RPC_CHAR *pPort,
     IN BOOL fUseCache,
     IN BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    Address - Storage for the address
    NetworkAddress - The address of the server or 0 if local
    Endpoint - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    WS_SOCKADDR *pAddr = (WS_SOCKADDR *)Address;
    ULONG HostAddr;
    ULONG Endpoint;
    int i;
    USHORT port;
    RPC_STATUS status;


    // Figure out the destination port

    status = EndpointToPortNumber(pPort, port);

    if (RPC_S_OK != status)
        {
        ASSERT( 0 );
        return(status);
        }

    CDP_InitLocalAddress( &pAddr->clusaddr, port );

    // Resolve the network address - CDP addresses are
    // numbers representing a member ID in the cluster.

    pAddr->clusaddr.sac_node = _wtol( NetworkAddress );

    return(status);
}

RPC_STATUS
RPC_ENTRY
CDP_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD Flags,
    IN DG_TRANSPORT_ENDPOINT ServerEndpoint OPTIONAL
    )
{
    RPC_STATUS Status;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;


    // We don't care what port we bind to, we also don't care what
    // port we bind to.
    // I think he's trying to say that we don't care what port
    // we bind to.

    CDP_InitLocalAddress(&pEndpoint->ListenAddr.clusaddr, 0);

    pEndpoint->id = CDP;
    pEndpoint->fClient = TRUE;
    pEndpoint->fAsync = fAsync;
    pEndpoint->EndpointFlags = 0;
    pEndpoint->fDynamicEndpoint = 1;

    Status = DG_CreateEndpoint(pEndpoint);

    return Status;
}


RPC_STATUS
CDP_InitializeSockAddr(
    IN char *Endpoint,
    OUT WS_SOCKADDR *pSockAddr,
    DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Initialized the sockaddr to be a loopback address to the
    endpoint specified.  Used to forward packets locally.

Arguments:

    Endpoint - The string value of the servers endpoint.

    pSockAddr - The sockaddr to fill in.

Return Value:

    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_OK

--*/
{
    long port;

    port = atol(Endpoint);

    if (port <= 0 || port > 0xFFFF)
        {
        ASSERT( 0 );
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    CDP_InitLocalAddress(&pSockAddr->clusaddr, (unsigned short) port);

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
CDP_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    RPC_STATUS Status;

    Status = DG_GetEndpointStats(ThisEndpoint, pStats);
    if (Status)
        {
        pStats->MaxPduSize       = 1452;
        pStats->MaxPacketSize    = 1452;
        pStats->PreferredPduSize = 1452;

        pStats->ReceiveBufferSize= 8192;
        return Status;
        }

    //
    // ethernet frame (1500) - UDP/IP headers (28) - CNP/CDP headers (20)
    //

    pStats->MaxPacketSize    = 1452;
    pStats->PreferredPduSize = 4096;
    if (pStats->PreferredPduSize > pStats->MaxPduSize)
        {
        pStats->PreferredPduSize = pStats->MaxPduSize;
        }

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////
//
// UDP/IP specific functions.
//
RPC_STATUS RPC_ENTRY
UDP_ServerListen(
    IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
    IN RPC_CHAR      *NetworkAddress,
    IN OUT RPC_CHAR **pPort,
    IN     void      *pSecurityDescriptor,
    IN     ULONG      EndpointFlags,
    IN     ULONG      NICFlags
    )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    pPort - The endpoint to listen on or a pointer to 0 if
        the transport should choose the address.
        Contains the endpoint listened to on output.  The
        caller should free this.
    pSecurityDiscriptor - Security to attach to this endpoint (not
        used by UDP).
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS      status;
    NTSTATUS        NtStatus;
    USHORT          port;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AsciiString;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    addr->inetaddr.sin_family = AF_INET;

    if (NetworkAddress)
        {
        IP_ADDRESS_RESOLVER resolver(NetworkAddress,
            cosServer,
            ipvtuIPv4       // IP version to use
            );

        // Loop until success, fatal failure or we run out of addresses.

        status = resolver.NextAddress(&addr->inetaddr);
        if (status != RPC_S_OK)
            {
            return RPC_S_INVALID_NET_ADDR;
            }
        }
    else
        {
        addr->inetaddr.sin_addr.s_addr = INADDR_ANY;
        }
    
    // Figure out the port to listen on.

    if (*pPort)
        {
        status = EndpointToPortNumber(*pPort, port);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        pEndpoint->fDynamicEndpoint = 0;
        addr->inetaddr.sin_port = htons(port);
        }
    else
        {
        addr->inetaddr.sin_port = 0;
        pEndpoint->fDynamicEndpoint = 1;
        }

    pEndpoint->id = UDP;
    pEndpoint->fClient = FALSE;
    pEndpoint->fAsync = TRUE;
    pEndpoint->EndpointFlags = EndpointFlags;

    //
    // Actually create the endpoint
    //
    status = DG_CreateEndpoint(pEndpoint);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    // If needed, return the endpoint.

    if (!*pPort)
        {
        *pPort = new RPC_CHAR[IP_MAXIMUM_ENDPOINT];
        if (!*pPort)
            {
            DG_ServerAbortListen(ThisEndpoint);
            return(RPC_S_OUT_OF_MEMORY);
            }

        port = ntohs(addr->inetaddr.sin_port);

        PortNumberToEndpoint(port, *pPort);
        }

    // Figure out the network addresses
    ASSERT(pEndpoint->pAddressVector == NULL);
    status = IP_BuildAddressVector(&pEndpoint->pAddressVector,
                                   NICFlags,
                                   NetworkAddress,
                                   NULL);

    if (status != RPC_S_OK)
        {
        DG_ServerAbortListen(ThisEndpoint);
        return(status);
        }

    return RPC_S_OK;
}

RPC_STATUS
UDP_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    WS_SOCKADDR * pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    unsigned NativeSocket = ntohs(pSockAddr->inetaddr.sin_port);
    char AnsiBuffer[IP_MAXIMUM_ENDPOINT];

    char * pAnsi = AnsiBuffer;
    RPC_CHAR * pUni = pClientEndpoint;

    //
    // Convert endpoint to an ASCII string, and thence to Unicode.
    //
    _ultoa(NativeSocket, AnsiBuffer, 10);

    while ( *pUni++ = *pAnsi++ );

    return RPC_S_OK;
}

RPC_STATUS
UDP_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientAddress
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AsciiString;
    WS_SOCKADDR *pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    NTSTATUS NtStatus;

    UnicodeString.Buffer = pClientAddress;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = IP_MAXIMUM_RAW_NAME * sizeof(RPC_CHAR);

    char *t = inet_ntoa(pSockAddr->inetaddr.sin_addr);
    ASSERT(t);

    RtlInitAnsiString(&AsciiString, t);
    ASSERT(AsciiString.Length < IP_MAXIMUM_RAW_NAME);

    NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString,
                                            &AsciiString,
                                            FALSE);

    if (!NT_SUCCESS(NtStatus))
        {
        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
UDP_ClientInitializeAddress
    (
     OUT DG_TRANSPORT_ADDRESS Address,
     IN RPC_CHAR *NetworkAddress,
     IN RPC_CHAR *pPort,
     IN BOOL fUseCache,
     IN BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    Address - Storage for the address
    NetworkAddress - The address of the server or 0 if local
    Endpoint - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    WS_SOCKADDR *pAddr = (WS_SOCKADDR *)Address;
    ULONG HostAddr;
    ULONG Endpoint;
    int i;
    USHORT port;
    RPC_STATUS status;

    // Contant part of address
    memset(pAddr->inetaddr.sin_zero, 0, 8);

    pAddr->inetaddr.sin_family = AF_INET;

    // Figure out the destination port

    status = EndpointToPortNumber(pPort, port);

    if (RPC_S_OK != status)
        {
        return(status);
        }

    pAddr->inetaddr.sin_port = htons(port);

    // Resolve the network address

    if (fBroadcast)
        {
        pAddr->inetaddr.sin_addr.s_addr = INADDR_BROADCAST;
        return(RPC_S_OK);
        }

    // Multiple server address support for UDP/IP is not available.

    IP_ADDRESS_RESOLVER resolver(NetworkAddress,
        cosClient,
        ipvtuIPv4       // IP version to use
        );

    status = resolver.NextAddress(&pAddr->inetaddr);

    if (status)
        {
        RpcpErrorAddRecord( EEInfoGCWinsock,
                            status,
                            EEInfoDLWinsockDatagramResolve10,
                            NetworkAddress
                            );
        }

    return(status);
}

RPC_STATUS
RPC_ENTRY
UDP_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD EndpointFlags,
    IN DG_TRANSPORT_ENDPOINT ServerEndpoint OPTIONAL
    )
{

    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR *addr = &pEndpoint->ListenAddr;

    //
    // We don't care what port we bind to.
    // Ordinarily, we don't care what interface we bind to.  When using selective
    // bindings and making a callback, we should bind to the same IP address that
    // was the original target of the call.  This will come from the server endpoint.
    //

    memset(addr, 0, sizeof(*addr));

    // ServerEndpoint is provided only when processing a callback with selective bindings.
    if (ServerEndpoint != NULL)
        {
        memcpy(&(addr->inetaddr.sin_addr), &(((PWS_DATAGRAM_ENDPOINT)ServerEndpoint)->ListenAddr.inetaddr.sin_addr), sizeof(addr->inetaddr.sin_addr));
        }

    addr->inetaddr.sin_family = AF_INET;
    pEndpoint->id = UDP;
    pEndpoint->fClient = TRUE;
    pEndpoint->fAsync = fAsync;
    pEndpoint->EndpointFlags = EndpointFlags;
    pEndpoint->fDynamicEndpoint = 1;

    return(DG_CreateEndpoint(pEndpoint));
}


RPC_STATUS
UDP_InitializeSockAddr(
    IN char *Endpoint,
    OUT WS_SOCKADDR *pSockAddr,
    DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Initialized the sockaddr to be a loopback address to the
    endpoint specified or the address from ThisEndpoint to the
    endpoint specified.  Used to forward packets locally.

    ThisEndpoint will be provided when running with selective bindings
    to make sure that the packet is forwarded to the same interface
    on which the endpoint mapper received it, to ensure that the reply
    can reach the client.

Arguments:

    Endpoint - The string value of the servers endpoint.

    pSockAddr - The sockaddr to fill in.

Return Value:

    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_OK

--*/
{
    int len;
    long port;

    pSockAddr->generic.sa_family = AF_INET;
    if (ThisEndpoint == NULL)
        {
        pSockAddr->inetaddr.sin_addr.s_addr = 0x0100007F;  // byte swapped, 127.0.0.1
        }
    else
        {
        memcpy(&(pSockAddr->inetaddr.sin_addr.s_addr), &(((WS_DATAGRAM_ENDPOINT *)ThisEndpoint)->ListenAddr.inetaddr.sin_addr), sizeof(in_addr));
        }

    port = atol(Endpoint);

    if (port <= 0 || port > 0xFFFF)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    pSockAddr->inetaddr.sin_port = htons((USHORT) port);

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
UDP_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    RPC_STATUS Status;

    Status = DG_GetEndpointStats(ThisEndpoint, pStats);
    if (Status)
        {
        pStats->MaxPduSize       = 1472;
        pStats->MaxPacketSize    = 1472;
        pStats->PreferredPduSize = 1472;

        pStats->ReceiveBufferSize= 8192;
        return Status;
        }

    pStats->MaxPacketSize    = 1472;
    pStats->PreferredPduSize = 4096;
    if (pStats->PreferredPduSize > pStats->MaxPduSize)
        {
        pStats->PreferredPduSize = pStats->MaxPduSize;
        }

    return RPC_S_OK;
}


#ifdef IPX_ON

////////////////////////////////////////////////////////////////////////
//
// IPX specific functions.
//

RPC_STATUS RPC_ENTRY
IPX_ServerListen(
   IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
   IN RPC_CHAR      *NetworkAddress,
   IN OUT RPC_CHAR **pPort,
   IN     void      *pSecurityDescriptor,
   IN     ULONG      EndpointFlags,
   IN     ULONG      NICFlags
   )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    pPort - The endpoint to listen on or a pointer to 0 if
        the transport should choose the address.
        Contains the endpoint listened to on output.  The
        caller should free this.
    pSecurityDiscriptor - Security to attach to this endpoint (not
        used by the IPX transport).
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS      status;
    NTSTATUS        NtStatus;
    USHORT          port;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AsciiString;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    //
    // Figure out what port to listen on.
    //
    if (*pPort)
        {
        status = EndpointToPortNumber(*pPort, port);

        if (status != RPC_S_OK)
            {
            return(status);
            }
        pEndpoint->fDynamicEndpoint = 0;
        }
    else
        {
        port = 0;
        pEndpoint->fDynamicEndpoint = 1;
        }


    addr->generic.sa_family = AF_IPX;
    addr->ipxaddr.sa_socket = htons(port);

    pEndpoint->id = IPX;
    pEndpoint->fClient = FALSE;
    pEndpoint->fAsync = TRUE;
    pEndpoint->EndpointFlags = 0;

    //
    // Actually create the endpoint
    //
    status =
    DG_CreateEndpoint(pEndpoint);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    // If needed, figure out the dynamically allocated endpoint.

    if (!*pPort)
        {
        *pPort = new RPC_CHAR[IP_MAXIMUM_ENDPOINT];
        if (!*pPort)
            {
            DG_ServerAbortListen(ThisEndpoint);
            return(RPC_S_OUT_OF_MEMORY);
            }

        port = ntohs(addr->ipxaddr.sa_socket);

        PortNumberToEndpoint(port, *pPort);
        }

    // Update the local address cache
    //
    // Since there is only one addess no lock is required.
    //
    memcpy(IpxAddr.sa_netnum, addr->ipxaddr.sa_netnum, sizeof(IpxAddr.sa_netnum));
    memcpy(IpxAddr.sa_nodenum, addr->ipxaddr.sa_nodenum, sizeof(IpxAddr.sa_nodenum));
    fIpxAddrValid = TRUE;

    //
    // Figure out our server's raw IPX address.
    //

    status = IPX_BuildAddressVector(&(pEndpoint->pAddressVector));
    if (status != RPC_S_OK)
        {
        DG_ServerAbortListen(ThisEndpoint);
        delete *pPort;
        return(status);
        }

    return RPC_S_OK;
}


RPC_STATUS
IPX_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    WS_SOCKADDR * pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    unsigned NativeSocket = ntohs(pSockAddr->ipxaddr.sa_socket);
    char AnsiBuffer[IPX_MAXIMUM_ENDPOINT];

    char * pAnsi = AnsiBuffer;
    RPC_CHAR * pUni = pClientEndpoint;

    //
    // Convert endpoint to an ASCII string, and thence to Unicode.
    //
    _ultoa(NativeSocket, AnsiBuffer, 10);

    while ( *pUni++ = *pAnsi++ );

    return RPC_S_OK;
}

RPC_STATUS
IPX_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pString
    )
{
    WS_SOCKADDR *pSockAddr = (WS_SOCKADDR *) pOriginalEndpoint;

    IPX_AddressToName(&pSockAddr->ipxaddr, pString);

    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
IPX_ClientInitializeAddress
    (
     OUT DG_TRANSPORT_ADDRESS Address,
     IN RPC_CHAR *NetworkAddress,
     IN RPC_CHAR *pPort,
     IN BOOL fUseCache,
     IN BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    Address - Storage for the address
    NetworkAddress - The address of the server or 0 if local
    pPort - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    WS_SOCKADDR *pAddr = (WS_SOCKADDR *)Address;
    RPC_STATUS status = RPC_S_OK;
    USHORT port = 0;

    pAddr->ipxaddr.sa_family = AF_IPX;
    pAddr->ipxaddr.sa_socket = 0;

    // Convert unicode endpoint to port number

    status = EndpointToPortNumber(pPort, port);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    //
    // Convert unicode network address to ipx address
    //

    if (FALSE == fBroadcast)
        {
        status = IPX_NameToAddress(NetworkAddress,
                                   fUseCache,
                                   &pAddr->ipxaddr
                                   );

        }
    else
        {
        memset(pAddr->ipxaddr.sa_netnum, 0, sizeof(pAddr->ipxaddr.sa_netnum));
        memset(pAddr->ipxaddr.sa_nodenum, 0xFF, sizeof(pAddr->ipxaddr.sa_nodenum));
        }

    pAddr->ipxaddr.sa_socket = htons(port);

    return(status);
}


RPC_STATUS
RPC_ENTRY
IPX_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD Flags
    )
{
    RPC_STATUS status;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    // We don't care what port we bind to, we also don't care what
    // port we bind to.

    memset(addr, 0, sizeof(*addr));

    addr->ipxaddr.sa_family = AF_IPX;

    pEndpoint->id = IPX;
    pEndpoint->fClient = TRUE ;
    pEndpoint->fAsync = fAsync;
    pEndpoint->EndpointFlags = 0;
    pEndpoint->fDynamicEndpoint = 1;

    status = DG_CreateEndpoint(pEndpoint);

    if (status == RPC_S_OK)
        {
        // Update cache
        memcpy(IpxAddr.sa_netnum, addr->ipxaddr.sa_netnum, sizeof(IpxAddr.sa_netnum));
        memcpy(IpxAddr.sa_nodenum, addr->ipxaddr.sa_nodenum, sizeof(IpxAddr.sa_nodenum));
        fIpxAddrValid = TRUE;
        }

    return(status);
}


RPC_STATUS
IPX_InitializeSockAddr(
    IN char *Endpoint,
    OUT WS_SOCKADDR *pSockAddr
    )
/*++

Routine Description:

    Initialized the sockaddr to be a loopback address to the
    endpoint specified.  Used to forward packets locally.

Arguments:

    Endpoint - The string value of the servers endpoint.

    pSockAddr - The sockaddr to fill in.

Return Value:

    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_OK

--*/
{
    int len;
    long port;

    pSockAddr->generic.sa_family = AF_IPX;

    port = atol(Endpoint);
    if (port <= 0 || port > 0xFFFF)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }
    pSockAddr->ipxaddr.sa_socket = htons((USHORT)port);

    //
    // In order to get this far this server must have
    // alrady listened to IPX.
    //
    ASSERT(fIpxAddrValid);
    memcpy(pSockAddr->ipxaddr.sa_netnum, IpxAddr.sa_netnum, sizeof(pSockAddr->ipxaddr.sa_netnum));
    memcpy(pSockAddr->ipxaddr.sa_nodenum, IpxAddr.sa_nodenum, sizeof(pSockAddr->ipxaddr.sa_nodenum));

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
IPX_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    RPC_STATUS Status;

    Status = DG_GetEndpointStats(ThisEndpoint, pStats);
    if (Status)
        {
        pStats->MaxPduSize       = 1478;
        pStats->MaxPacketSize    = 1478;
        pStats->PreferredPduSize = 1478;

        pStats->ReceiveBufferSize= 8192;
        return Status;
        }

    pStats->MaxPacketSize    = 1478;
    pStats->PreferredPduSize = pStats->MaxPduSize;
    pStats->MaxPacketSize    = pStats->MaxPduSize;

    return RPC_S_OK;
}
#endif

////////////////////////////////////////////////////////////////////////
//
// Transport interface structures and loader
//

const RPC_DATAGRAM_TRANSPORT
UDP_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    UDP_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_ip_udp"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    DG_GetNetworkAddressVector,
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_SOCKADDR),
    IP_MAXIMUM_ENDPOINT,
    IP_MAXIMUM_PRETTY_NAME,
    1024,
    1472,
    DG_SendPacket,
    UDP_ClientOpenEndpoint,
    UDP_ClientInitializeAddress,
    DG_ClientCloseEndpoint,
    DG_ReceivePacket,
    UDP_ServerListen,
    DG_ServerAbortListen,
    COMMON_ServerCompleteListen,
    DG_ForwardPacket,
    UDP_QueryAddress,
    UDP_QueryEndpoint,
    UDP_GetEndpointStats,

    FALSE,              // fIsMessageTransport (TRUE/FALSE).

    0,                  // OptionSize
    0,                  // InitOptions()
    0,                  // SetOption()
    0,                  // InqOption()
    0,                  // ImplementOptions()
    0,                  // AllowReceives()
    0                   // InquireAuthClient()
};

// When the RPC verifier is enabled and we are corrupting client receives,
// we will use a modified transport interface given below.  It will have the sync
// receive members overwritten.
RPC_DATAGRAM_TRANSPORT *pUDP_TransportInterface_Avrf = NULL;

const RPC_DATAGRAM_TRANSPORT
CDP_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    CDP_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_cluster"),
    NULL,
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    DG_GetNetworkAddressVector,
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_SOCKADDR),
    IP_MAXIMUM_ENDPOINT,
    IP_MAXIMUM_PRETTY_NAME,
    1024,
    1452,
    DG_SendPacket,
    CDP_ClientOpenEndpoint,
    CDP_ClientInitializeAddress,
    DG_ClientCloseEndpoint,
    DG_ReceivePacket,
    CDP_ServerListen,
    DG_ServerAbortListen,
    COMMON_ServerCompleteListen,
    DG_ForwardPacket,
    CDP_QueryAddress,
    CDP_QueryEndpoint,
    CDP_GetEndpointStats,

    FALSE,              // fIsMessageTransport (TRUE/FALSE).

    0,                  // OptionSize
    0,                  // InitOptions()
    0,                  // SetOption()
    0,                  // InqOption()
    0,                  // ImplementOptions()
    0,                  // AllowReceives()
    0                   // InquireAuthClient()
};

RPC_DATAGRAM_TRANSPORT *pCDP_TransportInterface_Avrf = NULL;

#ifdef IPX_ON
const RPC_DATAGRAM_TRANSPORT
IPX_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    IPX_TOWER_ID,
    IPX_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_ipx"),
    "34280",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    DG_GetNetworkAddressVector,
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_SOCKADDR),
    IPX_MAXIMUM_ENDPOINT,
    IPX_MAXIMUM_PRETTY_NAME,
    1024,
    1464,
    DG_SendPacket,
    IPX_ClientOpenEndpoint,
    IPX_ClientInitializeAddress,
    DG_ClientCloseEndpoint,
    DG_ReceivePacket,
    IPX_ServerListen,
    DG_ServerAbortListen,
    COMMON_ServerCompleteListen,
    DG_ForwardPacket,
    IPX_QueryAddress,
    IPX_QueryEndpoint,
    IPX_GetEndpointStats,

    FALSE,              // fIsMessageTransport (TRUE/FALSE).

    0,                  // OptionSize
    0,                  // InitOptions()
    0,                  // SetOption()
    0,                  // InqOption()
    0,                  // ImplementOptions()
    0,                  // AllowReceives()
    0                   // InquireAuthClient()
};
#endif


#ifdef NCADG_MQ_ON
const RPC_DATAGRAM_TRANSPORT
MQ_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    MQ_TOWER_ID,
    MQ_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_mq"),
    "EpMapper",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    MQ_GetNetworkAddressVector, // Since MQ is being depricated, this is not defined.
    sizeof(MQ_DATAGRAM_ENDPOINT),
    sizeof(MQ_DATAGRAM_ENDPOINT),
    sizeof(MQ_ADDRESS),
    MQ_MAXIMUM_ENDPOINT,
    MQ_MAXIMUM_PRETTY_NAME,

    MQ_MAX_PDU_SIZE,
    MQ_PREFERRED_PDU_SIZE,

    MQ_SendPacket,
    MQ_ClientOpenEndpoint,
    MQ_ClientInitializeAddress,
    MQ_ClientCloseEndpoint,
    MQ_ReceivePacket,
    MQ_ServerListen,
    MQ_ServerAbortListen,
    COMMON_ServerCompleteListen,
    MQ_ForwardPacket,
    MQ_QueryAddress,
    MQ_QueryEndpoint,
    MQ_GetEndpointStats,

    TRUE,                // fIsMessageTransport (TRUE/FALSE).

    sizeof(MQ_OPTIONS),  // OptionSize
    MQ_InitOptions,      // InitOptions()
    MQ_SetOption,        // SetOption()
    MQ_InqOption,        // InqOption()
    MQ_ImplementOptions, // ImplementOptions()
    MQ_AllowReceives,    // AllowReceives()
    MQ_InquireAuthClient
};
#endif // NCADG_MQ_ON


const RPC_DATAGRAM_TRANSPORT *
DG_TransportLoad (
    IN PROTOCOL_ID index
    )
/*++

Routine Description:

    Loads a datagram protocol and returns the transport interface
    information for the protocol.

Arguments:

    index - the PROTOCOL_ID value of the protocol to load.

Return Value:

    0 - failure
    !0 - success

--*/
{
    const RPC_DATAGRAM_TRANSPORT *pInfo;

    if (fWinsockLoaded == FALSE)
        {
        if (RPC_WSAStartup() == FALSE)
            {
            return(0);
            }
        fWinsockLoaded = TRUE;
        }

    switch(index)
        {
        case UDP:
            if (DoFirewallInit())
                {
                // Overwrite the SyncReceive member of the transport interface if the
                // RPC verifier is enabled.
                if (gfRpcVerifierCorruptionInjectClientReceives)
                    {
                    // Check if we have previously initialized the Avrf transport interface.
                    if (pUDP_TransportInterface_Avrf == NULL)
                        {
                        // Allocate a transport interface structure to override the default.
                        pUDP_TransportInterface_Avrf = new (RPC_DATAGRAM_TRANSPORT);
                        if (pUDP_TransportInterface_Avrf == NULL)
                            {
                            return NULL;
                            }
                        // Initialize the Avrf transport interface with the default values.
                        RpcpMemoryCopy(pUDP_TransportInterface_Avrf,
                                       &UDP_TransportInterface,
                                       sizeof(RPC_DATAGRAM_TRANSPORT));
                        // Override the interface function for sync receive.
                        ASSERT(pUDP_TransportInterface_Avrf->SyncReceive == DG_ReceivePacket);
                        pUDP_TransportInterface_Avrf->SyncReceive = DG_ReceivePacket_Avrf;               
                        }
                    pInfo = pUDP_TransportInterface_Avrf;
                    }
                else
                    {
                    pInfo = &UDP_TransportInterface;
                    }
                break;
                }

#ifdef IPX_ON
        case IPX:
            if (InitializeIpxNameCache() != RPC_S_OK)
                {
                pInfo = 0;
                }
            else
                {
                pInfo = &IPX_TransportInterface;
                }
            break;
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
            if (!MQ_Initialize())
                {
                return(0);
                }
            else
                {
                pInfo = &MQ_TransportInterface;
                }
            break;
#endif  // NCADG_MQ_ON

        case CDP:
            // Overwrite the SyncReceive member of the transport interface if the
            // RPC verifier is enabled.
            if (gfRpcVerifierCorruptionInjectClientReceives)
                {
                // Check if we have previously initialized the Avrf transport interface.
                if (pCDP_TransportInterface_Avrf == NULL)
                    {
                    // Allocate a transport interface structure to override the default.
                    pCDP_TransportInterface_Avrf = new (RPC_DATAGRAM_TRANSPORT);
                    if (pCDP_TransportInterface_Avrf == NULL)
                        {
                        return NULL;
                        }
                    // Initialize the Avrf transport interface with the default values.
                    RpcpMemoryCopy(pCDP_TransportInterface_Avrf,
                                   &CDP_TransportInterface,
                                   sizeof(RPC_DATAGRAM_TRANSPORT));
                    // Override the interface function for sync receive.
                    ASSERT(pCDP_TransportInterface_Avrf->SyncReceive == DG_ReceivePacket);
                    pCDP_TransportInterface_Avrf->SyncReceive = DG_ReceivePacket_Avrf;               
                    }
                pInfo = pCDP_TransportInterface_Avrf;
                }
            else
                {
                pInfo = &CDP_TransportInterface;
                }
            break;

        default:
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG_TransportLoad called with index: %d\n",
                           index));

            ASSERT(0);
            pInfo = 0;
            break;
        }

    // PERFBUG: Add code to lookup real PDU sizes

    return(pInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\cookie.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    Cookie.cxx

Abstract:

    HTTP2 Cookie management functions.

Author:

    KamenM      09-18-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <Cookie.hxx>

CookieCollection *g_pServerCookieCollection = NULL;

CookieCollection *g_pInProxyCookieCollection = NULL;

CookieCollection *g_pOutProxyCookieCollection = NULL;

HTTP2VirtualConnection *CookieCollection::FindElement (
    IN HTTP2ServerCookie *Cookie
    )
/*++

Routine Description:

    Finds an element in the cookie collection.

Arguments:

    Cookie - element to find. Only the Cookie part of it
        is looked at.

Return Value:

    NULL - the element was not found.
    non-NULL - pointer to the found element

--*/
{
    LIST_ENTRY *CurrentListElement;
    HTTP2ServerCookie *CurrentCookie;
    ULONG *CurrentCookieNumber;
    ULONG *CookieNumberToLookFor;

    Mutex.VerifyOwned();

    CookieNumberToLookFor = (ULONG *)Cookie->GetCookie();

    CurrentListElement = ListHead.Flink;
    while (CurrentListElement != &ListHead)
        {
        CurrentCookie = CONTAINING_RECORD(CurrentListElement, HTTP2ServerCookie, ListEntry);
        CurrentCookieNumber = (ULONG *)CurrentCookie->GetCookie();
        // the cookies are cryptographically strong numbers. From a performance
        // perspective, the chances that the first comparison will succeed and
        // the others will fail are extremely slim
        if ((*(CurrentCookieNumber + 0) == *(CookieNumberToLookFor + 0))
            && (*(CurrentCookieNumber + 1) == *(CookieNumberToLookFor + 1))
            && (*(CurrentCookieNumber + 2) == *(CookieNumberToLookFor + 2))
            && (*(CurrentCookieNumber + 3) == *(CookieNumberToLookFor + 3)) )
            {
            return CurrentCookie->Connection;
            }
        CurrentListElement = CurrentListElement->Flink;
        }
    return NULL;
}

RPC_STATUS CookieCollection::InitializeCookieCollection (
    IN OUT CookieCollection **CookieCollectionPtr
    )
/*++

Routine Description:

    Initializes a given cookie collection.

    N.B. This method is not thread safe. Callers
    must synchronize before calling it.

Arguments:

    CookieCollectionPtr - on input verified to point to NULL.
        If the function succeeds, on output it will contain
        the collection. If the function fails, on output it
        is guaranteed to contain NULL.

Return Value:

    RPC_S_OK for success or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (*CookieCollectionPtr == NULL)
        {
        *CookieCollectionPtr = new CookieCollection(&RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            delete *CookieCollectionPtr;
            *CookieCollectionPtr = NULL;
            }
        }

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\complete.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Complete.cxx

Abstract:

    The place that IO completes

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/19/1996    Bits 'n pieces
    MarioGo    10/25/1996    Async RPC

--*/
#include <precomp.hxx>
#include <trans.hxx>
#include <cotrans.hxx>

HANDLE RpcCompletionPort = 0;
HANDLE InactiveRpcCompletionPort = 0;

HANDLE *RpcCompletionPorts;
long *CompletionPortHandleLoads;

BASE_ADDRESS *AddressList = 0;

HANDLE g_NotificationHandle = 0;
LONG g_ListeningForPNPNotifications = 0;
LONG g_NotifyRt = 0;

OVERLAPPED g_Overlapped;
CRITICAL_SECTION AddressListLock;


RPC_STATUS
RPC_ENTRY
COMMON_PostNonIoEvent(
    RPC_TRANSPORT_EVENT Event,
    DWORD Type,
    PVOID Context
    )
{
    BOOL b;
    int i = 5;

    ASSERT(Event != TRANSPORT_POSTED_KEY);

    do
        {
        // Kick a listening thread
        b = PostQueuedCompletionStatus(RpcCompletionPort,
                                       Type,
                                       Event,
                                       (LPOVERLAPPED)Context
                                       );
        if (b)
            {
            break;
            }

        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "PostQueuedCompleitonStatus failed %d\n",
                       GetLastError()));

        Sleep(100);
        i--;
        }
    while(i);

    //
    // If this has failed we are out of luck unless something else manages
    // to wake up the listen thread.
    //
    // As of 4/19/96 PostQueuedCompletionStatus will only fail if the handle
    // is invalid or the kernel is unable to allocate a small bit of non-paged
    // pool.  Either way we're toast...
    //

    ASSERT(b);

    if (!b)
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
COMMON_PostRuntimeEvent(
    IN DWORD Type,
    IN PVOID Context
    )
/*++

Routine Description:

    Posts an event to the completion port.  This will complete
    with an event type of RuntimePosted, event status RPC_S_OK
    and event context of Context.

Arguments:
    Context - Context associated with the event

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    return(COMMON_PostNonIoEvent(RuntimePosted, Type, Context));
}



void
COMMON_AddressManager(
    BASE_ADDRESS *pAddress
    )
/*++

Routine Description:

    When an address does not have an outstanding connect/accept/recv for some
    reason it is added to the AddressList global list of address objects.  Listen
    threads will try to submit a listen on these as time passed.  New addresses
    are put onto this list when they are ready to start listening.

Arguments:

    pAddress - An address without an outstanding listen.

Return Value:

    None

--*/
{

    EnterCriticalSection(&AddressListLock);

    if (pAddress->InAddressList == NotInList)
        {

        #if DBG
        // The address should not be in the list.
        BASE_ADDRESS *pT = AddressList;
        while(pT)
            {
            ASSERT(pT != pAddress);
            pT = pT->pNext;
            }
        #endif

        pAddress->pNext = AddressList;
        AddressList = pAddress;
        pAddress->InAddressList = InTheList;
        }

    LeaveCriticalSection(&AddressListLock);
}


void RPC_ENTRY
COMMON_ServerCompleteListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress
    )
/*++

Routine Description:

    Called on an address once the runtime is really ready to start
    processing connections on this address.

Arguments:

    Address - A fully initalized address which the runtime is
        ready to start receiving connection on.

Return Value:

    None

--*/
{
    BASE_ADDRESS *pList = (BASE_ADDRESS *) ThisAddress;

    while(pList)
        {
        COMMON_AddressManager(pList);
        pList = pList->pNextAddress;
        }

    COMMON_ListenForPNPNotifications();

    // The TRANSPORT message indicates that a new
    // address has been added to the AddressList.

    COMMON_PostNonIoEvent(TRANSPORT, 0, 0);


    return;
}



RPC_STATUS RPC_ENTRY
COMMON_PrepareNewHandle(HANDLE hAdd)
/*++

Routine Description:

    Generic wrapper used to add a newly create IO handle to
    to the IO completion port.

Arguments:

    hAdd - The handle to be added to the port.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    HANDLE h = CreateIoCompletionPort(hAdd,
                                      RpcCompletionPort,
                                      TRANSPORT_POSTED_KEY,
                                      0);

    if (h)
        {
        ASSERT(h == RpcCompletionPort);
        return(RPC_S_OK);
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "CreateIoCompletionPort failed %d\n",
                   GetLastError()));

    ASSERT((GetLastError() == ERROR_NO_SYSTEM_RESOURCES) ||
		   (GetLastError() == ERROR_NOT_ENOUGH_QUOTA));

    return(RPC_S_OUT_OF_MEMORY);
}


void
COMMON_RemoveAddress (
    IN BASE_ADDRESS *Address
    )
/*++
Function Name:COMMON_RemoveAddress

Parameters:

Description:
    This function must be called only when AddressListLock is held
    Remove address from the address manager list

Returns:

--*/
{
    Address->InAddressList = Inactive;

    //
    // Close the sockets in the address
    //

    if (Address->type & DATAGRAM)
        {
        DG_DeactivateAddress((WS_DATAGRAM_ENDPOINT *) Address);
        }
    else
        {
        WS_DeactivateAddress((WS_ADDRESS *) Address);
        }
}


VOID
RPC_ENTRY
COMMON_StartPnpNotifications (
    )
{
    ASSERT(RpcCompletionPort);

    g_NotifyRt = TRUE;
    COMMON_ListenForPNPNotifications();
}


VOID
RPC_ENTRY
COMMON_ListenForPNPNotifications (
    )
/*++
Function Name:COMMON_ListenForPNPNotifications

Parameters:

Description:

Returns:

--*/
{
    int retval;
    HANDLE h;

    if (hWinsock2 == 0)
        {
        //
        // Winsock not loaded, don't need to do any PNP stuff
        //
        return;
        }

    if (InterlockedIncrement(&g_ListeningForPNPNotifications) != 1)
        {
        return;
        }

    // REVIEW: We may need to provide a mechanism to prevent spinning for lack of
    // resources

    if (g_NotificationHandle == 0)
        {
        retval = WSAProviderConfigChange(
                                     &g_NotificationHandle,
                                     0, 0);
        if (retval != 0 || g_NotificationHandle == 0)
            {
            if (g_NotificationHandle)
                CloseHandle(g_NotificationHandle);
            goto Cleanup;
            }

        h = CreateIoCompletionPort(g_NotificationHandle,
                               RpcCompletionPort,
                               NewAddress,
                               0);

        if (h == 0)
            {
            CloseHandle(g_NotificationHandle);
            goto Cleanup;
            }
        else
            {
            ASSERT(h == RpcCompletionPort);
            }
        }

    // if the previous request is still there, we don't want to submit another one
    if (g_Overlapped.Internal != STATUS_PENDING)
        {
        g_Overlapped.hEvent = 0;
        g_Overlapped.Offset = 0;
        g_Overlapped.OffsetHigh = 0;

        retval = WSAProviderConfigChange(
                                         &g_NotificationHandle,
                                         &g_Overlapped,
                                         0);
        if (retval != 0)
            {
            if (GetLastError() != WSA_IO_PENDING)
                {
                CloseHandle(g_NotificationHandle);
                goto Cleanup;
                }
            }
        }

    if (!TransportProtocol::ResubmitQueriesIfNecessary())
        {
        CloseHandle(g_NotificationHandle);
        goto Cleanup;
        }

    g_ListeningForPNPNotifications = 2;
    return;

Cleanup:
    g_ListeningForPNPNotifications = 0;
    g_NotificationHandle = 0;
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "COMMON_ListenForPNPNotifications failed\n"));
}


RPC_STATUS
RPC_ENTRY
COMMON_ProcessCalls(
    IN  INT Timeout,
    OUT RPC_TRANSPORT_EVENT *pEvent,
    OUT RPC_STATUS *pEventStatus,
    IN OUT PVOID *ppEventContext,
    OUT UINT *pBufferLength,
    OUT BUFFER *pBuffer,
    OUT PVOID *ppSourceContext)
/*++

Routine Description:

    This routine waits for any async IO to complete for all protocols
    within a transport DLL.  It maybe called by multiple threads at a
    time.  A minimum of one thread should always be calling this function
    for each DLL.

    Note: async clients with no outstanding IO may allow the
        last thread to timeout and only call this function again
        when a new call is started.

    Note: During calls to this API in connection oriented servers
        a callback to I_RpcTransServerNewConnection() may occur.

Arguments:

    Timeout - -1 - infinite
              other - number of milliseconds to wait for IO

    pEvent - Set on return to the type of IO event which finished.

    pEventStatus - The status of the IO event

    ppEventContext - On IN, the handle that the thread should dequeue on.
        On output the context of the event

    pBufferLength - If the event is successful then the number of
        bytes transferred.

    pBuffer - If the even is successful then the buffer associated
        with the IO.

    ppSourceContext - For datagram recvs this is the address
        of the sender.
            For connection sends this is the SendContext associated
        with the IO.  For connection recvs it is NULL.

Return Value:

    RPC_S_OK - IO completed, see pEventStatus.

    RPC_P_TIMEOUT - only if Timeout != INFINITE and is exceeded.

--*/
{
    BOOL b;
    ULONG_PTR key;
    DWORD bytes;
    RPC_STATUS status;
    LPOVERLAPPED lpOverlapped;
    PBASE_OVERLAPPED pBaseOverlapped;
    PREQUEST pRequest;
    PCONNECTION pConnection;
    PADDRESS pAddress;
    INT LocalTimeout;
    HANDLE hCompletionPortHandle = (HANDLE) *ppEventContext;
    DWORD LastError;

    ASSERT(RpcCompletionPort);

    *pEvent = 0;
    *pBuffer = 0;

    for(;;)
        {

        //
        // Do general house keeping work here.  If it appears that more
        // house keeping work will be required in the future make
        // sure to reduce the LocalTimeout to something < INFINITE.
        //

        LocalTimeout = Timeout;

        // House keeping - look for any non-listening addresses and see if we
        // can make them listen now.  Addresses start in this list and are added
        // back into the list if they are unable to submit a listen for some reason.

        if (AddressList)
            {
            EnterCriticalSection(&AddressListLock);

            if (AddressList)
                {

                pAddress = (PADDRESS)AddressList;
                AddressList = 0;

                if (Timeout == INFINITE)
                    {
                    // We want to wake up again soon and recheck the AddressList.
                    LocalTimeout = 7*1000;
                    }
                }
            else
                {
                pAddress = 0;
                }

            LeaveCriticalSection(&AddressListLock);

            while(pAddress)
                {
                PADDRESS pNext = (PADDRESS)pAddress->pNext;
                pAddress->pNext = 0;

                if (pAddress->InAddressList == InTheList)
                    {
                    pAddress->InAddressList = NotInList;
                    pAddress->SubmitListen(pAddress);
                    }
                pAddress = pNext;
                }
            }

        if (!g_ListeningForPNPNotifications)
            {
            COMMON_ListenForPNPNotifications();
            }

        //
        // The good part!  Wait for something to happen...
        //
        b = GetQueuedCompletionStatus(hCompletionPortHandle,
                                      &bytes,
                                      &key,
                                      &lpOverlapped,
                                      LocalTimeout
                                      );

        if (!b && !lpOverlapped)
            {
            // If lpOverlapped is NULL this mean no IO completed.
            if ((status = GetLastError()) == STATUS_TIMEOUT)
                {
                if (Timeout == INFINITE)
                    {
                    continue;
                    }
                return(RPC_P_TIMEOUT);
                }
            else
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "GetQueuedCompletionStatus failed %d\n",
                               status));

                ASSERT(0);
                Sleep(1);  // Avoid burning all the CPU in case we are hosed.
                continue;
                }
            }

        //PrintToDebugger("A request arrived at the completion port\n");
        if (key != TRANSPORT_POSTED_KEY)
            {
            if (b)
                {
                // Internal Non-IO posted event
                //    Key - The type of event
                //    lpOverlapped - The context associated with the event

                ASSERT(   key == RuntimePosted
                   || key == TRANSPORT
                   || key == NewAddress);

                // RuntimePosted events allowed the RPC runtime to wake
                // a listening thread with an atbitrary context.
                if (key == RuntimePosted)
                    {
                    *pEvent = RuntimePosted;
                    *pEventStatus = RPC_S_OK;
                    *ppEventContext = lpOverlapped;
                    *pBufferLength = bytes;
                    return(RPC_S_OK);
                    }

                //
                // A protocol was just loaded or unloaded. Take care of it
                //
                if (key == NewAddress)
                    {
                    if (TransportProtocol::HandlePnPStateChange())
                        {
                        g_ListeningForPNPNotifications = 0;
                        *pEvent = NewAddress;

                        return(RPC_S_OK);
                        }

                    // REVIEW: Not processing notification handling failures
                    // may create problems where new protocols, or unloading of
                    // old ones are ignored. This is not very bad, so we keep
                    // it simple and ignore it.
                    g_ListeningForPNPNotifications = 0;
                    continue;
                    }

                // TRANSPORT event is posted when a new address
                // has been added to the AddressListen.  Simply continue
                // around the loop.

                ASSERT(bytes == 0);
                ASSERT(lpOverlapped == 0);
                }
            else
                {

                if (key == NewAddress)
                    {
                    g_ListeningForPNPNotifications = 0;
                    }
                }
            continue;
            }

        ASSERT(!b || lpOverlapped);

        status = RPC_S_OK;

        if (!b)
            {
            pBaseOverlapped = FindOverlapped(lpOverlapped);
            pRequest = FindRequest(lpOverlapped);

            LastError = GetLastError();
            if ((   pRequest->type & ADDRESS)
                 && (LastError != ERROR_MORE_DATA))
                {
                VALIDATE(GetLastError())
                    {
                    ERROR_NETNAME_DELETED,
                    ERROR_BAD_NETPATH,
                    ERROR_NO_SYSTEM_RESOURCES,
                    ERROR_SEM_TIMEOUT,
                    ERROR_OPERATION_ABORTED,
                    ERROR_HOST_UNREACHABLE,
                    ERROR_NETWORK_UNREACHABLE,
                    ERROR_UNEXP_NET_ERR,
                    ERROR_NOT_ENOUGH_QUOTA,
                    ERROR_BROKEN_PIPE,
                    ERROR_CONNECTION_ABORTED
                    } END_VALIDATE;

                COMMON_AddressManager((BASE_ADDRESS *)pRequest);
                continue;
                }

            switch (LastError)
                {
                case ERROR_MORE_DATA:
                    {
                    // Normal parital read of a connection request
                    // or an oversized datagram.  This is ok, falls
                    // into the normal path.

                    status = RPC_P_OVERSIZE_PACKET;
                    break;
                    }

                case ERROR_INVALID_HANDLE:
                    // Named pipes allows a close to reach the server before
                    // the read.  When this happens the server rejects the read
                    // with an invalid handle error.
                    ASSERT(pRequest->id == NMP);
                    ASSERT(pRequest->fAborted);

                    // Fall into normal close case.

                case ERROR_NETNAME_DELETED:
                case ERROR_BROKEN_PIPE:
                case ERROR_PIPE_NOT_CONNECTED:
                case ERROR_NO_DATA:
                case ERROR_SEM_TIMEOUT:
                case ERROR_GRACEFUL_DISCONNECT:
                case WSAECONNRESET:
                case WSAESHUTDOWN:
                case WSAECONNABORTED:
                case WSAEHOSTDOWN:
                case ERROR_CONNECTION_ABORTED:
                    {
                    bytes = 0;
                    ASSERT((pRequest->type & PROTO_MASK) == CONNECTION);
                    // Will be handled as a close
                    break;
                    }

                case ERROR_NO_SYSTEM_RESOURCES:
                    {
                    //
                    // This is just like the errors above except that both c/o and datagram requests
                    // can generate it.
                    //
                    if ((pRequest->type & PROTO_MASK) == CONNECTION)
                        {
                        bytes = 0;
                        // Will be handled as a close
                        }
                    else
                        {
                        bytes = 0;
                        status = ERROR_OPERATION_ABORTED;
                        }

                    break;
                    }

                case ERROR_OPERATION_ABORTED:
                    {
                    //
                    // When a thread that issued an I/O dies the operation
                    // completes with this error.
                    // There are a couple cases here:
                    //  1) The IO is datagram in which case we can just
                    //     reissue the I/O on this thread.  In an idle
                    //     server eventually all DG I/O will migrate to
                    //     the single listening thread.
                    //  2) The IO is on a client connection and the
                    //     the client thread has died.  In this case
                    //     we need to abort the connection and return
                    //     to the runtime.
                    //  3) If this happens on an address we have a bug.
                    //  4) If this happens on a server connection we have a bug.
                    //

                    if (pRequest->type & DATAGRAM)
                        {
                        // We deal with this in the normal datagram path
                        ASSERT(bytes == 0);
                        status = ERROR_OPERATION_ABORTED;
                        break;
                        }

                    ASSERT((pRequest->type & PROTO_MASK) == CONNECTION);
                    // zero out the bytes just in case. Sometimes network operations
                    // return positive byte count on operation aborted
                    bytes = 0;

                    // We'll treat this as a connection close on the client.
                    // REVIEW: Maybe do something better.

                    break;
                    }

                case ERROR_NETWORK_UNREACHABLE:
                case ERROR_HOST_UNREACHABLE:
                case ERROR_PORT_UNREACHABLE:
                    //
                    // errors coming from ICMP packets to our UDP endpoint.
                    // Winsock does not present this in a way our async architecture
                    // can use, so ignore them.
                    //
                    if ((pRequest->type & PROTO_MASK) == CONNECTION)
                        {
                        bytes = 0;
                        // Will be handled as a close
                        }
                    else
                        {
                        status = ERROR_OPERATION_ABORTED;
                        }
                    break;

                default:
                    {
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "IO failed %lX %d\n",
                                   pRequest,
                                   GetLastError()));

                    ASSERT(0);
                    status = RPC_S_OUT_OF_RESOURCES;
                    // treat as a close
                    bytes = 0;
                    break;
                    }
                }
            }

        // here we actually have a completed IO
        pBaseOverlapped = FindOverlapped(lpOverlapped);
        pRequest = FindRequest(lpOverlapped);

        if (pRequest == NULL)
            {
            ASSERT(0);
            return (RPC_S_INTERNAL_ERROR);
            }
        
        switch(pRequest->type & PROTO_MASK)
            {
            case CONNECTION:
                //
                // Connection IO completed.
                //
                I_RpcTransUnprotectThread(pBaseOverlapped->thread);

                pConnection = (PCONNECTION)pRequest;

                // A read or write either completed or failed

                *ppEventContext = pConnection;

                if (pBaseOverlapped == &pConnection->Read)
                    {
                    // Read completed
                    *ppSourceContext = UlongToPtr(bytes);

                    if (bytes == 0)
                        {
                        *pEvent = pConnection->type | RECEIVE;
                        pConnection->Abort();

                        *pEventStatus = RPC_P_CONNECTION_SHUTDOWN;
                        return(RPC_S_OK);
                        }

                    status = pConnection->ProcessRead(bytes,
                                                      pBuffer,
                                                      pBufferLength);

                    // N.B. Do not move the reading of the pConnection->type
                    // before ProcessRead. ProcessRead can change the type based
                    // on what it reads
                    *pEvent = pConnection->type | RECEIVE;

                    if (status != RPC_P_PARTIAL_RECEIVE)
                        {
                        ASSERT(   status == RPC_P_RECEIVE_FAILED
                               || status == RPC_S_OK
                               || status == RPC_P_INITIALIZE_HTTP2_CONNECTION);


                        *pEventStatus = status;
                        return(RPC_S_OK);
                        }

                    // Message is not complete, submit the next read and continue.

                    status = CO_SubmitRead(pConnection);

                    if (status != RPC_S_OK)
                        {
                        ASSERT(status == RPC_P_RECEIVE_FAILED);
                        *pEventStatus = status;
                        return(RPC_S_OK);
                        }
                    }
                else
                    {
                    // Write completed
                    CO_SEND_CONTEXT *pSend = (CO_SEND_CONTEXT *)pBaseOverlapped;

                    ASSERT(pSend->Write.pAsyncObject == pConnection);

                    *pEvent = pConnection->type | SEND;
                    *ppSourceContext = pSend;

                    *pBuffer = pSend->pWriteBuffer;

                    if (bytes == 0)
                        {
                        pConnection->Abort();

                        *pEventStatus = RPC_P_SEND_FAILED;
                        *pBufferLength = 0;
                        }
                    else
                        {
                        status = RPC_S_OK;

                        *pEventStatus = status;
                        *pBufferLength = pSend->maxWriteBuffer;

                        // Netbios client-side writes are sizeof(DWORD) too big since
                        // they also include the sequence number.

                        ASSERT(   bytes == pSend->maxWriteBuffer
                                       || (    (bytes == pSend->maxWriteBuffer + sizeof(DWORD))
                                          && ((pConnection->type & TYPE_MASK) == CLIENT) ) );
                        }

                    return(RPC_S_OK);
                    }
                break;

            case ADDRESS:
                {
//                ASSERT(bytes == 0);
                pAddress = (PADDRESS)pRequest;
                PCONNECTION pNewConnection = 0;

                status = pAddress->NewConnection(pAddress, &pNewConnection);

                if (RPC_S_OK == status)
                    {
                    // Opened a connection, now try to submit the first recv.

                    ASSERT(pNewConnection);
                    RPC_CONNECTION_TRANSPORT *pInfo;

                    pInfo = (RPC_CONNECTION_TRANSPORT *)TransportTable[pAddress->id].pInfo;

                    ASSERT(pInfo->Recv);

                    status = (pInfo->Recv)(pNewConnection);

                    if (RPC_S_OK != status)
                        {
                        ASSERT(status == RPC_P_RECEIVE_FAILED);
                        *pEvent = pNewConnection->type | RECEIVE;
                        *ppEventContext = pNewConnection;
                        *pEventStatus = status;
                        return(RPC_S_OK);
                        }
                    }

                // Connection has been established or closed, either
                // way we can continue around the loop.
                }
                break;

            case DATAGRAM:
                {
                BASE_ASYNC_OBJECT *pBase = (BASE_ASYNC_OBJECT*)pRequest;

#ifdef NCADG_MQ_ON
                if (pBase->id == MSMQ)
                    {
                    // MSMQ (Falcon) datagram path:
                    MQ_DATAGRAM          *pDatagram = (MQ_DATAGRAM*)pRequest;
                    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)pDatagram->pEndpoint;

                    if (status == RPC_P_OVERSIZE_PACKET)
                        {
                        // Data still pending, get it:
                        status = MQ_ResizePacket( pEndpoint,
                                                  (void**)&pDatagram->pAddress,
                                                  (unsigned int*)pBufferLength,
                                                  pBuffer );
                        }

                    if (status == RPC_S_OK)
                        {
                        MQ_FillInAddress(pDatagram->pAddress,pDatagram->Read.aMsgPropVar);

                        *pEvent = pDatagram->type;
                        *pEventStatus = status;
                        *ppEventContext = pEndpoint;
                        // WATCH OUT! MSMQ doesn't return the size in "bytes"
                        // from GetQueuedCompletionStatus() like everything
                        // else does! We need to extract the #bytes from the
                        // message structure.
                        //
                        // DON'T: *pBufferLength = bytes;
                        *pBufferLength = pDatagram->Read.aMsgPropVar[1].ulVal;
                        *pBuffer = (BUFFER)pDatagram->pPacket;
                        *ppSourceContext = pDatagram->pAddress;

                        pDatagram->pPacket = 0;
                        pDatagram->dwPacketSize = 0;
                        }

                    pDatagram->Busy = 0;

                    LONG c = InterlockedDecrement(&pEndpoint->cPendingIos);

                    ASSERT(c >= 0);

                    if (c == 0)
                        {
                        // No pending receives, time to post more. This doesn't
                        // get hit very often, normally additional recieves are
                        // after sending a packet. (see DG_SendPacket)

                        MQ_SubmitReceives(pEndpoint);
                        }

                    if (status == RPC_S_OK)
                        {
                        return RPC_S_OK;
                        }
                    }
                else
#endif
                    {
                    // Normal datagram path:
                    WS_DATAGRAM          *pDatagram = (WS_DATAGRAM *)pRequest;
                    WS_DATAGRAM_ENDPOINT *pEndpoint = (WS_DATAGRAM_ENDPOINT*)pDatagram->pEndpoint;

                    if (status == RPC_P_OVERSIZE_PACKET)
                        {
                        ASSERT(bytes == pDatagram->Packet.len);
                        }

                    if (   status == RPC_S_OK
                           || status == RPC_P_OVERSIZE_PACKET)
                        {
                        // A receive completed

                        ASSERT(bytes);

                        *pEvent = pDatagram->type;
                        *pEventStatus = status;
                        *ppEventContext = pEndpoint;
                        *pBufferLength = bytes;
                        *pBuffer = (BUFFER)pDatagram->Packet.buf;
                        *ppSourceContext = pDatagram->AddressPair;

                        ASSERT( pDatagram->Packet.buf );

                        // Ready the datagram for another IO operation.
                        pDatagram->Packet.buf = 0;

                        status = RPC_S_OK;
                        }

#if DBG
                    if (status != RPC_S_OK &&
                        status != ERROR_OPERATION_ABORTED)
                        {
                        DbgPrint("RPC: I/O completed with 0x%x\n", status);

                        ASSERT( 0 );
                        }
#endif

                    // Do not touch the datagram after this!
                    pDatagram->Busy = 0;

                    LONG c = InterlockedDecrement(&pEndpoint->cPendingIos);

                    ASSERT(c >= 0);

                    if (c == 0)
                        {
                        // No pending receives, time to post more. This doesn't
                        // get hit very often, normally additional recieves are
                        // after sending a packet. (see DG_SendPacket)

                        DG_SubmitReceives(pEndpoint);
                        }

                    if (status == RPC_S_OK)
                        {
                        return RPC_S_OK;
                        }
                    }
                }
                // Operation aborted, continue around the loop.
                break;

            default:
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "Invalid request type: 0x%x (%p)\n",
                               pRequest->type, pRequest));

                ASSERT(0);
                break;
            }

        // Loop
        }

    ASSERT(0);
    return(RPC_S_INTERNAL_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\hndlcach.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    hndlcach.cxx

Abstract:

    The handle cache.

Author:

    Kamen Moutafov    [KamenM]

Revision History:

--*/

#include <precomp.hxx>

HandleCache::~HandleCache(void)
{
    int i;
    BOOL b;

    for (i = 0; i < DEFAULT_CACHE_SIZE; i ++)
        {
        if (cacheSlots[i] == NULL)
            {
            b = CloseHandle(cacheSlots[i]);
            ASSERT(b);
            cacheSlots[i] = NULL;
            }
        }    
}


HANDLE HandleCache::CheckOutHandle(void)
{
    int i;
    HANDLE h;

    for (i = 0; i < DEFAULT_CACHE_SIZE; i++)
        {
        if (cacheSlots[i] != NULL)
            {
            h = cacheSlots[i];
            cacheSlots[i] = NULL;
            return h;
            }
        }

    return NULL;
}

void HandleCache::CheckinHandle(HANDLE *ph)
{
    int i;

    for (i = 0; i < DEFAULT_CACHE_SIZE; i++)
        {
        if ( NULL == InterlockedCompareExchangePointer(&cacheSlots[i],
                                                       *ph, NULL) )
            {
            *ph = NULL;
            break;
            }
        }
}

#if defined(DBG) || defined(_DEBUG)
BOOL HandleCache::IsSecondHandleUsed(void)
{
    ASSERT (DEFAULT_CACHE_SIZE >= 2);
    return (cacheSlots[1] != NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\cmap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cmap.cxx
//
//--------------------------------------------------------------------------


#include <precomp.hxx>
#include <mqtrans.hxx>

//------------------------------------------------------------------------
//  Constructor
//------------------------------------------------------------------------
CQueueMap::CQueueMap() : cs((InitStatus = RPC_S_OK, &InitStatus))
{
    dwMapSize = 0;
    dwOldest = 0;
    pMap = 0;
}

//------------------------------------------------------------------------
//  Initialize()
//------------------------------------------------------------------------
BOOL CQueueMap::Initialize( DWORD dwNewMapSize )
{
    if (!dwNewMapSize)
       return FALSE;

    if (!dwMapSize)
       {

       if (InitStatus != RPC_S_OK)
           return FALSE;

       pMap = new QUEUEMAP_ENTRY [dwNewMapSize];
       if (!pMap)
          return FALSE;

       dwMapSize = dwNewMapSize;

       for (unsigned i=0; i<dwMapSize; i++)
           {
           pMap[i].hQueue = 0;
           pMap[i].pwsQFormat = 0;
           }
    }

    return TRUE;
}

//------------------------------------------------------------------------
//  Destructor
//------------------------------------------------------------------------
CQueueMap::~CQueueMap()
{
    if (pMap)
        {
        for (unsigned i=0; i<dwMapSize; i++)
            {
            if (pMap[i].hQueue)
               MQCloseQueue(pMap[i].hQueue);
            if (pMap[i].pwsQFormat)
               delete [] pMap[i].pwsQFormat;
            }
        }

   delete pMap;
}

//------------------------------------------------------------------------
//  Lookup()
//------------------------------------------------------------------------
QUEUEHANDLE CQueueMap::Lookup( RPC_CHAR *pwsQFormat )
{

    cs.Request();

    for (unsigned i=0; i<dwMapSize; i++)
        {
        if ((pMap[i].pwsQFormat)&&(!RpcpStringSCompare(pwsQFormat,pMap[i].pwsQFormat)))
            {
            cs.Clear();
            return pMap[i].hQueue;
            }
        }

    cs.Clear();

    return 0;
}

//------------------------------------------------------------------------
//  Add()
//------------------------------------------------------------------------
BOOL CQueueMap::Add( RPC_CHAR *pwsQFormat, QUEUEHANDLE hQueue )
{
    // Only add entries that look valid...
    if ( !pwsQFormat || !hQueue )
        {
        return FALSE;
        }

    cs.Request();

    // If the table is full, the clear out the oldest entry:
    if (pMap[dwOldest].hQueue)
        {
        MQCloseQueue(pMap[dwOldest].hQueue);
        pMap[dwOldest].hQueue = 0;
        }

    if (pMap[dwOldest].pwsQFormat)
        {
        delete [] pMap[dwOldest].pwsQFormat;
        pMap[dwOldest].pwsQFormat = 0;
        }

    // New entry:
    pMap[dwOldest].pwsQFormat = new RPC_CHAR [1+RpcpStringLength(pwsQFormat)];
    if (!pMap[dwOldest].pwsQFormat)
        {
        cs.Clear();
        return FALSE;
        }

    RpcpStringCopy(pMap[dwOldest].pwsQFormat,pwsQFormat);
    pMap[dwOldest].hQueue = hQueue;

    dwOldest = (1 + dwOldest)%dwMapSize;

    cs.Clear();

    return TRUE;
}

//------------------------------------------------------------------------
//  Remove()
//------------------------------------------------------------------------
BOOL CQueueMap::Remove( RPC_CHAR *pwsQFormat )
{
    cs.Request();

    for (unsigned i=0; i<dwMapSize; i++)
        {
        if ((pMap[i].pwsQFormat)&&(!RpcpStringSCompare(pwsQFormat,pMap[i].pwsQFormat)))
            {
            delete [] pMap[i].pwsQFormat;
            pMap[i].pwsQFormat = 0;
            pMap[i].hQueue = 0;
            cs.Clear();
            return TRUE;
            }
        }

    cs.Clear();

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\http2.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    HTTP2.cxx

Abstract:

    HTTP2 transport-specific functions.

Author:

    KamenM      08-30-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <rpcssl.h>
#include <CharConv.hxx>
#include <HttpRTS.hxx>
#include <sdict.hxx>
#include <binding.hxx>
#include <Cookie.hxx>
#include <Http2Log.hxx>
#include <WHttpImp.hxx>

// external definition
TRANS_INFO  *
GetLoadedClientTransportInfoFromId (
    IN unsigned short TransportId
    );

BOOL DefaultChannelLifetimeStringRead = FALSE;
#if DBG
ULONG DefaultChannelLifetime = 128 * 1024;  // 128K for now
char *DefaultChannelLifetimeString = "131072";
ULONG DefaultChannelLifetimeStringLength = 6;   // does not include null terminator
#else
ULONG DefaultChannelLifetime = 1024 * 1024 * 1024;  // 1GB for now
char *DefaultChannelLifetimeString = "1073741824";
ULONG DefaultChannelLifetimeStringLength = 11;   // does not include null terminator
#endif

ULONG DefaultReceiveWindowSize = 64 * 1024;      // 64K

const ULONG ClientReservedChannelLifetime = 4 * 1024;   // 4K
const ULONG ServerReservedChannelLifetime = 8 * 1024;   // 8K

const ULONG DefaultReplacementChannelCallTimeout = 3 * 60 * 1000;   // 3 minutes in milliseconds

const ULONG MinimumConnectionTimeout = 30 * 1000;   // 30 seconds in milliseconds

BOOL ActAsSeparateMachinesOnWebFarm = FALSE;

BOOL AlwaysUseWinHttp = FALSE;

long ChannelIdCounter = 0;

ULONG HTTP2ClientReceiveWindow = HTTP2DefaultClientReceiveWindow;
ULONG HTTP2InProxyReceiveWindow = HTTP2DefaultInProxyReceiveWindow;
ULONG HTTP2OutProxyReceiveWindow = HTTP2DefaultOutProxyReceiveWindow;
ULONG HTTP2ServerReceiveWindow = HTTP2DefaultServerReceiveWindow;

ULONG OverrideMinimumConnectionTimeout = 0;

RPC_CHAR *InChannelTargetTestOverride = NULL;
RPC_CHAR *OutChannelTargetTestOverride = NULL;

/*********************************************************************
    Global Functions and utility classes
 *********************************************************************/

static const RPC_CHAR *HTTP_DEF_CHANNEL_LIFE_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeDefaultChannelLifetime (
    void
    )
/*++

Routine Description:

    Read the default channel lifetime from the registry and
    initialize the default global variable

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    if (DefaultChannelLifetimeStringRead)
        return RPC_S_OK;

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_DEF_CHANNEL_LIFE_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"DefaultChannelLifetime",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        DefaultChannelLifetime = Result;
        RpcpItoa(Result, Buffer, 10);
        DefaultChannelLifetimeStringLength = RpcpStringLengthA(Buffer);

        DefaultChannelLifetimeString = new char [DefaultChannelLifetimeStringLength + 1];
        if (DefaultChannelLifetimeString == NULL)
            Status = RPC_S_OUT_OF_MEMORY;
        else
            {
            RpcpMemoryCopy(DefaultChannelLifetimeString, Buffer, DefaultChannelLifetimeStringLength + 1);
            DefaultChannelLifetimeStringRead = TRUE;
            }
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

static const RPC_CHAR *HTTP_ACT_AS_WEB_FARM_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeActAsWebFarm (
    void
    )
/*++

Routine Description:

    Read the act as web farm variable. Used as a test hook to emulate
        web farm on single machine

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_ACT_AS_WEB_FARM_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"ActAsWebFarm",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        ActAsSeparateMachinesOnWebFarm = Result;
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

static const RPC_CHAR *HTTP_USE_HTTP_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeUseWinHttp (
    void
    )
/*++

Routine Description:

    Read the use WinHttp variable. Used as a test hook to force
        WinHttp usage regardless of security

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
#if 1
    // always use WinHttp for now
    return RPC_S_OK;
#else
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_ACT_AS_WEB_FARM_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"UseWinHttp",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        AlwaysUseWinHttp = Result;
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
#endif
}

static const RPC_CHAR *HTTP_RECEIVE_WINDOWS_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeReceiveWindows (
    void
    )
/*++

Routine Description:

    Read the receive windows.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];
    RPC_CHAR *Keys[4];
    ULONG *Values[4];
    int i;

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_RECEIVE_WINDOWS_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Keys[0] = L"ClientReceiveWindow";
    Keys[1] = L"InProxyReceiveWindow";
    Keys[2] = L"OutProxyReceiveWindow";
    Keys[3] = L"ServerReceiveWindow";

    Values[0] = &HTTP2ClientReceiveWindow;
    Values[1] = &HTTP2InProxyReceiveWindow;
    Values[2] = &HTTP2OutProxyReceiveWindow;
    Values[3] = &HTTP2ServerReceiveWindow;

    for (i = 0; i < 4; i ++)
        {
        DwordSize = sizeof(DWORD);

        Status = RegQueryValueExW(
                        h,
                        Keys[i],
                        0,
                        &Type,
                        (LPBYTE) &Result,
                        &DwordSize
                        );

        if (Status == ERROR_SUCCESS
            && Type == REG_DWORD)
            {
            *(Values[i]) = Result;
            }
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return RPC_S_OK;
}

// N.B. This value must agree with the key specified in the system.adm file
static const RPC_CHAR *HTTP_MIN_CONN_TIMEOUT_KEY = 
    L"Software\\Policies\\Microsoft\\Windows NT\\Rpc\\MinimumConnectionTimeout";

RPC_STATUS InitializeMinConnectionTimeout (
    void
    )
/*++

Routine Description:

    Read the minimum connection timeout from the registry/policy.
    An admin may set a lower timeout than the IIS timeout.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  HTTP_MIN_CONN_TIMEOUT_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"MinimumConnectionTimeout",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD
        && Result >= 90
        && Result <= 14400)
        {
        OverrideMinimumConnectionTimeout = Result * 1000;
        }

    // if the type was not REG_DWORD or out of range, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

// N.B. This value must agree with the key specified in the system.adm file
static const RPC_CHAR *LM_COMPATIBILITY_LEVEL_KEY = 
    L"System\\Currentcontrolset\\Control\\Lsa";

RPC_STATUS IsLanManHashDisabled (
    OUT BOOL *Disabled
    )
/*++

Routine Description:

    Check in the registry whether the lan man hash was disabled.

Arguments:

    Disabled - on successful output, if true, the lan man hash was disabled.
        Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    *Disabled = FALSE;

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  LM_COMPATIBILITY_LEVEL_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed as if the hash is enabled
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"lmcompatibilitylevel",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed as if hash is enabled
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD
        && Result >= 2)
        {
        *Disabled = TRUE;
        }

    // if the type was not REG_DWORD or out of range, probably registry is corrupted
    // in this case, assume hash is enabled

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

BOOL g_fHttpClientInitialized = FALSE;

BOOL g_fHttpServerInitialized = FALSE;

TRANS_INFO *HTTPTransInfo = NULL;

RPC_STATUS InitializeHttpCommon (
    void
    )
/*++

Routine Description:

    Initialize the common (b/n client & server) Http transport
    if not done already

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    GlobalMutexVerifyOwned();

    if (HTTPTransInfo == NULL)
        {
        HTTPTransInfo = GetLoadedClientTransportInfoFromId(HTTP_TOWER_ID);
        // the TCP transport should have been initialized by now
        ASSERT(HTTPTransInfo);
        }

    return InitializeReceiveWindows();
}

RPC_STATUS InitializeHttpClient (
    void
    )
/*++

Routine Description:

    Initialize the Http client if not done already

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    GlobalMutexRequest();

    if (g_fHttpClientInitialized == FALSE)
        {
        RpcStatus = InitializeHttpCommon();

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = InitializeDefaultChannelLifetime();

            if (RpcStatus == RPC_S_OK)
                {
                RpcStatus = InitializeUseWinHttp();
                if (RpcStatus == RPC_S_OK)
                    {
                    RpcStatus = InitializeMinConnectionTimeout();
                    if (RpcStatus == RPC_S_OK)
                        {
                        g_fHttpClientInitialized = TRUE;
                        }
                    }
                }
            }
        }
    else
        {
        RpcStatus = RPC_S_OK;
        }
    GlobalMutexClear();

    return RpcStatus;
}

RPC_STATUS InitializeHttpServer (
    void
    )
/*++

Routine Description:

    Initialize the Http server if not done already

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    GlobalMutexRequest();

    if (g_fHttpServerInitialized == FALSE)
        {
        RpcStatus = InitializeHttpCommon();

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = CookieCollection::InitializeServerCookieCollection();

            if (RpcStatus == RPC_S_OK)
                {
                g_fHttpServerInitialized = TRUE;
                }
            }
        }
    else
        {
        RpcStatus = RPC_S_OK;
        }
    GlobalMutexClear();

    return RpcStatus;
}

#if 1

#define ShouldUseWinHttp(x)        (TRUE)

#else
BOOL ShouldUseWinHttp (
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials
    )
/*++

Routine Description:

    Based on http credentials determines whether WinHttp
    should be used or raw sockets.

Arguments:

    HttpCredentials - transport credentials

Return Value:

    non-zero - WinHttp should be used. 0 means it is not
    necessary to use WinHttp.

--*/
{
    RPC_STATUS RpcStatus;

    if (AlwaysUseWinHttp)
        return 1;

    if (HttpCredentials == NULL)
        return 0;

    if (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
        return 1;

    if (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME)
        return 1;

    if (HttpCredentials->TransportCredentials)
        return 1;

    if (HttpCredentials->NumberOfAuthnSchemes)
        return 1;

    if (HttpCredentials->AuthnSchemes)
        return 1;

    if (HttpCredentials->ServerCertificateSubject)
        return 1;

    return 0;
}
#endif

void CALLBACK HTTP2PingTimerCallback(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired  // reason
    )
/*++

Routine Description:

    A periodic timer fired. Reference it, and dispatch to
    the appropriate object.

Arguments:

    lpParameter - the parameter supplied when the timer was
        registered. In our case the HTTP2PingOriginator object

    TimerOrWaitFired - the reason for the callback. Must be timer
        in our case.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2PingOriginator *PingOriginator;
    RPC_STATUS RpcStatus;
    THREAD *Thread;

    ASSERT(TimerOrWaitFired);

    Thread = ThreadSelf();
    // if we can't initialize the thread object, we just return. Worst case
    // the connection will fall apart due to the timeout. That's ok.
    if (Thread == NULL)
        return;

    PingOriginator = (HTTP2PingOriginator *)lpParameter;
    RpcStatus = PingOriginator->ReferenceFromCallback();

    if (RpcStatus == RPC_S_OK)
        PingOriginator->TimerCallback();
}

void CALLBACK HTTP2TimeoutTimerCallback(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired  // reason
    )
/*++

Routine Description:

    A one time timer fired. Dispatch to
    the appropriate object.

Arguments:

    lpParameter - the parameter supplied when the timer was
        registered.  In our case the address of a TimerContext object.

    TimerOrWaitFired - the reason for the callback. Must be timer
        in our case.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    TimerContext *pTimer;
    RPC_STATUS RpcStatus;

    ASSERT(TimerOrWaitFired);

    // REVIEW - if this fails, offload to an RPC worker thread?
    ThreadSelf();

    pTimer = (TimerContext *)lpParameter;
    pTimer->Parent->TimeoutExpired(pTimer);
}

void CALLBACK WinHttpCallback (
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    )
/*++

Routine Description:

    The WinHttp callback routine.

Arguments:

    hInternet - The hSession handle specified in a call to WinHttpSetStatusCallback.

    dwContext - Depends on the callback.  May be the Context argument to WinHttpSendRequest

    dwInternetStatus - Status with which an async IO completed.

    lpvStatusInformation - Additional info depending on the callback.

    dwStatusInformationLength - Additional info depending on the callback.

Return Value:

--*/
{
    HTTP2WinHttpTransportChannel *TransportChannel = (HTTP2WinHttpTransportChannel *) dwContext;
    WINHTTP_ASYNC_RESULT *AsyncResult;
    void *SendContext;
    BYTE *Buffer;
    RPC_STATUS RpcStatus;
    ULONG Api;
    BOOL HttpResult;
    ULONG StatusCode;
    ULONG StatusCodeLength;

    // WinHttp bug #541722 - bogus handles can be signalled if we do SSL through proxy. Ignore them
    if (dwContext == NULL)
        return;

    LOG_FN_OPERATION_ENTRY2(HTTP2LOG_OPERATION_WINHTTP_CALLBACK, HTTP2LOG_OT_WINHTTP_CALLBACK, TransportChannel, dwInternetStatus);

    // N.B. After setting the event or posting a runtime event, do not touch
    // the TransportChannel - it could be gone
    switch (dwInternetStatus)
        {
        case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:
            if (TransportChannel->State == whtcsSendingRequest)
                TransportChannel->VerifyServerCredentials();
            break;

        case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
            ASSERT(TransportChannel->State == whtcsSendingRequest);

            // This signals the async completion of WinHttpSendRequest.
            TransportChannel->State = whtcsSentRequest;
            TransportChannel->AsyncError = RPC_S_OK;
            ASSERT(TransportChannel->SyncEvent);
            SetEvent(TransportChannel->SyncEvent);
            break;

        case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
            ASSERT(TransportChannel->State == whtcsReceivingResponse);

            // This signals the async completion of WinHttpReceiveResponse.
            TransportChannel->State = whtcsReceivedResponse;
            TransportChannel->AsyncError = RPC_S_OK;
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DELAYED_RECV,
                TransportChannel
                );
            break;

        case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
            ASSERT(TransportChannel->State == whtcsReceivedResponse);

            TransportChannel->AsyncError = RPC_S_OK;

            // Get the bytes read.
            // Since we query for the data available before a receive, we should
            // receive at least the amount the query has promissed.
            ASSERT(TransportChannel->NumberOfBytesTransferred <= dwStatusInformationLength);
            TransportChannel->NumberOfBytesTransferred = dwStatusInformationLength;

            // This signals the async completion of WinHttpRead.
            ASSERT(TransportChannel->SyncEvent);
            SetEvent(TransportChannel->SyncEvent);
            break;

        case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
            if (TransportChannel->State == whtcsDraining)
                {
                // harvest the bytes available
                TransportChannel->AsyncError = RPC_S_OK;
                TransportChannel->NumberOfBytesTransferred = *(ULONG *)lpvStatusInformation;
                TransportChannel->ContinueDrainChannel();
                }
            else
                {
                ASSERT(TransportChannel->State == whtcsReading);

                TransportChannel->State = whtcsReceivedResponse;

                // A read has completed asyncronously - issue a callback.
                TransportChannel->AsyncError = RPC_S_OK;
                // harvest the bytes available
                TransportChannel->NumberOfBytesTransferred = *(ULONG *)lpvStatusInformation;
                (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                    TransportChannel
                    );
                }
            break;

        case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:
            ASSERT(TransportChannel->State == whtcsWriting);

            TransportChannel->AsyncError = RPC_S_OK;

            // get the bytes written
            TransportChannel->NumberOfBytesTransferred = *(ULONG *)lpvStatusInformation;
            // A write has completed asyncronously - issue a callback.
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                TransportChannel
                );
            break;

        case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
            // An async IO has failed.  The async IO that can be outstanding is
            // from the following APIs:
            //
            // WinHttpSendRequest, WinHttpReceiveResponse, WinHttpReadData,
            // WinHttpWriteData.
            //
            // Conditions when async IO is outstanding for these APIs correpsond to the
            // states of: whtcsSendingRequest, whtcsReceivingResponse, whtcsReading, 
            // whtcsWriting respectively.
            //
            // We are also notified of the failed API via dwResult field of WINHTTP_ASYNC_RESULT.
            //
            // WinHttpSendRequest and WinHttpReceiveResponse will wait for SyncEvent
            // to be raised.  We will notify them of the failure by setting AsyncError.
            // WinHttpReadData and WinHttpWriteData failures will be propagated to the upper layers
            // via an async callback.
            //
            AsyncResult = (WINHTTP_ASYNC_RESULT *) lpvStatusInformation;
            Api = AsyncResult->dwResult;

            LOG_FN_OPERATION_ENTRY2(HTTP2LOG_OPERATION_WHTTP_ERROR, HTTP2LOG_OT_WINHTTP_CALLBACK, UlongToPtr(Api), AsyncResult->dwError);

            switch (Api)
                {
                case API_SEND_REQUEST:
                    ASSERT(TransportChannel->State == whtcsSendingRequest);
                    // the only two values allowed here are ok or access denied
                    // (which means we didn't like the server certificate name).
                    ASSERT((TransportChannel->AsyncError == RPC_S_OK)
                        || (TransportChannel->AsyncError == RPC_S_INTERNAL_ERROR)
                        || (TransportChannel->AsyncError == RPC_S_ACCESS_DENIED) );
                    TransportChannel->State = whtcsSentRequest;
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_NAME_NOT_RESOLVED,
                        ERROR_NOT_ENOUGH_MEMORY,
                        ERROR_COMMITMENT_LIMIT,
                        ERROR_WINHTTP_OPERATION_CANCELLED,
                        ERROR_WINHTTP_INTERNAL_ERROR
                        } END_VALIDATE;

                    ASSERT (AsyncResult->dwError != ERROR_WINHTTP_RESEND_REQUEST);

                    // if not access denied, make it send failed
                    if (TransportChannel->AsyncError != RPC_S_ACCESS_DENIED)
                        TransportChannel->AsyncError = RPC_P_SEND_FAILED;
                    ASSERT(TransportChannel->SyncEvent);
                    SetEvent(TransportChannel->SyncEvent);
                    break;

                case API_READ_DATA:
                    ASSERT(TransportChannel->State == whtcsReceivedResponse);

                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CONNECTION_ERROR
                        } END_VALIDATE;

                    // This signals the async completion of WinHttpRead.
                    TransportChannel->AsyncError = RPC_P_RECEIVE_FAILED;
                    ASSERT(TransportChannel->SyncEvent);
                    SetEvent(TransportChannel->SyncEvent);
                    break;

                case API_RECEIVE_RESPONSE:
                    ASSERT(TransportChannel->State == whtcsReceivingResponse);
                    TransportChannel->State = whtcsReceivedResponse;
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_OPERATION_CANCELLED,
                        ERROR_NOT_ENOUGH_MEMORY,
                        ERROR_COMMITMENT_LIMIT,
                        ERROR_WINHTTP_LOGIN_FAILURE
                        } END_VALIDATE;

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        TransportChannel->AsyncError = RPC_P_AUTH_NEEDED;
                    else
                        TransportChannel->AsyncError = RPC_P_RECEIVE_FAILED;

                    (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DELAYED_RECV,
                        TransportChannel
                        );
                    break;

                case API_QUERY_DATA_AVAILABLE:
                    // if we get closed while receiving data, we can be
                    // in draining state
                    ASSERT((TransportChannel->State == whtcsReading)
                        || (TransportChannel->State == whtcsDraining));
                    TransportChannel->State = whtcsReceivedResponse;
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_OPERATION_CANCELLED
                        } END_VALIDATE;

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        {
                        ASSERT(0);
                        }

                    TransportChannel->AsyncError = RPC_P_RECEIVE_FAILED;
                    (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                        TransportChannel
                        );
                    break;

                case API_WRITE_DATA:
                    ASSERT(TransportChannel->State == whtcsWriting);
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_OPERATION_CANCELLED
                        } END_VALIDATE;

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        {
                        ASSERT(0);
                        }

                    TransportChannel->AsyncError = RPC_P_SEND_FAILED;
                    (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                        TransportChannel
                        );
                    break;

                default:
                    ASSERT(0);
                }

            break;

        default:
            // don't care about the other notifications
            break;
        }

    LOG_FN_OPERATION_EXIT2(HTTP2LOG_OPERATION_WINHTTP_CALLBACK, HTTP2LOG_OT_WINHTTP_CALLBACK, TransportChannel, dwInternetStatus);
};

RPC_STATUS WaitForSyncSend (
    IN BASE_ASYNC_OBJECT *Connection,
    IN HTTP2SendContext *SendContext,
    IN HTTP2VirtualConnection *Parent,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Waits for a synchronous send to complete.

Arguments:

    Connection - run time view of the transport connection

    SendContext - the send context

    Parent - the parent virtual connection (used to abort)

    fDisableCancelCheck - don't do checks for cancels. Can be
        used as optimization

    Timeout - the call timeout

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2Channel *ThisChannel;

    // the IO was submitted. Wait for it.
    // If fDisableCancelCheck, make the thread wait non-alertably,
    // otherwise, make it wait alertably.
    RpcStatus = UTIL_GetOverlappedHTTP2ResultEx(Connection,
                                        &SendContext->Write.ol,
                                        SendContext->u.SyncEvent,
                                        !fDisableCancelCheck,   // bAlertable
                                        Timeout);

    if (RpcStatus != RPC_S_OK)
        {
        Parent->AbortChannels(RpcStatus);

        if ((RpcStatus == RPC_S_CALL_CANCELLED) || (RpcStatus == RPC_P_TIMEOUT))
            {
            // Wait for the write to finish.  Since we closed the
            // connection this won't take very long.
            UTIL_WaitForSyncHTTP2IO(&SendContext->Write.ol,
                               SendContext->u.SyncEvent,
                               FALSE,   // fAlertable
                               INFINITE     // Timeout
                               );
            }
        }

    return(RpcStatus);
}

void
AddBufferQueueToChannel (
    IN LIST_ENTRY *NewBufferHead,
    IN HTTP2Channel *Channel
    )
/*++

Routine Description:

    Adds all the send contexts from the queue to the front of given channel.
    Presumably the channel has a plug channel down somewhere which does
    the actual ordering work

Arguments:

    NewBufferHead - the list head of the buffer queue. They are assumed to
        be in order.

    Channel - the channel to make the sends on

Return Value:

Notes:

    The new channel must still be plugged.

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *PrevListEntry;
    RPC_STATUS RpcStatus;

    // Queue the sends to the front of the new channel
    // walk the queue in reverse order and add it to the plug channel
    CurrentListEntry = NewBufferHead->Blink;
    while (CurrentListEntry != NewBufferHead)
        {
        QueuedSendContext 
            = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        PrevListEntry = CurrentListEntry->Blink;

        QueuedSendContext->Flags |= SendContextFlagPutInFront;

        // Setting this flag ensures that the send will not fail even for
        // a channel with a pending abort.  This is necessary to force a send
        // and get the send context queued inside the plug channel.
        QueuedSendContext->Flags |= SendContextFlagPluggedChannel;

        RpcStatus = Channel->Send(QueuedSendContext);

        // since we know the channel is plugged yet, this cannot fail
        ASSERT(RpcStatus == RPC_S_OK);
        
        CurrentListEntry = PrevListEntry;
        }
}

void
RPC_CLIENT_PROCESS_IDENTIFIER::SetHTTP2ClientIdentifier (
    IN void *Buffer,
    IN size_t BufferSize,
    IN BOOL fLocal
    )
/*++

Routine Description:

    sets an HTTP2 client identifier

Arguments:

    Buffer - the buffer with the client identifier.

    BufferSize - the number of bytes containg valid 
        info in the buffer.

    fLocal - non-zero if client is local. 0 otherwise.

Return Value:

--*/
{
    BYTE *CurrentPosition;

    this->fLocal = fLocal;
    this->ZeroPadding = 0;
    ASSERT(sizeof(u.ULongClientId) >= BufferSize);
    RpcpMemorySet(u.ULongClientId, 0, sizeof(u.ULongClientId) - BufferSize);
    CurrentPosition = ((BYTE *)u.ULongClientId) + sizeof(u.ULongClientId) - BufferSize;
    RpcpMemoryCopy(CurrentPosition, Buffer, BufferSize);    
}


RPC_STATUS
HttpSendIdentifyResponse(
    IN SOCKET Socket
    )
/*++

Routine Description:

    <TBS>

Arguments:

    Socket -

Return Value:

    None

--*/
{
    RPC_STATUS  Status = RPC_S_OK;
    int         iBytes;
    char        *pszId = HTTP_SERVER_ID_STR;
    DWORD       dwSize;

    iBytes = send(
                Socket,
                pszId,
                HTTP_SERVER_ID_STR_LEN,
                0
                );

    if (iBytes == SOCKET_ERROR)
        {
        VALIDATE(GetLastError())
            {
            WSAENETDOWN,
            WSAECONNREFUSED,
            WSAECONNRESET,
            WSAENETRESET,
            WSAETIMEDOUT,
            WSAECONNABORTED,
            WSASYSCALLFAILURE
            } END_VALIDATE;

        Status = RPC_S_OUT_OF_RESOURCES;
        }

    return Status;
}

RPC_STATUS
HTTP_TryConnect( SOCKET Socket,
                 char  *pszProxyMachine,
                 USHORT iPort             )
/*++

Routine Description:

    Used by HTTP_Open() to actually call the connect(). HTTP_Open() will try
    first to reach the RPC Proxy directly, if it can't then it will call this
    routine again to try to reach an HTTP proxy (i.e. MSProxy for example).

Arguments:

    Socket          - The socket to use in the connect().
    pszProxyMachine - The name of the machine to try to connect() to.
    iPort           - The port to connect() on.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS  Status = RPC_S_OK;
    WS_SOCKADDR ProxyServer;
    RPC_CHAR pwszBuffer[MAX_HTTP_COMPUTERNAME_SIZE+1];

    //
    // Check for empty proxy machine name:
    //
    if ( (!pszProxyMachine) || (*pszProxyMachine == 0))
        {
        return RPC_S_SERVER_UNAVAILABLE;
        }

    memset((char *)&ProxyServer, 0, sizeof(ProxyServer));

    //
    // Resolve the machine name (or dot-notation address) into
    // a network address. If that works then try to connect
    // using the supplied port.
    //
    SimpleAnsiToPlatform(pszProxyMachine,pwszBuffer);
    IP_ADDRESS_RESOLVER resolver(pwszBuffer, 
        cosClient,
        ipvtuIPv4       // IP version to use
        );

    Status = resolver.NextAddress(&ProxyServer.inetaddr);
    if (Status == RPC_S_OK)
        {
        ProxyServer.inetaddr.sin_family = AF_INET;
        ProxyServer.inetaddr.sin_port   = htons(iPort);

        //
        // Try to connect...
        //
        if (SOCKET_ERROR == connect(Socket,
                                    (struct sockaddr *)&ProxyServer.inetaddr,
                                    sizeof(ProxyServer.inetaddr)))
            {
            #if DBG_ERROR
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           "HTTP_Open(): connect() failed: %d\n",
                           WSAGetLastError()));

            #endif // DBG_ERROR

            VALIDATE(GetLastError())
                {
                WSAENETDOWN,
                WSAEADDRNOTAVAIL,
                WSAECONNREFUSED,
                WSAECONNABORTED,
                WSAENETUNREACH,
                WSAEHOSTUNREACH,
                WSAENOBUFS,
                WSAETIMEDOUT
                } END_VALIDATE;

            Status = RPC_S_SERVER_UNAVAILABLE;
            }
        }

    return Status;
}

RPC_STATUS HTTP2Cookie::Create (
    void
    )
/*++

Routine Description:

    Create a cryptographically strong HTTP2 cookie

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* failure

--*/
{
    return GenerateRandomNumber(Cookie, sizeof(Cookie));
}

void HTTPResolverHint::VerifyInitialized (
    void
    )
/*++

Routine Description:

    Verify that the resolver hint is properly initialized and consistent

Arguments:

Return Value:

--*/
{
    ASSERT(RpcServer);
    ASSERT(ServerPort != 0);
    ASSERT(RpcProxy);
    ASSERT(RpcProxyPort != 0);
    if (HTTPProxy)
        {
        ASSERT(HTTPProxyPort != 0);
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_Initialize (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * /* NetworkAddress */,
    IN RPC_CHAR * /* NetworkOptions */,
    IN BOOL /* fAsync */
    )
/*++

Routine Description:

    Called by the runtime to do initial initialization of the transport
    object. The purpose of this initialization is to allow the transport
    to do some minimal initialization sufficient to ensure ordely 
    destruction in case of failure.

Arguments:

    ThisConnection - an uninitialized connection allocated by the runtime
    NetworkAddress - ignored
    NetworkOptions - ignored
    fAsync - ignored

Return Value:

    RPC_S_OK for success of RPC_S_* / Win32 error for error.

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;

    BaseObject->id = INVALID_PROTOCOL_ID;

    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
HTTP_CheckIPAddressForDirectConnection (
    IN HTTPResolverHint *Hint
    )
/*++

Routine Description:

    Checks if the rpc proxy server address given in the hint should be used
    for direct connection based on registry settings

Arguments:

    Hint - the resolver hint

Return Value:

    RPC_S_OK or RPC_S_* / win32 error code

--*/
{
    HKEY RpcOptionsKey;
    DWORD Status;
    DWORD KeyType;
    const RPC_CHAR *UseProxyForIPAddrIfRDNSFailsRegKey = RPC_CONST_STRING("UseProxyForIPAddrIfRDNSFails");
    const RPC_CHAR *RpcRegistryOptions =
                RPC_CONST_STRING("Software\\Microsoft\\Rpc");
    DWORD UseProxyForIPAddrIfRDNSFails;
    DWORD RegKeySize;
    int err;
    ADDRINFO AddrHint;
    ADDRINFO *AddrInfo;

    RpcpMemorySet(&AddrHint, 0, sizeof(ADDRINFO));
    AddrHint.ai_flags = AI_NUMERICHOST;

    err = getaddrinfo(Hint->RpcProxy, 
        NULL, 
        &AddrHint,
        &AddrInfo
        );

    ASSERT((err != EAI_BADFLAGS)
        && (err != EAI_SOCKTYPE));

    if (err)
        {
        // the address was not numeric. It's not up to us to tell
        // where this should go
        return RPC_S_OK;
        }

    // assume direct connection for now    
    Hint->AccessType = rpcpatDirect;

    Status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         (const RPC_SCHAR *)RpcRegistryOptions,
                         &RpcOptionsKey );

    if (Status != ERROR_SUCCESS)
        {
        // direct connection is already set
        goto CleanupAndExit;
        }

    RegKeySize = sizeof(DWORD);
    Status = RegQueryValueEx(RpcOptionsKey,
                             (const RPC_SCHAR *)UseProxyForIPAddrIfRDNSFailsRegKey,
                             NULL,
                             &KeyType,
                             (LPBYTE)&UseProxyForIPAddrIfRDNSFails,
                             &RegKeySize);

    RegCloseKey(RpcOptionsKey);

    if ( (Status != ERROR_SUCCESS) ||
         (KeyType != REG_DWORD) )
        {
        // direct connection is already set
        goto CleanupAndExit;
        }

    if (UseProxyForIPAddrIfRDNSFails != 1)
        {
        // direct connection is already set
        goto CleanupAndExit;
        }

    err = getnameinfo(AddrInfo->ai_addr,
        AddrInfo->ai_addrlen,
        NULL,
        0,
        NULL,
        0,
        NI_NAMEREQD
        );

    if (err)
        {
        Hint->AccessType = rpcpatHTTPProxy;
        }
    // else
    // direct connection is already set

CleanupAndExit:
    freeaddrinfo(AddrInfo);

    return RPC_S_OK;
}

void
RPC_ENTRY HTTP_FreeResolverHint (
    IN void *ResolverHint
    )
/*++

Routine Description:

    Called by the runtime to free the resolver hint.

Arguments:

    ResolverHint - the resolver hint created by the transport.

Return Value:

--*/
{
    HTTPResolverHint *Hint = (HTTPResolverHint *)ResolverHint;

    Hint->FreeHTTPProxy();
    Hint->FreeRpcProxy();
    Hint->FreeRpcServer();
}

RPC_STATUS
RPC_ENTRY HTTP_CopyResolverHint (
    IN void *TargetResolverHint,
    IN void *SourceResolverHint,
    IN BOOL SourceWillBeAbandoned
    )
/*++

Routine Description:

    Tells the transport to copy the resolver hint from Source to Target

Arguments:

    TargetResolverHint - pointer to the target resolver hint

    SourceResolverHint - pointer to the source resolver hint

    SourceWillBeAbandoned - non-zero if the source hint was in temporary
        location and will be abandoned. Zero otherwise.

Return Value:

    if SourceWillBeAbandoned is specified, this function is guaranteed
    to return RPC_S_OK. Otherwise, it may return RPC_S_OUT_OF_MEMORY as well.

--*/
{
    HTTPResolverHint *TargetHint = (HTTPResolverHint *)TargetResolverHint;
    HTTPResolverHint *SourceHint = (HTTPResolverHint *)SourceResolverHint;
    ULONG HTTPProxyNameLength;

    ASSERT(TargetHint != SourceHint);

    // bulk copy most of the stuff, and then hand copy few items
    RpcpMemoryCopy(TargetHint, SourceHint, sizeof(HTTPResolverHint));

    if (SourceWillBeAbandoned)
        {
        // the source hint will be abandoned - just hijack all
        // embedded pointers
        if (SourceHint->RpcServer == SourceHint->RpcServerName)
            TargetHint->RpcServer = TargetHint->RpcServerName;
        SourceHint->HTTPProxy = NULL;
        SourceHint->RpcProxy = NULL;
        SourceHint->RpcServer = NULL;
        }
    else
        {
        TargetHint->HTTPProxy = NULL;
        TargetHint->RpcProxy = NULL;
        TargetHint->RpcServer = NULL;
        if (SourceHint->HTTPProxy)
            {
            HTTPProxyNameLength = RpcpStringLengthA(SourceHint->HTTPProxy) + 1;
            TargetHint->HTTPProxy = new char [HTTPProxyNameLength];
            if (TargetHint->HTTPProxy == NULL)
                goto FreeTargetHintAndExit;
            RpcpMemoryCopy(TargetHint->HTTPProxy, SourceHint->HTTPProxy, HTTPProxyNameLength);
            }

        TargetHint->RpcProxy = new char [SourceHint->ProxyNameLength + 1];
        if (TargetHint->RpcProxy == NULL)
            goto FreeTargetHintAndExit;
        RpcpMemoryCopy(TargetHint->RpcProxy, SourceHint->RpcProxy, SourceHint->ProxyNameLength + 1);

        if (SourceHint->RpcServer == SourceHint->RpcServerName)
            TargetHint->RpcServer = TargetHint->RpcServerName;
        else
            {
            TargetHint->RpcServer = new char [SourceHint->ServerNameLength + 1];
            if (TargetHint->RpcServer == NULL)
                goto FreeTargetHintAndExit;
            RpcpMemoryCopy(TargetHint->RpcServer, SourceHint->RpcServer, SourceHint->ServerNameLength + 1);
            }
        }

    return RPC_S_OK;

FreeTargetHintAndExit:
    TargetHint->FreeHTTPProxy();
    TargetHint->FreeRpcProxy();
    TargetHint->FreeRpcServer();

    return RPC_S_OUT_OF_MEMORY;
}

int
RPC_ENTRY HTTP_CompareResolverHint (
    IN void *ResolverHint1,
    IN void *ResolverHint2
    )
/*++

Routine Description:

    Tells the transport to compare the given 2 resolver hints

Arguments:

    ResolverHint1 - pointer to the first resolver hint

    ResolverHint2 - pointer to the second resolver hint

Return Value:

    (same semantics as memcmp)
    0 - the resolver hints are equal
    non-zero - the resolver hints are not equal

--*/
{
    HTTPResolverHint *Hint1 = (HTTPResolverHint *)ResolverHint1;
    HTTPResolverHint *Hint2 = (HTTPResolverHint *)ResolverHint2;

    if (Hint1->Version != Hint2->Version)
        return 1;

    if (Hint1->ServerPort != Hint2->ServerPort)
        return 1;

    if (Hint1->ServerNameLength != Hint2->ServerNameLength)
        return 1;

    return RpcpMemoryCompare(Hint1->RpcServer, Hint2->RpcServer, Hint1->ServerNameLength);
}

RPC_STATUS RPC_ENTRY 
HTTP_SetLastBufferToFree (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN void *Buffer
    )
/*++

Routine Description:

    Tells the transport what buffer to free when it is done with the last send

Arguments:

    ThisConnection - connection to act on.

    Buffer - pointer of the buffer to free. Must be freed using 
        RpcFreeBuffer/I_RpcTransConnectionFreePacket

Return Value:

    RPC_S_OK - the last buffer to free was accepted by the transport

    RPC_S_CANNOT_SUPPORT - the transport does not support this functionality

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2ServerVirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    if (BaseObject->id == HTTPv2)
        {
        // this must be called on server connections only
        ASSERT(BaseObject->type == (COMPLEX_T | CONNECTION | SERVER));
        VirtualConnection = (HTTP2ServerVirtualConnection *) ThisConnection;

        VirtualConnection->SetLastBufferToFree(Buffer);

        return RPC_S_OK;
        }
    else
        {
        return RPC_S_CANNOT_SUPPORT;
        }
}
    

RPC_STATUS
RPC_ENTRY
HTTP_Open (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN PVOID ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection

    ProtocolSeqeunce - "ncacn_http"

    NetworkAddress - The name of the server, either a dot address or DNS name

    NetworkOptions - the http binding handle options (e.g. HttpProxy/RpcProxy)

    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite

    SendBufferSize - ignored

    RecvBufferSize - ignored

    ResolverHint - pointer to the resolver hint object

    fHintInitialized - non-zero if the ResolverHint points to previously
        initialized memory. 0 otheriwse.

    CallTimeout - call timeout in milliseconds

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given

    AdditionalCredentials - additional credentials that we were given.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    HTTPResolverHint *Hint = (HTTPResolverHint *)ResolverHint;
    char *RpcProxyPort = NULL;
    char *HttpProxyPort = NULL;
    BOOL NetworkAddressAllocated;
    BOOL Result;
    char PortString[20];
    ULONG   StringLength;
    RPC_STATUS Status;
    RPC_STATUS RetValue;
    PWS_CCONNECTION p = (PWS_CCONNECTION) ThisConnection;
    HTTP2ClientVirtualConnection *VirtualConnection = (HTTP2ClientVirtualConnection *) ThisConnection;
    BOOL Retry;
    BOOL fUserModeConnection;
    BOOL HintNeedsCleanup;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
    BOOL UseSSLPort;
    ULONG HostAddr;
    BOOL LocalDirect;

    ASSERT(NetworkAddress);
    ASSERT(Endpoint);

    ASSERT(RpcpStringCompare(ProtocolSequence, L"ncacn_http") == 0);

    if (AdditionalTransportCredentialsType != 0)
        {
        if (AdditionalTransportCredentialsType != RPC_C_AUTHN_INFO_TYPE_HTTP)
            {
            ASSERT(0);
            return RPC_S_CANNOT_SUPPORT;
            }
        ASSERT(AdditionalCredentials != NULL);
        }

    HttpCredentials = (RPC_HTTP_TRANSPORT_CREDENTIALS_W *) AdditionalCredentials;

    Status = InitializeHttpClientIfNecessary();
    if (Status != RPC_S_OK)
        return Status;

    HintNeedsCleanup = FALSE;

    // Check the resolver hint. If not initialized, initialize all
    // fields in the hint
    if (fHintInitialized == FALSE)
        {
        RpcProxyPort = NULL;
        HttpProxyPort = NULL;
        Hint->HTTPProxy = NULL;
        Hint->RpcProxy = NULL;
        Hint->RpcServer = NULL;

        Status = Hint->AssociationGroupId.Create();
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        // the TCP transport should have been initialized by now
        ASSERT(HTTPTransInfo);

        Status = HTTPTransInfo->StartServerIfNecessary();
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        StringLength = RpcpStringLength(NetworkAddress);

        //
        // RPC Server Name
        //
        if (StringLength == 0)
            {
            // no server name was specified. Use local machine name
            NetworkAddress = AllocateAndGetComputerName(cnaNew, 
                ComputerNamePhysicalDnsFullyQualified,
                0,      // ExtraBytes
                0,      // Starting offset
                &StringLength
                );

            if (NetworkAddress == NULL)
                return RPC_S_OUT_OF_MEMORY;
            NetworkAddressAllocated = TRUE;
            }
        else
            {
            // make space for terminating NULL
            StringLength += 1;
            NetworkAddressAllocated = FALSE;
            }

        // StringLength is in characters and includes terminating null
        if (StringLength <= sizeof(Hint->RpcServerName))
            {
            Hint->RpcServer = Hint->RpcServerName;
            }
        else
            {
            Hint->RpcServer = new char [StringLength];
            if (Hint->RpcServer == NULL)
                {
                if (NetworkAddressAllocated)
                    delete NetworkAddress;
                return RPC_S_OUT_OF_MEMORY;
                }
            }

        SimplePlatformToAnsi(NetworkAddress, Hint->RpcServer);

        // subtract 1 to eliminate terminating NULL
        Hint->ServerNameLength = StringLength - 1;

        if (NetworkAddressAllocated)
            {
            delete NetworkAddress;
            NetworkAddress = NULL;
            }

        // by now Hint->RpcServer points to the ascii name for the server
        ASSERT(Hint->RpcServer);

        //
        // At this point, we know the destination server/port, but don't yet know
        // if we need to go through an HTTP proxy, and what the IIS RPC proxy
        // machine is. We'll get these, if specified from the network options
        // and the registry.
        //
        if (HttpCredentials && (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL))
            UseSSLPort = TRUE;
        else
            UseSSLPort = FALSE;

        Result = HttpParseNetworkOptions(
                 NetworkOptions,
                 Hint->RpcServer,
                 &(Hint->RpcProxy),
                 &RpcProxyPort,
                 UseSSLPort,
                 &(Hint->HTTPProxy),
                 &HttpProxyPort,
                 &(Hint->AccessType),
                 (unsigned long *) &Status
                 );

        if (Result == FALSE)
            {
            ASSERT(Status != RPC_S_OK);
            Hint->FreeRpcServer();
            return Status;
            }
        else
            {
            if (Hint->AccessType != rpcpatDirect)
                {
                ASSERT(Hint->HTTPProxy);
                // if the proxy name is empty, set the method to direct
                if (Hint->HTTPProxy[0] == 0)
                    Hint->AccessType = rpcpatDirect;
                }
            ASSERT(Status == RPC_S_OK);
            HintNeedsCleanup = TRUE;
            }

        Status = EndpointToPortNumber(Endpoint, Hint->ServerPort);
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        Status = EndpointToPortNumberA(RpcProxyPort, Hint->RpcProxyPort);
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        Hint->ProxyNameLength = RpcpStringLengthA(Hint->RpcProxy);

        if (Hint->HTTPProxy)
            {
            Status = EndpointToPortNumberA(HttpProxyPort, Hint->HTTPProxyPort);
            if (Status != RPC_S_OK)
                {
                RetValue = Status;
                goto AbortAndCleanup;
                }
            }

        // we will optimistically presume that we can talk HTTP2
        // until proven wrong
        Hint->Version = httpvHTTP2;

        // by now the resolver hint is fully initialized. fall through
        // the case that has initialized resolver hint
        }

    Hint->VerifyInitialized();

    // disable retries by default. If we have to loop around, we will set it to TRUE
    Retry = FALSE;

    do
        {
        // we have it all now.
        if (Hint->Version == httpvHTTP2)
            {
            // use explicit placement
            VirtualConnection = new (ThisConnection) HTTP2ClientVirtualConnection (
                (RPC_HTTP_TRANSPORT_CREDENTIALS *)AdditionalCredentials,
                &Status);
            if (Status != RPC_S_OK)
                {
                VirtualConnection->HTTP2ClientVirtualConnection::~HTTP2ClientVirtualConnection();
                RetValue = Status;
                goto AbortAndCleanup;
                }

            Status = VirtualConnection->ClientOpen(Hint,
                fHintInitialized,
                ConnTimeout,
                CallTimeout
                );

            // if we got a protocol error or a receive failed, and
            // we don't have credentials, fall back to old protocol.
            if (
                (
                 (Status == RPC_S_PROTOCOL_ERROR)
                 || 
                 (Status == RPC_P_RECEIVE_FAILED)
                )
                &&
                (HttpCredentials == NULL)
               )
                {
                // cause the loop to start over.
                // make sure next iteration it tries old http
                Hint->Version = httpvHTTP;
                VirtualConnection->HTTP2ClientVirtualConnection::~HTTP2ClientVirtualConnection();
                Retry = TRUE;
                }
            else
                {
                if ((Status == RPC_S_PROTOCOL_ERROR)
                    || 
                    (Status == RPC_P_RECEIVE_FAILED))
                    {
                    Status = RPC_S_SERVER_UNAVAILABLE;
                    }

                ASSERT(Status != RPC_P_PACKET_CONSUMED);
                RetValue = Status;
                VirtualConnection->id = HTTPv2;
                if (Status == RPC_S_OK)
                    goto CleanupAndExit;
                else
                    {
                    VirtualConnection->HTTP2ClientVirtualConnection::~HTTP2ClientVirtualConnection();
                    goto AbortAndCleanup;
                    }
                }
            }
        else
            {
            ASSERT(Hint->Version == httpvHTTP);

            // HTTP1 doesn't support proxy discovery. If we don't know
            // just assume local and hope it works.
            if (Hint->AccessType == rpcpatUnknown)
                Hint->AccessType = rpcpatDirect;

            // we need to re-initialize the connection object with old
            // format connection
            WS_Initialize(p, 0, 0, 0);

            // use explicit placement to initialize the vtable. We need this to
            // be able to use the virtual functions
            p = new (p) WS_CLIENT_CONNECTION;

            p->id = HTTP;

            // Call common open function. Note that for http connection
            // WS_Open will just open a socket. That's all we need right now.
            Status = WS_Open(p, 
                NULL, 
                ConnTimeout, 
                SendBufferSize, 
                RecvBufferSize, 
                CallTimeout,
                FALSE       // fHTTP2Open
                );
            if (Status != RPC_S_OK)
                {
                RetValue = Status;
                goto AbortAndCleanup;
                }

            //
            // WS_Open has been successfully called. Do connect() work here...
            //

            // If AccessType is direct, then we are going to try to directly
            // connect to the IIS that is the RPC Proxy first. If that suceeds,
            // then we will just tunnel to the RPC server from there. If it fails,
            // then we will try to go through an HTTP proxy (i.e. MSProxy server)
            // if one is available...
            if (Hint->AccessType != rpcpatHTTPProxy)
                {
                Status = HTTP_CheckIPAddressForDirectConnection(Hint);
                if (Status != RPC_S_OK)
                    {
                    RetValue = RPC_S_OUT_OF_MEMORY;
                    goto AbortAndCleanup;
                    }

                if (Hint->AccessType == rpcpatDirect)
                    {
                    Status = HTTP_TryConnect( p->Conn.Socket, Hint->RpcProxy, Hint->RpcProxyPort );
                    }
                }

            if ((Status != RPC_S_OK) || (Hint->AccessType != rpcpatDirect))
                {
                //
                // If we get here, then we are going to try to use an HTTP proxy first...
                //
                Status = HTTP_TryConnect( p->Conn.Socket, Hint->HTTPProxy, Hint->HTTPProxyPort );

                //
                // If we successfully connected to the HTTP proxy, then let's go on and
                // tunnel through to the RPC proxy:
                //
                if (Status != RPC_S_OK)
                    {
                    RetValue = RPC_S_SERVER_UNAVAILABLE;
                    goto Abort;
                    }

                PortNumberToEndpointA(Hint->RpcProxyPort, PortString);

                if (!HttpTunnelToRpcProxy(p->Conn.Socket,
                                          Hint->RpcProxy,
                                          PortString))
                    {
                    RetValue = RPC_S_SERVER_UNAVAILABLE;
                    goto Abort;
                    }
                }

            //
            // Finally, negotiate with the RPC proxy to get the connection through to
            // the RPC server.
            //

            PortNumberToEndpointA(Hint->ServerPort, PortString);

            if (!HttpTunnelToRpcServer( p->Conn.Socket,
                                        Hint->RpcServer,
                                        PortString ))
                {
                RetValue = RPC_S_SERVER_UNAVAILABLE;
                goto Abort;
                }

            fUserModeConnection = IsUserModeSocket(p->Conn.Socket, &RetValue);
            if (RetValue != RPC_S_OK)
                goto Abort;

            // if this is SAN or loadable transport not using true handles, go through Winsock
            if (fUserModeConnection)
                p = new (p) WS_SAN_CLIENT_CONNECTION;

            Retry = FALSE;
            }
        }
    while (Retry);

    RetValue = RPC_S_OK;
    goto CleanupAndExit;

Abort:
    p->WS_CONNECTION::Abort();

AbortAndCleanup:
    if (HintNeedsCleanup)
        {
        ASSERT(RetValue != RPC_S_OK);
        Hint->FreeRpcServer();
        Hint->FreeRpcProxy();
        Hint->FreeHTTPProxy();
        }

CleanupAndExit:

    // Creating a thread can fail with RPC_S_OUT_OF_THREADS
    // and the caller may not be prepared to deal with this error.
    if (RetValue == RPC_S_OUT_OF_THREADS)
        {
        RetValue = RPC_S_OUT_OF_RESOURCES;
        }

    VALIDATE (RetValue)
        {
        RPC_S_OK,
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_SERVER_UNAVAILABLE,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_SERVER_TOO_BUSY,
        RPC_S_INVALID_NETWORK_OPTIONS,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_INVALID_NET_ADDR,
        RPC_S_ACCESS_DENIED,
        RPC_S_INTERNAL_ERROR,
        RPC_S_SERVER_OUT_OF_MEMORY,
        RPC_S_CALL_CANCELLED
        } END_VALIDATE;

    if (RpcProxyPort != NULL)
        delete RpcProxyPort;

    if (HttpProxyPort != NULL)
        delete HttpProxyPort;

    if (Hint->ServerNameLength <= sizeof(Hint->RpcServerName))
        {
        ASSERT(Hint->RpcServer == Hint->RpcServerName);
        }

    return (RetValue);
}




RPC_STATUS
HTTP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags
    )
{
    RPC_STATUS RpcStatus;

    RpcStatus = InitializeHttpServerIfNecessary();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    return (TCP_ServerListenEx(
                ThisAddress,
                NetworkAddress,
                pEndpoint,
                PendingQueueSize,
                SecurityDescriptor,
                EndpointFlags,
                NICFlags,
                TRUE // HTTP!
                ));
}

void WINAPI ProxyIoCompletionCallback (
    IN LPEXTENSION_CONTROL_BLOCK lpECB,
    IN PVOID pContext,
    IN DWORD cbIO,
    IN DWORD dwError
    )
/*++

Routine Description:

    IIS io completion callback function

Arguments:

    lpECB - extension control block

    pContext - the IISChannel pointer.

    cbIO - Bytes transferred in the last operation

    dwError - status of the operation

Return Value:

--*/
{
    HTTP2IISTransportChannel *IISChannel;
    THREAD *Thread;

    Thread = ThreadSelf();
    if (Thread == NULL)
        return;     // abandon the completion if worse comes to worse.

    IISChannel = (HTTP2IISTransportChannel *)pContext;

    IISChannel->IOCompleted(cbIO, dwError);
}

BOOL RPCTransInitialized = FALSE;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN ULONG ConnectionType,
    IN USHORT *ServerAddress,
    IN USHORT *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    )
/*++

Routine Description:

    Entry point from the ISAPI extension. Called when a new
    connection request arrives at an in or out proxy.

Arguments:

    ConnectionType - currently RPC_PROXY_CONNECTION_TYPE_IN_PROXY or
        RPC_PROXY_CONNECTION_TYPE_OUT_PROXY to indicate the type of
        connection establishment request we have received
    ServerAddress - unicode network address of the server
    ServerPort - unicode port of the server
    ConnectionParameter - the Extension Control Block in this case.
    ProxyCallbackInterface - a callback interface to the proxy to perform
        various proxy specific functions

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

Note:

    This function and all its callees must ensure that if this function
    returns error, it doesn't call HSE_REQ_DONE_WITH_SESSION. If it
    return RPC_S_OK, it must call HSE_REQ_DONE_WITH_SESSION. If these 2
    rules are violated, IIS will AV.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    EXTENSION_CONTROL_BLOCK *ECB;
    void *IISContext;
    BOOL Result;
    RPC_TRANSPORT_INTERFACE TransInterface;
    TRANS_INFO *TransInfo;
    THREAD *ThisThread;
    HTTP2ProxyVirtualConnection *ProxyVirtualConnection;

    if (RPCTransInitialized == FALSE)
        {
        InitializeIfNecessary();

        GlobalMutexRequest();

        // all of the initialization here is idempotent.
        // If we fail midway, we don't have to un-initialize - 
        // next initialization attempt will pick up where we left.

        RpcStatus = OsfMapRpcProtocolSequence(FALSE,
            L"ncacn_http",
            &TransInfo);

        if (RpcStatus == RPC_S_OK)
            {
            ASSERT(TransInfo);

            if (HTTPTransInfo == NULL)
                HTTPTransInfo = TransInfo;

            RpcStatus = TransInfo->StartServerIfNecessary();

            if (RpcStatus == RPC_S_OK)
                {
                RpcStatus = InitializeDefaultChannelLifetime();

                if (RpcStatus == RPC_S_OK)
                    {
                    RpcStatus = InitializeActAsWebFarm();
                    if (RpcStatus == RPC_S_OK)
                        {
                        RpcStatus = InitializeMinConnectionTimeout();
                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = CookieCollection::InitializeInProxyCookieCollection();
                            if (RpcStatus == RPC_S_OK)
                                {
                                RpcStatus = CookieCollection::InitializeOutProxyCookieCollection();
                                if (RpcStatus == RPC_S_OK)
                                    {
                                    RpcStatus = InitializeReceiveWindows();
                                    }
                                }
                            }
                        }
                    }
                }
            }

        RPCTransInitialized = (RpcStatus == RPC_S_OK);
        GlobalMutexClear();

        if (RpcStatus != RPC_S_OK)
            {
            return RPC_S_OK;
            }
        }

    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (ConnectionType == RPC_PROXY_CONNECTION_TYPE_IN_PROXY)
        {
        ProxyVirtualConnection = new HTTP2InProxyVirtualConnection(&RpcStatus);
        }
    else
        {
        ASSERT(ConnectionType == RPC_PROXY_CONNECTION_TYPE_OUT_PROXY);
        ProxyVirtualConnection = new HTTP2OutProxyVirtualConnection(&RpcStatus);
        }

    if (ProxyVirtualConnection == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (RpcStatus != RPC_S_OK)
        {
        delete ProxyVirtualConnection;
        return RpcStatus;
        }

    RpcStatus = ProxyVirtualConnection->InitializeProxyFirstLeg(ServerAddress,
        ServerPort,
        ConnectionParameter,
        ProxyCallbackInterface,
        &IISContext
        );

    if (RpcStatus != RPC_S_OK)
        {
        delete ProxyVirtualConnection;
        return RpcStatus;
        }

    // we have initialized far enough. Associate callback
    // with this connection
    ECB = (EXTENSION_CONTROL_BLOCK *) ConnectionParameter;

    Result = ECB->ServerSupportFunction (ECB->ConnID,
        HSE_REQ_IO_COMPLETION,
        ProxyIoCompletionCallback,
        NULL,
        (LPDWORD)IISContext
        );

    if (Result == FALSE)
        {
        ProxyVirtualConnection->Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    // after we call StartProxy, it takes off on success and
    // we don't know whether we have a vconnection anymore. Thus
    // we must block rundowns until we are done with everything.
    ProxyVirtualConnection->BlockConnectionFromRundown();

    RpcStatus = ProxyVirtualConnection->StartProxy();
    if (RpcStatus != RPC_S_OK)
        {
        ProxyVirtualConnection->UnblockConnectionFromRundown();
        ProxyVirtualConnection->Abort();
        return RpcStatus;
        }

    ProxyVirtualConnection->EnableIISSessionClose();

    ProxyVirtualConnection->UnblockConnectionFromRundown();

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2IISDirectReceive (
    IN void *Context
    )
/*++

Routine Description:

    Direct notification from the thread pool to an IIS channel
    for a receive. The proxy stacks use that to post receives
    to themselves.

Arguments:

    Context - the HTTP2IISTransportChannel

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ((HTTP2IISTransportChannel *)Context)->DirectReceive();

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2DirectReceive (
    IN void *Context,
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection,
    OUT BOOL *IsServer
    )
/*++

Routine Description:

    Direct notification from the thread pool to a receiver
    for a receive. The stacks use that to post receives
    to themselves.

Arguments:

    Context - an instance of the HTTP2EndpointReceiver

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

    IsServer - true if this is the server 

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_RECV_COMPLETE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)Context);

    RpcStatus = ((HTTP2EndpointReceiver *)Context)->DirectReceiveComplete(
        ReceivedBuffer,
        ReceivedBufferLength,
        RuntimeConnection,
        IsServer
        );

    LOG_FN_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_RECV_COMPLETE, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2WinHttpDirectReceive (
    IN void *Context,
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection
    )
/*++

Routine Description:

    Direct notification from the thread pool to a receiver
    for a receive. The stacks use that to post receives
    to themselves.

Arguments:

    Context - an instance of HTTP2WinHttpTransportChannel

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_OPERATION_WHTTP_DRECV_COMPLETE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)Context);

    RpcStatus = ((HTTP2WinHttpTransportChannel *)Context)->DirectReceiveComplete(
        ReceivedBuffer,
        ReceivedBufferLength,
        RuntimeConnection
        );

    LOG_FN_OPERATION_EXIT(HTTP2LOG_OPERATION_WHTTP_DRECV_COMPLETE, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2WinHttpDirectSend (
    IN void *Context,
    OUT BYTE **SentBuffer,
    OUT void **SendContext
    )
/*++

Routine Description:

    Direct notification from the thread pool to a sender
    for a send. The stacks use that to post sends
    to themselves.

Arguments:

    Context - an instance of HTTP2WinHttpTransportChannel

    SentBuffer - the buffer that we sent.

    SendContext - the send context to return to the runtime
        if the packet is not consumed.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_OPERATION_WHTTP_DSEND_COMPLETE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)Context);

    RpcStatus = ((HTTP2WinHttpTransportChannel *)Context)->DirectSendComplete(
        SentBuffer,
        SendContext
        );

    LOG_FN_OPERATION_EXIT(HTTP2LOG_OPERATION_WHTTP_DSEND_COMPLETE, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPCRTAPI
void
RPC_ENTRY
HTTP2WinHttpDelayedReceive (
    IN void *Context
    )
/*++

Routine Description:

    Direct notification from the thread pool to 
    post a DelayedReceive.

Arguments:

    Context - an instance of HTTP2WinHttpTransportChannel

Return Value:

    none

--*/
{
    ((HTTP2WinHttpTransportChannel *)Context)->DelayedReceive();
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2PlugChannelDirectSend (
    IN void *Context
    )
/*++

Routine Description:

    Direct notification from the thread pool to the plug channel
    for a send. The plug channel uses that to post sends
    to itself. Usable only on proxies (i.e. doesn't return to runtime)

Arguments:

    Context - an instance of HTTP2PlugChannel

Return Value:

    RPC_S_OK

--*/
{
    return ((HTTP2PlugChannel *)Context)->DirectSendComplete();
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2FlowControlChannelDirectSend (
    IN void *Context,
    OUT BOOL *IsServer,
    OUT BOOL *SendToRuntime,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct notification from the thread pool to the flow control channel
    for a send. The flow control channel uses that to post sends
    to itself.

Arguments:

    Context - an instance of HTTP2FlowControlSender

    IsServer - on both success and failure MUST be set by this function.

    SendToRuntime - on both success and failure MUST be set by this function.

    SendContext - the send context as needs to be seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK

--*/
{
    RPC_STATUS RpcStatus;

#if DBG
    *IsServer = 0xBAADBAAD;
    *SendToRuntime = 0xBAADBAAD;
#endif  // DBG

    RpcStatus = ((HTTP2FlowControlSender *)Context)->DirectSendComplete(IsServer,
        SendToRuntime,
        SendContext,
        Buffer,
        BufferLength);

    // make sure DirectSendComplete didn't forget to set it
    ASSERT(*IsServer != 0xBAADBAAD);
    ASSERT(*SendToRuntime != 0xBAADBAAD);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2ChannelDataOriginatorDirectSend (
    IN void *Context,
    OUT BOOL *IsServer,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct notification from the thread pool to the channel data originator
    for a send complete. The channel data originator uses that to post send
    compeltes to itself. Usable only on endpoints (i.e. does return to runtime)

Arguments:

    Context - an instance of HTTP2ChannelDataOriginator

    IsServer - on both success and failure MUST be set by this function.

    SendContext - the send context as needs to be seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK

--*/
{
    RPC_STATUS RpcStatus;

#if DBG
    *IsServer = 0xBAADBAAD;
#endif  // DBG

    RpcStatus = ((HTTP2ChannelDataOriginator *)Context)->DirectSendComplete(IsServer,
        SendContext,
        Buffer,
        BufferLength);

    // make sure DirectSendComplete didn't forget to set it
    ASSERT(*IsServer != 0xBAADBAAD);

    return RpcStatus;
}

RPCRTAPI
void
RPC_ENTRY
HTTP2TimerReschedule (
    IN void *Context
    )
/*++

Routine Description:

    A timer reschedule notification came in.

Arguments:

    Context - actually a ping channel pointer for the channel
        that asked for rescheduling

Return Value:

--*/
{
    HTTP2PingOriginator *PingChannel;

    PingChannel = (HTTP2PingOriginator *)Context;

    PingChannel->RescheduleTimer();
}

RPCRTAPI
void
RPC_ENTRY
HTTP2AbortConnection (
    IN void *Context
    )
/*++

Routine Description:

    A request to abort the connection was posted on a worker thread.

Arguments:

    Context - actually a top channel pointer for the connection to abort.

Return Value:

--*/
{
    HTTP2Channel *TopChannel;

    TopChannel = (HTTP2Channel *)Context;

    TopChannel->AbortConnection(RPC_P_CONNECTION_SHUTDOWN);
    TopChannel->RemoveReference();
}

RPCRTAPI
void
RPC_ENTRY
HTTP2RecycleChannel (
    IN void *Context
    )
/*++

Routine Description:

    A request to recycle the channel was posted on a worker thread.

Arguments:

    Context - actually a top channel pointer for the channel to
        recycle.

Return Value:

--*/
{
    HTTP2Channel *TopChannel;

    TopChannel = (HTTP2Channel *)Context;

    // don't care about return code. See rule 29.
    (void) TopChannel->HandleSendResultFromNeutralContext(RPC_P_CHANNEL_NEEDS_RECYCLING);
    TopChannel->RemoveReference();
}

RPC_STATUS 
HTTP2ProcessComplexTReceive (
    IN OUT void **Connection,
    IN RPC_STATUS EventStatus,
    IN ULONG Bytes,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    A receive notification came from the completion port.

Arguments:

    Connection - a pointer to a pointer to a connection.
        On input it will be the raw connection. On output
        it needs to be the virtual connection so that
        runtime can find its object off there. This out
        parameter must be set on both success and failure.

    EventStatus - status of the operation

    Bytes - bytes received

    Buffer - on output (success only), the received buffer

    BufferLength - on output (success only), the length of the
        received buffer.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure
    RPC_P_PARTIAL_RECEIVE allowed for partial receives.
    RPC_P_PACKET_CONSUMED must be returned for all transport
        traffic (success or failure). Anything else will AV the
        runtime.

--*/
{
    WS_HTTP2_CONNECTION *RawConnection = (WS_HTTP2_CONNECTION *)*Connection;
    BYTE *Packet;
    ULONG PacketLength;
    WS_HTTP2_INITIAL_CONNECTION *ThisConnection;
    HTTP2ServerVirtualConnection *ServerVirtualConnection;
    BOOL VirtualConnectionCreated;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_COMPLEX_T_RECV, HTTP2LOG_OT_CALLBACK, EventStatus);

    ASSERT (EventStatus != RPC_P_PACKET_CONSUMED);

    // Detect whether this is an initial connection.
    // If this is an initial connection, process receive and initialize the connection.

    // EventStatus will be RPC_P_INITIALIZE_HTTP2_CONNECTION in the case of connection establishment.
    if (EventStatus == RPC_P_INITIALIZE_HTTP2_CONNECTION)
        {
        Packet = (BYTE *) *Buffer;
        PacketLength = *BufferLength;
        ThisConnection = (WS_HTTP2_INITIAL_CONNECTION *) *Connection;

        // The packet received must have been an RTS packet.
        ASSERT(IsRTSPacket(Packet));

        // unlink this connection from the PnP list before it is migrated
        TransportProtocol::RemoveObjectFromProtocolList((BASE_ASYNC_OBJECT *) ThisConnection);

        EventStatus = HTTP2ServerVirtualConnection::InitializeServerConnection (
            Packet,
            PacketLength,
            ThisConnection,
            &ServerVirtualConnection,
            &VirtualConnectionCreated
            );
        
        // Note that if the above call succeeds, ThisConnection may have been deleted on another thread
        // after this point.  This is possible when the data receive posted has completed on another thread,
        // causing a connection close.

        if (EventStatus == RPC_S_OK)
            {
            // We are done with connection initialization and may return.
            
            // N.B. Do not use the this pointer as WS_HTTP2_INITIAL_CONNECTION 
            // pointer after here. It has been migrated to a new location
            // and this actually points to HTTP2ServerVirtualConnection

            *Buffer = NULL;
            *BufferLength = 0;
            RpcFreeBuffer(Packet);
            return RPC_P_PACKET_CONSUMED;
            }
        else
            {
            if (VirtualConnectionCreated == FALSE)
                {
                // failed to create a virtual connection. Link the connection 
                // back to its protocol list to ensure orderly destruction
                TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) ThisConnection);

                // Send failure to the runtime to have the OSF_SCONNECTION cleaned up.
                return RPC_P_RECEIVE_FAILED;
                }
            else
                {
                // nothing to do. The virtual connection was created but it failed to
                // initialize. We will process the failure and let the runtime destroy
                // the connection.
                EventStatus = RPC_P_RECEIVE_FAILED;
                }
            }

        // The only status expected beyond this point is a failure.
        ASSERT(EventStatus == RPC_P_RECEIVE_FAILED);
        }

    // stick the runtime idea of the transport connection
    *Connection = RawConnection->RuntimeConnectionPtr;

    if (Bytes && (EventStatus == RPC_S_OK))
        {
        EventStatus = RawConnection->ProcessReceiveComplete(Bytes,
                                          Buffer,
                                          BufferLength);

        if (EventStatus == RPC_P_PARTIAL_RECEIVE)
            {
            // Message is not complete, submit the next read and continue.
            EventStatus = CO_SubmitRead(RawConnection);

            if (EventStatus != RPC_S_OK)
                {
                EventStatus = RawConnection->ProcessReceiveFailed(RPC_P_CONNECTION_SHUTDOWN);
                if (EventStatus != RPC_P_PACKET_CONSUMED)
                    {
                    ASSERT(EventStatus == RPC_P_RECEIVE_FAILED);
                    }
                }
            else
                EventStatus = RPC_P_PARTIAL_RECEIVE;
            }
        else
            {
            ASSERT(   (EventStatus == RPC_P_RECEIVE_FAILED)
                   || (EventStatus == RPC_S_OK)
                   || (EventStatus == RPC_P_PACKET_CONSUMED)
                   || (EventStatus == RPC_P_CONNECTION_CLOSED));
            }
        }
    else
        {
        // in other rare case (again server connection establishment), the connection
        // can be the virtual connection, not the transport connection. In such cases,
        // let the error fall through back to the runtime. Since this happens only during
        // connection establishment, and the receive did not go through the channels,
        // we should not complete it through the channels.
        if ((RawConnection->id == HTTPv2) 
            && (RawConnection->type == (COMPLEX_T | CONNECTION | SERVER)))
            {
            // this is a server virtual connecton. Read the connection from there
            *Connection = RawConnection;
            }
        else
            {
            if (EventStatus != RPC_S_OK)
                EventStatus = RawConnection->ProcessReceiveFailed(EventStatus);
            else
                EventStatus = RawConnection->ProcessReceiveFailed(RPC_P_RECEIVE_FAILED);

            if (EventStatus == RPC_P_CONNECTION_SHUTDOWN)
                EventStatus = RPC_P_RECEIVE_FAILED;
            }

        ASSERT(   (EventStatus == RPC_P_RECEIVE_FAILED)
               || (EventStatus == RPC_S_OK)
               || (EventStatus == RPC_P_PACKET_CONSUMED));
        }

    LOG_FN_OPERATION_EXIT(HTTP2LOG_COMPLEX_T_RECV, HTTP2LOG_OT_CALLBACK, EventStatus);

    return EventStatus;
}

RPC_STATUS 
HTTP2ProcessComplexTSend (
    IN void *SendContext,
    IN RPC_STATUS EventStatus,
    OUT BUFFER *Buffer
    )
/*++

Routine Description:

    A send notification came from the completion port.

Arguments:

    SendContext - the send context

    EventStatus - status of the operation

    Buffer - if the packet is not consumed, must be the sent
        buffer.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure
    RPC_P_PACKET_CONSUMED must be returned for all transport
        traffic (success or failure). Anything else will AV the
        runtime.

--*/
{
    HTTP2SendContext *HttpSendContext = (HTTP2SendContext *)SendContext;
    WS_HTTP2_CONNECTION *RawConnection;
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_COMPLEX_T_SEND, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)HttpSendContext);

    *Buffer = HttpSendContext->pWriteBuffer;
    RawConnection = (WS_HTTP2_CONNECTION *)HttpSendContext->Write.pAsyncObject;

    RpcStatus = RawConnection->ProcessSendComplete(EventStatus, HttpSendContext);

    LOG_FN_OPERATION_EXIT(HTTP2LOG_COMPLEX_T_SEND, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPC_STATUS ProxyAsyncCompleteHelper (
    IN HTTP2Channel *TopChannel,
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    A helper function that completes an async io.

Arguments:

    TopChannel - the top channel for the stack
    
    CurrentStatus - the status with which the complete
        notification completed.

Return Value:

    RPC_S_OK.

--*/
{
    ASSERT(CurrentStatus != RPC_S_CANNOT_SUPPORT);
    ASSERT(CurrentStatus != RPC_S_INTERNAL_ERROR);

    if ((CurrentStatus != RPC_S_OK)
        &&
        (CurrentStatus != RPC_P_PACKET_CONSUMED))
        {
        // if this failed, abort the whole connection
        TopChannel->AbortAndDestroyConnection(CurrentStatus);
        }

    TopChannel->RemoveReference();

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2TestHook (
    IN SystemFunction001Commands FunctionCode,
    IN void *InData,
    OUT void *OutData
    )
/*++

Routine Description:

    Test hook for the http functions

Arguments:

    FunctionCode - which test function to perform

    InData - input data from the test function

    OutData - output data from the test function

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_CHAR *NewTarget;

    switch (FunctionCode)
        {
        case sf001cHttpSetInChannelTarget:
            NewTarget = (RPC_CHAR *)InData;

            if (InChannelTargetTestOverride)
                {
                delete [] InChannelTargetTestOverride;
                InChannelTargetTestOverride = NULL;
                }

            if (NewTarget)
                {
                InChannelTargetTestOverride = DuplicateString(NewTarget);
                if (InChannelTargetTestOverride == NULL)
                    return RPC_S_OUT_OF_MEMORY;
                }
            break;

        case sf001cHttpSetOutChannelTarget:
            NewTarget = (RPC_CHAR *)InData;

            if (OutChannelTargetTestOverride)
                {
                delete [] OutChannelTargetTestOverride;
                OutChannelTargetTestOverride = NULL;
                }

            if (NewTarget)
                {
                OutChannelTargetTestOverride = DuplicateString(NewTarget);
                if (OutChannelTargetTestOverride == NULL)
                    return RPC_S_OUT_OF_MEMORY;
                }
            break;

        default:
            // we should never be called with a value we can't handle
            ASSERT(0);
            return RPC_S_INTERNAL_ERROR;
        }

    return RPC_S_OK;
}

/*********************************************************************
    HTTP2TransportChannel
 *********************************************************************/

RPC_STATUS HTTP2TransportChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    VerifyValidSendContext(SendContext);

    return LowerLayer->Send(SendContext);
}

RPC_STATUS HTTP2TransportChannel::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return LowerLayer->Receive(TrafficType);
}

RPC_STATUS HTTP2TransportChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send
    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return UpperLayer->SendComplete(EventStatus,
        SendContext
        );
}

RPC_STATUS HTTP2TransportChannel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return UpperLayer->ReceiveComplete(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );
}

void HTTP2TransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    LowerLayer->Abort(RpcStatus);
}

void HTTP2TransportChannel::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.
    Most channels don't care as they don't account for or hang on to sends.
    Called only in submission context.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

--*/
{
    UpperLayer->SendCancelled(SendContext);
}

void HTTP2TransportChannel::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->Reset();
}

RPC_STATUS HTTP2TransportChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Helper routine that helps complete an async operation

Arguments:
    
    CurrentStatus - the current status of the operation

Return Value:

    The status to return to the runtime.

--*/
{
    return TopChannel->AsyncCompleteHelper(CurrentStatus);
}

RPC_STATUS HTTP2TransportChannel::HandleSendResultFromNeutralContext (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Handles the result code from send from a neutral context.
    This includes checking for channel recycling and intiating
    one if necessary. This routine simply delegates to the top channel

Arguments:

    CurrentStatus - the status from the send operation

Return Value:

    RPC_S_OK or RPC_S_*. Callers may ignore it since all cleanup was
    done.

Notes: 

    This must be called in upcall or neutral context only

--*/
{
    return TopChannel->HandleSendResultFromNeutralContext(CurrentStatus);
}

/*********************************************************************
    WS_HTTP2_CONNECTION
 *********************************************************************/

RPC_STATUS WS_HTTP2_CONNECTION::Send(HANDLE hFile, LPCVOID lpBuffer,
                               DWORD nNumberOfBytesToWrite,
                               LPDWORD lpNumberOfBytesWritten,
                               LPOVERLAPPED lpOverlapped)
/*++

Routine Description:

    Does an asynchronous send on the connection.

Arguments:

    hFile - file to send on

    lpBuffer - buffer to send

    nNumberOfBytesToWrite - number of bytes to send

    lpNumberOfBytesWritten - number of bytes written. Will never get filled
        in this code path because it is async.

    lpOverlapped - overlapped to use for the operation

Return Value:

    WSA Error Code

--*/
{
    // See Rule 32.
    return UTIL_WriteFile2(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped);
}

RPC_STATUS WS_HTTP2_CONNECTION::Receive(HANDLE hFile, 
    LPVOID lpBuffer, 
    DWORD nNumberOfBytesToRead, 
    LPDWORD lpNumberOfBytesRead, 
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    Does an asynchronous receive on the connection.

Arguments:

    hFile - file to receive on

    lpBuffer - buffer to receive into

    nNumberOfBytesToRead - number of bytes to receive

    lpNumberOfBytesRead - number of bytes read. Will never get filled
        in this code path because it is async.

    lpOverlapped - overlapped to use for the operation

Return Value:

    WSA Error Code

--*/
{
    return SANReceive(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessReceiveFailed (
    IN RPC_STATUS EventStatus
    )
/*++

Routine Description:

    Notifies a raw connection of receive failure.

Arguments:

    EventStatus - error with which the receive failed

Return Value:

    RPC_S_OK to return packet to runtime 
    or RPC_P_PACKET_CONSUMED to hide it.

--*/
{
    // if we failed before we parsed the header, chances are the problem
    // was with the header format. Treat it as protocol error.
    if ((HeaderRead == FALSE) && (EventStatus == RPC_P_CONNECTION_SHUTDOWN))
        EventStatus = RPC_S_PROTOCOL_ERROR;

    return Channel->ReceiveComplete(EventStatus, http2ttRaw, pReadBuffer, 0);
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessSendComplete (
    IN RPC_STATUS EventStatus,
    IN CO_SEND_CONTEXT *SendContext
    )
/*++

Routine Description:

    Notifies a raw connection of send completion (fail or succeed).

Arguments:

    EventStatus - error with which the send failed

Return Value:

    RPC_S_OK to return packet to runtime 
    or RPC_P_PACKET_CONSUMED to hide it.

--*/
{
    HTTP2SendContext *HttpSendContext = (HTTP2SendContext *)SendContext;
    VerifyValidSendContext(HttpSendContext);

    return Channel->SendComplete(EventStatus, HttpSendContext);
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessRead(
    IN  DWORD bytes, 
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength
    )
/*++

Routine Description:

    Processes a connection oriented receive
    complete. But in HTTP2 we no-op this and do all read
    processing through the COMPLEX_T mechanism.

Arguments:

    bytes - the number of read (not including those in iLastRead).

    pBuffer - when returning RPC_S_OK will contain the message.

    pBufferLength - when return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK

--*/
{
    return RPC_S_OK;
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessReceiveComplete(
    IN  DWORD bytes, 
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength
    )
/*++

Routine Description:

    Processes a connection oriented receive
    complete. It takes care of fragmentation.

Arguments:

    bytes - the number of read (not including those in iLastRead).

    pBuffer - when returning RPC_S_OK will contain the message.

    pBufferLength - when return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK to return packet to runtime 
    or RPC_P_PACKET_CONSUMED to hide it.

--*/
{
    RPC_STATUS RpcStatus;

    if (HeaderRead)
        {
        RpcStatus = BASE_CONNECTION::ProcessRead(bytes, pBuffer, pBufferLength);

        if (RpcStatus == RPC_P_PARTIAL_RECEIVE)
            return RpcStatus;
        }
    else if (bytes != 0)
        {
        ASSERT(ReadHeaderFn);

        RpcStatus = ReadHeaderFn(this,
            bytes,
            (ULONG *)pBufferLength
            );

        if (RpcStatus == RPC_P_PARTIAL_RECEIVE)
            return RpcStatus;

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = BASE_CONNECTION::ProcessRead(*pBufferLength, pBuffer, pBufferLength);
            }

        if (RpcStatus == RPC_P_PARTIAL_RECEIVE)
            return RpcStatus;
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    // we corrupt the RTS packet if necessary
    if ( gfRPCVerifierEnabled && (pRpcVerifierSettings->fCorruptionInjectServerReceives) && (RpcStatus == RPC_S_OK) )
        {
        if (IsRTSPacket(*pBuffer))
    	    {
            CorruptionInject(ServerReceive,
                             (UINT *)pBufferLength,
                             (void **)pBuffer);

            LogEvent(SU_CORRUPT, EV_NOTIFY, *pBuffer, this, *pBufferLength, 0, 0);
    	    }
        }

    if (RpcStatus == RPC_S_OK)
        {
        RpcStatus = Channel->ReceiveComplete(RpcStatus,
            http2ttRaw,
            (BYTE *)*pBuffer,
            *pBufferLength);
        }
    else
        {
        RpcStatus = Channel->ReceiveComplete(RpcStatus,
            http2ttRaw,
            NULL,
            0);
        }

    return RpcStatus;
}

RPC_STATUS WS_HTTP2_CONNECTION::Abort (
    void
    )
/*++

Routine Description:

    No-op. This is called from common
    transport code. We don't abort HTTP2
    connections from common transport code. Ignore
    this call.

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    return RPC_S_OK;
}

void WS_HTTP2_CONNECTION::Free (
    void
    )
/*++

Routine Description:

    Acts like destructor. All memory needs to
    be freed.

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    if (pReadBuffer)
        {
        RpcFreeBuffer(pReadBuffer);
        pReadBuffer = NULL;
        }

    // This may be called on a partially initialized connection
    // during its migration.  Ignore such calls.
    if (fIgnoreFree)
        return;

    // Unlink the object from the PnP list.
    TransportProtocol::RemoveObjectFromProtocolList(this);

    // Make sure we don't free the connection without closing the socket.
    // When we close the socket, we set it to NULL.
    ASSERT(Conn.Socket == NULL);
}

void WS_HTTP2_CONNECTION::RealAbort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP2 connection.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_RAW_CONNECTION, 0);

    (void)WS_CONNECTION::Abort();
}

void WS_HTTP2_CONNECTION::Initialize (
    void
    )
/*++

Routine Description:

    Initializes a raw connection

Arguments:

Return Value:

--*/
{
    BASE_CONNECTION::Initialize();
#if DBG
    // client and server virtual connections must initialize this. In debug
    // builds toast anybody who forgets. Proxies don't care
    type = 0xC0C0C0C0;
#endif
    pAddress = NULL;
    RpcpInitializeListHead(&ObjectList);

    fIgnoreFree = FALSE;

    // use explicit placement to initialize the vtable. We need this to
    // be able to use the virtual functions
    (void) new (this) WS_HTTP2_CONNECTION;
}

/*********************************************************************
    WS_HTTP2_INITIAL_CONNECTION
 *********************************************************************/

C_ASSERT(sizeof(rpcconn_common) == sizeof(CONN_RPC_HEADER));

RPC_STATUS WS_HTTP2_INITIAL_CONNECTION::ProcessRead(
    IN  DWORD BytesRead, 
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength
    )
/*++

Routine Description:

    Processes a connection oriented receive
    complete. It determines whether HTTP2 or HTTP will be
    used.  For HTTP2, the actual work is done in
    HTTP2ProcessComplexTReceive.

Arguments:

    BytesRead - the number of read (not including those in iLastRead).

    pBuffer - when returning RPC_S_OK will contain the message.

    pBufferLength - when return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK for successful processing
    RPC_PARTIAL_RECEIVE - not enough was received to tell
    RPC_P_RECEIVE_FAILED - error occurred.
    RPC_P_INITIALIZE_HTTP2_CONNECTION - offload the connection establishment to HTTP2ProcessComplexTReceive.

--*/
{
    RPC_STATUS RpcStatus;
    BYTE *Packet;

    RpcStatus = BASE_CONNECTION::ProcessRead(BytesRead,
        pBuffer,
        pBufferLength
        );

    if (RpcStatus == RPC_S_OK)
        {
        // ProcessRead guarantees that on return value of RPC_S_OK
        // we have at least rpcconn_common bytes read successfully
        Packet = (BYTE *)*pBuffer;
        if (IsRTSPacket(Packet))
            {
            // The final initialization will take place in HTTP2ProcessComplexTReceive.
            this->type |= COMPLEX_T;

            // Signal to HTTP2ProcessComplexTReceive that we are in the process of
            // connection establishment by returning RPC_P_INITIALIZE_HTTP2_CONNECTION.
            RpcStatus = RPC_P_INITIALIZE_HTTP2_CONNECTION;
            }
        else
            {
            // morph the connection into WS_CONNECTION to serve
            // HTTP requests. The only thing we need to change is the
            // vtable. We have a little bit of extra goo at the end, but
            // that's ok.
            (void) new (this) WS_CONNECTION;            
            }
        }

    return RpcStatus;
}


RPC_STATUS WS_HTTP2_INITIAL_CONNECTION::Abort(
    void
    )
/*++

Routine Description:

    Aborts an WS_HTTP2_INITIAL_CONNECTION connection.
    Very rare to be called.

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_INITIAL_RAW_CONNECTION, 0);

    WS_HTTP2_CONNECTION::RealAbort();
    return RPC_S_OK;
}

/*********************************************************************
    HTTP2BottomChannel
 *********************************************************************/

RPC_STATUS HTTP2BottomChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, EventStatus);

    RpcStatus = HTTP2TransportChannel::SendComplete(EventStatus,
        SendContext
        );

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, RpcStatus);

    return AsyncCompleteHelper(RpcStatus);
}

RPC_STATUS HTTP2BottomChannel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, EventStatus);

    RpcStatus = HTTP2TransportChannel::ReceiveComplete(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, RpcStatus);

    return AsyncCompleteHelper(RpcStatus);
}

/*********************************************************************
    HTTP2SocketTransportChannel
 *********************************************************************/

RPC_STATUS HTTP2SocketTransportChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request. Forward the send to the raw connection

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    DWORD Ignored;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SOCKET_CHANNEL, (ULONG_PTR)SendContext);

    // route this through the completion port
    SendContext->Write.ol.hEvent = NULL;
    SendContext->Write.pAsyncObject = RawConnection;

    // N.B. The Winsock provider will touch the overlapped on the return path. We need
    // to make sure that either the overlapped is around (in which case we can use WSASend), 
    // or otherwise use UTIL_WriteFile2 which does not touch the overlapped on return.
    // We know the overlapped may not be around when this is a proxy data send, any type
    // of RTS send, or abandoned send. All non-proxy, not-abandoned data sends will have 
    // the overlapped around.
    if ((SendContext->TrafficType == http2ttData) 
        && (((SendContext->Flags & (SendContextFlagAbandonedSend | SendContextFlagProxySend)) == 0)))
        {
        RpcStatus = RawConnection->WS_HTTP2_CONNECTION::SANSend(
                                RawConnection->Conn.Handle,
                                SendContext->pWriteBuffer,
                                SendContext->maxWriteBuffer,
                                &Ignored,
                                &SendContext->Write.ol
                                );
        }
    else
        {
        RpcStatus = RawConnection->WS_HTTP2_CONNECTION::Send(
                                RawConnection->Conn.Handle,
                                SendContext->pWriteBuffer,
                                SendContext->maxWriteBuffer,
                                &Ignored,
                                &SendContext->Write.ol
                                );
        }

    if (   (RpcStatus != RPC_S_OK)
        && (RpcStatus != ERROR_IO_PENDING) )
        {
        VALIDATE(RpcStatus)
            {
            ERROR_NETNAME_DELETED,
            ERROR_GRACEFUL_DISCONNECT,
            ERROR_NO_DATA,
            ERROR_NO_SYSTEM_RESOURCES,
            ERROR_WORKING_SET_QUOTA,
            ERROR_BAD_COMMAND,
            ERROR_OPERATION_ABORTED,
            ERROR_WORKING_SET_QUOTA,
            WSAECONNABORTED,
            WSAECONNRESET
            } END_VALIDATE;

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SOCKET_CHANNEL, RPC_P_SEND_FAILED);

        return(RPC_P_SEND_FAILED);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SOCKET_CHANNEL, RPC_S_OK);

    return RPC_S_OK;
}

RPC_STATUS HTTP2SocketTransportChannel::Receive (
    IN HTTP2TrafficType TrafficType
    )
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_SOCKET_CHANNEL, TrafficType);

    ASSERT(TrafficType == http2ttRaw);

    RpcStatus = CO_Recv(RawConnection);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_SOCKET_CHANNEL, RpcStatus);

    return RpcStatus;
}

void HTTP2SocketTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_SOCKET_CHANNEL, RpcStatus);

    RawConnection->RealAbort();
}

void HTTP2SocketTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_SOCKET_CHANNEL, 0);

    RawConnection->Free();

    HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
}

void HTTP2SocketTransportChannel::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    RawConnection->HeaderRead = FALSE;
}

/*********************************************************************
    HTTP2FragmentReceiver
 *********************************************************************/

RPC_STATUS HTTP2FragmentReceiver::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if (iLastRead && iLastRead == MaxReadBuffer)
        {
        ASSERT(pReadBuffer);

        // This means we received a coalesced read of a complete
        // message. (Or that we received a coalesced read < header size)
        // We should complete that as it's own IO in neutral context. 
        // This is very rare.
        (void) COMMON_PostRuntimeEvent(GetPostRuntimeEvent(),
            this
            );

        return(RPC_S_OK);
        }

    ASSERT(iLastRead == 0 || (iLastRead < MaxReadBuffer));

    return(PostReceive());
};

RPC_STATUS HTTP2FragmentReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN OUT BYTE **Buffer,
    IN OUT UINT *BufferLength
    )
/*++

Routine Description:

    Processes a receive complete notification.

Arguments:

    EventStatus - the status code of the operation.

    TrafficType - the type of traffic we have received

    Buffer - the buffer. Must be NULL at this level on input. On
        output contains the buffer for the current receive. If NULL
        on output, we did not have a full packet. Undefined on failure.

    BufferLength - the actual number of bytes received. On output the
        number of bytes for the current packet. If 0 on output,
        we did not have a complete packet. Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error. Note that unlike BASE_CONNECTION::ProcessRead,
    this function does not return RPC_P_PARTIAL_RECEIVE. See note section for
    more information.

Note:

    NULL returned Buffer and RPC_S_OK means a partial receive.

--*/
{
    BYTE *LocalReadBuffer;
    ULONG MessageSize;
    ULONG ExtraSize;
    ULONG AllocSize;
    BYTE *NewBuffer;
    BOOL DoNotComplete;
    ULONG LocalBufferLength = *BufferLength;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_FRAGMENT_RECEIVER, LocalBufferLength);

    DoNotComplete = FALSE;
    if (EventStatus == RPC_S_OK)
        {
        ASSERT(pReadBuffer);

        LocalBufferLength += iLastRead;

        ASSERT(LocalBufferLength <= MaxReadBuffer);

        if (LocalBufferLength < sizeof(CONN_RPC_HEADER))
            {
            // Not a whole header, resubmit the read and continue.

            iLastRead = LocalBufferLength;

            EventStatus = PostReceive();

            if (EventStatus == RPC_S_OK)
                DoNotComplete = TRUE;
            else
                LocalReadBuffer = NULL;
            }
        else
            {
            MessageSize = MessageLength((PCONN_RPC_HEADER)pReadBuffer);

            if (MessageSize < sizeof(CONN_RPC_HEADER))
                {
                ASSERT(MessageSize >= sizeof(CONN_RPC_HEADER));
                EventStatus = RPC_P_RECEIVE_FAILED;
                LocalReadBuffer = NULL;
                }
            else if (LocalBufferLength == MessageSize)
                {
                // All set, have a complete request.
                LocalReadBuffer = pReadBuffer;
                LocalBufferLength = MessageSize;

                iLastRead = 0;
                pReadBuffer = 0;
                }
            else if (MessageSize > LocalBufferLength)
                {
                // Don't have a complete message, realloc if needed and
                // resubmit a read for the remaining bytes.

                if (MaxReadBuffer < MessageSize)
                    {
                    // Buffer too small for the message.
                    EventStatus = TransConnectionReallocPacket(NULL,
                                                          &pReadBuffer,
                                                          LocalBufferLength,
                                                          MessageSize);

                    if (EventStatus == RPC_S_OK)
                        {
                        // increase the post size, but not if we are in direct
                        // buffer mode.
                        if (gBCacheMode == BCacheModeCached)
                            iPostSize = MessageSize;
                        }
                    }

                if (EventStatus == RPC_S_OK)
                    {
                    // Setup to receive exactly the remaining bytes of the message.
                    iLastRead = LocalBufferLength;
                    MaxReadBuffer = MessageSize;

                    EventStatus = PostReceive();

                    if (EventStatus == RPC_S_OK)
                        DoNotComplete = TRUE;
                    else
                        LocalReadBuffer = NULL;
                    }
                else
                    {
                    LocalReadBuffer = NULL;
                    }
                }
            else
                {
                // Coalesced read, save extra data.  Very uncommon

                ASSERT(LocalBufferLength > MessageSize);

                // The first message and size will be returned

                LocalReadBuffer = pReadBuffer;

                ExtraSize = LocalBufferLength - MessageSize;

                LocalBufferLength = MessageSize;

                // Try to find a good size of the extra PDU(s)
                if (ExtraSize < sizeof(CONN_RPC_HEADER))
                    {
                    // Not a whole header, we'll assume gPostSize;

                    AllocSize = gPostSize;
                    }
                else
                    {
#ifdef _M_IA64
                    // The first packet may not contain a number of bytes
                    // that align the second on an 8-byte boundary.  Hence, the
                    // structure may end up unaligned. 
                    AllocSize = MessageLengthUnaligned((PCONN_RPC_HEADER)(pReadBuffer
                                                                           + MessageSize));
#else
                    AllocSize = MessageLength((PCONN_RPC_HEADER)(pReadBuffer
                                                                  + MessageSize));
#endif
                    }

                if (AllocSize < ExtraSize)
                    {
                    // This can happen if there are more than two PDUs coalesced together
                    // in the buffer.  Or if the PDU is invalid. Or if the iPostSize is
                    // smaller than the next PDU.
                    AllocSize = ExtraSize;
                    }

                // Allocate a new buffer to save the extra data for the next read.
                NewBuffer = (BYTE *)RpcAllocateBuffer(AllocSize);

                if (0 == NewBuffer)
                    {
                    // We have a complete request.  We could process the request and
                    // close the connection only after trying to send the reply.

                    LocalReadBuffer = NULL;
                    LocalBufferLength = 0;

                    EventStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(pReadBuffer);

                    // Save away extra data for the next receive
                    RpcpMemoryCopy(NewBuffer,
                                   pReadBuffer + LocalBufferLength,
                                   ExtraSize);
                    pReadBuffer = NewBuffer;
                    iLastRead = ExtraSize;
                    MaxReadBuffer = AllocSize;

                    ASSERT(iLastRead <= MaxReadBuffer);

                    EventStatus = RPC_S_OK;
                    }
                }
            }
        }
    else
        {
        // in failure cases we keep the buffer. We will 
        // free it on Abort.
        LocalReadBuffer = NULL;
        }

    if (DoNotComplete == FALSE)
        {
        *Buffer = LocalReadBuffer;
        *BufferLength = LocalBufferLength;

        if (gfRPCVerifierEnabled)
            {
            // check whether we are on the proxy side or client side.
            // Currently only those two use the HTTP2FragmentReceiver
            if (TopChannel->IsProxyChannel())
                {
                CorruptionInject(ServerReceive,
                                 (UINT *)&LocalBufferLength,
                                 (void **)&LocalReadBuffer);
                }
            else
                {
                CorruptionInject(ClientReceive,
                                 (UINT *)&LocalBufferLength,
                                 (void **)&LocalReadBuffer);
                }
            }

        EventStatus = UpperLayer->ReceiveComplete(EventStatus,
            TrafficType,
            LocalReadBuffer,
            LocalBufferLength
            );

        EventStatus = AsyncCompleteHelper(EventStatus);
        // don't touch the this pointer after AsyncCompleteHelper.
        // It could be gone.
        }
    else
        {
        *Buffer = NULL;
        *BufferLength = 0;
        EventStatus = RPC_S_OK;
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_FRAGMENT_RECEIVER, *BufferLength);

    return EventStatus;
}

RPC_STATUS HTTP2FragmentReceiver::DepositReceivedData (
    IN ULONG DataSize,
    IN BYTE *Data
    )
/*++

Routine Description:

    Deposits data directly in the receive queue. That is, the
    data arriving from this method will be posted in such a way as
    if they were received from the network on a previous receive.
    This means receive complete will not be issued for this call
    and another receive must be issued to retrieve the data passed
    in.

Arguments:

    DataSize - the size of the data buffer.

    Data - the buffer itself. This function makes its own copy of the
        data. Caller is responsible for freeing the passed in
        parameter.

Return Value:

Notes:

    Currently the method is structured to function correctly only
    when no data already received exist. It will ASSERT if data
    are already present. It is straightforward to rework the method
    to append the incoming data to existing data, but it's not
    necessary as it will be currently called on first data chunk
    only.

--*/
{
    // make sure that this happens only when there are no
    // accumulated data
    ASSERT (iLastRead == 0);

    if (pReadBuffer == NULL)
        {
        pReadBuffer = (BYTE *)RpcAllocateBuffer(DataSize);
        if (pReadBuffer == NULL)
            return RPC_S_OUT_OF_MEMORY;
        }

    RpcpMemoryCopy (pReadBuffer, Data, DataSize);
    iLastRead = DataSize;
    MaxReadBuffer = DataSize;

    return RPC_S_OK;
}

/*********************************************************************
    HTTP2WinHttpTransportChannel
 *********************************************************************/

// our public constants are aligned with HTTP constants. Even though it is
// unlikely for either to change, make sure they don't. If they do, we need
// a remapping function as we use them interchangeably in the code
C_ASSERT(WINHTTP_AUTH_SCHEME_BASIC == RPC_C_HTTP_AUTHN_SCHEME_BASIC);
C_ASSERT(WINHTTP_AUTH_SCHEME_NTLM == RPC_C_HTTP_AUTHN_SCHEME_NTLM);
C_ASSERT(WINHTTP_AUTH_SCHEME_PASSPORT == RPC_C_HTTP_AUTHN_SCHEME_PASSPORT);
C_ASSERT(WINHTTP_AUTH_SCHEME_DIGEST == RPC_C_HTTP_AUTHN_SCHEME_DIGEST);
C_ASSERT(WINHTTP_AUTH_SCHEME_NEGOTIATE == RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE);

HTTP2WinHttpTransportChannel::HTTP2WinHttpTransportChannel (
    OUT RPC_STATUS *RpcStatus
    ) : Mutex (RpcStatus)
/*++

Routine Description:

    HTTP2WinHttpTransportChannel constructor.

Arguments:
    
    RpcStatus - on output will contain the result of the
        initialization.

Return Value:

--*/
{
    hSession = NULL;
    hConnect = NULL;
    hRequest = NULL;
    SyncEvent = NULL;

    RpcpInitializeListHead(&BufferQueueHead);

    SendsPending = 0;

    State = whtcsNew;

    AsyncError = RPC_S_INTERNAL_ERROR;

    HttpCredentials = NULL;

    KeepAlive = FALSE;

    CredentialsSetForScheme = 0;

    PreviousRequestContentLength = -1;

    ChosenAuthScheme = 0;

    DelayedReceiveTrafficType = http2ttNone;

    CurrentSendContext = NULL;
}

const RPC_CHAR ContentLengthHeader[] = L"Content-Length:";

RPC_STATUS HTTP2WinHttpTransportChannel::Open (
    IN HTTPResolverHint *Hint,
    IN const RPC_CHAR *Verb,
    IN const RPC_CHAR *Url,
    IN const RPC_CHAR *AcceptType,
    IN ULONG ContentLength,
    IN ULONG CallTimeout,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,
    IN ULONG ChosenAuthScheme,
    IN const BYTE *AdditionalData OPTIONAL
    )
/*++

Routine Description:

    Opens the connection to the proxy. We know that a failed Open
    will be followed by Abort.

Arguments:
    
    Hint - the resolver hint

    Verb - the verb to use.

    Url - the url to connect to.

    AcceptType - string representation of the accept type.

    ContentLength - the content length for the request (i.e. the
        channel lifetime)

    CallTimeout - the timeout for the operation

    HttpCredentials - the HTTP transport credentials

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

Return Value:

    RPC_S_OK or RPC_S_* error.

--*/
{
    BOOL HttpResult = FALSE;
    DWORD dwReadBufferSizeSize = sizeof(ULONG);
    ULONG WinHttpAccessType;
    LPCWSTR AcceptTypes[2];
    ULONG LastError;
    RPC_CHAR *UnicodeString;
    ULONG UnicodeStringSize;    // in characters including null terminated NULL
    RPC_STATUS RpcStatus;
    ULONG FlagsToAdd;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *TransHttpCredentials;
    ULONG AdditionalDataLengthToUse;
    ULONG ContentLengthToUse;
    ULONG BytesAvailable;
    RPC_CHAR ContentLengthString[40];   // enough space for "Content-Length:" + channel lifetime
    BOOL IsInChannel;
    BOOL TestOverrideUsed;
    RPC_CHAR *User;
    RPC_CHAR *Password;
    RPC_CHAR *Domain;
    HANDLE LocalEvent = NULL;
    ULONG SecLevel;
    BOOL LanManHashDisabled;
    ULONG DomainAndUserLength;      // length in characters not including null terminator
    ULONG DomainLength;             // length in characters not including null terminator
    ULONG UserLength;               // length in characters not including null terminator
    RPC_CHAR *DomainAndUserName;
    RPC_CHAR *CurrentPos;
    ULONG HttpProxyLength;          // length in characters not including null terminator

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        (ULONG_PTR)ContentLength);

    this->HttpCredentials = HttpCredentials;

    // Open can be called multiple times to send opening requests.
    // Make sure general initialization is done only once.
    if (hSession == NULL)
        {
        ASSERT(hConnect == NULL);

        State = whtcsOpeningRequest;

        ASSERT(Hint->AccessType != rpcpatUnknown);
        if (Hint->AccessType == rpcpatDirect)
            {
            WinHttpAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;
            UnicodeString = NULL;
            UnicodeStringSize = 0;
            }
        else
            {
            WinHttpAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;

            // 1 is terminating NULL, 5 is the max port number for a USHORT (65536) 
            // and 1 is the column b/n them
            HttpProxyLength = RpcpStringLengthA(Hint->HTTPProxy);
            UnicodeStringSize = HttpProxyLength + 1 + 6;
            UnicodeString = new RPC_CHAR [UnicodeStringSize];

            if (UnicodeString == NULL)
                {
                LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                    RPC_S_OUT_OF_MEMORY);
                return RPC_S_OUT_OF_MEMORY;
                }

            FullAnsiToUnicode(Hint->HTTPProxy, UnicodeString);
            // go to the end of the string and append the port
            CurrentPos = UnicodeString + HttpProxyLength;
            *CurrentPos = ':';
            CurrentPos ++;
            PortNumberToEndpoint(Hint->HTTPProxyPort, CurrentPos);
            }

        // Use WinHttpOpen to obtain a session handle.
        hSession = WinHttpOpenImp( L"MSRPC",
                                WinHttpAccessType,
                                UnicodeString,
                                WINHTTP_NO_PROXY_BYPASS,
                                WINHTTP_FLAG_ASYNC
                                );
        if (!hSession)
            {
            VALIDATE(GetLastError())
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            if (UnicodeString)
                delete [] UnicodeString;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Set the callback to be used by WinHttp to notify us of IO completion.
        WinHttpSetStatusCallbackImp( hSession,
                                    WinHttpCallback,
                                    WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
                                    NULL   // Reserved: must be NULL
                                    );

        // Set the communication timeout.
        HttpResult = WinHttpSetOptionImp( hSession,
                                       WINHTTP_OPTION_CONNECT_TIMEOUT,
                                       (LPVOID)&CallTimeout,
                                       sizeof(ULONG)
                                       );

        // this function cannot fail unless we give it invalid parameters
        ASSERT(HttpResult == TRUE);

        // Set the send/receive timeout.
        CallTimeout = 30 * 60 * 1000;
        HttpResult = WinHttpSetOptionImp( hSession,
                                       WINHTTP_OPTION_SEND_TIMEOUT,
                                       (LPVOID)&CallTimeout,
                                       sizeof(ULONG)
                                       );

        // this function cannot fail unless we give it invalid parameters
        ASSERT(HttpResult == TRUE);

        CallTimeout = 30 * 60 * 1000;
        HttpResult = WinHttpSetOptionImp( hSession,
                                       WINHTTP_OPTION_RECEIVE_TIMEOUT,
                                       (LPVOID)&CallTimeout,
                                       sizeof(ULONG)
                                       );

        // this function cannot fail unless we give it invalid parameters
        ASSERT(HttpResult == TRUE);

        RpcStatus = TopChannel->IsInChannel(&IsInChannel);
        // this cannot fail here. We're opening the channel
        ASSERT(RpcStatus == RPC_S_OK);

        if (IsInChannel && InChannelTargetTestOverride)
            {
            TestOverrideUsed = TRUE;
            UnicodeString = InChannelTargetTestOverride;
            }
        else if (!IsInChannel && OutChannelTargetTestOverride)
            {
            TestOverrideUsed = TRUE;
            UnicodeString = OutChannelTargetTestOverride;
            }
        else
            {
            TestOverrideUsed = FALSE;

            if (Hint->ProxyNameLength + 1 > UnicodeStringSize)
                {
                if (UnicodeString)
                    delete [] UnicodeString;
                UnicodeString = new RPC_CHAR [Hint->ProxyNameLength + 1];
                if (UnicodeString == NULL)
                    {
                    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                        RPC_S_OUT_OF_MEMORY);
                    return RPC_S_OUT_OF_MEMORY;
                    }
                }

            FullAnsiToUnicode(Hint->RpcProxy, UnicodeString);
            }

        // Specify an HTTP server to talk to.
        hConnect = WinHttpConnectImp( hSession,
                                   UnicodeString,
                                   Hint->RpcProxyPort,
                                   NULL    // Reserved: must be NULL
                                   );

        if (TestOverrideUsed == FALSE)
            delete [] UnicodeString;

        if (!hConnect)
            {
            VALIDATE(GetLastError())
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Create an HTTP Request handle.
        AcceptTypes[0] = AcceptType;
        AcceptTypes[1] = NULL;

        if (HttpCredentials && (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL))
            FlagsToAdd = WINHTTP_FLAG_SECURE;
        else
            FlagsToAdd = 0;
        hRequest = WinHttpOpenRequestImp( hConnect,
                                       Verb,
                                       Url,
                                       NULL, // Version: HTTP/1.1
                                       WINHTTP_NO_REFERER, // Referer: none
                                       AcceptTypes, // AcceptTypes: all
                                       WINHTTP_FLAG_REFRESH | FlagsToAdd  // Flags
                                       );
        if (!hRequest)
            {
            VALIDATE(GetLastError())
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Query the optimal read buffer size.
        // We can only query the buffer size from the request handle.
        HttpResult = WinHttpQueryOptionImp( hRequest,
                                         WINHTTP_OPTION_READ_BUFFER_SIZE,
                                         (LPVOID)&iPostSize,
                                         &dwReadBufferSizeSize
                                         );
        // this cannot fail unless we give it invalid parameters
        ASSERT (HttpResult == TRUE);

        ASSERT(dwReadBufferSizeSize != 0);
        }
    else
        {
        ASSERT(hConnect != NULL);
        ASSERT(hRequest != NULL);
        }

    // do we have a winner? If yes, have we already set the credentials for
    // this scheme? Note that for Basic we need to set them every time.
    if (ChosenAuthScheme 
        && 
        (
         (ChosenAuthScheme != CredentialsSetForScheme)
         || 
         (ChosenAuthScheme == RPC_C_HTTP_AUTHN_SCHEME_BASIC)
        )
       )
        {
        // yes. Just use it
        ASSERT(HttpCredentials);

        // we will set the auto logon policy to low (i.e. send NTLM credentials)
        // in two cases. One is if SSL & mutual auth are used. The second is if LM
        // hash is disabled (i.e. the NTLM negotiate leg does not expose user credentials)
        // first, check whether the hash is enabled
        RpcStatus = IsLanManHashDisabled(&LanManHashDisabled);
        if (RpcStatus != RPC_S_OK)
            {
            VALIDATE(RpcStatus)
                {
                RPC_S_OUT_OF_MEMORY
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RpcStatus);
            return RpcStatus;
            }

        if (
            (
             (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
              &&
             (HttpCredentials->ServerCertificateSubject)
            )
            ||
            (LanManHashDisabled)
           )
            {
            SecLevel = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;
            HttpResult = WinHttpSetOptionImp( hRequest,
                                            WINHTTP_OPTION_AUTOLOGON_POLICY,
                                            &SecLevel, 
                                            sizeof(ULONG)
                                            );

            // this function cannot fail unless we give it invalid parameters
            ASSERT(HttpResult == TRUE);
            }

        TransHttpCredentials = I_RpcTransGetHttpCredentials(HttpCredentials);
        if (TransHttpCredentials == NULL)
            {
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        if (TransHttpCredentials->TransportCredentials)
            {
            User = TransHttpCredentials->TransportCredentials->User;
            Domain = TransHttpCredentials->TransportCredentials->Domain;
            Password = TransHttpCredentials->TransportCredentials->Password;
            DomainLength = RpcpStringLength(Domain);
            UserLength = RpcpStringLength(User);

            // add 1 for '\'
            DomainAndUserLength = DomainLength + 1 + UserLength;
            // add 1 for terminator
            DomainAndUserName = new RPC_CHAR [DomainAndUserLength + 1];
            if (DomainAndUserName == NULL)
                {
                I_RpcTransFreeHttpCredentials(TransHttpCredentials);
                LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                    RPC_S_OUT_OF_MEMORY);
                return RPC_S_OUT_OF_MEMORY;
                }

            RpcpMemoryCopy(DomainAndUserName, Domain, DomainLength * 2);
            DomainAndUserName[DomainLength] = '\\';
            RpcpMemoryCopy(DomainAndUserName + DomainLength + 1, User, UserLength * 2);
            DomainAndUserName[DomainLength + 1 + UserLength] = '\0';
            }
        else
            {
            if (ChosenAuthScheme == RPC_C_HTTP_AUTHN_SCHEME_BASIC)
                {
                // Basic does not support implicit credentials
                LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                    RPC_S_ACCESS_DENIED);
                return RPC_S_ACCESS_DENIED;
                }
            User = NULL;
            Password = NULL;
            DomainAndUserName = NULL;
            }

        HttpResult = WinHttpSetCredentialsImp (hRequest,
            WINHTTP_AUTH_TARGET_SERVER,
            ChosenAuthScheme,
            DomainAndUserName,
            Password,
            NULL
            );

        // success or error, free the domain and user name
        if (DomainAndUserName)
            {
            // technically speaking, we don't have to zero out user and domain name
            // since they are not secret. However, the way the heap works it is likely
            // that they will be next to our credentials, which are not encrypted very
            // strongly. So wipe out the domain and user to prevent an attacker from
            // using them to locate the credentials
            SecureZeroMemory(DomainAndUserName, DomainAndUserLength);
            delete [] DomainAndUserName;
            }

        if (!HttpResult)
            {
            LastError = GetLastError();

            VALIDATE(LastError)
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;
            }

        I_RpcTransFreeHttpCredentials(TransHttpCredentials);

        if (!HttpResult)
            {
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // remember that we have already set credentials for this scheme
        CredentialsSetForScheme = ChosenAuthScheme;
        }

    LocalEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (LocalEvent == NULL)
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    SyncEvent = LocalEvent;
    LastError = RPC_S_OK;

    // Send a Request.
    if (AdditionalData)
        {
        // if additional data to append, send them immediately
        AdditionalDataLengthToUse = ContentLength;
        ContentLengthToUse = ContentLength;
        }
    else
        {
        AdditionalDataLengthToUse = 0;
        ContentLengthToUse = ContentLength;
        }

    if ((PreviousRequestContentLength != -1) && (ContentLengthToUse != PreviousRequestContentLength))
        {
        // WinHttp normally doesn't update the content-length header if you reuse the
        // request. Do that now.
        RpcpMemoryCopy(ContentLengthString, ContentLengthHeader, sizeof(ContentLengthHeader));
        RpcpItow(ContentLengthToUse, ContentLengthString + (sizeof(ContentLengthHeader) / sizeof(RPC_CHAR)) - 1, 10);
        HttpResult = WinHttpAddRequestHeadersImp (hRequest,
            ContentLengthString,
            -1, // dwHeadersLength - have WinHttp calculate it
            WINHTTP_ADDREQ_FLAG_REPLACE
            );

        if (!HttpResult)
            {
            LastError = GetLastError();

            VALIDATE(LastError)
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            RpcStatus = LastError;
            goto CleanupAndExit;
            }
        }

    PreviousRequestContentLength = ContentLengthToUse;

    State = whtcsSendingRequest;

    HttpResult = WinHttpSendRequestImp( hRequest,
                                     WINHTTP_NO_ADDITIONAL_HEADERS, // Additional headers
                                     0, // Length of the additional headers
                                     (LPVOID)AdditionalData, // Optional data to append to the request
                                     AdditionalDataLengthToUse, // Length of the optional data
                                     ContentLengthToUse, // Length in bytes of the total data sent
                                     (DWORD_PTR) this  // Application-specified context for this request
                                     );
    if (!HttpResult)
        {
        SyncEvent = NULL;

        LastError = GetLastError();
        }
    else
        {
        // Sleep waiting for the send request to be completed.
        LastError = WaitForSingleObject(SyncEvent, INFINITE);
        SyncEvent = NULL;
        ASSERT(State == whtcsSentRequest);
        ASSERT(AsyncError != RPC_S_INTERNAL_ERROR);
        LastError = AsyncError;
        AsyncError = RPC_S_INTERNAL_ERROR;
        }

    if (LastError != RPC_S_OK)
        {
        VALIDATE(LastError)
            {
            ERROR_WINHTTP_CANNOT_CONNECT,
            ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_INVALID_URL,
            ERROR_WINHTTP_LOGIN_FAILURE,
            ERROR_WINHTTP_NAME_NOT_RESOLVED,
            ERROR_WINHTTP_OUT_OF_HANDLES,
            ERROR_WINHTTP_REDIRECT_FAILED,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SECURE_FAILURE,
            ERROR_WINHTTP_SHUTDOWN,
            ERROR_WINHTTP_TIMEOUT,
            ERROR_NOT_ENOUGH_MEMORY,
            ERROR_NOT_SUPPORTED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_SEND_FAILED,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_ACCESS_DENIED,
            ERROR_NO_SYSTEM_RESOURCES,
            ERROR_COMMITMENT_LIMIT,
            ERROR_NOT_ENOUGH_QUOTA
            } END_VALIDATE;

        switch (LastError)
            {
            case ERROR_WINHTTP_CANNOT_CONNECT:
            case ERROR_WINHTTP_CONNECTION_ERROR:
            case ERROR_WINHTTP_INVALID_URL:
            case ERROR_WINHTTP_NAME_NOT_RESOLVED:
            case ERROR_WINHTTP_REDIRECT_FAILED:
            case ERROR_WINHTTP_RESEND_REQUEST:
            case ERROR_WINHTTP_SHUTDOWN:
            case RPC_P_RECEIVE_FAILED:
            case RPC_P_SEND_FAILED:
                RpcStatus = RPC_S_SERVER_UNAVAILABLE;
                break;

            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
            case ERROR_WINHTTP_SECURE_FAILURE:
                RpcStatus = RPC_S_ACCESS_DENIED;
                break;

            case ERROR_WINHTTP_INVALID_SERVER_RESPONSE:
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                break;

            case ERROR_WINHTTP_OUT_OF_HANDLES:
            case ERROR_NOT_ENOUGH_MEMORY:
            case RPC_S_OUT_OF_MEMORY:
            case ERROR_NO_SYSTEM_RESOURCES:
            case ERROR_COMMITMENT_LIMIT:
            case ERROR_NOT_ENOUGH_QUOTA :
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;

            case ERROR_NOT_SUPPORTED:
                RpcStatus = RPC_S_CANNOT_SUPPORT;
                break;

            case ERROR_WINHTTP_TIMEOUT:
                RpcStatus = RPC_S_CALL_CANCELLED;
                break;

            default:
                // acess denied doesn't get remapped
                ASSERT(LastError == RPC_S_ACCESS_DENIED);
                RpcStatus = LastError;
                break;
            }
        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
            RpcStatus);

        goto CleanupAndExit;
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RPC_S_OK);

    RpcStatus = RPC_S_OK;

CleanupAndExit:
    if (LocalEvent != NULL)
        CloseHandle(LocalEvent);

    return RpcStatus;
}
                                      
RPC_STATUS HTTP2WinHttpTransportChannel::Send (
        IN OUT HTTP2SendContext *SendContext
        )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL HttpResult = TRUE;
    ULONG LastError;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        (ULONG_PTR)SendContext);

    Mutex.Request();
    SendsPending ++;
    ASSERT(SendsPending >= 0);
    if (SendsPending > 1)
        {
        // queue and exit
        SendContext->SetListEntryUsed();
        RpcpInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
        Mutex.Clear();

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_WINHTTP_CHANNEL, 
            SendsPending);

        return RPC_S_OK;
        }
    Mutex.Clear();

    ASSERT(State == whtcsSentRequest);

    State = whtcsWriting;

    CurrentSendContext = SendContext;

    HttpResult = WinHttpWriteDataImp(hRequest,
                                  SendContext->pWriteBuffer,
                                  SendContext->maxWriteBuffer,
                                  NULL // Number of bytes sent will be provided on async completion.
                                  );
    if (HttpResult == FALSE)
        {
        // Revert the state if a write could not be posted.
        State = whtcsSentRequest;

        LastError = GetLastError();

        VALIDATE(LastError)
            {
            ERROR_NOT_ENOUGH_MEMORY,
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SHUTDOWN,
            ERROR_WINHTTP_INTERNAL_ERROR
            } END_VALIDATE;

        RpcStatus = RPC_P_SEND_FAILED;
        }
    else
        RpcStatus = RPC_S_OK;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
};

RPC_STATUS HTTP2WinHttpTransportChannel::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL HttpResult;
    ULONG LastError;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        TrafficType);

    //
    // Before we can do any receives, we need to do a WinHttpReceiveResponse
    // if it has not been issued yet.
    //
    // This call only needs to be done before the first Receive.
    //

    if (State != whtcsReceivedResponse)
        {
        Mutex.Request();

        // if there are still sends, we have indicated our
        // traffic type in the DelayedReceiveTrafficType.
        // Just exit, and the last send will do the receive
        // work.
        if (SendsPending > 0)
            {
            if (TrafficType == http2ttRTS)
                DelayedReceiveTrafficType = http2ttRTSWithSpecialBit;
            else if (TrafficType == http2ttData)
                DelayedReceiveTrafficType = http2ttDataWithSpecialBit;
            else
                {
                ASSERT(TrafficType == http2ttRaw);
                DelayedReceiveTrafficType = http2ttRawWithSpecialBit;
                }
            Mutex.Clear();
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                SendsPending);

            return RPC_S_OK;
            }
        Mutex.Clear();

        DelayedReceiveTrafficType = TrafficType;

        ASSERT(State == whtcsSentRequest);

        State = whtcsReceivingResponse;

        HttpResult = WinHttpReceiveResponseImp(hRequest, NULL);

        // If the function returned FALSE, then it has failed syncronously.
        if (!HttpResult)
            {
            DelayedReceiveTrafficType = http2ttNone;

            LastError = GetLastError();

            VALIDATE(LastError)
                    {
                    ERROR_WINHTTP_CANNOT_CONNECT,
                    ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                    ERROR_WINHTTP_CONNECTION_ERROR,
                    ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                    ERROR_WINHTTP_INVALID_URL,
                    ERROR_WINHTTP_LOGIN_FAILURE,
                    ERROR_WINHTTP_NAME_NOT_RESOLVED,
                    ERROR_WINHTTP_OUT_OF_HANDLES,
                    ERROR_WINHTTP_REDIRECT_FAILED,
                    ERROR_WINHTTP_RESEND_REQUEST,
                    ERROR_WINHTTP_SECURE_FAILURE,
                    ERROR_WINHTTP_SHUTDOWN,
                    ERROR_WINHTTP_TIMEOUT,
                    ERROR_NOT_SUPPORTED,
                    ERROR_WINHTTP_INTERNAL_ERROR
                    } END_VALIDATE;

            switch (LastError)
                {
                case ERROR_WINHTTP_CONNECTION_ERROR:
                case ERROR_WINHTTP_REDIRECT_FAILED:
                case ERROR_WINHTTP_RESEND_REQUEST:
                case ERROR_WINHTTP_SHUTDOWN:
                case ERROR_WINHTTP_SECURE_FAILURE:
                    RpcStatus = RPC_P_RECEIVE_FAILED;
                    break;

                case ERROR_WINHTTP_INVALID_SERVER_RESPONSE:
                    RpcStatus = RPC_S_PROTOCOL_ERROR;
                    break;

                case ERROR_NOT_SUPPORTED:
                    RpcStatus = RPC_S_CANNOT_SUPPORT;
                    break;

                case ERROR_WINHTTP_TIMEOUT:
                    RpcStatus = RPC_S_CALL_CANCELLED;
                    break;

                default:
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    break;
                }

            VALIDATE(RpcStatus)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES,
                RPC_P_RECEIVE_FAILED,
                RPC_S_CALL_CANCELLED,
                RPC_P_SEND_FAILED,
                RPC_P_CONNECTION_SHUTDOWN,
                RPC_P_TIMEOUT
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RpcStatus);

            return RpcStatus;
            }
        else
            {
            // If the function returned TRUE, then it will complete asyncronously.
            // We should return. All additional work will be done on a separate thread

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OK);

            return RPC_S_OK;
            }
        }

    RpcStatus = HTTP2FragmentReceiver::Receive(TrafficType);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
};

RPC_STATUS HTTP2WinHttpTransportChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    ULONG LocalSendsPending;
    BOOL HttpResult;
    ULONG LastError;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        EventStatus);

    CurrentSendContext = NULL;

    Mutex.Request();
    // decrement this in advance so that if we post another send on send
    // complete, it doesn't get queued
    LocalSendsPending = -- SendsPending;
    ASSERT(SendsPending >= 0);

    Mutex.Clear();

    // If we are processing a failed send-complete, this call may abort
    // the channels and complete pending sends.
    EventStatus = HTTP2TransportChannel::SendComplete(EventStatus, SendContext);

    if ((EventStatus == RPC_S_OK)
        || (EventStatus == RPC_P_PACKET_CONSUMED) )
        {
        QueuedSendContext = NULL;

        // Check if we have a queued send context.
        // Because we pre-decremented SendsPending, we have "borrowed"
        // a count and there is a queued context iff the count is above 0.
        if (LocalSendsPending > 0)
            {
            Mutex.Request();
            QueuedListEntry = RpcpRemoveHeadList(&BufferQueueHead);
            ASSERT(QueuedListEntry);
            ASSERT(QueuedListEntry != &BufferQueueHead);
            QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);
            Mutex.Clear();
            QueuedSendContext->SetListEntryUnused();
            }

        if (QueuedSendContext)
            {
            ASSERT(State == whtcsSentRequest);

            State = whtcsWriting;

            // need to synchronize with aborts (rule 9)
            RpcStatus = TopChannel->BeginSimpleSubmitAsync();

            CurrentSendContext = QueuedSendContext;
            NumberOfBytesTransferred = QueuedSendContext->maxWriteBuffer;

            if (RpcStatus == RPC_S_OK)
                {
                HttpResult = WinHttpWriteDataImp(hRequest,
                                              QueuedSendContext->pWriteBuffer,
                                              QueuedSendContext->maxWriteBuffer,
                                              NULL // Number of bytes sent will be provided on async completion.
                                              );

                TopChannel->FinishSubmitAsync();

                if (HttpResult == FALSE)
                    {
                    // Revert the state if a write could not be posted.
                    State = whtcsSentRequest;

                    LastError = GetLastError();

                    VALIDATE(LastError)
                        {
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SHUTDOWN
                        } END_VALIDATE;

                    // the send failed. We don't get a notification for it
                    // so we must issue one. We do this by posting direct send
                    AsyncError = RPC_P_SEND_FAILED;
                    ASSERT(CurrentSendContext == QueuedSendContext);

                    (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                        this
                        );
                    }
                else
                    {
                    // nothing to do - notification will come asynchronously
                    }
                }
            else
                {
                // Revert the state if a write could not be posted.
                State = whtcsSentRequest;

                AsyncError = RPC_P_SEND_FAILED;
                ASSERT(CurrentSendContext == QueuedSendContext);

                (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                    this
                    );
                }
            }
        }

    // if a receive has registered itself and we're the one who finished the
    // sends, do the receive
    if (
        (
         (DelayedReceiveTrafficType == http2ttRTSWithSpecialBit)
         || (DelayedReceiveTrafficType == http2ttDataWithSpecialBit)
         || (DelayedReceiveTrafficType == http2ttRawWithSpecialBit)
        )
        && 
        (LocalSendsPending == 0)
       )
        {
        if (DelayedReceiveTrafficType == http2ttRTSWithSpecialBit)
            DelayedReceiveTrafficType = http2ttRTS;
        else if (DelayedReceiveTrafficType == http2ttRawWithSpecialBit)
            DelayedReceiveTrafficType = http2ttRaw;
        else
            {
            ASSERT(DelayedReceiveTrafficType == http2ttDataWithSpecialBit);
            DelayedReceiveTrafficType = http2ttData;
            }

        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = Receive(DelayedReceiveTrafficType);

            TopChannel->FinishSubmitAsync();
            }

        if (RpcStatus != RPC_S_OK)
            {
            // offload the result as direct receive. We use the refcount of the receive
            // to complete the operation on the worker thread.
            AsyncError = RpcStatus;

            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            }
        else
            {
            // when it completes, it will issue its own notification
            }
        }

    // don't call AsyncCompleteHelper here. We will always be called from DirectSendComplete
    // which will call AsyncCompleteHelper for us

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        EventStatus);

    return EventStatus;
}

//
// WinHttpCloseHandle may return failure in low-memory conditions.
// We will just re-try several times and record that a handle has been leaked.
// We should remove this code when:
// 647932 WinHttpCloseHandle fails in low memory conditions
// is fixed.
//

unsigned int nWinHttpHandlesLeaked = 0;

void HTTP2WinHttpTransportChannel::TryClosingWinHttpHandle (
    IN HINTERNET *pHandle
    )
/*++

Routine Description:

    Tries to close a WinHttp handle.

Arguments:

    hHandle - Pointer to a handle to close.  Handle is set to NULL after lcosing.

--*/
{
    BOOL HttpResult;
    unsigned int nRetries = 10;

    do
        {
        HttpResult = WinHttpCloseHandleImp(*pHandle);
        if (!HttpResult)
            {
            nRetries--;
            Sleep (10);
            }
        }
    while (!HttpResult && nRetries > 0);

    if (nRetries == 0)
        {
        nWinHttpHandlesLeaked++;
        }

    *pHandle = NULL;
}

void HTTP2WinHttpTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

Notes:

    This method must be idempotent. It may be called multiple times.

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_WINHTTP_CHANNEL, RpcStatus);

    if (hRequest)
        {
        TryClosingWinHttpHandle(&hRequest);
        }

    if (hConnect)
        {
        TryClosingWinHttpHandle(&hConnect);
        }

    if (hSession)
        {
        TryClosingWinHttpHandle(&hSession);
        }

    Mutex.Request();
    // If there are more then 1 pending sends, then some sends must have been queued.
    // We will abort the queued sends.
    for (; SendsPending > 1; )
        {
        ASSERT(!RpcpIsListEmpty(&BufferQueueHead));
        QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

        -- SendsPending;
        ASSERT(SendsPending > 0);
        HTTP2TransportChannel::SendComplete(RpcStatus, QueuedSendContext);
        AsyncCompleteHelper(RpcStatus);
        }
    Mutex.Clear();
}

void HTTP2WinHttpTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_WINHTTP_CHANNEL, 0);

    if (pReadBuffer)
        {
        RpcFreeBuffer(pReadBuffer);
        pReadBuffer = NULL;
        }

    HTTP2WinHttpTransportChannel::~HTTP2WinHttpTransportChannel();
}

RPC_STATUS HTTP2WinHttpTransportChannel::DirectReceiveComplete (
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection
    )
/*++

Routine Description:

    Direct receive completion (i.e. we posted a receive
    to ourselves)

Arguments:

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

Return Value:

    RPC_S_OK, RPC_P_PACKET_CONSUMED or RPC_S_* errors.

--*/
{
    RPC_STATUS RpcStatus;
    BOOL HttpResult;
    ULONG WaitResult;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        AsyncError);

    *RuntimeConnection = TopChannel->GetRuntimeConnection();

    // two cases - previous coalesced read and a real read
    if (iLastRead && iLastRead == MaxReadBuffer)
        {
        // previous coalesced read
        *ReceivedBufferLength = MaxReadBuffer;
        iLastRead = 0;
        RpcStatus = RPC_S_OK;
        }
    else
        {
        // real read
        ASSERT(AsyncError != RPC_S_INTERNAL_ERROR);

        if ((AsyncError == RPC_S_OK) 
            && (NumberOfBytesTransferred == 0))
            {
            // zero bytes transferred indicates end of request.
            AsyncError = RPC_P_RECEIVE_FAILED;
            }

        RpcStatus = AsyncError;
        AsyncError = RPC_S_INTERNAL_ERROR;

        if (RpcStatus == RPC_S_OK)
            {
            if (pReadBuffer == NULL)
                {
                if (NumberOfBytesTransferred > iPostSize)
                    MaxReadBuffer = NumberOfBytesTransferred;
                else
                    MaxReadBuffer = iPostSize;
                pReadBuffer = (BYTE *)RpcAllocateBuffer(MaxReadBuffer);
                // fall through for error check below
                }
            else if (MaxReadBuffer - iLastRead < NumberOfBytesTransferred)
                {
                ASSERT(iLastRead < MaxReadBuffer);

                // Buffer too small for the message.
                RpcStatus = TransConnectionReallocPacket(NULL,
                                                      &pReadBuffer,
                                                      iLastRead,
                                                      iLastRead + NumberOfBytesTransferred
                                                      );

                if (RpcStatus != RPC_S_OK)
                    {
                    RpcFreeBuffer(pReadBuffer);
                    pReadBuffer = NULL;
                    }

                MaxReadBuffer = iLastRead + NumberOfBytesTransferred;
                }
            else
                {
                // buffer should be enough - no need to reallocate
                ASSERT(iLastRead < MaxReadBuffer);
                }
    
            if (pReadBuffer == NULL)
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                NumberOfBytesTransferred = 0;
                }
            else
                {
                // we need to temporarily get into submission context to synchronize
                // with Aborts
                RpcStatus = TopChannel->BeginSimpleSubmitAsync();
                if (RpcStatus == RPC_S_OK)
                    {
                    ASSERT(SyncEvent == NULL);
                    SyncEvent = I_RpcTransGetThreadEvent();
                    ResetEvent(SyncEvent);

                    HttpResult = WinHttpReadDataImp(hRequest,
                                                 pReadBuffer + iLastRead,
                                                 NumberOfBytesTransferred,
                                                 NULL // Number of bytes read will be provided on async completion.
                                                 );

                    // wait for read complete to finish
                    WaitResult = WaitForSingleObject(SyncEvent, INFINITE);
                    // this cannot fail
                    ASSERT(WaitResult == WAIT_OBJECT_0);
                    SyncEvent = NULL;

                    // the data are available. We cannot possibly fail
                    ASSERT(HttpResult);
                    TopChannel->FinishSubmitAsync();

                    VALIDATE (AsyncError)
                        {
                        RPC_P_RECEIVE_FAILED,
                        RPC_S_OK
                        } END_VALIDATE;

                    RpcStatus = AsyncError;
                    AsyncError = RPC_S_INTERNAL_ERROR;
                    // fall through with the status
                    }
                else
                    {
                    // fall through with the error.
                    }
                }
            }

        *ReceivedBufferLength = NumberOfBytesTransferred;
        }

    RpcStatus = HTTP2WinHttpTransportChannel::ReceiveComplete(RpcStatus,
        http2ttRaw,
        ReceivedBuffer,
        (UINT *)ReceivedBufferLength
        );

    // did we receive an incomplete buffer?
    if ((RpcStatus == RPC_S_OK) && (*ReceivedBuffer == NULL))
        {
        // hide it from the runtime
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }

    // AsyncCompleteHelper has already been called in ReceiveComplete

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
}

RPC_STATUS HTTP2WinHttpTransportChannel::DirectSendComplete (
    OUT BYTE **SentBuffer,
    OUT void **SendContext
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us). 

Arguments:

    SentBuffer - on output the buffer that we tried to send

    SendContext - on output contains the send context as 
        seen by the runtime

Return Value:

    RPC_S_OK to return error to runtime
    RPC_P_PACKET_CONSUMED - to hide packet from runtime
    RPC_S_* error - return error to runtime

--*/
{
    HTTP2SendContext *LocalCurrentSendContext;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        AsyncError);

    ASSERT(AsyncError != RPC_S_INTERNAL_ERROR);

    ASSERT(CurrentSendContext);

    State = whtcsSentRequest;

    LocalCurrentSendContext = CurrentSendContext;

    // CurrentSendContext is zeroed out by the call.
    RpcStatus = HTTP2WinHttpTransportChannel::SendComplete(AsyncError, LocalCurrentSendContext);

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        // this will return to the runtime. Make sure it is valid
        I_RpcTransVerifyClientRuntimeCallFromContext(LocalCurrentSendContext);
        *SendContext = LocalCurrentSendContext;
        *SentBuffer = LocalCurrentSendContext->pWriteBuffer;
        }
    else
        {
        // the packet was a transport packet - it won't be seen by the runtime
        *SendContext = NULL;
        *SentBuffer = NULL;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);
    // do not touch this pointer after here unless the list was not-empty
    // (which implies we still have refcounts)

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
}

void HTTP2WinHttpTransportChannel::DelayedReceive (
    void
    )
/*++

Routine Description:

    Performs a delayed receive. The first receive on an WinHttp
    channel is delayed because we must receive the headers before
    we can do the actual receive.

Arguments:

Return Value:

Note: Will be called from upcall context

--*/
{
    BOOL HttpResult;
    ULONG LastError;
    RPC_STATUS RpcStatus;
    BOOL InSubmissionContext;
    BYTE *Ignored;
    UINT BufferLength;
    ULONG StatusCode;
    ULONG StatusCodeLength;
    ULONG HttpStatus;
    RPC_CHAR ConnectionOptions[40];
    RPC_CHAR *ConnectionOptionsToUse;
    ULONG ConnectionOptionsLength;
    int i;
    RPC_CHAR *KeepAliveString;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_WHTTP_DELAYED_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        AsyncError);

    // Check if we have received an async failure.
    LastError = AsyncError;
    AsyncError = RPC_S_INTERNAL_ERROR;
    RpcStatus = RPC_S_OK;
    InSubmissionContext = FALSE;

    if (LastError == RPC_S_OK)
        {
        // get into submission context
        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            InSubmissionContext = TRUE;

            StatusCodeLength = sizeof(StatusCode);
            HttpResult = WinHttpQueryHeadersImp (
                hRequest,
                WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                WINHTTP_HEADER_NAME_BY_INDEX,
                &StatusCode,
                &StatusCodeLength,
                WINHTTP_NO_HEADER_INDEX
                );

            if (!HttpResult)
                {
                LastError = GetLastError();
                }
            else
                {
                if (StatusCode != HTTP_STATUS_OK)
                    {
                    if ((StatusCode >= RPC_S_INVALID_STRING_BINDING) && (StatusCode <= RPC_X_BAD_STUB_DATA))
                        {
                        // if it is an RPC error code, just return it.
                        RpcStatus = StatusCode;
                        }
                    else if ((StatusCode == HTTP_STATUS_NOT_FOUND)
                        || (StatusCode == HTTP_STATUS_BAD_METHOD)
                        || (StatusCode == HTTP_STATUS_BAD_METHOD)
                        || (StatusCode == HTTP_STATUS_SERVER_ERROR)
                        || (StatusCode == HTTP_STATUS_NOT_SUPPORTED)
                        || (StatusCode == HTTP_STATUS_SERVICE_UNAVAIL) )
                        {
                        RpcStatus = RPC_S_SERVER_UNAVAILABLE;
                        }
                    else if (StatusCode == HTTP_STATUS_REQUEST_TOO_LARGE)
                        RpcStatus = RPC_S_SERVER_OUT_OF_MEMORY;
                    else if (StatusCode == HTTP_STATUS_PROXY_AUTH_REQ)
                        {
                        if ((HttpCredentials == NULL) 
                            || (HttpCredentials->AuthenticationTarget & RPC_C_HTTP_AUTHN_TARGET_PROXY) == 0)
                            {
                            // we were not asked to authenticate against a proxy. Just fail
                            RpcStatus = RPC_S_ACCESS_DENIED;
                            }
                        else
                            {
                            ChosenAuthScheme = NegotiateAuthScheme();
                            if (ChosenAuthScheme == 0)
                                RpcStatus = RPC_S_ACCESS_DENIED;
                            else
                                {
                                State = whtcsDraining;
                                HttpResult = WinHttpQueryDataAvailableImp(hRequest,
                                    NULL // Number of bytes available will be provided on async completion.
                                    );

                                ASSERT(HttpResult);
                                RpcStatus = RPC_S_OK;
                                goto CleanupAndExit;
                                }
                            }
                        }
                    else if (StatusCode == HTTP_STATUS_DENIED)
                        {
                        if ((HttpCredentials == NULL) 
                            || (HttpCredentials->AuthenticationTarget & RPC_C_HTTP_AUTHN_TARGET_SERVER) == 0)
                            {
                            // we were not asked to authenticate against a server. Just fail
                            RpcStatus = RPC_S_ACCESS_DENIED;
                            }
                        else
                            {
                            ChosenAuthScheme = NegotiateAuthScheme();
                            if (ChosenAuthScheme == 0)
                                RpcStatus = RPC_S_ACCESS_DENIED;
                            else
                                {
                                State = whtcsDraining;
                                HttpResult = WinHttpQueryDataAvailableImp(hRequest,
                                    NULL // Number of bytes available will be provided on async completion.
                                    );

                                ASSERT(HttpResult);

                                RpcStatus = RPC_S_OK;
                                goto CleanupAndExit;
                                }
                            }
                        }
                    else
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                    }
                else
                    {
                    // RpcStatus is already set above
                    ASSERT(RpcStatus == RPC_S_OK);

                    ConnectionOptionsLength = sizeof(ConnectionOptions);
                    ConnectionOptionsToUse = ConnectionOptions;

                    for (i = 0; i < 2; i ++)
                        {
                        HttpResult = WinHttpQueryHeadersImp (
                            hRequest,
                            WINHTTP_QUERY_CONNECTION,
                            WINHTTP_HEADER_NAME_BY_INDEX,
                            ConnectionOptionsToUse,
                            &ConnectionOptionsLength,
                            WINHTTP_NO_HEADER_INDEX
                            );

                        if (!HttpResult)
                            {
                            LastError = GetLastError();
                            if (LastError == ERROR_INSUFFICIENT_BUFFER)
                                {
                                ConnectionOptionsToUse = new RPC_CHAR[ConnectionOptionsLength];
                                if (ConnectionOptionsToUse == NULL)
                                    {
                                    LastError = RPC_S_OUT_OF_MEMORY;
                                    // fall through with the error below
                                    break;
                                    }
                                }
                            else if (LastError == ERROR_WINHTTP_HEADER_NOT_FOUND)
                                {
                                // we did not get keep alives. This is ok
                                LastError = RPC_S_OK;
                                KeepAlive = FALSE;
                                break;
                                }
                            else
                                {
                                LastError = RPC_S_OUT_OF_MEMORY;
                                // fall through with the error below
                                break;
                                }
                            }
                        else
                            {
                            LastError = RPC_S_OK;
                            break;
                            }
                        }   // for (i ...

                    ASSERT(LastError != ERROR_INSUFFICIENT_BUFFER);
                    if (LastError == RPC_S_OK)
                        {
                        // we got the connection options. Do we have keep alive?
                        KeepAliveString = RpcpStrStr(ConnectionOptionsToUse, L"Keep-Alive");
                        if (KeepAliveString)
                            KeepAlive = TRUE;
                        }

                    if (ConnectionOptionsToUse != ConnectionOptions)
                        delete [] ConnectionOptionsToUse;

                    }   // StatusCode == HTTP_STATUS_OK
                }   // WinHttpQueryHeadersImp succeeded
            }   // BeginSimpleSubmitAsync succeeded
        else
            {
            // BeginSimpleSubmitAsync failed - fall through with the error
            // RpcStatus and success LastError
            ASSERT(LastError == RPC_S_OK);
            }
        }

    if (LastError != RPC_S_OK)
        {
        VALIDATE(LastError)
            {
            ERROR_WINHTTP_CANNOT_CONNECT,
            ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_INVALID_URL,
            ERROR_WINHTTP_LOGIN_FAILURE,
            ERROR_WINHTTP_NAME_NOT_RESOLVED,
            ERROR_WINHTTP_OUT_OF_HANDLES,
            ERROR_WINHTTP_REDIRECT_FAILED,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SECURE_FAILURE,
            ERROR_WINHTTP_SHUTDOWN,
            ERROR_WINHTTP_TIMEOUT,
            ERROR_NOT_SUPPORTED,
            RPC_P_SEND_FAILED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_AUTH_NEEDED
            } END_VALIDATE;

        switch (LastError)
            {
            case ERROR_WINHTTP_CONNECTION_ERROR:
            case ERROR_WINHTTP_REDIRECT_FAILED:
            case ERROR_WINHTTP_RESEND_REQUEST:
            case ERROR_WINHTTP_SHUTDOWN:
            case ERROR_WINHTTP_CANNOT_CONNECT:
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
            case ERROR_WINHTTP_INVALID_URL:
            case ERROR_WINHTTP_LOGIN_FAILURE:
            case ERROR_WINHTTP_NAME_NOT_RESOLVED:
            case ERROR_WINHTTP_SECURE_FAILURE:
            case RPC_P_AUTH_NEEDED:
                RpcStatus = RPC_P_RECEIVE_FAILED;
                break;

            case ERROR_WINHTTP_INVALID_SERVER_RESPONSE:
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                break;

            case ERROR_NOT_SUPPORTED:
                RpcStatus = RPC_S_CANNOT_SUPPORT;
                break;

            case ERROR_WINHTTP_TIMEOUT:
                RpcStatus = RPC_S_CALL_CANCELLED;
                break;

            case RPC_P_SEND_FAILED:
            case RPC_P_RECEIVE_FAILED:
                RpcStatus = LastError;
                break;

            default:
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;
            }

        VALIDATE(RpcStatus)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_RECEIVE_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_TIMEOUT
            } END_VALIDATE;
        }

    if (RpcStatus == RPC_S_OK)
        {
        ASSERT(InSubmissionContext);

        RpcStatus = HTTP2FragmentReceiver::Receive(DelayedReceiveTrafficType);
        }

CleanupAndExit:
    if (InSubmissionContext)
        {
        TopChannel->FinishSubmitAsync();
        }

    DelayedReceiveTrafficType = http2ttNone;

    if (RpcStatus != RPC_S_OK)
        {
        // we got a failure. Issue receive complete. Since DelayedReceive
        // happens only on channel recycling, and then we know we
        // issue RTS receive, we don't need to indicate this to the runtime
        BufferLength = 0;
        RpcStatus = ReceiveComplete(RpcStatus, 
            DelayedReceiveTrafficType,
            &Ignored,
            &BufferLength
            );

        ASSERT(RpcStatus == RPC_P_PACKET_CONSUMED);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_WHTTP_DELAYED_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);
}

void HTTP2WinHttpTransportChannel::VerifyServerCredentials (
    void
    )
/*++

Routine Description:

    Verifies that the server credentials match the subject info we
    were given.

Arguments:
    
Return Value:

--*/
{
    BOOL HttpResult;
    PCERT_CONTEXT CertContext;
    ULONG OptionSize;
    RPC_STATUS RpcStatus;
    RPC_CHAR *StringSPN;
    RPC_STATUS AbortError;

    // make sure nobody has touched the async error after open
    ASSERT((AsyncError == RPC_S_OK)
        || ((AsyncError == RPC_S_INTERNAL_ERROR)));

    // if no credentials, nothing to verify
    if ((HttpCredentials == NULL) 
        || (HttpCredentials->ServerCertificateSubject == NULL))
        return;

    OptionSize = sizeof(PCERT_CONTEXT);
    HttpResult = WinHttpQueryOptionImp(hRequest,
        WINHTTP_OPTION_SERVER_CERT_CONTEXT,
        &CertContext,
        &OptionSize
        );

    if (!HttpResult)
        {
        AsyncError = GetLastError();
        VALIDATE(AsyncError)
            {
            ERROR_NOT_ENOUGH_MEMORY,
            ERROR_INVALID_OPERATION
            } END_VALIDATE;

        switch (AsyncError)
            {
            case ERROR_INVALID_OPERATION:
                // we will get this when we ask for the certificate of non
                // SSL connection
                AsyncError = RPC_S_ACCESS_DENIED;
                break;

            default:
                AbortError = RPC_S_OUT_OF_MEMORY;
            }

        goto AbortAndExit;
        }

    RpcStatus = I_RpcTransCertMatchPrincipalName(CertContext, HttpCredentials->ServerCertificateSubject);
    if (RpcStatus != RPC_S_OK)
        {
        AbortError = AsyncError = RpcStatus;
        goto AbortAndExit;
        }

    return;

AbortAndExit:
    ASSERT(AsyncError != ERROR_SUCCESS);
    // HTTP2WinHttpTransportChannel::Abort is idempotent. We'll call it now to
    // tell WinHttp to abort, and ClientOpen will call it again. This is ok.
    Abort(AbortError);
}

RPC_STATUS HTTP2WinHttpTransportChannel::PostReceive (
    void
    )
/*++

Routine Description:

    Posts a receive to WinHttp.

Arguments:
    
Return Value:

    RPC_S_OK or RPC_S_* error

Note: May be called from both submission and upcall context

--*/
{
    BOOL HttpResult;
    RPC_STATUS RpcStatus;
    ULONG LastError;
    ULONG AvailableLength;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 0);

    ASSERT(State == whtcsReceivedResponse);

    State = whtcsReading;

    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        {
        // Revert the state if a read could not be posted.
        State = whtcsReceivedResponse;
        return RpcStatus;
        }

    HttpResult = WinHttpQueryDataAvailableImp (hRequest,
        NULL // Number of bytes available will be provided on async completion.
        );

    TopChannel->FinishSubmitAsync();

    if (!HttpResult)
        {
        LastError = GetLastError();

        VALIDATE(LastError)
            {
            ERROR_NOT_ENOUGH_MEMORY,
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SHUTDOWN
            } END_VALIDATE;

        // Revert the state if a read could not be posted.
        State = whtcsReceivedResponse;
        RpcStatus = RPC_P_RECEIVE_FAILED;
        }
    else
        {
        // If the function returned non-zero,
        // then it will complete asyncronously.
        // Nothing to do here, we will receive async notification.
        RpcStatus = RPC_S_OK;
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, RpcStatus);
    
    return RpcStatus;
}

ULONG HTTP2WinHttpTransportChannel::GetPostRuntimeEvent (
    void
    )
/*++

Routine Description:

    Gets the message to be posted to the runtime.

Arguments:

Return Value:

    The message to post to the runtime

--*/
{
    return HTTP2_WINHTTP_DIRECT_RECV;
}

ULONG HTTP2WinHttpTransportChannel::NegotiateAuthScheme (
    void
    )
/*++

Routine Description:

    Negotiates an auth scheme supported by client and server/proxy
    according to preference rules.

Arguments:

Return Value:

    The negotiated scheme or 0 if no scheme could be negotiated.

Notes:

    The actual server/proxy supported/preferred schemes will be retrieved
    from hRequest.

--*/
{
    BOOL HttpResult;
    ULONG Ignored;
    ULONG ServerSupportedSchemes;   // we use Server for brevity, but this
    ULONG ServerPreferredScheme;   // applies to proxies as well
    ULONG *ClientSupportedSchemes;
    ULONG CountOfClientSupportedSchemes;
    int i;
    
    HttpResult = WinHttpQueryAuthSchemesImp (hRequest,
        &ServerSupportedSchemes,
        &ServerPreferredScheme,
        &Ignored        // pdwAuthTarget - we have already determined this
                        // from the error code - ignore now.
        );

    if (!HttpResult)
        return 0;

    // first, if we support the server preference, we just choose
    // that.
    CountOfClientSupportedSchemes = HttpCredentials->NumberOfAuthnSchemes;
    ClientSupportedSchemes = HttpCredentials->AuthnSchemes;

    ASSERT(CountOfClientSupportedSchemes > 0);
    ASSERT(ClientSupportedSchemes != NULL);

    for (i = 0; i < CountOfClientSupportedSchemes; i ++)
        {
        if (ServerPreferredScheme == ClientSupportedSchemes[i])
            return ServerPreferredScheme;
        }

    // client doesn't support what the server asks for. Try whether the server
    // supports what the client prefers
    for (i = 0; i < CountOfClientSupportedSchemes; i ++)
        {
        if (ServerSupportedSchemes & ClientSupportedSchemes[i])
            return ClientSupportedSchemes[i];
        }

    return 0;
}


void HTTP2WinHttpTransportChannel::ContinueDrainChannel (
    void
    )
/*++

Routine Description:

    Continue draining the channel after authentication challenge. We
    need to drain the channel before we can proceed with the next
    request. The number of bytes received is in NumberOfBytesTransferred.
    If the channel was aborted in the meantime, issue receive
    complete.

Arguments:

Return Value:

--*/
{
    BYTE *Buffer;
    RPC_STATUS RpcStatus;
    BOOL HttpResult;
    HANDLE LocalSyncEvent;

    // read the reported bytes. Then query again. If the
    // number of bytes reported is 0, issue a receive
    // for RPC_P_AUTH_NEEDED
    if (NumberOfBytesTransferred > 0)
        {
        ASSERT(State == whtcsDraining);

        Buffer = (BYTE *)RpcAllocateBuffer(NumberOfBytesTransferred);
        if (Buffer == NULL)
            {
            AsyncError = RPC_S_OUT_OF_MEMORY;
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            return;
            }

        // get into submissions context in order to safely access the
        // request
        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus != RPC_S_OK)
            {
            RpcFreeBuffer(Buffer);
            AsyncError = RpcStatus;
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            return;
            }

        ASSERT(SyncEvent == NULL);

        LocalSyncEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (LocalSyncEvent == NULL)
            {
            TopChannel->FinishSubmitAsync();
            RpcFreeBuffer(Buffer);
            AsyncError = RPC_S_OUT_OF_MEMORY;
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            return;
            }

        // read complete expects this state. Substitute it for draining
        // for now. We'll restore it back later.
        State = whtcsReceivedResponse;
        SyncEvent = LocalSyncEvent;

        HttpResult = WinHttpReadDataImp (hRequest,
            Buffer,
            NumberOfBytesTransferred,
            NULL // Number of bytes read will be provided on async completion.
            );

        // read complete expects this state. Substitute it for draining
        // for now. We'll restore it back later.
        State = whtcsDraining;
        SyncEvent = NULL;
        CloseHandle(LocalSyncEvent);

        // the data are here. This cannot fail
        ASSERT(HttpResult);

        RpcFreeBuffer(Buffer);

        // ask for more
        HttpResult = WinHttpQueryDataAvailableImp (hRequest,
            NULL // Number of bytes available will be provided on async completion.
            );

        ASSERT(HttpResult);

        TopChannel->FinishSubmitAsync();

        // if WinHttp has the data, it will complete the QueryDataAvailable
        // on the same thread as we are causing a recursive call to 
        // ContinueDrainChannel. If the recursion completed with success, we
        // will already have RPC_P_AUTH_NEEDED for the AsyncError. Check
        // for this case and bail out. All is done - we just need to get
        // out of here
        if (AsyncError == RPC_P_AUTH_NEEDED)
            {
            return;
            }
        else if (AsyncError == RPC_S_INTERNAL_ERROR)
            {
            // if WinHttpQueryDataAvailable resulted in recursive call
            // of this function, deeper recursive levels may have set
            // AsyncError to RPC_S_INTERNAL_ERROR. Reset if back
            // once we pop out of the recursion. Since we will set it
            // back on output from this function, this is a no-op.
            AsyncError = RPC_S_OK;
            }

        VALIDATE (AsyncError)
            {
            RPC_P_RECEIVE_FAILED,
            RPC_S_OK
            } END_VALIDATE;

        if (AsyncError != RPC_S_OK)
            {
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            return;
            }

        AsyncError = RPC_S_INTERNAL_ERROR;
        }
    else
        {
        AsyncError = RPC_P_AUTH_NEEDED;
        (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
            this
            );
        }
}

/*********************************************************************
    HTTP2ProxySocketTransportChannel
 *********************************************************************/

RPC_STATUS HTTP2ProxySocketTransportChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Helper routine that helps complete an async operation

Arguments:
    
    CurrentStatus - the current status of the operation

Return Value:

    The status to return to the runtime.

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_COMPLETE_HELPER, HTTP2LOG_OT_PROXY_SOCKET_CHANNEL, CurrentStatus);

    ProxyAsyncCompleteHelper(TopChannel, CurrentStatus);

    return RPC_P_PACKET_CONSUMED;
}

/*********************************************************************
    HTTP2IISTransportChannel
 *********************************************************************/

const char ServerErrorString[] = "HTTP/1.0 503 RPC Error: %X\r\n\r\n";

DWORD 
ReplyToClientWithStatus (
    IN EXTENSION_CONTROL_BLOCK *pECB,
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Sends a reply to the client with the given error code as error.

Arguments:

    pECB - extension control block
    RpcStatus - error code to be returned to client

Return Value:

    Return value appropriate for return to IIS (i.e. HSE_STATUS_*)

--*/
{
    // size is the error string + 10 space for the error code
    char Buffer[sizeof(ServerErrorString) + 10];
    ULONG Size;
    ULONG Status;
    BOOL Result;
    DWORD  dwFlags = (HSE_IO_SYNC | HSE_IO_NODELAY);

    sprintf (Buffer,
        ServerErrorString,
        RpcStatus
        );

    Size = RpcpStringLengthA(Buffer);

    if (!pECB->WriteClient(pECB->ConnID, Buffer, &Size, dwFlags))
        {
        Status = GetLastError();
        #ifdef DBG_ERROR
        DbgPrint("ReplyToClientWithStatus(): failed: %d\n", Status);
        #endif
        return RPC_S_OUT_OF_MEMORY;
        }
    else
        return RPC_S_OK;
}


RPC_STATUS HTTP2IISTransportChannel::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    // if some data arrived with the ECB, pass them down for
    // potential defragmentation
    if (ECBDataConsumed == FALSE)
        {

        ECBDataConsumed = TRUE;

        if (ControlBlock->cbAvailable > 0)
            {
            RpcStatus = DepositReceivedData (ControlBlock->cbAvailable,
                        ControlBlock->lpbData
                        );

            if (RpcStatus != RPC_S_OK)
                return RpcStatus;
            }
        // fall through to the actual receive
        }

    // ask the fragment receiver to perform a receive
    return HTTP2FragmentReceiver::Receive (TrafficType);
}

RPC_STATUS HTTP2IISTransportChannel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // make sure nobody gets here. Everybody should be using the internal
    // version
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2IISTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    BOOL Result;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_IIS_CHANNEL, RpcStatus);

    ReplyToClientWithStatus(ControlBlock, RpcStatus);

    // must abort the IIS session
    Result = ControlBlock->ServerSupportFunction( ControlBlock->ConnID,
                                          HSE_REQ_CLOSE_CONNECTION,
                                          NULL, 
                                          NULL, 
                                          NULL);

    if (Result == FALSE)
        {
        ASSERT(GetLastError() == WSAECONNRESET);
        }
}

void HTTP2IISTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_IIS_CHANNEL, 0);

    FreeIISControlBlock();

    if (pReadBuffer)
        {
        RpcFreeBuffer(pReadBuffer);
        pReadBuffer = NULL;
        }

    HTTP2IISTransportChannel::~HTTP2IISTransportChannel();
}

void HTTP2IISTransportChannel::IOCompleted (
    IN ULONG Bytes,
    DWORD Error
    )
/*++

Routine Description:

    An IO completed. Figure out what IO and what to do with it.

Arguments:

Return Value:

--*/
{
    RPC_STATUS RpcStatus;
    BYTE *Ignored;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_IIS_IO_COMPLETED, HTTP2LOG_OT_IIS_CHANNEL, Error);

    if (Direction == iistcdReceive)
        {
        (void) ReceiveCompleteInternal(Error ? RPC_P_RECEIVE_FAILED : RPC_S_OK, 
            http2ttRaw, 
            TRUE,   // ReadCompleted
            &Ignored, 
            (UINT *)&Bytes
            );
        }
    else
        {
        if (Error == ERROR_SUCCESS)
            {
            ASSERT(Bytes == CurrentSendContext->maxWriteBuffer);
            }

        (void) SendComplete(Error ? RPC_P_SEND_FAILED : RPC_S_OK, CurrentSendContext);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_IIS_IO_COMPLETED, HTTP2LOG_OT_IIS_CHANNEL, 0);
}

void HTTP2IISTransportChannel::DirectReceive (
    void
    )
/*++

Routine Description:

    Direct receive callback from the thread pool

Arguments:

Return Value:

--*/
{
    ULONG Bytes;
    RPC_STATUS RpcStatus;
    BYTE *Ignored;

    Bytes = iLastRead;
    iLastRead = 0;

    RpcStatus = ReceiveCompleteInternal(RPC_S_OK,
        http2ttRaw,
        FALSE,      // ReadCompleted
        &Ignored,
        (UINT *)&Bytes
        );

    ASSERT(RpcStatus != RPC_S_INTERNAL_ERROR);
    ASSERT(RpcStatus != RPC_P_PARTIAL_RECEIVE);
}

RPC_STATUS HTTP2IISTransportChannel::ReceiveCompleteInternal (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BOOL ReadCompleted,
    IN OUT BYTE **Buffer,
    IN OUT UINT *BufferLength
    )
/*++

Routine Description:

    Receive complete notification for the IIS transport channel. Somewhat
    different signature than normal receive complete.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    ReadCompleted - non-zero if a read completed. FALSE if it hasn't.

    Buffer - the buffer. Must be NULL at this level on input. On
        output contains the buffer for the current receive. If NULL
        on output, we did not have a full packet. Undefined on failure.

    BufferLength - the actual number of bytes received. On output the
        number of bytes for the current packet. If 0 on output,
        we did not have a complete packet. Undefined on failure.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if (ReadCompleted)
        ReadsPending --;
    ASSERT(ReadsPending == 0);

    return HTTP2FragmentReceiver::ReceiveComplete (EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );
}

void HTTP2IISTransportChannel::FreeIISControlBlock (
    void
    )
/*++

Routine Description:

    Frees the IIS control block associated with this channel

Arguments:

Return Value:

--*/
{
    BOOL Result;

    if (IISCloseEnabled)
        {
        Result = ControlBlock->ServerSupportFunction( ControlBlock->ConnID,
                                              HSE_REQ_DONE_WITH_SESSION,
                                              NULL, 
                                              NULL, 
                                              NULL);

        ASSERT(Result);
        }

    ControlBlock = NULL;
}

RPC_STATUS HTTP2IISTransportChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    A helper function that completes an async io.

Arguments:
    
    CurrentStatus - the status with which the complete
        notification completed.

Return Value:

--*/
{
    return ProxyAsyncCompleteHelper(TopChannel, CurrentStatus);
}

RPC_STATUS HTTP2IISTransportChannel::PostReceive (
    void
    )
/*++

Routine Description:

    Posts a receive to IIS.

Arguments:
    
Return Value:

    RPC_S_OK or RPC_S_* error

Note: May be called from both submission and upcall context

--*/
{
    BOOL Result;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_IIS_CHANNEL, 0);

    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    ASSERT (Direction == iistcdReceive);

    if (pReadBuffer == NULL)
        {
        pReadBuffer = (BYTE *)RpcAllocateBuffer(iPostSize);
        if (pReadBuffer == NULL)
            {
            TopChannel->FinishSubmitAsync();
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_IIS_CHANNEL, RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        MaxReadBuffer = iPostSize;
        }
    else
        {
        ASSERT(iLastRead < MaxReadBuffer);
        }

    ReadsPending ++;
    ASSERT(ReadsPending == 1);

    BytesToTransfer = MaxReadBuffer - iLastRead;

    Result = ControlBlock->ServerSupportFunction(ControlBlock->ConnID,
                                    HSE_REQ_ASYNC_READ_CLIENT,
                                    pReadBuffer + iLastRead,
                                    &BytesToTransfer,
                                    &IISIoFlags
                                    );

    TopChannel->FinishSubmitAsync();

    if (Result == FALSE)
        {
        ReadsPending --;
        ASSERT(ReadsPending == 0);

        ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);

        RpcStatus = RPC_P_RECEIVE_FAILED;
        }
    else
        RpcStatus = RPC_S_OK;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_IIS_CHANNEL, RpcStatus);
    
    return RpcStatus;
}

ULONG HTTP2IISTransportChannel::GetPostRuntimeEvent (
    void
    )
/*++

Routine Description:

    Gets the message to be posted to the runtime.

Arguments:

Return Value:

    The message to post to the runtime

--*/
{
    return IN_PROXY_IIS_DIRECT_RECV;
}

/*********************************************************************
    HTTP2IISSenderTransportChannel
 *********************************************************************/

RPC_STATUS HTTP2IISSenderTransportChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL Result;
    ULONG LocalSendsPending;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_IIS_SENDER_CHANNEL, (ULONG_PTR)SendContext);

    Mutex.Request();
    LocalSendsPending = SendsPending.Increment();
    if ((LocalSendsPending > 1) || ReadsPending)
        {
        // queue and exit
        SendContext->SetListEntryUsed();
        RpcpInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
        Mutex.Clear();

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_IIS_SENDER_CHANNEL, 1);

        return RPC_S_OK;
        }
    Mutex.Clear();

    if (Direction == iistcdReceive)
        ReverseDirection();

    CurrentSendContext = SendContext;
    BytesToTransfer = SendContext->maxWriteBuffer;
    Result = ControlBlock->WriteClient(ControlBlock->ConnID,
                                    SendContext->pWriteBuffer,
                                    &BytesToTransfer,
                                    IISIoFlags
                                    );

    if (Result == FALSE)
        {
        ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);
        RpcStatus = RPC_P_SEND_FAILED;
        }
    else
        RpcStatus = RPC_S_OK;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_IIS_SENDER_CHANNEL, RpcStatus);

    return RpcStatus;
}

RPC_STATUS HTTP2IISSenderTransportChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ULONG LocalSendsPending;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_IIS_SENDER_CHANNEL, EventStatus);

    CurrentSendContext = NULL;

    // decrement this in advance so that if we post another send on send
    // complete, it doesn't get queued
    LocalSendsPending = SendsPending.Decrement();

    EventStatus = HTTP2TransportChannel::SendComplete(EventStatus, SendContext);

    if ((EventStatus == RPC_S_OK)
        || (EventStatus == RPC_P_PACKET_CONSUMED) )
        {
        EventStatus = SendQueuedContextIfNecessary (LocalSendsPending, EventStatus);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_IIS_SENDER_CHANNEL, EventStatus);

    return AsyncCompleteHelper(EventStatus);
}

void HTTP2IISSenderTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_IIS_SENDER_CHANNEL, RpcStatus);

    HTTP2IISTransportChannel::Abort(RpcStatus);

    Mutex.Request();
    if (SendsPending.GetInteger() > 1)
        {
        ASSERT(!RpcpIsListEmpty(&BufferQueueHead));
        QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
        do
            {
            QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

            SendsPending.Decrement();
            HTTP2TransportChannel::SendComplete(RpcStatus, QueuedSendContext);
            TopChannel->RemoveReference();

            QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
            }
        while (QueuedListEntry != &BufferQueueHead);
        }
    Mutex.Clear();
}

void HTTP2IISSenderTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_IIS_SENDER_CHANNEL, 0);

    FreeIISControlBlock();

    HTTP2IISSenderTransportChannel::~HTTP2IISSenderTransportChannel();
}

RPC_STATUS HTTP2IISSenderTransportChannel::ReceiveCompleteInternal (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BOOL ReadCompleted,
    IN OUT BYTE **Buffer,
    IN OUT UINT *BufferLength
    )
/*++

Routine Description:

    Receive complete notification for the IIS sender transport channel. Somewhat
    different signature than normal receive complete.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    ReadCompleted - non-zero if a read completed. FALSE if it hasn't.

    Buffer - the buffer. Must be NULL at this level on input. On
        output contains the buffer for the current receive. If NULL
        on output, we did not have a full packet. Undefined on failure.

    BufferLength - the actual number of bytes received. On output the
        number of bytes for the current packet. If 0 on output,
        we did not have a complete packet. Undefined on failure.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    ULONG LocalSendsPending;

    Mutex.Request();
    // decrease the reads pending and check the sends within the mutex -
    // this ensures atomicity with respect to the send path's (which is
    // the only path we race with) increase of the sends and check of the
    // reads
    if (ReadCompleted)
        ReadsPending --;
    ASSERT(ReadsPending == 0);

    LocalSendsPending = SendsPending.GetInteger();
    Mutex.Clear();

    RpcStatus = HTTP2FragmentReceiver::ReceiveComplete (EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );

    if ((RpcStatus == RPC_P_PACKET_CONSUMED)
        || 
        (
         (RpcStatus == RPC_S_OK)
         &&
         (*Buffer != NULL)
        ) 
       )
        {
        RpcStatus = SendQueuedContextIfNecessary (LocalSendsPending, RpcStatus);
        }

    return RpcStatus;
}

RPC_STATUS HTTP2IISSenderTransportChannel::SendQueuedContextIfNecessary (
    IN ULONG LocalSendsPending,
    IN RPC_STATUS EventStatus
    )
/*++

Routine Description:

    Checks if any send contexts are queued for sending, and if yes, sends
    the first one (which on completion will send the next, etc).

Arguments:

    LocalSendsPending - the number of sends pending at the time the current
    operation completed save for the count of the current operation (if it
    was send)

    EventStatus - the RPC Status so far. Must be a success error status
    (RPC_S_OK or RPC_P_PACKET_CONSUMED)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    BOOL Result;

    if (LocalSendsPending != 0)
        {
        Mutex.Request();

        if (Direction == iistcdReceive)
            ReverseDirection();

        QueuedListEntry = RpcpRemoveHeadList(&BufferQueueHead);
        // it is possible that if an abort executed between getting LocalSendsPending
        // in caller and grabbing the mutex here that the list is empty.
        ASSERT(QueuedListEntry);
        if (QueuedListEntry == &BufferQueueHead)
            {
            Mutex.Clear();
            return EventStatus;
            }
        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);
        Mutex.Clear();
        QueuedSendContext->SetListEntryUnused();

        // need to synchronize with aborts (rule 9)
        EventStatus = TopChannel->BeginSimpleSubmitAsync();
        if (EventStatus == RPC_S_OK)
            {
            CurrentSendContext = QueuedSendContext;
            BytesToTransfer = QueuedSendContext->maxWriteBuffer;
            Result = ControlBlock->WriteClient(ControlBlock->ConnID,
                                            QueuedSendContext->pWriteBuffer,
                                            &BytesToTransfer,
                                            IISIoFlags
                                            );

            if (Result == FALSE)
                {
                EventStatus = RPC_P_SEND_FAILED;
                ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);
                // the send failed. We don't get a notification for it
                // so we must issue one. Reference for the send we
                // failed to post is already added
                EventStatus = HTTP2TransportChannel::SendComplete(EventStatus, QueuedSendContext);
                TopChannel->RemoveReference();
                }
            else
                {
                // must already be ok
                ASSERT(EventStatus == RPC_S_OK);
                }

            TopChannel->FinishSubmitAsync();
            }
        }

    return EventStatus;
}

/*********************************************************************
    HTTP2GenericReceiver
 *********************************************************************/

void HTTP2GenericReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2GenericReceiver::~HTTP2GenericReceiver();
}

void HTTP2GenericReceiver::TransferStateToNewReceiver (
    OUT HTTP2GenericReceiver *NewReceiver
    )
/*++

Routine Description:

    Transfers all the settings from this receiver (i.e. the state
        of the receive) to a new one.

Arguments:

    NewReceiver - the new receiver to transfer the settings to

Return Value:

Notes:

    This must be called in an upcall context (i.e. no real receives
    pending) and the channel on which this is called must be non-default
    by now.

--*/
{
    NewReceiver->ReceiveWindow = ReceiveWindow;
}

RPC_STATUS HTTP2GenericReceiver::BytesReceivedNotification (
    IN ULONG Bytes
    )
/*++

Routine Description:

    Notifies channel that bytes have been received.

Arguments:

    Bytes - the number of data bytes received.

Return Value:

    RPC_S_OK if the received bytes did not violate the
        flow control protocol. RPC_S_PROTOCOL error otherwise.

--*/
{
    Mutex.VerifyOwned();

    BytesReceived += Bytes;
    BytesInWindow += Bytes;
    ASSERT(BytesInWindow <= ReceiveWindow);
    FreeWindowAdvertised -= Bytes;

    if (FreeWindowAdvertised < 0)
        {
        ASSERT(0);
        // sender sent data even though
        // we told it we don't have enough window
        // to receive it - protocol violation
        return RPC_S_PROTOCOL_ERROR;
        }

    return RPC_S_OK;
}

void HTTP2GenericReceiver::BytesConsumedNotification (
    IN ULONG Bytes,
    IN BOOL OwnsMutex,
    OUT BOOL *IssueAck,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck
    )
/*++

Routine Description:

    Notifies channel that bytes have been consumed and can
    be freed from the receive window of the channel.

Arguments:

    Bytes - the number of data bytes consumed.

    OwnsMutex - non-zero if the mutex for the channel is
        already owned.

    IssueAck - must be FALSE on input. If the caller needs
        to issue an Ack, it will be set to non-zero on
        output.

    BytesReceivedForAck - on output, if IssueAck is non-zero,
        it will contain the bytes received to put in the
        ack packet. If IssueAck is FALSE, it is undefined.

    WindowForAck - on output, if IssueAck is non-zero,
        it will contain the window available to put in the
        ack packet. If IssueAck is FALSE, it is undefined.

Return Value:

--*/
{
    ULONG ReceiveWindowThreshold;

    if (OwnsMutex)
        {
        Mutex.VerifyOwned();
        }
    else
        {
        Mutex.Request();
        }

    ASSERT(*IssueAck == FALSE);

    BytesInWindow -= Bytes;
    // make sure we don't wrap
    ASSERT(BytesInWindow <= ReceiveWindow);
    ReceiveWindowThreshold = ReceiveWindow >> 1;
    if (FreeWindowAdvertised < (LONG)ReceiveWindowThreshold)
        {
        // we fell below the threshold. ACK our current window
        *IssueAck = TRUE;
        FreeWindowAdvertised = ReceiveWindow - BytesInWindow;
        ASSERT(FreeWindowAdvertised >= 0);
        *BytesReceivedForAck = BytesReceived;
        *WindowForAck = FreeWindowAdvertised;
        }

    if (OwnsMutex == FALSE)
        {
        Mutex.Clear();
        }
}

RPC_STATUS HTTP2GenericReceiver::SendFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Sends a flow control Ack packet.

Arguments:

    BytesReceivedForAck - the number of bytes received while
        we were issuing the Ack

    WindowForAck - the window available when BytesReceivedForAck
        bytes have been received

Return Value:

    RPC_S_OK or RPC_S_* for error

Notes:

    This must be called in a neutral context.

--*/
{
    return TopChannel->ForwardFlowControlAck (BytesReceivedForAck,
        WindowForAck
        );
}

/*********************************************************************
    HTTP2EndpointReceiver
 *********************************************************************/

RPC_STATUS HTTP2EndpointReceiver::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL PostReceive;
    RPC_STATUS RpcStatus;
    BOOL DequeuePacket;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, TrafficType);

    DequeuePacket = FALSE;
    PostReceive = FALSE;
    Mutex.Request();

    switch (TrafficType)
        {
        case http2ttNone:
            ASSERT(0);
            RpcStatus = RPC_S_INTERNAL_ERROR;
            Mutex.Clear();
            return RpcStatus;

        case http2ttRTS:
            // we cannot issue two RTS receives.
            ASSERT((ReceivesPosted & http2ttRTS) == 0);
            // if we have RTS receives queued, dequeue one and
            // complete it
            if (ReceivesQueued == http2ttRTS)
                {
                ASSERT(DirectCompletePosted == FALSE);
                DirectCompletePosted = TRUE;
                DequeuePacket = TRUE;
                }
            else
                {
                // we have no packets queued, or only data packets
                // queued. If we have no data request pending, create
                // a request pending. Otherwise just add ourselves to
                // the map
                if (ReceivesPosted)
                    {
                    ASSERT(ReceivesPosted == http2ttData);
                    ReceivesPosted = http2ttAny;
                    }
                else
                    {
                    PostReceive = TRUE;
                    ReceivesPosted = http2ttRTS;
                    }
                }
            break;

        case http2ttData:
            // we cannot issue two Data receives.
            ASSERT((ReceivesPosted & http2ttData) == 0);
            // if we have Data receives queued, dequeue one and
            // complete it
            if (ReceivesQueued == http2ttData)
                {
                ASSERT(DirectCompletePosted == FALSE);
                DirectCompletePosted = TRUE;
                DequeuePacket = TRUE;
                }
            else
                {
                // we have no packets queued, or only RTS packets
                // queued. If we have no RTS request pending, create
                // a request pending. Otherwise just add ourselves to
                // the map
                if (ReceivesPosted)
                    {
                    ASSERT(ReceivesPosted == http2ttRTS);
                    ReceivesPosted = http2ttAny;
                    }
                else
                    {
                    PostReceive = TRUE;
                    ReceivesPosted = http2ttData;
                    }
                }
            break;

        default:
            ASSERT(0);
            RpcStatus = RPC_S_INTERNAL_ERROR;
            Mutex.Clear();
            return RpcStatus;
        }

    // only one of PostReceive and DequeuePacket can be set here.
    // Neither is ok too.
    ASSERT((PostReceive ^ DequeuePacket) 
        || ((PostReceive == FALSE)
             &&
            (DequeuePacket == FALSE)
           )
          );

    Mutex.Clear();

    if (DequeuePacket)
        {
        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, 0);
        (void) COMMON_PostRuntimeEvent(HTTP2_DIRECT_RECEIVE,
            this
            );
        return RPC_S_OK;
        }

    if (PostReceive == FALSE)
        {
        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, 1);
        return RPC_S_OK;
        }

    RpcStatus = HTTP2TransportChannel::Receive(http2ttRaw);
    if (RpcStatus != RPC_S_OK)
        {
        // we have indicated our receive as pending, yet we
        // couldn't submit it. Not good. Must attempt to
        // remove it from the pending variable unless somebody
        // else already did (which is possible if we wanted
        // to submit data and there was already pending RTS).
        Mutex.Request();

        switch (ReceivesPosted)
            {
            case http2ttNone:
                // should not be possible
                ASSERT(FALSE);
                RpcStatus = RPC_S_INTERNAL_ERROR;
                Mutex.Clear();
                return RpcStatus;

            case http2ttData:
                if (TrafficType == http2ttData)
                    ReceivesPosted = http2ttNone;
                else
                    {
                    // not possible that we submitted RTS
                    // and have data pending but not RTS
                    ASSERT(0);
                    Mutex.Clear();
                    return RPC_S_INTERNAL_ERROR;
                    }
                break;

            case http2ttRTS:
                if (TrafficType == http2ttRTS)
                    ReceivesPosted = http2ttNone;
                else
                    {
                    // possible that we attempted to submit data,
                    // but while we were trying, an async RTS submission
                    // failed, and we indicated it asynchronously. In this
                    // case we must not indicate the failure synchronously
                    RpcStatus = RPC_S_OK;
                    }
                break;

            case http2ttAny:
                if (TrafficType == http2ttRTS)
                    ReceivesPosted = http2ttData;
                else
                    ReceivesPosted = http2ttRTS;
                break;

            default:
                ASSERT(0);
                Mutex.Clear();
                return RPC_S_INTERNAL_ERROR;
            }

        Mutex.Clear();
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, 3);
    return RpcStatus;
}

RPC_STATUS HTTP2EndpointReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2TrafficType NewReceivesPosted;
    HTTP2TrafficType ThisCompleteTrafficType;
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    BOOL BufferQueued;
    RPC_STATUS RTSStatus;
    RPC_STATUS DataStatus;
    BOOL ReceiveCompletesFailed;
    BYTE *CurrentPosition;
    USHORT PacketFlags;
    BOOL IssueAck;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, EventStatus);

    BufferQueued = FALSE;
    Mutex.Request();

    if (EventStatus == RPC_S_OK)
        {
        if (IsRTSPacket(Buffer))
            ThisCompleteTrafficType = http2ttRTS;
        else
            {
            ThisCompleteTrafficType = http2ttData;
            EventStatus = BytesReceivedNotification(BufferLength
                );

            if (EventStatus != RPC_S_OK)
                {
                // fall through with an error. Don't free the buffer
                // (Rule 34).
                }
            }
        }

    if (EventStatus != RPC_S_OK)
        {
        if (ReceivesPosted == http2ttAny)
            ThisCompleteTrafficType = http2ttData;
        else
            ThisCompleteTrafficType = ReceivesPosted;
        }

    ReceiveCompletesFailed = FALSE;

    switch (ThisCompleteTrafficType)
        {
        case http2ttData:
            if ((ReceivesPosted & http2ttData) == FALSE)
                {
                // we haven't asked for data, but we get some. We'll
                // have to queue it
                ASSERT(ReceivesQueued != http2ttRTS);
                ReceivesQueued = http2ttData;
                if (BufferQueue.PutOnQueue(Buffer, BufferLength))
                    {
                    ReceiveCompletesFailed = TRUE;
                    RpcFreeBuffer(Buffer);
                    }
                BufferQueued = TRUE;
                }
            else
                {
                ReceivesPosted = (HTTP2TrafficType)(ReceivesPosted ^ http2ttData);
                NewReceivesPosted = ReceivesPosted;
                }
            break;

        case http2ttRTS:
            if ((ReceivesPosted & http2ttRTS) == FALSE)
                {
                // we haven't asked for RTS, but we get some. We'll
                // have to queue it
                ASSERT(ReceivesQueued != http2ttData);
                ReceivesQueued = http2ttRTS;
                if (BufferQueue.PutOnQueue(Buffer, BufferLength))
                    {
                    ReceiveCompletesFailed = TRUE;
                    RpcFreeBuffer(Buffer);
                    }
                BufferQueued = TRUE;
                }
            else
                {
                ReceivesPosted = (HTTP2TrafficType)(ReceivesPosted ^ http2ttRTS);
                NewReceivesPosted = ReceivesPosted;
                }
            break;

        default:
            ASSERT(0);
            break;
        }

    IssueAck = FALSE;

    if ((BufferQueued == FALSE) 
        && (ReceiveCompletesFailed == FALSE)
        && (ThisCompleteTrafficType == http2ttData)
        && (EventStatus == RPC_S_OK))
        {
        // we know the data will be consumed immediately
        BytesConsumedNotification (BufferLength,
            TRUE,       // OwnsMutex
            &IssueAck,
            &BytesReceivedForAck,
            &WindowForAck
            );
        }

    Mutex.Clear();

    if (IssueAck)
        {
        RpcStatus = SendFlowControlAck (BytesReceivedForAck,
            WindowForAck
            );

        if (RpcStatus != RPC_S_OK)
            {
            // turn this into a failure
            EventStatus = RpcStatus;
            // fall through to issuing the notification
            if (EventStatus == RPC_P_SEND_FAILED)
                EventStatus = RPC_P_RECEIVE_FAILED;
            }
        }

    if (ReceiveCompletesFailed)
        {
        // we got an unwanted receive, and couldn't queue it.
        // Abort the connection
        TopChannel->AbortConnection(RPC_S_OUT_OF_MEMORY);
        return RPC_P_PACKET_CONSUMED;
        }

    if (BufferQueued)
        {
        ASSERT(ReceivesPosted != http2ttNone);

        // the packet was not of the type we wanted.
        // Submit another receive hoping to get what we want
        RpcStatus = TopChannel->BeginSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            // we know we have one type of receive in the map. Nobody
            // can post another. Just post ours
            RpcStatus = HTTP2TransportChannel::Receive(http2ttRaw);
            TopChannel->FinishSubmitAsync();
            if (RpcStatus != RPC_S_OK)
                {
                TopChannel->RemoveReference();
                }
            }

        if (RpcStatus != RPC_S_OK)
            {
            // we failed to submit the receive. We have to issue notification for it
            RpcStatus = HTTP2TransportChannel::ReceiveComplete(RpcStatus, 
                ReceivesPosted,
                NULL,   // Buffer
                0       // BufferLength
                );

            TopChannel->AbortConnection(RpcStatus);
            }

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, RPC_P_PACKET_CONSUMED);

        // if we have queued, this means the runtime did not
        // ask for this packet. Don't let it see it.
        return RPC_P_PACKET_CONSUMED;
        }

    // The buffer was not queued - pass it up
    RpcStatus = HTTP2TransportChannel::ReceiveComplete(EventStatus,
        ThisCompleteTrafficType,
        Buffer,
        BufferLength
        );

    if (NewReceivesPosted != http2ttNone)
        {
        // if we left something in the map, nobody could have
        // posted a raw receive - they would have just upgraded the
        // map. It could still have been aborted though
        ASSERT((NewReceivesPosted == http2ttRTS)
            ||
            (NewReceivesPosted == http2ttData));

        // see what was left as pending recieve, and
        // actually submit that. We do that only if we didn't
        // fail before. If we did, don't bother
        if (EventStatus == RPC_S_OK)
            {
            RpcStatus2 = TopChannel->BeginSimpleSubmitAsync();
            if (RpcStatus2 == RPC_S_OK)
                {
                RpcStatus2 = HTTP2TransportChannel::Receive(http2ttRaw);

                TopChannel->FinishSubmitAsync();
                }
            }
        else
            {
            // transfer the error code
            RpcStatus2 = EventStatus;
            }

        if (RpcStatus2 != RPC_S_OK)
            {
            // we failed to submit the receive. We have to issue notification for it
            RpcStatus2 = HTTP2TransportChannel::ReceiveComplete(RpcStatus2, 
                NewReceivesPosted,
                NULL,   // Buffer
                0       // BufferLength
                );

            if (NewReceivesPosted == http2ttRTS)
                {
                ASSERT(RpcStatus2 != RPC_S_OK);
                }

            TopChannel->RemoveReference();  // remove reference for the receive complete
            }
        }

    // here, ThisCompleteTrafficType is the type of completed receive and
    // RpcStatus is the status for it. NewReceivesPosted is the next submit we received
    // (http2ttNone if none) and RpcStatus2 is the status for it.

    // make sure nobody has left unconsumed success RTS packets
    if (ThisCompleteTrafficType == http2ttRTS)
        {
        ASSERT(RpcStatus != RPC_S_OK);
        }

    // if there is only one receive type, no merging is necessary - just return
    if (NewReceivesPosted == http2ttNone)
        {
        // consume RTS receives
        if (ThisCompleteTrafficType == http2ttRTS)
            RpcStatus = RPC_P_PACKET_CONSUMED;

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, RpcStatus);

        return RpcStatus;
        }

    // Process them and determine the appropriate return code. If we
    // have two receives, we merge them as per the table below
    // N    First Receive        Second Receive      Return value    Note
    // --   --------------       -----------------   -------------   ---------
    // 1    DS                   RS                  S
    // 2    DS                   RC                  S
    // 3    DS                   RF                  S               Abort
    // 4    DF                   RS                  F
    // 5    DF                   RC                  F
    // 6    DF                   RF                  F               Choose first receive error
    // 7    RS                   DS                  Invalid combination (first RTS should have been consumed)
    // 8    RC                   DS                  C
    // 9    RF                   DS                  S              Abort
    // 10   RS                   DF                  Invalid combination (first RTS should have been consumed)
    // 11   RC                   DF                  C              Abort
    // 12   RF                   DF                  F              Choose first receive error

    if (ThisCompleteTrafficType == http2ttData)
        {
        ASSERT(NewReceivesPosted == http2ttRTS);
        DataStatus = RpcStatus;
        RTSStatus = RpcStatus2;
        }
    else
        {
        ASSERT(NewReceivesPosted == http2ttData);
        DataStatus = RpcStatus2;
        RTSStatus = RpcStatus;
        }

    if (DataStatus == RPC_S_OK)
        {
        if (RTSStatus == RPC_S_OK)
            {
            // case 1 - just return ok
            RpcStatus = RTSStatus;
            }
        else if (RTSStatus == RPC_P_PACKET_CONSUMED)
            {
            // case 2
            if (ThisCompleteTrafficType == http2ttData)
                {
                RpcStatus = DataStatus;
                }
            else
                {
                // case 8
                RpcStatus = RTSStatus;
                }
            }
        else
            {
            // cases 3 & 9
            TopChannel->AbortConnection(RTSStatus);
            }
        }
    else
        {
        if (RTSStatus == RPC_S_OK)
            {
            // case 4
            RpcStatus = DataStatus;
            }
        else if (RTSStatus == RPC_P_PACKET_CONSUMED)
            {
            // case 5 
            if (ThisCompleteTrafficType == http2ttData)
                {
                RpcStatus = DataStatus;
                }
            else
                {
                // case 11
                TopChannel->AbortConnection(DataStatus);
                RpcStatus = RTSStatus;
                }
            }
        else
            {
            // cases 6 & 12
            // nothing to do. First error is already in RpcStatus
            }
        }

    if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
        || (RpcStatus == RPC_P_CONNECTION_CLOSED)
        || (RpcStatus == RPC_P_SEND_FAILED)
        || (RpcStatus == RPC_S_OUT_OF_MEMORY))
        RpcStatus = RPC_P_RECEIVE_FAILED;

    VALIDATE (RpcStatus)
        {
        RPC_S_OK,
        RPC_P_PACKET_CONSUMED,
        RPC_P_RECEIVE_FAILED
        } END_VALIDATE;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, RpcStatus);

    return RpcStatus;
}

void HTTP2EndpointReceiver::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    BYTE *CurrentBuffer;
    UINT Ignored;
    ULONG SizeOfQueueToLeave;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_ENDPOINT_RECEIVER, RpcStatus);

    HTTP2TransportChannel::Abort(RpcStatus);

    Mutex.Request();

    // if there is a direct complete posted, we have to
    // leave one element in the queue, because the
    // direct complete routine will need it
    if (DirectCompletePosted)
        SizeOfQueueToLeave = 1;
    else
        SizeOfQueueToLeave = 0;

    while (BufferQueue.Size() > SizeOfQueueToLeave)
        {
        CurrentBuffer = (BYTE *) BufferQueue.TakeOffEndOfQueue(&Ignored);
        // the elements in the queue are unwanted anyway -
        // they don't have refcounts or anything else - just
        // free them
        RpcFreeBuffer(CurrentBuffer);
        }
    // If we have taken elements off the queue,
    // mark that there are no longer any receives queued on this channel.
    if (SizeOfQueueToLeave == 0)
        {
        ReceivesQueued = http2ttNone;
        }

    Mutex.Clear();
}

void HTTP2EndpointReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2EndpointReceiver::~HTTP2EndpointReceiver();
}

RPC_STATUS HTTP2EndpointReceiver::DirectReceiveComplete (
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection,
    OUT BOOL *IsServer
    )
/*++

Routine Description:

    Direct receive completion (i.e. we posted a receive
    to ourselves). We can be called in only one case -
    a receive was submitted and there were already
        queued receives.

Arguments:

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

    IsServer - non-zero if the server

Return Value:

    RPC_S_OK, RPC_P_PACKET_CONSUMED or RPC_S_* errors.

Notes:

    The directly posted receive carries a reference count

--*/
{
    BYTE *Buffer;
    ULONG BufferLength;
    RPC_STATUS RpcStatus;
    HTTP2TrafficType QueuedPacketsType;
    BOOL IssueAck;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    BOOL PacketNeedsFlowControl;

    *IsServer = this->IsServer;
    *RuntimeConnection = TopChannel->GetRuntimeConnection();

    // dequeue a packet
    // we cannot have a queue and a posted receive at the same time
    ASSERT((ReceivesPosted & ReceivesQueued) == FALSE);

    Mutex.Request();

    ASSERT(DirectCompletePosted);
    ASSERT(DirectReceiveInProgress == FALSE);
    // they must be set in this order, because if a thread in 
    // TransferStateToNewReceiver synchronizes with us, it will check
    // them in reverse order.
    InterlockedIncrement((long *)&DirectReceiveInProgress);
    DirectCompletePosted = FALSE;

    QueuedPacketsType = ReceivesQueued;

    Buffer = (BYTE *)BufferQueue.TakeOffQueue((UINT *)&BufferLength);
    // even if aborted, at least one buffer must have been left for us
    // because we had the DirectCompletePosted flag set
    ASSERT (Buffer);

    if (BufferQueue.IsQueueEmpty())
        ReceivesQueued = http2ttNone;

    PacketNeedsFlowControl = (((ULONG_PTR)Buffer & 1) == 0);
    Buffer = (BYTE *)(((ULONG_PTR)Buffer) & (~(ULONG_PTR)1));

    RpcStatus = RPC_S_OK;
    *ReceivedBuffer = Buffer;
    *ReceivedBufferLength = BufferLength;

    // we know the data will be consumed.
    IssueAck = FALSE;
    if ((QueuedPacketsType == http2ttData) && PacketNeedsFlowControl)
        {
        BytesConsumedNotification (BufferLength,
            TRUE,       // OwnsMutex
            &IssueAck,
            &BytesReceivedForAck,
            &WindowForAck
            );
        }

    Mutex.Clear();

    if (IssueAck)
        {
        RpcStatus = SendFlowControlAck (BytesReceivedForAck,
            WindowForAck
            );

        if (RpcStatus != RPC_S_OK)
            {
            // turn this into a failure. Note that we must supply a buffer
            // on failure, hence we don't free it (Rule 34)
            // fall through to issuing the notification
            }
        }

    // decrement if before receive complete. In receive complete
    // we may post another receive and cause a race
    InterlockedDecrement((long *)&DirectReceiveInProgress);

    // one of three things must happen here if this is a client. Either this 
    // is RTS packet, or somebody sync waits for this packet, or the connection
    // is not exclusive
    if (!this->IsServer)
        {
        // actually do the checks
        if ((QueuedPacketsType != http2ttRTS)
            && (((HTTP2ClientChannel *)UpperLayer)->IsSyncRecvPending() == FALSE)
            && (I_RpcTransIsClientConnectionExclusive(*RuntimeConnection))
            )
            {
            ASSERT(0);
            // make it hold on free builds
            *((ULONG *)0) = RpcStatus;
            }
        }

    RpcStatus = HTTP2TransportChannel::ReceiveComplete(RpcStatus,
        QueuedPacketsType,
        Buffer,
        BufferLength
        );

    if (QueuedPacketsType == http2ttRTS)
        {
        ASSERT(RpcStatus != RPC_S_OK);
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }
    else
        {
        if (RpcStatus == RPC_P_SEND_FAILED)
            RpcStatus = RPC_P_RECEIVE_FAILED;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);

    VALIDATE(RpcStatus)
        {
        RPC_P_CONNECTION_CLOSED,
        RPC_P_RECEIVE_FAILED,
        RPC_P_CONNECTION_SHUTDOWN,
        RPC_P_PACKET_CONSUMED,
        RPC_S_OK
        } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS HTTP2EndpointReceiver::TransferStateToNewReceiver (
    OUT HTTP2EndpointReceiver *NewReceiver
    )
/*++

Routine Description:

    Transfers all the settings from this receiver (i.e. the state
        of the receive) to a new one.

Arguments:

    NewReceiver - the new receiver to transfer the settings to

Return Value:

    RPC_S_OK or RPC_S_* errors.

Notes:

    This must be called in an upcall context (i.e. no real receives
    pending) and the channel on which this is called must be non-default
    by now.

--*/
{
    void *Buffer;
    UINT BufferLength;
    void *QueueElement;
    int Result;
    BOOL QueueTransferred;

    // this channel is not a default channel by now. We know that
    // there may be receives in progress, but no new receives will be
    // submitted.
    while (TRUE)
        {
        Mutex.Request();
        if (DirectCompletePosted || DirectReceiveInProgress)
            {
            Mutex.Clear();
            Sleep(5);
            }
        else
            break;
        }

    NewReceiver->Mutex.Request();

    // transfer the settings for the base class
    HTTP2GenericReceiver::TransferStateToNewReceiver(NewReceiver);

    if (NewReceiver->BufferQueue.IsQueueEmpty() == FALSE)
        {
        // the only way we can end up here is if the channel replacement
        // took so long that the peer started pinging us. This is a protocol
        // error.
        NewReceiver->Mutex.Clear();
        Mutex.Clear();
        return RPC_S_PROTOCOL_ERROR;
        }

    QueueTransferred = FALSE;
    while (TRUE)
        {
        QueueElement = BufferQueue.TakeOffEndOfQueue(&BufferLength);
        if (QueueElement == 0)
            {
            QueueTransferred = TRUE;
            break;
            }

        if (NewReceiver->BufferQueue.PutOnFrontOfQueue((void *)((ULONG_PTR)QueueElement | 1), BufferLength) != 0)
            {
            // guaranteed to succeed since we never decrease buffers
            BufferQueue.PutOnFrontOfQueue(QueueElement, BufferLength);
            break;
            }
        }

    if (QueueTransferred == FALSE)
        {
        // failure - out of memory. Since the buffers are unwanted
        // we can just return failure. Both channels will be
        // aborted
        NewReceiver->Mutex.Clear();
        Mutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    NewReceiver->ReceivesQueued = ReceivesQueued;

    // Mark that there are no longer any receives queued on this channel.
    ReceivesQueued = http2ttNone;

    // we never transfer data receives. They will be transferred by our caller
    // We also preserve existing receives on the new receiver. There is a race where
    // data receives may have ended up on the new channel. That's ok as long as they
    // are off the old.
    ASSERT(((NewReceiver->ReceivesPosted & http2ttData) == 0)
        || ((ReceivesPosted & http2ttData) == 0));
    NewReceiver->ReceivesPosted 
        = (HTTP2TrafficType)(NewReceiver->ReceivesPosted | (ReceivesPosted & (~http2ttData)));

    // direct complete posted cannot be true here
    ASSERT(DirectCompletePosted == FALSE);

    NewReceiver->Mutex.Clear();

    Mutex.Clear();

    return RPC_S_OK;
}

/*********************************************************************
    HTTP2ProxyReceiver
 *********************************************************************/

RPC_STATUS HTTP2ProxyReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if ((EventStatus == RPC_S_OK) && (IsRTSPacket(Buffer) == FALSE))
        {
        Mutex.Request();
        EventStatus = BytesReceivedNotification(BufferLength
            );
        Mutex.Clear();

        if (EventStatus != RPC_S_OK)
            {
            // consume the packet and fall through with an error
            RpcFreeBuffer(Buffer);
            }
        }

    return HTTP2TransportChannel::ReceiveComplete(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );
}

void HTTP2ProxyReceiver::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel.

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    BYTE *CurrentBuffer;
    UINT Ignored;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_PROXY_RECEIVER, RpcStatus);

    HTTP2TransportChannel::Abort(RpcStatus);

    Mutex.Request();

    while (BufferQueue.Size() > 0)
        {
        CurrentBuffer = (BYTE *) BufferQueue.TakeOffQueue(&Ignored);
        // the elements in the queue are unwanted anyway -
        // they don't have refcounts or anything else - just
        // free them
        RpcFreeBuffer(CurrentBuffer);
        }
    Mutex.Clear();
}

void HTTP2ProxyReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2ProxyReceiver::~HTTP2ProxyReceiver();
}

/*********************************************************************
    HTTP2PlugChannel
 *********************************************************************/

C_ASSERT(http2plRTSPlugged == http2ttRTS);
C_ASSERT(http2plDataPlugged == http2ttData);

RPC_STATUS HTTP2PlugChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2TrafficType SendType;
    RPC_STATUS RpcStatus;

#if DBG
    TrafficSentOnChannel = TRUE;
#endif // DBG

    SendType = SendContext->TrafficType;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_PLUG_CHANNEL, PtrToUlong(SendContext));

    ASSERT((SendType == http2ttData)
        || (SendType == http2ttRTS)
        || (SendType == http2ttRaw) );

    // if the plug level says this packet should not go through, queue it
    // This means the traffic is no raw, and the plug level is less than
    // the send type. Since the constants are ordered this comparison is
    // sufficient
    if ((SendType != http2ttRaw) && (PlugLevel <= SendType))
        {
        SendContext->SetListEntryUsed();
        Mutex.Request();
        // queue and exit
        if (SendContext->Flags & SendContextFlagPutInFront)
            {
            RpcpfInsertHeadList(&BufferQueueHead, &SendContext->ListEntry);
            }
        else
            {
            RpcpfInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
            }
        Mutex.Clear();

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_PLUG_CHANNEL, 0);
        return RPC_S_OK;
        }
    else
        {
        // can't put in front on unplugged channel
        ASSERT((SendContext->Flags & SendContextFlagPutInFront) == 0);
        RpcStatus = HTTP2TransportChannel::Send(SendContext);

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_PLUG_CHANNEL, RpcStatus);
        return RpcStatus;
        }
}

void HTTP2PlugChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

Note: All sends carry a refcount. We must fully complete the sends

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_PLUG_CHANNEL, RpcStatus);

    HTTP2TransportChannel::Abort(RpcStatus);

    SendFailedStatus = RpcStatus;

    // Abort is made from submission context. We
    // know it is synchronized with other submissions
    // and we cannot issue upcalls for it. We will just post
    // as many direct send completions as there are buffers in 
    // the queue. When the post comes around, it will dequeue
    // and free one buffer for every post.
    // We know that after abort there will be no more submissions,
    // so not dequeuing them is fine

    if (!RpcpIsListEmpty(&BufferQueueHead))
        {
        (void) COMMON_PostRuntimeEvent(PLUG_CHANNEL_DIRECT_SEND,
            this
            );
        }
}

void HTTP2PlugChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2PlugChannel::~HTTP2PlugChannel();
}

void HTTP2PlugChannel::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    ASSERT(SendFailedStatus);
    ASSERT(RpcpIsListEmpty(&BufferQueueHead));
    PlugLevel = http2plDataPlugged;
    LowerLayer->Reset();
}

RPC_STATUS HTTP2PlugChannel::DirectSendComplete (
    void
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us)

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    RPC_STATUS RpcStatus;
    BOOL IsListEmpty;

    ASSERT(SendFailedStatus != RPC_S_INTERNAL_ERROR);

    // we wouldn't have a post if there wasn't something
    // in the list.
    ASSERT(!RpcpIsListEmpty(&BufferQueueHead));

    do
        {
        QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);

        // capture the state of the list before we do AsyncCompleteHelper.
        // after that, the this object may be gone.
        IsListEmpty = RpcpIsListEmpty(&BufferQueueHead);

        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

        RpcStatus = HTTP2TransportChannel::SendComplete(SendFailedStatus, QueuedSendContext);

        // we don't care about the return code.
        (void) AsyncCompleteHelper(RpcStatus);

        // if the list is empty by now, the this object is gone. Don't touch anything
        }
    while (!IsListEmpty);

    return RPC_S_OK;
}

RPC_STATUS HTTP2PlugChannel::Unplug (
    void
    )
/*++

Routine Description:

    Unplugs the channel. This means that all bottled up traffic 
    starts flowing forward.

Arguments:
    
Return Value:

    RPC_S_OK or RPC_S_* errors

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    RPC_STATUS RpcStatus;

    // first, send pending traffic. Then open the channel. Otherwise
    // traffic may get out of order

    while (TRUE)
        {
        Mutex.Request();
        QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
        // if we had non-zero elements ...
        if (QueuedListEntry != &BufferQueueHead)
            {
            Mutex.Clear();
            }
        else
            {
            // we have zero elements - just unplug the channel
            PlugLevel = http2plUnplugged;
            Mutex.Clear();
            RpcStatus = RPC_S_OK;
            break;
            }

        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

        QueuedSendContext->SetListEntryUnused();

        // get into submission context - rule 9.
        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = HTTP2TransportChannel::Send(QueuedSendContext);
            TopChannel->FinishSubmitAsync();
            }

        if (RpcStatus != RPC_S_OK)
            {
            QueuedSendContext->SetListEntryUsed();
            Mutex.Request();
            RpcpfInsertHeadList(&BufferQueueHead, QueuedListEntry);
            Mutex.Clear();
            break;
            }
        }

    return RpcStatus;    
}

void HTTP2PlugChannel::SetStrongPlug (
    void
    )
/*++

Routine Description:

    Upgrades the default plug level (http2plDataPlugged) to
    RTS (http2plRTSPlugged)

Arguments:
    
Return Value:

--*/
{
    // make sure we haven't done any sending on the channel. The
    // channel cannot change plug levels after the first send
    ASSERT(TrafficSentOnChannel == FALSE);
    PlugLevel = http2plRTSPlugged;
}

/*********************************************************************
    HTTP2ProxyPlugChannel
 *********************************************************************/

RPC_STATUS HTTP2ProxyPlugChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    A helper function that completes an async io.

Arguments:
    
    CurrentStatus - the status with which the complete
        notification completed.

Return Value:

--*/
{
    return ProxyAsyncCompleteHelper(TopChannel, CurrentStatus);
}

/*********************************************************************
    HTTP2FlowControlSender
 *********************************************************************/

RPC_STATUS HTTP2FlowControlSender::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure
    if SendContextFlagSendLast is set, the following semantics applies:
    RPC_S_OK - no sends are pending. Last context directly sent
    ERROR_IO_PENDING - sends were pending. When they are all drained
        top channel and virtual connection will be notified through
        the LastPacketSentNotification mechanism
    RPC_S_* errors occured during synchronous send


--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *LocalSendContext;

    if (SendContext->TrafficType == http2ttData)
        {
        // we can't send data without knowing the receive window
        // of the peer
        ASSERT(PeerReceiveWindow != 0);
        }

    if (SendContext->Flags & SendContextFlagSendLast)
        {
        // register the last send. We know if this is called, no
        // new sends will be submitted. However, we race with the
        // send complete thread
        InterlockedExchangePointer((PVOID *)&SendContextOnDrain, SendContext);

        if (SendsPending.GetInteger() == 0)
            {
            // no sends are pending. Attempt to grab back the context
            // and do it synchronously
            LocalSendContext = 
                (HTTP2SendContext *)InterlockedExchangePointer((PVOID *)&SendContextOnDrain, NULL);
            if (LocalSendContext)
                {
                // we managed to grab it back. We have won the right to
                // synchronously submit the last context.
                RpcStatus = HTTP2TransportChannel::Send(LocalSendContext);
                // return ok or an error
                return RpcStatus;
                }
            }

        // either there are sends pending, or we lost the race and we have to
        // rely on asynchronous notifications
        return ERROR_IO_PENDING;
        }

    SendsPending.Increment();

    return SendInternal(SendContext,
        FALSE       // IgnoreQueuedPackets
        );
}

RPC_STATUS HTTP2FlowControlSender::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send
    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    int LocalSendsPending;
    HTTP2SendContext *LocalSendContextOnDrain;

    LocalSendsPending = SendsPending.Decrement();
    // in the case of Last packet to send completing, the counter will wrap to -1 here because
    // the last send is not present in SendsPending. That's ok.

    RpcStatus = HTTP2TransportChannel::SendComplete(EventStatus, SendContext);

    if (LocalSendsPending == 0)
        {
        LocalSendContextOnDrain = (HTTP2SendContext *) SendContextOnDrain;
        if (LocalSendContextOnDrain)
            {
            // try to consume the SendContextOnDrain in a thread safe manner
            // in respect to a thread that is setting it. In the cases where SendContextOnDrain
            // will be called the channel is already detached, so we know no new sends will
            // be submitted and we don't need to worry about the race with SendsPending going
            // up again
            LocalSendContextOnDrain = 
                (HTTP2SendContext *)InterlockedCompareExchangePointer((PVOID *)&SendContextOnDrain,
                NULL, 
                LocalSendContextOnDrain
                );

            if (LocalSendContextOnDrain)
                {
                // remove the reference for the previous send
                TopChannel->RemoveReference();

                // last packet must be RTS.
                ASSERT(LocalSendContextOnDrain->TrafficType == http2ttRTS);
                RpcStatus = TopChannel->LastPacketSentNotification(LocalSendContextOnDrain);
                // don't care about return code. This channel is dying anyway
                RpcStatus2 = TopChannel->Send(LocalSendContextOnDrain);

                // the second error takes precedence here
                if (RpcStatus2 != RPC_S_OK)
                    RpcStatus = RpcStatus2;
                }
            }
        }

    return RpcStatus;
}


void HTTP2FlowControlSender::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    // we have a bunch of sends carrying ref-counts, etc.
    // We must make sure they are completed.

    HTTP2TransportChannel::Abort(RpcStatus);

    // we know we are synchronized with everybody else
    if (!RpcpIsListEmpty(&BufferQueueHead))
        {
        AbortStatus = RpcStatus;
        (void) COMMON_PostRuntimeEvent(HTTP2_FLOW_CONTROL_DIRECT_SEND,
            this
            );
        }
}

void HTTP2FlowControlSender::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2FlowControlSender::~HTTP2FlowControlSender();
}

void HTTP2FlowControlSender::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

Note:

    The channel must not be receiving new requests by now (i.e.
    it must be non-default and fully drained)

--*/
{
    SendsPending.Decrement();

    UpperLayer->SendCancelled(SendContext);
}

RPC_STATUS HTTP2FlowControlSender::FlowControlAckNotify (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Notifies the channel that a flow control ack has arrived.

Arguments:

    BytesReceivedForAck - the bytes received from the ack packet

    WindowForAck - the available window advertised in the ack

Return Value:

    RPC_S_OK or RPC_S_PROTOCOL_ERROR if the received values are bogus

--*/
{
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *NextListEntry;
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;
    BOOL ChannelNeedsRecycling;

#if 0
    DbgPrint("%X: HTTP2FlowControlSender::FlowControlAckNotify: %d; %d; %d\n",
        GetCurrentProcessId(), 
        DataBytesSent,
        BytesReceivedForAck,
        WindowForAck
        );
#endif

    RpcStatus = RPC_S_OK;
    ChannelNeedsRecycling = FALSE;

    Mutex.Request();
    CORRUPTION_ASSERT((DataBytesSent - BytesReceivedForAck) <= PeerReceiveWindow);
    if ((DataBytesSent - BytesReceivedForAck) > PeerReceiveWindow)
        {
        Mutex.Clear();
        return RPC_S_PROTOCOL_ERROR;
        }
    
    PeerAvailableWindow = WindowForAck - (DataBytesSent - BytesReceivedForAck);
    CORRUPTION_ASSERT(PeerAvailableWindow <= PeerReceiveWindow);
    if (PeerAvailableWindow > PeerReceiveWindow)
        {
        Mutex.Clear();
        return RPC_S_PROTOCOL_ERROR;
        }

    // did we free up enough window to send some of our queued buffers?
    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        if (SendContext->maxWriteBuffer <= PeerAvailableWindow)
            {
            SendContext->SetListEntryUnused();
            RpcpfRemoveHeadList(&BufferQueueHead);
            // set the CurrentListEntry for the next iteration of the loop
            CurrentListEntry = BufferQueueHead.Flink;
            // send it through this channel. This will update DataBytesSent
            // and PeerAvailableWindow
            RpcStatus = SendInternal(SendContext,
                TRUE    // IgnoreQueuedPackets
                );
            if (RpcStatus != RPC_S_OK)
                {
                if (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING)
                    {
                    // we failed to send - stick back the current context and
                    // return error. This will cause caller to abort and
                    // this will complete all queued sends
                    SendContext->SetListEntryUsed();
                    RpcpfInsertHeadList(&BufferQueueHead, &SendContext->ListEntry);
                    break;
                    }
                else
                    {
                    // remeber that we need to return RPC_P_CHANNEL_NEEDS_RECYCLING at
                    // the end
                    ChannelNeedsRecycling = TRUE;
                    }
                }
            }
        else
            {
            // we don't have enough space to send more. Break out of the loop
            break;
            }
        }
    Mutex.Clear();

    if (ChannelNeedsRecycling)
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
    else
        return RpcStatus;
}

void HTTP2FlowControlSender::GetBufferQueue (
    OUT LIST_ENTRY *NewQueueHead
    )
/*++

Routine Description:

    Grab all queued buffers and pile them on the list head
        that we passed to it. All refcounts must be removed (i.e.
        undone).

Arguments:

    NewQueueHead - new queue heads to pile buffers on

Return Value:

--*/
{
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *NextListEntry;
    HTTP2SendContext *SendContext;

    ASSERT(RpcpIsListEmpty(NewQueueHead));

    Mutex.Request();
    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        SendContext->SetListEntryUnused();
        NextListEntry = CurrentListEntry->Flink;
        RpcpfInsertHeadList(NewQueueHead, CurrentListEntry);
        UpperLayer->SendCancelled(SendContext);
        CurrentListEntry = NextListEntry;
        }
    RpcpInitializeListHead(&BufferQueueHead);
    Mutex.Clear();
}

RPC_STATUS HTTP2FlowControlSender::DirectSendComplete (
    OUT BOOL *IsServer,
    OUT BOOL *SendToRuntime,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us). Note that we will get one notification for
    all buffered sends. We must empty the whole queue, and post
    one notification for each buffer in the queue

Arguments:

    IsServer - in all cases MUST be set to TRUE or FALSE.

    SendToRuntime - in all cases MUST be set to TRUE or FALSE. If FALSE,
        it won't be sent to the runtime (used by proxies)

    SendContext - on output contains the send context as 
        seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK to return error to runtime
    RPC_P_PACKET_CONSUMED - to hide packet from runtime
    RPC_S_* error - return error to runtime

--*/
{
    LIST_ENTRY *CurrentListEntry;
    HTTP2SendContext *CurrentSendContext;
    RPC_STATUS RpcStatus;
    BOOL PostAnotherReceive;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_FLOW_CONTROL_SENDER, 
        !RpcpIsListEmpty(&BufferQueueHead));
    *IsServer = (BOOL)(this->IsServer);
    *SendToRuntime = (BOOL)(this->SendToRuntime);

    // this should only get called when we are aborted. This
    // ensures that we are single threaded in the code
    // below
    TopChannel->VerifyAborted();

    CurrentListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
    ASSERT(CurrentListEntry != &BufferQueueHead);
    
    CurrentSendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
    CurrentSendContext->SetListEntryUnused();

    ASSERT(AbortStatus != RPC_S_OK);

    RpcStatus = HTTP2TransportChannel::SendComplete(AbortStatus, CurrentSendContext);

    PostAnotherReceive = !(RpcpIsListEmpty(&BufferQueueHead));

    if ((RpcStatus != RPC_P_PACKET_CONSUMED) && this->SendToRuntime)
        {
        // this will return to the runtime. Make sure it is valid
        if (this->IsServer)
            I_RpcTransVerifyServerRuntimeCallFromContext(CurrentSendContext);
        else
            I_RpcTransVerifyClientRuntimeCallFromContext(CurrentSendContext);
        *SendContext = CurrentSendContext;
        *Buffer = CurrentSendContext->pWriteBuffer;
        *BufferLength = CurrentSendContext->maxWriteBuffer;
        }
    else
        {
        // the packet was a transport packet - it won't be seen by the runtime
        *SendContext = NULL;
        *Buffer = NULL;
        *BufferLength = 0;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);
    // do not touch this pointer after here unless the list was not-empty
    // (which implies we still have refcounts)

    if (PostAnotherReceive)
        {
        (void) COMMON_PostRuntimeEvent(HTTP2_FLOW_CONTROL_DIRECT_SEND,
            this
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_FLOW_CONTROL_SENDER, 
        PostAnotherReceive);

    return RpcStatus;
}

RPC_STATUS HTTP2FlowControlSender::SendInternal (
    IN OUT HTTP2SendContext *SendContext,
    IN BOOL IgnoreQueuedBuffers
    )
/*++

Routine Description:

    Send request without incrementing SendsPending counter
    and without handling SendContextFlagSendLast

Arguments:

    SendContext - the send context

    IgnoreQueuedBuffers - if non-zero, the send will proceed even if
        there are queued buffers. If FALSE, the send will be queued
        if there are queued buffers.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *LocalSendContext;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_FLOW_CONTROL_SENDER, PtrToUlong(SendContext));

    if (SendContext->TrafficType == http2ttData)
        {
        Mutex.Request();
        // if the peer doesn't have enough window to accept this packet
        // or there are queued packets and we were told not to ignore them, 
        // we have to queue it. Otherwise we can send it
        if (
            (PeerAvailableWindow < SendContext->maxWriteBuffer) 
            || 
            (
               (IgnoreQueuedBuffers == FALSE)
               &&
               (BufferQueueHead.Flink != &BufferQueueHead)
            )
           )
            {
            // either the receiver doesn't have enough window or
            // we have pending buffers
            SendContext->SetListEntryUsed();
            RpcpfInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
            Mutex.Clear();
#if DBG_ERROR
            DbgPrint("Flow controlling sends ...%p\n", this);
#endif

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_FLOW_CONTROL_SENDER, 0);
            return RPC_S_OK;
            }
        else
            {
            // yes, update counters and continue with send
            DataBytesSent += SendContext->maxWriteBuffer;
            PeerAvailableWindow -= SendContext->maxWriteBuffer;
            }
        Mutex.Clear();
        }

    RpcStatus = HTTP2TransportChannel::Send(SendContext);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_FLOW_CONTROL_SENDER, RpcStatus);
    return RpcStatus;
}

/*********************************************************************
    HTTP2PingOriginator
 *********************************************************************/

RPC_STATUS HTTP2PingOriginator::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ConsecutivePingsOnInterval = 0;

    return SendInternal(SendContext);
}

RPC_STATUS HTTP2PingOriginator::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification. Consume packets generated by us
    and forward everything else up.

Arguments:

    EventStatus - the status of the send

    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if ((SendContext->TrafficType == http2ttRTS) 
        && (TrustedIsPingPacket(SendContext->pWriteBuffer)))
        {
        // this is a packet we generated. Eat it up
        FreeRTSPacket(SendContext);
        return RPC_P_PACKET_CONSUMED;
        }

    return HTTP2TransportChannel::SendComplete(EventStatus, SendContext);
}

RPC_STATUS HTTP2PingOriginator::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection. Ignored for this function since we are always
        protected when we start a new submit.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives. Ignored in this
        function.

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    ULONG LocalNewPingInterval;

    // technically the time stamp can be 0, but this would
    // be extremely rare
    ASSERT(LastPacketSentTimestamp);
    ASSERT(Units == tuMilliseconds);

    if (TurnOn == FALSE)
        KeepAliveInterval = 0;
    else
        KeepAliveInterval = KAInterval;

    LocalNewPingInterval = GetPingInterval(ConnectionTimeout,
        KeepAliveInterval
        );

    return SetNewPingInterval(LocalNewPingInterval);
}

void HTTP2PingOriginator::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    HTTP2TransportChannel::Abort(RpcStatus);

    // we are already synchronized with everybody. Just
    // call the internal function
    DisablePingsInternal();
}

void HTTP2PingOriginator::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2PingOriginator::~HTTP2PingOriginator();
}

void HTTP2PingOriginator::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

--*/
{
    RPC_STATUS RpcStatus;

    // a call was cancelled. We don't know what was the last sent
    // time before that, so the only safe thing to do is send another
    // ping. This should be extremely rare as it happens only sometimes
    // during channel recycling.
    
    RpcStatus = ReferenceFromCallback();

    // if already aborted, don't bother
    if (RpcStatus != RPC_S_OK)
        return;

    // we don't care about the result. The channel is dying. If we
    // managed to submit the ping, it's better. If not, we hope the
    // channel will last for long enough in order to complete the
    // recycle process
    RpcStatus = SendPingPacket();

    // SendCancelled will be called only when the channel is close to the
    // end of its recycling. We cannot get another recycling request here.
    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    TopChannel->FinishSubmitAsync();

    UpperLayer->SendCancelled(SendContext);
}

void HTTP2PingOriginator::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    LastPacketSentTimestamp = 0;

    LowerLayer->Reset();
}

RPC_STATUS HTTP2PingOriginator::SetConnectionTimeout (
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Sets the connection timeout for the ping channel. The ping channel
    does not ping when initialized. This call starts the process. It is
    synchronized with DisablePings but not with Aborts.

Arguments:

    ConnectionTimeout - the connection timeout in milliseconds

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    ULONG LocalNewPingInterval;

    // we don't accept anything less than the minimum timeout
    if (ConnectionTimeout <= MinimumConnectionTimeout)
        return RPC_S_PROTOCOL_ERROR;

    // technically the time stamp can be 0, but this would
    // be extremely rare
    ASSERT(LastPacketSentTimestamp);

    if (OverrideMinimumConnectionTimeout)
        this->ConnectionTimeout = min(ConnectionTimeout, OverrideMinimumConnectionTimeout);
    else
        this->ConnectionTimeout = ConnectionTimeout;

    LocalNewPingInterval = GetPingInterval(ConnectionTimeout,
        KeepAliveInterval
        );

    return SetNewPingInterval(LocalNewPingInterval);
}

void HTTP2PingOriginator::DisablePings (
    void
    )
/*++

Routine Description:

    Disables the pings for the channel. Synchronized with
    SetConnectionTimeout but not with Aborts

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    // synchronize with aborts and then call internal
    // routine
    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus == RPC_S_OK)
        {
        DisablePingsInternal();
        TopChannel->FinishSubmitAsync();
        }
}

void HTTP2PingOriginator::TimerCallback (
    void
    )
/*++

Routine Description:

    Timer callback routine - a periodic timer fired.
    Figure out what type of timer it was, and take
    appropriate action.

    N.B. We enter this routine with BeginSubmitAsync
    called on this channel.

    N.B. We enter this routine with one refcount on
    the top channel.

Arguments:

Return Value:

--*/
{
    ULONG CurrentTickCount;
    ULONG LocalLastSentTickCount;
    RPC_STATUS RpcStatus;
    ULONG LocalPingInterval;
    BOOL PingPacketSent;

    LocalLastSentTickCount = LastPacketSentTimestamp;
    CurrentTickCount = NtGetTickCount();

    // if less than the grace period has expired since the last
    // packet was sent, don't bother to send a ping
    if (CurrentTickCount - LocalLastSentTickCount >= GetGracePeriod())
        {
        PingPacketSent = TRUE;
        ConsecutivePingsOnInterval ++;

#if DBG_ERROR
        DbgPrint("Timer expired. No recent activity - sending ping ...\n");
#endif
        RpcStatus = SendPingPacket();

        if ((RpcStatus != RPC_S_OK)
            && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
            {
            // if this fails, SendPingPacket did not take over
            // the refcount. In this case we hand over the
            // refcount to HTTP2_ABORT_CONNECTION which still
            // needs one refcount to operate.
#if DBG_ERROR
            DbgPrint("Ping failed. Aborting connection.\n");
#endif
            TopChannel->FinishSubmitAsync();
            // offload the aborting to a worker thread (rule 33)
            (void) COMMON_PostRuntimeEvent(HTTP2_ABORT_CONNECTION,
                TopChannel
                );
            return;
            }

        // if SendPingPacket succeeds, it took over
        // the refcount. We have no refcount in this code path. The only
        // thing that prevents a problem is that we haven't called
        // FinishSubmitAsync yet. Until we call this, we cannot be
        // aborted.
        if (ConsecutivePingsOnInterval >= ThresholdConsecutivePingsOnInterval)
            {
            LocalPingInterval = ScaleBackPingInterval();

            if (LocalPingInterval > PingInterval)
                {
                // we need to scale back. We can't do it from the timer callback, so we
                // need to offload to a worker thread for this

                ConsecutivePingsOnInterval = 0;

                // add a reference for the offloaded work item
                TopChannel->AddReference();

                (void) COMMON_PostRuntimeEvent(HTTP2_RESCHEDULE_TIMER,
                    this
                    );
                }
            }
        }
    else
        {
        PingPacketSent = FALSE;
#if DBG_ERROR
        DbgPrint("Timer expired. Recent activity on channel detected - no ping necessary\n");
#endif
        }

    if (PingPacketSent != FALSE)
        {
        if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
            {
            // we have the timer callback reference here which protects us. Once we
            // offload to a worker thread, the reference doesn't hold. Add another
            // reference for this.
            TopChannel->AddReference();

            TopChannel->FinishSubmitAsync();

            // offload the recycling to a worker thread. This is necessary because
            // the recycling will abort on failure which violates rule 33.
            (void) COMMON_PostRuntimeEvent(HTTP2_RECYCLE_CHANNEL,
                TopChannel
                );
            }
        else
            {
            TopChannel->FinishSubmitAsync();
            }
        }
    else
        {
        TopChannel->FinishSubmitAsync();

        // drop the reference added for us by the timer callback
        TopChannel->RemoveReference();
        }
}

RPC_STATUS HTTP2PingOriginator::ReferenceFromCallback (
    void
    )
/*++

Routine Description:

    References a ping originator object from the callback
    routine.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    return TopChannel->BeginSubmitAsync();
}

RPC_STATUS HTTP2PingOriginator::SetNewPingInterval (
    IN ULONG NewPingInterval
    )
/*++

Routine Description:

    Puts into effect the new ping interval. This means
    cancelling the old interval (if any) and setting
    the timer for the new. Must NOT be called from
    timer callbacks or we will deadlock.

Arguments:

    NewPingInterval - the new ping interval to use

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    BOOL Result;

    // the new interval is different than the old. Need to update
    // and reschedule
    PingInterval = NewPingInterval;
    ConsecutivePingsOnInterval = 0;

    // synchronize with Aborts
    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    if (PingTimer)
        {
        DisablePingsInternal();
        }

    Result = CreateTimerQueueTimer(&PingTimer,
        NULL,
        HTTP2PingTimerCallback,
        this,
        PingInterval,  // time to first fire
        PingInterval,  // periodic interval
        WT_EXECUTELONGFUNCTION
        );

    if (Result == FALSE)
        {
        PingTimer = NULL;
        TopChannel->FinishSubmitAsync();
        return RPC_S_OUT_OF_MEMORY;
        }

    // add one reference for the timer callback we have set up
    TopChannel->AddReference();

    TopChannel->FinishSubmitAsync();

    return RPC_S_OK;
}

void HTTP2PingOriginator::RescheduleTimer (
    void
    )
/*++

Routine Description:

    Reschedules a timer. This means scale back a timer.

Arguments:

Return Value:

--*/
{
    ULONG LocalPingInterval;

    LocalPingInterval = ScaleBackPingInterval();

    if (LocalPingInterval > PingInterval)
        {
        // ignore the result. Scaling back is a best effort.
        // If it fails, that's ok.
        (void) SetNewPingInterval(LocalPingInterval);
        }

    // remove the reference for the work item
    TopChannel->RemoveReference();
}

void HTTP2PingOriginator::DisablePingsInternal (
    void
    )
/*++

Routine Description:

    Disables the pings for the channel. Must be synchronized with
    SetConnectionTimeout, Abort and DisablePings

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    BOOL Result;

    if (PingTimer)
        {
        Result = DeleteTimerQueueTimer(NULL,
            PingTimer,
            INVALID_HANDLE_VALUE    // tell the timer function to wait for all callbacks
                                    // to complete before returning
            );

#if DBG
        // during process shutdown the loader termination code will
        // shutdown threads (including the NTDLL thread pool threads)
        // before it indicates to anybody that it is doing so. This ASSERT
        // will fire in such cases causing random stress breaks. Disable it.
        // ASSERT(Result);     
#endif  // DBG

        // we added one reference for the timer callback. Remove it
        TopChannel->RemoveReference();

        PingTimer = NULL;
        }
}

RPC_STATUS HTTP2PingOriginator::SendPingPacket (
    void
    )
/*++

Routine Description:

    Sends a ping packet on this channel. Must be called with AsyncSubmit
        started.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *PingPacket;
    ULONG PingPacketSize;

    PingPacket = AllocateAndInitializePingPacket();
    if (PingPacket == NULL)
        return RPC_S_OUT_OF_MEMORY;

    PingPacketSize = PingPacket->maxWriteBuffer;

    RpcStatus = SendInternal(PingPacket);
    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        FreeRTSPacket(PingPacket);
    else if (NotifyTopChannelForPings)
        TopChannel->PingTrafficSentNotify(PingPacketSize);

    return RpcStatus;
}

RPC_STATUS HTTP2PingOriginator::SendInternal (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    LastPacketSentTimestamp = NtGetTickCount();
    
    return HTTP2TransportChannel::Send(SendContext);
}

/*********************************************************************
    HTTP2PingReceiver
 *********************************************************************/

RPC_STATUS HTTP2PingReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if (EventStatus == RPC_S_OK)
        {
        if (IsRTSPacket(Buffer) && UntrustedIsPingPacket(Buffer, BufferLength))
            {
            // this is a ping packet. Consume it and post another receive if
            // necessary
            if (PostAnotherReceive)
                {
                EventStatus = TopChannel->BeginSubmitAsync();
                if (EventStatus == RPC_S_OK)
                    {
                    EventStatus = HTTP2TransportChannel::Receive(http2ttRaw);
                    TopChannel->FinishSubmitAsync();
                    if (EventStatus != RPC_S_OK)
                        TopChannel->RemoveReference();
                    }
                }

            if (EventStatus == RPC_S_OK)
                {
                // we free the buffer only in success case. In failure case
                // we need a buffer to pass to receive complete down.
                RpcFreeBuffer(Buffer);
                return RPC_P_PACKET_CONSUMED;
                }
            else
                {
                // fall through to indicating a receive failure below
                }
            }
        }

    return HTTP2TransportChannel::ReceiveComplete(EventStatus, TrafficType, Buffer, BufferLength);
}

void HTTP2PingReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2PingReceiver::~HTTP2PingReceiver();
}

/*********************************************************************
    HTTP2ChannelDataOriginator
 *********************************************************************/

HTTP2ChannelDataOriginator::HTTP2ChannelDataOriginator (
    IN ULONG ChannelLifetime,
    IN BOOL IsServer,
    OUT RPC_STATUS *Status
    ) : Mutex(Status,
    FALSE,  // pre-allocate semaphore
    5000    // spin count
    )
/*++

Routine Description:

    HTTP2ChannelDataOriginator constructor

Arguments:

    ChannelLifetime - the lifetime read from the registry

    IsServer - non-zero if this is a server side data originator.
        0 otherwise.

    Status - on input RPC_S_OK. On output, the result of the constructor.

Return Value:

--*/
{
    RpcpInitializeListHead(&BufferQueueHead);

    this->ChannelLifetime = ChannelLifetime;
    NonreservedLifetime = ChannelLifetime;
    if (IsServer)
        NonreservedLifetime -= ServerReservedChannelLifetime;
    else
        NonreservedLifetime -= ClientReservedChannelLifetime;
    this->IsServer = IsServer;
    BytesSentOnChannel = 0;
    ChannelReplacementTriggered = FALSE;
    AbortStatus = RPC_S_OK;
#if DBG
    RawDataAlreadySent = FALSE;
#endif  // DBG
}


RPC_STATUS HTTP2ChannelDataOriginator::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ULONG NewBytesSentOnChannel;
    BOOL ChannelReplacementNeeded;
    RPC_STATUS RpcStatus;
    ULONG LocalBytesSentOnChannel;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CDATA_ORIGINATOR, BytesSentOnChannel);

    ChannelReplacementNeeded = FALSE;

    // if this is raw traffic, don't count it
    if (SendContext->TrafficType == http2ttRaw)
        {
        RawDataBeingSent();
        }
    // otherwise, count it only if the traffic is not specifically exempt
    else if ((SendContext->Flags & SendContextFlagNonChannelData) == 0)
        {
        // we don't always take the mutex. We know that the bytes sent will only
        // grow. If we think it is a good time to recycle the channel, the fact that
        // another thread is also sending in a race condition with us makes it even
        // more so. We just need to be careful to properly update the BytesSendOnChannel
        // at the end
        LocalBytesSentOnChannel = BytesSentOnChannel;
        NewBytesSentOnChannel = LocalBytesSentOnChannel + SendContext->maxWriteBuffer;
        if ((NewBytesSentOnChannel > NonreservedLifetime) || ChannelReplacementTriggered)
            {
            Mutex.Request();

            // now that we have the mutex, check again. Sometimes the channel
            // can start sending from 0 again (e.g. out proxy negotiates a new
            // out channel with the client and server is ready to start from 0)
            // This can happen in restart channel, which is also protected by the
            // mutex

            LocalBytesSentOnChannel = BytesSentOnChannel;
            NewBytesSentOnChannel = LocalBytesSentOnChannel + SendContext->maxWriteBuffer;
            if ((NewBytesSentOnChannel > NonreservedLifetime) || ChannelReplacementTriggered)
                {
                if (ChannelReplacementTriggered == FALSE)
                    {
                    ChannelReplacementNeeded = TRUE;
                    ChannelReplacementTriggered = TRUE;
                    }

                // if this is data, queue it
                if (SendContext->TrafficType == http2ttData)
                    {
                    SendContext->SetListEntryUsed();
                    RpcpfInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
                    Mutex.Clear();

                    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CDATA_ORIGINATOR, BytesSentOnChannel);

                    if (ChannelReplacementNeeded)
                        {
                        LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_CHANNEL_RECYCLE, HTTP2LOG_OT_CDATA_ORIGINATOR, NewBytesSentOnChannel);
                        return RPC_P_CHANNEL_NEEDS_RECYCLING;
                        }
                    else
                        return RPC_S_OK;
                    }
                else
                    {
                    ASSERT(SendContext->TrafficType == http2ttRTS);
                    // fall through to sending below
                    }
                }

            Mutex.Clear();
            // either channel got reset or this was RTS traffic. Fall through to
            // sending
            }

        // update BytesSentOnChannel in thread safe manner
        do
            {
            LocalBytesSentOnChannel = BytesSentOnChannel;
            NewBytesSentOnChannel = LocalBytesSentOnChannel + SendContext->maxWriteBuffer;
            }
        while (InterlockedCompareExchange((LONG *)&BytesSentOnChannel, 
            NewBytesSentOnChannel, 
            LocalBytesSentOnChannel) != LocalBytesSentOnChannel);
        }

    RpcStatus = HTTP2TransportChannel::Send(SendContext);

    if (ChannelReplacementNeeded && (RpcStatus == RPC_S_OK))
        {
#if DBG        
        DbgPrintEx(DPFLTR_RPCPROXY_ID,
                       DPFLTR_TRACE_LEVEL,
                       "RPCRT4: Indicating channel needs recycling %p %d\n",
                       this, 
                       IsServer);
#endif  // DBG

        LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_CHANNEL_RECYCLE, HTTP2LOG_OT_CDATA_ORIGINATOR, NewBytesSentOnChannel);
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CDATA_ORIGINATOR, BytesSentOnChannel);

    return RpcStatus;
}

void HTTP2ChannelDataOriginator::Abort (
    IN RPC_STATUS RpcStatus
    )
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CDATA_ORIGINATOR, RpcStatus);

    // we have a bunch of sends carrying ref-counts, etc.
    // We must make sure they are completed.

    HTTP2TransportChannel::Abort(RpcStatus);

    // we know we are synchronized with everybody else
    if (!RpcpIsListEmpty(&BufferQueueHead))
        {
        AbortStatus = RpcStatus;
        (void) COMMON_PostRuntimeEvent(CHANNEL_DATA_ORIGINATOR_DIRECT_SEND,
            this
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CDATA_ORIGINATOR, RpcStatus);
}

void HTTP2ChannelDataOriginator::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2ChannelDataOriginator::~HTTP2ChannelDataOriginator();
}

void HTTP2ChannelDataOriginator::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
#if DBG
    RawDataAlreadySent = FALSE;
#endif  // DBG
    ASSERT(RpcpIsListEmpty(&BufferQueueHead));
    LowerLayer->Reset();
}

void HTTP2ChannelDataOriginator::GetBufferQueue (
    OUT LIST_ENTRY *NewQueueHead
    )
/*++

Routine Description:

    Grab all queued buffers and pile them on the list head
    that we passed to it. All refcounts must be removed (i.e.
    undone). Called in submission context only and we know there
    will be no more sends. Therefore we are single threaded.

Arguments:

    NewQueueHead - new queue heads to pile buffers on

Return Value:

--*/
{
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *NextListEntry;
    HTTP2SendContext *SendContext;

    ASSERT(RpcpIsListEmpty(NewQueueHead));

    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        SendContext->SetListEntryUnused();
        NextListEntry = CurrentListEntry->Flink;
        RpcpfInsertHeadList(NewQueueHead, CurrentListEntry);
        UpperLayer->SendCancelled(SendContext);
        CurrentListEntry = NextListEntry;
        }
    RpcpInitializeListHead(&BufferQueueHead);
}

RPC_STATUS HTTP2ChannelDataOriginator::DirectSendComplete (
    OUT BOOL *IsServer,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us). Note that we will get one notification for
    all buffered sends. We must empty the whole queue, and post
    one notification for each buffer in the queue

Arguments:

    IsServer - in all cases MUST be set to TRUE or FALSE.

    SendContext - on output contains the send context as 
        seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK to return error to runtime
    RPC_P_PACKET_CONSUMED - to hide packet from runtime
    RPC_S_* error - return error to runtime

--*/
{
    LIST_ENTRY *CurrentListEntry;
    HTTP2SendContext *CurrentSendContext;
    RPC_STATUS RpcStatus;
    BOOL PostAnotherReceive;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_CDATA_ORIGINATOR, 
        !RpcpIsListEmpty(&BufferQueueHead));
    *IsServer = this->IsServer;

    // this should only get called when we are aborted. This
    // ensures that we are single threaded in the code
    // below
    TopChannel->VerifyAborted();

    CurrentListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
    ASSERT(CurrentListEntry != &BufferQueueHead);
    
    CurrentSendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
    CurrentSendContext->SetListEntryUnused();

    ASSERT(AbortStatus != RPC_S_OK);

    RpcStatus = HTTP2TransportChannel::SendComplete(AbortStatus, CurrentSendContext);

    PostAnotherReceive = !(RpcpIsListEmpty(&BufferQueueHead));

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        // this will return to the runtime. Make sure it is valid
        if (this->IsServer)
            I_RpcTransVerifyServerRuntimeCallFromContext(CurrentSendContext);
        else
            I_RpcTransVerifyClientRuntimeCallFromContext(CurrentSendContext);
        *SendContext = CurrentSendContext;
        *Buffer = CurrentSendContext->pWriteBuffer;
        *BufferLength = CurrentSendContext->maxWriteBuffer;
        }
    else
        {
        // the packet was a transport packet - it won't be seen by the runtime
        *SendContext = NULL;
        *Buffer = NULL;
        *BufferLength = 0;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);
    // do not touch this pointer after here unless the list was not-empty
    // (which implies we still have refcounts)

    if (PostAnotherReceive)
        {
        (void) COMMON_PostRuntimeEvent(CHANNEL_DATA_ORIGINATOR_DIRECT_SEND,
            this
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_CDATA_ORIGINATOR, 
        PostAnotherReceive);

    return RpcStatus;
}

RPC_STATUS HTTP2ChannelDataOriginator::RestartChannel (
    void
    )
/*++

Routine Description:

    Restart the channel. Somehow the channel lifetime became
    fully available again, and we can start from 0. This happens
    when the out proxy renegotiates the out channel with the client
    and we can keep using the server channels again.

Arguments:

Return Value:

    RPC_S_OK
    RPC_S_* error

--*/
{
    LIST_ENTRY *CurrentListEntry;
    HTTP2SendContext *SendContext;
    ULONG NewBytesSentOnChannel = 0;
    ULONG BytesForThisSend;
    RPC_STATUS RpcStatus;

    // the channel must have been plugged
    ASSERT(BytesSentOnChannel > NonreservedLifetime);

    Mutex.Request();
    // grab all queued packets and send them out
    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        SendContext->SetListEntryUnused();
        ASSERT(SendContext->TrafficType == http2ttData);

        BytesForThisSend = SendContext->maxWriteBuffer;

        // assume success of the send and remove the element from the queue.
        // This is necessary because if the send succeeds, there is a race
        // condition with the send complete path
        (void) RpcpfRemoveHeadList(&BufferQueueHead);

        RpcStatus = HTTP2TransportChannel::Send(SendContext);

        ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

        if (RpcStatus != RPC_S_OK)
            {
            // failure. We should issue send complete for all queued sends
            // including the current one. However, it is easier for us to add back
            // the currently failed send and return failure to caller. Caller will
            // abort and there we will issue send complete for all pending sends.
            SendContext->SetListEntryUsed();
            RpcpfInsertHeadList(&BufferQueueHead, CurrentListEntry);
            Mutex.Clear();
            // return failure to the caller. This will cause the caller to abort the
            // channel, and all sends will be completed.
            return RpcStatus;
            }

        NewBytesSentOnChannel += BytesForThisSend;

        ASSERT(NewBytesSentOnChannel < NonreservedLifetime);

        // process the next element (which by now has become the first since
        // we removed the successfully sent one).
        CurrentListEntry = BufferQueueHead.Flink;
        }

    // reset the counters
    ChannelReplacementTriggered = FALSE;
    BytesSentOnChannel = NewBytesSentOnChannel;

    Mutex.Clear();

    return RPC_S_OK;
}

RPC_STATUS HTTP2ChannelDataOriginator::NotifyTrafficSent (
    IN ULONG TrafficSentSize
    )
/*++

Routine Description:

    Notifies the channel that bytes were sent on the wire. Channel
    reports back whether channel recycling should occur.

Arguments:

    TrafficSentSize - the number of bytes sent.

Return Value:

    RPC_S_OK or RPC_P_CHANNEL_NEEDS_RECYCLING.

--*/
{
    ULONG LocalBytesSentOnChannel;
    ULONG NewBytesSentOnChannel;
    BOOL ChannelReplacementNeeded;

    ChannelReplacementNeeded = FALSE;

    // this is very rare. Don't bother to take the mutex opportunistically.
    // Just make sure that we do use interlocks because no all paths take
    // the mutex. The mutex synchronizes us with Restart
    Mutex.Request();

    LocalBytesSentOnChannel = BytesSentOnChannel;
    NewBytesSentOnChannel = LocalBytesSentOnChannel + TrafficSentSize;
    if (NewBytesSentOnChannel > NonreservedLifetime)
        {
        if (ChannelReplacementTriggered == FALSE)
            {
            ChannelReplacementNeeded = TRUE;
            ChannelReplacementTriggered = TRUE;
            }
        }

    Mutex.Clear();

    // update BytesSentOnChannel in thread safe manner
    do
        {
        LocalBytesSentOnChannel = BytesSentOnChannel;
        NewBytesSentOnChannel = LocalBytesSentOnChannel + TrafficSentSize;
        }
    while (InterlockedCompareExchange((LONG *)&BytesSentOnChannel, 
        NewBytesSentOnChannel, 
        LocalBytesSentOnChannel) != LocalBytesSentOnChannel);

    if (ChannelReplacementNeeded)
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
    else
        return RPC_S_OK;
}

/*********************************************************************
    HTTP2Channel
 *********************************************************************/

RPC_STATUS HTTP2Channel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    if (SendContext->Flags & SendContextFlagPluggedChannel)
        {
        BeginSubmitAsyncNonFailing();
        }
    else
        {
        RpcStatus = BeginSubmitAsync();
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        }

    RpcStatus = LowerLayer->Send(SendContext);

    FinishSubmitAsync();

    if ((RpcStatus != RPC_S_OK) 
        && (RpcStatus != ERROR_IO_PENDING) 
        && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        {
        RemoveReference();  // remove the reference for the async send
        }

    return(RpcStatus);
}

RPC_STATUS HTTP2Channel::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = BeginSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    RpcStatus = LowerLayer->Receive(TrafficType);

    FinishSubmitAsync();

    if (RpcStatus != RPC_S_OK)
        RemoveReference();  // remove the reference for the async receive

    return(RpcStatus);
}

RPC_STATUS HTTP2Channel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation
    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = CheckSendCompleteForSync(EventStatus,
        SendContext
        );

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        RpcStatus = ForwardUpSendComplete(EventStatus,
            SendContext
            );
        }

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification complete notification

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_CHANNEL, (ULONG_PTR)EventStatus);

    RpcStatus = CheckReceiveCompleteForSync(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        RpcStatus = ForwardUpReceiveComplete(EventStatus,
            Buffer,
            BufferLength
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_CHANNEL, (ULONG_PTR)RpcStatus);

    return RpcStatus;
}


void HTTP2Channel::PrepareForSyncSend (
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Prepares a SendContext for SyncSend

Arguments:

    BufferLength - the length of the buffer

    Buffer - the buffer to send

    SendContext - a memory block of sufficient size to initialize a send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    SendContext->u.SyncEvent = I_RpcTransGetThreadEvent();
    ResetEvent(SendContext->u.SyncEvent);
    SendContext->SetListEntryUnused();
    SendContext->maxWriteBuffer = BufferLength;
    SendContext->pWriteBuffer = Buffer;
    // SendContext->Write.pAsyncObject = NULL; // this will be initialized in the bottom layer
    SendContext->Write.ol.Internal = STATUS_PENDING;
    SendContext->TrafficType = http2ttData;
    SendContext->Write.ol.OffsetHigh = 0;
    SendContext->Flags = 0;
    SendContext->UserData = 0;
}


RPC_STATUS HTTP2Channel::SyncSend (
    IN HTTP2TrafficType TrafficType,
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout,
    IN BASE_ASYNC_OBJECT *Connection,
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Emulate a sync send using lower level async primitives

Arguments:

    TrafficType - the type of traffic

    BufferLength - the length of the buffer

    Buffer - the buffer to send

    fDisableCancelCheck - don't do checks for cancels. Can be
        used as optimization

    Timeout - the call timeout

    Connection - the transport connection object. Used for cancelling.

    SendContext - a memory block of sufficient size to initialize a send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CHANNEL, 0);

    PrepareForSyncSend (BufferLength,
                        Buffer,
                        SendContext);

    RpcStatus = HTTP2Channel::Send(SendContext);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CHANNEL, RpcStatus);
    return RpcStatus;
}

RPC_STATUS HTTP2Channel::ForwardTraffic (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    On receiving channels forwards to the sending channel.
    On sending channels sends down. This implementation
    is for a sending channel (since all sending channels
    are the same). Receiving channels must override it.

Arguments:

    Packet - the packet to forward

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeContextFromPacket(Packet,
        PacketLength
        );

    if (SendContext != NULL)
        {
        return Send(SendContext);
        }
    else
        return RPC_S_OUT_OF_MEMORY;
}

RPC_STATUS HTTP2Channel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack. Receiving channels don't 
        need this. Sending channels must override to forward
        to the right place.

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    // we should never be here
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2Channel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Helper routine that helps complete an async operation

Arguments:
    
    CurrentStatus - the current status of the operation

Return Value:

    The status to return to the runtime.

--*/
{
    HTTP2VirtualConnection *VirtualConnection;

    ASSERT(CurrentStatus != RPC_S_CANNOT_SUPPORT);
    ASSERT(CurrentStatus != RPC_S_INTERNAL_ERROR);

    if (CurrentStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // recycle the parent connection
        VirtualConnection = LockParentPointer();
        if (VirtualConnection)
            {
            CurrentStatus = VirtualConnection->RecycleChannel(
                TRUE    // IsFromUpcall
                );
            UnlockParentPointer();
            }
        else
            {
            CurrentStatus = RPC_S_OK;
            }
        }
    else if ((CurrentStatus != RPC_S_OK)
        &&
        (CurrentStatus != RPC_P_PACKET_CONSUMED))
        {
        // if this failed, abort the whole connection
        AbortConnection(CurrentStatus);
        }

    RemoveReference();

    return CurrentStatus;
}

void HTTP2Channel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Aborts the channel and all of the stack below it. The
    request must come from above or from neutral context -
    never from submit context from below. Otherwise we
    will deadlock when we drain the upcalls

Arguments:

    RpcStatus - the error to abort with

Return Value:

--*/
{
    BOOL Result;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CHANNEL, RpcStatus);

    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    Result = InitiateAbort();
    if (Result)
        {
        SetAbortReason(RpcStatus);
        // forward it down
        LowerLayer->Abort(RpcStatus);
        }
}

void HTTP2Channel::AbortConnection (
    IN RPC_STATUS AbortReason
    )
/*++

Routine Description:

    Aborts the virtual connection.

Arguments:

    RpcStatus - the error to abort with

Return Value:

--*/
{
    HTTP2VirtualConnection *VirtualConnection;

    // abort the parent connection
    VirtualConnection = LockParentPointer();
    if (VirtualConnection)
        {
        VirtualConnection->AbortChannels(AbortReason);
        UnlockParentPointer();
        }
    else
        {
        // abort this channel at least
        Abort(AbortReason);
        }
}

void HTTP2Channel::AbortAndDestroyConnection (
    IN RPC_STATUS AbortStatus
    )
/*++

Routine Description:

    Aborts and destroys the virtual connection.

Arguments:
    
    AbortStatus - the status to abort the connection
        with.

Return Value:

Note: The method is idempotent

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    BOOL Result;

    // first, tell connection to destroy itself (almost entirely)
    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        {
        // abort ourselves at least
        Abort(AbortStatus);
        return;
        }

    Result = VirtualConnection->AbortAndDestroy(TRUE,   // IsFromChannel
        ChannelId, 
        AbortStatus);

    UnlockParentPointer();

    // if somebody is already destroying it, just return
    if (Result == FALSE)
        return;

    // because we have called AbortAndDestroy, we know the connection
    // will stay for us. Synchronize with upcalls from this channel
    DrainUpcallsAndFreeParent();

    // now VirtualConnection is a pointer disconnected from everybody
    // that we can destroy at our leisure
    delete VirtualConnection;
}

RPC_STATUS HTTP2Channel::CheckSendCompleteForSync (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification. Checks for sync operation,
    and if yes, completes the sync send and consumes
    the packet.

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // was this a sync send?
    if (SendContext->u.SyncEvent)
        {
        // yes, consume it
        SendContext->Write.ol.Internal = (ULONG)EventStatus;
        SendContext->Write.ol.OffsetHigh = 1;
        SetEvent(SendContext->u.SyncEvent);
        return RPC_P_PACKET_CONSUMED;
        }

    return RPC_S_OK;
}

RPC_STATUS HTTP2Channel::ForwardUpSendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification. Forwards the send complete to the 
    virtual connection.

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;
    BOOL IsRTSPacket;

    VirtualConnection = LockParentPointer();
    // if parent has already detached, just return back
    if (VirtualConnection == NULL)
        {
        // in some cases the parent will detach without aborting
        if (EventStatus == RPC_S_OK)
            {
            if (SendContext->TrafficType == http2ttRTS)
                RpcStatus = RPC_P_PACKET_CONSUMED;
            else
                RpcStatus = EventStatus;    // already ok
            }
        else
            {
            // Abort in these cases (Abort is idempotent)
            Abort(EventStatus);
            RpcStatus = EventStatus;
            }
        IsRTSPacket = (SendContext->TrafficType == http2ttRTS);
        // if we have data sends pending, and we are an endpoint, 
        // we shouldn't have disconnected
        if (Flags.GetFlag(ProxyChannelType) == FALSE)
            {
            ASSERT(IsRTSPacket);
            }

        FreeSendContextAndPossiblyData(SendContext);

        if (IsRTSPacket)
            return RPC_P_PACKET_CONSUMED;
        else
            return RpcStatus;
        }

    RpcStatus = VirtualConnection->SendComplete(EventStatus,
        SendContext,
        ChannelId
        );

    UnlockParentPointer();

    return RpcStatus;
}


RPC_STATUS HTTP2Channel::CheckReceiveCompleteForSync (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification. Checks if the receive was
    sync, and if yes, fires event and consumes the packet. For
    base class it's always not for us (base class does not
    support sync receives)

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // not for us after all. Let it continue
    return RPC_S_OK;
}

RPC_STATUS HTTP2Channel::ForwardUpReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification. Forwards the receive
    complete to the virtual connection

Arguments:

    EventStatus - status of the operation

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    VirtualConnection = LockParentPointer();
    // if parent has already detached, just return back
    if (VirtualConnection == NULL)
        {
        // in some cases the parent will detach without aborting
        // Abort in these cases (Abort is idempotent)
        Abort(RPC_P_CONNECTION_SHUTDOWN);
        return RPC_P_PACKET_CONSUMED;
        }

    RpcStatus = VirtualConnection->ReceiveComplete(EventStatus,
        Buffer,
        BufferLength,
        ChannelId
        );

    UnlockParentPointer();

    if (RpcStatus == RPC_P_ABORT_NEEDED)
        {
        // in some cases the parent cannot abort because the channel
        // is already detached from the parent. In such cases it will
        // tell us to abort. (Abort is idempotent)
        Abort(RPC_P_CONNECTION_SHUTDOWN);
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    // many channels don't support this and
    // shouldn't be called with it. Those who do support it
    // should override it.

    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2Channel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support past packet notifications

Arguments:

    LastSendContext - the context we're sending

Return Value:

    The value to return to the bottom channel/runtime.

--*/
{
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2Channel::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

--*/
{
    RemoveReference();
}

void HTTP2Channel::PingTrafficSentNotify (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Notifies a channel that ping traffic has been sent.

Arguments:

    PingTrafficSize - the size of the ping traffic sent.

--*/
{
    // nobody should be here. Channels that use that must
    // override.
    ASSERT(0);
}

void HTTP2Channel::FreeObject (
        void
        )
/*++

Routine Description:

    Frees a client in channel object

Arguments:

Return Value:

--*/
{
    // make sure we have been aborted
    ASSERT(Aborted.GetInteger() > 0);

    LowerLayer->FreeObject();

    // the client channel is the top of the stack. Just free us
    // which will free the whole stack
    delete this;
}

RPC_STATUS HTTP2Channel::ForwardFlowControlAckOnDefaultChannel (
    IN BOOL IsInChannel,
    IN ForwardDestinations Destination,
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack on the default channel

Arguments:

    IsInChannel - non-zero if the IN channel is to be used. FALSE
        otherwise

    Destination - where to forward to.

    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

Notes:

    If on an endpoint, called from a neutral context only. Proxies
    call it in submission context.

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;

    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        return RPC_P_CONNECTION_SHUTDOWN;

    // allocate and initalize the flow control ACK packet
    SendContext = AllocateAndInitializeFlowControlAckPacketWithDestination (
        Destination,
        BytesReceivedForAck,
        WindowForAck,
        VirtualConnection->MapChannelIdToCookie(ChannelId)
        );

    if (SendContext == NULL)
        {
        UnlockParentPointer();
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcStatus = VirtualConnection->SendTrafficOnDefaultChannel(IsInChannel,
        SendContext
        );

    UnlockParentPointer();

    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::ForwardFlowControlAckOnThisChannel (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck,
    IN BOOL NonChannelData
    )
/*++

Routine Description:

    Forwards a flow control ack on this channel

Arguments:

    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

    NonChannelData - non-zero if the data being sent don't go on the HTTP
    channel. FALSE if they do

Return Value:

    RPC_S_OK or RPC_S_*

Notes: 

    This must be called in upcall or neutral context only

--*/
{
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;
    HTTP2VirtualConnection *VirtualConnection;

    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        return RPC_P_CONNECTION_SHUTDOWN;

    // allocate and initalize the flow control ACK packet
    SendContext = AllocateAndInitializeFlowControlAckPacket (
        BytesReceivedForAck,
        WindowForAck,
        VirtualConnection->MapChannelIdToCookie(ChannelId)
        );

    UnlockParentPointer();

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (NonChannelData)
        SendContext->Flags |= SendContextFlagNonChannelData;

    RpcStatus = Send(SendContext);

    // this can be called on the server, or on the proxy. If on the server,
    // it will be called with NonChannelData. This means we cannot have
    // channel recycle indication here.
    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    if (RpcStatus != RPC_S_OK)
        {
        FreeRTSPacket(SendContext);
        }

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::HandleSendResultFromNeutralContext (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Handles the result code from send from a neutral context.
    This includes checking for channel recycling and intiating
    one if necessary.

Arguments:

    CurrentStatus - the status from the send operation

Return Value:

    RPC_S_OK or RPC_S_*. Callers may ignore it since all cleanup was
    done.

Notes: 

    This must be called in upcall or neutral context only

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2VirtualConnection *VirtualConnection;

    ASSERT(CurrentStatus != RPC_S_CANNOT_SUPPORT);
    ASSERT(CurrentStatus != RPC_S_INTERNAL_ERROR);

    if (CurrentStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // recycle the parent connection
        VirtualConnection = LockParentPointer();
        if (VirtualConnection)
            {
            RpcStatus = VirtualConnection->RecycleChannel(
                TRUE    // IsFromUpcall
                );
            UnlockParentPointer();

            if (RpcStatus != RPC_S_OK)
                {
                // if this failed, abort the whole connection
                AbortConnection(CurrentStatus);
                }

            CurrentStatus = RpcStatus;
            }
        else
            {
            // nothing to do - the channel is dying anyway
            CurrentStatus = RPC_P_CONNECTION_SHUTDOWN;
            }
        }

    return CurrentStatus;
}

RPC_STATUS HTTP2Channel::IsInChannel (
    OUT BOOL *InChannel
    )
/*++

Routine Description:

    Checks if the current channel is an in channel or an
    out channel.

Arguments:

    InChannel - on output will be set to non-zero if this is an
    in channel. It will be set to 0 if this is an out channel.
    Undefined on failure.

Return Value:

    RPC_S_OK or RPC_P_CONNECTION_SHUTDOWN. If the parent has detached, 
    RPC_P_CONNECTION_SHUTDOWN will be returned. In all other cases 
    success is returned.

--*/
{
    HTTP2VirtualConnection *VirtualConnection;

    VirtualConnection = LockParentPointer();
    if (VirtualConnection)
        {
        VirtualConnection->VerifyValidChannelId(ChannelId);
        *InChannel = VirtualConnection->IsInChannel(ChannelId);
        UnlockParentPointer();
        return RPC_S_OK;
        }
    else
        return RPC_P_CONNECTION_SHUTDOWN;
}

/*********************************************************************
    HTTP2VirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2VirtualConnection::Send (
    IN UINT Length,
    IN BUFFER Buffer,
    IN PVOID SendContext
    )
/*++

Routine Description:

    Send on an HTTP client virtual connection. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer of at least SendContextSize bytes
        which will be used during the call and returned
        when the send completes.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

Note:

    Can be called from runtime/neutral context only.

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2Channel *Channel;
    HTTP2SendContext *HttpSendContext;
    RPC_STATUS RpcStatus;

    HttpSendContext = (HTTP2SendContext *)SendContext;
    HttpSendContext->SetListEntryUnused();
    HttpSendContext->maxWriteBuffer = Length;
    HttpSendContext->pWriteBuffer = Buffer;
    HttpSendContext->TrafficType = http2ttData;
    HttpSendContext->u.SyncEvent = NULL;
    HttpSendContext->Flags = 0;
    HttpSendContext->UserData = 0;

    Channel = LockDefaultSendChannel(&ChannelPtr);
    if (Channel)
        {
        RpcStatus = Channel->Send(HttpSendContext);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_SEND_FAILED;
        }

    RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
        FALSE       // IsFromUpcall
        );

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        // Note that send can't really fail with protocol error. When
        // it happens it has simply picked the error with which
        // the connection was aborted. This is as good as a failed send.
        if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
            || (RpcStatus == RPC_P_CONNECTION_CLOSED)
            || (RpcStatus == RPC_P_RECEIVE_FAILED)
            || (RpcStatus == RPC_S_PROTOCOL_ERROR) )
            {
            RpcStatus = RPC_P_SEND_FAILED;
            }
        }

    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::Receive (
    void
    )
/*++

Routine Description:

    Post a receive on a HTTP client virtual connection.

Arguments:

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    Channel = LockDefaultReceiveChannel(&ChannelPtr);
    if (Channel)
        {
        RpcStatus = Channel->Receive(http2ttData);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::SyncSend (
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Do a sync send on an HTTP connection.

Arguments:

    BufferLength - the length of the data to send.

    Buffer - the data to send.

    fDisableShutdownCheck - ignored

    fDisableCancelCheck - runtime indicates no cancel
        will be attempted on this send. Can be used
        as optimization hint by the transport

    Timeout - send timeout (call timeout)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    HTTP2SendContext LocalSendContext;
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;

    // we will convert a sync send to an async send
    // make sure there is a thread to pick up the completion
    RpcStatus = HTTPTransInfo->CreateThread();
    if (RpcStatus != RPC_S_OK)
        {
        if (RpcStatus == RPC_S_OUT_OF_THREADS)
            RpcStatus = RPC_S_OUT_OF_RESOURCES;

        VALIDATE(RpcStatus)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_SEND_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_COMPLETE,
            RPC_P_TIMEOUT
            } END_VALIDATE;

        return RpcStatus;
        }

    Channel = LockDefaultSendChannel (&ChannelPtr);
    if (Channel == NULL)
        {
        return RPC_P_SEND_FAILED;
        }

    RpcStatus = Channel->SyncSend(http2ttData,
        BufferLength,
        Buffer,
        fDisableCancelCheck,
        Timeout,
        this,
        &LocalSendContext
        );

    ChannelPtr->UnlockChannelPointer();

    if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // get the ball rolling with the recycle
        RpcStatus = RecycleChannel(
            FALSE    // IsFromUpcall
            );

        // ok or not, we have to wait for IO to complete
        RpcStatus2 = WaitForSyncSend(this,
            &LocalSendContext,
            this,
            fDisableCancelCheck,
            Timeout
            );

        if ((RpcStatus2 == RPC_S_OK) && (RpcStatus != RPC_S_OK))
            RpcStatus2 = RpcStatus;

        if ((RpcStatus2 == RPC_P_CONNECTION_SHUTDOWN)
            || (RpcStatus2 == RPC_P_RECEIVE_FAILED)
            || (RpcStatus2 == RPC_P_CONNECTION_CLOSED)
            || (RpcStatus2 == RPC_S_SERVER_UNAVAILABLE)
            || (RpcStatus2 == RPC_S_PROTOCOL_ERROR) )
            RpcStatus2 = RPC_P_SEND_FAILED;

        VALIDATE(RpcStatus2)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_SEND_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_COMPLETE,
            RPC_P_TIMEOUT,
            }
        END_VALIDATE;


        return RpcStatus2;
        }
    else
        {
        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = WaitForSyncSend(this,
                &LocalSendContext,
                this,
                fDisableCancelCheck,
                Timeout
                );
            }

        if (RpcStatus != RPC_S_OK)
            {
            if ((RpcStatus == RPC_P_RECEIVE_FAILED)
                || (RpcStatus == RPC_P_CONNECTION_CLOSED)
                || (RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
                || (RpcStatus == RPC_S_SERVER_UNAVAILABLE)
                || (RpcStatus == RPC_S_PROTOCOL_ERROR) )
                RpcStatus = RPC_P_SEND_FAILED;
            }

        VALIDATE(RpcStatus)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_SEND_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_COMPLETE,
            RPC_P_TIMEOUT,
            RPC_S_SERVER_UNAVAILABLE
            } 
        END_VALIDATE;

        return RpcStatus;
        }
}

RPC_STATUS HTTP2VirtualConnection::SyncRecv (
    IN BYTE **Buffer,
    IN ULONG *BufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Do a sync receive on an HTTP connection.

Arguments:

    Buffer - if successful, points to a buffer containing the next PDU.
    BufferLength -  if successful, contains the length of the message.
    Timeout - the amount of time to wait for the receive. If -1, we wait
        infinitely.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // nobody should be calling SyncRecv on the base connection
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2VirtualConnection::Close (
    IN BOOL DontFlush
    )
/*++

Routine Description:

    Closes an HTTP connection. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

--*/
{
    Abort();
}

RPC_STATUS HTTP2VirtualConnection::TurnOnOffKeepAlives (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN BOOL IsFromUpcall,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for HTTP. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    IsFromUpcall - non-zero if called from upcall context. Zero otherwise.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we use it on the server, we must protect
        the connection against async aborts.

--*/
{
    // The server doesn't support this for Whistler. Think
    // about it for Longhorn. Client overrides it.
    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::QueryClientAddress (
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::QueryLocalAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::QueryClientId(
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is supposed to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::QueryClientIpAddress (
    IN OUT RPC_CLIENT_IP_ADDRESS *ClientIpAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    ClientIpAddress - Will contain the ip address on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2VirtualConnection::AbortChannels (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Aborts an HTTP connection but does not disconnect
    the channels. Can be called from above, upcall, or
    neutral context, but not from submit context!

Arguments:

    RpcStatus - the error to abort the channels with

Return Value:

--*/
{
    HTTP2ChannelPointer *Channels[4];
    HTTP2Channel *CurrentChannel;
    int i;

    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    // quick optimization. Don't abort already aborted channels
    // All channels are protected against double abortion - this
    // is just an optimization
    if (Aborted.GetInteger() > 0)
        return;

    Channels[0] = &InChannels[0];
    Channels[1] = &InChannels[1];
    Channels[2] = &OutChannels[0];
    Channels[3] = &OutChannels[1];

    for (i = 0; i < 4; i ++)
        {
        CurrentChannel = Channels[i]->LockChannelPointer();
        if (CurrentChannel)
            {
            CurrentChannel->Abort(RpcStatus);
            Channels[i]->UnlockChannelPointer();
            }
        }
}

BOOL HTTP2VirtualConnection::AbortAndDestroy (
    IN BOOL IsFromChannel,
    IN int CallingChannelId,
    IN RPC_STATUS AbortStatus
    )
/*++

Routine Description:

    Aborts and destroys a connection. This is safe to
    call from an upcall, as long as the calling channel
    passes in its channel id. Actually the destruction
    does not happen here. The caller has the obligation
    to destroy it after synchronizing its upcalls.

Arguments:

    IsFromChannel - non-zero if the call comes from a channel.
        Zero otherwise.

    CallingChannelId - the id of the calling channel. If IsFromChannel
        is FALSE, this argument should be ignored.

    AbortStatus - the error to abort the connection with.

Return Value:

    non-zero - caller may destroy the connection.
    FALSE - destruction is already in progress. Caller
        must not destroy the connection.

--*/
{
    if (IsFromChannel)
        {
        VerifyValidChannelId(CallingChannelId);
        }

    // abort the channels themselves
    AbortChannels(AbortStatus);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return FALSE;

    DisconnectChannels(IsFromChannel, CallingChannelId);

    // we have disconnected all but the channel on which we received
    // this call.
    return TRUE;
}

void HTTP2VirtualConnection::LastPacketSentNotification (
    IN int ChannelId,
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a channel wants to notify the virtual connection
    that the last packet has been sent, they call this function. 
    Must be called from an upcall/neutral context. Only flow control
    senders generated past packet notifications

Arguments:

    ChannelId - the channelfor which this notification is.

    LastSendContext - the send context for the last send

Return Value:

--*/
{
    ASSERT(0);
}

RPC_STATUS HTTP2VirtualConnection::PostReceiveOnChannel (
    IN HTTP2ChannelPointer *ChannelPtr,
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Posts a receceive on specified channel

Arguments:

    ChannelPtr - the channel pointer to post the receive on

    TrafficType - the type of traffic we wish to receive

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    if (ChannelPtr == NULL)
        {
        // This should never happen.
        ASSERT(0);
        return RPC_S_INTERNAL_ERROR;
        }

    Channel = ChannelPtr->LockChannelPointer();
    if (Channel)
        {
        RpcStatus = Channel->Receive(TrafficType);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        RpcStatus = RPC_P_CONNECTION_CLOSED;

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::PostReceiveOnDefaultChannel (
    IN BOOL IsInChannel,
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Posts a receceive on the default channel for the specified type

Arguments:

    IsInChannel - if non-zero, post a receive on default in channel.
        If 0, post a receive on default out channel

    TrafficType - the type of traffic we wish to receive

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    if (IsInChannel)
        Channel = LockDefaultInChannel(&ChannelPtr);
    else
        Channel = LockDefaultOutChannel(&ChannelPtr);

    if (Channel)
        {
        RpcStatus = Channel->Receive(TrafficType);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        RpcStatus = RPC_P_CONNECTION_CLOSED;

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::ForwardTrafficToChannel (
    IN HTTP2ChannelPointer *ChannelPtr,
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Forwards the given packet on the given channel

Arguments:

    ChannelPtr - the channel pointer

    Packet - the packet to forward

    PacketLength - the length of the packet to forward

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    Channel = ChannelPtr->LockChannelPointer();
    if (Channel)
        {
        RpcStatus = Channel->ForwardTraffic(Packet, PacketLength);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::ForwardTrafficToDefaultChannel (
    IN BOOL IsInChannel,
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Forwards the given packet on the given channel

Arguments:

    IsInChannel - if non-zero, forward to default in channel.
        If 0, forward to default out channel

    Packet - the packet to forward

    PacketLength - the length of the packet to forward

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    if (IsInChannel)
        Channel = LockDefaultInChannel(&ChannelPtr);
    else
        Channel = LockDefaultOutChannel(&ChannelPtr);

    if (Channel)
        {
        RpcStatus = Channel->ForwardTraffic(Packet, PacketLength);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::SendTrafficOnChannel (
    IN HTTP2ChannelPointer *ChannelPtr,
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Sends the given packet on the given channel

Arguments:

    ChannelPtr - the channel pointer on which to send.

    SendContext - context to send

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    Channel = ChannelPtr->LockChannelPointer();

    if (Channel)
        {
        RpcStatus = Channel->Send(SendContext);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::SendTrafficOnDefaultChannel (
    IN BOOL IsInChannel,
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Sends the given packet on the given channel

Arguments:

    IsInChannel - if non-zero, send on default in channel.
        If 0, send on default out channel

    SendContext - context to send

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    if (IsInChannel)
        Channel = LockDefaultInChannel(&ChannelPtr);
    else
        Channel = LockDefaultOutChannel(&ChannelPtr);

    if (Channel)
        {
        RpcStatus = Channel->Send(SendContext);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::RecycleChannel (
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    Initiates channel recycling. Each endpoint supports
    initiating recycling of only one channel, so it knows
    which one it is.
    Endpoints override that. On proxies it shouldn't be called
    at all.

Arguments:

    IsFromUpcall - non-zero if it comes from upcall. Zero otherwise.

Return Value:

    RPC_S_OK of the recycling operation started successfully.
    RPC_S_* error for errors.

--*/
{
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::StartChannelRecyclingIfNecessary (
    IN RPC_STATUS RpcStatus,
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    Checks the result of the send for channel recycle indication, and if one
    is present, initiate channel recycle

Arguments:

    RpcStatus - the return code from the Send operation.

    IsFromUpcall - non-zero if this was called from an upcall. Zero otherwise.

Return Value:

    RPC_S_* errors - the channel recycling failed to start.
    any success code will be the passed in success code turned around.
    If this function starts with a failure, the failure will be turned around

Notes:

    May be called in an upcall or runtime context only.

--*/
{
    if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        RpcStatus = RecycleChannel(IsFromUpcall);

    return RpcStatus;
}

HTTP2Channel *HTTP2VirtualConnection::MapCookieToChannelPointer (
    IN HTTP2Cookie *ChannelCookie,
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Maps a channel cookie to a channel pointer. A channel will be selected only if
    it is the default channel as well. The returned channel is locked.

Arguments:

    ChannelCookie - the cookie for the channel.

    ChannelPtr - the channel pointer. On NULL return value this is undefined.

Return Value:

    The channel if the channel was found or NULL
    if the channel was not found. During some recycling scenarios
    the channel may not be there, or the returning channel pointer
    may have a detached channel

--*/
{
    volatile int *DefaultChannelSelector;
    int TargetChannelSelector;
    HTTP2ChannelPointer *LocalChannelPtr;
    HTTP2Channel *Channel;

    if (InChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[0];
        DefaultChannelSelector = &DefaultInChannelSelector;
        TargetChannelSelector = 0;
        }
    else if (InChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[1];
        DefaultChannelSelector = &DefaultInChannelSelector;
        TargetChannelSelector = 1;
        }
    else if (OutChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[0];
        DefaultChannelSelector = &DefaultOutChannelSelector;
        TargetChannelSelector = 0;
        }
    else if (OutChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[1];
        DefaultChannelSelector = &DefaultOutChannelSelector;
        TargetChannelSelector = 1;
        }
    else 
        return NULL;

    Channel = LocalChannelPtr->LockChannelPointer();
    if (Channel)
        {
        if (*DefaultChannelSelector == TargetChannelSelector)
            {
            // if we locked the channel and it is the right channel,
            // use it
            *ChannelPtr = LocalChannelPtr;
            return Channel;
            }
        LocalChannelPtr->UnlockChannelPointer();
        }

    return NULL;
}

HTTP2Channel *HTTP2VirtualConnection::MapCookieToAnyChannelPointer (
    IN HTTP2Cookie *ChannelCookie,
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Maps a channel cookie to a channel pointer. Unlike MapCookieToChannelPointer,
    channel will be selected regardless of whether it is default.The returned 
    channel is locked.

Arguments:

    ChannelCookie - the cookie for the channel.

    ChannelPtr - the channel pointer. On NULL return value this is undefined.

Return Value:

    The channel if the channel was found or NULL
    if the channel was not found. During some recycling scenarios
    the channel may not be there, or the returning channel pointer
    may have a detached channel

--*/
{
    HTTP2ChannelPointer *LocalChannelPtr;
    HTTP2Channel *Channel;

    if (InChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[0];
        }
    else if (InChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[1];
        }
    else if (OutChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[0];
        }
    else if (OutChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[1];
        }
    else 
        return NULL;

    Channel = LocalChannelPtr->LockChannelPointer();
    if (Channel)
        {
        // if we locked the channel and it is the right channel,
        // use it
        *ChannelPtr = LocalChannelPtr;
        return Channel;
        }

    return NULL;
}

HTTP2Channel *HTTP2VirtualConnection::LockDefaultSendChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the send channel. Most connections don't override that.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultOutChannel)

--*/
{
    return LockDefaultOutChannel(ChannelPtr);
}

HTTP2Channel *HTTP2VirtualConnection::LockDefaultReceiveChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the receive channel. Most connections don't override that.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultInChannel)

--*/
{
    return LockDefaultInChannel(ChannelPtr);
}

void HTTP2VirtualConnection::SetFirstInChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the passed in channel as first default in channel.
    Typically used during building a stack.

Arguments:

    NewChannel - new in channel.

Return Value:

--*/
{
    int InChannelId;

    InChannelId = AllocateChannelId();

    DefaultInChannelSelector = 0;
    NewChannel->SetChannelId(InChannelId);
    InChannels[0].SetChannel(NewChannel);
    InChannelIds[0] = InChannelId;
}

void HTTP2VirtualConnection::SetFirstOutChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the passed in channel as first default out channel.
    Typically used during building a stack.

Arguments:

    NewChannel - new out channel.

Return Value:

--*/
{
    int OutChannelId;

    OutChannelId = AllocateChannelId();

    DefaultOutChannelSelector = 0;
    NewChannel->SetChannelId(OutChannelId);
    OutChannels[0].SetChannel(NewChannel);
    OutChannelIds[0] = OutChannelId;
}

void HTTP2VirtualConnection::SetNonDefaultInChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the non default in channel. Used during channel
    recycling. Note that this MUST be called by the code
    that received RPC_P_CHANNEL_NEEDS_RECYCLING, because
    it is not thread safe.

Arguments:

    NewChannel - new in channel.

Return Value:

--*/
{
    int InChannelId;
    int NonDefaultInChannelSelector;

    InChannelId = AllocateChannelId();
    NonDefaultInChannelSelector = GetNonDefaultInChannelSelector();

    NewChannel->SetChannelId(InChannelId);
    InChannels[NonDefaultInChannelSelector].SetChannel(NewChannel);
    InChannelIds[NonDefaultInChannelSelector] = InChannelId;
}

void HTTP2VirtualConnection::SetNonDefaultOutChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the non default out channel. Used during channel
    recycling. Note that this MUST be called by the code
    that received RPC_P_CHANNEL_NEEDS_RECYCLING, because
    it is not thread safe.

Arguments:

    NewChannel - new out channel.

Return Value:

--*/
{
    int OutChannelId;
    int NonDefaultOutChannelSelector;

    OutChannelId = AllocateChannelId();
    NonDefaultOutChannelSelector = GetNonDefaultOutChannelSelector();

    NewChannel->SetChannelId(OutChannelId);
    OutChannels[NonDefaultOutChannelSelector].SetChannel(NewChannel);
    OutChannelIds[NonDefaultOutChannelSelector] = OutChannelId;
}

void HTTP2VirtualConnection::DisconnectChannels (
    IN BOOL ExemptChannel,
    IN int ExemptChannelId
    )
/*++

Routine Description:

    Disconnects all channels. Must be called from runtime
    or neutral context. Cannot be called from upcall or
    submit context unless an exempt channel is given
    Note that call must synchronize to ensure we're the only
    thread doing the disconnect

Arguments:

    ExemptChannel - non-zero if ExemptChannelId contains a
        valid exempt channel id. FALSE otherwise.

    ExemptChannelId - if ExemptChannel is non-zero, this argument
        is the id of a channel that will be disconnected, but not
        synchronized with up calls.
        If ExampleChannel is FALSE, this argument is undefined

Return Value:

--*/
{
    HTTP2ChannelPointer *Channels[4];
    int ChannelIds[4];
    HTTP2Channel *CurrentChannel;
    int i;

    // we should be the only thread aborting - just disconnect everybody
    Channels[0] = &InChannels[0];
    ChannelIds[0] = InChannelIds[0];

    Channels[1] = &InChannels[1];
    ChannelIds[1] = InChannelIds[1];

    Channels[2] = &OutChannels[0];
    ChannelIds[2] = OutChannelIds[0];

    Channels[3] = &OutChannels[1];
    ChannelIds[3] = OutChannelIds[1];

    for (i = 0; i < 4; i ++)
        {
        if ((ExemptChannel == FALSE)
            || ((ExemptChannel != FALSE) && (ExemptChannelId != ChannelIds[i])))
            {
            // disconnect the channel
            Channels[i]->FreeChannelPointer(TRUE,
                FALSE,  // CalledFromUpcallContext
                FALSE,  // Abort
                RPC_S_OK
                );
            }
        else
            {
            Channels[i]->FreeChannelPointer(FALSE,
                FALSE,  // CalledFromUpcallContext
                FALSE,  // Abort
                RPC_S_OK
                );
            }
        }

}


/*********************************************************************
    HTTP2ClientChannel
 *********************************************************************/

const char *HeaderFragment1 = " http://";
const int HeaderFragment1Length = 8;    // length of " http://"
const char *HeaderFragment2 = "/rpc/rpcproxy.dll?";
const int HeaderFragment2Length = 18;    // length of /rpc/rpcproxy.dll?
const RPC_CHAR *HeaderFragment2W = L"/rpc/rpcproxy.dll?";
const int HeaderFragment2WLength = 36;    // length of wide /rpc/rpcproxy.dll?
const char *HeaderFragment3 = ":";
const int HeaderFragment3Length = 1;     // length of :
const RPC_CHAR *HeaderFragment3W = L":";
const int HeaderFragment3WLength = 2;     // length of wide :
const char *HeaderFragment4 = " HTTP/1.1\r\nAccept:application/rpc\r\nUser-Agent:MSRPC\r\nHost:";
const int HeaderFragment4Length = 58;    // length of " HTTP/1.1\r\nAccept:application/rpc\r\nUser-Agent:MSRPC\r\nHost:"
const char *HeaderFragment5 = "\r\nContent-Length:";
const int HeaderFragment5Length = 17;    // "\r\nlength of Content-Length:"
const char *HeaderFragment6 = "\r\nConnection: Keep-Alive\r\nCache-control:no-cache\r\nPragma:no-cache\r\n\r\n";
const int HeaderFragment6Length = 69;    // length of \r\nConnection: Keep-Alive\r\nCache-control:no-cache\r\nPragma:no-cache\r\n\r\n

const RPC_CHAR *HeaderAcceptType = L"application/rpc";

RPC_STATUS HTTP2ClientChannel::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN const char *Verb,
    IN int VerbLength,
    IN BOOL InChannel,
    IN BOOL ReplacementChannel,
    IN BOOL UseWinHttp,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,   OPTIONAL
    IN ULONG ChosenAuthScheme,      OPTIONAL
    IN HTTP2WinHttpTransportChannel *WinHttpChannel, OPTIONAL
    IN ULONG CallTimeout,
    IN const BYTE *AdditionalData, OPTIONAL
    IN ULONG AdditionalDataLength OPTIONAL
    )
/*++

Routine Description:

    Sends the HTTP establishment header on 
    the in/out channel.

Arguments:

    Hint - the resolver hint

    Verb - the verb to use.

    VerbLength - the length of the verb (in characters, not including
        null terminator).

    InChannel - non-zero if this is an in channel open. In such case we use 
        the channel lifetime as the content length. If 0, this is an out 
        channel and we use the real content length + some additional space.
        The additional space depends on the ReplacementChannel parameter

    ReplacementChannel - non-zero if this is a replacement channel. Zero 
        otherwise. If it is a replacement channel, we add the size of D4/A3.
        Else, we use the size of D1/A1. This is valid only for out channels

    UseWinHttp - non-zero if we should use WinHttp for bottom level communications

    HttpCredentials - the encrypted Http Credentials to use. Ignored unless UseWinHttp
        is non-zero.

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    WinHttpChannel - the winhttp channel to use for opening. Ignored unless UseWinHttp
        is non-zero.

    CallTimeout - the call timeout for this call.

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

    AdditionalDataLength - the length of the additional data to send with the header.
        Must be set iff AdditionalLength != NULL

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ULONG MemorySize;
    char *Buffer;
    RPC_CHAR *BufferW;
    RPC_CHAR *OriginalBufferW;
    RPC_CHAR *VerbW;
    char *Header;
    char ServerPortString[6];
    ULONG ServerPortStringLength;
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;
    char ContentLengthString[6];
    ULONG AdditionalLength;
    ULONG ContentLengthStringLength;     // without terminating NULL
    char *ContentLengthToUse;

    // we have plenty of parameters. Verify them
    // We can't have chosen auth scheme without credentials
    // or WinHttpChannel
    if (ChosenAuthScheme)
        {
        ASSERT(HttpCredentials);
        ASSERT(WinHttpChannel);
        }

    // we can't have additional data without data and vice versa
    if (AdditionalData)
        {
        ASSERT(AdditionalDataLength);
        }
    else
        {
        ASSERT(AdditionalDataLength == 0);
        }

    PortNumberToEndpointA(Hint->ServerPort, ServerPortString);
    ServerPortStringLength = RpcpStringLengthA(ServerPortString);

    // determine the content length
    if (AdditionalData)
        {
        AdditionalLength = AdditionalDataLength;
        if (!UseWinHttp)
            {
            RpcpItoa(AdditionalLength, ContentLengthString, 10);
            ContentLengthStringLength = RpcpStringLengthA(ContentLengthString);
            ContentLengthToUse = ContentLengthString;
            }
        }
    else
        {
        if (InChannel == FALSE)
            {
            if (ReplacementChannel)
                AdditionalLength = GetD4_A3TotalLength() + GetD4_A11TotalLength();
            else
                AdditionalLength = GetD1_A1TotalLength();
            if (!UseWinHttp)
                {
                RpcpItoa(AdditionalLength, ContentLengthString, 10);
                ContentLengthStringLength = RpcpStringLengthA(ContentLengthString);
                ContentLengthToUse = ContentLengthString;
                }
            }
        else
            {
            if (UseWinHttp)
                {
                AdditionalLength = DefaultChannelLifetime;
                }
            else
                {
                ContentLengthStringLength = DefaultChannelLifetimeStringLength;
                ContentLengthToUse = DefaultChannelLifetimeString;
                }
            }
        }

    if (UseWinHttp)
        {
        ASSERT(WinHttpChannel != NULL);

        VerbW = new RPC_CHAR[VerbLength + 1];
        if (VerbW == NULL)
            return RPC_S_OUT_OF_MEMORY;

        FullAnsiToUnicode((char *)Verb, VerbW);

        MemorySize = HeaderFragment2Length
            + Hint->ServerNameLength
            + HeaderFragment3Length
            + ServerPortStringLength
            + 1
            ;

        BufferW = (RPC_CHAR *)RpcAllocateBuffer(MemorySize * sizeof(RPC_CHAR));
        if (BufferW == NULL)
            {
            delete [] VerbW;
            return RPC_S_OUT_OF_MEMORY;
            }

        OriginalBufferW = BufferW;

        RpcpMemoryCopy(BufferW, HeaderFragment2W, HeaderFragment2WLength);
        BufferW += HeaderFragment2Length;

        FullAnsiToUnicode(Hint->RpcServer, BufferW);
        BufferW += Hint->ServerNameLength;

        RpcpMemoryCopy(BufferW, HeaderFragment3W, HeaderFragment3WLength);
        BufferW += HeaderFragment3Length;

        FullAnsiToUnicode(ServerPortString, BufferW);

        RpcStatus = WinHttpChannel->Open (Hint,
            VerbW,
            OriginalBufferW,    // Url
            HeaderAcceptType,
            AdditionalLength,
            CallTimeout,
            HttpCredentials,
            ChosenAuthScheme,
            AdditionalData
            );

        delete [] VerbW;
        RpcFreeBuffer(OriginalBufferW);
        }
    else
        {
        MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2SendContext)
            + VerbLength
            + HeaderFragment1Length
            + Hint->ProxyNameLength
            + HeaderFragment2Length
            + Hint->ServerNameLength
            + HeaderFragment3Length
            + ServerPortStringLength
            + HeaderFragment4Length
            + Hint->ProxyNameLength
            + HeaderFragment5Length
            + ContentLengthStringLength
            + HeaderFragment6Length
            ;

        if (AdditionalDataLength)
            MemorySize += AdditionalDataLength;

        Buffer = (char *)RpcAllocateBuffer(MemorySize);
        if (Buffer == NULL)
            return RPC_S_OUT_OF_MEMORY;

        SendContext = (HTTP2SendContext *)Buffer;
        Buffer += SIZE_OF_OBJECT_AND_PADDING(HTTP2SendContext);
        Header = Buffer;

        RpcpMemoryCopy(Buffer, Verb, VerbLength);
        Buffer += VerbLength;

        RpcpMemoryCopy(Buffer, HeaderFragment1, HeaderFragment1Length);
        Buffer += HeaderFragment1Length;

        RpcpMemoryCopy(Buffer, Hint->RpcProxy, Hint->ProxyNameLength);
        Buffer += Hint->ProxyNameLength;

        RpcpMemoryCopy(Buffer, HeaderFragment2, HeaderFragment2Length);
        Buffer += HeaderFragment2Length;

        RpcpMemoryCopy(Buffer, Hint->RpcServer, Hint->ServerNameLength);
        Buffer += Hint->ServerNameLength;

        RpcpMemoryCopy(Buffer, HeaderFragment3, HeaderFragment3Length);
        Buffer += HeaderFragment3Length;

        RpcpMemoryCopy(Buffer, ServerPortString, ServerPortStringLength);
        Buffer += ServerPortStringLength;

        RpcpMemoryCopy(Buffer, HeaderFragment4, HeaderFragment4Length);
        Buffer += HeaderFragment4Length;

        RpcpMemoryCopy(Buffer, Hint->RpcProxy, Hint->ProxyNameLength);
        Buffer += Hint->ProxyNameLength;

        RpcpMemoryCopy(Buffer, HeaderFragment5, HeaderFragment5Length);
        Buffer += HeaderFragment5Length;

        RpcpMemoryCopy(Buffer, ContentLengthToUse, ContentLengthStringLength);
        Buffer += ContentLengthStringLength;

        RpcpMemoryCopy(Buffer, HeaderFragment6, HeaderFragment6Length);

        if (AdditionalDataLength)
            {
            Buffer += HeaderFragment6Length;
            RpcpMemoryCopy(Buffer, AdditionalData, AdditionalDataLength);
            }

#if DBG
        SendContext->ListEntryUsed = FALSE;
#endif
        SendContext->maxWriteBuffer = MemorySize - SIZE_OF_OBJECT_AND_PADDING(HTTP2SendContext);
        SendContext->pWriteBuffer = (BUFFER)Header;
        SendContext->u.SyncEvent = NULL;
        SendContext->TrafficType = http2ttRaw;
        SendContext->Flags = 0;
        SendContext->UserData = 0;

        RpcStatus = BeginSubmitAsync();
        if (RpcStatus != RPC_S_OK)
            {
            RpcFreeBuffer(SendContext);
            return RpcStatus;
            }

        RpcStatus = LowerLayer->Send(SendContext);
    
        FinishSubmitAsync();

        if (RpcStatus != RPC_S_OK)
            {
            RpcFreeBuffer(SendContext);
            RemoveReference();
            }
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send

    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2VirtualConnection *VirtualConnection;

    RpcStatus = HTTP2Channel::CheckSendCompleteForSync(EventStatus,
        SendContext
        );

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        // is this our client open packet?
        if (SendContext->TrafficType == http2ttRaw)
            {
            if (EventStatus != RPC_S_OK)
                {
                VirtualConnection = (HTTP2VirtualConnection *)LockParentPointer();
                if (VirtualConnection != NULL)
                    {
                    VirtualConnection->Abort();
                    UnlockParentPointer();
                    }
                }

            RpcFreeBuffer(SendContext);

            RpcStatus = RPC_P_PACKET_CONSUMED;
            }
        else if (RpcStatus == RPC_S_OK)
            {
            // doesn't seem like our traffic. Forward it up.
            RpcStatus = ForwardUpSendComplete(EventStatus,
                SendContext
                );
            }
        else
            {
            // must be an error - just fall through
            }
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientChannel::CheckReceiveCompleteForSync (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification. Checks if the receive was
    sync, and if yes, fires event and consumes the packet.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HANDLE hEvent;

    // RTS receives are never sync even if there
    // is a sync waiter
    if (TrafficType == http2ttRTS)
        return RPC_S_OK;

    // was this a sync receive?
    if (Ol.ReceiveOverlapped.hEvent)
        {
        LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_CHECK_RECV_COMPLETE, HTTP2LOG_OT_CLIENT_CHANNEL, (ULONG_PTR)Buffer);

        // yes, consume it
        if (EventStatus == RPC_S_OK)
            {
            ASSERT(Buffer != NULL);
            }
        Ol.ReceiveOverlapped.Buffer = Buffer;
        Ol.ReceiveOverlapped.BufferLength = BufferLength;
        hEvent = Ol.ReceiveOverlapped.hEvent;
        Ol.ReceiveOverlapped.Internal = (ULONG)EventStatus;
        Ol.ReceiveOverlapped.IOCompleted = TRUE;
        SetEvent(hEvent);
        return RPC_P_PACKET_CONSUMED;
        }

    // wasn't for us after all. Let it continue
    return RPC_S_OK;
}

void HTTP2ClientChannel::WaitInfiniteForSyncReceive (
    void
    )
/*++

Routine Description:

    Waits infinitely for a sync recv to complete.
    Channel must be aborted before this is called.

Arguments:

Return Value:

--*/
{
    ASSERT(Aborted.GetInteger() > 0);

    UTIL_WaitForSyncHTTP2IO(&Ol.Overlapped,
                       Ol.ReceiveOverlapped.hEvent,
                       FALSE,   // Alertable
                       INFINITE);
}

RPC_STATUS HTTP2ClientChannel::SubmitSyncRecv (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Submits a sync recv.

Arguments:

    TrafficType - the type of traffic

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{    
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SYNC_RECV, HTTP2LOG_OT_CLIENT_CHANNEL, TrafficType);

    // transfer the settings from parameters to the receive overlapped
    Ol.ReceiveOverlapped.hEvent = I_RpcTransGetThreadEvent();
    ResetEvent(Ol.ReceiveOverlapped.hEvent);
    Ol.ReceiveOverlapped.IOCompleted = FALSE;

    // submit the actual receive
    return HTTP2Channel::Receive(TrafficType);
}

RPC_STATUS HTTP2ClientChannel::WaitForSyncRecv (
    IN BYTE **Buffer,
    IN ULONG *BufferLength,
    IN ULONG Timeout,
    IN ULONG ConnectionTimeout,
    IN BASE_ASYNC_OBJECT *Connection,
    OUT BOOL *AbortNeeded,
    OUT BOOL *IoPending
    )
/*++

Routine Description:

    Waits for a sync receive to complete.

Arguments:

    Buffer - on success will contain the received buffer. On failure
        is undefined.

    BufferLength - on success will contain the length of the buffer.
        On failure is undefined.

    Timeout - the call timeout

    ConnectionTimeout - the connection timeout

    Connection - the transport connection object

    AbortNeeded - must be FALSE on entry. This function will set it to
        non-zero if abort and wait are needed.

    WaitPending - must be FALSE on entry. If on return there is an Io
        pending, it will be set to non-zero

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{    
    RPC_STATUS RpcStatus;
    DWORD dwActualTimeout;
    BOOL fWaitOnConnectionTimeout;
    BOOL fSetKeepAliveVals;
    KEEPALIVE_TIMEOUT KATimeout;
    RPC_STATUS RpcStatus2;

    ASSERT(*AbortNeeded == FALSE);
    ASSERT(*IoPending == FALSE);

    // if there's a per operation timeout, use the lesser of the operation
    // and connection timeout
    ASSERT(ConnectionTimeout);

    if (Timeout != INFINITE)
        {
        if (Timeout <= ConnectionTimeout)
            {
            dwActualTimeout = Timeout;
            fWaitOnConnectionTimeout = FALSE;
            }
        else
            {
            dwActualTimeout = ConnectionTimeout;
            fWaitOnConnectionTimeout = TRUE;
            }
        }
    else
        {
        // wait on the connection timeout
        dwActualTimeout = ConnectionTimeout;
        fWaitOnConnectionTimeout = TRUE;
        }

    fSetKeepAliveVals = FALSE;

    do
        {

        //
        // Wait for the pending receive to complete
        //

        RpcStatus = UTIL_GetOverlappedHTTP2ResultEx(Connection,
                                            &Ol.Overlapped,
                                            Ol.ReceiveOverlapped.hEvent,
                                            TRUE, // Alertable
                                            dwActualTimeout);


        if (RpcStatus != RPC_S_OK)
            {
            // if we timed out ...
            if (RpcStatus == RPC_P_TIMEOUT)
                {
                ASSERT(dwActualTimeout != INFINITE);

                // if we waited on the per connection timeout ...
                if (fWaitOnConnectionTimeout)
                    {
                    ASSERT(ConnectionTimeout != INFINITE);
                    if (Timeout == INFINITE)
                        {
                        // enable keep alives and wait forever
                        dwActualTimeout = INFINITE;
                        }
                    else
                        {
                        ASSERT(ConnectionTimeout < Timeout);

                        // enable keep alives and wait the difference
                        dwActualTimeout = Timeout - ConnectionTimeout;
                        fWaitOnConnectionTimeout = FALSE;
                        }
                    // Enable aggressive keepalives on the socket if lower layers
                    // support it. 
                    KATimeout.Milliseconds = ConnectionTimeout;
                    RpcStatus2 = SetKeepAliveTimeout (
                        TRUE,       // TurnOn
                        FALSE,      // bProtectIO
                        tuMilliseconds,
                        KATimeout,
                        KATimeout.Milliseconds
                        ); 

                    if (RpcStatus2 != RPC_S_OK)
                        {
                        *AbortNeeded = TRUE;
                        *IoPending = TRUE;
                        goto CleanupAndExit;
                        }

                    fSetKeepAliveVals = TRUE;

                    continue;
                    }
                // else we have chosen the per operation timeout and
                // have timed out on that - time to bail out
                }

            // Normal error path
            if ((RpcStatus == RPC_S_CALL_CANCELLED) || (RpcStatus == RPC_P_TIMEOUT))
                {
                if ((RpcStatus == RPC_P_TIMEOUT) && fWaitOnConnectionTimeout)
                    {
                    RpcStatus = RPC_P_RECEIVE_FAILED;
                    }
                *AbortNeeded = TRUE;
                *IoPending = TRUE;
                goto CleanupAndExit;
                }

            *AbortNeeded = TRUE;
            // connection was aborted - no need to turn off keep alives
            goto CleanupAndExit;
            }
        }
    while (RpcStatus == RPC_P_TIMEOUT);

    if (fSetKeepAliveVals)
        {
        // Call completed, clear keep alives. Turning off is a best
        // effort. Ignore failures
        KATimeout.Milliseconds = 0;
        (void) SetKeepAliveTimeout(
            FALSE,      // TurnOn
            FALSE,      // bProtectIO
            tuMilliseconds,
            KATimeout,
            KATimeout.Milliseconds
            );
        }

    *Buffer = Ol.ReceiveOverlapped.Buffer;
    *BufferLength = Ol.ReceiveOverlapped.BufferLength;

    if (RpcStatus == RPC_S_OK)
        {
        ASSERT(*Buffer != NULL);
        }

CleanupAndExit:
    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SYNC_RECV, HTTP2LOG_OT_CLIENT_CHANNEL, RpcStatus);

    if (*IoPending == FALSE)
        {
        // consume the event if there will be no wait
        Ol.ReceiveOverlapped.hEvent = NULL;
        }
    return RpcStatus;
}

void HTTP2ClientChannel::AbortConnection (
    IN RPC_STATUS AbortReason
    )
/*++

Routine Description:

    Aborts the client virtual connection. The only
    difference from HTTP2Channel::AbortConnection
    is that it specifically calls AbortChannels on
    the client virtual connection. This is necessary
    because AbortChannels is not virtual.

Arguments:

    RpcStatus - the error to abort with

Return Value:

--*/
{
    HTTP2ClientVirtualConnection *VirtualConnection;

    // abort the parent connection
    VirtualConnection = (HTTP2ClientVirtualConnection *)LockParentPointer();
    if (VirtualConnection)
        {
        VirtualConnection->AbortChannels(AbortReason);
        UnlockParentPointer();
        }
    else
        {
        // abort this channel at least
        Abort(AbortReason);
        }
}

/*********************************************************************
    HTTP2ClientInChannel
 *********************************************************************/

RPC_STATUS HTTP2ClientInChannel::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN const char *Verb,
    IN int VerbLength,
    IN BOOL UseWinHttp,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,
    IN ULONG ChosenAuthScheme,
    IN ULONG CallTimeout,
    IN const BYTE *AdditionalData, OPTIONAL
    IN ULONG AdditionalDataLength OPTIONAL
    )
/*++

Routine Description:

    Sends the HTTP establishment header on 
    the in channel.

Arguments:

    Hint - the resolver hint

    Verb - the verb to use.

    VerbLength - the length of the verb (in characters, not including
        null terminator).

    UseWinHttp - non-zero if WinHttp needs to be used. 0 otherwise

    HttpCredentials - encrypted transport credentials

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    CallTimeout - the call timeout for this call

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

    AdditionalDataLength - the length of the additional data to send with the header.
        Must be set iff AdditionalLength != NULL

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    return HTTP2ClientChannel::ClientOpen(Hint,
        Verb,
        VerbLength,
        TRUE,    // InChannel
        FALSE,    // ReplacementChannel
        UseWinHttp,
        HttpCredentials,
        ChosenAuthScheme,
        GetWinHttpConnection(),
        CallTimeout,
        AdditionalData,
        AdditionalDataLength
        );
}

RPC_STATUS HTTP2ClientInChannel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error.
    May return RPC_P_CHANNEL_NEEDS_RECYCLING - caller needs to handle.

--*/
{
    HTTP2SendContext *KeepAliveChangeContext;
    RPC_STATUS RpcStatus;
    BOOL WasChannelRecyclingTriggered;

    ASSERT(Units == tuMilliseconds);

    // HTTP keep alives are heavy weight. Moderate the caller's
    // settings
    if (TurnOn)
        {
        if (KAInterval < MinimumClientSideKeepAliveInterval)
            KAInterval = MinimumClientSideKeepAliveInterval;
        }
    else
        {
        KAInterval = 0;
        }

    // tell the proxy to change it's keepalives and then
    // ask our ping originator to change its keepalives as well
    KeepAliveChangeContext = AllocateAndInitializeKeepAliveChangePacket (KAInterval);
    if (KeepAliveChangeContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = Send(KeepAliveChangeContext);

    WasChannelRecyclingTriggered = FALSE;
    if (RpcStatus != RPC_S_OK)
        {
        if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
            WasChannelRecyclingTriggered = TRUE;
        else
            {
            FreeRTSPacket(KeepAliveChangeContext);
            return RpcStatus;
            }
        }

    // get into submission context
    RpcStatus = BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    // ask our ping channel to change as well
    RpcStatus = GetPingOriginatorChannel()->SetKeepAliveTimeout (
        TurnOn,
        bProtectIO,
        Units,
        KATime,
        KAInterval
        );

    FinishSubmitAsync();

    // if we failed for other reasons or channel recycling was not triggered
    // at all, return the current status
    if ((WasChannelRecyclingTriggered == FALSE) || (RpcStatus != RPC_S_OK))
        return RpcStatus;
    else
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
}

/*********************************************************************
    HTTP2ClientOutChannel
 *********************************************************************/

RPC_STATUS HTTP2ClientOutChannel::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN const char *Verb,
    IN int VerbLength,
    IN BOOL ReplacementChannel,
    IN BOOL UseWinHttp,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,
    IN ULONG ChosenAuthScheme,
    IN ULONG CallTimeout,
    IN const BYTE *AdditionalData, OPTIONAL
    IN ULONG AdditionalDataLength OPTIONAL
    )
/*++

Routine Description:

    Sends the HTTP establishment header on 
    the out channel.

Arguments:

    Hint - the resolver hint

    Verb - the verb to use.

    VerbLength - the length of the verb (in characters, not including
        null terminator).

    ReplacementChannel - non-zero if this is a replacement channel.
        Zero if it is not.

    UseWinHttp - non-zero if WinHttp needs to be used. 0 otherwise

    HttpCredentials - encrypted transport credentials

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    CallTimeout - the call timeout for this call.

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

    AdditionalDataLength - the length of the additional data to send with the header.
        Must be set iff AdditionalLength != NULL

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    return HTTP2ClientChannel::ClientOpen(Hint,
        Verb,
        VerbLength,
        FALSE,       // InChannel
        ReplacementChannel,
        UseWinHttp,
        HttpCredentials,
        ChosenAuthScheme,
        GetWinHttpConnection(),
        CallTimeout,
        AdditionalData,
        AdditionalDataLength
        );
}

RPC_STATUS HTTP2ClientOutChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack to the out proxy through the in proxy

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

Notes:

    Must be called from neutral context only.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ForwardFlowControlAckOnDefaultChannel(TRUE,    // IsInChannel
        fdOutProxy,
        BytesReceivedForAck,
        WindowForAck
        );

    RpcStatus = HandleSendResultFromNeutralContext(RpcStatus);

    return RpcStatus;
}

RPC_STATUS HTTP2ClientOutChannel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    HTTP2ClientVirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    // turn around the request through the connection
    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        return RPC_P_CONNECTION_SHUTDOWN;

    RpcStatus = VirtualConnection->TurnOnOffKeepAlives(
        TurnOn,
        bProtectIO,
        TRUE,   // IsFromUpcall
        Units,
        KATime,
        KAInterval
        );

    UnlockParentPointer();

    return RpcStatus;
}

/*********************************************************************
    HTTP2ClientVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2ClientVirtualConnection::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN UINT ConnTimeout,
    IN ULONG CallTimeout
    )
/*++

Routine Description:

    Opens a client side virtual connection.

Arguments:

    Hint - the resolver hint

    HintWasInitialized - the hint was initialized on input.

    ConnTimeout - connection timeout

    CallTimeout - operation timeout

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return ClientOpenInternal (
        Hint,
        HintWasInitialized,
        ConnTimeout,
        CallTimeout,
        TRUE,       // OpenInChannel
        TRUE,       // OpenOutChannel
        FALSE,      // IsReplacementChannel
        FALSE       // IsFromUpcall
        );
}

RPC_STATUS HTTP2ClientVirtualConnection::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate send complete.

Arguments:

    EventStatus - status of the operation

    SendContext - the context for the send complete

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    HTTP2TrafficType TrafficType;
    
    VerifyValidChannelId(ChannelId);

    if (EventStatus == RPC_S_OK)
        {
        // successful sends are always no-ops on the
        // client. Just cleanup if necessary and
        // return
        if (SendContext->TrafficType == http2ttRTS)
            {
            FreeSendContextAndPossiblyData(SendContext);
            return RPC_P_PACKET_CONSUMED;
            }
        else
            return RPC_S_OK;
        }

    // we know the send failed
    if (IsDefaultInChannel(ChannelId) || IsDefaultOutChannel(ChannelId))
        {
        // on a default channel such error is fatal
        AbortChannels(EventStatus);

        if (SendContext->TrafficType == http2ttRTS)
            {
            FreeSendContextAndPossiblyData(SendContext);
            return RPC_P_PACKET_CONSUMED;
            }

        ASSERT(SendContext->TrafficType == http2ttData);

        return EventStatus;
        }
    else
        {
        // all data sends go on default channels. RTS sends
        // may go either way. If this is RTS, this is fatal.
        // Otherwise, ignore.
        if (SendContext->TrafficType == http2ttRTS)
            {
            FreeSendContextAndPossiblyData(SendContext);
            AbortChannels(EventStatus);
            return RPC_P_PACKET_CONSUMED;
            }
        else
            return RPC_S_OK;
        }
}

RPC_STATUS HTTP2ClientVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error
    Buffer - buffer received
    BufferLength - length of buffer received
    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_P_ABORT_NEEDED - if the channel needs to be aborted but
        couldn't be aborted in this function because it was detached.
        After aborting, the semantics is same as RPC_P_PACKET_CONSUMED.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    RPC_STATUS RpcStatus;
    ULONG ProxyConnectionTimeout;
    BOOL BufferFreed = FALSE;
    BOOL WakeOpenThread;
    HTTP2ClientInChannel *InChannel;
    HTTP2ClientOutChannel *OutChannel;
    HTTP2ClientOutChannel *OutChannel2;
    HTTP2ClientInChannel *NewInChannel;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *NewChannelPtr;
    LIST_ENTRY NewBufferHead;
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *PrevListEntry;
    HTTP2SendContext *QueuedSendContext;
    BOOL MutexReleased;
    HTTP2SendContext *A5Context;    // may be D2/A5 or D3/A5
    HTTP2SendContext *D4_A7Context;
    HTTP2SendContext *PingContext;
    BOOL IsD2_A4;
    HTTP2ClientOpenedPacketType ClientPacketType;
    BOOL DataReceivePosted;
    HTTP2StateValues NewState;
    HTTP2StateValues ExpectedState;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2Cookie CookieForChannel;
    ULONG InProxyReceiveWindow;
    BOOL UseWinHttp;
    KEEPALIVE_TIMEOUT KATimeout;

    VerifyValidChannelId(ChannelId);

    if (
        (InChannelState.State == http2svSearchProxy) 
        && 
        (
         (EventStatus != RPC_S_OK) 
         || 
         IsEchoPacket(Buffer, BufferLength)
        )
       )
        {
        InChannelState.Mutex.Request();
        if (InChannelState.State == http2svSearchProxy)
            {
            InChannelState.Mutex.Clear();

            if (IsInChannel(ChannelId))
                {
                InOpenStatus = EventStatus;
                }
            else
                {
                OutOpenStatus = EventStatus;
                }

            // we won the race. Wake up the open thread
            WakeOpenThread = TRUE;

            RpcStatus = RPC_P_PACKET_CONSUMED;

            goto CleanupAndExit;
            }

        InChannelState.Mutex.Clear();
        }

    WakeOpenThread = FALSE;
    if (IsInChannel(ChannelId))
        {
        if (EventStatus != RPC_P_AUTH_NEEDED)
            {
            // we shouldn't really be receiving stuff on the in channel
            // unless there is an error
            if (EventStatus != RPC_S_OK)
                {
                if (IsDefaultInChannel(ChannelId) == FALSE)
                    {
                    InChannelState.Mutex.Request();
                    if (InChannelState.State == http2svOpened)
                        {
                        // close on the non-default channel in open
                        // state is not an error for the connection
                        // just abort the channel in question
                        InChannelState.Mutex.Clear();
                        ChannelPtr = GetChannelPointerFromId(ChannelId);
                        InChannel = (HTTP2ClientInChannel *)ChannelPtr->LockChannelPointer();
                        if (InChannel)
                            {
                            InChannel->Abort(EventStatus);
                            ChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_P_PACKET_CONSUMED;
                            }
                        else
                            RpcStatus = RPC_P_ABORT_NEEDED;

                        BufferFreed = TRUE;
                        return RpcStatus;
                        }
                    else
                        InChannelState.Mutex.Clear();
                    }
                RpcStatus = EventStatus;
                // in failed receives, we don't own the buffer
                BufferFreed = TRUE;
                }
            else
                {
                if (IsEchoPacket(Buffer, BufferLength))
                    {
                    InOpenStatus = EventStatus;
                    WakeOpenThread = TRUE;
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                }

            AbortChannels(RpcStatus);
            }
        else
            {
            // turn around the error code and fall through
            RpcStatus = EventStatus;
            }

        // the runtime never posted a receive on the in
        // channel. Don't let it see the packet
        InOpenStatus = RpcStatus;
        WakeOpenThread = TRUE;
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }
    else
        {
        // this is an out channel
        if (EventStatus != RPC_S_OK)
            {
            if (EventStatus != RPC_P_AUTH_NEEDED)
                {
                AbortChannels(EventStatus);
                RpcStatus = EventStatus;

                if (RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
                    RpcStatus = RPC_P_RECEIVE_FAILED;

                OutOpenStatus = RpcStatus;
                }
            else
                {
                OutOpenStatus = EventStatus;

                RpcStatus = RPC_P_RECEIVE_FAILED;
                }

            WakeOpenThread = TRUE;

            // in failed receives we don't own the buffer
            BufferFreed = TRUE;
            }
        else
            {
            // verify state and act upon it if RTS
            // for data we don't care
            if (IsRTSPacket(Buffer))
                {
                if (IsOtherCmdPacket(Buffer, BufferLength))
                    {
                    // the only cmd packet we expect is flow control ack
                    // try to interpret it as such
                    RpcStatus = ParseAndFreeFlowControlAckPacketWithDestination (
                        Buffer,
                        BufferLength,
                        fdClient,
                        &BytesReceivedForAck,
                        &WindowForAck,
                        &CookieForChannel
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_OK)
                        {
                        // notify the flow control sender about the ack
                        InChannel = (HTTP2ClientInChannel *)MapCookieToChannelPointer(
                            &CookieForChannel, 
                            &ChannelPtr
                            );

                        if (InChannel && !IsInChannel(ChannelPtr))
                            {
                            CORRUPTION_ASSERT(0);
                            ChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            InChannel = NULL;
                            // fall through with the error
                            }

                        if (InChannel)
                            {
                            RpcStatus = InChannel->FlowControlAckNotify(BytesReceivedForAck,
                                WindowForAck
                                );
                            ChannelPtr->UnlockChannelPointer();

                            RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                                TRUE        // IsFromUpcall
                                );
                            }

                        if (RpcStatus == RPC_S_OK)
                            {
                            // post another receive
                            RpcStatus = PostReceiveOnChannel (GetChannelPointerFromId(ChannelId),
                                http2ttRTS
                                );
                            }
                        }

                    if (RpcStatus != RPC_S_OK)
                        {
                        AbortChannels(RpcStatus);

                        OutOpenStatus = RpcStatus;
                        WakeOpenThread = TRUE;
                        }

                    // This is an RTS packet - consume it
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }
                else if (IsEchoPacket(Buffer, BufferLength))
                    {
                    OutOpenStatus = EventStatus;
                    WakeOpenThread = TRUE;
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }

                RpcStatus = HTTPTransInfo->CreateThread();

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);

                    // This is an RTS packet - consume it
                    RpcFreeBuffer(Buffer);
                    BufferFreed = TRUE;
                    OutOpenStatus = RpcStatus;
                    WakeOpenThread = TRUE;
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }

                MutexReleased = FALSE;
                InChannelState.Mutex.Request();
                switch (InChannelState.State)
                    {
                    case http2svA3W:
                        RpcStatus = ParseAndFreeD1_A3(Buffer,
                            BufferLength,
                            &ProxyConnectionTimeout
                            );

                        // we don't really do anything with the ProxyConnectionTimeout - it's
                        // for debugging purposes only

                        BufferFreed = TRUE;

                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = PostReceiveOnChannel(&OutChannels[0], http2ttRTS);
                            if (RpcStatus == RPC_S_OK)
                                {
                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svC2W, 1, 0);
                                InChannelState.State = http2svC2W;
                                }
                            else
                                {
                                OutOpenStatus = RpcStatus;
                                AbortChannels(RpcStatus);
                                WakeOpenThread = TRUE;
                                }
                            RpcStatus = RPC_P_PACKET_CONSUMED;
                            }
                        break;

                    case http2svC2W:
                        RpcStatus = ParseAndFreeD1_C2(Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &InProxyReceiveWindow,
                            &InProxyConnectionTimeout
                            );

                        BufferFreed = TRUE;

                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = PostReceiveOnChannel(&OutChannels[0], http2ttRTS);
                            if (RpcStatus == RPC_S_OK)
                                {
                                // Set the in proxy timeout to the channel
                                InChannel = LockDefaultInChannel(&ChannelPtr);
                                if (InChannel != NULL)
                                    {
                                    InChannel->SetPeerReceiveWindow(InProxyReceiveWindow);
                                    RpcStatus = InChannel->SetConnectionTimeout(InProxyConnectionTimeout);
                                    ChannelPtr->UnlockChannelPointer();
                                    }
                                else
                                    RpcStatus = RPC_P_CONNECTION_CLOSED;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    OutOpenStatus = RpcStatus;
                                    WakeOpenThread = TRUE;
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                                InChannelState.State = http2svOpened;

                                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                                OutChannelState.State = http2svOpened;

                                InOpenStatus = OutOpenStatus = RPC_S_OK;
                                SetClientOpenInEvent();

                                RpcStatus = RPC_P_PACKET_CONSUMED;
                                }
                            }
                        break;

                    default:
                        // all the opened states are handled here
                        ASSERT((InChannelState.State == http2svOpened)
                            || (InChannelState.State == http2svOpened_A4W) );
                        ASSERT((OutChannelState.State == http2svOpened)
                            || (OutChannelState.State == http2svOpened_A6W)
                            || (OutChannelState.State == http2svOpened_A10W) 
                            || (OutChannelState.State == http2svOpened_B3W) );

                        RpcStatus = GetClientOpenedPacketType (Buffer,
                            BufferLength,
                            &ClientPacketType
                            );

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RpcStatus);
                            RpcStatus = RPC_P_PACKET_CONSUMED;
                            break;
                            }

                        switch (ClientPacketType)
                            {
                            case http2coptD2_A4:
                            case http2coptD3_A4:
                                // in channel must be in Opened_A4W
                                // out channel can be in any state
                                CORRUPTION_ASSERT(InChannelState.State == http2svOpened_A4W);
                                if (InChannelState.State != http2svOpened_A4W)
                                    {
                                    InChannelState.Mutex.Clear();
                                    MutexReleased = TRUE;
                                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                InChannelState.Mutex.Clear();
                                MutexReleased = TRUE;

                                IsD2_A4 = IsD2_A4OrD3_A4(Buffer,
                                    BufferLength
                                    );

                                if (IsD2_A4)
                                    {
                                    RpcStatus = ParseAndFreeD2_A4(Buffer,
                                        BufferLength,
                                        fdClient,
                                        &ProtocolVersion,
                                        &InProxyReceiveWindow,
                                        &InProxyConnectionTimeout
                                        );
                                    }
                                else
                                    {
                                    // This must be a D3/A4
                                    RpcStatus = ParseAndFreeD3_A4 (Buffer,
                                        BufferLength
                                        );
                                    }

                                BufferFreed = TRUE;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = PostReceiveOnChannel(&OutChannels[DefaultOutChannelSelector], 
                                    http2ttRTS);
                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // lock the old channel
                                InChannel = LockDefaultInChannel(&ChannelPtr);
                                if (InChannel == NULL)
                                    {
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                if (IsD2_A4 == FALSE)
                                    {
                                    // capture the receive window from the old channel.
                                    // We know the proxy is the same so the window must be
                                    // the same as well
                                    InProxyReceiveWindow = InChannel->GetPeerReceiveWindow();
                                    }

                                // switch channels (new channel is still plugged)
                                SwitchDefaultInChannelSelector();

                                // wait for everybody that is in the process of using 
                                // the old channel to get out
                                InChannel->DrainPendingSubmissions();

                                // leave 1 for our lock
                                ChannelPtr->DrainPendingLocks(1);

                                // lock new channel (by now it is default)
                                NewInChannel = LockDefaultInChannel(&NewChannelPtr);
                                if (NewInChannel == NULL)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                NewInChannel->SetPeerReceiveWindow(InProxyReceiveWindow);

                                // Set the in proxy timeout to the new channel
                                RpcStatus = NewInChannel->SetConnectionTimeout(InProxyConnectionTimeout);

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    NewChannelPtr->UnlockChannelPointer();
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // if old flow control channel was queuing, grab all its buffers
                                // We must do this before the channel data originator to make sure
                                // the buffers end up behind the ones from the channel data
                                // originator
                                RpcpInitializeListHead(&NewBufferHead);
                                InChannel->GetFlowControlSenderBufferQueue(&NewBufferHead);

                                AddBufferQueueToChannel(&NewBufferHead, NewInChannel);

                                // GetChannelOriginatorBufferQueue can be called in submission
                                // context only. Get into submission context
                                RpcStatus = InChannel->BeginSimpleSubmitAsync();
                                if (RpcStatus != RPC_S_OK)
                                    {
                                    NewChannelPtr->UnlockChannelPointer();
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // if old channel channel data originator was queuing, grab all its buffers
                                RpcpInitializeListHead(&NewBufferHead);
                                InChannel->GetChannelOriginatorBufferQueue(&NewBufferHead);

                                InChannel->FinishSubmitAsync();

                                AddBufferQueueToChannel(&NewBufferHead, NewInChannel);

                                InChannelState.Mutex.Request();
                                // move channel state to opened
                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                                InChannelState.State = http2svOpened;
                                InChannelState.Mutex.Clear();

                                if (IsD2_A4)
                                    {
                                    // register the last packet to send with the old channel
                                    A5Context = AllocateAndInitializeD2_A5 (
                                        &InChannelCookies[DefaultInChannelSelector]
                                        );
                                    }
                                else
                                    {
                                    A5Context = AllocateAndInitializeD3_A5 (
                                        &InChannelCookies[DefaultInChannelSelector]
                                        );
                                    }

                                if (A5Context == NULL)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    NewChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // make sure the packet is sent last
                                RpcStatus = InChannel->Send(A5Context);

                                if (RpcStatus == RPC_S_OK)
                                    {
                                    UseWinHttp = ShouldUseWinHttp(HttpCredentials);
                                    if (UseWinHttp)
                                        {
                                        InChannel->DisablePings();
                                        RpcStatus = InChannel->Receive(http2ttRaw);
                                        }
                                    }
                                else
                                    {
                                    FreeRTSPacket(A5Context);
                                    }

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    NewChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // D2_A5 was sent. We must switch the
                                // default loopback and detach the channel.
                                // Note that we don't abort the channel - we
                                // just release the lifetime reference
                                // When the proxy closes the connection, then
                                // we will abort.
                                SwitchDefaultLoopbackChannelSelector();
                                ChannelPtr->UnlockChannelPointer();
                                ChannelPtr->FreeChannelPointer(
                                    TRUE,    // DrainUpcalls
                                    FALSE,   // CalledFromUpcallContext
                                    FALSE,   // Abort
                                    RPC_S_OK
                                    );

                                RpcStatus = NewInChannel->Unplug();
                                if (RpcStatus != RPC_S_OK)
                                    {
                                    NewChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                NewChannelPtr->UnlockChannelPointer();

                                RpcStatus = RPC_P_PACKET_CONSUMED;

                                break;

                            case http2coptD4_A2:
                                // in channel can be in any opened state
                                // out channel must be in http2svOpened
                                CORRUPTION_ASSERT(OutChannelState.State == http2svOpened);

                                if (OutChannelState.State != http2svOpened)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }
                                InChannelState.Mutex.Clear();
                                MutexReleased = TRUE;

                                RpcStatus = ParseAndFreeD4_A2(Buffer,
                                    BufferLength
                                    );

                                BufferFreed = TRUE;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = OpenReplacementOutChannel();

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = PostReceiveOnDefaultChannel(FALSE,  // IsInChannel
                                    http2ttRTS);
                                if (RpcStatus != RPC_S_OK)
                                    AbortChannels(RpcStatus);

                                RpcStatus = RPC_P_PACKET_CONSUMED;

                                break;

                            case http2coptD4_A6:
                            case http2coptD5_A6:
                                // in channel can be in any opened state
                                // out channel must be in http2svOpened_A6W
                                CORRUPTION_ASSERT(OutChannelState.State == http2svOpened_A6W);

                                if (OutChannelState.State != http2svOpened_A6W)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                if (ClientPacketType == http2coptD4_A6)
                                    NewState = http2svOpened_A10W;
                                else
                                    NewState = http2svOpened_B3W;

                                // move channel state to new state
                                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, NewState, 1, 0);
                                OutChannelState.State = NewState;

                                InChannelState.Mutex.Clear();
                                MutexReleased = TRUE;

                                if (ClientPacketType == http2coptD4_A6)
                                    {
                                    RpcStatus = ParseAndFreeD4_A6 (Buffer,
                                        BufferLength,
                                        fdClient,
                                        &ProtocolVersion,
                                        &ProxyConnectionTimeout
                                        );

                                    // we don't really do anything with ProxyConnectionTimeout. That's
                                    // ok. It's there mostly for debugging.
                                    }
                                else
                                    {
                                    RpcStatus = ParseAndFreeD5_A6 (Buffer,
                                        BufferLength,
                                        fdClient
                                        );
                                    }

                                BufferFreed = TRUE;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                if (ClientPacketType == http2coptD5_A6)
                                    {
                                    // in the D5 case, we won't send A11. Since
                                    // some proxies are picky about sending all
                                    // the declared data before allowing receiving
                                    // data to come in, we need to send an empty packet
                                    // of the necessary size to keep the proxy happy.
                                    PingContext = AllocateAndInitializePingPacketWithSize (
                                        GetD4_A11TotalLength()
                                        );

                                    if (PingContext == NULL)
                                        {
                                        AbortChannels(RPC_S_OUT_OF_MEMORY);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    RpcStatus = SendTrafficOnChannel(
                                        &OutChannels[GetNonDefaultOutChannelSelector()],
                                        PingContext
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        FreeRTSPacket(PingContext);
                                        AbortChannels(RpcStatus);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }
                                    }

                                D4_A7Context = AllocateAndInitializeD4_A7 (
                                    fdServer,
                                    &OutChannelCookies[GetNonDefaultOutChannelSelector()],
                                    ProtocolVersion
                                    );

                                if (D4_A7Context == NULL)
                                    {
                                    AbortChannels(RPC_S_OUT_OF_MEMORY);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = SendTrafficOnDefaultChannel(TRUE,   //IsInChannel
                                    D4_A7Context
                                    );

                                RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                                    TRUE        // IsFromUpcall
                                    );

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    FreeRTSPacket(D4_A7Context);
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = PostReceiveOnDefaultChannel (FALSE,     // IsInChannel
                                    http2ttRTS);

                                if (RpcStatus != RPC_S_OK)
                                    AbortChannels(RpcStatus);

                                RpcStatus = RPC_P_PACKET_CONSUMED;

                                break;

                            case http2coptD4_A10:
                            case http2coptD5_B3:
                                // in channel can be in any opened state
                                if (ClientPacketType == http2coptD4_A10)
                                    {
                                    // out channel must be in http2svOpened_A10W
                                    ASSERT(OutChannelState.State == http2svOpened_A10W);

                                    if (OutChannelState.State != http2svOpened_A10W)
                                        {
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    InChannelState.Mutex.Clear();
                                    MutexReleased = TRUE;

                                    RpcStatus = ParseD4_A10 (Buffer,
                                        BufferLength
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        AbortChannels(RpcStatus);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }
                                    }
                                else
                                    {
                                    // out channel must be in http2svOpened_B3W
                                    CORRUPTION_ASSERT(OutChannelState.State == http2svOpened_B3W);

                                    if (OutChannelState.State != http2svOpened_B3W)
                                        {
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    InChannelState.Mutex.Clear();
                                    MutexReleased = TRUE;

                                    RpcStatus = ParseAndFreeD5_B3 (Buffer,
                                        BufferLength
                                        );

                                    BufferFreed = TRUE;

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        AbortChannels(RpcStatus);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }
                                    }

                                ChannelPtr = GetChannelPointerFromId(ChannelId);
                                OutChannel = (HTTP2ClientOutChannel *)ChannelPtr->LockChannelPointer();
                                if (OutChannel == NULL)
                                    {
                                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                NewChannelPtr = &OutChannels[GetNonDefaultOutChannelSelector()];
                                OutChannel2 = (HTTP2ClientOutChannel *)NewChannelPtr->LockChannelPointer ();
                                if (OutChannel2 == NULL)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                OutChannel2->BlockDataReceives();

                                // we're done with this channel. We want to switch
                                // channels and destroy
                                // and detach the channel.
                                // In the D5 case we can't switch earlier, because we
                                // have a race condition where folks may receive data
                                // on the new channel before they have drained the old,
                                // which may result in out-of-order delivery. Since
                                // data receives are blocked here, switching and draining
                                // is atomical in respect to the new channel
                                SwitchDefaultOutChannelSelector();

                                // make sure everybody who was submitting is out
                                OutChannel->DrainPendingSubmissions();

                                // 1 is for the lock that we have
                                ChannelPtr->DrainPendingLocks(1);

                                RpcStatus = OutChannel->TransferReceiveStateToNewChannel(OutChannel2);

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    OutChannel2->UnblockDataReceives();
                                    NewChannelPtr->UnlockChannelPointer();

                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // if there is recv pending, but it is not an sync recv,
                                // make a note of that - we will resubmit it later. If it is
                                // sync, we will use the ReissueRecv mechanism to transfer
                                // the recv to the new channel
                                DataReceivePosted = FALSE;
                                if (OutChannel->IsDataReceivePosted())
                                    {
                                    if (OutChannel->IsSyncRecvPending())
                                        {
                                        // before we destroy, tell any pending recv to re-issue
                                        // itself upon failure.
                                        ReissueRecv = TRUE;
                                        }
                                    else
                                        {
                                        DataReceivePosted = TRUE;
                                        }
                                    }

                                ChannelPtr->UnlockChannelPointer();


                                if (ClientPacketType == http2coptD4_A10)
                                    {
                                    // after having transfered the receive settings,
                                    // we can send D4/A11 to open the pipeline
                                    RpcStatus = ForwardTrafficToDefaultChannel(FALSE,    // IsInChannel
                                        Buffer,
                                        BufferLength
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        NewChannelPtr->UnlockChannelPointer();
                                        OutChannel2->UnblockDataReceives();
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    // we no longer own the buffer
                                    BufferFreed = TRUE;
                                    }

                                // we couldn't unblock receives earlier because new receives
                                // must be synchronized w.r.t. D4/A11 - we can't post
                                // real receives before D4/A11 because it will switch WinHttp
                                // into receiveing mode. We also can't send D4/A11 before we
                                // have transferred the settings
                                OutChannel2->UnblockDataReceives();
                                NewChannelPtr->UnlockChannelPointer();

                                RpcStatus = PostReceiveOnDefaultChannel (FALSE,     // IsInChannel
                                    http2ttRTS);

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // detach, abort and free lifetime reference
                                ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                                    TRUE,   // CalledFromUpcallContext
                                    TRUE,   // Abort
                                    RPC_P_CONNECTION_SHUTDOWN
                                    );

                                InChannelState.Mutex.Request();
                                // we haven't posted a receive yet - there is no
                                // way the state of the channel will change
                                if (ClientPacketType == http2coptD4_A10)
                                    ExpectedState = http2svOpened_A10W;
                                else
                                    ExpectedState = http2svOpened_B3W;

                                ASSERT(OutChannelState.State == ExpectedState);
                                // move channel state to opened
                                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                                OutChannelState.State = http2svOpened;
                                InChannelState.Mutex.Clear();

                                if (DataReceivePosted)
                                    {
                                    RpcStatus = PostReceiveOnDefaultChannel (
                                        FALSE,   // IsInChannel
                                        http2ttData
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        }
                                    }

                                RpcStatus = RPC_P_PACKET_CONSUMED;
                                break;

                            default:
                                ASSERT(0);
                                RpcStatus = RPC_S_INTERNAL_ERROR;
                            }
                    }   // switch (InChannelState.State)
                if (MutexReleased == FALSE)
                    {
                    InChannelState.Mutex.Clear();
                    }
                }   // if (IsRTSPacket(Buffer))
            else
                {
                RpcStatus = RPC_S_OK;
                // data packet - ownership of the buffer passes to the runtime
                BufferFreed = TRUE;
                }
            }   // else of clause if (EventStatus != RPC_S_OK)
        }   // else of clause if (IsInChannel(ChannelId))

CleanupAndExit:
    if (((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_PACKET_CONSUMED))
        || WakeOpenThread)
        {
        if ((InChannelState.State == http2svA3W)
            || (InChannelState.State == http2svC2W)
            || (InChannelState.State == http2svSearchProxy)
            || WakeOpenThread
            )
            {
            if (ClientOpenInEvent && (InOpenStatus != ERROR_IO_PENDING))
                SetClientOpenInEvent();
            else if (ClientOpenOutEvent && (OutOpenStatus != ERROR_IO_PENDING))
                SetClientOpenOutEvent();
            }
        }

    if (BufferFreed == FALSE)
        RpcFreeBuffer(Buffer);

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::SyncRecv (
    IN BYTE **Buffer,
    IN ULONG *BufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Do a sync receive on an HTTP connection.

Arguments:

    Buffer - if successful, points to a buffer containing the next PDU.
    BufferLength -  if successful, contains the length of the message.
    Timeout - the amount of time to wait for the receive. If -1, we wait
        infinitely.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ClientChannel *Channel;
    RPC_STATUS RpcStatus;
    BOOL AbortNeeded;
    BOOL IoPending;

    while (TRUE)
        {
        Channel = LockDefaultOutChannel(&ChannelPtr);
        if (Channel)
            {
            RpcStatus = Channel->SubmitSyncRecv(http2ttData);

            // keep a reference for the operations below
            Channel->AddReference();

            ChannelPtr->UnlockChannelPointer();

            IoPending = FALSE;

            if (RpcStatus == RPC_S_OK)
                {
                AbortNeeded = FALSE;
                RpcStatus = Channel->WaitForSyncRecv(Buffer,
                    BufferLength,
                    Timeout,
                    ConnectionTimeout,
                    this,
                    &AbortNeeded,
                    &IoPending
                    );
                }
            else
                {
                AbortNeeded = TRUE;
                }

            if (AbortNeeded)
                {
                Channel->Abort(RpcStatus);
                }

            if (IoPending)
                {
                Channel->WaitInfiniteForSyncReceive();
                Channel->RemoveEvent();
                }

            if (AbortNeeded)
                {
                if (ReissueRecv)
                    {
                    ReissueRecv = FALSE;
                    // we don't re-issue on time outs
                    if (RpcStatus != RPC_S_CALL_CANCELLED)
                        {
                        Channel->RemoveReference();
                        continue;
                        }
                    }
                else
                    {
//                    ASSERT(!"This test should not have failing receives\n");
                    }
                }

            Channel->RemoveReference();

            if (RpcStatus == RPC_S_OK)
                {
                ASSERT(*Buffer != NULL);
                ASSERT(IsBadWritePtr(*Buffer, 4) == FALSE);
                }

            if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
                || (RpcStatus == RPC_P_SEND_FAILED)
                || (RpcStatus == RPC_S_SERVER_UNAVAILABLE)
                || (RpcStatus == RPC_P_CONNECTION_CLOSED) )
                {
                RpcStatus = RPC_P_RECEIVE_FAILED;
                }

            break;
            }
        else
            {
            RpcStatus = RPC_P_RECEIVE_FAILED;
            break;
            }
        }

    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_RECEIVE_FAILED,
        RPC_S_CALL_CANCELLED,
        RPC_P_SEND_FAILED,
        RPC_P_CONNECTION_SHUTDOWN,
        RPC_P_TIMEOUT
        } 
    CORRUPTION_VALIDATE
        {
        RPC_S_PROTOCOL_ERROR
        } CORRUPTION_END_VALIDATE;

    return RpcStatus;
}

void HTTP2ClientVirtualConnection::Abort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP connection and disconnects the channels.
    Must only come from the runtime.
    Note: Don't call any virtual methods in this function. It
    may be called in an environment without fully initialized
    vtable.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CLIENT_VC, 0);

    // abort the channels themselves
    AbortChannels(RPC_P_CONNECTION_CLOSED);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return;

    HTTP2VirtualConnection::DisconnectChannels(FALSE, 0);

    // call destructor without freeing memory
    HTTP2ClientVirtualConnection::~HTTP2ClientVirtualConnection();
}

void HTTP2ClientVirtualConnection::Close (
    IN BOOL DontFlush
    )
/*++

Routine Description:

    Closes a client HTTP connection.
    Note: Don't call virtual functions in this method.
    It may be called in an environment without fully
    initialized vtable.

Arguments:

    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

--*/
{
    HTTP2ClientVirtualConnection::Abort();
}

RPC_STATUS HTTP2ClientVirtualConnection::TurnOnOffKeepAlives (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN BOOL IsFromUpcall,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for HTTP.

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    IsFromUpcall - non-zero if called from upcall context. Zero otherwise.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we were to use it on the server, we must protect
        the connection against async aborts.
    Called in upcall or runtime context only.

--*/
{
    HTTP2ClientInChannel *InChannel;
    int i;
    RPC_STATUS RpcStatus;

    if (TurnOn)
        CurrentKeepAlive = KAInterval;
    else
        CurrentKeepAlive = 0;

    // convert the timeout from runtime scale to transport scale
    if (Units == tuRuntime)
        {
        ASSERT(KATime.RuntimeUnits != RPC_C_BINDING_INFINITE_TIMEOUT);
        KATime.Milliseconds = ConvertRuntimeTimeoutToWSTimeout(KATime.RuntimeUnits);
        Units = tuMilliseconds;
        }

    // make the change on both channels
    for (i = 0; i < 2; i ++)
        {
        InChannel = (HTTP2ClientInChannel *)InChannels[i].LockChannelPointer();
        if (InChannel != NULL)
            {
            RpcStatus = InChannel->SetKeepAliveTimeout (
                TurnOn,
                bProtectIO,
                Units,
                KATime,
                KATime.Milliseconds
                );

            InChannels[i].UnlockChannelPointer();

            RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                IsFromUpcall
                );

            if (RpcStatus != RPC_S_OK)
                break;
            }
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::RecycleChannel (
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    An in channel recycle is initiated. This may be called
    in an upcall or runtime context.

Arguments:

    IsFromUpcall - non-zero if it comes from upcall. Zero otherwise.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2ClientInChannel *NewInChannel;
    int NonDefaultInChannelSelector;
    HTTP2ChannelPointer *NewInChannelPtr;
    HTTP2SendContext *D2_A1Context;
    BOOL UseWinHttp;

#if DBG
    DbgPrint("RPCRT4: %d Recycling IN channel\n", GetCurrentProcessId());
#endif

    UseWinHttp = ShouldUseWinHttp(HttpCredentials);

    // we shouldn't get recycle unless we're in an opened state
    ASSERT(InChannelState.State == http2svOpened);

    // create a new in channel
    RpcStatus = ClientOpenInternal (&ConnectionHint,
        TRUE,       // HintWasInitialize
        ConnectionTimeout,
        DefaultReplacementChannelCallTimeout,
        TRUE,       // ClientOpenInChannel,
        FALSE,      // ClientOpenOutChannel
        TRUE,       // IsReplacementChannel
        IsFromUpcall
        );

    if (RpcStatus != RPC_S_OK)
        {
        // ClientOpenInternal Aborts on failure. No need to abort
        // here
        return RpcStatus;
        }

    NonDefaultInChannelSelector = GetNonDefaultInChannelSelector();

    NewInChannelPtr = &InChannels[NonDefaultInChannelSelector];
    NewInChannel = (HTTP2ClientInChannel *)NewInChannelPtr->LockChannelPointer();

    if (NewInChannel == NULL)
        {
        Abort();
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    InChannelState.Mutex.Request();
    if (InChannelState.State != http2svOpened)
        {
        InChannelState.Mutex.Clear();
        NewInChannelPtr->UnlockChannelPointer();
        Abort();
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    // move to Opened_A4W in anticipation of the send we will make.
    InChannelState.State = http2svOpened_A4W;
    InChannelState.Mutex.Clear();

    D2_A1Context = AllocateAndInitializeD2_A1(ProtocolVersion,
        &EmbeddedConnectionCookie,
        &InChannelCookies[DefaultInChannelSelector],
        &InChannelCookies[NonDefaultInChannelSelector]
        );
    if (D2_A1Context == NULL)
        {
        NewInChannelPtr->UnlockChannelPointer();
        Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcStatus = NewInChannel->Send(D2_A1Context);
    if (RpcStatus != RPC_S_OK)
        {
        NewInChannelPtr->UnlockChannelPointer();
        FreeRTSPacket(D2_A1Context);
        Abort();
        return RpcStatus;
        }

    if (!UseWinHttp)
        {
        RpcStatus = NewInChannel->Receive(http2ttRaw);
        }
    NewInChannelPtr->UnlockChannelPointer();

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::OpenReplacementOutChannel (
    void
    )
/*++

Routine Description:

    Opens a replacement out channel. Used during out channel
    recycling.

Arguments:

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2ClientOutChannel *NewOutChannel;
    int NonDefaultOutChannelSelector;
    HTTP2ChannelPointer *NewOutChannelPtr;
    HTTP2SendContext *D4_A3Context;
    KEEPALIVE_TIMEOUT KATime;

    // create a new out channel
    RpcStatus = ClientOpenInternal (&ConnectionHint,
        TRUE,       // HintWasInitialize
        ConnectionTimeout,
        DefaultReplacementChannelCallTimeout,
        FALSE,      // ClientOpenInChannel,
        TRUE,       // ClientOpenOutChannel
        TRUE,       // IsReplacementChannel
        TRUE        // IsFromUpcall
        );

    if (RpcStatus != RPC_S_OK)
        {
        // ClientOpenInternal has already aborted the connection
        return RpcStatus;
        }

    NonDefaultOutChannelSelector = GetNonDefaultOutChannelSelector();

    NewOutChannelPtr = &OutChannels[NonDefaultOutChannelSelector];
    NewOutChannel = (HTTP2ClientOutChannel *)NewOutChannelPtr->LockChannelPointer();

    if (NewOutChannel == NULL)
        {
        AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    InChannelState.Mutex.Request();
    if (OutChannelState.State != http2svOpened)
        {
        InChannelState.Mutex.Clear();
        NewOutChannelPtr->UnlockChannelPointer();
        AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    // move to Opened_A6W in anticipation of the send we will make.
    OutChannelState.State = http2svOpened_A6W;
    InChannelState.Mutex.Clear();

    D4_A3Context = AllocateAndInitializeD4_A3(ProtocolVersion,
        &EmbeddedConnectionCookie,
        &OutChannelCookies[DefaultOutChannelSelector],
        &OutChannelCookies[NonDefaultOutChannelSelector],
        HTTP2ClientReceiveWindow
        );

    if (D4_A3Context == NULL)
        {
        NewOutChannelPtr->UnlockChannelPointer();
        AbortChannels(RPC_S_OUT_OF_MEMORY);
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcStatus = NewOutChannel->Send(D4_A3Context);
    if (RpcStatus != RPC_S_OK)
        {
        NewOutChannelPtr->UnlockChannelPointer();
        FreeRTSPacket(D4_A3Context);
        AbortChannels(RpcStatus);
        return RpcStatus;
        }

    if (CurrentKeepAlive)
        {
        KATime.Milliseconds = 0;
        RpcStatus = NewOutChannel->SetKeepAliveTimeout (
            TRUE,       // TurnOn
            FALSE,      // bProtectIO
            tuMilliseconds,
            KATime,
            CurrentKeepAlive
            );

        ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);
        }

    NewOutChannelPtr->UnlockChannelPointer();

    if (RpcStatus != RPC_S_OK)
        {
        AbortChannels(RpcStatus);
        }

    return RpcStatus;
}

void HTTP2ClientVirtualConnection::AbortChannels (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Aborts an HTTP connection but does not disconnect
    the channels. Can be called from above, upcall, or
    neutral context, but not from submit context!

Arguments:

    RpcStatus - the error to abort the channels with

Return Value:

--*/
{
    // wait for the critical paths to unblock abort. The
    // only critical path that will do that is Open, and
    // it is extremely unlikely that this code will execute
    // together with open (though it is possible, and this
    // is why we need the additional synchronization).
    ChannelsAborted = TRUE;

    WaitForAbortsToUnblock();

    HTTP2VirtualConnection::AbortChannels (RpcStatus);
}

HTTP2Channel *HTTP2ClientVirtualConnection::LockDefaultSendChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the send channel. For client connections this is the in channel.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultOutChannel)

--*/
{
    return LockDefaultInChannel(ChannelPtr);
}

HTTP2Channel *HTTP2ClientVirtualConnection::LockDefaultReceiveChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the receive channel. For client connections this is the out channel.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultInChannel)

--*/
{
    return LockDefaultOutChannel(ChannelPtr);
}

const int MaxOutChannelHeader = 300;

RPC_STATUS
RPC_ENTRY 
HTTP2ClientReadChannelHeader (
    IN WS_HTTP2_CONNECTION *Connection,
    IN ULONG BytesRead,
    OUT ULONG *NewBytesRead
    )
/*++

Routine Description:

    Read a channel HTTP header (usually some string). In success
    case, there is real data in Connection->pReadBuffer. The
    number of bytes there is in NewBytesRead

Arguments:

    Connection - the connection on which the header arrived.

    BytesRead - the bytes received from the net

    NewBytesRead - the bytes read from the channel (success only)

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    DWORD message_size;
    RPC_STATUS RpcStatus;
    char *CurrentPosition;
    char *LastPosition;     // first position after end
    char *LastPosition2;    // first position after end + 4
                            // useful for end-of-loop comparison
    char *StartPosition;
    char *HeaderEnd;        // first character after header end
    ULONG HTTPResponse;
    BYTE *NewBuffer;

    BytesRead += Connection->iLastRead;

    // we have read something. Let's process it now.
    // search for double CR-LF (\r\n\r\n)
    StartPosition = (char *)(Connection->pReadBuffer);
    LastPosition = StartPosition + BytesRead;
    LastPosition2 = LastPosition + 4;
    HeaderEnd = NULL;
    CurrentPosition = (char *)(Connection->pReadBuffer);

    while (CurrentPosition < LastPosition2)
        {
        if ((*CurrentPosition == '\r')
            && (*(CurrentPosition + 1) == '\n')
            && (*(CurrentPosition + 2) == '\r')
            && (*(CurrentPosition + 3) == '\n')
           )
            {
            // we have a full header
            HeaderEnd = CurrentPosition + 4;
            break;
            }

        CurrentPosition ++;
        }

    if (CurrentPosition - StartPosition >= MaxOutChannelHeader)
        {
        // we should have seen the header by now. Abort. Returning
        // failure is enough - we know the caller will abort
        return RPC_S_PROTOCOL_ERROR;
        }

    if (HeaderEnd == NULL)
        {
        // we didn't find the end of the header. Submit another receive
        // for the rest
        RpcStatus = TransConnectionReallocPacket(Connection,
                                              &Connection->pReadBuffer,
                                              BytesRead,
                                              MaxOutChannelHeader);

        if (RpcStatus != RPC_S_OK)
            {
            ASSERT(RpcStatus == RPC_S_OUT_OF_MEMORY);
            return(RpcStatus);
            }

        Connection->iLastRead = BytesRead;
        Connection->maxReadBuffer = MaxOutChannelHeader;
        return RPC_P_PARTIAL_RECEIVE;
        }

    // we have found the header end. Grab the status code
    HTTPResponse = HttpParseResponse(StartPosition);
    if ((HTTPResponse >= RPC_S_INVALID_STRING_BINDING) && (HTTPResponse <= RPC_X_BAD_STUB_DATA))
        {
        // if it is an RPC error code, just return it.
        return HTTPResponse;
        }

    if (HTTPResponse != 200)
        return RPC_S_PROTOCOL_ERROR;

    // check whether we have something else besides the HTTP header
    if (HeaderEnd < LastPosition)
        {
        NewBuffer = TransConnectionAllocatePacket(Connection,
                                                   LastPosition - HeaderEnd);

        if (0 == NewBuffer)
            return RPC_S_OUT_OF_MEMORY;

        RpcpMemoryCopy(NewBuffer, HeaderEnd, LastPosition - HeaderEnd);
        *NewBytesRead = LastPosition - HeaderEnd;

        RpcFreeBuffer(Connection->pReadBuffer);
        Connection->pReadBuffer = NewBuffer;
        Connection->maxReadBuffer = LastPosition - HeaderEnd;
        Connection->iLastRead = 0;
        Connection->HeaderRead = TRUE;

        return RPC_S_OK;
        }

    // reset the pointer. By doing so we forget all we have 
    // read so far (which is only the HTTP header anyway)
    Connection->iLastRead = 0;
    Connection->HeaderRead = TRUE;
    return RPC_P_PARTIAL_RECEIVE;
}

// this is a bit mask. For any particular scheme, AND it with the constant
// Non-zero means it is multillegged. Schemes are:
// Scheme                             Value             Multilegged
// RPC_C_HTTP_AUTHN_SCHEME_BASIC      0x00000001        0
// RPC_C_HTTP_AUTHN_SCHEME_NTLM       0x00000002        1
// RPC_C_HTTP_AUTHN_SCHEME_PASSPORT   0x00000004        1
// RPC_C_HTTP_AUTHN_SCHEME_DIGEST     0x00000008        1
// RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE  0x00000010        1

const ULONG MultiLeggedSchemeMap = 
    RPC_C_HTTP_AUTHN_SCHEME_NTLM
    | RPC_C_HTTP_AUTHN_SCHEME_PASSPORT
    | RPC_C_HTTP_AUTHN_SCHEME_DIGEST
    | RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE;

/*
    All client opened types are valid initial states. The transitions are:

    cotSearchProxy ------+----> cotUknownAuth
                         |
        +----------------+---------------+
        |                |               |
    cotMLAuth       cotSLAuth       cotNoAuth
        |
    cotMLAuth2

 */

typedef enum tagClientOpenTypes
{
    cotSearchProxy,
    cotNoAuth,
    cotMLAuth,
    cotMLAuth2,
    cotSLAuth,
    cotUnknownAuth,
    cotInvalid
} ClientOpenTypes;

const char *InHeaderVerb = "RPC_IN_DATA";
const int InHeaderVerbLength = 11;    // length of RPC_IN_DATA

const char *OutHeaderVerb = "RPC_OUT_DATA";
const int OutHeaderVerbLength = 12;    // length of RPC_OUT_DATA

const BYTE EchoData[4] = {0xF8, 0xE8, 0x18, 0x08};
const ULONG EchoDataLength = sizeof(EchoData);

RPC_STATUS HTTP2ClientVirtualConnection::ClientOpenInternal (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN UINT ConnTimeout,
    IN ULONG CallTimeout,
    IN BOOL ClientOpenInChannel,
    IN BOOL ClientOpenOutChannel,
    IN BOOL IsReplacementChannel,
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    Opens a client side virtual connection.

Arguments:

    Hint - the resolver hint

    HintWasInitialized - the hint was initialized on input.

    ConnTimeout - connection timeout

    CallTimeout - operation timeout

    ClientOpenInChannel - non-zero if the in channel is to be opened.

    ClientOpenOutChannel - non-zero if the out channel is to be
        opened.

    IsReplacementChannel - non-zero if this is channel recycling

    IsFromUpcall - non-zero if this is called from an upcall. Zero otherwise.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2ClientInChannel *NewInChannel;
    HTTP2ClientOutChannel *NewOutChannel;
    BOOL InChannelLocked = FALSE;
    BOOL OutChannelLocked = FALSE;
    HTTP2SendContext *OutChannelSendContext = NULL;
    HTTP2SendContext *InChannelSendContext = NULL;
    ULONG WaitResult;
    HANDLE LocalClientOpenEvent;
    BOOL UseWinHttp;
    KEEPALIVE_TIMEOUT KATimeout;
    BOOL RebuildInChannel;
    BOOL RebuildOutChannel;
    BOOL NukeInChannel;
    BOOL NukeOutChannel;
    BOOL ResetInChannel;
    BOOL ResetOutChannel;
    BOOL SendInChannel;
    BOOL SendOutChannel;
    BOOL OpenInChannel;
    BOOL OpenOutChannel;
    BOOL ReceiveInChannel;
    BOOL ReceiveOutChannel;
    RPCProxyAccessType StoredAccessType;
    const char *VerbToUse;
    int VerbLengthToUse;
    const BYTE *AdditionalDataToUse;
    ULONG AdditionalDataLengthToUse;
    HTTP2StateValues NewConnectionState = http2svInvalid;
    BOOL SetNewConnectionState;
    RPC_STATUS LocalInOpenStatus;
    RPC_STATUS LocalOutOpenStatus;
    ULONG InChosenAuthScheme;
    ULONG OutChosenAuthScheme;
    BOOL IsKeepAlive;
    BOOL IsDone;
    int NonDefaultInChannelSelector;
    int NonDefaultOutChannelSelector;
    HTTP2ChannelPointer *InChannelPtr;
    HTTP2ChannelPointer *OutChannelPtr;
    ClientOpenTypes InOpenType;
    ClientOpenTypes OutOpenType;
    ClientOpenTypes OldOpenType;
    ClientOpenTypes OldInOpenType;
    ClientOpenTypes OldOutOpenType;
    int CurrentCase;
#if DBG
    int NumberOfRetries = 0;
#endif
    BOOL AbortsBlocked = FALSE;     // if non-zero, the aborts have been blocked and need
                            // unblocking before we exit

    if (IsReplacementChannel == FALSE)
        {
        if (ConnTimeout != RPC_C_BINDING_INFINITE_TIMEOUT)
            {
            ASSERT(   ((long)ConnTimeout >= RPC_C_BINDING_MIN_TIMEOUT)
                   && (ConnTimeout <= RPC_C_BINDING_MAX_TIMEOUT));

            // convert the timeout from runtime scale to transport scale
            ConnectionTimeout = ConvertRuntimeTimeoutToWSTimeout(ConnTimeout);
            }
        else
            {
            ConnectionTimeout = INFINITE;
            }
        }

    UseWinHttp = ShouldUseWinHttp(HttpCredentials);

    if (UseWinHttp)
        {
        RpcStatus = InitWinHttpIfNecessary();
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        }

    InOpenType = OutOpenType = cotInvalid;

    InChosenAuthScheme = 0;
    OutChosenAuthScheme = 0;

    IsDone = FALSE;

    if (HttpCredentials)
        {
        // WinHttp5.x does not support pre-auth for digest. This means that even if
        // you know that digest is your scheme, you have to pretend that you don't
        // and wait for the challenge before you choose it. Otherwise WinHttp5.x will
        // complain and fail.
        if ((HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME)
            && (*(HttpCredentials->AuthnSchemes) != RPC_C_HTTP_AUTHN_SCHEME_DIGEST))
            {
            OutChosenAuthScheme = InChosenAuthScheme = *(HttpCredentials->AuthnSchemes);
            if (ClientOpenInChannel)
                {
                if (InChosenAuthScheme & MultiLeggedSchemeMap)
                    InOpenType = cotMLAuth;
                else
                    InOpenType = cotSLAuth;
                }

            if (ClientOpenOutChannel)
                {
                if (OutChosenAuthScheme & MultiLeggedSchemeMap)
                    OutOpenType = cotMLAuth;
                else
                    OutOpenType = cotSLAuth;
                }
            }
        }
    else if (IsReplacementChannel == FALSE)
        {
        ASSERT(OutOpenType == cotInvalid);

        InOpenType = OutOpenType = cotNoAuth;
        }
    else if (ClientOpenInChannel)
        {
        InOpenType = cotNoAuth;
        IsDone = TRUE;
        }
    else
        {
        OutOpenType = cotNoAuth;
        IsDone = TRUE;
        }

    LocalClientOpenEvent = CreateEvent(NULL,        // lpEventAttributes
        FALSE,      // bManualReset
        FALSE,      // bInitialState
        NULL        // lpName
        );

    if (LocalClientOpenEvent == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (IsReplacementChannel == FALSE)
        {
        RpcStatus = EmbeddedConnectionCookie.Create();

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;
        }
    else
        {
        if (ClientOpenInChannel)
            NonDefaultInChannelSelector = GetNonDefaultInChannelSelector();
        else
            {
            ASSERT(ClientOpenOutChannel);
            NonDefaultOutChannelSelector = GetNonDefaultOutChannelSelector();
            }
        }

    if (ClientOpenInChannel)
        {
        if (IsReplacementChannel)
            RpcStatus = InChannelCookies[NonDefaultInChannelSelector].Create();
        else
            RpcStatus = InChannelCookies[0].Create();

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;
        }

    if (ClientOpenOutChannel)
        {
        if (IsReplacementChannel)
            RpcStatus = OutChannelCookies[NonDefaultOutChannelSelector].Create();
        else
            RpcStatus = OutChannelCookies[0].Create();

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;
        }

    if (ClientOpenInChannel)
        {
        RebuildInChannel = TRUE;
        NukeInChannel = FALSE;
        ResetInChannel = FALSE;
        OpenInChannel = TRUE;
        InOpenStatus = ERROR_IO_PENDING;
        }
    else
        {
        RebuildInChannel = FALSE;
        NukeInChannel = FALSE;
        ResetInChannel = FALSE;
        OpenInChannel = FALSE;
        ReceiveInChannel = FALSE;
        }

    if (ClientOpenOutChannel)
        {
        RebuildOutChannel = TRUE;
        NukeOutChannel = FALSE;
        ResetOutChannel = FALSE;
        OpenOutChannel = TRUE;
        // receive is done below
        OutOpenStatus = ERROR_IO_PENDING;
        }
    else
        {
        RebuildOutChannel = FALSE;
        NukeOutChannel = FALSE;
        ResetOutChannel = FALSE;
        OpenOutChannel = FALSE;
        ReceiveOutChannel = FALSE;
        }

    SetNewConnectionState = FALSE;

    ClientOpenInEvent = ClientOpenOutEvent = LocalClientOpenEvent;

    ASSERT(InChosenAuthScheme == OutChosenAuthScheme);

    // do we know whether to use a proxy?
    StoredAccessType = Hint->AccessType;
    if (StoredAccessType == rpcpatUnknown)
        {
        // this should never happen for replacement channels
        ASSERT(IsReplacementChannel == FALSE);

        // we don't.
        InOpenType = OutOpenType = cotSearchProxy;

        // move to http2svSearchProxy
        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svSearchProxy, 1, 0);
        InChannelState.State = http2svSearchProxy;

        SendInChannel = FALSE;
        SendOutChannel = FALSE;

        ReceiveInChannel = TRUE;
        ReceiveOutChannel = TRUE;
        }
    else
        {
        // we know. Do we know what authentication to use?
        if (InChosenAuthScheme)
            {
            ASSERT(InChosenAuthScheme == OutChosenAuthScheme);
            if (InChosenAuthScheme & MultiLeggedSchemeMap)
                {
                if (ClientOpenInChannel)
                    InOpenType = cotMLAuth;
                else
                    InOpenType = cotInvalid;

                if (ClientOpenOutChannel)
                    {
                    OutOpenType = cotMLAuth;
                    ReceiveOutChannel = TRUE;
                    }
                else
                    {
                    OutOpenType = cotInvalid;
                    ReceiveOutChannel = FALSE;
                    }
                }
            else
                {
                if (ClientOpenInChannel)
                    {
                    InOpenType = cotSLAuth;
                    if (IsReplacementChannel)
                        IsDone = TRUE;
                    }
                else
                    InOpenType = cotInvalid;

                if (ClientOpenOutChannel)
                    {
                    OutOpenType = cotSLAuth;
                    if (IsReplacementChannel)
                        {
                        ReceiveOutChannel = FALSE;
                        IsDone = TRUE;
                        }
                    else
                        ReceiveOutChannel = TRUE;
                    }
                else
                    {
                    OutOpenType = cotInvalid;
                    ReceiveOutChannel = FALSE;
                    }
                }
            }
        else
            {
            if (ClientOpenInChannel)
                {
                if (InOpenType != cotNoAuth)
                    InOpenType = cotUnknownAuth;
                }
            else 
                InOpenType = cotInvalid;

            if (ClientOpenOutChannel)
                {
                if (OutOpenType != cotNoAuth)
                    {
                    OutOpenType = cotUnknownAuth;
                    ReceiveOutChannel = TRUE;
                    }
                else if (IsReplacementChannel)
                    ReceiveOutChannel = FALSE;
                else
                    ReceiveOutChannel = TRUE;
                }
            else
                {
                OutOpenType = cotInvalid;
                ReceiveOutChannel = FALSE;
                }
            }

        if (IsReplacementChannel == FALSE)
            {
            // move to http2svA3W
            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svA3W, 1, 0);
            InChannelState.State = http2svA3W;
            }

        if (
            (
             (InOpenType == cotSLAuth)
             || 
             (InOpenType == cotNoAuth)
            )
            &&
            (IsReplacementChannel == FALSE)
           )
            {
            SendInChannel = TRUE;
            }
        else
            SendInChannel = FALSE;

        if (
            (
             (OutOpenType == cotSLAuth)
             || 
             (OutOpenType == cotNoAuth)
            )
            &&
            (IsReplacementChannel == FALSE)
           )
            {
            SendOutChannel = TRUE;
            }
        else
            SendOutChannel = FALSE;

        // 3 cases for the receive on the in channel
        // 1. If we don't use WinHttp and this is the first open or is in channel replacement, 
        //    we post a receive on this channel
        // 2. If this is a single legged operation, or this is a replacement channel we don't
        //    post a receive.
        // 3. All other cases (we use WinHttp and this is MLAuth/UnknownAuth) we post a receive
        if (ClientOpenInChannel)
            {
            if (!UseWinHttp)
                ReceiveInChannel = TRUE;
            else if ((InOpenType == cotNoAuth) || (InOpenType == cotSLAuth))
                ReceiveInChannel = FALSE;
            else
                ReceiveInChannel = TRUE;
            }
        else
            ReceiveInChannel = FALSE;
        }

    while (TRUE)
        {
#if DBG_ERROR
        DbgPrint("Starting loop iteration ....\n");
        NumberOfRetries ++;
        ASSERT (NumberOfRetries < 10);
#endif
        if (ClientOpenInChannel == FALSE)
            {
            // if we were told not to touch the in channel, make
            // sure we don't
            ASSERT(RebuildInChannel == FALSE
                && NukeInChannel == FALSE
                && ResetInChannel == FALSE
                && SendInChannel == FALSE
                && OpenInChannel == FALSE
                && ReceiveInChannel == FALSE);
            }

        if (ClientOpenOutChannel == FALSE)
            {
            // if we were told not to touch the out channel, make 
            // sure we don't
            ASSERT(RebuildOutChannel == FALSE
                && NukeOutChannel == FALSE
                && ResetOutChannel == FALSE
                && SendOutChannel == FALSE
                && OpenOutChannel == FALSE
                && ReceiveOutChannel == FALSE);
            }

        if (NukeInChannel)
            {
            if (IsReplacementChannel)
                InChannelPtr = &InChannels[NonDefaultInChannelSelector];
            else
                InChannelPtr = &InChannels[0];

            InChannelPtr->FreeChannelPointer(TRUE,      // DrainUpCalls
                IsReplacementChannel,      // CalledFromUpcallContext
                TRUE,       // Abort
                RPC_P_CONNECTION_SHUTDOWN   // AbortStatus
                );

            InOpenStatus = ERROR_IO_PENDING;
            }

        if (NukeOutChannel)
            {
            if (IsReplacementChannel)
                OutChannelPtr = &OutChannels[NonDefaultOutChannelSelector];
            else
                OutChannelPtr = &OutChannels[0];

            OutChannelPtr->FreeChannelPointer(TRUE,      // DrainUpCalls
                IsReplacementChannel,      // CalledFromUpcallContext
                TRUE,       // Abort
                RPC_P_CONNECTION_SHUTDOWN   // AbortStatus
                );

            OutOpenStatus = ERROR_IO_PENDING;
            }

        // after both channels are nuked, see whether we need to change the
        // connection state. We have to do this after nuking the channels
        // to avoid a race in ReceiveComplete where late receives may
        // see a different state
        if (SetNewConnectionState)
            {
            ASSERT(NewConnectionState != http2svInvalid);
            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, NewConnectionState, 1, 0);
            InChannelState.State = NewConnectionState;
            SetNewConnectionState = FALSE;
            }

        // we're entering the critical path of opening - the creating of the channel
        // and the opening itself. Block aborts until we fully open both channels
        // (or fail to do so)
        RpcStatus = BlockAborts();
        if (RpcStatus != RPC_S_OK)
            {
            goto AbortAndExit;
            }
        AbortsBlocked = TRUE;

        if (RebuildInChannel)
            {
            if (StoredAccessType == rpcpatUnknown)
                {
                ASSERT((InOpenType == cotSearchProxy)
                    || (InOpenType == cotMLAuth)
                    || (InOpenType == cotSLAuth)
                    );
                // if we don't know the type yet, try
                // direct for the in, proxy for the out.
                // One of them will work.
                Hint->AccessType = rpcpatDirect;
                }

            // initialize in channel
            RpcStatus = AllocateAndInitializeInChannel(Hint,
                HintWasInitialized,
                CallTimeout,
                UseWinHttp,
                &NewInChannel
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                {
                goto AbortAndExit;
                }

            if (IsReplacementChannel)
                SetNonDefaultInChannel(NewInChannel);
            else
                SetFirstInChannel(NewInChannel);
            }

        if (RebuildOutChannel)
            {
            if (StoredAccessType == rpcpatUnknown)
                {
                ASSERT((OutOpenType == cotSearchProxy)
                    || (OutOpenType == cotMLAuth)
                    || (OutOpenType == cotSLAuth)
                    );
                // if we don't know the type yet, try
                // direct for the in, proxy for the out.
                // One of them will work.
                Hint->AccessType = rpcpatHTTPProxy;
                }

            // initialize out channel
            RpcStatus = AllocateAndInitializeOutChannel(Hint,
                TRUE,   // HintWasInitialized
                CallTimeout,
                UseWinHttp,
                &NewOutChannel
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                {
                goto AbortAndExit;
                }

            if (IsReplacementChannel)
                SetNonDefaultOutChannel(NewOutChannel);
            else
                SetFirstOutChannel(NewOutChannel);
            }

        // at least one channel must wait for something to happen
        if (IsReplacementChannel == FALSE)
            {
            ASSERT((InOpenStatus == ERROR_IO_PENDING)
                || (OutOpenStatus == ERROR_IO_PENDING));
            }
        else if (ClientOpenInChannel)
            {
            ASSERT(InOpenStatus == ERROR_IO_PENDING);
            }
        else
            {
            ASSERT(ClientOpenOutChannel);
            ASSERT(OutOpenStatus == ERROR_IO_PENDING);
            }

        if (ResetInChannel || OpenInChannel || SendInChannel)
            {
            // Lock channel

            // after calling ClientOpen, we may be aborted asynchronously at any moment.
            // we will have pending async operations soon. Do the channel access by the
            // book. 
            if (IsReplacementChannel)
                InChannelPtr = &InChannels[NonDefaultInChannelSelector];
            else
                InChannelPtr = &InChannels[0];

            NewInChannel = (HTTP2ClientInChannel *)InChannelPtr->LockChannelPointer();

            if (NewInChannel == NULL)
                {
                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                goto AbortAndExit;
                }

            InChannelLocked = TRUE;
            }

        // Nuke and rebuild are mutually exclusive with Reset
        if (ResetInChannel)
            {
            ASSERT(NukeInChannel == FALSE);
            ASSERT(RebuildInChannel == FALSE);

            NewInChannel->Reset();
            }

        if (OpenInChannel)
            {
            // do we do in_data or echo's?
            if ((InOpenType == cotSearchProxy)
                || (InOpenType == cotMLAuth)
                || (InOpenType == cotUnknownAuth)
                )
                {
                AdditionalDataToUse = EchoData;
                AdditionalDataLengthToUse = EchoDataLength;
                if (StoredAccessType == rpcpatUnknown)
                    {
                    // if we don't know the type yet, try
                    // direct for the in, proxy for the out.
                    // One of them will work.
                    Hint->AccessType = rpcpatDirect;
                    }
                }
            else
                {
                ASSERT((InOpenType == cotSLAuth)
                    || (InOpenType == cotNoAuth)
                    || (InOpenType == cotMLAuth2)
                    );
                ASSERT(StoredAccessType != rpcpatUnknown);
                if (IsReplacementChannel == FALSE)
                    {
                    ASSERT(SendInChannel);
                    }
                else
                    {
                    ASSERT(SendInChannel == FALSE);
                    }
                AdditionalDataToUse = NULL;
                AdditionalDataLengthToUse = 0;
                }

            if (IsReplacementChannel == FALSE)
                {
                RpcStatus = NewInChannel->Unplug();
                // since no sends have been done yet, unplugging cannot fail here
                ASSERT(RpcStatus == RPC_S_OK);
                }

            RpcStatus = NewInChannel->ClientOpen(Hint,
                InHeaderVerb,
                InHeaderVerbLength,
                UseWinHttp,
                HttpCredentials,
                InChosenAuthScheme,
                CallTimeout,
                AdditionalDataToUse,
                AdditionalDataLengthToUse
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                {
                // if we are searching for the proxy, a failure here is not
                // fatal. We'll just prevent further operations on the channel,
                // and see what the other channel has to say
                if (InChannelState.State == http2svSearchProxy)
                    {
                    InOpenStatus = RpcStatus;
                    SendInChannel = FALSE;
                    ReceiveInChannel = FALSE;
                    // we don't need to unlock the channel - the code
                    // below will do.
                    }
                else
                    goto AbortAndExit;
                }
            }

        if (ResetOutChannel || OpenOutChannel || SendOutChannel)
            {
            if (IsReplacementChannel)
                OutChannelPtr = &OutChannels[NonDefaultOutChannelSelector];
            else
                OutChannelPtr = &OutChannels[0];

            NewOutChannel = (HTTP2ClientOutChannel *)OutChannelPtr->LockChannelPointer();

            if (NewOutChannel == NULL)
                {
                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                goto AbortAndExit;
                }

            OutChannelLocked = TRUE;
            }

        // Nuke and rebuild are mutually exclusive with Reset
        if (ResetOutChannel)
            {
            ASSERT(NukeOutChannel == FALSE);
            ASSERT(RebuildOutChannel == FALSE);

            NewOutChannel->Reset();
            }

        if (OpenOutChannel)
            {
            // do we do out_data or echo's?
            if ((OutOpenType == cotSearchProxy)
                || (OutOpenType == cotMLAuth)
                || (OutOpenType == cotUnknownAuth)
                )
                {
                AdditionalDataToUse = EchoData;
                AdditionalDataLengthToUse = 0;
                AdditionalDataLengthToUse = EchoDataLength;
                if (StoredAccessType == rpcpatUnknown)
                    {
                    // if we don't know the type yet, try
                    // direct for the in, proxy for the out.
                    // One of them will work.
                    Hint->AccessType = rpcpatHTTPProxy;
                    }
                }
            else
                {
                ASSERT((OutOpenType == cotNoAuth)
                    || (OutOpenType == cotSLAuth)
                    || (OutOpenType == cotMLAuth2)
                    );
                ASSERT(StoredAccessType != rpcpatUnknown);
                if (IsReplacementChannel == FALSE)
                    {
                    ASSERT(SendOutChannel);
                    }
                else
                    {
                    ASSERT(SendOutChannel == FALSE);
                    }
                AdditionalDataToUse = NULL;
                AdditionalDataLengthToUse = 0;
                }

            RpcStatus = NewOutChannel->ClientOpen(Hint,
                OutHeaderVerb,
                OutHeaderVerbLength,
                IsReplacementChannel,   // ReplacementChannel
                UseWinHttp,
                HttpCredentials,
                OutChosenAuthScheme,
                CallTimeout,
                AdditionalDataToUse,
                AdditionalDataLengthToUse
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                {
                // if this is the initial open and we are searching for the proxy, and 
                // the other channel opened, 
                // a failure here is not fatal. We'll just prevent further 
                // operations on the channel, and see what the other channel has 
                // to say. Note that during initial opening all the state is on the
                // in channel - that's why we check InChannelState here, not OutChannelState
                if ((IsReplacementChannel == FALSE) 
                    && (InChannelState.State == http2svSearchProxy) 
                    && (InOpenStatus == ERROR_IO_PENDING))
                    {
                    OutOpenStatus = RpcStatus;
                    SendOutChannel = FALSE;
                    ReceiveOutChannel = FALSE;
                    // we don't need to unlock the channel - the code
                    // below will do.
                    }
                else
                    {
                    goto AbortAndExit;
                    }
                }
            }

        // we're done with the opening itself. Unblock aborts
        ASSERT(AbortsBlocked);
        UnblockAborts();
        AbortsBlocked = FALSE;

        if (SendInChannel)
            {
            // should not happen during replacement
            ASSERT(IsReplacementChannel == FALSE);

            InChannelSendContext = AllocateAndInitializeD1_B1(HTTP2ProtocolVersion,
                &EmbeddedConnectionCookie,
                &InChannelCookies[0],
                DefaultChannelLifetime,
                DefaultClientKeepAliveInterval,
                &Hint->AssociationGroupId
                );

            if (InChannelSendContext == NULL)
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                goto AbortAndExit;
                }

            RpcStatus = NewInChannel->Send(InChannelSendContext);

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;

            // we don't own this buffer now
            InChannelSendContext = NULL;
            }

        if (SendOutChannel)
            {
            // should not happen during replacement
            ASSERT(IsReplacementChannel == FALSE);

            OutChannelSendContext = AllocateAndInitializeD1_A1(HTTP2ProtocolVersion,
                &EmbeddedConnectionCookie,
                &OutChannelCookies[0],
                HTTP2ClientReceiveWindow
                );

            if (OutChannelSendContext == NULL)
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                goto AbortAndExit;
                }

            RpcStatus = NewOutChannel->Send(OutChannelSendContext);

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;

            // we don't own this buffer anymore
            OutChannelSendContext = NULL;
            }

        // post receives on both channels
        if (ReceiveOutChannel)
            {
            RpcStatus = NewOutChannel->Receive(http2ttRTS);

            if (RpcStatus != RPC_S_OK)
                {
                goto AbortAndExit;
                }
            }

        if (ReceiveInChannel)
            {
            RpcStatus = NewInChannel->Receive(http2ttRaw);

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;
            }

        if (ResetInChannel || OpenInChannel || SendInChannel)
            {
            ASSERT(InChannelLocked);

            InChannelPtr->UnlockChannelPointer();

            InChannelLocked = FALSE;
            // channel is unlocked. Can't touch it
            NewInChannel = NULL;
            }

        if (ResetOutChannel || OpenOutChannel || SendOutChannel)
            {
            ASSERT(OutChannelLocked);

            OutChannelPtr->UnlockChannelPointer();

            OutChannelLocked = FALSE;
            // channel is unlocked. Can't touch it
            NewOutChannel = NULL;
            }

        if (IsDone)
            {
            RpcStatus = RPC_S_OK;
            break;
            }

        // no authentication and single leg authentication are
        // completed in one leg. Make sure we don't loop around
        // with them for replacement case
        if (ClientOpenInChannel && IsReplacementChannel)
            {
            ASSERT(InOpenType != cotNoAuth);
            ASSERT(InOpenType != cotSLAuth);
            ASSERT(InOpenType != cotMLAuth2);
            }

        if (ClientOpenOutChannel && IsReplacementChannel)
            {
            ASSERT(OutOpenType != cotNoAuth);
            ASSERT(OutOpenType != cotSLAuth);
            ASSERT(OutOpenType != cotMLAuth2);
            }
WaitAgain:
        // wait for something to happen
        WaitResult = WaitForSingleObject(LocalClientOpenEvent, CallTimeout);

        if (WaitResult == WAIT_TIMEOUT)
            {
            RpcStatus = RPC_S_CALL_CANCELLED;
            goto AbortAndExit;
            }

        ASSERT(WaitResult == WAIT_OBJECT_0);

        // there is race where we could have picked up a channel's event
        // after we waited (e.g. two channels completed immediately after each
        // other). In such case, there wouldn't be anything on any channel - wait
        // again. This race exists only if we do initial connect.
        if (IsReplacementChannel == FALSE)
            {
            if ((InOpenStatus == ERROR_IO_PENDING)
                && (OutOpenStatus == ERROR_IO_PENDING))
                {
                goto WaitAgain;
                }
            }

        OldInOpenType = InOpenType;
        OldOutOpenType = OutOpenType;

        // analyze what happened

        // If we are in a non-terminal state, check what transitions we
        // need to make to a terminal state
        if (ClientOpenOutChannel 
            &&
            (
             (OutOpenType == cotSearchProxy) 
             || 
             (OutOpenType == cotUnknownAuth)
            )
           )
            {
            OldOpenType = OutOpenType;

            // We can be here in 3 cases:
            // 1. We're searching for a proxy during initial open
            // 2. We don't know the auth type during initial open
            // 3. We recycle the out channel with unknown auth type

            // The events of interest are:
            // 1. If we are in case 2, and the channel is still pending,
            // skip the channel.
            // 2. If we're in the remainder of case 2 or we're in 3, or
            // (we're in 1 and the in channel is not positive yet and we
            // have given it enough time to come in, and we have a positive
            // response on this channel), the result is final.
            // 3. In case 1, if this channel has a negative response, fall through
            // to both channel check
            // 4. In case 1, if the other channel has come in, fall through

            // capture the out open status to get a consistent view of it in
            // the ifs below
            LocalOutOpenStatus = OutOpenStatus;

            if (OutOpenType == cotSearchProxy)
                {
                ASSERT(IsReplacementChannel == FALSE);
                CurrentCase = 1;
                }
            else if (IsReplacementChannel == FALSE)
                {
                ASSERT(OutOpenType == cotUnknownAuth);
                CurrentCase = 2;
                }
            else
                {
                ASSERT(IsReplacementChannel);
                ASSERT(OutOpenType == cotUnknownAuth);
                CurrentCase = 3;
                }

            if ((CurrentCase == 2)
                && (LocalOutOpenStatus == ERROR_IO_PENDING))
                {
                NukeOutChannel = FALSE;
                RebuildOutChannel = FALSE;
                ResetOutChannel = FALSE;
                OpenOutChannel = FALSE;
                ReceiveOutChannel = FALSE;
                SendOutChannel = FALSE;
                }
            else if 
                (
                 (CurrentCase == 2)
                 ||
                 (CurrentCase == 3)
                 || 
                 (
                  // positive response on case 1
                  (CurrentCase == 1)
                  &&
                  (!IsInChannelPositiveWithWait())
                  &&
                  (
                   (LocalOutOpenStatus == RPC_S_OK)
                   ||
                   (LocalOutOpenStatus == RPC_P_AUTH_NEEDED)
                  )
                 )
                )
                {
                // We'll be here in 3 cases
                // 1. We don't know the auth type during initial open and we have
                // a response on the channel
                // 2. We recycle the out channel with unknown auth type
                // 3. We search for a proxy and this channel will be chosen

                // the status is final
                if ((LocalOutOpenStatus != RPC_S_OK)
                    && (LocalOutOpenStatus != RPC_P_AUTH_NEEDED))
                    {
                    RpcStatus = LocalOutOpenStatus;
                    goto AbortAndExit;
                    }

                // In all cases the auth scheme is final for the new channel and we
                // need to continue authentication

                // if we haven't chosen a scheme yet, choose it now
                if (OutChosenAuthScheme == 0)
                    {
                    OutChosenAuthScheme = GetOutChannelChosenScheme(IsReplacementChannel);
                    }

                if (OutChosenAuthScheme & MultiLeggedSchemeMap)
                    {
                    // milti legged authentication implies keep alives
                    IsKeepAlive = TRUE;
                    OutOpenType = cotMLAuth;

                    // we need only reset, open, send and receive
                    NukeOutChannel = FALSE;
                    RebuildOutChannel = FALSE;
                    ResetOutChannel = TRUE;
                    OpenOutChannel = TRUE;
                    SendOutChannel = FALSE;
                    ReceiveOutChannel = TRUE;
                    }
                else
                    {
                    // SSL always supports keep alives
                    if (HttpCredentials && HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
                        IsKeepAlive = TRUE;
                    else
                        {
                        IsKeepAlive = IsOutChannelKeepAlive(IsReplacementChannel);
                        }

                    if (OutChosenAuthScheme)
                        OutOpenType = cotSLAuth;
                    else
                        OutOpenType = cotNoAuth;
                    if (IsKeepAlive)
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeOutChannel = FALSE;
                        RebuildOutChannel = FALSE;
                        ResetOutChannel = TRUE;
                        }
                    else
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeOutChannel = TRUE;
                        RebuildOutChannel = TRUE;
                        ResetOutChannel = FALSE;
                        }

                    OpenOutChannel = TRUE;
                    if (IsReplacementChannel)
                        {
                        ReceiveOutChannel = FALSE;

                        // should be done on next iteration
                        IsDone = TRUE;
                        }
                    else
                        {
                        SendOutChannel = TRUE;
                        ReceiveOutChannel = TRUE;
                        }

                    }
                OutOpenStatus = ERROR_IO_PENDING;

                if (InOpenType == cotSearchProxy)
                    {
                    // we need to nuke, rebuild, open, send, possibly receive in channel
                    NukeInChannel = TRUE;
                    RebuildInChannel = TRUE;
                    ResetInChannel = FALSE;
                    OpenInChannel = TRUE;
                    SendInChannel = FALSE;

                    // if we have already chosen an auth scheme, presumably
                    // because of RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME, set it
                    if (InChosenAuthScheme)
                        {
                        ASSERT(IsReplacementChannel == FALSE);
                        ASSERT(HttpCredentials);
                        ASSERT(HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME);

                        if (InChosenAuthScheme & MultiLeggedSchemeMap)
                            InOpenType = cotMLAuth;
                        else
                            {
                            InOpenType = cotSLAuth;
                            SendInChannel = TRUE;
                            }
                        }
                    else
                        InOpenType = cotUnknownAuth;

                    // multilegged schemes will still need to do some pinging.
                    // single legged schemes are done and only need to open
                    // the connection.
                    if (OutChosenAuthScheme & MultiLeggedSchemeMap)
                        ReceiveInChannel = TRUE;
                    else if (InOpenType == cotUnknownAuth)
                        {
                        ReceiveInChannel = TRUE;
                        }
                    else
                        {
                        ReceiveInChannel = FALSE;
                        }

                    StoredAccessType = rpcpatHTTPProxy;
                    Hint->AccessType = rpcpatHTTPProxy;
                    }

                if (IsReplacementChannel == FALSE)
                    {
                    // change the connection and channel state
                    SetNewConnectionState = TRUE;
                    NewConnectionState = http2svA3W;
                    }

                if ((OldOpenType == cotSearchProxy) || IsReplacementChannel)
                    continue;
                else
                    {
                    // we were doing initial open with cotUnknownAuth
                    // fall through to the in channel handling code to see
                    // what is it up to
                    }
                }
            else
                {
                // events 3 and 4. We're searching for the proxy and
                // either this channel came with a negative response or
                // the other channel came in
                ASSERT(CurrentCase == 1);
                ASSERT(IsReplacementChannel == FALSE);
                ASSERT(OutOpenType == cotSearchProxy);
                ASSERT(
                       (
                        (LocalOutOpenStatus != RPC_S_OK)
                        && 
                        (LocalOutOpenStatus != RPC_P_AUTH_NEEDED)
                       )
                       ||
                       (
                        (InOpenStatus == RPC_S_OK)
                        ||
                        (InOpenStatus == RPC_P_AUTH_NEEDED)
                       )
                      );

                // fall through to the in channel check
                }
            }

        if (
            ClientOpenInChannel
            &&
            (
             (InOpenType == cotSearchProxy) 
             || 
             (InOpenType == cotUnknownAuth)
            )
           )
            {
            OldOpenType = InOpenType;

            // We can be here in 3 cases:
            // 1. We do initial open and we search for proxy
            // 2. We do initial open with unknown auth.
            // 3. We do in channel recycling with unknown auth

            // The events of interest are:
            // 1. If the channel is still pending and we are in case 2,
            // skip the channel.
            // 2. If we're in case 3, or the remainder of 2, or (we're in 1 and
            // the result is positive), the result is final.
            // 3. If we're in case 1, and the result is negative, fall 
            // through below to both channels checks

            if (InOpenType == cotSearchProxy)
                {
                ASSERT(IsReplacementChannel == FALSE);
                CurrentCase = 1;
                }
            else if (IsReplacementChannel == FALSE)
                {
                ASSERT(InOpenType == cotUnknownAuth);
                CurrentCase = 2;
                }
            else
                {
                ASSERT(IsReplacementChannel);
                ASSERT(InOpenType == cotUnknownAuth);
                CurrentCase = 3;
                }

            // capture the InOpenStatus to get a consistent view
            LocalInOpenStatus = InOpenStatus;
            if ((CurrentCase == 2) && (LocalInOpenStatus == ERROR_IO_PENDING))
                {
                NukeInChannel = FALSE;
                RebuildInChannel = FALSE;
                ResetInChannel = FALSE;
                OpenInChannel = FALSE;
                ReceiveInChannel = FALSE;
                SendInChannel = FALSE;
                // the wait must have been woken by the out channel. Loop around
                continue;
                }
            else if 
                (
                 (CurrentCase == 2)
                 ||
                 (CurrentCase == 3)
                 ||
                 (
                  (CurrentCase == 1)
                  &&
                  (
                   (LocalInOpenStatus == RPC_S_OK)
                   ||
                   (LocalInOpenStatus == RPC_P_AUTH_NEEDED)
                  )
                 )
                )
                {
                if ((LocalInOpenStatus != RPC_S_OK)
                    && (LocalInOpenStatus != RPC_P_AUTH_NEEDED))
                    {
                    RpcStatus = LocalInOpenStatus;
                    goto AbortAndExit;
                    }

                // if we haven't chosen a scheme yet, choose it now
                if (InChosenAuthScheme == 0)
                    {
                    InChosenAuthScheme = GetInChannelChosenScheme(IsReplacementChannel);
                    }

                if (InChosenAuthScheme & MultiLeggedSchemeMap)
                    {
                    // milti legged authentication implies keep alives
                    IsKeepAlive = TRUE;
                    InOpenType = cotMLAuth;

                    // we need only reset, open, send and receive
                    NukeInChannel = FALSE;
                    RebuildInChannel = FALSE;
                    ResetInChannel = TRUE;
                    OpenInChannel = TRUE;
                    SendInChannel = FALSE;
                    ReceiveInChannel = TRUE;
                    }
                else
                    {
                    // SSL always supports keep alives
                    if (HttpCredentials && HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
                        IsKeepAlive = TRUE;
                    else
                        {
                        IsKeepAlive = IsInChannelKeepAlive(IsReplacementChannel);
                        }
                    if (InChosenAuthScheme)
                        InOpenType = cotSLAuth;
                    else
                        InOpenType = cotNoAuth;
                    if (IsKeepAlive)
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeInChannel = FALSE;
                        RebuildInChannel = FALSE;
                        ResetInChannel = TRUE;
                        }
                    else
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeInChannel = TRUE;
                        RebuildInChannel = TRUE;
                        ResetInChannel = FALSE;
                        }

                    OpenInChannel = TRUE;
                    if (IsReplacementChannel)
                        IsDone = TRUE;
                    else
                        SendInChannel = TRUE;

                    if (UseWinHttp || (IsReplacementChannel == FALSE))
                        ReceiveInChannel = FALSE;
                    else
                        ReceiveInChannel = TRUE;
                    }

                InOpenStatus = ERROR_IO_PENDING;

                if (OutOpenType == cotSearchProxy)
                    {
                    // we need to nuke, rebuild, open, send, possibly receive in channel
                    NukeOutChannel = TRUE;
                    RebuildOutChannel = TRUE;
                    ResetOutChannel = FALSE;
                    OpenOutChannel = TRUE;
                    SendOutChannel = FALSE;
                    ReceiveOutChannel = TRUE;

                    // if we have already chosen an auth scheme, presumably
                    // because of RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME, set it
                    if (OutChosenAuthScheme)
                        {
                        ASSERT(IsReplacementChannel == FALSE);
                        ASSERT(HttpCredentials);
                        ASSERT(HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME);

                        if (OutChosenAuthScheme & MultiLeggedSchemeMap)
                            OutOpenType = cotMLAuth;
                        else
                            {
                            OutOpenType = cotSLAuth;

                            SendOutChannel = TRUE;
                            }
                        }
                    else
                        OutOpenType = cotUnknownAuth;

                    StoredAccessType = rpcpatDirect;
                    Hint->AccessType = rpcpatDirect;
                    }

                if (IsReplacementChannel == FALSE)
                    {
                    // change the connection and channel state
                    SetNewConnectionState = TRUE;
                    NewConnectionState = http2svA3W;
                    }

                if ((OldOpenType == cotSearchProxy) || IsReplacementChannel)
                    continue;
                else
                    {
                    // fall through to code that handles both channels
                    }
                }
            else
                {
                ASSERT(CurrentCase == 1);
                ASSERT((LocalInOpenStatus != RPC_S_OK)
                    && (LocalInOpenStatus != RPC_P_AUTH_NEEDED) );
                // fall through below
                }
            }

        // did we get to an opened state? This should be checked only
        // when we open both (initial open).
        if ((IsReplacementChannel == FALSE) 
            && (InChannelState.State == http2svOpened))
            {

            RpcStatus = RPC_S_OK;

            ASSERT(InChannelState.State == http2svOpened);
            ASSERT(OutChannelState.State == http2svOpened);

            RpcStatus = HTTP_CopyResolverHint(&ConnectionHint,
                Hint,
                FALSE   // SourceWillBeAbandoned
                );

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;

            break;
            }

        // if we are in a non-transitional state and we're doing an
        // initial open, this means one of the channels didn't come in.
        // Loop around
        if ((IsReplacementChannel == FALSE)
            && (
                (InOpenType == cotUnknownAuth)
                ||
                (OutOpenType == cotUnknownAuth)
               )
              )
            {
            ASSERT((LocalInOpenStatus == ERROR_IO_PENDING)
                || (LocalOutOpenStatus == ERROR_IO_PENDING));
            continue;
            }

        // we're probably authenticating the individual channels
        // see which channel is actionable and what to do with it
        if (ClientOpenInChannel && (OldInOpenType == cotMLAuth))
            {
            // capture the InOpenStatus in a local variable for consistent
            // view
            LocalInOpenStatus = InOpenStatus;
            if (LocalInOpenStatus != ERROR_IO_PENDING)
                {
                // something happened on the in channel. Process it
                if (LocalInOpenStatus == RPC_S_OK)
                    {
                    // we have successfully completed
                    // authentication. Open the connection on the RTS
                    // level
                    InOpenStatus = ERROR_IO_PENDING;
                    // we need to reset, open, send, receive out channel
                    NukeInChannel = FALSE;
                    RebuildInChannel = FALSE;
                    ResetInChannel = TRUE;
                    OpenInChannel = TRUE;

                    ReceiveInChannel = FALSE;

                    if (IsReplacementChannel)
                        {
                        SendInChannel = FALSE;
                        IsDone = TRUE;
                        }
                    else
                        SendInChannel = TRUE;

                    InOpenType = cotMLAuth2;
                    }
                else
                    {
                    // if after all the auth we still get a challenge, this means
                    // we couldn't auth and this is access denied.
                    if (LocalInOpenStatus == RPC_P_AUTH_NEEDED)
                        RpcStatus = RPC_S_ACCESS_DENIED;
                    else
                        RpcStatus = LocalInOpenStatus;
                    goto AbortAndExit;
                    }
                }
            else
                {
                // fall through. Below we will detect the state
                // hasn't changed and we won't do any operations
                // on this channel
                }
            }

        if (ClientOpenOutChannel && (OldOutOpenType == cotMLAuth))
            {
            // capture the OutOpenStatus in a local variable for consistent
            // view
            LocalOutOpenStatus = OutOpenStatus;
            if (LocalOutOpenStatus != ERROR_IO_PENDING)
                {
                // something happened on the in channel. Process it
                if (LocalOutOpenStatus == RPC_S_OK)
                    {
                    // we have successfully completed multi-legged
                    // authentication. Open the connection on the RTS
                    // level
                    OutOpenStatus = ERROR_IO_PENDING;
                    // we need to reset, open, send, receive out channel
                    NukeOutChannel = FALSE;
                    RebuildOutChannel = FALSE;
                    ResetOutChannel = TRUE;
                    OpenOutChannel = TRUE;
                    if (IsReplacementChannel)
                        {
                        ReceiveOutChannel = FALSE;
                        SendOutChannel = FALSE;
                        IsDone = TRUE;
                        }
                    else
                        {
                        ReceiveOutChannel = TRUE;
                        SendOutChannel = TRUE;
                        }

                    OutOpenType = cotMLAuth2;
                    }
                else
                    {
                    // if after all the auth we still get a challenge, this means
                    // we couldn't auth and this is access denied.
                    if (LocalOutOpenStatus == RPC_P_AUTH_NEEDED)
                        RpcStatus = RPC_S_ACCESS_DENIED;
                    else
                        RpcStatus = LocalOutOpenStatus;
                    goto AbortAndExit;
                    }
                }
            else
                {
                // fall through. Below we will detect the state
                // hasn't changed and we won't do any operations
                // on this channel
                }
            }

        if ((IsReplacementChannel == FALSE) && (InOpenType == cotSearchProxy))
            {
            // none of the channels came in positive so far. If at least one
            // is still pending, wait for it
            if ((LocalInOpenStatus == ERROR_IO_PENDING)
                || (LocalOutOpenStatus == ERROR_IO_PENDING))
                {
#if DBG_ERROR
                DbgPrint("Waiting again ....\n");
#endif
                goto WaitAgain;
                }

            // both channels came in negative. The server is not
            // available
            if ((LocalInOpenStatus == RPC_S_ACCESS_DENIED)
                || (LocalOutOpenStatus == RPC_S_ACCESS_DENIED))
                RpcStatus = RPC_S_ACCESS_DENIED;
            else
                RpcStatus = RPC_S_SERVER_UNAVAILABLE;
            goto AbortAndExit;
            }

        // if we came in with a terminal state and the server responded
        // with an error, bail out
        // first, capture the InOpenStatus in a local variable for consistent
        // view
        LocalInOpenStatus = InOpenStatus;
        if (ClientOpenInChannel
            && 
            (
             (OldInOpenType == cotSLAuth)
             ||
             (OldInOpenType == cotNoAuth)
             ||
             (OldInOpenType == cotMLAuth2)
            )
            &&
            (LocalInOpenStatus != RPC_S_OK)
            &&
            (LocalInOpenStatus != ERROR_IO_PENDING)
           )
            {
            if (LocalInOpenStatus == RPC_P_AUTH_NEEDED)
                RpcStatus = RPC_S_ACCESS_DENIED;
            else
                RpcStatus = LocalInOpenStatus;
            goto AbortAndExit;
            }

        // capture the OutOpenStatus in a local variable for consistent
        // view
        LocalOutOpenStatus = OutOpenStatus;
        if (ClientOpenOutChannel
            && 
            (
             (OldOutOpenType == cotSLAuth)
             ||
             (OldOutOpenType == cotNoAuth)
             ||
             (OldOutOpenType == cotMLAuth2)
            )
            &&
            (LocalOutOpenStatus != RPC_S_OK)
            &&
            (LocalOutOpenStatus != ERROR_IO_PENDING)
           )
            {
            if (LocalOutOpenStatus == RPC_P_AUTH_NEEDED)
                RpcStatus = RPC_S_ACCESS_DENIED;
            else
                RpcStatus = LocalOutOpenStatus;
            goto AbortAndExit;
            }

        // if state hasn't changed, don't do anything on this channel
        if (OldInOpenType == InOpenType)
            {
            NukeInChannel = FALSE;
            RebuildInChannel = FALSE;
            ResetInChannel = FALSE;
            OpenInChannel = FALSE;
            ReceiveInChannel = FALSE;
            SendInChannel = FALSE;
            }

        if (OldOutOpenType == OutOpenType)
            {
            NukeOutChannel = FALSE;
            RebuildOutChannel = FALSE;
            ResetOutChannel = FALSE;
            OpenOutChannel = FALSE;
            ReceiveOutChannel = FALSE;
            SendOutChannel = FALSE;
            }
        // loop around for further processing
        }

    if (AbortsBlocked)
        UnblockAborts();

    ASSERT(RpcStatus == RPC_S_OK);

    if (IsReplacementChannel == FALSE)
        {
        ASSERT(InChannelState.State == http2svOpened);
        }

    ASSERT(LocalClientOpenEvent);
    InChannelState.Mutex.Request();
    ClientOpenInEvent = NULL;
    ClientOpenOutEvent = NULL;
    InChannelState.Mutex.Clear();
    CloseHandle(LocalClientOpenEvent);

    return RpcStatus;

AbortAndExit:
    if (InChannelLocked)
        {
        InChannelPtr->UnlockChannelPointer();
        }

    if (OutChannelLocked)
        {
        OutChannelPtr->UnlockChannelPointer();
        }

    if (InChannelSendContext)
        {
        FreeRTSPacket(InChannelSendContext);
        }

    if (OutChannelSendContext)
        {
        FreeRTSPacket(OutChannelSendContext);
        }

    if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
        || (RpcStatus == RPC_P_CONNECTION_CLOSED)
        || (RpcStatus == RPC_P_SEND_FAILED))
        RpcStatus = RPC_S_SERVER_UNAVAILABLE;
    else if ((RpcStatus == RPC_P_RECEIVE_FAILED) && IsReplacementChannel)
        {
        // RPC_P_RECEIVE_FAILED is also mapped to server unavailable, but only
        // during channel recycling. The reason is that the old crappy RPC Proxy
        // will just close the connection if we directly access the RPC Proxy,
        // so all that we will get will be RPC_P_RECEIVE_FAILED. Not mapping it
        // during initial conneciton establishment allows upper layers to try the old
        // HTTP thus preserving interop
        RpcStatus = RPC_S_SERVER_UNAVAILABLE;
        }
    else if (RpcStatus == ERROR_NOT_ENOUGH_QUOTA
             || RpcStatus == ERROR_MAX_THRDS_REACHED)
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        }

    ASSERT(LocalClientOpenEvent);
    InChannelState.Mutex.Request();
    ClientOpenInEvent = NULL;
    ClientOpenOutEvent = NULL;
    InChannelState.Mutex.Clear();
    CloseHandle(LocalClientOpenEvent);

    VALIDATE (RpcStatus)
        {
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_SERVER_UNAVAILABLE,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_SERVER_TOO_BUSY,
        RPC_S_INVALID_NETWORK_OPTIONS,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_INVALID_NET_ADDR,
        RPC_S_ACCESS_DENIED,
        RPC_S_INTERNAL_ERROR,
        RPC_S_SERVER_OUT_OF_MEMORY,
        RPC_S_CALL_CANCELLED,
        RPC_S_PROTOCOL_ERROR,
        RPC_P_RECEIVE_FAILED
        } END_VALIDATE;

    if (AbortsBlocked)
        UnblockAborts();

    // If we are not from upcall, abort. Else, caller will
    // abort 
    if (IsFromUpcall == FALSE)
        Abort();

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::AllocateAndInitializeInChannel (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN ULONG CallTimeout,
    IN BOOL UseWinHttp,
    OUT HTTP2ClientInChannel **ReturnInChannel
    )
/*++

Routine Description:

    Allocate and initialize the in channel stack

Arguments:

    Hint - the resolver hint

    HintWasInitialized - true if the hint was initialized on input

    CallTimeout - the timeout for the operation

    ReturnInChannel - on success the pointer to the allocated in channel.
        Undefined on failure.

    UseWinHttp - non-zero if WinHttp should be used for the bottom channel.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ClientInChannel *InChannel;
    HTTP2PlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2PingOriginator *PingOriginator;
    HTTP2ChannelDataOriginator *ChannelDataOriginator;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    HTTP2WinHttpTransportChannel *WinHttpConnection;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL PingOriginatorNeedsCleanup;
    BOOL ChannelDataOriginatorNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    BOOL WinHttpConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator)
        ;

    if (UseWinHttp)
        MemorySize += sizeof(HTTP2WinHttpTransportChannel);
    else
        {
        MemorySize += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
            + sizeof(WS_HTTP2_CONNECTION);
        }

    CurrentBlock = MemoryBlock = (BYTE *) new char [MemorySize];
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2ClientInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientInChannel);

    PlugChannel = (HTTP2PlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    PingOriginator = (HTTP2PingOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator);

    ChannelDataOriginator = (HTTP2ChannelDataOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator);

    if (UseWinHttp)
        {
        WinHttpConnection = (HTTP2WinHttpTransportChannel *)CurrentBlock;
        }
    else
        {
        RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
        CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

        RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
        RawConnection->HeaderRead = FALSE;
        RawConnection->ReadHeaderFn = HTTP2ClientReadChannelHeader;
        }

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    PingOriginatorNeedsCleanup = FALSE;
    ChannelDataOriginatorNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;
    WinHttpConnectionNeedsCleanup = FALSE;

    if (UseWinHttp)
        {
        RpcStatus = RPC_S_OK;
        WinHttpConnection = new (WinHttpConnection) HTTP2WinHttpTransportChannel (&RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            WinHttpConnection->HTTP2WinHttpTransportChannel::~HTTP2WinHttpTransportChannel();
            goto AbortAndExit;
            }

        WinHttpConnectionNeedsCleanup = TRUE;
        }
    else
        {
        RpcStatus = InitializeRawConnection (RawConnection,
            Hint,
            HintWasInitialized,
            CallTimeout
            );

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;

        RawConnection->RuntimeConnectionPtr = this;
        RawConnectionNeedsCleanup = TRUE;

        RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
            goto AbortAndExit;
            }

        RawConnection->Channel = RawChannel;

        RawChannelNeedsCleanup = TRUE;
        }

    ChannelDataOriginator = new (ChannelDataOriginator) HTTP2ChannelDataOriginator (DefaultChannelLifetime,
        FALSE,      // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ChannelDataOriginator->HTTP2ChannelDataOriginator::~HTTP2ChannelDataOriginator();
        goto AbortAndExit;
        }

    if (UseWinHttp)
        {
        WinHttpConnection->SetUpperChannel(ChannelDataOriginator);
        ChannelDataOriginator->SetLowerChannel(WinHttpConnection);
        }
    else
        {
        RawChannel->SetUpperChannel(ChannelDataOriginator);
        ChannelDataOriginator->SetLowerChannel(RawChannel);
        }

    ChannelDataOriginatorNeedsCleanup = TRUE;

    PingOriginator = new (PingOriginator) HTTP2PingOriginator (
        FALSE       // NotifyTopChannelForPings
        );

    ChannelDataOriginator->SetUpperChannel(PingOriginator);
    PingOriginator->SetLowerChannel(ChannelDataOriginator);

    PingOriginatorNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (FALSE,      // IsServer
        TRUE,        // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    PingOriginator->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(PingOriginator);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2PlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2PlugChannel::~HTTP2PlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2ClientInChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2ClientInChannel::~HTTP2ClientInChannel();
        goto AbortAndExit;
        }

    if (UseWinHttp)
        WinHttpConnection->SetTopChannel(InChannel);
    else
        RawChannel->SetTopChannel(InChannel);
    ChannelDataOriginator->SetTopChannel(InChannel);
    PingOriginator->SetTopChannel(InChannel);
    FlowControlSender->SetTopChannel(InChannel);
    PlugChannel->SetTopChannel(InChannel);

    PlugChannel->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(PlugChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnInChannel = InChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (PingOriginatorNeedsCleanup)
        {
        PingOriginator->Abort(RpcStatus);
        PingOriginator->FreeObject();
        }
    else if (ChannelDataOriginatorNeedsCleanup)
        {
        ChannelDataOriginator->Abort(RpcStatus);
        ChannelDataOriginator->FreeObject();
        }
    else if (UseWinHttp)
        {
        if (WinHttpConnectionNeedsCleanup)
            {
            WinHttpConnection->Abort(RpcStatus);
            WinHttpConnection->FreeObject();
            }
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS
RPC_ENTRY 
HTTP2ReadHttpLegacyResponse (
    IN WS_HTTP2_CONNECTION *Connection,
    IN ULONG BytesRead,
    OUT ULONG *NewBytesRead
    )
/*++

Routine Description:

    Read a channel HTTP header (usually some string). In success
    case, there is real data in Connection->pReadBuffer. The
    number of bytes there is in NewBytesRead

Arguments:

    Connection - the connection on which the header arrived.

    BytesRead - the bytes received from the net

    NewBytesRead - the bytes read from the channel (success only)

Return Value:

    RPC_S_OK or other RPC_S_* errors for error
    RPC_P_PARTIAL_RECEIVE will cause another loop.
    Any other error will cause processing of NewBuffer

--*/
{
    RPC_STATUS RpcStatus;
    BYTE *NewBuffer;

    BytesRead += Connection->iLastRead;

    // check whether what we have is a legacy response
    // legacy response is ncacn_http/1.0
    if (*(ULONG *)Connection->pReadBuffer == (ULONG)'cacn')
        {
        // Let's process it now.
        // see if we have sufficient length
        if (BytesRead < HTTP_SERVER_ID_STR_LEN)
            {
            Connection->iLastRead = BytesRead;
            return RPC_P_PARTIAL_RECEIVE;
            }
        else if (BytesRead == HTTP_SERVER_ID_STR_LEN)
            {
            // reset the pointer. By doing so we forget all we have 
            // read so far
            Connection->iLastRead = 0;
            Connection->HeaderRead = TRUE;
            return RPC_P_PARTIAL_RECEIVE;
            }
        else
            {
            // we have what we expect, and something more (coalesced read)
            // Process it. First make sure it is what we expect
            if (RpcpMemoryCompare(Connection->pReadBuffer, HTTP_SERVER_ID_STR, HTTP_SERVER_ID_STR_LEN) != 0)
                {
                return RPC_S_PROTOCOL_ERROR;
                }

            NewBuffer = TransConnectionAllocatePacket(Connection,
                   max(Connection->iPostSize, BytesRead - HTTP_SERVER_ID_STR_LEN));

            if (0 == NewBuffer)
                return RPC_S_OUT_OF_MEMORY;

            RpcpMemoryCopy(NewBuffer, 
                ((BYTE *)Connection->pReadBuffer) + HTTP_SERVER_ID_STR_LEN, 
                BytesRead - HTTP_SERVER_ID_STR_LEN);
            *NewBytesRead = BytesRead - HTTP_SERVER_ID_STR_LEN;

            RpcFreeBuffer(Connection->pReadBuffer);
            Connection->pReadBuffer = NewBuffer;
            Connection->iLastRead = 0;
            Connection->HeaderRead = TRUE;

            return RPC_S_OK;
            }
        }
    else
        {
        *NewBytesRead = BytesRead;
        Connection->iLastRead = 0;
        Connection->HeaderRead = TRUE;
        return RPC_S_OK;
        }
}

RPC_STATUS HTTP2ClientVirtualConnection::AllocateAndInitializeOutChannel (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN ULONG CallTimeout,
    IN BOOL UseWinHttp,
    OUT HTTP2ClientOutChannel **ReturnOutChannel
    )
/*++

Routine Description:

    Allocate and initialize the out channel stack

Arguments:

    Hint - the resolver hint

    HintWasInitialized - true if the hint was initialized on input

    CallTimeout - the timeout for the operation

    ReturnInChannel - on success the pointer to the allocated in channel.
        Undefined on failure.

    UseWinHttp - non-zero if WinHttp should be used for the bottom channel.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ClientOutChannel *OutChannel;
    HTTP2EndpointReceiver *EndpointReceiver;
    HTTP2PingReceiver *PingReceiver;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    HTTP2WinHttpTransportChannel *WinHttpConnection;
    BOOL EndpointReceiverNeedsCleanup;
    BOOL PingReceiverNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    BOOL WinHttpConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the out channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver)
        ;

    if (UseWinHttp)
        MemorySize += sizeof(HTTP2WinHttpTransportChannel);
    else
        {
        MemorySize += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
            + sizeof(WS_HTTP2_CONNECTION);
        }

    CurrentBlock = MemoryBlock = (BYTE *) new char [MemorySize];
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2ClientOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientOutChannel);

    EndpointReceiver = (HTTP2EndpointReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver);

    PingReceiver = (HTTP2PingReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver);

    if (UseWinHttp)
        {
        WinHttpConnection = (HTTP2WinHttpTransportChannel *)CurrentBlock;
        }
    else
        {
        RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
        CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

        RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
        RawConnection->HeaderRead = FALSE;
        RawConnection->ReadHeaderFn = HTTP2ClientReadChannelHeader;
        }

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    EndpointReceiverNeedsCleanup = FALSE;
    PingReceiverNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;
    WinHttpConnectionNeedsCleanup = FALSE;

    if (UseWinHttp)
        {
        RpcStatus = RPC_S_OK;
        WinHttpConnection = new (WinHttpConnection) HTTP2WinHttpTransportChannel (&RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            WinHttpConnection->HTTP2WinHttpTransportChannel::~HTTP2WinHttpTransportChannel();
            goto AbortAndExit;
            }

        WinHttpConnectionNeedsCleanup = TRUE;
        }
    else
        {
        RpcStatus = InitializeRawConnection (RawConnection,
            Hint,
            HintWasInitialized,
            CallTimeout
            );

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;

        RawConnection->RuntimeConnectionPtr = this;
        RawConnectionNeedsCleanup = TRUE;

        RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
            goto AbortAndExit;
            }

        RawConnection->Channel = RawChannel;

        RawChannelNeedsCleanup = TRUE;
        }

    PingReceiver = new (PingReceiver) HTTP2PingReceiver(TRUE);

    if (UseWinHttp)
        {
        WinHttpConnection->SetUpperChannel(PingReceiver);
        PingReceiver->SetLowerChannel(WinHttpConnection);
        }
    else
        {
        RawChannel->SetUpperChannel(PingReceiver);
        PingReceiver->SetLowerChannel(RawChannel);
        }

    PingReceiverNeedsCleanup = TRUE;

    EndpointReceiver = new (EndpointReceiver) HTTP2EndpointReceiver(HTTP2ClientReceiveWindow,
        FALSE,      // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        EndpointReceiver->HTTP2EndpointReceiver::~HTTP2EndpointReceiver();
        goto AbortAndExit;
        }

    PingReceiver->SetUpperChannel(EndpointReceiver);
    EndpointReceiver->SetLowerChannel(PingReceiver);

    EndpointReceiverNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2ClientOutChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2ClientOutChannel::~HTTP2ClientOutChannel();
        goto AbortAndExit;
        }

    EndpointReceiver->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(EndpointReceiver);

    if (UseWinHttp)
        WinHttpConnection->SetTopChannel(OutChannel);
    else
        RawChannel->SetTopChannel(OutChannel);
    PingReceiver->SetTopChannel(OutChannel);
    EndpointReceiver->SetTopChannel(OutChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnOutChannel = OutChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (EndpointReceiverNeedsCleanup)
        {
        EndpointReceiver->Abort(RpcStatus);
        EndpointReceiver->FreeObject();
        }
    else if (PingReceiverNeedsCleanup)
        {
        PingReceiver->Abort(RpcStatus);
        PingReceiver->FreeObject();
        }
    else if (UseWinHttp)
        {
        if (WinHttpConnectionNeedsCleanup)
            {
            WinHttpConnection->Abort(RpcStatus);
            WinHttpConnection->FreeObject();
            }
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::InitializeRawConnection (
    IN OUT WS_HTTP2_CONNECTION *RawConnection,
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN ULONG CallTimeout
    )
/*++

Routine Description:

    Initialize a raw client connection

Arguments:

    RawConnection - memory for the connection. It is uninitialized

    Hint - the resolver hint

    HintWasInitialized - true if the hint was initialized on input

    CallTimeout - the timeout for the operation

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    RPC_CHAR *ConnectionTargetName;
    USHORT PortToUse;

    RawConnection->Initialize();
    RawConnection->type = COMPLEX_T | CONNECTION | CLIENT;

    // initialize raw connection
    if (Hint->AccessType == rpcpatHTTPProxy)
        {
        ConnectionTargetName = new RPC_CHAR [RpcpStringLengthA(Hint->HTTPProxy) + 2];
        if (ConnectionTargetName == NULL)
            {
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            return RpcStatus;
            }

        FullAnsiToUnicode(Hint->HTTPProxy, ConnectionTargetName);

        PortToUse = Hint->HTTPProxyPort;
        }
    else
        {
        ASSERT(Hint->AccessType == rpcpatDirect);

        ConnectionTargetName = new RPC_CHAR [RpcpStringLengthA(Hint->RpcProxy) + 1];
        if (ConnectionTargetName == NULL)
            {
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            return RpcStatus;
            }

        FullAnsiToUnicode(Hint->RpcProxy, ConnectionTargetName);

        PortToUse = Hint->RpcProxyPort;
        }

    RpcStatus = TCPOrHTTP_Open(RawConnection,
        ConnectionTargetName,
        PortToUse,
        ConnectionTimeout,
        0,      // SendBufferSize
        0,      // RecvBufferSize
        Hint,
        HintWasInitialized,
        CallTimeout,
        TRUE,    // fHTTP2Open
        NULL     // IsValidMachineFn
        );

    delete [] ConnectionTargetName;

    return RpcStatus;
}

BOOL HTTP2ClientVirtualConnection::IsInChannelKeepAlive (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Checks whether the an in channel supports keep alives.
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    non-zero - the channel supports keep alives
    0 - the channel doesn't support keep alives

--*/
{
    HTTP2ClientInChannel *InChannel;
    BOOL IsKeepAlive;
    HTTP2ChannelPointer *InChannelPtr;

    if (IsReplacementChannel)
        InChannelPtr = &InChannels[GetNonDefaultInChannelSelector()];
    else
        InChannelPtr = &InChannels[0];

    InChannel = (HTTP2ClientInChannel *)InChannelPtr->LockChannelPointer();

    // nobody can abort the connection here
    ASSERT (InChannel != NULL);

    IsKeepAlive = InChannel->IsKeepAlive();

    InChannelPtr->UnlockChannelPointer();

    return IsKeepAlive;
}

BOOL HTTP2ClientVirtualConnection::IsOutChannelKeepAlive (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Checks whether an out channel supports keep alives
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    non-zero - the channel supports keep alives
    0 - the channel doesn't support keep alives

--*/
{
    HTTP2ClientOutChannel *OutChannel;
    BOOL IsKeepAlive;
    HTTP2ChannelPointer *OutChannelPtr;

    if (IsReplacementChannel)
        OutChannelPtr = &OutChannels[GetNonDefaultOutChannelSelector()];
    else
        OutChannelPtr = &OutChannels[0];

    OutChannel = (HTTP2ClientOutChannel *)OutChannelPtr->LockChannelPointer();
    // nobody can abort the connection here
    ASSERT (OutChannel != NULL);

    IsKeepAlive = OutChannel->IsKeepAlive();

    OutChannelPtr->UnlockChannelPointer();

    return IsKeepAlive;
}

ULONG HTTP2ClientVirtualConnection::GetInChannelChosenScheme (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Gets the chosen scheme for the an in channel
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    Chosen scheme

--*/
{
    HTTP2ClientInChannel *InChannel;
    ULONG ChosenScheme;
    HTTP2ChannelPointer *InChannelPtr;

    if (IsReplacementChannel)
        InChannelPtr = &InChannels[GetNonDefaultInChannelSelector()];
    else
        InChannelPtr = &InChannels[0];

    InChannel = (HTTP2ClientInChannel *)InChannelPtr->LockChannelPointer();
    // nobody can abort the connection here
    ASSERT (InChannel != NULL);

    ChosenScheme = InChannel->GetChosenAuthScheme();

    InChannelPtr->UnlockChannelPointer();

    return ChosenScheme;
}

ULONG HTTP2ClientVirtualConnection::GetOutChannelChosenScheme (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Gets the chosen scheme for an out channel
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    Chosen scheme

--*/
{
    HTTP2ClientOutChannel *OutChannel;
    ULONG ChosenScheme;
    HTTP2ChannelPointer *OutChannelPtr;

    if (IsReplacementChannel)
        OutChannelPtr = &OutChannels[GetNonDefaultOutChannelSelector()];
    else
        OutChannelPtr = &OutChannels[0];

    OutChannel = (HTTP2ClientOutChannel *)OutChannelPtr->LockChannelPointer();
    // nobody can abort the connection here
    ASSERT (OutChannel != NULL);

    ChosenScheme = OutChannel->GetChosenAuthScheme();

    OutChannelPtr->UnlockChannelPointer();

    return ChosenScheme;
}

BOOL HTTP2ClientVirtualConnection::IsInChannelPositiveWithWait (
    void
    )
/*++

Routine Description:

    Checks if the in channel has come in with positive result. If
    not, it waits a bit and tries again. If not again, return FALSE.

Arguments:

Return Value:

    non-zero if the in channel came in positive.
    0 otherwise.

--*/
{
    if ((InOpenStatus == RPC_S_OK)
        || (InOpenStatus == RPC_P_AUTH_NEEDED))
        return TRUE;

    Sleep(100);

    return ((InOpenStatus == RPC_S_OK)
        || (InOpenStatus == RPC_P_AUTH_NEEDED));
}

/*********************************************************************
    Switching Layer
 *********************************************************************/

RPC_STATUS
RPC_ENTRY
HTTP_SyncRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Perform a sync recv on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - transport connection
    Buffer - if successful, points to a buffer containing the next PDU.
    BufferLength -  if successful, contains the length of the message.
    Timeout - the amount of time to wait for the receive. If -1, we wait
        infinitely.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    if (BaseObject->id == HTTP)
        {
        return WS_SyncRecv(ThisConnection,
            pBuffer,
            pBufferLength,
            dwTimeout
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        RpcStatus = VirtualConnection->SyncRecv((BYTE **)pBuffer,
            (ULONG *)pBufferLength,
            dwTimeout);

        VALIDATE(RpcStatus)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_RECEIVE_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_TIMEOUT
            }
      	 CORRUPTION_VALIDATE
            {
            RPC_S_PROTOCOL_ERROR
         } CORRUPTION_END_VALIDATE;

        return RpcStatus;
        }
}

RPC_STATUS 
RPC_ENTRY 
HTTP_Abort (
    IN RPC_TRANSPORT_CONNECTION Connection
    )
/*++

Routine Description:

    Aborts an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    Connection - transport connection

Return Value:

    RPC_S_OK

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) Connection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return WS_Abort(Connection);
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)Connection;

        if ((VirtualConnection->type & TYPE_MASK) == CLIENT)
            {
            ((HTTP2ClientVirtualConnection *)VirtualConnection)->HTTP2ClientVirtualConnection::Abort();
            }
        else
            {
            ASSERT((VirtualConnection->type & TYPE_MASK) == SERVER);
            ((HTTP2ServerVirtualConnection *)VirtualConnection)->HTTP2ServerVirtualConnection::Abort();
            }
        return RPC_S_OK;
        }
}

RPC_STATUS
RPC_ENTRY
HTTP_Close (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Aborts an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - transport connection
    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

    RPC_S_OK

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_OPERATION_CLOSE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)ThisConnection);

#if DBG
    // verify the list is still ok
    TransportProtocol::AssertProtocolListIntegrity(BaseObject);
#endif  // DBG

    if (BaseObject->id == HTTP)
        {
        RpcStatus = WS_Close(ThisConnection,
            fDontFlush
            );
        }
    else if (BaseObject->id == INVALID_PROTOCOL_ID)
        {
        // object was never completely initialized - just return
        RpcStatus = RPC_S_OK;
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        // the object may have been destroyed by now - cannot use
        // virtual functions. Determine statically the type
        // and call the function to cleanup (it knows how to
        // deal with destroyed objects)
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        if ((VirtualConnection->type & TYPE_MASK) == CLIENT)
            {
            ((HTTP2ClientVirtualConnection *)VirtualConnection)->HTTP2ClientVirtualConnection::Close(fDontFlush);
            }
        else
            {
            ASSERT((VirtualConnection->type & TYPE_MASK) == SERVER);
            ((HTTP2ServerVirtualConnection *)VirtualConnection)->HTTP2ServerVirtualConnection::Close(fDontFlush);
            }
        RpcStatus = RPC_S_OK;
        }

    LOG_FN_OPERATION_EXIT(HTTP2LOG_OPERATION_CLOSE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)BaseObject->id);

    return RpcStatus;
}


RPC_STATUS
RPC_ENTRY
HTTP_Send(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Length,
    BUFFER Buffer,
    PVOID SendContext
    )
/*++

Routine Description:

    Does a send on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - The connection to send the data on.
    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer to use as the HTTP2SendContext for
        this operation.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return CO_Send(ThisConnection,
            Length,
            Buffer,
            SendContext
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->Send(Length,
            Buffer,
            SendContext
            );
        }
}

RPC_STATUS
RPC_ENTRY
HTTP_Recv(
    RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    Does a receive on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - A connection without a read pending on it.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return CO_Recv(ThisConnection);
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->Receive();
        }
}

RPC_STATUS
RPC_ENTRY
HTTP_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Does a sync send on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    Connection - The connection to send on.
    BufferLength - The size of the buffer.
    Buffer - The data to sent.
    fDisableShutdownCheck - Normally FALSE, when true this disables
        the transport check for async shutdown PDUs.
    fDisableCancelCheck - runtime indicates no cancel
        will be attempted on this send. Can be used
        as optimization hint by the transport
    Timeout - send timeout (call timeout)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) Connection;
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    if (BaseObject->id == HTTP)
        {
        RpcStatus = WS_SyncSend(Connection,
            BufferLength,
            Buffer,
            fDisableShutdownCheck,
            fDisableCancelCheck,
            Timeout
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)Connection;

        RpcStatus = VirtualConnection->SyncSend(BufferLength,
            Buffer,
            fDisableShutdownCheck,
            fDisableCancelCheck,
            Timeout
            );
        }

    VALIDATE(RpcStatus)
        {
         RPC_S_OK,
         RPC_S_OUT_OF_MEMORY,
         RPC_S_OUT_OF_RESOURCES,
         RPC_P_RECEIVE_FAILED,
         RPC_S_CALL_CANCELLED,
         RPC_P_SEND_FAILED,
         RPC_P_CONNECTION_SHUTDOWN,
         RPC_P_TIMEOUT
        } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS
RPC_ENTRY 
HTTP_TurnOnOffKeepAlives (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - The connection to turn keep alives on on.
    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.
    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.
    Units - in what units is KATime
    KATime - how much to wait before turning on keep alives
    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we use it on the server, we must protect
        the connection against async aborts.

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return WS_TurnOnOffKeepAlives(ThisConnection,
            TurnOn,
            bProtectIO,
            Units,
            KATime,
            KAInterval
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        // don't bother if the connection is aborted. Besides shorter
        // execution, this avoids trouble where we try to perform the
        // operation on an aborted connection and we run into all
        // sorts of problems. 
        if (VirtualConnection->IsAborted())
            return RPC_S_OK;

        return VirtualConnection->TurnOnOffKeepAlives(TurnOn,
            bProtectIO,
            FALSE,      // IsFromUpcall
            Units,
            KATime,
            KAInterval
            );
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_QueryClientAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.

Arguments:

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return TCP_QueryClientAddress(ThisConnection,
            pNetworkAddress
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->QueryClientAddress(pNetworkAddress);
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_QueryLocalAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return TCP_QueryLocalAddress(ThisConnection,
            Buffer,
            BufferSize,
            AddressFormat
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->QueryLocalAddress(Buffer,
            BufferSize,
            AddressFormat
            );
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_QueryClientId(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is supposed to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

Arguments:

    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return TCP_QueryClientId(ThisConnection,
            ClientProcess
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->QueryClientId(ClientProcess);
        }
}

RPC_STATUS
RPC_ENTRY
HTTP_QueryClientIpAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT RPC_CLIENT_IP_ADDRESS *ClientIpAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a SOCKADDR.

Arguments:

    ThisConnection - The server connection of interest.

    ClientIpAddress - the buffer to store the address to.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return TCP_QueryClientIpAddress(ThisConnection,
            ClientIpAddress
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->QueryClientIpAddress(ClientIpAddress);
        }
}

/*********************************************************************
    HTTP Transport Interface
 *********************************************************************/

const int HTTPClientConnectionSize = max(sizeof(WS_CLIENT_CONNECTION), sizeof(WS_SAN_CLIENT_CONNECTION));
const int HTTP2ClientConnectionSize = sizeof(HTTP2ClientVirtualConnection);

const int HTTPServerConnectionSize = max(sizeof(WS_CONNECTION), sizeof(WS_SAN_CONNECTION));
const int HTTP2ServerConnectionSize = max(sizeof(HTTP2ServerVirtualConnection), sizeof(WS_HTTP2_INITIAL_CONNECTION));

const RPC_CONNECTION_TRANSPORT
HTTP_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    HTTP_TOWER_ID,
    HTTP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_http"),
    "593",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    WS_GetNetworkAddressVector,
    sizeof(WS_ADDRESS),
    max(HTTPClientConnectionSize, HTTP2ClientConnectionSize),
    max(HTTPServerConnectionSize, HTTP2ServerConnectionSize),
    sizeof(HTTP2SendContext),
    sizeof(HTTPResolverHint),
    HTTP_MAX_SEND,
    HTTP_Initialize,
    0, // InitComplete,
    HTTP_Open,
    0, // No SendRecv on winsock
    HTTP_SyncRecv,
    HTTP_Abort,
    HTTP_Close,
    HTTP_Send,
    HTTP_Recv,
    HTTP_SyncSend,
    HTTP_TurnOnOffKeepAlives,
    HTTP_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    HTTP_QueryClientAddress,
    HTTP_QueryLocalAddress,
    HTTP_QueryClientId,
    HTTP_QueryClientIpAddress,
    0, // Impersonate
    0, // Revert
    HTTP_FreeResolverHint,
    HTTP_CopyResolverHint,
    HTTP_CompareResolverHint,
    HTTP_SetLastBufferToFree
    };


/*********************************************************************
    HTTP2ProxyServerSideChannel
 *********************************************************************/

RPC_STATUS HTTP2ProxyServerSideChannel::InitializeRawConnection (
    IN RPC_CHAR *ServerName,
    IN USHORT ServerPort,
    IN ULONG ConnectionTimeout,
    IN I_RpcProxyIsValidMachineFn IsValidMachineFn
    )
/*++

Routine Description:

    Initializes a raw connection.

Arguments:

    ServerName - the server to connect to.

    ServerPort - which port on that server to use

    ConnectionTimeout - the connection timeout to use.

    IsValidMachineFn - a callback function to verify if the
        target machine/port are not blocked

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTPResolverHint DummyHint;

    RpcStatus = TCPOrHTTP_Open(RawConnection,
        ServerName,
        ServerPort,
        ConnectionTimeout,
        0,      // SendBufferSize
        0,      // RecvBufferSize
        &DummyHint,
        FALSE,      // HintWasInitialized
        10 * 60 * 60,   // 10 minutes
        TRUE,    // fHTTP2Open
        IsValidMachineFn
        );

    return RpcStatus;    
}

/*********************************************************************
    HTTP2TimeoutTargetConnection
 *********************************************************************/

RPC_STATUS HTTP2TimeoutTargetConnection::SetTimeout (
    IN ULONG Timeout,
    IN TimerContext *pTimer
    )
/*++

Routine Description:

    Called to setup a one time timer. Caller must make
    sure this function is synchronized with CancelTimeout and
    must make sure we don't schedule a timer behind an aborting
    thread (i.e. a timer fires after the object goes away).

Arguments:

    Timeout - interval before the timer fires

    pTimer - which timer do we refer to.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    BOOL Result;

    VerifyValidTimer(pTimer);

    VerifyTimerNotSet(pTimer);

    Result = CreateTimerQueueTimer(&(pTimer->Handle),
        NULL,
        HTTP2TimeoutTimerCallback,
        pTimer,
        Timeout,  // time to first fire
        0,  // periodic interval
        WT_EXECUTELONGFUNCTION
        );

    if (Result == FALSE)
        return RPC_S_OUT_OF_MEMORY;

    return RPC_S_OK;
}

void HTTP2TimeoutTargetConnection::CancelTimeout (
    IN TimerContext *pTimer
    )
/*++

Routine Description:

    Called to cancel a timer. The function will not return until
    the timer callbacks have been drained. Caller must ensure
    that this method is synchronized with SetTimeout

Arguments:

    pTimer - which timer do we refer to.

Return Value:

--*/
{
    HANDLE LocalTimerHandle;
    BOOL Result;
    unsigned int Retries = 0;

    VerifyValidTimer(pTimer);

    LocalTimerHandle = InterlockedExchangePointer(&(pTimer->Handle), NULL);

    // if the timer already fired there is nothing to do here.
    if (LocalTimerHandle == NULL)
        return;

    do 
        {
        Result = DeleteTimerQueueTimer(NULL,
            LocalTimerHandle,
            INVALID_HANDLE_VALUE    // tell the timer function to wait for all callbacks
                                    // to complete before returning
            );

        //
        // This cannot fail unless we give it invalid parameters or
        // we are out of memory.  Retry on out of memory since there is nothing we can do.
        // If after a few attempts we still fail, we need to halt to avoid a later AV.
        //
        // From Rob Earhart:
        // 485863 covers one of the allocs... the entire module is pretty bad code;
        // I'm planning to just replace it (and the API, too).
        //

        if (!Result)
            {
            ASSERT(GetLastError() == ERROR_NOT_ENOUGH_MEMORY);
            DbgPrint("RPC: DeleteTimerQueueTimer failed: %d\n", GetLastError());
            Sleep(10);
            }
        Retries++;
        }
    while (!Result && Retries < 10);

    if (!Result)
        {
        DbgPrint("RPC: DeleteTimerQueueTimer repeatedly failed - execution can't proceed.\n");
        DbgBreakPoint();
        }
}

/*********************************************************************
    HTTP2ProxyVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2ProxyVirtualConnection::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate send complete.

Arguments:

    EventStatus - status of the operation

    SendContext - the context for the send complete

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyInChannel *InProxyInChannel;
    HTTP2OutProxyInChannel *OutProxyInChannel;
    BOOL LocalIsInProxy;
    BOOL IssueAck;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    BOOL UnlockPointer;

    VerifyValidChannelId(ChannelId);

    if ((EventStatus == RPC_S_OK)
        && (SendContext->TrafficType == http2ttData))
        {
        ChannelPtr = MapSendContextUserDataToChannelPtr(SendContext->UserData);
        if (ChannelPtr)
            {
            UnlockPointer = FALSE;
            IssueAck = FALSE;
            LocalIsInProxy = IsInProxy();
            if (LocalIsInProxy)
                {
                InProxyInChannel = (HTTP2InProxyInChannel *)ChannelPtr->LockChannelPointer();
                if (InProxyInChannel)
                    {
                    UnlockPointer = TRUE;
                    InProxyInChannel->BytesConsumedNotification (SendContext->maxWriteBuffer,
                        FALSE,      // OwnsMutex
                        &IssueAck,
                        &BytesReceivedForAck,
                        &WindowForAck
                        );
                    }
                }
            else
                {
                OutProxyInChannel = (HTTP2OutProxyInChannel *)ChannelPtr->LockChannelPointer();
                if (OutProxyInChannel)
                    {
                    UnlockPointer = TRUE;
                    OutProxyInChannel->BytesConsumedNotification (SendContext->maxWriteBuffer,
                        FALSE,      // OwnsMutex
                        &IssueAck,
                        &BytesReceivedForAck,
                        &WindowForAck
                        );
                    }
                }

            if (IssueAck)
                {
                // we need to issue a flow control ack to the peer. InProxy uses
                // forwarding, out proxy sends ack directly
                if (LocalIsInProxy)
                    {
                    EventStatus = InProxyInChannel->ForwardFlowControlAck(
                        BytesReceivedForAck,
                        WindowForAck
                        );
                    }
                else
                    {
                    EventStatus = OutProxyInChannel->ForwardFlowControlAck(
                        BytesReceivedForAck,
                        WindowForAck
                        );
                    }

#if DBG_ERROR
                DbgPrint("%s proxy issuing flow control ack: %d, %d\n", 
                    LocalIsInProxy ? "IN" : "OUT",
                    BytesReceivedForAck, WindowForAck);
#endif
                }

            if (UnlockPointer)
                ChannelPtr->UnlockChannelPointer();
            }
        else
            {
#if DBG
            DbgPrint("RPCRT4: %d: Channel for User Data %d on connection %p not found\n", 
                GetCurrentProcessId(),
                SendContext->UserData,
                this
                );
#endif
            }
        }

    // successful sends are no-op. Failed sends cause abort. Just
    // turn around the operation status after freeing the packet
    FreeSendContextAndPossiblyData(SendContext);

    // ok to return any error code. See Rule 12
    return EventStatus;
}

void HTTP2ProxyVirtualConnection::Abort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP connection and disconnects the channels.
    Must only come from neutral context.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_PROXY_VC, 0);

    // abort the channels themselves
    AbortChannels(RPC_P_CONNECTION_SHUTDOWN);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return;

    DisconnectChannels(FALSE, 0);
}

void HTTP2ProxyVirtualConnection::DisconnectChannels (
    IN BOOL ExemptChannel,
    IN int ExemptChannelId
    )
/*++

Routine Description:

    Disconnects all channels. Must be called from runtime
    or neutral context. Cannot be called from upcall or
    submit context unless an exempt channel is given
    Note that call must synchronize to ensure we're the only
    thread doing the disconnect

Arguments:

    ExemptChannel - non-zero if ExemptChannelId contains a
        valid exempt channel id. FALSE otherwise.

    ExemptChannelId - if ExemptChannel is non-zero, this argument
        is the id of a channel that will be disconnected, but not
        synchronized with up calls.
        If ExampleChannel is FALSE, this argument is undefined

Return Value:

--*/
{
    while (RundownBlock.GetInteger() > 0)
        {
        Sleep(2);
        }

    RemoveConnectionFromCookieCollection();

    HTTP2VirtualConnection::DisconnectChannels(ExemptChannel,
        ExemptChannelId
        );

    // cancel the timeouts after we have disconnected the channels.
    // Since all timeouts are setup within upcalls
    CancelAllTimeouts();
}

RPC_STATUS HTTP2ProxyVirtualConnection::AddConnectionToCookieCollection (
    void
    )
/*++

Routine Description:

    Adds this virtual connection to the cookie collection

Arguments:

Return Value:

--*/
{
    CookieCollection *ProxyCookieCollection;
    HTTP2VirtualConnection *ExistingConnection;

    if (IsInProxy())
        ProxyCookieCollection = GetInProxyCookieCollection();
    else
        ProxyCookieCollection = GetOutProxyCookieCollection();

    ProxyConnectionCookie = new HTTP2ServerCookie(EmbeddedConnectionCookie);
    if (ProxyConnectionCookie == NULL)
        return RPC_S_OUT_OF_MEMORY;

    ProxyConnectionCookie->SetConnection(this);
    IsConnectionInCollection = TRUE;

    ProxyCookieCollection->LockCollection();
    ExistingConnection = ProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);

    if (ExistingConnection == NULL)
        ProxyCookieCollection->AddElement(ProxyConnectionCookie);

    ProxyCookieCollection->UnlockCollection();

    if (ExistingConnection)
        return RPC_S_PROTOCOL_ERROR;
    else
        return RPC_S_OK;
}

void HTTP2ProxyVirtualConnection::RemoveConnectionFromCookieCollection (
    void
    )
/*++

Routine Description:

    Removes this virtual connection from the cookie collection

Arguments:

Return Value:

Note:

    This function must be called exactly once and is not thread safe.

--*/
{
    CookieCollection *ProxyCookieCollection;
    BOOL DeleteProxyConnectionCookie;

    if (IsConnectionInCollection)
        {
        ASSERT(ProxyConnectionCookie);
        DeleteProxyConnectionCookie = FALSE;

        if (IsInProxy())
            ProxyCookieCollection = GetInProxyCookieCollection();
        else
            ProxyCookieCollection = GetOutProxyCookieCollection();

        ProxyCookieCollection->LockCollection();

        if (ProxyConnectionCookie->RemoveRefCount())
            {
            ProxyCookieCollection->RemoveElement(ProxyConnectionCookie);
            DeleteProxyConnectionCookie = TRUE;
            }
        else
            {
            // the only we we can have a non-zero refcount is if the same
            // machine fakes a web farm.
            ASSERT(ActAsSeparateMachinesOnWebFarm);
            }

        ProxyCookieCollection->UnlockCollection();

        if (DeleteProxyConnectionCookie)
            {
            // delete is outside the lock
            delete ProxyConnectionCookie;
            }
        }
}

void HTTP2ProxyVirtualConnection::TimeoutExpired (
    IN TimerContext *pTimer
    )
/*++

Routine Description:

    A timeout expired before we cancelled the timer. Abort the connection.

Arguments:

Return Value:

--*/
{
    BOOL Result;

    Result = AbortAndDestroy(FALSE,      // IsFromChannel
        0,      // CallingChannelId
        RPC_P_TIMEOUT
        );

    // if somebody is already destroying it, just return
    if (Result == FALSE)
        return;

    // now 'this' is a pointer disconnected from everybody
    // that we can destroy at our leisure
    delete this;

    // Once we mark the timer as expired, we are no longer protected from
    // the virtual connection being freed during the timer callback.
    // We can't touch the virtual connection after this call.
    TimerExpiredNotify(pTimer);
}

RPC_STATUS HTTP2ProxyVirtualConnection::ProxyForwardDataTrafficToDefaultChannel (
    IN BOOL IsInChannel,
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ULONG ChannelId
    )
/*++

Routine Description:

    Forwards the given packet on the given channel. Overloaded
    version for the proxy as we need to do special things for
    the proxy. It can be used for data traffic only. RTS packets
    cannot use this method, as the TrafficType on the outgoing
    packet will be initialized to http2ttData.

Arguments:

    IsInChannel - if non-zero, forward to default in channel.
        If 0, forward to default out channel

    Packet - the packet to forward. Ownership of the packet
        passes to this function regardless of success or
        failure.

    PacketLength - the length of the packet to forward

    ChannelId - the id of the channel on which we received the
        packet.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;

    SendContext = AllocateAndInitializeContextFromPacket(Packet,
        PacketLength
        );

    if (SendContext == NULL)
        {
        RpcFreeBuffer(Packet);
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        }
    else
        {
        ASSERT(SendContext->Flags == 0);
        SendContext->Flags = SendContextFlagProxySend;
        SendContext->UserData = ConvertChannelIdToSendContextUserData(ChannelId);
        // make sure we can find it after that
        ASSERT(MapSendContextUserDataToChannelPtr(SendContext->UserData) != NULL);
        RpcStatus = SendTrafficOnDefaultChannel(IsInChannel,  // IsInChannel 
            SendContext
            );

        // this is a proxy channel - it should not recycle
        ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

        if (RpcStatus != RPC_S_OK)
            {
            FreeSendContextAndPossiblyData(SendContext);
            }
        }

    return RpcStatus;
}

/*********************************************************************
    HTTP2InProxyInChannel
 *********************************************************************/

RPC_STATUS HTTP2InProxyInChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack to the client through the server

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    return ForwardFlowControlAckOnDefaultChannel(FALSE,    // IsInChannel
        fdClient,
        BytesReceivedForAck,
        WindowForAck
        );
}

/*********************************************************************
    HTTP2InProxyOutChannel
 *********************************************************************/

RPC_STATUS HTTP2InProxyOutChannel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support last packet notifications

Arguments:

    LastSendContext - the context for the last send

Return Value:

    The value to return to the bottom channel

--*/
{
    // just return ok to caller. When the server aborts the connection,
    // we will abort too.
    return RPC_S_OK;
}

RPC_STATUS HTTP2InProxyOutChannel::SetRawConnectionKeepAlive (
    IN ULONG KeepAliveInterval      // in milliseconds
    )
/*++

Routine Description:

    Sets the raw connection keep alive. On abort connections
    failures are ignored.

Arguments:

    KeepAliveInterval - keep alive interval in milliseconds

Return Value:

    The value to return to the bottom channel

--*/
{
    RPC_STATUS RpcStatus;
    WS_HTTP2_CONNECTION *RawConnection;
    KEEPALIVE_TIMEOUT KATimeout;

    RpcStatus = BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RPC_S_OK;
    
    RawConnection = GetRawConnection();
    KATimeout.Milliseconds = KeepAliveInterval;

    // turn off the old interval
    RpcStatus = WS_TurnOnOffKeepAlives(RawConnection,
        FALSE,      // TurnOn
        FALSE,      // bProtectIO
        tuMilliseconds,
        KATimeout,
        DefaultClientNoResponseKeepAliveInterval
        );

    // turning off should always succeed
    ASSERT(RpcStatus == RPC_S_OK);

    // turn on the new interval
    // start with the keep alives immediately and proceed until the specified interval
    RpcStatus = WS_TurnOnOffKeepAlives(RawConnection,
        TRUE,       // TurnOn
        FALSE,      // bProtectIO
        tuMilliseconds,
        KATimeout,
        KeepAliveInterval
        );

    FinishSubmitAsync();

    return RpcStatus;
}

/*********************************************************************
    HTTP2InProxyVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2InProxyVirtualConnection::InitializeProxyFirstLeg (
    IN USHORT *ServerAddress,
    IN USHORT *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface,
    void **IISContext
    )
/*++

Routine Description:

    Initialize the proxy (first leg - second leg will happen when we
        receive first RTS packet).

Arguments:

    ServerAddress - unicode pointer string to the server network address.

    ServerPort - unicode pointer string to the server port

    ConnectionParameter - the extension control block in this case

    ProxyCallbackInterface - a callback interface to the proxy to perform
        various proxy specific functions

    IISContext - on output (success only) it must be initialized to
        the bottom IISChannel for the InProxy.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2InProxyInChannel *NewInChannel;
    int InChannelId;
    int ServerAddressLength;    // in characters + terminating 0

    // initialize in channel
    RpcStatus = AllocateAndInitializeInChannel(ConnectionParameter,
        &NewInChannel,
        IISContext
        );

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    SetFirstInChannel(NewInChannel);

    this->ProxyCallbackInterface = ProxyCallbackInterface;
    this->ConnectionParameter = ConnectionParameter;

    ServerAddressLength = RpcpStringLength(ServerAddress) + 1;
    ServerName = new RPC_CHAR [ServerAddressLength];

    if (ServerName == NULL)
        {
        Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpMemoryCopy(ServerName, ServerAddress, ServerAddressLength * 2);

    RpcStatus = EndpointToPortNumber(ServerPort, this->ServerPort);

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        // fall through with error
        }

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::StartProxy (
    void
    )
/*++

Routine Description:

    Kicks off listening on the proxy

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2InProxyInChannel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svClosed, 1, 0);
    State.State = http2svClosed;    // move to closed state expecting the opening RTS packet

    Channel = LockDefaultInChannel(&ChannelPtr);

    ASSERT(Channel != NULL);  // we cannot be disconnected now

    RpcStatus = Channel->Receive(http2ttRaw);

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

C_ASSERT(sizeof(SOCKADDR_IN) == MAX_IPv4_ADDRESS_SIZE);
C_ASSERT(sizeof(SOCKADDR_IN6) == MAX_IPv6_ADDRESS_SIZE);

RPC_STATUS HTTP2InProxyVirtualConnection::InitializeProxySecondLeg (
    void
    )
/*++

Routine Description:

    Initialize the proxy (second leg - first leg has happened when we
        received the HTTP establishment header).

Arguments:

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2InProxyOutChannel *NewOutChannel;
    int OutChannelId;
    int ServerAddressLength;    // in characters + terminating 0
    char ClientIpAddress[16];
    ULONG ClientIpAddressSize;
    ADDRINFO DnsHint;
    ADDRINFO *AddrInfo;
    int err;

    // initialize out channel
    RpcStatus = AllocateAndInitializeOutChannel(
        &NewOutChannel
        );

    if (RpcStatus != RPC_S_OK)
        {
        // this will always come from an upcall. Just return failure
        return RpcStatus;
        }

    SetFirstOutChannel(NewOutChannel);

    RpcStatus = ProxyCallbackInterface->GetConnectionTimeoutFn(&IISConnectionTimeout);
    if (RpcStatus != RPC_S_OK)
        {
        // this will always come from an upcall. Just return failure
        return RpcStatus;
        }

    // convert it from seconds to milliseconds
    IISConnectionTimeout *= 1000;

    ClientIpAddressSize = sizeof(ClientIpAddress);
    RpcStatus = ProxyCallbackInterface->GetClientAddressFn(
        ConnectionParameter,
        ClientIpAddress,
        &ClientIpAddressSize
        );

    ASSERT(RpcStatus != ERROR_INSUFFICIENT_BUFFER);

    if (RpcStatus != RPC_S_OK)
        {
        // this will always come from an upcall. Just return failure
        return RpcStatus;
        }

    RpcpMemorySet(&DnsHint, 0, sizeof(ADDRINFO));

    DnsHint.ai_flags = AI_NUMERICHOST;
    DnsHint.ai_family = PF_UNSPEC;

    err = getaddrinfo(ClientIpAddress, 
        NULL, 
        &DnsHint,
        &AddrInfo);

    // make sure IIS doesn't feed us garbage IP address
    if (err != ERROR_SUCCESS)
        {
        VALIDATE (GetLastError())
            {
            ERROR_OUTOFMEMORY,
            ERROR_NOT_ENOUGH_MEMORY
            } END_VALIDATE;
        // this will always come from an upcall. Just return failure
        return RPC_S_OUT_OF_MEMORY;
        }

    ASSERT(AddrInfo->ai_family == AF_INET);

    ClientAddress.AddressType = catIPv4;
    RpcpCopyIPv4Address((SOCKADDR_IN *)AddrInfo->ai_addr, (SOCKADDR_IN *)&ClientAddress.u);

    freeaddrinfo(AddrInfo);

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error

    Buffer - buffer received

    BufferLength - length of buffer received

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    RPC_STATUS RpcStatus;
    BOOL BufferFreed = FALSE;
    BOOL MutexCleared;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *ChannelPtr2;
    HTTP2InProxyOutChannel *OutChannel;
    HTTP2InProxyInChannel *InChannel;
    HTTP2InProxyInChannel *InChannel2;
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;
    CookieCollection *InProxyCookieCollection;
    HTTP2InProxyVirtualConnection *ExistingConnection;
    HTTP2Cookie NewChannelCookie;
    HTTP2SendContext *EmptyRTS;
    int NonDefaultSelector;
    int DefaultSelector;
    HTTP2SendContext *D3_A2Context;
    HTTP2OtherCmdPacketType PacketType;
    int i;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2Cookie CookieForChannel;
    ULONG ServerReceiveWindowSize;
    HTTP2SendContext *SendContext;
    ULONG DefaultInChannelId;
    ULONG NewProtocolVersion;


    VerifyValidChannelId(ChannelId);

    if (EventStatus == RPC_S_OK)
        {
        // N.B. All recieve packets are guaranteed to be
        // validated up to the common conn packet size
        if (IsRTSPacket(Buffer))
            {
            // Intermediate versions of .NET Server 2003 and 
            // all versions of Windows XPSP1 send D4/A7 without
            // version information (old D4/A7). .NET Server 2003
            // RTM and later send D4/A7 with version information
            // (new D4/A7). Check for new D4/A7 and convert it
            // to D4/A8 if necessary
            if (IsNewD4_A7Packet (Buffer,
                BufferLength,
                fdServer,
                &NewProtocolVersion))
                {
                // We know that the new protocol version cannot
                // be higher than ours because the new guy in D4 (the
                // new out proxy) can only dumb it down.
                CORRUPTION_ASSERT (NewProtocolVersion <= ProtocolVersion);
                if (NewProtocolVersion > ProtocolVersion)
                    {
                    RpcFreeBuffer(Buffer);
                    return RPC_S_PROTOCOL_ERROR;
                    }
                ProtocolVersion = NewProtocolVersion;
                ConvertNewD4_A7ToD4_A8 (Buffer,
                    (ULONG *)&BufferLength);
                RpcStatus = RPC_P_PACKET_NEEDS_FORWARDING;
                }
            else
            {
                RpcStatus = CheckPacketForForwarding(Buffer,
                    BufferLength,
                    fdInProxy
                    );
                }
            }

        if (IsRTSPacket(Buffer) && (RpcStatus != RPC_P_PACKET_NEEDS_FORWARDING))
            {
            // RTS packet - check what we need to do with it
            if (IsOtherCmdPacket(Buffer, BufferLength))
                {
                if (IsOutChannel(ChannelId))
                    {
                    // the only other cmd we expect on the out channel in the proxy are
                    // flow control acks
                    RpcStatus = ParseAndFreeFlowControlAckPacket (Buffer,
                        BufferLength,
                        &BytesReceivedForAck,
                        &WindowForAck,
                        &CookieForChannel
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus != RPC_S_OK)
                        return RpcStatus;

                    // notify the channel
                    ChannelPtr = GetChannelPointerFromId(ChannelId);
                    OutChannel = (HTTP2InProxyOutChannel *)ChannelPtr->LockChannelPointer();
                    if (OutChannel == NULL)
                        return RPC_P_CONNECTION_SHUTDOWN;

                    RpcStatus = OutChannel->FlowControlAckNotify(BytesReceivedForAck,
                        WindowForAck
                        );

                    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus != RPC_S_OK)
                        return RpcStatus;

                    // post another receive
                    RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                        http2ttRaw
                        );

                    if (RpcStatus != RPC_S_OK)
                        return RpcStatus;

                    return RPC_P_PACKET_CONSUMED;
                    }

                RpcStatus = GetOtherCmdPacketType(Buffer, 
                    BufferLength,
                    &PacketType
                    );

                if (RpcStatus == RPC_S_OK)
                    {
                    switch (PacketType)
                        {
                        case http2ocptKeepAliveChange:
                            RpcStatus = ParseAndFreeKeepAliveChangePacket(Buffer,
                                BufferLength,
                                &CurrentClientKeepAliveInterval
                                );

                            BufferFreed = TRUE;

                            if (RpcStatus == RPC_S_OK)
                                {
                                if (CurrentClientKeepAliveInterval == 0)
                                    CurrentClientKeepAliveInterval = DefaultClientKeepAliveInterval;

                                // by now the keep alive interval has been set on the connection.
                                // Any new channels will be taken care of by the virtual connection
                                // We need to go in and effect this change on the existing channels
                                for (i = 0; i < 2; i ++)
                                    {
                                    OutChannel = (HTTP2InProxyOutChannel *)OutChannels[0].LockChannelPointer();
                                    if (OutChannel)
                                        {
                                        RpcStatus = OutChannel->SetRawConnectionKeepAlive(CurrentClientKeepAliveInterval);
                                        OutChannels[0].UnlockChannelPointer();
                                        if (RpcStatus != RPC_S_OK)
                                            break;
                                        }
                                    }
                                }

                            if (RpcStatus == RPC_S_OK)
                                {
                                // post another receive
                                RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                                    http2ttRaw
                                    );

                                if (RpcStatus == RPC_S_OK)
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                }
                            // return the status code - success or error, both get
                            // handled below us
                            return RpcStatus;
                            break;

                        default:
                            ASSERT(0);
                            return RPC_S_INTERNAL_ERROR;
                        }
                    }
                }

            MutexCleared = FALSE;
            State.Mutex.Request();
            switch (State.State)
                {
                case http2svClosed:
                    // for closed states, we must receive
                    // stuff only on the default in channel
                    ASSERT(IsDefaultInChannel(ChannelId));

                    CurrentPosition = ValidateRTSPacketCommon(Buffer,
                        BufferLength
                        );

                    if (CurrentPosition == NULL)
                        {
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RTS = (rpcconn_tunnel_settings *)Buffer;
                    if ((RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL) == 0)
                        {
                        RpcStatus = ParseAndFreeD1_B1(Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &InChannelCookies[0],
                            &ChannelLifetime,
                            &AssociationGroupId,
                            &CurrentClientKeepAliveInterval
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            break;

                        if (CurrentClientKeepAliveInterval < MinimumClientKeepAliveInterval)
                            {
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svB3W, 1, 0);
                        State.State = http2svB3W;
                        State.Mutex.Clear();
                        MutexCleared = TRUE;

                        RpcStatus = InitializeProxySecondLeg();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = ConnectToServer();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = SendD1_B2ToServer();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = PostReceiveOnChannel(&InChannels[0], http2ttRaw);

                        if (RpcStatus != RPC_S_OK)
                            break;

                        DefaultClientKeepAliveInterval = CurrentClientKeepAliveInterval;

                        OutChannel = LockDefaultOutChannel(&ChannelPtr);
                        if (OutChannel == NULL)
                            {
                            RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                            break;
                            }

                        RpcStatus = OutChannel->SetRawConnectionKeepAlive(CurrentClientKeepAliveInterval);
                        ChannelPtr->UnlockChannelPointer();

                        // fall through with the error code
                        }
                    else
                        {
                        RpcStatus = ParseAndFreeD2_A1 (Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &InChannelCookies[1],   // Old cookie - use InChannelCookies[1] 
                                                    // as temporary storage only
                            &InChannelCookies[0]    // New cookie
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            break;

                        // caller claims this is recycling for an already existing connection
                        // find out this connection
                        InProxyCookieCollection = GetInProxyCookieCollection();
                        InProxyCookieCollection->LockCollection();
                        ExistingConnection = (HTTP2InProxyVirtualConnection *)
                            InProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);
                        if (ExistingConnection == NULL || ActAsSeparateMachinesOnWebFarm)
                            {
                            // no dice. Probably we executed on a different machine on the web farm
                            // proceed as a standalone connection
                            InProxyCookieCollection->UnlockCollection();

                            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svB2W, 1, 0);
                            State.State = http2svB2W;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            RpcStatus = InitializeProxySecondLeg();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = ConnectToServer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            // posts receive on the server channel as
                            // well
                            RpcStatus = SendD2_A2ToServer();
                            if (RpcStatus != RPC_S_OK)
                                break;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            if (OutChannel == NULL)
                                {
                                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                                break;
                                }

                            RpcStatus = OutChannel->SetRawConnectionKeepAlive(CurrentClientKeepAliveInterval);
                            ChannelPtr->UnlockChannelPointer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = PostReceiveOnChannel(&InChannels[0], http2ttRaw);
                            }
                        else
                            {
                            // detach the in channel from this connection and attach
                            // it to the found connection. Grab a reference to it
                            // to prevent the case where it goes away underneath us
                            // we know that in its current state the connection is single
                            // threaded because we are in the completion path of the 
                            // only async operation

                            RpcStatus = ExistingConnection->SetTimeout(DefaultNoResponseTimeout,
                                                                       ExistingConnection->GetInChannelTimer());

                            if (RpcStatus != RPC_S_OK)
                                break;

                            ChannelPtr = GetChannelPointerFromId(ChannelId);
                            InChannel = (HTTP2InProxyInChannel *)ChannelPtr->LockChannelPointer();
                            // there is no way that somebody detached the channel here
                            ASSERT(InChannel);

                            // add a reference to keep the channel alive while we disconnect it
                            InChannel->AddReference();

                            ChannelPtr->UnlockChannelPointer();

                            // no need to drain the upcalls - we know we are the only
                            // upcall
                            ChannelPtr->FreeChannelPointer(
                                FALSE,      // DrainUpCalls
                                FALSE,      // CalledFromUpcallContext
                                FALSE,      // Abort
                                RPC_S_OK
                                );

                            DefaultSelector = ExistingConnection->DefaultInChannelSelector;
                            NonDefaultSelector = ExistingConnection->GetNonDefaultInChannelSelector();
                            if (ExistingConnection->InChannelCookies[DefaultSelector].Compare (&InChannelCookies[1]))
                                {
                                // nice try - cookies are different. Ditch the newly established channel
                                InProxyCookieCollection->UnlockCollection();
                                InChannel->RemoveReference();
                                RpcStatus = RPC_S_PROTOCOL_ERROR;
                                break;
                                }

                            InChannel->SetParent(ExistingConnection);
                            ExistingConnection->InChannels[NonDefaultSelector].SetChannel(InChannel);
                            ExistingConnection->InChannelCookies[NonDefaultSelector].SetCookie(InChannelCookies[0].GetCookie());
                            ExistingConnection->InChannelIds[NonDefaultSelector] = ChannelId;

                            // check if connection is aborted
                            if (ExistingConnection->Aborted.GetInteger() > 0)
                                {
                                InChannel->Abort(RPC_P_CONNECTION_SHUTDOWN);
                                }

                            // the extra reference that we added above passes to the existing connection
                            // However, below we party on the existing connection and we need to keep it alive
                            ExistingConnection->BlockConnectionFromRundown();
                            InProxyCookieCollection->UnlockCollection();

                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            // nuke the rest of the old connection

                            // we got to the destructive phase of the abort
                            // guard against double aborts
                            if (Aborted.Increment() > 1)
                                return FALSE;

                            // abort the channels
                            AbortChannels(RPC_P_CONNECTION_SHUTDOWN);

                            DisconnectChannels(FALSE,       // ExemptChannel
                                0                           // ExemptChannel id
                                );

                            delete this;
                            // N.B. don't touch the this pointer after here (Duh!)

                            ExistingConnection->State.Mutex.Request();
                            LogEvent(SU_HTTPv2, EV_STATE, ExistingConnection, IN_CHANNEL_STATE, http2svOpened_A5W, 1, 0);
                            ExistingConnection->State.State = http2svOpened_A5W;
                            ExistingConnection->State.Mutex.Clear();

                            // send D3/A2 to server
                            D3_A2Context = AllocateAndInitializeD3_A2(&ExistingConnection->InChannelCookies[NonDefaultSelector]);
                            if (D3_A2Context == NULL)
                                {
                                ExistingConnection->UnblockConnectionFromRundown();
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                break;
                                }

                            RpcStatus = ExistingConnection->SendTrafficOnDefaultChannel (
                                FALSE,  // IsInChannel
                                D3_A2Context
                                );

                            if (RpcStatus != RPC_S_OK)
                                {
                                FreeRTSPacket(D3_A2Context);
                                break;
                                }

                            RpcStatus = ExistingConnection->PostReceiveOnChannel(
                                &ExistingConnection->InChannels[NonDefaultSelector],
                                http2ttRaw
                                );
                            ExistingConnection->UnblockConnectionFromRundown();

                            // fall through with the obtained RpcStatus
                            }
                        }
                    break;

                case http2svOpened:
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // the only RTS packets we expect in opened state is D2/A5
                    RpcStatus = ParseD2_A5 (Buffer,
                        BufferLength,
                        &NewChannelCookie
                        );

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        {
                        RpcFreeBuffer(Buffer);
                        break;
                        }

                    // send D2/A6 immediately, and queue D2/B1 for sending
                    // Since D2/A6 is the same as D2/A5 (the packet we just
                    // received), we can just forward it
                    RpcStatus = ForwardTrafficToDefaultChannel (
                        FALSE,  // IsInChannel
                        Buffer,
                        BufferLength
                        );

                    if (RpcStatus != RPC_S_OK)
                        break;

                    // we don't own the buffer after a successful send
                    BufferFreed = TRUE;

                    OutChannel = LockDefaultOutChannel (&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    // Allocate D1/B1
                    EmptyRTS = AllocateAndInitializeEmptyRTS ();
                    if (EmptyRTS == NULL)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        break;
                        }

                    EmptyRTS->Flags = SendContextFlagSendLast;
                    RpcStatus = OutChannel->Send(EmptyRTS);
                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus == RPC_S_OK)
                        {
                        // we're done. There were no queued buffers and D1/B1
                        // was sent immediately. When the server aborts its
                        // end of the connection, we will close down
                        break;
                        }
                    else if (RpcStatus == ERROR_IO_PENDING)
                        {
                        // D1/B1 was not sent immediately. When it is sent,
                        // the LastPacketSentNotification mechanism will
                        // destroy the connection. Return success for know
                        RpcStatus = RPC_S_OK;
                        }
                    else
                        {
                        // an error occurred during sending. Free the packet and 
                        // return it back to the caller
                        FreeRTSPacket(EmptyRTS);
                        }
                    break;

                case http2svOpened_A5W:

                    // the only RTS packets we expect in opened_A5W state is D3/A5
                    RpcStatus = ParseAndFreeD3_A5 (Buffer,
                        BufferLength,
                        &NewChannelCookie
                        );

                    BufferFreed = TRUE;

                    CancelTimeout(GetInChannelTimer());

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    ASSERT(InChannels[0].IsChannelSet() && InChannels[1].IsChannelSet());

                    if (InChannelCookies[GetNonDefaultInChannelSelector()].Compare(&NewChannelCookie))
                        {
                        // abort
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    // switch channels and get rid of the old channel
                    SwitchDefaultInChannelSelector();

                    // we received all those packets on the default in channel by
                    // definition
                    DefaultInChannelId = GetDefaultInChannelId();

                    // drain the queue of buffers received on the non-default
                    // channel (new channel) and actually send them on the new default channel
                    while ((Buffer = (BYTE *) NonDefaultChannelBufferQueue.TakeOffQueue(&BufferLength)) != NULL)
                        {
                        RpcStatus = ProxyForwardDataTrafficToDefaultChannel (FALSE,     // IsInChannel
                            Buffer,
                            BufferLength,
                            DefaultInChannelId
                            );

                        if (RpcStatus != RPC_S_OK)
                            {
                            // just exit. During abort the rest of the buffers
                            // will be freed
                            break;
                            }
                        }

                    // if we finished the loop with an error, bail out
                    if (RpcStatus != RPC_S_OK)
                        break;

                    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;

                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    ChannelPtr = GetChannelPointerFromId(ChannelId);

                    InChannel2 = LockDefaultInChannel(&ChannelPtr2);
                    if (InChannel2 == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    InChannel = (HTTP2InProxyInChannel *)ChannelPtr->LockChannelPointer();
                    if (InChannel == NULL)
                        {
                        ChannelPtr2->UnlockChannelPointer();
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    InChannel->TransferReceiveStateToNewChannel(InChannel2);

                    ChannelPtr2->UnlockChannelPointer();
                    ChannelPtr->UnlockChannelPointer();

                    // detach, abort, and release lifetime reference
                    ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                        TRUE,       // CalledFromUpcallContext
                        TRUE,       // Abort
                        RPC_P_CONNECTION_SHUTDOWN   // AbortStatus
                        );

                    // return success. When the reference for this receive
                    // is removed, the channel will go away
                    RpcStatus = RPC_S_OK;
                    break;

                case http2svB2W:
                    if (IsOutChannel(ChannelId) == FALSE)
                        {
                        ASSERT(0);
                        // make sure client doesn't rush things
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RpcStatus = ParseAndFreeD2_B2(Buffer,
                        BufferLength,
                        &ServerReceiveWindowSize
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    // we know the connection is legitimate - add ourselves
                    // to the collection
                    InProxyCookieCollection = GetInProxyCookieCollection();
                    InProxyCookieCollection->LockCollection();
                    ExistingConnection = (HTTP2InProxyVirtualConnection *)
                        InProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);

                    if (ExistingConnection != NULL)
                        {
                        // the only way we will be in this protocol is if
                        // we were faking a web farm
                        ASSERT (ActAsSeparateMachinesOnWebFarm);
                        ProxyConnectionCookie = ExistingConnection->GetCookie();
                        ProxyConnectionCookie->AddRefCount();
                        ProxyConnectionCookie->SetConnection(this);

                        // remember that we are part of the cookie collection now
                        IsConnectionInCollection = TRUE;
                        }
                    else
                        {
                        // we truly didn't find anything - add ourselves.
                        RpcStatus = AddConnectionToCookieCollection ();
                        if (RpcStatus != RPC_S_OK)
                            {
                            InProxyCookieCollection->UnlockCollection();
                            break;
                            }
                        }

                    InProxyCookieCollection->UnlockCollection();

                    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // unplug the out channel to get the flow going
                    OutChannel = LockDefaultOutChannel (&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    OutChannel->SetPeerReceiveWindow(ServerReceiveWindowSize);
                    RpcStatus = OutChannel->Unplug();

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus != RPC_S_OK)
                        break;

                    RpcStatus = PostReceiveOnDefaultChannel(FALSE,  // IsInChannel
                        http2ttRaw
                        );
                    break;

                case http2svB3W:
                    ASSERT(IsDefaultOutChannel(ChannelId));
                    RpcStatus = ParseAndFreeD1_B3(Buffer,
                        BufferLength,
                        &ServerReceiveWindowSize,
                        &ProtocolVersion
                        );

                    ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_OK)
                        {
                        RpcStatus = PostReceiveOnChannel(&OutChannels[0], http2ttRaw);
                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = AddConnectionToCookieCollection();

                            if (RpcStatus == RPC_S_OK)
                                {
                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                                State.State = http2svOpened;
                                State.Mutex.Clear();
                                MutexCleared = TRUE;

                                OutChannel = (HTTP2InProxyOutChannel *)OutChannels[0].LockChannelPointer();
                                if (OutChannel)
                                    {
                                    OutChannel->SetPeerReceiveWindow(ServerReceiveWindowSize);
                                    RpcStatus = OutChannel->Unplug();
                                    OutChannels[0].UnlockChannelPointer();
                                    }
                                else
                                    {
                                    RpcStatus = RPC_P_CONNECTION_CLOSED;
                                    }
                                }
                            }
                        }

                    break;

                default:
                    ASSERT(0);
                }
            if (MutexCleared == FALSE)
                State.Mutex.Clear();
            }
        else
            {
            // data packet or RTS packet that needs forwarding. Just forward it
            if (IsDefaultOutChannel(ChannelId))
                {
                // non-RTS packet in any state from out channel
                // is a protocol error
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                }
            else
                {
                if ((State.State == http2svOpened_A5W)
                    && (!IsRTSPacket(Buffer)))
                    {
                    // this thread is racing with a thread that received D3/A5 on the default
                    // channel and is trying to switch the default channel and the state. Make
                    // the check within the mutex
                    State.Mutex.Request();
                    if (IsDefaultInChannel(ChannelId) == FALSE) 
                        {
                        // sends on non-default channel in Opened_A5W state get queued until we
                        // receive D3/A5
                        if (State.State == http2svOpened_A5W)
                            {
                            if (NonDefaultChannelBufferQueue.PutOnQueue(Buffer, BufferLength))
                                {
                                State.Mutex.Clear();
                                return RPC_S_OUT_OF_MEMORY;
                                }
                            State.Mutex.Clear();

                            // post a receive for the next buffer
                            ChannelPtr = GetChannelPointerFromId(ChannelId);

                            RpcStatus = PostReceiveOnChannel(ChannelPtr, http2ttRaw);

                            return RPC_S_OK;
                            }
                        }
                    else
                        {
                        // the channel is default - fall through to forwarding the data
                        }
                    State.Mutex.Clear();
                    }

                RpcStatus = ProxyForwardDataTrafficToDefaultChannel (FALSE,     // IsInChannel
                    Buffer,
                    BufferLength,
                    ChannelId
                    );

                // ownership of the buffer passed to ProxyForwardDataTrafficToDefaultChannel
                // regardless of success or failure. Make sure we remember that.
                BufferFreed = TRUE;

                if (RpcStatus == RPC_S_OK)
                    {
                    ChannelPtr = GetChannelPointerFromId(ChannelId);

                    RpcStatus = PostReceiveOnChannel(ChannelPtr, http2ttRaw);
                    }
                else
                    {
                    // fall through with the error
                    }
                }
            }
        }
    else
        {
        if (IsInChannel(ChannelId) && !IsDefaultInChannel(ChannelId))
            {
            // ignore errors on non-default in channels. They can go
            // away while we are still sending data to the server.
            // We will destroy the connection when the server is done
            RpcStatus = RPC_S_OK;
            }
        else
            {
            // just turn around the error code
            RpcStatus = EventStatus;
            }
        // in failure cases we don't own the buffer
        BufferFreed = TRUE;
        }

    if (BufferFreed == FALSE)
        RpcFreeBuffer(Buffer);

    return RpcStatus;
}

void HTTP2InProxyVirtualConnection::EnableIISSessionClose (
    void
    )
/*++

Routine Description:

    Enables close of the IIS session at the IISTransportChannel
    level. Simply delegates to the appropriate channel.

Arguments:

Return Value:

--*/
{
    // on the in proxy, the in channel has the IISTransport channel
    HTTP2InProxyInChannel *InChannel;
    HTTP2ChannelPointer *ChannelPtr;
    
    InChannel = LockDefaultInChannel(&ChannelPtr);
    if (InChannel == NULL)
        {
        // somebody aborted the connection - nothing to do
        return;
        }

    InChannel->EnableIISSessionClose();

    ChannelPtr->UnlockChannelPointer();
}

void HTTP2InProxyVirtualConnection::DisconnectChannels (
    IN BOOL ExemptChannel,
    IN int ExemptChannelId
    )
/*++

Routine Description:

    Disconnects all channels. Must be called from runtime
    or neutral context. Cannot be called from upcall or
    submit context unless an exempt channel is given
    Note that call must synchronize to ensure we're the only
    thread doing the disconnect

Arguments:

    ExemptChannel - non-zero if ExemptChannelId contains a
        valid exempt channel id. FALSE otherwise.

    ExemptChannelId - if ExemptChannel is non-zero, this argument
        is the id of a channel that will be disconnected, but not
        synchronized with up calls.
        If ExampleChannel is FALSE, this argument is undefined

Return Value:

--*/
{
    BYTE *Buffer;
    UINT BufferLength;

    State.Mutex.Request();
    if (State.State == http2svOpened_A5W)
        {
        while ((Buffer = (BYTE *) NonDefaultChannelBufferQueue.TakeOffQueue(&BufferLength)) != NULL)
            {
            RpcFreeBuffer(Buffer);
            }
        }
    State.Mutex.Clear();

    HTTP2ProxyVirtualConnection::DisconnectChannels(ExemptChannel,
        ExemptChannelId
        );
}

RPC_STATUS HTTP2InProxyVirtualConnection::AllocateAndInitializeInChannel (
    IN void *ConnectionParameter,
    OUT HTTP2InProxyInChannel **ReturnInChannel,
    OUT void **IISContext
    )
/*++

Routine Description:

    Allocates and initializes the in proxy in channel.

Arguments:

    ConnectionParameter - really an EXTENSION_CONTROL_BLOCK

    ReturnInChannel - on success the created in channel.

    IISContext - on output, the IISChannel pointer used as 
        connection context with IIS.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2InProxyInChannel *InChannel;
    HTTP2ProxyReceiver *ProxyReceiver;
    HTTP2PingReceiver *PingReceiver;
    HTTP2IISTransportChannel *IISChannel;
    BOOL ProxyReceiverNeedsCleanup;
    BOOL PingReceiverNeedsCleanup;
    BOOL IISChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2IISTransportChannel);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2InProxyInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyInChannel);

    ProxyReceiver = (HTTP2ProxyReceiver *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver);

    PingReceiver = (HTTP2PingReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver);

    IISChannel = (HTTP2IISTransportChannel *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    ProxyReceiverNeedsCleanup = FALSE;
    PingReceiverNeedsCleanup = FALSE;
    IISChannelNeedsCleanup = FALSE;
    RpcStatus = RPC_S_OK;

    IISChannel = new (IISChannel) HTTP2IISTransportChannel (ConnectionParameter);

    IISChannelNeedsCleanup = TRUE;

    ProxyReceiver = new (ProxyReceiver) HTTP2ProxyReceiver (HTTP2InProxyReceiveWindow,
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ProxyReceiver->HTTP2ProxyReceiver::~HTTP2ProxyReceiver();
        goto AbortAndExit;
        }

    IISChannel->SetUpperChannel(ProxyReceiver);
    ProxyReceiver->SetLowerChannel(IISChannel);

    ProxyReceiverNeedsCleanup = TRUE;

    PingReceiver = new (PingReceiver) HTTP2PingReceiver(TRUE);
    if (RpcStatus != RPC_S_OK)
        {
        PingReceiver->HTTP2PingReceiver::~HTTP2PingReceiver();
        goto AbortAndExit;
        }

    ProxyReceiver->SetUpperChannel(PingReceiver);
    PingReceiver->SetLowerChannel(ProxyReceiver);

    PingReceiverNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2InProxyInChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2InProxyInChannel::~HTTP2InProxyInChannel();
        goto AbortAndExit;
        }

    PingReceiver->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(PingReceiver);

    IISChannel->SetTopChannel(InChannel);
    ProxyReceiver->SetTopChannel(InChannel);
    PingReceiver->SetTopChannel(InChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnInChannel = InChannel;
    *IISContext = IISChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (PingReceiverNeedsCleanup)
        {
        PingReceiver->Abort(RpcStatus);
        PingReceiver->FreeObject();
        }
    else if (ProxyReceiverNeedsCleanup)
        {
        ProxyReceiver->Abort(RpcStatus);
        ProxyReceiver->FreeObject();
        }
    else if (IISChannelNeedsCleanup)
        {
        IISChannel->Abort(RpcStatus);
        IISChannel->FreeObject();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::AllocateAndInitializeOutChannel (
    OUT HTTP2InProxyOutChannel **ReturnOutChannel
    )
/*++

Routine Description:

    Allocates and initializes the in proxy out channel.

Arguments:

    ReturnInChannel - on success the created in channel.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2InProxyOutChannel *OutChannel;
    HTTP2ProxyPlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2ProxySocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel)
        + sizeof(WS_HTTP2_CONNECTION);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2InProxyOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyOutChannel);

    PlugChannel = (HTTP2ProxyPlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    RawChannel = (HTTP2ProxySocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
    RawConnection->HeaderRead = FALSE;
    RawConnection->ReadHeaderFn = HTTP2ReadHttpLegacyResponse;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;

    RawConnection->id = INVALID_PROTOCOL_ID;
    RawConnection->Initialize();
    RawConnection->type = COMPLEX_T | CONNECTION | CLIENT;

    RawConnectionNeedsCleanup = TRUE;

    RpcStatus = RPC_S_OK;
    RawChannel = new (RawChannel) HTTP2ProxySocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2ProxySocketTransportChannel::~HTTP2ProxySocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (FALSE,  // IsServer
        FALSE,      // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(RawChannel);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2ProxyPlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2ProxyPlugChannel::~HTTP2ProxyPlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2InProxyOutChannel (this, 
        RawConnection, 
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2InProxyOutChannel::~HTTP2InProxyOutChannel();
        goto AbortAndExit;
        }

    PlugChannel->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(PlugChannel);

    RawChannel->SetTopChannel(OutChannel);
    FlowControlSender->SetTopChannel(OutChannel);
    PlugChannel->SetTopChannel(OutChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnOutChannel = OutChannel;

    goto CleanupAndExit;

AbortAndExit:

    RawConnection->fIgnoreFree = TRUE;

    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    RawConnection->fIgnoreFree = FALSE;

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::ConnectToServer (
    void
    )
/*++

Routine Description:

    Connects to the server

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyOutChannel *OutChannel;
    RPC_STATUS RpcStatus;

    OutChannel = LockDefaultOutChannel(&ChannelPtr);
    
    // we don't have any async operations to abort the connection
    // yet - the out channel must be there
    if (OutChannel == NULL)
        {
        ASSERT(0);
        return RPC_S_INTERNAL_ERROR;
        }

    RpcStatus = OutChannel->InitializeRawConnection(ServerName,
        ServerPort,
        ConnectionTimeout,
        ProxyCallbackInterface->IsValidMachineFn
        );

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::SendD1_B2ToServer (
    void
    )
/*++

Routine Description:

    Sends D1/B2 to server

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyOutChannel *OutChannel;
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;
    BOOL SendSucceeded = FALSE;

    SendContext = AllocateAndInitializeD1_B2(ProtocolVersion,
        &EmbeddedConnectionCookie,
        &InChannelCookies[0],
        HTTP2InProxyReceiveWindow,
        IISConnectionTimeout,
        &AssociationGroupId,
        &ClientAddress
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = LockDefaultOutChannel(&ChannelPtr);
    // we don't have any async operations to abort the connection
    // yet - the out channel must be there
    ASSERT(OutChannel);
    RpcStatus = OutChannel->Send(SendContext);
    if (RpcStatus == RPC_S_OK)
        {
        SendSucceeded = TRUE;
        RpcStatus = OutChannel->Receive(http2ttRaw);
        }
    ChannelPtr->UnlockChannelPointer();

    if (SendSucceeded == FALSE)
        {
        FreeRTSPacket(SendContext);
        }

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::SendD2_A2ToServer (
    void
    )
/*++

Routine Description:

    Sends D2/A2 to server

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyOutChannel *OutChannel;
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;
    BOOL SendSucceeded = FALSE;

    SendContext = AllocateAndInitializeD2_A2(ProtocolVersion,
        &EmbeddedConnectionCookie,
        &InChannelCookies[1],
        &InChannelCookies[0],
        HTTP2InProxyReceiveWindow,
        IISConnectionTimeout
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = LockDefaultOutChannel(&ChannelPtr);
    // we don't have any async operations to abort the connection
    // yet - the out channel must be there
    ASSERT(OutChannel);
    RpcStatus = OutChannel->Send(SendContext);
    if (RpcStatus == RPC_S_OK)
        {
        SendSucceeded = TRUE;
        RpcStatus = OutChannel->Receive(http2ttRaw);
        }
    ChannelPtr->UnlockChannelPointer();

    if (SendSucceeded == FALSE)
        {
        FreeRTSPacket(SendContext);
        }

    return RpcStatus;
}

/*********************************************************************
    HTTP2OutProxyInChannel
 *********************************************************************/

RPC_STATUS HTTP2OutProxyInChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack back to the server

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    return ForwardFlowControlAckOnThisChannel(BytesReceivedForAck,
        WindowForAck,
        FALSE   // NonChannelData
        );
}

/*********************************************************************
    HTTP2OutProxyOutChannel
 *********************************************************************/

RPC_STATUS HTTP2OutProxyOutChannel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support last packet notifications

Arguments:

    LastSendContext - the context for the last send

Return Value:

    The value to return to the bottom channel

--*/
{
    HTTP2OutProxyVirtualConnection *VirtualConnection;

    ASSERT(LastSendContext->Flags & SendContextFlagSendLast);
    ASSERT((LastSendContext->UserData == oplptD4_A10)
        || (LastSendContext->UserData == oplptD5_B3));

    VirtualConnection = (HTTP2OutProxyVirtualConnection *)LockParentPointer();
    // if the connection was already aborted, nothing to do
    if (VirtualConnection == NULL)
        return RPC_P_PACKET_CONSUMED;

    // we know the parent will disconnect from us in their
    // notification
    VirtualConnection->LastPacketSentNotification(ChannelId,
        LastSendContext);

    UnlockParentPointer();

    if (LastSendContext->UserData == oplptD5_B3)
        {
        // if we are about to send D5_B3, this is the last packet
        // on the channel. Detach from the parent and return an
        // error
        DrainUpcallsAndFreeParent();
        }

    // just shutdown the connection or what has remained of it
    // (only this channel in the D5_B3 case)
    return RPC_P_CONNECTION_SHUTDOWN;
}

void HTTP2OutProxyOutChannel::PingTrafficSentNotify (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Notifies a channel that ping traffic has been sent.

Arguments:

    PingTrafficSize - the size of the ping traffic sent.

--*/
{
    BOOL Result;

    AccumulatedPingTraffic += PingTrafficSize;
    if (AccumulatedPingTraffic >= AccumulatedPingTrafficNotifyThreshold)
        {
        Result = PingTrafficSentNotifyServer (AccumulatedPingTraffic);
        if (Result)
            AccumulatedPingTraffic = 0;
        }
}

BOOL HTTP2OutProxyOutChannel::PingTrafficSentNotifyServer (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Sends a notification to the server that ping traffic originated
    at the out proxy has been sent. This allows to server to do
    proper accounting for when to recycle the out channel.

Arguments:

    PingTrafficSize - the size of the ping traffic to notify the
        server about.

Return Value:

    Non-zero if the notification was sent successfully.
    0 otherwise.

--*/
{
    HTTP2OutProxyVirtualConnection *VirtualConnection;
    BOOL Result;

    VirtualConnection = (HTTP2OutProxyVirtualConnection *)LockParentPointer();
    // if the connection was already aborted, nothing to do
    if (VirtualConnection == NULL)
        return TRUE;

    Result = VirtualConnection->PingTrafficSentNotifyServer(PingTrafficSize);

    UnlockParentPointer();

    return Result;
}

/*********************************************************************
    HTTP2OutProxyVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2OutProxyVirtualConnection::InitializeProxyFirstLeg (
    IN USHORT *ServerAddress,
    IN USHORT *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface,
    void **IISContext
    )
/*++

Routine Description:

    Initialize the proxy.

Arguments:

    ServerAddress - unicode pointer string to the server network address.

    ServerPort - unicode pointer string to the server port

    ConnectionParameter - the extension control block in this case

    ProxyCallbackInterface - a callback interface to the proxy to perform
        various proxy specific functions.

    IISContext - on output (success only) it must be initialized to
        the bottom IISChannel for the InProxy.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2OutProxyOutChannel *NewOutChannel;
    int OutChannelId;
    int ServerAddressLength;    // in characters + terminating 0

    // initialize out channel
    RpcStatus = AllocateAndInitializeOutChannel(ConnectionParameter,
        &NewOutChannel,
        IISContext
        );

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    SetFirstOutChannel(NewOutChannel);

    this->ProxyCallbackInterface = ProxyCallbackInterface;
    this->ConnectionParameter = ConnectionParameter;

    ServerAddressLength = RpcpStringLength(ServerAddress) + 1;
    ServerName = new RPC_CHAR [ServerAddressLength];

    if (ServerName == NULL)
        {
        Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpMemoryCopy(ServerName, ServerAddress, ServerAddressLength * 2);

    RpcStatus = EndpointToPortNumber(ServerPort, this->ServerPort);

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        // fall through with error
        }

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::StartProxy (
    void
    )
/*++

Routine Description:

    Kicks off listening on the proxy

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2OutProxyOutChannel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svClosed, 1, 0);
    State.State = http2svClosed;    // move to closed state expecting the opening RTS packet

    Channel = LockDefaultOutChannel(&ChannelPtr);

    ASSERT(Channel != NULL);  // we cannot be disconnected now    

    RpcStatus = Channel->Receive(http2ttRaw);

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::InitializeProxySecondLeg (
    void
    )
/*++

Routine Description:

    Initialize the proxy.

Arguments:

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2OutProxyInChannel *NewInChannel;
    int InChannelId;

    // initialize in channel
    RpcStatus = AllocateAndInitializeInChannel(
        &NewInChannel
        );

    if (RpcStatus != RPC_S_OK)
        {
        // this will always come from an upcall. Just return failure
        return RpcStatus;
        }

    SetFirstInChannel(NewInChannel);

    RpcStatus = ProxyCallbackInterface->GetConnectionTimeoutFn(&IISConnectionTimeout);
    if (RpcStatus != RPC_S_OK)
        {
        // this will always come from an upcall. Just return failure
        return RpcStatus;
        }

    IISConnectionTimeout *= 1000;

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error
    Buffer - buffer received
    BufferLength - length of buffer received
    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    RPC_STATUS RpcStatus;
    BOOL BufferFreed = FALSE;
    BOOL MutexCleared;
    ULONG ChannelLifetime;
    ULONG Ignored;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *ChannelPtr2;
    HTTP2OutProxyOutChannel *OutChannel;
    HTTP2OutProxyOutChannel *OutChannel2;
    CookieCollection *OutProxyCookieCollection;
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;
    HTTP2SendContext *D5_A4Context;
    HTTP2OutProxyVirtualConnection *ExistingConnection;
    int NonDefaultSelector;
    int DefaultSelector;
    HTTP2SendContext *D4_A10Context;
    BOOL IsAckOrNak;
    HTTP2SendContext *D5_B3Context;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2Cookie CookieForChannel;
    ULONG ClientReceiveWindowSize;
    HTTP2SendContext *SendContext;
    ULONG LocalProtocolVersion;

    VerifyValidChannelId(ChannelId);

    if (EventStatus == RPC_S_OK)
        {
        // N.B. All recieve packets are guaranteed to be
        // validated up to the common conn packet size
        if (IsRTSPacket(Buffer))
            {
            RpcStatus = HTTPTransInfo->CreateThread();
            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                return RpcStatus;
                }

            if (IsD2_A3Packet (Buffer,
                BufferLength,
                &LocalProtocolVersion))
                {
                // the newly acquired version can only be lower than the 
                // old version
                CORRUPTION_ASSERT (LocalProtocolVersion <= ProtocolVersion);
                if (LocalProtocolVersion > ProtocolVersion)
                    {
                    RpcFreeBuffer(Buffer);
                    return RPC_S_PROTOCOL_ERROR;
                    }

                ProtocolVersion = LocalProtocolVersion;
                RpcStatus = RPC_P_PACKET_NEEDS_FORWARDING;
                }
            else
                {
                RpcStatus = CheckPacketForForwarding(Buffer,
                    BufferLength,
                    fdOutProxy
                    );
                }
            }

        if (IsRTSPacket(Buffer) && (RpcStatus != RPC_P_PACKET_NEEDS_FORWARDING))
            {
            // RTS packet - check what we need to do with it
            if (IsOtherCmdPacket(Buffer, BufferLength))
                {
                // the only other cmd packets we expect in the proxy are
                // flow control acks
                RpcStatus = ParseAndFreeFlowControlAckPacketWithDestination (Buffer,
                    BufferLength,
                    fdOutProxy,
                    &BytesReceivedForAck,
                    &WindowForAck,
                    &CookieForChannel
                    );

                BufferFreed = TRUE;

                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                // notify the flow control sender about the ack
                OutChannel = (HTTP2OutProxyOutChannel *)MapCookieToAnyChannelPointer(
                    &CookieForChannel, 
                    &ChannelPtr
                    );

                if (OutChannel && !IsOutChannel(ChannelPtr))
                    {
                    CORRUPTION_ASSERT(0);
                    ChannelPtr->UnlockChannelPointer();
                    RpcStatus = RPC_S_PROTOCOL_ERROR;
                    OutChannel = NULL;
                    // fall through with the error
                    }

                if (OutChannel)
                    {
                    RpcStatus = OutChannel->FlowControlAckNotify(BytesReceivedForAck,
                        WindowForAck
                        );

                    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

                    ChannelPtr->UnlockChannelPointer();
                    }

                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                // post another receive
                RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                    http2ttRaw
                    );

                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                return RPC_P_PACKET_CONSUMED;
                }

            MutexCleared = FALSE;
            State.Mutex.Request();
            switch (State.State)
                {
                case http2svClosed:
                    // for closed states, we must receive
                    // stuff only on the default out (client) channel
                    ASSERT(IsDefaultOutChannel(ChannelId));

                    CurrentPosition = ValidateRTSPacketCommon(Buffer,
                        BufferLength
                        );

                    if (CurrentPosition == NULL)
                        {
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RTS = (rpcconn_tunnel_settings *)Buffer;
                    if ((RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL) == 0)
                        {
                        RpcStatus = ParseAndFreeD1_A1(Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &OutChannelCookies[0],
                            &ClientReceiveWindowSize
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus == RPC_S_OK)
                            {
                            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svC1W, 1, 0);
                            State.State = http2svC1W;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            RpcStatus = InitializeProxySecondLeg();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = ConnectToServer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendHeaderToClient();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            if (OutChannel == NULL)
                                {
                                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                                break;
                                }

                            OutChannel->SetPeerReceiveWindow(ClientReceiveWindowSize);
                            RpcStatus = OutChannel->SetConnectionTimeout(IISConnectionTimeout);
                            ChannelPtr->UnlockChannelPointer();

                            // zero out the in channel cookie
                            InChannelCookies[0].ZeroOut();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendD1_A3ToClient();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendD1_A2ToServer(DefaultChannelLifetime);
                            }
                        }
                    else
                        {
                        RpcStatus = ParseAndFreeD4_A3 (Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &OutChannelCookies[1],   // Old cookie - use OutChannelCookies[1] 
                                                    // as temporary storage only
                            &OutChannelCookies[0],   // New cookie
                            &ClientReceiveWindowSize
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            break;

                        // caller claims this is recycling for an already existing connection
                        // find out this connection
                        OutProxyCookieCollection = GetOutProxyCookieCollection();
                        OutProxyCookieCollection->LockCollection();
                        ExistingConnection = (HTTP2OutProxyVirtualConnection *)
                            OutProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);
                        if (ExistingConnection == NULL || ActAsSeparateMachinesOnWebFarm)
                            {
                            // no dice. Probably we executed on a different machine on the web farm
                            // proceed as a standalone connection
                            OutProxyCookieCollection->UnlockCollection();

                            LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svA11W, 1, 0);
                            State.State = http2svA11W;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            RpcStatus = InitializeProxySecondLeg();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            // we cannot be aborted here
                            ASSERT(OutChannel);
                            OutChannel->SetPeerReceiveWindow(ClientReceiveWindowSize);
                            // make sure no packets (RTS or other) go out until
                            // we get out D4/A11 and send out the header response
                            OutChannel->SetStrongPlug();
                            ChannelPtr->UnlockChannelPointer();

                            // zero out the in channel cookie
                            InChannelCookies[0].ZeroOut();

                            RpcStatus = ConnectToServer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendD4_A4ToServer(DefaultChannelLifetime);

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = PostReceiveOnDefaultChannel(FALSE,  // IsInChannel
                                http2ttRaw
                                );
                            }
                        else
                            {
                            // detach the out channel from this connection and attach
                            // it to the found connection. Grab a reference to it
                            // to prevent the case where it goes away underneath us
                            // we know that in its current state the connection is single
                            // threaded because we are in the completion path of the 
                            // only async operation
                            ChannelPtr = GetChannelPointerFromId(ChannelId);
                            OutChannel = (HTTP2OutProxyOutChannel *)ChannelPtr->LockChannelPointer();
                            // there is no way that somebody detached the channel here
                            ASSERT(OutChannel);

                            // add a reference to keep the channel alive while we disconnect it
                            OutChannel->AddReference();

                            ChannelPtr->UnlockChannelPointer();

                            // no need to drain the upcalls - we know we are the only
                            // upcall
                            ChannelPtr->FreeChannelPointer(
                                FALSE,      // DrainUpCalls
                                FALSE,      // CalledFromUpcallContext
                                FALSE,      // Abort
                                RPC_S_OK
                                );

                            DefaultSelector = ExistingConnection->DefaultOutChannelSelector;
                            NonDefaultSelector = ExistingConnection->GetNonDefaultOutChannelSelector();
                            if (ExistingConnection->OutChannelCookies[DefaultSelector].Compare (&OutChannelCookies[1]))
                                {
                                // nice try - cookies are different. Ditch the newly established channel
                                OutProxyCookieCollection->UnlockCollection();
                                OutChannel->RemoveReference();
                                RpcStatus = RPC_S_PROTOCOL_ERROR;
                                break;
                                }

                            OutChannel2 = ExistingConnection->LockDefaultOutChannel(&ChannelPtr2);
                            if (OutChannel2 == NULL)
                                {
                                OutProxyCookieCollection->UnlockCollection();
                                OutChannel->RemoveReference();
                                RpcStatus = RPC_S_PROTOCOL_ERROR;
                                break;
                                }

                            ClientReceiveWindowSize = OutChannel2->GetPeerReceiveWindow();
                            ChannelPtr2->UnlockChannelPointer();

                            OutChannel->SetPeerReceiveWindow(ClientReceiveWindowSize);

                            OutChannel->SetParent(ExistingConnection);
                            ExistingConnection->OutChannels[NonDefaultSelector].SetChannel(OutChannel);
                            ExistingConnection->OutChannelCookies[NonDefaultSelector].SetCookie(OutChannelCookies[0].GetCookie());
                            ExistingConnection->OutChannelIds[NonDefaultSelector] = ChannelId;

                            // check if connection is aborted
                            if (ExistingConnection->Aborted.GetInteger() > 0)
                                {
                                OutChannel->Abort(RPC_P_CONNECTION_SHUTDOWN);
                                }

                            // the extra reference that we added above passes to the existing connection
                            // However, below we party on the existing connection and we need to keep it alive
                            ExistingConnection->BlockConnectionFromRundown();
                            OutProxyCookieCollection->UnlockCollection();

                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            // nuke the rest of the old connection

                            // we got to the destructive phase of the abort
                            // guard against double aborts
                            if (Aborted.Increment() <= 1)
                                {
                                // abort the channels
                                AbortChannels(RPC_P_CONNECTION_SHUTDOWN);

                                DisconnectChannels(FALSE,       // ExemptChannel
                                    0                           // ExemptChannel id
                                    );

                                delete this;
                                // N.B. don't touch the this pointer after here
                                }

                            // post another receive on the new channel
                            RpcStatus = PostReceiveOnChannel (&(ExistingConnection->OutChannels[NonDefaultSelector]),
                                http2ttRaw);
                            if (RpcStatus != RPC_S_OK)
                                {
                                ExistingConnection->UnblockConnectionFromRundown();
                                break;
                                }

                            ExistingConnection->State.Mutex.Request();
                            LogEvent(SU_HTTPv2, EV_STATE, ExistingConnection, OUT_CHANNEL_STATE, http2svOpened_B1W, 1, 0);
                            ExistingConnection->State.State = http2svOpened_B1W;
                            ExistingConnection->State.Mutex.Clear();

                            // send D5/A4 to server
                            D5_A4Context = AllocateAndInitializeD5_A4(&ExistingConnection->OutChannelCookies[NonDefaultSelector]);
                            if (D5_A4Context == NULL)
                                {
                                ExistingConnection->UnblockConnectionFromRundown();
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                break;
                                }

                            RpcStatus = ExistingConnection->SendTrafficOnDefaultChannel (
                                TRUE,  // IsInChannel
                                D5_A4Context
                                );

                            if (RpcStatus != RPC_S_OK)
                                FreeRTSPacket(D5_A4Context);

                            ExistingConnection->UnblockConnectionFromRundown();

                            // fall through with the obtained RpcStatus
                            }
                        }
                    break;

                case http2svOpened:
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // the only RTS packets we expect in opened state is D4/A9
                    RpcStatus = ParseAndFreeD4_A9 (Buffer,
                        BufferLength
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    // queue D4/A10 for sending
                    // First, allocate D4/A10
                    D4_A10Context = AllocateAndInitializeD4_A10 ();
                    if (D4_A10Context == NULL)
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        break;
                        }

                    D4_A10Context->Flags = SendContextFlagSendLast;
                    D4_A10Context->UserData = oplptD4_A10;
                    RpcStatus = SendTrafficOnDefaultChannel (FALSE,     // IsInChannel
                        D4_A10Context);

                    if (RpcStatus == RPC_S_OK)
                        {
                        // we're done. There were no queued buffers and D4/A10
                        // was sent immediately. Close down
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }
                    else if (RpcStatus == ERROR_IO_PENDING)
                        {
                        // D4/A10 was not sent immediately. When it is sent,
                        // the LastPacketSentNotification mechanism will
                        // destroy the connection. Return success for know
                        RpcStatus = RPC_S_OK;
                        }
                    else
                        {
                        // an error occurred during sending. Free the packet and 
                        // return error back to the caller
                        FreeRTSPacket(D4_A10Context);
                        }

                    // on success, post another receive so that we can get flow control
                    // acks and we can keep sending to the client in case there was
                    // a queue on the out channel
                    if (RpcStatus == RPC_S_OK)
                        {
                        RpcStatus = PostReceiveOnChannel(&InChannels[0], http2ttRaw);
                        // fall through with any errors
                        }

                    break;

                case http2svC1W:
                    ASSERT(IsDefaultInChannel(ChannelId));
                    RpcStatus = ParseD1_C1(Buffer,
                        BufferLength,
                        &ProtocolVersion,
                        &Ignored,   // InProxyReceiveWindowSize
                        &Ignored    // InProxyConnectionTimeout
                        );

                    if (RpcStatus == RPC_S_OK)
                        {
                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        RpcStatus = AddConnectionToCookieCollection();

                        if (RpcStatus == RPC_S_OK)
                            {
                            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                            State.State = http2svOpened;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            if (OutChannel != NULL)
                                {
                                RpcStatus = OutChannel->ForwardTraffic(Buffer,
                                    BufferLength
                                    );

                                if (RpcStatus == RPC_S_OK)
                                    {
                                    BufferFreed = TRUE;
                                    RpcStatus = PostReceiveOnChannel(&InChannels[0], http2ttRaw);

                                    if (RpcStatus == RPC_S_OK)
                                        {
                                        RpcStatus = OutChannel->Unplug();
                                        }
                                    }

                                ChannelPtr->UnlockChannelPointer();
                                }
                            else
                                RpcStatus = RPC_P_CONNECTION_CLOSED;
                            }
                        }
                    break;

                case http2svOpened_CliW:
                    break;

                case http2svOpened_B1W:
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // the only RTS packets we expect in opened state is D5/B1 or D2/B2
                    RpcStatus = ParseAndFreeD5_B1orB2 (Buffer,
                        BufferLength,
                        &IsAckOrNak
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus != RPC_S_OK)
                        break;

                    OutChannel = LockDefaultOutChannel(&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    // keep an extra reference for after we detach the
                    // channel 
                    OutChannel->AddReference();
                    ChannelPtr->UnlockChannelPointer();

                    if (IsAckOrNak == FALSE)
                        {
                        // Nak - nuke the non-default channel
                        // and move to state opened
                        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                            FALSE,      // CalledFromUpcallContext
                            TRUE,       // Abort
                            RPC_S_PROTOCOL_ERROR
                            );

                        // switch to state opened
                        State.Mutex.Request();
                        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                        State.State = http2svOpened;                    
                        State.Mutex.Clear();

                        break;
                        }

                    SwitchDefaultOutChannelSelector();

                    // Send D5/B3 to client
                    D5_B3Context = AllocateAndInitializeD5_B3();

                    if (D5_B3Context == NULL)
                        {
                        OutChannel->RemoveReference();
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        break;
                        }

                    D5_B3Context->Flags = SendContextFlagSendLast;
                    D5_B3Context->UserData = oplptD5_B3;
                    RpcStatus = OutChannel->Send(D5_B3Context);

                    if (RpcStatus == RPC_S_OK)
                        {
                        // synchronous send. Abort and detach the old channel
                        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                            FALSE,      // CalledFromUpcallContext
                            TRUE,      // Abort
                            RPC_P_CONNECTION_SHUTDOWN
                            );
                        }
                    else if (RpcStatus == ERROR_IO_PENDING)
                        {
                        // async send. Just release our reference
                        // and return success
                        RpcStatus = RPC_S_OK;
                        }
                    else
                        {
                        // failed to send. Abort all
                        FreeRTSPacket(D5_B3Context);
                        OutChannel->Abort(RpcStatus);
                        OutChannel->RemoveReference();
                        break;
                        }

                    // release the extra reference
                    OutChannel->RemoveReference();

                    // switch to state opened
                    State.Mutex.Request();
                    LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;                    
                    State.Mutex.Clear();

                    // unplug the newly created channel
                    OutChannel = LockDefaultOutChannel(&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    RpcStatus = OutChannel->Unplug();

                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    // send the header response to the client
                    RpcStatus = SendHeaderToClient();
                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    // set the connection timeout

                    RpcStatus = OutChannel->SetConnectionTimeout(IISConnectionTimeout);

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus != RPC_S_OK)
                        break;

                    // post another receive on the channel
                    RpcStatus = PostReceiveOnDefaultChannel(TRUE,   // IsInChannel
                        http2ttRaw);
                    // fall through with the new error code
                    break;

                case http2svA11W:
                    if (IsOutChannel(ChannelId) == FALSE)
                        {
                        ASSERT(0);
                        // make sure client doesn't rush things
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RpcStatus = ParseAndFreeD4_A11(Buffer,
                        BufferLength
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    // now that we know the new channel is legit, add it to the
                    // collection
                    OutProxyCookieCollection = GetOutProxyCookieCollection();
                    OutProxyCookieCollection->LockCollection();
                    ExistingConnection = (HTTP2OutProxyVirtualConnection *)
                        OutProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);
                    if (ExistingConnection != NULL)
                        {
                        // the only way we will be in this protocol is if
                        // we were faking a web farm
                        ASSERT (ActAsSeparateMachinesOnWebFarm);
                        ProxyConnectionCookie = ExistingConnection->GetCookie();
                        ProxyConnectionCookie->AddRefCount();
                        ProxyConnectionCookie->SetConnection(this);

                        // remember that we are part of the cookie collection now
                        IsConnectionInCollection = TRUE;
                        }
                    else
                        {
                        // we truly didn't find anything - add ourselves.
                        RpcStatus = AddConnectionToCookieCollection ();
                        if (RpcStatus != RPC_S_OK)
                            {
                            OutProxyCookieCollection->UnlockCollection();
                            break;
                            }
                        }
                    OutProxyCookieCollection->UnlockCollection();

                    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // unplug the out channel to get the flow going
                    OutChannel = LockDefaultOutChannel (&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    RpcStatus = SendHeaderToClient();
                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    RpcStatus = OutChannel->SetConnectionTimeout(IISConnectionTimeout);
                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    RpcStatus = OutChannel->Unplug();

                    ChannelPtr->UnlockChannelPointer();

                    break;

                case http2svOpened_A5W:
                    break;

                case http2svB2W:
                    break;

                default:
                    ASSERT(0);
                }
            if (MutexCleared == FALSE)
                State.Mutex.Clear();
            }
        else
            {
            // data packet or RTS packet that needs forwarding. Just forward it
            ASSERT (IsDefaultInChannel(ChannelId));

            if (State.State == http2svC1W)
                {
                // non-RTS packet or forward RTS packet in C1W state from out channel
                // is a protocol error
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                }
            else
                {
                SendContext = AllocateAndInitializeContextFromPacket(Buffer,
                    BufferLength
                    );

                // the buffer is converted to send context. We can't free
                // it directly - we must make sure we free it on failure before exit.
                BufferFreed = TRUE;

                if (SendContext == NULL)
                    {
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(SendContext->Flags == 0);
                    SendContext->Flags = SendContextFlagProxySend;
                    SendContext->UserData = ConvertChannelIdToSendContextUserData(ChannelId);
                    RpcStatus = SendTrafficOnDefaultChannel(FALSE,  // IsInChannel 
                        SendContext
                        );
                    if (RpcStatus == RPC_S_OK)
                        {
                        ChannelPtr = GetChannelPointerFromId(ChannelId);

                        RpcStatus = PostReceiveOnChannel(ChannelPtr, http2ttRaw);
                        }
                    else
                        {
                        FreeSendContextAndPossiblyData(SendContext);
                        }
                    }                
                }
            }
        }
    else
        {
        // just turn around the error code
        RpcStatus = EventStatus;
        // in failure cases we don't own the buffer
        BufferFreed = TRUE;
        }

    if (BufferFreed == FALSE)
        RpcFreeBuffer(Buffer);

    return RpcStatus;
}

void HTTP2OutProxyVirtualConnection::EnableIISSessionClose (
    void
    )
/*++

Routine Description:

    Enables close of the IIS session at the IISTransportChannel
    level. Simply delegates to the appropriate channel.

Arguments:

Return Value:

--*/
{
    // on the out proxy, the out channel has the IISTransport channel
    HTTP2OutProxyOutChannel *OutChannel;
    HTTP2ChannelPointer *ChannelPtr;
    
    OutChannel = LockDefaultOutChannel(&ChannelPtr);
    if (OutChannel == NULL)
        {
        // somebody aborted the connection - nothing to do
        return;
        }

    OutChannel->EnableIISSessionClose();

    ChannelPtr->UnlockChannelPointer();
}

BOOL HTTP2OutProxyVirtualConnection::PingTrafficSentNotifyServer (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Sends a notification to the server that ping traffic originated
    at the out proxy has been sent. This allows to server to do
    proper accounting for when to recycle the out channel.
    The function is called from neutral upcall context. It can't
    return an error, and it can't abort.

Arguments:

    PingTrafficSize - the size of the ping traffic to notify the
        server about.

Return Value:

    Non-zero if the notification was sent successfully.
    0 otherwise.

--*/
{
    HTTP2SendContext *PingTrafficSentContext;
    RPC_STATUS RpcStatus;

    PingTrafficSentContext = AllocateAndInitializePingTrafficSentNotifyPacket (PingTrafficSize);
    if (PingTrafficSentContext == NULL)
        return FALSE;

    RpcStatus = SendTrafficOnDefaultChannel (TRUE,      // IsInChannel
        PingTrafficSentContext
        );

    if (RpcStatus != RPC_S_OK)
        {
        FreeRTSPacket(PingTrafficSentContext);
        return FALSE;
        }
    else
        return TRUE;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::AllocateAndInitializeInChannel (
    OUT HTTP2OutProxyInChannel **ReturnInChannel
    )
/*++

Routine Description:

    Allocates and initializes the out proxy in channel.

Arguments:

    ReturnInChannel - on success the created in channel.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2OutProxyInChannel *InChannel;
    HTTP2ProxyReceiver *ProxyReceiver;
    HTTP2ProxySocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL ProxyReceiverNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel)
        + sizeof(WS_HTTP2_CONNECTION);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2OutProxyInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyInChannel);

    ProxyReceiver = (HTTP2ProxyReceiver *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver);

    RawChannel = (HTTP2ProxySocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
    RawConnection->HeaderRead = FALSE;
    RawConnection->ReadHeaderFn = HTTP2ReadHttpLegacyResponse;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    ProxyReceiverNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;

    RawConnection->id = INVALID_PROTOCOL_ID;
    RawConnection->Initialize();
    RawConnection->type = COMPLEX_T | CONNECTION | CLIENT;

    RawConnectionNeedsCleanup = TRUE;

    RpcStatus = RPC_S_OK;
    RawChannel = new (RawChannel) HTTP2ProxySocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2ProxySocketTransportChannel::~HTTP2ProxySocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    ProxyReceiver = new (ProxyReceiver) HTTP2ProxyReceiver (HTTP2OutProxyReceiveWindow,
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ProxyReceiver->HTTP2ProxyReceiver::~HTTP2ProxyReceiver();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(ProxyReceiver);
    ProxyReceiver->SetLowerChannel(RawChannel);

    ProxyReceiverNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2OutProxyInChannel (this, 
        RawConnection, 
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2OutProxyInChannel::~HTTP2OutProxyInChannel();
        goto AbortAndExit;
        }

    ProxyReceiver->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(ProxyReceiver);

    RawChannel->SetTopChannel(InChannel);
    ProxyReceiver->SetTopChannel(InChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnInChannel = InChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (ProxyReceiverNeedsCleanup)
        {
        ProxyReceiver->Abort(RpcStatus);
        ProxyReceiver->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::AllocateAndInitializeOutChannel (
    IN void *ConnectionParameter,
    OUT HTTP2OutProxyOutChannel **ReturnOutChannel,
    OUT void **IISContext
    )
/*++

Routine Description:

    Allocates and initializes the out proxy out channel.

Arguments:

    ConnectionParameter - really an EXTENSION_CONTROL_BLOCK

    ReturnOutChannel - on success the created out channel.

    IISContext - on output, the IISChannel pointer used as 
        connection context with IIS.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2OutProxyOutChannel *OutChannel;
    HTTP2ProxyPlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2PingOriginator *PingOriginator;
    HTTP2PingReceiver *PingReceiver;
    HTTP2IISSenderTransportChannel *IISChannel;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL PingOriginatorNeedsCleanup;
    BOOL PingReceiverNeedsCleanup;
    BOOL IISChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2IISSenderTransportChannel)
        ;

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2OutProxyOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyOutChannel);

    PlugChannel = (HTTP2ProxyPlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    PingOriginator = (HTTP2PingOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator);

    PingReceiver = (HTTP2PingReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver);

    IISChannel = (HTTP2IISSenderTransportChannel *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    PingOriginatorNeedsCleanup = FALSE;
    PingReceiverNeedsCleanup = FALSE;
    IISChannelNeedsCleanup = FALSE;
    RpcStatus = RPC_S_OK;

    IISChannel = new (IISChannel) HTTP2IISSenderTransportChannel (ConnectionParameter, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        IISChannel->HTTP2IISSenderTransportChannel::~HTTP2IISSenderTransportChannel();
        goto AbortAndExit;
        }

    IISChannelNeedsCleanup = TRUE;

    PingReceiver = new (PingReceiver) HTTP2PingReceiver (FALSE);

    IISChannel->SetUpperChannel(PingReceiver);
    PingReceiver->SetLowerChannel(IISChannel);

    PingReceiverNeedsCleanup = TRUE;

    PingOriginator = new (PingOriginator) HTTP2PingOriginator (
        TRUE        // NotifyTopChannelForPings
        );

    PingReceiver->SetUpperChannel(PingOriginator);
    PingOriginator->SetLowerChannel(PingReceiver);

    PingOriginatorNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (FALSE,      // IsServer
        FALSE,      // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    PingOriginator->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(PingOriginator);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2ProxyPlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2ProxyPlugChannel::~HTTP2ProxyPlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2OutProxyOutChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2OutProxyOutChannel::~HTTP2OutProxyOutChannel();
        goto AbortAndExit;
        }

    PlugChannel->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(PlugChannel);

    IISChannel->SetTopChannel(OutChannel);
    PingOriginator->SetTopChannel(OutChannel);
    PingReceiver->SetTopChannel(OutChannel);
    FlowControlSender->SetTopChannel(OutChannel);
    PlugChannel->SetTopChannel(OutChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnOutChannel = OutChannel;
    *IISContext = IISChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (PingOriginatorNeedsCleanup)
        {
        PingOriginator->Abort(RpcStatus);
        PingOriginator->FreeObject();
        }
    else if (PingReceiverNeedsCleanup)
        {
        PingReceiver->Abort(RpcStatus);
        PingReceiver->FreeObject();
        }
    else if (IISChannelNeedsCleanup)
        {
        IISChannel->Abort(RpcStatus);
        IISChannel->FreeObject();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::ConnectToServer (
    void
    )
/*++

Routine Description:

    Connects to the server and sends D1/A2

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2OutProxyInChannel *InChannel;
    RPC_STATUS RpcStatus;

    InChannel = LockDefaultInChannel(&ChannelPtr);

    // we cannot be aborted right now
    if (InChannel == NULL)
        {
        ASSERT(0);
        return RPC_S_INTERNAL_ERROR;
        }

    RpcStatus = InChannel->InitializeRawConnection(ServerName,
        ServerPort,
        ConnectionTimeout,
        ProxyCallbackInterface->IsValidMachineFn
        );

    if (RpcStatus == RPC_S_OK)
        {
        RpcStatus = InChannel->Receive(http2ttRaw);
        }
    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::SendHeaderToClient (
    void
    )
/*++

Routine Description:

    Sends response header to client

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeResponseHeader();
    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        RpcFreeBuffer(SendContext);

    return RpcStatus;
}


RPC_STATUS HTTP2OutProxyVirtualConnection::SendD1_A3ToClient (
    void
    )
/*++

Routine Description:

    Sends D1/A3 to client

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeD1_A3(IISConnectionTimeout);
    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::SendD1_A2ToServer (
    IN ULONG ChannelLifetime
    )
/*++

Routine Description:

    Sends D1/A3 to client

Arguments:

    ChannelLifetime - the lifetime of the channel as established by
        the client.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeD1_A2 (ProtocolVersion,
        &EmbeddedConnectionCookie,
        &OutChannelCookies[0],
        ChannelLifetime,
        ProxyReceiveWindowSize
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(TRUE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::SendD4_A4ToServer (
    IN ULONG ChannelLifetime
    )
/*++

Routine Description:

    Sends D1/A3 to client

Arguments:

    ChannelLifetime - the lifetime of the channel as established by
        the client.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeD4_A4 (ProtocolVersion,
        &EmbeddedConnectionCookie,
        &OutChannelCookies[1],
        &OutChannelCookies[0],
        ChannelLifetime,
        ProxyReceiveWindowSize,
        IISConnectionTimeout
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(TRUE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

void HTTP2OutProxyVirtualConnection::LastPacketSentNotification (
    IN int ChannelId,
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a channel wants to notify the virtual connection
    that the last packet has been sent, they call this function. 
    Must be called from an upcall/neutral context. Only flow control
    senders generated past packet notifications

Arguments:

    ChannelId - the channelfor which this notification is.

    LastSendContext - the send context for the last send

Return Value:

--*/
{
    HTTP2ChannelPointer *ChannelPtr;

    ASSERT(LastSendContext->Flags & SendContextFlagSendLast);
    ASSERT((LastSendContext->UserData == oplptD4_A10)
        || (LastSendContext->UserData == oplptD5_B3));

    if (LastSendContext->UserData == oplptD5_B3)
        {
        ChannelPtr = GetChannelPointerFromId(ChannelId);

        if (ChannelPtr == NULL)
            {
            // This should never happen.
            ASSERT(0);
            return;
            }

        // Detach the old channel
        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
            TRUE,      // CalledFromUpcallContext
            FALSE,      // Abort
            RPC_S_OK
            );
        }
}

/*********************************************************************
    HTTP2ServerChannel
 *********************************************************************/

void HTTP2ServerChannel::AbortConnection (
    IN RPC_STATUS AbortReason
    )
/*++

Routine Description:

    Aborts the virtual connection.

Arguments:

    RpcStatus - the error to abort with

Return Value:

--*/
{
    HTTP2VirtualConnection *VirtualConnection;

    // Per Rule 40:
    // We need to syncronize with the channels' being added in InitializeServerConnection().
    // It is possible that another thread is calling SetChannel on the channel pointer
    // and we do not want to ensure mutual exclusion with that thread.
    // The thread in InitializeServerConnection() will be holding CookieCollection mutex.
    // We must take this look before LockParentPointer() to avoid a deadlock with a thread
    // in InitializeServerConnection();
    GetServerCookieCollection()->LockCollection();

    // abort the parent connection
    VirtualConnection = LockParentPointer();
    if (VirtualConnection)
        {
        VirtualConnection->AbortChannels(AbortReason);
        UnlockParentPointer();
        }
    else
        {
        // abort this channel at least
        Abort(AbortReason);
        }

    GetServerCookieCollection()->UnlockCollection();
}

/*********************************************************************
    HTTP2ServerInChannel
 *********************************************************************/

RPC_STATUS HTTP2ServerInChannel::QueryLocalAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a channel.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    WS_HTTP2_CONNECTION *RawConnection;

    RpcStatus = BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    RawConnection = GetRawConnection();
    RpcStatus = TCP_QueryLocalAddress(RawConnection,
        Buffer,
        BufferSize,
        AddressFormat
        );

    FinishSubmitAsync();

    return RpcStatus;
}

RPC_STATUS HTTP2ServerInChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack back to the in proxy

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ForwardFlowControlAckOnThisChannel(BytesReceivedForAck,
        WindowForAck,
        TRUE        // NonChannelData
        );

    // we're sending non-channel data. This cannot lead to channel recycle
    // indication
    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    return RpcStatus;
}

/*********************************************************************
    HTTP2ServerOutChannel
 *********************************************************************/

RPC_STATUS HTTP2ServerOutChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    BOOL IsDataSend;

    IsDataSend = (SendContext->TrafficType == http2ttData);

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SERVER_CHANNEL, PtrToUlong(SendContext));

    if (IsDataSend)
        DataSendsPending.Increment();

    RpcStatus = HTTP2ServerChannel::Send(SendContext);

    if (IsDataSend && (RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        DataSendsPending.Decrement();

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SERVER_CHANNEL, (IsDataSend << 24) | DataSendsPending.GetInteger());

    return RpcStatus;
}

RPC_STATUS HTTP2ServerOutChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send

    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    BOOL IsDataSend;

    IsDataSend = (SendContext->TrafficType == http2ttData);

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_SERVER_CHANNEL, PtrToUlong(SendContext));

    if (SendContext->Flags & SendContextFlagAbandonedSend)
        {
        // abandoned send. Complete it silently and return back
        ASSERT(SendContext->TrafficType == http2ttData);

        RpcFreeBuffer(SendContext->u.BufferToFree);
        FreeLastSendContext(SendContext);

        if (IsDataSend)
            DataSendsPending.Decrement();
        ASSERT(DataSendsPending.GetInteger()>=0);

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_SERVER_CHANNEL, (IsDataSend << 24) | DataSendsPending.GetInteger());

        return RPC_P_PACKET_CONSUMED;
        }

    RpcStatus = HTTP2Channel::SendComplete (EventStatus, SendContext);

    if (IsDataSend)
        DataSendsPending.Decrement();
    ASSERT(DataSendsPending.GetInteger()>=0);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_SERVER_CHANNEL, (IsDataSend << 24) | DataSendsPending.GetInteger());

    return RpcStatus;
}

RPC_STATUS HTTP2ServerOutChannel::SyncSend (
    IN HTTP2TrafficType TrafficType,
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout,
    IN BASE_ASYNC_OBJECT *Connection,
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Overwrites HTTP2Channel::SyncSend.
    In the case of HTTP2ServerOutChannel we need to make sure that its
    Send method is called and DataSendsPending counter is incremented.

Arguments:

    TrafficType - the type of traffic

    BufferLength - the length of the buffer

    Buffer - the buffer to send

    fDisableCancelCheck - don't do checks for cancels. Can be
        used as optimization

    Timeout - the call timeout

    Connection - the transport connection object. Used for cancelling.

    SendContext - a memory block of sufficient size to initialize a send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SERVER_CHANNEL, 0);

    PrepareForSyncSend (BufferLength,
                        Buffer,
                        SendContext);

    // In the case of HTTP2ServerOutChannel we need to make sure that its
    // Send method is called and DataSendsPending counter is incremented.
    RpcStatus = Send(SendContext);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SERVER_CHANNEL, RpcStatus);
    return RpcStatus;
}

void HTTP2ServerOutChannel::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_CANCELLED, HTTP2LOG_OT_SERVER_CHANNEL, PtrToUlong(SendContext));

    HTTP2Channel::SendCancelled(SendContext);

    if(SendContext->TrafficType == http2ttData)
        DataSendsPending.Decrement();

    ASSERT(DataSendsPending.GetInteger()>=0);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_CANCELLED, HTTP2LOG_OT_SERVER_CHANNEL, DataSendsPending.GetInteger());
}

RPC_STATUS HTTP2ServerOutChannel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    // The server channel does not support this for Whistler
    return RPC_S_CANNOT_SUPPORT;
}

RPC_STATUS HTTP2ServerOutChannel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support past packet notifications

Arguments:

    LastSendContext - the context for the last send

Return Value:

    The value to return to the runtime

--*/
{
    HTTP2ServerVirtualConnection *VirtualConnection;

    VirtualConnection = LockParentPointer();
    // if the connection was already aborted, nothing to do
    if (VirtualConnection == NULL)
        return RPC_P_PACKET_CONSUMED;

    // we know the parent will disconnect from us in their
    // notification
    VirtualConnection->LastPacketSentNotification(ChannelId,
        LastSendContext);

    UnlockParentPointer();

    DrainUpcallsAndFreeParent();

    return RPC_P_PACKET_CONSUMED;
}

RPC_STATUS HTTP2ServerOutChannel::GetChannelOriginatorBufferQueue (
    OUT LIST_ENTRY *NewBufferHead
    )
/*++

Routine Description:

    Gets the buffer queue of the channel data originator and if
    any send contexts are done on the cached send context, they are
    moved to an allocated send context.

Arguments:

    NewBufferHead - the linked list head to add the buffers on.
        The head must be empty.

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    ASSERT(RpcpIsListEmpty(NewBufferHead));

    GetDataOriginatorChannel()->GetBufferQueue(NewBufferHead);

    return UnaffinitizeSendContextList(NewBufferHead);
}

RPC_STATUS HTTP2ServerOutChannel::GetFlowControlSenderBufferQueue (
    OUT LIST_ENTRY *NewBufferHead
    )
/*++

Routine Description:

    Gets the buffer queue of the flow control sender channel and if
    any send contexts are done on the cached send context, they are
    moved to an allocated send context.

Arguments:

    NewBufferHead - the linked list head to add the buffers on.
        The head must be empty.

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    ASSERT(RpcpIsListEmpty(NewBufferHead));

    GetFlowControlSenderChannel()->GetBufferQueue(NewBufferHead);

    return UnaffinitizeSendContextList(NewBufferHead);
}

HTTP2SendContext *HTTP2ServerOutChannel::GetLastSendContext (
    void
    )
/*++

Routine Description:

    Gets (creates if necessary) a last send context.

Arguments:

Return Value:

    The last context created or NULL if there is not enough memory

Notes:

    Since each connection will submit one last send at a time, this
        method can be single threaded.

--*/
{
    if (CachedLastSendContextUsed == FALSE)
        {
        CachedLastSendContextUsed = TRUE;
        return GetCachedLastSendContext();
        }
    else
        {
        return (new HTTP2SendContext);
        }
}

RPC_STATUS HTTP2ServerOutChannel::UnaffinitizeSendContextList (
    IN LIST_ENTRY *ListHead
    )
/*++

Routine Description:

    Walks through the supplied list of send contexts and if any
    one is the channel cached context, it allocates a new send
    context and frees the cached context send (i.e. unaffinitizes
    it).

Arguments:

    ListHead - the list of send contexts. The list may be empty.

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    LIST_ENTRY *CurrentEntry;
    HTTP2SendContext *CachedSendContext;
    LIST_ENTRY *CachedSendContextListEntry;
    HTTP2SendContext *NewSendContext;
    BOOL CachedSendContextFound;
    LIST_ENTRY *NextListEntry;

    CachedSendContext = GetCachedLastSendContext();
    CachedSendContextListEntry = &CachedSendContext->ListEntry;

    CachedSendContextFound = FALSE;
    CurrentEntry = ListHead->Flink;

    while (CurrentEntry != ListHead)
        {
        if (CurrentEntry == CachedSendContextListEntry)
            {
            ASSERT(CachedLastSendContextUsed);
            // the cached context can be found only once in the list
            ASSERT(CachedSendContextFound == FALSE);
            CachedSendContextFound = TRUE;
            NewSendContext = new HTTP2SendContext;
            if (NewSendContext == NULL)
                {
                // free the whole list and exit
                CurrentEntry = ListHead;

                while (CurrentEntry != ListHead)
                    {
                    // save the next element before we delete
                    NextListEntry = CurrentEntry->Flink;

                    FreeLastSendContext(CONTAINING_RECORD(CurrentEntry, HTTP2SendContext, ListEntry));

                    // move on to the next
                    CurrentEntry = NextListEntry;
                    }

                return RPC_S_OUT_OF_MEMORY;
                }
            // copy the context and relink the new entry to the list
            RpcpMemoryCopy(NewSendContext, CachedSendContext, sizeof(HTTP2SendContext));

            NewSendContext->ListEntry.Blink->Flink = &NewSendContext->ListEntry;
            NewSendContext->ListEntry.Flink->Blink = &NewSendContext->ListEntry;
            CurrentEntry = &NewSendContext->ListEntry;

            FreeLastSendContext(CachedSendContext);
            }

        CurrentEntry = CurrentEntry->Flink;
        }

    return RPC_S_OK;
}

/*********************************************************************
    HTTP2ServerVirtualConnection
 *********************************************************************/

void HTTP2ServerVirtualConnection::Abort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP connection and disconnects the channels.
    Must only come from the runtime.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_SERVER_VC, 0);

    // abort the channels themselves
    HTTP2VirtualConnection::AbortChannels(RPC_P_CONNECTION_CLOSED);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return;

    // rule 38 - drain the sends before disconnecting
    DrainOutChannelPendingSends ();

    HTTP2VirtualConnection::DisconnectChannels(FALSE, 0);

    CancelAllTimeouts();
}

void HTTP2ServerVirtualConnection::Close (
    IN BOOL DontFlush
    )
/*++

Routine Description:

    Closes an HTTP connection. Connection may have already been aborted.

Arguments:

    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

--*/
{
    CookieCollection *ServerCookieCollection = GetServerCookieCollection();

    ServerCookieCollection->LockCollection();
    ServerCookieCollection->RemoveElement(&EmbeddedConnectionCookie);
    ServerCookieCollection->UnlockCollection();

    HTTP2ServerVirtualConnection::Abort();

    // call destructor without freeing memory
    HTTP2ServerVirtualConnection::~HTTP2ServerVirtualConnection();
}

RPC_STATUS HTTP2ServerVirtualConnection::QueryClientAddress (
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG ClientAddressType;

    if (ClientAddress.AddressType == catIPv4)
        {
        ClientAddressType = TCP;
        ((SOCKADDR_IN *)&ClientAddress.u)->sin_family = AF_INET;
        }
    else
        {
        ClientAddressType = TCP_IPv6;
        ((SOCKADDR_IN6 *)&ClientAddress.u)->sin6_family = AF_INET6;
        }

    return WS_ConvertClientAddress((const SOCKADDR *)&ClientAddress.u,
        ClientAddressType,
        pNetworkAddress
        );
}

RPC_STATUS HTTP2ServerVirtualConnection::QueryLocalAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    HTTP2ServerInChannel *ServerInChannel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    ServerInChannel = LockDefaultInChannel(&ChannelPtr);
    if (ServerInChannel == NULL)
        return RPC_S_NO_CONTEXT_AVAILABLE;

    RpcStatus = ServerInChannel->QueryLocalAddress(Buffer,
        BufferSize,
        AddressFormat
        );

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::QueryClientId(
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is supposed to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ClientProcess->SetHTTP2ClientIdentifier(AssociationGroupId.GetCookie(),
        COOKIE_SIZE_IN_BYTES,
        FALSE   // fLocal
        );

    return RPC_S_OK;
}

RPC_STATUS HTTP2ServerVirtualConnection::QueryClientIpAddress (
    IN OUT RPC_CLIENT_IP_ADDRESS *ClientIpAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    ClientIpAddress - Will contain the ip address on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG BufferLength = max(sizeof(SOCKADDR_IN), sizeof(SOCKADDR_IN6));

    if (ClientAddress.AddressType == catIPv4)
        {
        ((SOCKADDR_IN *)&ClientAddress.u)->sin_family = AF_INET;
        BufferLength = sizeof(SOCKADDR_IN);
        }
    else
        {
        ((SOCKADDR_IN6 *)&ClientAddress.u)->sin6_family = AF_INET6;
        BufferLength = sizeof(SOCKADDR_IN6);
        }

    ASSERT(BufferLength <= sizeof(*ClientIpAddress));

    ClientIpAddress->DataSize = BufferLength;

    RpcpMemoryCopy (ClientIpAddress, &ClientAddress.u, BufferLength);

    return RPC_S_OK;
}

void HTTP2ServerVirtualConnection::LastPacketSentNotification (
    IN int ChannelId,
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a channel wants to notify the virtual connection
    that the last packet has been sent, they call this function. 
    Must be called from an upcall/neutral context. Only flow control
    senders generates last packet notifications

Arguments:

    ChannelId - the channelfor which this notification is.

    LastSendContext - the context for the last send

Return Value:

--*/
{
    // this must not be on the default in channel
    ASSERT(IsOutChannel(ChannelId));
    ASSERT(!IsDefaultOutChannel(ChannelId));

    // detach the channel that notified us. Since we're in upcall, we know
    // we hold at least one reference
    OutChannels[GetNonDefaultOutChannelSelector()].FreeChannelPointer(FALSE,  // DrainUpCalls
        FALSE,      // CalledFromUpcallContext
        FALSE,      // Abort
        RPC_S_OK    // AbortStatus
        );
}

RPC_STATUS HTTP2ServerVirtualConnection::RecycleChannel (
    IN BOOL
    )
/*++

Routine Description:

    Initiates channel recycling on the server.

Arguments:

    IsFromUpcall - non-zero if it comes from upcall. Zero otherwise.
        Ignored for server side recycling.

Return Value:

    RPC_S_OK of the recycling operation started successfully.
    RPC_S_* error for errors.

--*/
{
    HTTP2SendContext *D4_A1Context;
    RPC_STATUS RpcStatus;

#if DBG
    DbgPrint("RPCRT4: %d: Recycling OUT channel\n", GetCurrentProcessId());
#endif

    InChannelState.Mutex.Request();
    // we shouldn't get recycle unless we're in an opened state
    ASSERT(OutChannelState.State == http2svOpened);

    // we shouldn't recycle the default channel unless the non-default
    // is discarded. If we were to do this, this raises a race condition
    // where a third channel can arrive while the first is still not
    // discarded. To prevent this, we hold the ball until the first
    // channel is discarded, and then we open the flood gates for
    // new channel recycling. See how we handle delayed channel recycling
    // in HTTP2ServerVirtualConnection::ReceiveComplete

    if (OutChannels[GetNonDefaultOutChannelSelector()].IsChannelSet())
        {
        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svNonDefaultChannelCloseWait, 1, 0);
        OutChannelState.State = http2svNonDefaultChannelCloseWait;
        InChannelState.Mutex.Clear();
        return RPC_S_OK;
        }

    // Send invitation to the client to start channel recycling
    D4_A1Context = AllocateAndInitializeD4_A1 ();
    if (D4_A1Context == NULL)
        return RPC_S_OUT_OF_MEMORY;

    LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened_A4W, 1, 0);
    OutChannelState.State = http2svOpened_A4W;

    VerifyTimerNotSet (GetOutChannelTimer());

    InChannelState.Mutex.Clear();

    RpcStatus = SendTrafficOnDefaultChannel(FALSE,   // IsInChannel
        D4_A1Context
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(D4_A1Context);

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate send complete.

Arguments:

    EventStatus - status of the operation

    SendContext - the context for the send complete

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    VerifyValidChannelId(ChannelId);

    if (SendContext->TrafficType == http2ttRTS)
        {
        FreeSendContextAndPossiblyData(SendContext);
        if (EventStatus != RPC_S_OK)
            {
            // any send failures on the server are cause for connection abortion
            AbortChannels(EventStatus);
            }
        return RPC_P_PACKET_CONSUMED;
        }
    else
        return EventStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error
    Buffer - buffer received
    BufferLength - length of buffer received
    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    HTTP2ServerOutChannel *OutChannel;
    HTTP2ServerOutChannel *NewOutChannel;
    HTTP2ServerInChannel *InChannel;
    HTTP2ServerInChannel *InChannel2;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *NewChannelPtr;
    HTTP2ChannelPointer *DefaultChannelPtr;
    HTTP2Cookie ChannelCookie;
    RPC_STATUS RpcStatus;
    HTTP2SendContext *EmptyRTS;
    BOOL BufferFreed;
    BOOL DataReceivePosted;
    HTTP2ServerOpenedPacketType PacketType;
    LIST_ENTRY NewBufferHead;
    HTTP2SendContext *D4_A9Context;
    HTTP2SendContext *D5_A5Context;
    HTTP2SendContext *D5_B1OrB2Context;
    HTTP2SendContext *D2_B2Context;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2ServerOutChannelOtherCmdPacketType OutChannelPacketType;
    BOOL IsOtherCmd;
    ULONG PingTrafficSent;
    BOOL ChannelNotSet;
    BOOL ChannelRecyclingNeeded;

    VerifyValidChannelId(ChannelId);

    if (IsInChannel(ChannelId))
        {
        // in channel has an endpoint receiver. Delegate RTS and data failures to it
        if (EventStatus != RPC_S_OK)
            return EventStatus;

        if (IsRTSPacket(Buffer))
            {
            RpcStatus = HTTPTransInfo->CreateThread();

            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                AbortChannels(RPC_S_PROTOCOL_ERROR);
                return RPC_P_PACKET_CONSUMED;
                }

            BufferFreed = FALSE;

            RpcStatus = CheckPacketForForwarding(Buffer,
                BufferLength,
                fdServer
                );

            if (RpcStatus == RPC_P_PACKET_NEEDS_FORWARDING)
                {
                // flow control acks have some weird routing. Handle
                // them separately. First, test for other cmd, since it's
                // cheaper
                if (IsOtherCmdPacket(Buffer, BufferLength))
                    {
                    // we know this is a other cmd command. Now check for
                    // forwarded flow control ack
                    RpcStatus = ParseFlowControlAckPacketWithDestination (Buffer,
                        BufferLength,
                        fdOutProxy,
                        &BytesReceivedForAck,
                        &WindowForAck,
                        &ChannelCookie
                        );

                    if (RpcStatus == RPC_S_OK)
                        {
                        ChannelNotSet = FALSE;
                        // flow control ack. Route it based on which out channel has
                        // a matching cookie. It is possible that none has. That's ok -
                        // just drop the packet in these cases
                        if (OutChannelCookies[0].Compare(&ChannelCookie) == 0)
                            {
                            if (OutChannels[0].IsChannelSet())
                                {
                                RpcStatus = ForwardTrafficToChannel (
                                    &OutChannels[0],
                                    Buffer,
                                    BufferLength
                                    );
                                }
                            else
                                {
                                // see comment below where we check ChannelNotSet
                                ChannelNotSet = TRUE;
                                ASSERT(DefaultOutChannelSelector == 1);
                                }
                            }
                        else if (OutChannelCookies[1].Compare(&ChannelCookie) == 0)
                            {
                            if (OutChannels[1].IsChannelSet())
                                {
                                RpcStatus = ForwardTrafficToChannel (
                                    &OutChannels[1],
                                    Buffer,
                                    BufferLength
                                    );
                                }
                            else
                                {
                                // see comment below where we check ChannelNotSet
                                ChannelNotSet = TRUE;
                                ASSERT(DefaultOutChannelSelector == 0);
                                }
                            }
                        else
                            {
                            // fake failure - this will be handled below
                            RpcStatus = RPC_P_SEND_FAILED;
                            }

                        if (ChannelNotSet)
                            {
                            // we could have a match on a channel that does not exist
                            // if we are in D5 after D5/B1. The old channel still needs
                            // flow control, but the new channel cookie is current by
                            // now. In these cases the old channel cookie will be moved
                            // to the location of the cookie for the non-default channel
                            // Make sure this is the case. After that forward to the out proxy
                            // on the default channel. The out proxy will again compare cookies
                            // and will know which channel to forward the flow control ack to.
                            ASSERT(OutChannelState.State == http2svOpened);

                            RpcStatus = ForwardTrafficToDefaultChannel (
                                FALSE,  // IsInChannel
                                Buffer,
                                BufferLength
                                );
                            }

                        // handle a recycling request if necessary
                        RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                            TRUE        // IsFromUpcall
                            );

                        // since forwarding may fail if channels are discarded, consume
                        // the packet and ignore the failure
                        if (RpcStatus != RPC_S_OK)
                            {
                            RpcFreeBuffer(Buffer);
                            RpcStatus = RPC_S_OK;
                            }
                        }
                    else
                        {
                        // not a forwarded flow control ack after all. Just
                        // forward it using normal methods
                        RpcStatus = ForwardTrafficToDefaultChannel(
                            FALSE,  // IsInChannel
                            Buffer,
                            BufferLength
                            );
                        }
                    }
                else
                    {
                    RpcStatus = ForwardTrafficToDefaultChannel(
                        FALSE,  // IsInChannel
                        Buffer,
                        BufferLength
                        );
                    }

                RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                    TRUE        // IsFromUpcall
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                    RpcFreeBuffer(Buffer);
                    return RPC_P_PACKET_CONSUMED;
                    }

                // we no longer own the buffer
                BufferFreed = TRUE;
                }
            else if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                {
                // RTS packet is for us but is garbled
                AbortChannels(RPC_P_CONNECTION_CLOSED);
                RpcFreeBuffer(Buffer);
                return RPC_P_PACKET_CONSUMED;
                }
            else
                {
                RpcStatus = GetServerOpenedPacketType (Buffer,
                    BufferLength,
                    &PacketType
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                    RpcFreeBuffer(Buffer);
                    return RPC_P_PACKET_CONSUMED;
                    }

                if ((PacketType == http2soptD4_A8orD5_A8) || (PacketType == http2soptD2_A6orD3_A2))
                    {
                    InChannelState.Mutex.Request();
                    if (PacketType == http2soptD4_A8orD5_A8)
                        {
                        // determine whether it is D4/A8 or D5/A8 based on the state
                        // we are in
                        if (OutChannelState.State == http2svOpened_A8W)
                            PacketType = http2soptD4_A8;
                        else if (OutChannelState.State == http2svOpened_D5A8W)
                            PacketType = http2soptD5_A8;
                        else 
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                        }
                    else
                        {
                        // determine whether it is D2/A6 or D3/A2 based on the state
                        // we are in
                        if (InChannelState.State == http2svOpened_A6W)
                            PacketType = http2soptD2_A6;
                        else if (InChannelState.State == http2svOpened)
                            PacketType = http2soptD3_A2;
                        else 
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                        }
                    InChannelState.Mutex.Clear();
                    }

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                    RpcFreeBuffer(Buffer);
                    return RPC_P_PACKET_CONSUMED;
                    }

                switch (PacketType)
                    {
                    case http2soptD2_A6:
                        // this would better be D2/A6
                        RpcStatus = ParseAndFreeD2_A6 (Buffer,
                            BufferLength,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        // we got D2/A6. Cancel the timeout we setup with D2/A2
                        CancelTimeout(GetInChannelTimer());

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_P_CONNECTION_CLOSED);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        if (InChannelCookies[GetNonDefaultInChannelSelector()].Compare(&ChannelCookie))
                            {
                            // cookies don't match - nuke the channel
                            AbortChannels(RPC_P_CONNECTION_CLOSED);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        InChannelState.Mutex.Request();
                        // we haven't posted a receive yet - there is no
                        // way the state of the channel will change
                        ASSERT(InChannelState.State == http2svOpened_A6W);
                        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened_B1W, 1, 0);
                        InChannelState.State = http2svOpened_B1W;
                        InChannelState.Mutex.Clear();
                        break;

                    case http2soptD3_A2:
                        if (IsDefaultInChannel(ChannelId) == FALSE)
                            {
                            ASSERT(0);
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            RpcFreeBuffer(Buffer);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        RpcStatus = ParseAndFreeD3_A2 (Buffer,
                            BufferLength,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RpcStatus);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        // update the passed in cookie
                        InChannelCookies[DefaultInChannelSelector].SetCookie(ChannelCookie.GetCookie());

                        // pass D3/A3 back
                        EmptyRTS = AllocateAndInitializeEmptyRTSWithDestination (fdClient);
                        if (EmptyRTS == NULL)
                            {
                            AbortChannels(RpcStatus);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        RpcStatus = SendTrafficOnDefaultChannel (FALSE,     // IsInChannel
                            EmptyRTS
                            );

                        RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                            TRUE        // IsFromUpcall
                            );

                        break;

                    case http2soptD2_B1:
                        InChannelState.Mutex.Request();
                        if (InChannelState.State != http2svOpened_B1W)
                            {
                            InChannelState.Mutex.Clear();
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            RpcFreeBuffer(Buffer);
                            return RPC_P_PACKET_CONSUMED;
                            }
                        InChannelState.Mutex.Clear();

                        RpcStatus = ParseAndFreeEmptyRTS(Buffer,
                            BufferLength);

                        // we no longer own the buffer
                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;                        
                            }
                        // we're done with this channel. We want to switch
                        // channels and destroy
                        // and detach the channel.
                        SwitchDefaultInChannelSelector();

                        ChannelPtr = GetChannelPointerFromId(ChannelId);
                        InChannel = (HTTP2ServerInChannel *)ChannelPtr->LockChannelPointer();
                        if (InChannel == NULL)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;
                            }

                        InChannel2 = LockDefaultInChannel(&NewChannelPtr);
                        if (InChannel2 == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;
                            }

                        DataReceivePosted = InChannel->IsDataReceivePosted();

                        RpcStatus = InChannel->TransferReceiveStateToNewChannel(InChannel2);

                        NewChannelPtr->UnlockChannelPointer();
                        ChannelPtr->UnlockChannelPointer();

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        D2_B2Context = AllocateAndInitializeD2_B2 (HTTP2ServerReceiveWindow);
                        if (D2_B2Context == NULL)
                            {
                            AbortChannels(RPC_S_OUT_OF_MEMORY);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        // now that we have transferred the settings, we can open
                        // the pipeline from the new in proxy
                        RpcStatus = SendTrafficOnDefaultChannel(TRUE,    // IsInChannel
                            D2_B2Context
                            );

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            FreeRTSPacket(D2_B2Context);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        // detach, abort and free lifetime reference
                        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                            TRUE,   // CalledFromUpcallContext
                            TRUE,   // Abort
                            RPC_P_CONNECTION_SHUTDOWN
                            );

                        InChannelState.Mutex.Request();
                        // we haven't posted a receive yet - there is no
                        // way the state of the channel will change
                        ASSERT(InChannelState.State == http2svOpened_B1W);
                        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                        InChannelState.State = http2svOpened;
                        InChannelState.Mutex.Clear();

                        if (DataReceivePosted)
                            {
                            RpcStatus = PostReceiveOnDefaultChannel (
                                TRUE,   // IsInChannel
                                http2ttData
                                );

                            if (RpcStatus != RPC_S_OK)
                                {
                                AbortChannels(RPC_S_PROTOCOL_ERROR);
                                }
                            }

                        return RPC_P_PACKET_CONSUMED;
                        break;

                    case http2soptD4_A8:
                        // verify the new cookie against the old, and execute
                        // the detachment of the old channel after sending D4_A9
                        InChannelState.Mutex.Request();
                        if (OutChannelState.State != http2svOpened_A8W)
                            {
                            InChannelState.Mutex.Clear();
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        // move back to opened state
                        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                        OutChannelState.State = http2svOpened;
                        InChannelState.Mutex.Clear();

                        RpcStatus = ParseAndFreeD4_A8 (Buffer,
                            BufferLength,
                            fdServer,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        // we got D4/A8. Cancel the timeout we setup with D4/A4
                        CancelTimeout(GetOutChannelTimer());

                        if (RpcStatus != RPC_S_OK)
                            break;

                        if (OutChannelCookies[GetNonDefaultOutChannelSelector()].Compare(&ChannelCookie))
                            {
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        // lock the old channel
                        OutChannel = LockDefaultOutChannel(&ChannelPtr);
                        if (OutChannel == NULL)
                            {
                            RpcStatus = RPC_P_CONNECTION_CLOSED;
                            break;
                            }

                        // switch channels (new channel is still plugged)
                        SwitchDefaultOutChannelSelector();

                        // wait for all submits to get out of old channel
                        OutChannel->DrainPendingSubmissions();

                        // leave 1 for our lock
                        ChannelPtr->DrainPendingLocks(1);

                        // lock new channel (by now it is default)
                        NewOutChannel = LockDefaultOutChannel(&NewChannelPtr);
                        if (NewOutChannel == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_P_CONNECTION_CLOSED;
                            break;
                            }

                        // if flow control sender was queuing, grab all its buffers as well.
                        // Note that the flow control sender is higher in the stack and must
                        // be done first (to preserve packet ordering)
                        RpcpInitializeListHead(&NewBufferHead);
                        RpcStatus = OutChannel->GetFlowControlSenderBufferQueue(&NewBufferHead);
                        if (RpcStatus != RPC_S_OK)
                            {
                            // if we couldn't get the send contexts, they would have been
                            // freed in GetFlowControlSenderBufferQueue
                            NewChannelPtr->UnlockChannelPointer();
                            ChannelPtr->UnlockChannelPointer();
                            break;
                            }

                        AddBufferQueueToChannel(&NewBufferHead, NewOutChannel);

                        // GetChannelOriginatorBufferQueue must be called in submission
                        // context only. Get there
                        RpcStatus = OutChannel->BeginSimpleSubmitAsync();
                        if (RpcStatus != RPC_S_OK)
                            {
                            NewChannelPtr->UnlockChannelPointer();
                            ChannelPtr->UnlockChannelPointer();
                            break;
                            }

                        // if old channel was queuing, grab all its buffers. Since it is
                        // below the flow control sender, we must do it second to make sure
                        // they are before the flow control sender's buffers
                        RpcpInitializeListHead(&NewBufferHead);
                        RpcStatus = OutChannel->GetChannelOriginatorBufferQueue(&NewBufferHead);

                        OutChannel->FinishSubmitAsync();

                        if (RpcStatus != RPC_S_OK)
                            {
                            // if we couldn't get the send contexts, they would have been
                            // freed in GetChannelOriginatorBufferQueue
                            NewChannelPtr->UnlockChannelPointer();
                            ChannelPtr->UnlockChannelPointer();
                            break;
                            }

                        AddBufferQueueToChannel(&NewBufferHead, NewOutChannel);

                        // register the last packet to send with the old channel
                        D4_A9Context = AllocateAndInitializeD4_A9 ();

                        if (D4_A9Context == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            NewChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_S_OUT_OF_MEMORY;
                            break;
                            }

                        RpcStatus = OutChannel->Send(D4_A9Context);
                        if (RpcStatus != RPC_S_OK)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            NewChannelPtr->UnlockChannelPointer();
                            FreeRTSPacket(D4_A9Context);
                            break;
                            }

                        // D4_A9 was sent. We must switch the
                        // default loopback and detach the channel.
                        // Note that we don't abort the channel - we
                        // just release the lifetime reference
                        // When the proxy closes the connection, then
                        // we will abort
                        ChannelPtr->UnlockChannelPointer();

                        RpcStatus = NewOutChannel->Unplug();

                        NewChannelPtr->UnlockChannelPointer();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = RPC_P_PACKET_CONSUMED;

                        break;

                    case http2soptD5_A8:
                        // verify the new cookie against the old, and execute
                        // the detachment of the old channel after sending D4_A9
                        InChannelState.Mutex.Request();
                        if (OutChannelState.State != http2svOpened_D5A8W)
                            {
                            InChannelState.Mutex.Clear();
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        RpcStatus = ParseAndFreeD5_A8 (Buffer,
                            BufferLength,
                            fdServer,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        CancelTimeout(GetOutChannelTimer());

                        if (RpcStatus != RPC_S_OK)
                            {
                            InChannelState.Mutex.Clear();
                            break;
                            }

                        // we use the non-default out channel cookie simply as temporary storage
                        // b/n D5/A4 and D5/A8
                        if (OutChannelCookies[GetNonDefaultOutChannelSelector()].Compare(&ChannelCookie))
                            {
                            // the new channel is fake. Tell the proxy about it, and it will ditch it
                            D5_B1OrB2Context = AllocateAndInitializeD5_B1orB2 (FALSE);
                            if (D5_B1OrB2Context == NULL)
                                {
                                InChannelState.Mutex.Clear();
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                break;
                                }

                            RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
                                D5_B1OrB2Context);
                            if (RpcStatus != RPC_S_OK)
                                {
                                InChannelState.Mutex.Clear();
                                FreeRTSPacket(D5_B1OrB2Context);
                                break;
                                }

                            // move back to opened state
                            LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                            OutChannelState.State = http2svOpened;
                            InChannelState.Mutex.Clear();
                            break;
                            }

                        // the cookie matches. Move the new channel cookie from temporary to permanent
                        // storage and move the old channel cookie to temp storage

                        // move old cookie to temp storage
                        ChannelCookie.SetCookie(
                            OutChannelCookies[DefaultOutChannelSelector].GetCookie());
                        // move new cookie from class temp storage to permanent storage
                        OutChannelCookies[DefaultOutChannelSelector].SetCookie (
                            OutChannelCookies[GetNonDefaultOutChannelSelector()].GetCookie());
                        // move the old cookie from local temporary storage to class temporary storage
                        OutChannelCookies[GetNonDefaultOutChannelSelector()].SetCookie (
                            ChannelCookie.GetCookie());

                        // move back to opened state
                        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                        OutChannelState.State = http2svOpened;
                        InChannelState.Mutex.Clear();

                        OutChannel = LockDefaultOutChannel(&ChannelPtr);
                        if (OutChannel == NULL)
                            {
                            RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                            break;
                            }

                        OutChannel->PlugDataOriginatorChannel();

                        // Wait for everybody that was in to get out. This way we know
                        // the channel was plugged.

                        // we know that this will complete because eventually the runtime
                        // will flow control itself if there is no lull in sent traffic
                        OutChannel->DrainPendingSubmissions();

                        D5_B1OrB2Context = AllocateAndInitializeD5_B1orB2 (TRUE);
                        if (D5_B1OrB2Context == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_S_OUT_OF_MEMORY;
                            break;
                            }

                        RpcStatus = OutChannel->Send(D5_B1OrB2Context);
                        if (RpcStatus != RPC_S_OK)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            FreeRTSPacket(D5_B1OrB2Context);
                            break;
                            }

                        RpcStatus = OutChannel->RestartDataOriginatorChannel();

                        ChannelPtr->UnlockChannelPointer();

                        // fall through the error code
                        break;

                    default:
                        ASSERT(0);
                        break;
                    }
                }

            RpcStatus = PostReceiveOnDefaultChannel(
                TRUE,      // IsInChannel
                http2ttRTS
                );

            if (RpcStatus != RPC_S_OK)
                AbortChannels(RPC_P_CONNECTION_CLOSED);

            if (BufferFreed == FALSE)
                RpcFreeBuffer(Buffer);

            return RPC_P_PACKET_CONSUMED;                        
            }
        else
            {
            return EventStatus;
            }
        }
    else
        {
        if (EventStatus != RPC_S_OK)
            {
            if (IsDefaultOutChannel(ChannelId) == FALSE)
                {
                InChannelState.Mutex.Request();
                if ( (OutChannelState.State == http2svOpened)
                    || (OutChannelState.State == http2svNonDefaultChannelCloseWait))
                    {
                    // were in state where we were delaying recycling of the channel
                    // until the non-default channel is closed? See 
                    // HTTP2ServerVirtualConnection::RecycleChannel for more 
                    // information
                    if (OutChannelState.State == http2svNonDefaultChannelCloseWait)
                        {
                        ChannelRecyclingNeeded = TRUE;
                        OutChannelState.State = http2svOpened;
                        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                        }
                    else
                        ChannelRecyclingNeeded = FALSE;

                    // close on the non-default channel in open
                    // state is not an error. Just discard the channel
                    InChannelState.Mutex.Clear();

                    ChannelPtr = GetChannelPointerFromId(ChannelId);

                    if (ChannelPtr == NULL)
                        {
                        // This should never happen.
                        ASSERT(0);
                        return RPC_S_INTERNAL_ERROR;
                        }

                    if (ChannelRecyclingNeeded)
                        {
                        // we are currently on the non-default channel. Once we free it,
                        // we have nothing to keep the virtual connection alive while
                        // we trigger recycling. In order to protect the virtual
                        // connection from disappearing, we must get a second lock before
                        // we free our channel - Rule 39.
                        if (LockDefaultOutChannel(&DefaultChannelPtr) == NULL)
                            {
                            // the default out channel is gone - the connection is being
                            // aborted. Ignore the channel recycling and just bail out after
                            // cleanup
                            ASSERT(IsAborted());
                            ChannelRecyclingNeeded = FALSE;
                            // fall through. Next we will abort the channel and since
                            // ChannelRecyclingNeeded is FALSE, just bail out
                            }
                        }

                    OutChannel = (HTTP2ServerOutChannel *)ChannelPtr->LockChannelPointer();
                    if (OutChannel)
                        {
                        // make sure the pending sends are drained. Otherwise
                        // a send that is currently completing may violate 
                        // rule 38
                        OutChannel->DrainPendingSends();
                        ChannelPtr->UnlockChannelPointer();
                        }

                    ChannelPtr->FreeChannelPointer(
                        TRUE,    // DrainUpcalls
                        TRUE,    // CalledFromUpcallContext
                        TRUE,    // Abort
                        RPC_P_CONNECTION_SHUTDOWN
                        );

                    if (ChannelRecyclingNeeded)
                        {
                        RpcStatus = RecycleChannel(
                            TRUE    // IsFromUpcall
                            );

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RpcStatus);
                            // fall through to consuming the packet and returning.
                            // Since the channels are aborted, the pending operaitons 
                            // will come back and abort the connection.
                            }
                        DefaultChannelPtr->UnlockChannelPointer();
                        }

                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    BufferFreed = TRUE;
                    return RpcStatus;
                    }
                else
                    InChannelState.Mutex.Clear();
                }
            else if (InChannelState.State == http2svB2W)
                {
                // if this is a half open connection, treat
                // this as data receive and indicate it to the
                // runtime
                AbortChannels(EventStatus);

                // if we are still in this state, return error to the
                // runtime. Else, somebody else joined and we can ignore
                // this error
                InChannelState.Mutex.Request();
                if (InChannelState.State == http2svB2W)
                    {
                    // convert the state to closed. This is necessary so that
                    // if the in channel finally comes, it finds a closed
                    // connection and doesn't try to open it.
                    InChannelState.State = http2svClosed;

                    // Leave EventStatus as it is and fall through
                    }
                else
                    {
                    // consume the receive
                    EventStatus = RPC_P_PACKET_CONSUMED;
                    }
                InChannelState.Mutex.Clear();
                return EventStatus;
                }

            AbortChannels(EventStatus);

            // we expect only RTS traffic on this channel. Nobody would post
            // a data receive on this channel. Consume the receive
            return RPC_P_PACKET_CONSUMED;
            }

        if (IsRTSPacket(Buffer))
            {
            RpcStatus = HTTPTransInfo->CreateThread();
            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                AbortChannels(RPC_S_PROTOCOL_ERROR);
                return RPC_P_PACKET_CONSUMED;
                }

            IsOtherCmd = IsOtherCmdPacket(Buffer,
                BufferLength
                );

            RpcStatus = GetServerOutChannelOtherCmdPacketType (
                Buffer,
                BufferLength,
                &OutChannelPacketType
                );

            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                AbortChannels(RPC_S_PROTOCOL_ERROR);
                return RPC_P_PACKET_CONSUMED;
                }

            if (IsOtherCmd && (OutChannelPacketType == http2sococptFlowControl))
                {
                RpcStatus = ParseAndFreeFlowControlAckPacket (Buffer,
                    BufferLength,
                    &BytesReceivedForAck,
                    &WindowForAck,
                    &ChannelCookie
                    );

                if (RpcStatus == RPC_S_OK)
                    {
                    // notify the flow control sender
                    ChannelPtr = GetChannelPointerFromId(ChannelId);
                    OutChannel = (HTTP2ServerOutChannel *)ChannelPtr->LockChannelPointer();
                    // forward acks only on default channels. Non-default channels
                    // will have all their buffers transfered to the new channel in the
                    // immediate future. If we forward to them, we can cause nasty
                    // race conditions as another thread tries to get channels out of them
                    if (IsDefaultOutChannel(ChannelId))
                        {
                        if (OutChannel == NULL)
                            {
                            AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                            return RPC_P_PACKET_CONSUMED;
                            }

                        RpcStatus = OutChannel->FlowControlAckNotify(BytesReceivedForAck,
                            WindowForAck
                            );

                        RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                            TRUE        // IsFromUpcall
                            );
                        }

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus == RPC_S_OK)
                        {
                        // post another receive
                        RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                            http2ttRaw
                            );
                        }
                    }

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);
                    }
                }
            else if (IsOtherCmd && (OutChannelPacketType == http2sococptPingTrafficSentNotify))
                {
                RpcStatus = ParseAndFreePingTrafficSentNotifyPacket (Buffer,
                    BufferLength,
                    &PingTrafficSent
                    );

                if (RpcStatus == RPC_S_OK)
                    {
                    // notify the channel data originator
                    ChannelPtr = GetChannelPointerFromId(ChannelId);
                    OutChannel = (HTTP2ServerOutChannel *)ChannelPtr->LockChannelPointer();
                    if (OutChannel == NULL)
                        {
                        AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                        return RPC_P_PACKET_CONSUMED;
                        }

                    // prevent bogus values from the proxy. We allow no more than
                    // approximately MaxBytesSentByProxy bytes per BytesSentByProxyTimeInterval.
                    // The exact calculation doesn't matter. This requirement is so much below
                    // the bar necessary to attack the server, that anything close to it makes
                    // us safe
                    if (BytesSentByProxyTimeIntervalStart == 0)
                        BytesSentByProxyTimeIntervalStart = NtGetTickCount();
                    else
                        {
                        if (NtGetTickCount() - BytesSentByProxyTimeIntervalStart > BytesSentByProxyTimeInterval)
                            {
                            // start a new interval
                            BytesSentByProxyTimeIntervalStart = NtGetTickCount();
                            BytesSentByProxyForInterval = PingTrafficSent;
                            }
                        else
                            {
                            BytesSentByProxyForInterval += PingTrafficSent;
                            }

                        if (BytesSentByProxyForInterval > MaxBytesSentByProxy)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;
                            }
                        }

                    RpcStatus = OutChannel->NotifyDataOriginatorForTrafficSent (PingTrafficSent);

                    RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                        TRUE        // IsFromUpcall
                        );

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus == RPC_S_OK)
                        {
                        // post another receive
                        RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                            http2ttRaw
                            );
                        }
                    }

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);
                    }
                }
            else
                {
                // the only packet we expect here is D5/A4
                // we must be in Opened_A4W state for it
                InChannelState.Mutex.Request();
                if (OutChannelState.State != http2svOpened_A4W)
                    {
                    InChannelState.Mutex.Clear();
                    RpcFreeBuffer(Buffer);
                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                    return RPC_P_PACKET_CONSUMED;
                    }
                RpcStatus = ParseAndFreeD5_A4 (Buffer,
                    BufferLength,
                    &OutChannelCookies[GetNonDefaultOutChannelSelector()]
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                    InChannelState.Mutex.Clear();
                    return RPC_P_PACKET_CONSUMED;
                    }

                // move to Opened_A8W state
                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened_D5A8W, 1, 0);
                OutChannelState.State = http2svOpened_D5A8W;
                InChannelState.Mutex.Clear();

                RpcStatus = SetTimeout(DefaultNoResponseTimeout, GetOutChannelTimer());

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);
                    return RPC_P_PACKET_CONSUMED;
                    }

                // send out D5/A5
                D5_A5Context = AllocateAndInitializeD5_A5 (fdClient);

                if (D5_A5Context == NULL)
                    {
                    AbortChannels(RPC_S_OUT_OF_MEMORY);
                    return RPC_P_PACKET_CONSUMED;
                    }

                RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
                    D5_A5Context
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_S_OUT_OF_MEMORY);
                    FreeRTSPacket(D5_A5Context);
                    return RPC_P_PACKET_CONSUMED;
                    }

                RpcStatus = PostReceiveOnDefaultChannel(FALSE,      // IsInChannel
                    http2ttRaw
                    );

                if (RpcStatus != RPC_S_OK)
                    AbortChannels(RpcStatus);
                }

            return RPC_P_PACKET_CONSUMED;
            }
        else
            {
            // we shouldn't receive non-RTS packets on the out channel on the
            // server
            AbortChannels(RPC_S_PROTOCOL_ERROR);
            return RPC_P_PACKET_CONSUMED;
            }
        }
}

RPC_STATUS HTTP2ServerVirtualConnection::SyncSend (
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Does a sync send on a server HTTP connection.

Arguments:

    BufferLength - the length of the data to send.

    Buffer - the data to send.

    fDisableShutdownCheck - ignored

    fDisableCancelCheck - runtime indicates no cancel
        will be attempted on this send. Can be used
        as optimization hint by the transport

    Timeout - send timeout (call timeout)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    HTTP2SendContext *SendContext;
    HTTP2ServerOutChannel *Channel;
    HTTP2ChannelPointer *ChannelPtr;

#if DBG
    InChannelState.Mutex.Request();
    if ((OutChannelState.State == http2svOpened)
        || (OutChannelState.State == http2svNonDefaultChannelCloseWait) )
        {
        VerifyTimerNotSet(GetOutChannelTimer());
        }
    InChannelState.Mutex.Clear();
#endif

    // if the caller did not set a last buffer to free, we can't abandon the send
    // because we can't cleanup. Wait for the send to complete.
    if (IsLastBufferToFreeSet() == FALSE)
        {
        return HTTP2VirtualConnection::SyncSend (BufferLength,
            Buffer,
            fDisableShutdownCheck,
            fDisableCancelCheck,
            Timeout
            );
        }

    // we will complete this as an async send behind the covers
    // and we will fake success unless the submission itself
    // fails
    Channel = (HTTP2ServerOutChannel *)LockDefaultSendChannel (&ChannelPtr);
    if (Channel == NULL)
        {        
        return RPC_P_SEND_FAILED;
        }

    SendContext = Channel->GetLastSendContext();
    if (SendContext == NULL)
        {
        ChannelPtr->UnlockChannelPointer();
        return RPC_S_OUT_OF_MEMORY;
        }

    SendContext->u.BufferToFree = GetAndResetLastBufferToFree();
    SendContext->SetListEntryUnused();
    SendContext->maxWriteBuffer = BufferLength;
    SendContext->pWriteBuffer = Buffer;
    // SendContext->Write.pAsyncObject = NULL; // this will be initialized in the bottom layer
    SendContext->Write.ol.Internal = STATUS_PENDING;
    SendContext->TrafficType = http2ttData;
    SendContext->Write.ol.OffsetHigh = 0;
    // Clear any stale flags in case the context has been cached.
    SendContext->Flags = SendContextFlagAbandonedSend;
    SendContext->UserData = 0;

    RpcStatus = Channel->Send(SendContext);

    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        {
        // synchronous failure - cleanup
        RpcFreeBuffer(SendContext->u.BufferToFree);
        Channel->FreeLastSendContext(SendContext);
        }

    ChannelPtr->UnlockChannelPointer();

    //
    // If Send() returns RPC_P_CHANNEL_NEEDS_RECYCLING, then the SendContext
    // has been queued in HTTP2ChannelDataOriginator::Send() in BufferQueue
    // and HTTP2ChannelDataOriginator::Abort() will fail it later by posting
    // CHANNEL_DATA_ORIGINATOR_DIRECT_SEND in the case of communication breakdown.
    // 
    // We should make sure the send completes at most once.  Therefore, if we know
    // the send context will be taken off the queue during the abort, we will mask this
    // syncronous failure.
    //

    if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // make sure there is a thread to pick up the recycling events
        RpcStatus = HTTPTransInfo->CreateThread();
        if (RpcStatus != RPC_S_OK)
            {
            VALIDATE(RpcStatus)
                {
                RPC_S_OK,
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES,
                RPC_P_SEND_FAILED,
                RPC_S_CALL_CANCELLED,
                RPC_P_RECEIVE_COMPLETE,
                RPC_P_TIMEOUT
                } END_VALIDATE;

            // REVIEW: We may want to think what happens with the queued SendContext.
            // It may or may not get completed in this case.  Ideally, we would want
            // make sure that it will not complete if we are going to fail syncronously.
            return RpcStatus;
            }

        // get the ball rolling with the recycle
        RpcStatus = RecycleChannel(
            FALSE       // IsFromUpcall
            );

        VALIDATE(RpcStatus)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_S_CALL_CANCELLED,
            RPC_P_SEND_FAILED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_CONNECTION_CLOSED,
            RPC_P_TIMEOUT
            } END_VALIDATE;

        // Supress the sync failure.  The failure will be returned
        // during the abort on the completion of the queued send.
        if (RpcStatus != RPC_S_OK)
            {
            RpcStatus = RPC_S_OK;
            }
        }

    // Note that send can't really fail with protocol error. When
    // it happens it has simply picked the error with which
    // the connection was aborted. This is as good as a failed send.
    if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
        || (RpcStatus == RPC_P_RECEIVE_FAILED)
        || (RpcStatus == RPC_P_CONNECTION_CLOSED)
        || (RpcStatus == RPC_S_PROTOCOL_ERROR))
        RpcStatus = RPC_P_SEND_FAILED;

    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED,
        RPC_S_CALL_CANCELLED,
        RPC_P_RECEIVE_COMPLETE,
        RPC_P_TIMEOUT
        } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::InitializeServerConnection (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN WS_HTTP2_INITIAL_CONNECTION *Connection,
    OUT HTTP2ServerVirtualConnection **ServerVirtualConnection,
    OUT BOOL *VirtualConnectionCreated
    )
/*++

Routine Description:

    Initializes a server connection. Based on the content of the
    packet (i.e. D1/A2 or D1/B2), it will either initialize the
    out channel or the in channel respectively, and if it is
    the first leg of the connection establishment, establish the
    virtual connection itself and insert it into the cookie table

    Note: This function must initialize the type member and migrate the
    WS_HTTP2_INITIAL_CONNECTION after morphing it into
    WS_HTTP2_CONNECTION. The VirtualConnectionCreated parameter indicates
    whether this was done.

Arguments:

    Packet - received packet. Guaranteed to be present until PacketLength.
        On second leg, this function must not free the buffer. Ownership
        of the buffer remains with the caller.

    PacketLength - the lenght of the received packet.

    Connection - the received connection. It must be migrated
        and morphed into WS_HTTP2_CONNECTION on success. If the virtual
        connection was already created, then returning failure without
        un-migrating is fine. Cleanup paths will check and recognize this
        as HTTP2ServerVirtualConnection.

    ServerVirtualConnection - on successful return, the created server virtual
        connection

    VirtualConnectionCreated - if non-zero, the WS_HTTP2_INITIAL_CONNECTION
        was morphed into virtual connection. Else, the WS_HTTP2_INITIAL_CONNECTION
        is still around. Must be set on success and failure.

Return Value:

    RPC_S_OK or RPC_S_* for error. If we return RPC_S_OK, the packet will be
    consumed by caller. If we return anything else, it won't be.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    HTTP2FirstServerPacketType PacketType;
    WS_HTTP2_INITIAL_CONNECTION *OriginalConnection = Connection;
    HTTP2ServerInChannel *InChannel = NULL;
    HTTP2ServerOutChannel *OutChannel = NULL;
    HTTP2ServerCookie ServerCookie;
    HTTP2Cookie ChannelCookie;
    HTTP2Cookie NewChannelCookie;
    ULONG OutProxyReceiveWindow;
    ULONG ProtocolVersion;
    ULONG OutChannelLifetime;
    ULONG InProxyReceiveWindow;
    ULONG InProxyConnectionTimeout;
    ULONG OutProxyConnectionTimeout;
    HTTP2Cookie AssociationGroupId;
    ChannelSettingClientAddress ClientAddress;
    HTTP2ServerVirtualConnection *LocalServerConnection;
    HTTP2ServerVirtualConnection *VCPlaceHolder;
    BOOL FirstLeg;
    BOOL AbortServerConnection = FALSE;
    HTTP2ServerChannel *ThisChannel;
    HTTP2ChannelPointer *OtherChannelPtr;
    HTTP2SendContext *D1_C1Context;
    HTTP2SendContext *D1_B3Context;
    HTTP2SendContext *D2_A3Context;
    HTTP2SendContext *D4_A4Context;
    HTTP2SendContext *D4_A5Context;
    int NonDefaultChannel;

    *VirtualConnectionCreated = FALSE;

    // First, do a little bit of parsing to
    // determine if this is the first request for this connection
    // cookie. If not, join the other connection and destroy the
    // runtime stuff for this one. If yes, build a virtual connection
    RpcStatus = GetFirstServerPacketType(Packet,
        PacketLength,
        &PacketType
        );

    if (RpcStatus != RPC_S_OK)
        {
        // packet with failure will be propagated to the runtime
        return RpcStatus;
        }

    if (PacketType == http2fsptD1_A2)
        {
        RpcStatus = ParseD1_A2(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &OutChannelLifetime,
            &OutProxyReceiveWindow);

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        if (OutChannelLifetime < MinimumChannelLifetime)
            return RPC_S_PROTOCOL_ERROR;

        // a request to establish a new out connection
        RpcStatus = AllocateAndInitializeOutChannel (&Connection,
            OutChannelLifetime,
            &OutChannel);

        if (RpcStatus == RPC_S_OK)
            {
            // unplug the newly created out channel
            RpcStatus2 = OutChannel->Unplug ();
            // we know we can't fail here since there are no data in the pipe line
            ASSERT(RpcStatus2 == RPC_S_OK);

            OutChannel->SetPeerReceiveWindow(OutProxyReceiveWindow);
            }
        }
    else if (PacketType == http2fsptD1_B2)
        {
        RpcpMemorySet(&ClientAddress, 0, sizeof(ClientAddress));

        RpcStatus = ParseD1_B2(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &InProxyReceiveWindow,
            &InProxyConnectionTimeout,
            &AssociationGroupId,
            &ClientAddress
            );

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        // a request to establish a new in connection
        RpcStatus = AllocateAndInitializeInChannel (&Connection,
            &InChannel);
        }
    else if (PacketType == http2fsptD2_A2)
        {
        // in channel replacement
        RpcStatus = ParseD2_A2(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &NewChannelCookie,
            &InProxyReceiveWindow,
            &InProxyConnectionTimeout
            );

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        // a request to establish a replacement in connection
        RpcStatus = AllocateAndInitializeInChannel (&Connection,
            &InChannel);
        }
    else
        {
        ASSERT(PacketType == http2fsptD4_A4);

        // out channel replacement
        RpcStatus = ParseD4_A4(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &NewChannelCookie,
            &OutChannelLifetime,
            &OutProxyReceiveWindow,
            &OutProxyConnectionTimeout
            );

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        // a request to establish a replacement out connection
        RpcStatus = AllocateAndInitializeOutChannel (&Connection,
            OutChannelLifetime,
            &OutChannel);

        if (RpcStatus == RPC_S_OK)
            OutChannel->SetPeerReceiveWindow(OutProxyReceiveWindow);
        }

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    // take the lower of our and reported version
    ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

    // add the raw connection to the PnP list
    TransportProtocol::AddObjectToProtocolList(Connection);

    // figure out whether we arrived first or second
    GetServerCookieCollection()->LockCollection();

    LocalServerConnection = 
        (HTTP2ServerVirtualConnection *)GetServerCookieCollection()->FindElement(&ServerCookie);

    if (((PacketType == http2fsptD2_A2) || (PacketType == http2fsptD4_A4)) 
        && (LocalServerConnection == NULL))
        {
        // we cannot establish a replacement connection if the old one is not around
        OriginalConnection->fAborted = 1;
        OriginalConnection->pReadBuffer = NULL;
        RpcStatus = RPC_P_RECEIVE_FAILED;
        goto AbortFirstLegAndExit;
        }

    if (LocalServerConnection == NULL)
        {
        // we're first. Initialize the server virtual connection
        // we know the server has reserved space for the larger of
        // WS_HTTP2_INITIAL_CONNECTION and HTTP2ServerVirtualConnection.
        // Use the same space.

        VCPlaceHolder = (HTTP2ServerVirtualConnection *)OriginalConnection;
        LocalServerConnection = new (VCPlaceHolder) HTTP2ServerVirtualConnection(&ServerCookie,
            ProtocolVersion,
            &RpcStatus);

        if (RpcStatus == RPC_S_OK)
            {
            // we use the first timer for connection establishment
            RpcStatus = LocalServerConnection->SetTimeout(DefaultNoResponseTimeout,
                                                          LocalServerConnection->GetInChannelTimer());
            }

        if (RpcStatus != RPC_S_OK)
            {
            LocalServerConnection->HTTP2ServerVirtualConnection::~HTTP2ServerVirtualConnection();
            OriginalConnection->fAborted = 1;
            OriginalConnection->pReadBuffer = NULL;
            goto AbortFirstLegAndExit;
            }

        *VirtualConnectionCreated = TRUE;
        LocalServerConnection->id = HTTPv2;
        LocalServerConnection->type = COMPLEX_T | SERVER;
        FirstLeg = TRUE;
        }
    else
        {
        // the actual transport connection is by now owned by the channel
        // Create a fake connection in the current location that will no-op on
        // close.
        OriginalConnection->fAborted = 1;
        OriginalConnection->pReadBuffer = NULL;
        if (PacketType == http2fsptD2_A2)
            {
            // if this is a replacement channel, check the cookies
            if (LocalServerConnection->CompareCookieWithDefaultInChannelCookie(&ChannelCookie))
                {
                // cookies don't match. Nuke the newly established channel - it is probably
                // fake
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortFirstLegAndExit;
                }

            // we still hold the cookie collection mutex. This synchronizes with
            // aborts
            RpcStatus = LocalServerConnection->SetTimeout(DefaultNoResponseTimeout, 
                                                          LocalServerConnection->GetInChannelTimer());
            if (RpcStatus != RPC_S_OK)
                goto AbortFirstLegAndExit;
            }
        else if (PacketType == http2fsptD4_A4)
            {
            // if this is a replacement channel, check the cookies
            if (LocalServerConnection->CompareCookieWithDefaultOutChannelCookie(&ChannelCookie))
                {
                // cookies don't match. Nuke the newly established channel - it is probably
                // fake
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortFirstLegAndExit;
                }

            // we still hold the cookie collection mutex. This synchronizes with
            // aborts
            RpcStatus = LocalServerConnection->SetTimeout(DefaultNoResponseTimeout, 
                                                          LocalServerConnection->GetOutChannelTimer());
            if (RpcStatus != RPC_S_OK)
                goto AbortFirstLegAndExit;
            }

        FirstLeg = FALSE;
        }

    // set the runtime connection ptr for the raw connection
    Connection->RuntimeConnectionPtr = LocalServerConnection;

    LocalServerConnection->ProtocolVersion = min (ProtocolVersion, LocalServerConnection->ProtocolVersion);

    if (PacketType == http2fsptD1_A2)
        {
        if (LocalServerConnection->OutChannels[0].IsChannelSet())
            {
            // if we already have a second channel, then this is a protocol error
            RpcStatus = RPC_S_PROTOCOL_ERROR;
            goto AbortSecondLegAndExit;
            }

        LocalServerConnection->OutProxySettings[0].ReceiveWindow = OutProxyReceiveWindow;
        LocalServerConnection->OutProxySettings[0].ChannelLifetime = OutChannelLifetime;
        LocalServerConnection->OutChannelCookies[0].SetCookie(ChannelCookie.GetCookie());

        // attach the newly created stack to the connection
        LocalServerConnection->SetFirstOutChannel(OutChannel);
        OutChannel->SetParent(LocalServerConnection);

        if (FirstLeg)
            {
            ASSERT(LocalServerConnection->InChannelState.State == http2svClosed);
            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svB2W, 1, 0);
            LocalServerConnection->InChannelState.State = http2svB2W;
            GetServerCookieCollection()->AddElement(&LocalServerConnection->EmbeddedConnectionCookie);
            }
        else
            {
            // we got the second leg - cancel the timeout for the second leg
            LocalServerConnection->CancelTimeout(LocalServerConnection->GetInChannelTimer());

            if (LocalServerConnection->InChannelState.State != http2svA2W)
                {
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortSecondLegAndExit;
                }

            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svOpened, 1, 0);
            LocalServerConnection->InChannelState.State = http2svOpened;
            LocalServerConnection->OutChannelState.State = http2svOpened;

            ASSERT(InChannel == NULL);

            InChannel = LocalServerConnection->LockDefaultInChannel(&OtherChannelPtr);
            if (InChannel == NULL)
                {
                RpcStatus = RPC_P_RECEIVE_FAILED;
                goto AbortSecondLegAndExit;
                }
            InChannel->AddReference();
            OtherChannelPtr->UnlockChannelPointer();

            // for second leg, we need to add one reference before we release
            // the lock. Otherwise the pending receive on the first leg may
            // kill the connection and the channel with it
            OutChannel->AddReference();
            }
        }
    else if ((PacketType == http2fsptD1_B2) || (PacketType == http2fsptD2_A2))
        {
        if (PacketType == http2fsptD1_B2)
            {
            if (FirstLeg == FALSE)
                {
                // we got the second leg - cancel the timeout for the second leg
                LocalServerConnection->CancelTimeout(LocalServerConnection->GetInChannelTimer());
                }

            CopyClientAddress(&LocalServerConnection->ClientAddress,
                &ClientAddress);
            LocalServerConnection->InProxyReceiveWindows[0] = InProxyReceiveWindow;
            LocalServerConnection->InProxyConnectionTimeout = InProxyConnectionTimeout;
            LocalServerConnection->AssociationGroupId.SetCookie(AssociationGroupId.GetCookie());
            LocalServerConnection->InChannelCookies[0].SetCookie(ChannelCookie.GetCookie());

            // attach the newly created stack to the connection
            LocalServerConnection->SetFirstInChannel(InChannel);
            InChannel->SetParent(LocalServerConnection);
            }
        else
            {
            ASSERT(PacketType == http2fsptD2_A2);
            NonDefaultChannel = LocalServerConnection->GetNonDefaultInChannelSelector();
            LocalServerConnection->InProxyReceiveWindows[NonDefaultChannel] = InProxyReceiveWindow;
            LocalServerConnection->InProxyConnectionTimeout = InProxyConnectionTimeout;
            LocalServerConnection->InChannelCookies[NonDefaultChannel].SetCookie(NewChannelCookie.GetCookie());

            // attach the newly created stack to the connection
            LocalServerConnection->SetNonDefaultInChannel(InChannel);
            InChannel->SetParent(LocalServerConnection);

            if (LocalServerConnection->InChannelState.State != http2svOpened)
                {
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortSecondLegAndExit;
                }
            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svOpened_A6W, 1, 0);
            LocalServerConnection->InChannelState.State = http2svOpened_A6W;
            ASSERT(FirstLeg == FALSE);
            }

        if (FirstLeg)
            {
            ASSERT(LocalServerConnection->InChannelState.State == http2svClosed);
            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svA2W, 1, 0);
            LocalServerConnection->InChannelState.State = http2svA2W;
            GetServerCookieCollection()->AddElement(&LocalServerConnection->EmbeddedConnectionCookie);
            }
        else
            {
            if (PacketType == http2fsptD1_B2)
                {
                if (LocalServerConnection->InChannelState.State != http2svB2W)
                    {
                    // this can happen if the out channel managed to attach
                    // itself and then die
                    RpcStatus = RPC_P_RECEIVE_FAILED;
                    goto AbortSecondLegAndExit;
                    }
                LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                LocalServerConnection->InChannelState.State = http2svOpened;
                LocalServerConnection->OutChannelState.State = http2svOpened;
                }
            else
                {
                ASSERT(PacketType == http2fsptD2_A2);
                }

            ASSERT(OutChannel == NULL);

            OutChannel = LocalServerConnection->LockDefaultOutChannel(&OtherChannelPtr);
            if (OutChannel == NULL)
                {
                RpcStatus = RPC_P_RECEIVE_FAILED;
                goto AbortSecondLegAndExit;
                }
            OutChannel->AddReference();
            OtherChannelPtr->UnlockChannelPointer();

            // for second leg, we need to add one reference before we release
            // the lock. Otherwise the pending receive on the first leg may
            // kill the connection and the channel with it
            InChannel->AddReference();
            }
        }
    else if (PacketType == http2fsptD4_A4)
        {
        NonDefaultChannel = LocalServerConnection->GetNonDefaultOutChannelSelector();
        LocalServerConnection->OutProxySettings[NonDefaultChannel].ReceiveWindow = OutProxyReceiveWindow;
        LocalServerConnection->OutChannelCookies[NonDefaultChannel].SetCookie(NewChannelCookie.GetCookie());

        // attach the newly created stack to the connection
        LocalServerConnection->SetNonDefaultOutChannel(OutChannel);
        OutChannel->SetParent(LocalServerConnection);

        if (LocalServerConnection->OutChannelState.State != http2svOpened_A4W)
            {
            RpcStatus = RPC_S_PROTOCOL_ERROR;
            goto AbortSecondLegAndExit;
            }
        LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, OUT_CHANNEL_STATE, http2svOpened_A8W, 1, 0);
        LocalServerConnection->OutChannelState.State = http2svOpened_A8W;
        ASSERT(FirstLeg == FALSE);

        ASSERT(InChannel == NULL);

        InChannel = LocalServerConnection->LockDefaultInChannel(&OtherChannelPtr);
        if (InChannel == NULL)
            {
            RpcStatus = RPC_P_RECEIVE_FAILED;
            goto AbortSecondLegAndExit;
            }
        InChannel->AddReference();
        OtherChannelPtr->UnlockChannelPointer();

        // for second leg, we need to add one reference before we release
        // the lock. Otherwise the pending receive on the first leg may
        // kill the connection and the channel with it
        OutChannel->AddReference();
        }
    else
        {
        ASSERT(0);
        }

    // we have a virtual connection and at least one of its channels
    // attached to it. We have a no-op connection in OriginalConnection
    // by now. Any failure paths on the second leg must abort the virtual connection

    if ((PacketType == http2fsptD1_A2) || (PacketType == http2fsptD4_A4))
        {
        // out channel
        RpcStatus = OutChannel->Receive(http2ttRaw);
        ThisChannel = OutChannel;
        }
    else
        {
        ASSERT((PacketType == http2fsptD1_B2)
            || (PacketType == http2fsptD2_A2) );
        // in channel
        RpcStatus = InChannel->Receive(http2ttRTS);
        if ((PacketType == http2fsptD1_B2) && (RpcStatus == RPC_S_OK))
            {
            // naturally, we're also interested in data receives
            RpcStatus = InChannel->Receive(http2ttData);
            }
        ThisChannel = InChannel;
        }

    // Make sure HTTP2ServerVirtualConnection didn't forget to
    // initialize its type member
    if (FirstLeg && RpcStatus == RPC_S_OK)
        {
        ASSERT(LocalServerConnection->id == HTTPv2);
        ASSERT(LocalServerConnection->type & COMPLEX_T);
        }

    // Release the lock after posting a raw receive in order to syncronize the receive with
    // the in channel establishment.
    GetServerCookieCollection()->UnlockCollection();

    if (FirstLeg)
        {
        // this is the first leg. We know we are the only ones parting on
        // the connection. In case of error just return it back. The runtime
        // will turn around and close the connection
        }
    else
        {
        if ((PacketType == http2fsptD1_B2) || (PacketType == http2fsptD1_A2))
            {
            // the connection is fully fleshed out and both channels are plugged. Some
            // additional activity remains. We need to abort the runtime connection
            // for the second leg and remove the extra refcount
            if (RpcStatus == RPC_S_OK)
                {
                // we need to re-obtain the local server connection pointer through a safe mechanism. 
                // After we released the collection mutex, it may have been destroyed
                LocalServerConnection = (HTTP2ServerVirtualConnection *) InChannel->LockParentPointer();
                if (LocalServerConnection)
                    {                    
                    // we successfully submitted receives. Now send out D1/C1 and D1/B3
                    D1_C1Context = AllocateAndInitializeD1_C1(LocalServerConnection->ProtocolVersion,
                        LocalServerConnection->InProxyReceiveWindows[0],
                        LocalServerConnection->InProxyConnectionTimeout
                        );

                    if (D1_C1Context != NULL)
                        {
                        // we don't need to lock it, because we have a reference to it
                        RpcStatus = OutChannel->Send(D1_C1Context);

                        if (RpcStatus == RPC_S_OK)
                            {
                            D1_B3Context = AllocateAndInitializeD1_B3(HTTP2ServerReceiveWindow,
                                LocalServerConnection->ProtocolVersion
                                );
                            if (D1_B3Context != NULL)
                                {
                                RpcStatus = InChannel->Send(D1_B3Context);
                                if (RpcStatus != RPC_S_OK)
                                    FreeRTSPacket(D1_B3Context);
                                }
                            else
                                {
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                }
                            }
                        else
                            {
                            FreeRTSPacket(D1_C1Context);
                            }
                        }
                    else
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        }

                    InChannel->UnlockParentPointer();
                    }
                else
                    RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                }
            }
        else if (PacketType == http2fsptD2_A2)
            {
            // We have added the second channel to the connection. Keep the ball
            // rolling
            if (RpcStatus == RPC_S_OK)
                {
                // After we released the collection mutex, it may have been destroyed
                LocalServerConnection = (HTTP2ServerVirtualConnection *) OutChannel->LockParentPointer();
                if (LocalServerConnection)
                    {                    
                    // we successfully submitted receives. Now send out D2/A3
                    D2_A3Context = AllocateAndInitializeD2_A3(fdClient,
                        LocalServerConnection->ProtocolVersion,
                        LocalServerConnection->InProxyReceiveWindows[NonDefaultChannel],
                        LocalServerConnection->InProxyConnectionTimeout
                        );

                    if (D2_A3Context != NULL)
                        {
                        // we don't need to lock it, because we have a reference to it.
                        RpcStatus = OutChannel->Send(D2_A3Context);

                        if ((RpcStatus != RPC_S_OK)
                            && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
                            {
                            FreeRTSPacket(D2_A3Context);
                            }

                        // handle a recycling request if necessary
                        RpcStatus = LocalServerConnection->StartChannelRecyclingIfNecessary(RpcStatus,
                            FALSE        // IsFromUpcall
                            );                        
                        }
                    else
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        }

                    OutChannel->UnlockParentPointer();
                    }
                else
                    RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                }
            }
        else
            {
            ASSERT(PacketType == http2fsptD4_A4);

            // We have added the second channel to the connection. Keep the ball
            // rolling
            if (RpcStatus == RPC_S_OK)
                {
                // After we released the collection mutex, it may have been destroyed
                LocalServerConnection = (HTTP2ServerVirtualConnection *) OutChannel->LockParentPointer();
                if (LocalServerConnection)
                    {                    
                    // we successfully submitted receives. Now send out D4/A5
                    D4_A5Context = AllocateAndInitializeD4_A5(fdClient,
                        LocalServerConnection->ProtocolVersion,
                        OutProxyConnectionTimeout
                        );

                    if (D4_A5Context != NULL)
                        {
                        // We still need to send on the default channel. Obtain
                        // a pointer through the virtual connection
                        RpcStatus = LocalServerConnection->SendTrafficOnDefaultChannel(FALSE,   // IsInChannel
                            D4_A5Context
                            );
                        if (RpcStatus != RPC_S_OK)
                            FreeRTSPacket(D4_A5Context);
                        }
                    else
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        }

                    OutChannel->UnlockParentPointer();
                    }
                else
                    RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                }
            }

        if (RpcStatus != RPC_S_OK)
            {
            // we can't directly access the connection because we don't have
            // a way to prevent it from going away underneath us. We do it through
            // the channels instead (on which we do have a refcount)
            LocalServerConnection = (HTTP2ServerVirtualConnection *)ThisChannel->LockParentPointer();
            if (LocalServerConnection)
                {
                LocalServerConnection->AbortChannels(RpcStatus);
                ThisChannel->UnlockParentPointer();
                }
            }

        InChannel->RemoveReference();
        OutChannel->RemoveReference();

        if (RpcStatus == RPC_S_OK)
            {
            // fake failure to the runtime. We have migrated our transport connection
            // to the virtual connection and we don't need this one anymore
            RpcStatus = RPC_P_RECEIVE_FAILED;
            }
        }

    return RpcStatus;

AbortSecondLegAndExit:
    ASSERT(FirstLeg == FALSE);

    LocalServerConnection->Abort();

    GetServerCookieCollection()->UnlockCollection();

    // We do not need to unlink the added connection from the PnP list
    // since this will be done on Free().

    // the original connection must be WS_HTTP2_INITIAL_CONNECTION
    ASSERT(OriginalConnection->id == HTTP);

    ASSERT(RpcStatus != RPC_S_OK);

    return RpcStatus;

AbortFirstLegAndExit:
    // we failed to create a server connection. Release all locks and fail
    GetServerCookieCollection()->UnlockCollection();

    // the original connection must be WS_HTTP2_INITIAL_CONNECTION
    ASSERT(OriginalConnection->id == HTTP);

    // destroy the channel created during the first leg
    if ((PacketType == http2fsptD1_A2) || (PacketType == http2fsptD4_A4))
        {
        OutChannel->Abort(RpcStatus);
        OutChannel->RemoveReference();
        }
    else
        {
        ASSERT((PacketType == http2fsptD1_B2) || (PacketType == http2fsptD2_A2));
        InChannel->Abort(RpcStatus);
        InChannel->RemoveReference();
        }

    ASSERT(RpcStatus != RPC_S_OK);

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::AllocateAndInitializeInChannel (
    IN OUT WS_HTTP2_INITIAL_CONNECTION **Connection,
    OUT HTTP2ServerInChannel **ReturnInChannel
    )
/*++

Routine Description:

    Initializes a server in channel. 

    Note: This function must migrate the WS_HTTP2_INITIAL_CONNECTION after 
    morphing it into WS_HTTP2_CONNECTION

Arguments:

    Connection - on input, the received connection. It must be migrated
        and morphed into WS_HTTP2_CONNECTION on success. All failure paths
        must be sure to move the WS_HTTP2_INITIAL_CONNECTION back to its
        original location.

    ReturnInChannel - on successful return, the created server in channel

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ServerInChannel *InChannel;
    HTTP2EndpointReceiver *EndpointReceiver;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL EndpointReceiverNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
        + sizeof(WS_HTTP2_CONNECTION);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2ServerInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerInChannel);

    EndpointReceiver = (HTTP2EndpointReceiver *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver);

    RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    EndpointReceiverNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;

    // Wait for any pending IO to get out.
    while((*Connection)->IsIoStarting())
        Sleep(1);

    RpcpMemoryCopy(RawConnection, *Connection, sizeof(WS_HTTP2_CONNECTION));

    RawConnection->HeaderRead = TRUE;
    RawConnection->ReadHeaderFn = NULL;
    RawConnection->Read.pAsyncObject = RawConnection;
    RawConnection->type = COMPLEX_T | CONNECTION | SERVER;
    RawConnection->fAborted = 1;    // this connection must not be aborted
                                    // unless we successfully initialize
                                    // the channel. Therefore, artificially
                                    // abort the connection (preventing real
                                    // aborts) until we initialize the channel

    // Since Initialize() is not called, we need to init fIgnoreFree explicitly.
    RawConnection->fIgnoreFree = FALSE;

    RawConnection = new (RawConnection) WS_HTTP2_CONNECTION;

    RpcStatus = RPC_S_OK;

    RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    EndpointReceiver = new (EndpointReceiver) HTTP2EndpointReceiver (HTTP2ServerReceiveWindow,
        TRUE,   // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        EndpointReceiver->HTTP2EndpointReceiver::~HTTP2EndpointReceiver();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(EndpointReceiver);
    EndpointReceiver->SetLowerChannel(RawChannel);

    EndpointReceiverNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2ServerInChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2ServerInChannel::~HTTP2ServerInChannel();
        goto AbortAndExit;
        }

    EndpointReceiver->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(EndpointReceiver);

    RawChannel->SetTopChannel(InChannel);
    EndpointReceiver->SetTopChannel(InChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    RawConnection->fAborted = 0;

    *ReturnInChannel = InChannel;
    *Connection = (WS_HTTP2_INITIAL_CONNECTION *)RawConnection;

    goto CleanupAndExit;

AbortAndExit:

    // No need to clean up the raw connection.
    // If we failed, the virtual connection
    // is not created, and the caller will abort
    // the original conneciton.
    //
    // We need to make sure that this failure path
    // will not try freeing the raw connection.
    // For this we set fIgnoreFree to true to ensure that
    // the free will be ignored.

    ASSERT(RpcStatus != RPC_S_OK);

    RawConnection->fIgnoreFree = TRUE;

    if (EndpointReceiverNeedsCleanup)
        {
        EndpointReceiver->Abort(RpcStatus);
        EndpointReceiver->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }

    RawConnection->fIgnoreFree = FALSE;

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::AllocateAndInitializeOutChannel (
    IN OUT WS_HTTP2_INITIAL_CONNECTION **Connection,
    IN ULONG OutChannelLifetime,
    OUT HTTP2ServerOutChannel **ReturnOutChannel
    )
/*++

Routine Description:

    Initializes a server out channel. 

    Note: This function must migrate the WS_HTTP2_INITIAL_CONNECTION after 
    morphing it into WS_HTTP2_CONNECTION

Arguments:

    Connection - on input, the received connection. It must be migrated
        and morphed into WS_HTTP2_CONNECTION on success. All failure paths
        must be sure to move the WS_HTTP2_INITIAL_CONNECTION back to its
        original location.

    OutChannelLifetime - the lifetime on the out channel.

    ReturnOutChannel - on successful return, the created server out channel

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ServerOutChannel *OutChannel;
    HTTP2PlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2ChannelDataOriginator *ChannelDataOriginator;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL ChannelDataOriginatorNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the out channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
        + SIZE_OF_OBJECT_AND_PADDING(WS_HTTP2_CONNECTION)
        + sizeof(HTTP2SendContext)      // send context for the last send
        ;

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2ServerOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerOutChannel);

    PlugChannel = (HTTP2PlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    ChannelDataOriginator = (HTTP2ChannelDataOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator);

    RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    ChannelDataOriginatorNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;

    // migrate the connection to its new location. Since nobody points to it (we have
    // been unlinked from the PnP list), copying is sufficient

    // Wait for any pending IO to get out.
    while((*Connection)->IsIoStarting())
        Sleep(1);

    RpcpMemoryCopy(RawConnection, *Connection, sizeof(WS_HTTP2_CONNECTION));
    RawConnection->HeaderRead = TRUE;
    RawConnection->Read.pAsyncObject = RawConnection;
    RawConnection->type = COMPLEX_T | CONNECTION | SERVER;
    RawConnection->fAborted = 1;    // this connection must not be aborted
                                    // unless we successfully initialize
                                    // the channel. Therefore, artificially
                                    // abort the connection (preventing real
                                    // aborts) until we initialize the channel

    // Since Initialize() is not called, we need to init fIgnoreFree explicitly.
    RawConnection->fIgnoreFree = FALSE;

    RawConnection = new (RawConnection) WS_HTTP2_CONNECTION;

    RpcStatus = RPC_S_OK;

    RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    ChannelDataOriginator = new (ChannelDataOriginator) HTTP2ChannelDataOriginator (OutChannelLifetime,
        TRUE,   // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ChannelDataOriginator->HTTP2ChannelDataOriginator::~HTTP2ChannelDataOriginator();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(ChannelDataOriginator);
    ChannelDataOriginator->SetLowerChannel(RawChannel);

    ChannelDataOriginatorNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (TRUE,       // IsServer
        TRUE,       // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    ChannelDataOriginator->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(ChannelDataOriginator);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2PlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2PlugChannel::~HTTP2PlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2ServerOutChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2ServerOutChannel::~HTTP2ServerOutChannel();
        goto AbortAndExit;
        }

    RawChannel->SetTopChannel(OutChannel);
    ChannelDataOriginator->SetTopChannel(OutChannel);
    FlowControlSender->SetTopChannel(OutChannel);
    PlugChannel->SetTopChannel(OutChannel);

    PlugChannel->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(PlugChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    RawConnection->fAborted = 0;

    *ReturnOutChannel = OutChannel;
    *Connection = (WS_HTTP2_INITIAL_CONNECTION *)RawConnection;

    goto CleanupAndExit;

AbortAndExit:

    // We need to make sure that this failure path
    // will not try freeing the raw connection.
    // For this we set fIgnoreFree to true to ensure that
    // the free will be ignored.

    RawConnection->fIgnoreFree = TRUE;

    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (ChannelDataOriginatorNeedsCleanup)
        {
        ChannelDataOriginator->Abort(RpcStatus);
        ChannelDataOriginator->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }

    RawConnection->fIgnoreFree = FALSE;

    // no need to clean up the raw connection.
    // If we failed, the virtual connection
    // is not created, and the caller will abort
    // the original conneciton

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

void HTTP2ServerVirtualConnection::TimeoutExpired (
    IN TimerContext *pTimer
    )
/*++

Routine Description:

    A timeout expired before we cancelled the timer. Abort the connection.

Arguments:

    pTimer - Pointer to the timer context for which the timeour has expired.

Return Value:

--*/
{
    VerifyValidTimer(pTimer);

    AbortChannels(RPC_P_TIMEOUT);

    // Once we mark the timer as expired, we are no longer protected from
    // the virtual connection being freed during the timer callback.
    // We can't touch the virtual connection after this call.
    TimerExpiredNotify(pTimer);
}

void HTTP2ServerVirtualConnection::DrainOutChannelPendingSends (
    void
    )
/*++

Routine Description:

    Make sure all out channels have their sends drained.

Arguments:

Return Value:

--*/
{
    int i;
    HTTP2ServerOutChannel *OutChannel;

    for (i = 0; i < 2; i ++)
        {
        OutChannel = (HTTP2ServerOutChannel *)OutChannels[i].LockChannelPointer();
        if (OutChannel)
            {
            // make sure the pending sends are drained. Otherwise
            // a send that is currently completing may violate 
            // rule 38
            OutChannel->DrainPendingSends();
            OutChannels[i].UnlockChannelPointer();
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\httprts.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    HttpRTS.cxx

Abstract:

    HTTP2 RTS packets support functions.

Author:

    KamenM      09-07-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <HttpRTS.hxx>


const int TunnelSettingsCommandTypeSizes[LAST_RTS_COMMAND + 1] = 
    {
    sizeof(ULONG),    // tsctReceiveWindowSize
    sizeof(FlowControlAck),    // tsctFlowControlAck
    sizeof(ULONG),    // tsctConnectionTimeout
    sizeof(ChannelSettingCookie),    // tsctCookie
    sizeof(ULONG),    // tsctChannelLifetime
    sizeof(ULONG),    // tsctClientKeepalive
    sizeof(ULONG),    // tsctVersion
    0,    // tsctEmpty
    sizeof(ULONG),    // tsctPadding - size is variable. This is only for the conformance count
    0,    // tsctNANCE - no operands
    0,    // tsctANCE - no operands
    sizeof(ChannelSettingClientAddress),     // tsctClientAddress
    sizeof(ChannelSettingCookie),    // tsctAssociationGroupId
    sizeof(ULONG),      // tsctDestination
    sizeof(ULONG)       // tsctPingTrafficSentNotify
    };

const int ClientAddressSizes[] = 
    {
    FIELD_OFFSET(ChannelSettingClientAddress, u) + sizeof(SOCKADDR_IN),
    FIELD_OFFSET(ChannelSettingClientAddress, u) + sizeof(SOCKADDR_IN6)
    };

BYTE *ValidateRTSPacketCommon (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Validates the common portions of an RTS packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    A pointer to the location after the common part if successful.
    NULL is validation failed.

--*/
{
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;

    if (PacketLength < BaseRTSSizeAndPadding)
        {
        CORRUPTION_ASSERT(0);
        return NULL;
        }

    if (RTS->common.frag_length != (unsigned short) PacketLength)
        {
        CORRUPTION_ASSERT(0);
        return NULL;
        }

    if (   (RTS->common.rpc_vers != OSF_RPC_V20_VERS)
        || (RTS->common.rpc_vers_minor > OSF_RPC_V20_VERS_MINOR))
        {
        CORRUPTION_ASSERT(0);
        return NULL;
        }

    if (RTS->common.pfc_flags != (PFC_FIRST_FRAG | PFC_LAST_FRAG))
        {
        CORRUPTION_ASSERT(0);
        return NULL;
        }

    if (RTS->common.drep[0] != NDR_LITTLE_ENDIAN)
        {
        CORRUPTION_ASSERT(0);
        return NULL;
        }

    if ((RTS->common.auth_length != 0)
        || (RTS->common.call_id != 0))
        {
        CORRUPTION_ASSERT(0);
        return NULL;
        }

    return (Packet + BaseRTSSizeAndPadding);
}

RPC_STATUS CheckPacketForForwarding (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations CurrentLocation
    )
/*++

Routine Description:

    Checks whether a packet needs forwarding, and if yes,
    patches up the protocol version if it is present.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

    CurrentLocation - the current location we're in. This is how
        this routine knows whether to forward.

Return Value:

    RPC_S_OK for success (means the packet is for us)
    RPC_P_PACKET_NEEDS_FORWARDING - success, but packet is not for us
    RPC_S_PROTOCOL_ERROR - packet is garbled and cannot be processed

--*/
{
    BYTE *CurrentPosition;
    ULONG CurrentLength;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    TunnelSettingsCommand *CurrentCommand;
    int i;
    BOOL ForwardingNeeded;
    
    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return RPC_S_PROTOCOL_ERROR;

    ForwardingNeeded = FALSE;
    CurrentLength = CurrentPosition - Packet;
    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;
    for (i = 0; i < RTS->NumberOfSettingCommands; i ++)
        {
        // check if there is enough to read the command after this
        CurrentLength += BaseRTSCommandSize;
        if (CurrentLength > PacketLength)
            return RPC_S_PROTOCOL_ERROR;

        if (CurrentCommand->CommandType == tsctDestination)
            {
            CurrentLength += SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination);
            if (CurrentLength > PacketLength)
                return RPC_S_PROTOCOL_ERROR;
            if (CurrentCommand->u.Destination == CurrentLocation)
                return RPC_S_OK;

            ForwardingNeeded = TRUE;
            }
        else
            {
            if (CurrentCommand->CommandType > LAST_RTS_COMMAND)
                return RPC_S_PROTOCOL_ERROR;

            CurrentLength += SIZE_OF_RTS_CMD_AND_PADDING(CurrentCommand->CommandType);
            }
        
        CurrentCommand = (TunnelSettingsCommand *)(Packet + CurrentLength);
        }

    if (ForwardingNeeded)
        {
        return RPC_P_PACKET_NEEDS_FORWARDING;
        }

    return RPC_S_OK;
}

BOOL UntrustedIsPingPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Checks if a packet coming from an untrusted source is a
    ping packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    non-zero if it is a valid ping packet.
    zero if it is a valid non-ping packet or if it is an
    invalid packet.

--*/
{
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;

    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return FALSE;

    RTS = (rpcconn_tunnel_settings *)Packet;

    return (RTS->Flags & RTS_FLAG_PING);
}

BOOL IsEchoPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Checks if a packet is an echo packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    non-zero if it is a valid echo packet.
    zero if it is a valid non-echo packet or if it is an
    invalid packet.

--*/
{
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;

    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return FALSE;

    RTS = (rpcconn_tunnel_settings *)Packet;

    return (RTS->Flags & RTS_FLAG_ECHO);
}

BOOL IsOtherCmdPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Checks if a packet coming from an untrusted source is a
    other cmd packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    non-zero if it is a valid other cmd packet.
    zero if it is not a valid other cmd packet.

--*/
{
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;

    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return FALSE;

    RTS = (rpcconn_tunnel_settings *)Packet;

    return (RTS->Flags & RTS_FLAG_OTHER_CMD);
}

HTTP2SendContext *AllocateAndInitializePingPacket (
    void
    )
/*++

Routine Description:

    Allocates and initializes an RTS ping packet

Arguments:

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        0
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_PING;
        RTS->NumberOfSettingCommands = 0;
        }

    return SendContext;
}

HTTP2SendContext *AllocateAndInitializePingPacketWithSize (
    IN ULONG TotalPacketSize
    )
/*++

Routine Description:

    Allocates and initializes an RTS ping packet padding
    the packet until a certain size.

Arguments:

    TotalPacketSize - the total desired size of the packet.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;
    BOOL UseEmpty;
    ULONG ExtraSize;

    // the size of empty must be 0 for the calculation below to work
    ASSERT(SIZE_OF_RTS_CMD_AND_PADDING(tsctEmpty) == 0);

    ASSERT(TotalPacketSize >= BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctEmpty));

    // reduce the TotalPacketSize to the size of the actual padding
    // We subtract the base packet size + the padding command itself
    TotalPacketSize -= BaseRTSCommandSize * 1
        + BaseRTSSizeAndPadding;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + TotalPacketSize
        );

    if (SendContext)
        {
        // if we were required to use larger size, we'll use the padding.
        // if it was smaller, we'll use the empty command
        if (TotalPacketSize >= SIZE_OF_RTS_CMD_AND_PADDING(tsctPadding))
            {
            TotalPacketSize -= SIZE_OF_RTS_CMD_AND_PADDING(tsctPadding);
            UseEmpty = FALSE;
            }
        else
            {
            TotalPacketSize -= SIZE_OF_RTS_CMD_AND_PADDING(tsctEmpty);
            UseEmpty = TRUE;
            }

        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_PING;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        if (UseEmpty)
            {
            // set empty command
            CurrentCommand->CommandType = tsctEmpty;
            }
        else
            {
            // set padding command
            CurrentCommand->CommandType = tsctPadding;
            CurrentCommand->u.ConformanceCount = TotalPacketSize;
            CurrentCommand = SkipCommand(CurrentCommand, tsctPadding);

            // clean out the padding bytes
            RpcpMemorySet(CurrentCommand, 0, TotalPacketSize);
            }
        }

    return SendContext;
}

RPC_STATUS ParseAndFreePingPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a ping packet.
    N.B.: UntrustedIsPingPacket must have
    already been called and returned non-zero
    for this function to be used.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    RPC_S_OK for success
    RPC_S_PROTOCOL_ERROR for garbled packet

--*/
{
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    RPC_STATUS RpcStatus;

    if (RTS->NumberOfSettingCommands != 0)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_PING)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

ULONG GetD1_A1TotalLength (
    void
    )
/*++

Routine Description:

    Calculates the length of a D1/A1 RTS packet

Arguments:

Return Value:

    The length of the D1/A1 RTS packet.

--*/
{
    return (BaseRTSSizeAndPadding
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );
}

HTTP2SendContext *AllocateAndInitializeEmptyRTS (
    void
    )
/*++

Routine Description:

    Allocates and initializes an empty RTS packet

Arguments:

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set empty command
        CurrentCommand->CommandType = tsctEmpty;
        }

    return SendContext;
}

RPC_STATUS ParseEmptyRTS (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses an empty RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify empty
    if (CurrentCommand->CommandType != tsctEmpty)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}


RPC_STATUS ParseAndFreeEmptyRTS (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees an empty RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseEmptyRTS(Packet,
        PacketLength
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeEmptyRTSWithDestination (
    IN ForwardDestinations Destination
    )
/*++

Routine Description:

    Allocates and initializes an empty RTS packet

Arguments:

    Destination - where to forward this to.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        }

    return SendContext;
}

RPC_STATUS ParseEmptyRTSWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses an empty RTS packet with destination

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeEmptyRTSWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses and frees an empty RTS packet with destination

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseEmptyRTSWithDestination (Packet,
        PacketLength,
        ExpectedDestination
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_A1 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ClientReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D1/A1 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 4;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set client receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ClientReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_A1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ClientReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 4)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get client receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ClientReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_A2 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ChannelLifetime,
    IN ULONG ProxyReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D1/A2 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 5;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel lifetime
        CurrentCommand->CommandType = tsctChannelLifetime;
        CurrentCommand->u.ChannelLifetime = ChannelLifetime;
        CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

        // set proxy receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ProxyReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseD1_A2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ChannelLifetime,
    OUT ULONG *ProxyReceiveWindow
    )
/*++

Routine Description:

    Parses D1/A2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 5)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OUT_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel lifetime
    if (CurrentCommand->CommandType != tsctChannelLifetime)
        goto AbortAndExit;
    *ChannelLifetime = CurrentCommand->u.ChannelLifetime;
    CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

    // get proxy receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ProxyReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_B1 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ChannelLifetime,
    IN ULONG ClientKeepAliveInterval,
    IN HTTP2Cookie *AssociationGroupId
    )
/*++

Routine Description:

    Allocates and initializes a D1/B1 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ChannelLifetime - the lifetime of the channel

    ClientKeepAliveInterval - the client receive window

    AssociationGroupId - the association group id

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctAssociationGroupId)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 6;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel lifetime
        CurrentCommand->CommandType = tsctChannelLifetime;
        CurrentCommand->u.ChannelLifetime = ChannelLifetime;
        CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

        // set client receive window
        CurrentCommand->CommandType = tsctClientKeepalive;
        CurrentCommand->u.ClientKeepalive = ClientKeepAliveInterval;
        CurrentCommand = SkipCommand(CurrentCommand, tsctClientKeepalive);

        // set association group id
        CurrentCommand->CommandType = tsctAssociationGroupId;
        RpcpMemoryCopy(CurrentCommand->u.AssociationGroupId.Cookie, AssociationGroupId->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_B1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ChannelLifetime,
    OUT HTTP2Cookie *AssociationGroupId,
    OUT ULONG *ClientKeepAliveInterval
    )
/*++

Routine Description:

    Parses and frees a D1/B1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - on output, the version of the HTTP tunnelling protocol
        Success only.

    ConnectionCookie - on output, the connection cookie. Success only.

    ChannelCookie - on output, the channel cookie. Success only.

    ChannelLifetime - on output, the lifetime of the channel. Success only.

    AssociationGroupId - on output, the client association group id.
        Success only.

    ClientKeepAliveInterval - on output, the client receive window.
        Success only.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctAssociationGroupId)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 6)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel lifetime
    if (CurrentCommand->CommandType != tsctChannelLifetime)
        goto AbortAndExit;
    *ChannelLifetime = CurrentCommand->u.ChannelLifetime;
    CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

    // get client keep alive
    if (CurrentCommand->CommandType != tsctClientKeepalive)
        goto AbortAndExit;
    *ClientKeepAliveInterval = CurrentCommand->u.ClientKeepalive;
    CurrentCommand = SkipCommand(CurrentCommand, tsctClientKeepalive);

    // get association group id
    if (CurrentCommand->CommandType != tsctAssociationGroupId)
        goto AbortAndExit;
    AssociationGroupId->SetCookie((BYTE *)CurrentCommand->u.AssociationGroupId.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_B2 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ReceiveWindowSize,
    IN ULONG ConnectionTimeout,
    IN HTTP2Cookie *AssociationGroupId,
    IN ChannelSettingClientAddress *ClientAddress
    )
/*++

Routine Description:

    Allocates and initializes a D1/B2 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

    ClientAddress - client address of the client as seen by the in proxy

    AssociationGroupId - the association group id

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctAssociationGroupId)
        + ClientAddressSizes[ClientAddress->AddressType]
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_IN_CHANNEL;
        RTS->NumberOfSettingCommands = 7;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set receive window size
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

        // set association group id
        CurrentCommand->CommandType = tsctAssociationGroupId;
        RpcpMemoryCopy(CurrentCommand->u.AssociationGroupId.Cookie, AssociationGroupId->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctAssociationGroupId);

        // set client address.
        CurrentCommand->CommandType = tsctClientAddress;
        CurrentCommand->u.ClientAddress.AddressType = ClientAddress->AddressType;
        RpcpMemorySet(&CurrentCommand->u, 0, ClientAddressSizes[ClientAddress->AddressType]);
        if (ClientAddress->AddressType == catIPv4)
            {
            RpcpCopyIPv4Address((SOCKADDR_IN *)ClientAddress->u.IPv4Address,
                (SOCKADDR_IN *) CurrentCommand->u.ClientAddress.u.IPv4Address);
            }
        else
            {
            RpcpCopyIPv6Address((SOCKADDR_IN6 *)ClientAddress->u.IPv4Address,
                (SOCKADDR_IN6 *) CurrentCommand->u.ClientAddress.u.IPv4Address);
            }
        }

    return SendContext;
}

RPC_STATUS ParseD1_B2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *ConnectionTimeout,
    OUT HTTP2Cookie *AssociationGroupId,
    OUT ChannelSettingClientAddress *ClientAddress
    )
/*++

Routine Description:

    Parses a D1/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

    AssociationGroupId - the association group id

    ClientAddress - client address of the client as seen by the in proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        + FIELD_OFFSET(ChannelSettingClientAddress, u)      // check for enough space to read the
                                                            // address type
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 7)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_IN_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get receive window size
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    if (CurrentCommand->CommandType != tsctAssociationGroupId)
        goto AbortAndExit;
    AssociationGroupId->SetCookie((BYTE *)CurrentCommand->u.AssociationGroupId.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctAssociationGroupId);

    // get client address. Note that we have checked the length only up to
    // the address type. Everything after that must be validated separately
    if (CurrentCommand->CommandType != tsctClientAddress)
        goto AbortAndExit;
    ClientAddress->AddressType = CurrentCommand->u.ClientAddress.AddressType;

    // We have already calculated the size of the AddressType field. Add the
    // size for the body of the client address
    MemorySize += 
        ClientAddressSizes[ClientAddress->AddressType] 
        - FIELD_OFFSET(ChannelSettingClientAddress, u);
    if (PacketLength < MemorySize)
        goto AbortAndExit;

    if (ClientAddress->AddressType == catIPv4)
        {
        RpcpCopyIPv4Address((SOCKADDR_IN *)CurrentCommand->u.ClientAddress.u.IPv4Address,
            (SOCKADDR_IN *)ClientAddress->u.IPv4Address);
        }
    else
        {
        RpcpCopyIPv6Address((SOCKADDR_IN6 *)CurrentCommand->u.ClientAddress.u.IPv4Address,
            (SOCKADDR_IN6 *)ClientAddress->u.IPv4Address);
        }

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS GetFirstServerPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2FirstServerPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of the first server packet.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    if (RTS->Flags & RTS_FLAG_OUT_CHANNEL)
        {
        if (RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL)
            *PacketType = http2fsptD4_A4;
        else
            *PacketType = http2fsptD1_A2;
        return RPC_S_OK;
        }
    else if (RTS->Flags & RTS_FLAG_IN_CHANNEL)
        {
        if (RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL)
            *PacketType = http2fsptD2_A2;
        else
            *PacketType = http2fsptD1_B2;
        return RPC_S_OK;
        }
    else
        return RPC_S_PROTOCOL_ERROR;
}

RPC_STATUS GetClientOpenedPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2ClientOpenedPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of the packet in client opened (or one of
    the opened states)

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    // here we expect D2/A4, D3/A4, D4/A2, D4/A6, D5/A6
    // and D5/B3
    if (RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL)
        {
        *PacketType = http2coptD4_A2;
        }
    else if (RTS->Flags & RTS_FLAG_OUT_CHANNEL)
        {
        *PacketType = http2coptD4_A6;
        }
    else if (RTS->Flags & RTS_FLAG_EOF)
        {
        // D5/B3 has the EOF flag
        *PacketType = http2coptD5_B3;
        }
    else if (IsD4_A10(Packet, PacketLength))
        {
        // D4/A10 is an ANCE packet.
        *PacketType = http2coptD4_A10;
        }
    else if (IsD5_A6(Packet, PacketLength, fdClient))
        {
        // D5/A6 is an ANCE packet with forward destination.
        *PacketType = http2coptD5_A6;
        }
    else if (IsD2_A4OrD3_A4(Packet, PacketLength))
        {
        *PacketType = http2coptD2_A4;
        }
    else
        {
        *PacketType = http2coptD3_A4;
        }

    return RPC_S_OK;
}

RPC_STATUS GetServerOpenedPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2ServerOpenedPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of the packet in server opened (or one of
    the opened states)

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    // here we expect D2/A6, D2/B1, D3/A2, D4/A8 and D5/A8
    if (RTS->Flags & RTS_FLAG_OUT_CHANNEL)
        {
        // D4/A8 and D5/A8 are differentiated by state only
        *PacketType = http2soptD4_A8orD5_A8;
        }
    else if (IsEmptyRTS (Packet, PacketLength))
        {
        *PacketType = http2soptD2_B1;
        }
    else
        {
        *PacketType = http2soptD2_A6orD3_A2;
        }

    return RPC_S_OK;
}

RPC_STATUS GetOtherCmdPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2OtherCmdPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of a packet containing other cmd flag

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    // right now we only expect KeepAliveChange
    *PacketType = http2ocptKeepAliveChange;

    return RPC_S_OK;
}

RPC_STATUS GetServerOutChannelOtherCmdPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2ServerOutChannelOtherCmdPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of a packet containing other cmd flag

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;

    // tsctPingTrafficSentNotify is shorter than tsctFlowControlAck
    // This is how we differentiate them
    ASSERT(SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck) 
        > SIZE_OF_RTS_CMD_AND_PADDING(tsctPingTrafficSentNotify));

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        ;

    if (PacketLength < MemorySize)
        *PacketType = http2sococptPingTrafficSentNotify;
    else
        *PacketType = http2sococptFlowControl;

    return RPC_S_OK;
}

const char *ResponseHeaderFragment1 = "HTTP/1.1 200 Success\r\nContent-Type:application/rpc\r\nContent-Length:";
const int ResponseHeaderFragment1Length = 67;    // length of "HTTP/1.1 200 Success\r\nContent-Type:application/rpc\r\nContent-Length:"
const char *ResponseHeaderFragment2 = "\r\n\r\n";
const int ResponseHeaderFragment2Length = 4;     // length of "\r\n\r\n"

HTTP2SendContext *AllocateAndInitializeResponseHeader (
    void
    )
/*++

Routine Description:

    Allocates and initializes the out channel response header.

Arguments:

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    ULONG MemorySize;
    char *Buffer;
    char *OriginalBuffer;
    HTTP2SendContext *SendContext;

    MemorySize = ResponseHeaderFragment1Length
        + DefaultChannelLifetimeStringLength
        + ResponseHeaderFragment2Length
        ;

    Buffer = (char *)RpcAllocateBuffer(HTTPSendContextSizeAndPadding + MemorySize);
    if (Buffer == NULL)
        return NULL;

    OriginalBuffer = Buffer;

    SendContext = (HTTP2SendContext *)Buffer;
    Buffer += HTTPSendContextSizeAndPadding;

#if DBG
    SendContext->ListEntryUsed = FALSE;
#endif
    SendContext->maxWriteBuffer = MemorySize;
    SendContext->pWriteBuffer = (BUFFER)Buffer;
    SendContext->TrafficType = http2ttRaw;
    SendContext->u.SyncEvent = NULL;
    SendContext->Flags = 0;
    SendContext->UserData = 0;

    RpcpMemoryCopy(Buffer, ResponseHeaderFragment1, ResponseHeaderFragment1Length);
    Buffer += ResponseHeaderFragment1Length;

    RpcpMemoryCopy(Buffer, DefaultChannelLifetimeString, DefaultChannelLifetimeStringLength);
    Buffer += DefaultChannelLifetimeStringLength;

    RpcpMemoryCopy(Buffer, ResponseHeaderFragment2, ResponseHeaderFragment2Length);

    return (HTTP2SendContext *)OriginalBuffer;
}

HTTP2SendContext *AllocateAndInitializeD1_A3 (
    IN ULONG ProxyConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes an D1_A3 packet.

Arguments:

    ProxyConnectionTimeout - the proxy connection timeout.

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ProxyConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_A3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D1/A3 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProxyConnectionTimeout - the proxy connection timeout is returned
        here (success only).

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ProxyConnectionTimeout = CurrentCommand->u.ConnectionTimeout;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_B3 (
    IN ULONG ReceiveWindowSize,
    IN ULONG UpdatedProtocolVersion
    )
/*++

Routine Description:

    Allocates and initializes an D1_B3 packet.

Arguments:

    ReceiveWindowSize - the server receive window size.

    UpdatedProtocolVersion - the updated protocol version.

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->NumberOfSettingCommands = 2;

        CurrentCommand = RTS->Cmd;

        // set receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ConnectionTimeout = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = UpdatedProtocolVersion;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_B3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *UpdatedProtocolVersion
    )
/*++

Routine Description:

    Parses and frees a D1/A3 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ReceiveWindowSize - the receive window size is returned
        here (success only).

    UpdatedProtocolVersion - the updated protocol version from the
        server (success only)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *UpdatedProtocolVersion = CurrentCommand->u.Version;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_C1 (
    IN ULONG UpdatedProtocolVersion,
    IN ULONG InProxyReceiveWindowSize,
    IN ULONG InProxyConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D1_C1 packet.

Arguments:

    UpdatedProtocolVersion - the updated protocol version.

    InProxyReceiveWindowSize - the in proxy receive window size.

    InProxyConnectionTimeout - the in proxy connection timeout

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->NumberOfSettingCommands = 3;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = UpdatedProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = InProxyReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = InProxyConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseD1_C1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *UpdatedProtocolVersion,
    OUT ULONG *InProxyReceiveWindowSize,
    OUT ULONG *InProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses a D1_C1 packet.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    UpdatedProtocolVersion - the updated protocol version.

    InProxyReceiveWindowSize - the in proxy receive window size.

    InProxyConnectionTimeout - the in proxy connection timeout

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 3)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *UpdatedProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *InProxyReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *InProxyConnectionTimeout = CurrentCommand->u.ConnectionTimeout;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD1_C2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *UpdatedProtocolVersion,
    OUT ULONG *InProxyReceiveWindowSize,
    OUT ULONG *InProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D1_C2 packet.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    UpdatedProtocolVersion - the updated protocol version.

    InProxyReceiveWindowSize - the in proxy receive window size.

    InProxyConnectionTimeout - the in proxy connection timeout

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    // D1/C1 has the same format as D1/C2
    RpcStatus = ParseD1_C1(Packet,
        PacketLength,
        UpdatedProtocolVersion,
        InProxyReceiveWindowSize,
        InProxyConnectionTimeout
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A1 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Allocates and initializes a D2/A1 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_RECYCLE_CHANNEL;
        RTS->NumberOfSettingCommands = 4;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}


RPC_STATUS ParseAndFreeD2_A1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses and frees a D2/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - on output, the version of the HTTP tunnelling protocol
        Success only.

    ConnectionCookie - on output, the connection cookie. Success only.

    OldChannelCookie - on output, the old channel cookie. Success only.

    NewChannelCookie - on output, the new channel cookie. Success only.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 4)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_RECYCLE_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A2 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie,
    IN ULONG ReceiveWindowSize,
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D2/A2 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_IN_CHANNEL | RTS_FLAG_RECYCLE_CHANNEL;
        RTS->NumberOfSettingCommands = 6;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set receive window size
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        }

    return SendContext;
}


RPC_STATUS ParseD2_A2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Parses a D1/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 6)
        goto AbortAndExit;

    if (RTS->Flags != (RTS_FLAG_IN_CHANNEL | RTS_FLAG_RECYCLE_CHANNEL))
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get receive window size
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A3 (
    IN ForwardDestinations Destination,
    IN ULONG ProtocolVersion,
    IN ULONG ReceiveWindowSize,
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D2/A3 RTS packet

Arguments:

    Destination - where to forward this to.

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 4;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set receive window size
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseD2_A3orD2_A4 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *ProtocolVersion,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Parses a D2/A3 or D2/A4 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 4)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get receive window size
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

BOOL IsD2_A3Packet (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion
    )
/*++

Routine Description:

    Determines if a packet is a D2/A3 packet and if so, retrieves
    the ProtocolVersion contained in the packet.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - if this function returns TRUE, the version of the 
        HTTP tunnelling protocol. Undefined otherwise.

Return Value:

    Non-zero if this is a D2_A3 packet. Zero if it is not or it cannot be parsed.

--*/
{
    RPC_STATUS RpcStatus;
    ULONG ReceiveWindowSize;
    ULONG ConnectionTimeout;

    // we ignore the results for ReceiveWindowSize and
    // ConnectionTimeout
    RpcStatus = ParseD2_A3orD2_A4 (Packet,
        PacketLength,
        fdClient,
        ProtocolVersion,
        &ReceiveWindowSize,
        &ConnectionTimeout
        );

    return (RpcStatus == RPC_S_OK);
}

RPC_STATUS ParseAndFreeD2_A4 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *ProtocolVersion,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D2/A4 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseD2_A3orD2_A4 (Packet,
        PacketLength,
        ExpectedDestination,
        ProtocolVersion,
        ReceiveWindowSize,
        ConnectionTimeout
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A5 (
    IN HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Allocates and initializes a D2/A5 RTS packet

Arguments:

    NewChannelCookie - the new channel cookie

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

RPC_STATUS ParseD2_A5 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses a D2/A5 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    NewChannelCookie - the new channel cookie

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD2_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses and frees a D2/A6 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    NewChannelCookie - the new channel cookie

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    // D2/A6 is the same as D2/A5
    RpcStatus = ParseD2_A5(Packet,
        PacketLength,
        NewChannelCookie);

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_B2 (
    IN ULONG ServerReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D2/B2 RTS packet

Arguments:

    ServerReceiveWindow - the server receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set server receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ServerReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD2_B2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ServerReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D2/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ServerReceiveWindow - the server receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get server receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ServerReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A3 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie,
    IN ULONG ClientReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D4/A3 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_RECYCLE_CHANNEL;
        RTS->NumberOfSettingCommands = 5;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set client receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ClientReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD4_A2 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a D4/A2 packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_RECYCLE_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (fdClient != CurrentCommand->u.Destination)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

ULONG GetD4_A3TotalLength (
    void
    )
/*++

Routine Description:

    Calculates the length of a D1/A1 RTS packet

Arguments:

Return Value:

    The length of the D1/A1 RTS packet.

--*/
{
    return (BaseRTSSizeAndPadding
        + BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );
}

ULONG GetD4_A11TotalLength (
    void
    )
/*++

Routine Description:

    Calculates the length of a D4/A11 RTS packet

Arguments:

Return Value:

    The length of the D4/A11 RTS packet.

--*/
{
    return (BaseRTSSizeAndPadding
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );
}

RPC_STATUS ParseD4_A3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ClientReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 5)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_RECYCLE_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get client receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ClientReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD4_A3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ClientReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseD4_A3 (Packet,
        PacketLength,
        ProtocolVersion,
        ConnectionCookie,
        OldChannelCookie,
        NewChannelCookie,
        ClientReceiveWindow
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A4 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie,
    IN ULONG ChannelLifetime,
    IN ULONG ProxyReceiveWindow,
    IN ULONG ProxyConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D4/A4 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

    ProxyConnectionTimeout - the proxy connection timeout

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_RECYCLE_CHANNEL | RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 7;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel lifetime
        CurrentCommand->CommandType = tsctChannelLifetime;
        CurrentCommand->u.ChannelLifetime = ChannelLifetime;
        CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

        // set proxy receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ProxyReceiveWindow;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set proxy connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ProxyConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseD4_A4 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ChannelLifetime,
    OUT ULONG *ProxyReceiveWindow,
    OUT ULONG *ProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

    ProxyConnectionTimeout - the proxy connection timeout

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 7)
        goto AbortAndExit;

    if (RTS->Flags != (RTS_FLAG_RECYCLE_CHANNEL | RTS_FLAG_OUT_CHANNEL))
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel lifetime
    if (CurrentCommand->CommandType != tsctChannelLifetime)
        goto AbortAndExit;
    *ChannelLifetime = CurrentCommand->u.ChannelLifetime;
    CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

    // get proxy receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ProxyReceiveWindow = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get proxy connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ProxyConnectionTimeout = CurrentCommand->u.ConnectionTimeout;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A5 (
    IN ForwardDestinations Destination,
    IN ULONG ProtocolVersion,
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D4/A5 RTS packet

Arguments:

    Destination - where to forward this to.

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionTimeout - connection timeout of the out proxy

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 3;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD4_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *ProtocolVersion,
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D4/A6 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionTimeout - connection timeout of the out proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 3)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OUT_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A7 (
    IN ForwardDestinations Destination,
    IN HTTP2Cookie *NewChannelCookie,
    IN ULONG ProtocolVersion
    )
/*++

Routine Description:

    Allocates and initializes a D4/A7 RTS packet

Arguments:

    Destination - the destination for the packet.

    NewChannelCookie - the new channel cookie

    ProtocolVersion - the new version negotiated with the
        new out proxy.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 3;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new verison
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD4_A8 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses a D2/A5 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the id of the current hop that
        is being processed.

    NewChannelCookie - the new channel cookie

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OUT_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

BOOL IsNewD4_A7Packet (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *ProtocolVersion
    )
/*++

Routine Description:

    Intermediate versions of .NET Server 2003 and 
    all versions of Windows XPSP1 send D4/A7 without
    version information (old D4/A7). This routine 
    detects if the passed in packet is the new style
    D4/A7 and if yes, retrieves the new protocol version.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the id of the destination we
        expect to find in the packet.

    ProtocolVersion - if the function returns non-zero, this is
        the protocol version indicated by D4/A7. If the function
        returns FALSE, the contents of this parameter is undefined.

Return Value:

    non-zero if this is a new-style D4/A7 packet. Zero if it
        is not (including all cases of parsing failure)

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        ;

    if (PacketLength < MemorySize)
        return FALSE;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        return FALSE;

    if (RTS->NumberOfSettingCommands != 3)
        return FALSE;

    if (RTS->Flags != RTS_FLAG_OUT_CHANNEL)
        return FALSE;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // check for destination
    if (CurrentCommand->CommandType != tsctDestination)
        return FALSE;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        return FALSE;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // check for channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        return FALSE;
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // check for version
    if (CurrentCommand->CommandType != tsctVersion)
        return FALSE;
    *ProtocolVersion = CurrentCommand->u.Version;

    return TRUE;
}

void ConvertNewD4_A7ToD4_A8 (
    IN OUT BYTE *Packet,
    IN OUT ULONG *PacketLength
    )
/*++

Routine Description:

    Takes a parsed a valid new style D4/A7 and converts
    it in-place to D4/A8 packet.

Arguments:

    Packet - on input, the D4/A7 packet. On output, a 
        D4/A8 packet.

    PacketLength - on input, the length of the D4/A7 packet.
        On output, the length of the D4/A8 packet.

Return Value:

--*/
{
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;

#if DBG
    ULONG MemorySize;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        ;

    ASSERT (*PacketLength == MemorySize);
#endif  // DBG

    // remove the version information from the length
    *PacketLength -= BaseRTSCommandSize + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion);

    // adjust the fragment length in the RPC header.
    RTS->common.frag_length -= BaseRTSCommandSize + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion);

    // truncate the version information at the end
    RTS->NumberOfSettingCommands = 2;
}

HTTP2SendContext *AllocateAndInitializeD4_A9 (
    void
    )
/*++

Routine Description:

    Allocates and initializes a D4/A9 RTS packet

Arguments:

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ANCE command
        CurrentCommand->CommandType = tsctANCE;
        }

    return SendContext;
}

RPC_STATUS ParseD4_A9 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses a D4/A10 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify ANCE
    if (CurrentCommand->CommandType != tsctANCE)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD4_A9 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a D4/A10 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseD4_A10(Packet,
        PacketLength
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD5_A5 (
    IN ForwardDestinations Destination
    )
/*++

Routine Description:

    Allocates and initializes a D4/A9 RTS packet

Arguments:

    Destination - destination for forwarding

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)        
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 2;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set empty command
        CurrentCommand->CommandType = tsctANCE;
        }

    return SendContext;
}

RPC_STATUS ParseD5_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses a D5/A6 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for the target location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)        
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // verify ANCE
    if (CurrentCommand->CommandType != tsctANCE)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD5_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses and frees a D5/A5 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseD5_A6(Packet,
        PacketLength,
        ExpectedDestination
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD5_B1orB2 (
    IN BOOL IsAckOrNak
    )
/*++

Routine Description:

    Allocates and initializes a D5/B1 or D5/B2 RTS packet

Arguments:

    IsAckOrNack - non-zero if this is an ACK and D5/B1 needs
        to go out. If 0, this is a NACK and D5/B2 will go out.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    ASSERT(SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE) == SIZE_OF_RTS_CMD_AND_PADDING(tsctNANCE));

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ANCE or NANCE command
        if (IsAckOrNak)
            CurrentCommand->CommandType = tsctANCE;
        else
            CurrentCommand->CommandType = tsctNANCE;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD5_B1orB2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT BOOL *IsAckOrNak
    )
/*++

Routine Description:

    Parses and frees a D5/B1 or D2/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    IsAckOrNak - if success, on output it will contain
        non-zero if the packet was ACK (ANCE or D5/B1)
        or zero if the packet was NACK (NANCE or D5/B2)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify ANCE
    if (CurrentCommand->CommandType == tsctANCE)
        *IsAckOrNak = TRUE;
    else if (CurrentCommand->CommandType == tsctNANCE)
        *IsAckOrNak = FALSE;
    else
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD5_B3 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a D5/B3 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_EOF)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify ANCE
    if (CurrentCommand->CommandType != tsctANCE)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeKeepAliveChangePacket (
    IN ULONG NewKeepAliveInterval
    )
/*++

Routine Description:

    Allocates and initializes a keep alive change packet.

Arguments:

    NewKeepAliveInterval - the new keep alive interval in
        milliseconds

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctClientKeepalive;
        CurrentCommand->u.ClientKeepalive = NewKeepAliveInterval;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeKeepAliveChangePacket (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *NewKeepAliveInterval
    )
/*++

Routine Description:

    Parses and frees a keep alive change packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    NewKeepAliveInterval - the new keep alive interval

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get new client keep alive
    if (CurrentCommand->CommandType != tsctClientKeepalive)
        goto AbortAndExit;
    *NewKeepAliveInterval = CurrentCommand->u.ClientKeepalive;

    if ((*NewKeepAliveInterval < MinimumClientNewKeepAliveInterval)
        && (*NewKeepAliveInterval != 0))
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeFlowControlAckPacket (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck,
    IN HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Allocates and initializes a flow control ack packet

Arguments:

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we ack to.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ack command
        CurrentCommand->CommandType = tsctFlowControlAck;
        CurrentCommand->u.Ack.BytesReceived = BytesReceivedForAck;
        CurrentCommand->u.Ack.AvailableWindow = WindowForAck;
        RpcpMemoryCopy(CurrentCommand->u.Ack.ChannelCookie.Cookie, CookieForChannel->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

HTTP2SendContext *AllocateAndInitializeFlowControlAckPacketWithDestination (
    IN ForwardDestinations Destination,
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck,
    IN HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Allocates and initializes a flow control ack packet with a forward
        destination

Arguments:

    Destination - the destination to which to forward the packet

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we ack to.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)        
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 2;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set ack command
        CurrentCommand->CommandType = tsctFlowControlAck;
        CurrentCommand->u.Ack.BytesReceived = BytesReceivedForAck;
        CurrentCommand->u.Ack.AvailableWindow = WindowForAck;
        RpcpMemoryCopy(CurrentCommand->u.Ack.ChannelCookie.Cookie, CookieForChannel->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeFlowControlAckPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck,
    OUT HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Parses and frees a flow control ack packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we received ack for.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get ack values
    if (CurrentCommand->CommandType != tsctFlowControlAck)
        goto AbortAndExit;

    *BytesReceivedForAck = CurrentCommand->u.Ack.BytesReceived;
    *WindowForAck = CurrentCommand->u.Ack.AvailableWindow;
    CookieForChannel->SetCookie((BYTE *)CurrentCommand->u.Ack.ChannelCookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;    
}

RPC_STATUS ParseAndFreeFlowControlAckPacketWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck,
    OUT HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Parses and frees a flow control ack packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    Destination - the expected destination

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we received ack for.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseFlowControlAckPacketWithDestination (
        Packet,
        PacketLength,
        ExpectedDestination,
        BytesReceivedForAck,
        WindowForAck,
        CookieForChannel
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

RPC_STATUS ParseFlowControlAckPacketWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck,
    OUT HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Parses a flow control ack packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    Destination - the expected destination

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we received ack for.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // get ack values
    if (CurrentCommand->CommandType != tsctFlowControlAck)
        goto AbortAndExit;
    *BytesReceivedForAck = CurrentCommand->u.Ack.BytesReceived;
    *WindowForAck = CurrentCommand->u.Ack.AvailableWindow;
    CookieForChannel->SetCookie((BYTE *)CurrentCommand->u.Ack.ChannelCookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;    
}

HTTP2SendContext *AllocateAndInitializePingTrafficSentNotifyPacket (
    IN ULONG PingTrafficSentBytes
    )
/*++

Routine Description:

    Allocates and initializes a ping traffic sent packet

Arguments:

    PingTrafficSentBytes - the number of bytes sent in ping traffic

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctPingTrafficSentNotify)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ping traffic sent
        CurrentCommand->CommandType = tsctPingTrafficSentNotify;
        CurrentCommand->u.PingTrafficSent = PingTrafficSentBytes;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreePingTrafficSentNotifyPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *PingTrafficSentBytes
    )
/*++

Routine Description:

    Parses a ping traffic sent packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PingTrafficSentBytes - the number of bytes sent in ping traffic

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctPingTrafficSentNotify)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get ping traffic sent values
    if (CurrentCommand->CommandType != tsctPingTrafficSentNotify)
        goto AbortAndExit;
    *PingTrafficSentBytes = CurrentCommand->u.PingTrafficSent;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\mqtrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    mqtrans.cxx

Abstract:

    Support for MSMQ (Falcon) datagram transport. Based on MarioGo's
    DG transport code (dgtrans.cxx).

Author:

    Edward Reus (edwardr)    04-Jul-1997

Revision History:

--*/
#include <precomp.hxx>
#include <trans.hxx>
#include <dgtrans.hxx>
#include <wswrap.hxx>
#include "mqtrans.hxx"


////////////////////////////////////////////////////////////////////////
//
// MSMQ datagram routines.
//

//----------------------------------------------------------------
RPC_STATUS
MQ_SubmitReceive( IN MQ_DATAGRAM_ENDPOINT *pEndpoint,
                  IN MQ_DATAGRAM          *pDatagram )
/*++

Arguments:

    pEndpoint - The endpoint on which the receive should be posted.
    pDatagram - The datagram object to manage the receive.

Return Value:

    RPC_P_IO_PENDING - OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/

{
    RPC_STATUS status;
    BOOL       fRetry = TRUE;
    DWORD      dwBytes = 0;
    DWORD      dwStatus;
    HRESULT    hr;


    while (fRetry)
       {
       if (pDatagram->pPacket == 0)
           {
           pDatagram->dwPacketSize = dwBytes;
           status = I_RpcTransDatagramAllocate2( pEndpoint,
                                                 (BUFFER *)&pDatagram->pPacket,
                                                 (PUINT)   &pDatagram->dwPacketSize,
                                                 (PVOID *) &pDatagram->pAddress);

           if (status != RPC_S_OK)
               {
               return RPC_S_OUT_OF_MEMORY;
               }

           ASSERT( pDatagram->pPacket );

           memset(pDatagram->pAddress,0,sizeof(MQ_ADDRESS));
           }

       pDatagram->cRecvAddr = sizeof(MQ_ADDRESS);

       ASSERT(*(PDWORD)pDatagram->pPacket = 0xDEADF00D);

       hr = AsyncReadQueue( pEndpoint,
                            &pDatagram->Read,
                            pDatagram->pAddress,
                            pDatagram->pPacket,
                            pDatagram->dwPacketSize );

       if (!FAILED(hr))
           {
           return RPC_P_IO_PENDING;
           }

       if (hr == MQ_ERROR_BUFFER_OVERFLOW)
          {
          // This can happen if there is already a large sized call on the queue.
          dwBytes = pDatagram->Read.aMsgPropVar[1].ulVal;

          dwStatus = I_RpcTransDatagramFree( pEndpoint,
                                             (BUFFER)pDatagram->pPacket,
                                             (PVOID) pDatagram->pAddress);
          pDatagram->pPacket = 0;
          pDatagram->dwPacketSize = 0;
          if (dwStatus != RPC_S_OK)
              {
              TransDbgPrint((DPFLTR_RPCPROXY_ID,
                             DPFLTR_WARNING_LEVEL,
                             RPCTRANS "MQ_SubmitReceive(): I_RpcTransDatagram() failed: %d\n",
                             dwStatus));

              return RPC_S_OUT_OF_MEMORY;
              }
          }
       else
          {
          fRetry = FALSE;
          TransDbgPrint((DPFLTR_RPCPROXY_ID,
                         DPFLTR_WARNING_LEVEL,
                         RPCTRANS "MQ_SubmitReceive(): AsyncReadQueue() failed: 0x%x\n",
                         hr));
          }
       }

    return RPC_S_OUT_OF_RESOURCES;
}

//----------------------------------------------------------------
void
MQ_SubmitReceives(
    BASE_ADDRESS *ThisEndpoint
    )
/*++

Routine Description:

    Helper function called when the pending IO count
    on an address is too low.

Arguments:

    ThisEndpoint - The address to submit IOs on.

Return Value:

    None

--*/
{
    PMQ_DATAGRAM pDg;
    PMQ_DATAGRAM_ENDPOINT pEndpoint = (PMQ_DATAGRAM_ENDPOINT)ThisEndpoint;

    if ( (!pEndpoint->fAllowReceives) || (!pEndpoint->hQueue) )
        {
        return;
        }

    do
        {
        BOOL fIoSubmitted;

        fIoSubmitted = FALSE;

        // Only one thread should be trying to submit IOs at a time.
        // This saves locking each DATAGRAM object.

        // Simple lock - but requires a loop. See the comment at the end
        // of the loop.

        if (pEndpoint->fSubmittingIos != 0)
            break;

        if (InterlockedIncrement(&pEndpoint->fSubmittingIos) != 1)
            break;

        // Submit new IOs on all the idle datagram objects

        for (int i = 0; i < pEndpoint->cMaximumIos; i++)
            {
            pDg = &pEndpoint->aDatagrams[i];

            if (pDg->Busy)
                {
                continue;
                }

            // Must be all set for the IO to complete before trying
            // to submit the IO.
            InterlockedIncrement(&pEndpoint->cPendingIos);
            pDg->Busy = TRUE;

            if (MQ_SubmitReceive(pEndpoint, pDg) == RPC_P_IO_PENDING)
                {
                fIoSubmitted = TRUE;
                }
            else
                {
                pDg->Busy = FALSE;
                InterlockedDecrement(&pEndpoint->cPendingIos);
                break;
                }
            }

        // Release the "lock" on the endpoint object.
        //
        // Xeon processors have eratta G40:
        // Potential Loss of Data Coherency Duaring MP Data Ownership Transfer.
        // To work around it, it is necessary to use InterlockedExchange rather then an assignment
        // to force cache coherency.
        InterlockedExchange(&pEndpoint->fSubmittingIos, 0);

        if (!fIoSubmitted && pEndpoint->cPendingIos == 0)
            {
            // It appears that no IO is pending on the endpoint.
            COMMON_AddressManager(pEndpoint);
            return;
            }

        // Even if we submitted new IOs, they may all have completed
        // already.  Which means we may need to loop and submit more
        // IOs.  This is needed since the thread which completed the
        // last IO may have run into our lock and returned.
        }
    while (pEndpoint->cPendingIos == 0);

    return;
}



BOOL RPC_ENTRY MQ_AllowReceives(
                         IN DG_TRANSPORT_ENDPOINT pvTransEndpoint,
                         IN BOOL                  fAllowReceives,
                         IN BOOL                  fCancelPendingIos )
{
    BOOL        fPrevAllowReceives;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)pvTransEndpoint;

    fPrevAllowReceives = pEndpoint->fAllowReceives;
    pEndpoint->fAllowReceives = fAllowReceives;

    if (!pEndpoint->cPendingIos)
       {
       MQ_SubmitReceives(pEndpoint);
       }

    ASSERT( !fCancelPendingIos );   // Not implemented yet.

    return fPrevAllowReceives;
}



RPC_STATUS RPC_ENTRY
MQ_SendPacket(
    IN DG_TRANSPORT_ENDPOINT        ThisEndpoint,
    IN DG_TRANSPORT_ADDRESS         pvAddress,
    IN BUFFER                       pHeader,
    IN unsigned                     cHeader,
    IN BUFFER                       pBody,
    IN unsigned                     cBody,
    IN BUFFER                       pTrailer,
    IN unsigned                     cTrailer
    )
/*++

Routine Description:

    Sends a packet to an address.

    The routine will send a packet built out of the three buffers supplied.
    All the buffers are optional, the actual packet sent will be built from
    all the buffers actually supplied.  In each call at least buffer should
    NOT be null.

Arguments:

    ThisEndpoint  - Endpoint to send from.
    pAddress      - Address to send to.

    pHeader       - First data buffer
    cHeader       - Size of the first data buffer or 0.

    pBody         - Second data buffer
    cBody         - Size of the second data buffer or 0.

    pTrailer      - Third data buffer.
    cTrailer      - Size of the third data buffer or 0.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY
    RPC_P_SEND_FAILED

--*/
{
    RPC_STATUS            Status;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;
    MQ_ADDRESS           *pAddress = (MQ_ADDRESS*)pvAddress;
    UCHAR                *pBuffer;
    UCHAR                *pTemp;
    DWORD                 dwBytes = cHeader + cBody + cTrailer;
    HRESULT               hr;
    BOOL                  fNeedToFree = FALSE;


    ASSERT(dwBytes);

    //
    // Buffer assembly. I get the data PDU as up to three separate pieces,
    // so it needs to be assembled before being sent. For Falcon (which can't
    // do scatter/gather) this is expensive (allocate() + memcpy()'s). We try
    // to be cheap and avoid the allocation, or do an _alloca() off the stack
    // instead of the heap.
    //
    if ( (cHeader==0) && (cBody > 0) && (cTrailer == 0) )
        {
        pBuffer = pBody;
        }
    else if (  ((cBody == 0) && (cTrailer == 0))
            || ((pHeader+cHeader == pBody) && (pTrailer == 0)) )
        {
        pBuffer = pHeader;
        }
    else
        {
        pBuffer = (UCHAR*)I_RpcAllocate(dwBytes);
        fNeedToFree = TRUE;

        if (!pBuffer)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pTemp = pBuffer;
        if (cHeader)
            {
            memcpy(pTemp,pHeader,cHeader);
            pTemp += cHeader;
            }

        if (cBody)
            {
            memcpy(pTemp,pBody,cBody);
            pTemp += cBody;
            }

        if (cTrailer)
            {
            memcpy(pTemp,pTrailer,cTrailer);
            }

        ASSERT(pTemp != pBuffer);
        }

    #ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "MQ_SendPacket():\n"));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    To: %S: %S\n",
                   pAddress->wsMachine,
                   pAddress->wsQName));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    Size: %d\n",
                   dwBytes));

    DG_DbgPrintPacket(pBuffer);
    #endif

    hr = MQ_SendToQueue( pEndpoint, pAddress, pBuffer, dwBytes );
    Status = MQ_MapStatusCode(hr,RPC_P_SEND_FAILED);

    if (Status != RPC_S_OK)
       {
       if (fNeedToFree)
          {
          I_RpcFree(pBuffer);
          }

       return Status;
       }

    if ( (pEndpoint->cMinimumIos)
         && (pEndpoint->cPendingIos <= pEndpoint->cMaximumIos) )
        {
        MQ_SubmitReceives(pEndpoint);
        }

    if (fNeedToFree)
       {
       I_RpcFree(pBuffer);
       }

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
MQ_ForwardPacket(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BUFFER                pHeader,
    IN unsigned              cHeader,
    IN BUFFER                pBody,
    IN unsigned              cBody,
    IN BUFFER                pTrailer,
    IN unsigned              cTrailer,
    IN CHAR *                pszPort
    )

/*++

Routine Description:

    Sends a packet to the server it was originally destined for (that
    is, the client had a dynamic endpoint it wished the enpoint mapper
    to resolve and forward the packet to).

Arguments:

    ThisEndpoint      - The endpoint to forward the packet from.

    // Buffer like DG_SendPacket

    pszPort           - Pointer to the server port num to forward to.
                        This is in an Ansi string.

Return Value:

    RPC_S_CANT_CREATE_ENDPOINT - pEndpoint invalid.

    results of MQ_SendPacket().

--*/

{
    PMQ_DATAGRAM_ENDPOINT pEndpoint = (PMQ_DATAGRAM_ENDPOINT)ThisEndpoint;
    MQ_ADDRESS            Address;
    MQ_ADDRESS           *pAddress = &Address;
    RPC_CHAR              wsPort[MQ_MAX_Q_NAME_LEN];
    UNICODE_STRING        UnicodePort;
    ANSI_STRING           AsciiPort;
    DWORD                 Status;
    NTSTATUS              NtStatus;

    //
    // Convert pszPort to Unicode:
    //
    RtlInitAnsiString(&AsciiPort, pszPort);

    UnicodePort.Buffer = wsPort;
    UnicodePort.Length = 0;
    UnicodePort.MaximumLength = MQ_MAX_Q_NAME_LEN * sizeof(RPC_CHAR);

    NtStatus = RtlAnsiStringToUnicodeString(&UnicodePort,
                                            &AsciiPort,
                                            FALSE);

    if (!NT_SUCCESS(NtStatus))
        {
        return RPC_S_CANT_CREATE_ENDPOINT;
        }

    //
    // Try to connect to the server (to forward the packet to):
    //
    Status = ConnectToServerQueue(pAddress, NULL, wsPort );
    if (Status != RPC_S_OK)
        {
        return RPC_S_CANT_CREATE_ENDPOINT;
        }


    //
    // Forward the packet on:
    //
    Status = MQ_SendPacket(ThisEndpoint,
                           pAddress,
                           pHeader,
                           cHeader,
                           pBody,
                           cBody,
                           pTrailer,
                           cTrailer );

    //
    // Release the connection, we shouldn't need it any more:
    //
    DisconnectFromServer(pAddress);

    return Status;
}


RPC_STATUS
RPC_ENTRY
MQ_ResizePacket(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_TRANSPORT_ADDRESS *pReplyAddress,
    OUT PUINT pBufferLength,
    OUT BUFFER *pBuffer
    )
{
    RPC_STATUS Status = RPC_P_TIMEOUT;
    DWORD      dwBytes = 0;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;
    MQ_DATAGRAM          *pDatagram = &pEndpoint->aDatagrams[0];


    dwBytes = pDatagram->Read.aMsgPropVar[1].ulVal;

    ASSERT(dwBytes);

    #ifdef DBG
    DbgPrint("MQ_ResizePacket(): dwBytes: %d\n",dwBytes);
    #endif

    if ( (pDatagram->pPacket) && (pDatagram->dwPacketSize < dwBytes) )
        {
        Status = I_RpcTransDatagramFree( pEndpoint,
                                         (BUFFER)pDatagram->pPacket,
                                         (PVOID) pDatagram->pAddress);
        pDatagram->pPacket = 0;
        pDatagram->dwPacketSize = 0;
        if (Status != RPC_S_OK)
            {
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    if (!pDatagram->pPacket)
        {
        pDatagram->dwPacketSize = dwBytes;
        Status = I_RpcTransDatagramAllocate2( pEndpoint,
                                              (BUFFER *)&pDatagram->pPacket,
                                              (PUINT)   &pDatagram->dwPacketSize,
                                              (PVOID *) &pDatagram->pAddress);
        if (Status != RPC_S_OK)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pDatagram->cRecvAddr = sizeof(MQ_ADDRESS);

        ASSERT( pDatagram->pPacket );
        }

    #ifdef DBG
    DbgPrint("MQ_ResizePacket(): Ok\n");
    #endif

    return RPC_P_TIMEOUT;
}

RPC_STATUS
RPC_ENTRY
MQ_ReceivePacket(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_TRANSPORT_ADDRESS *pReplyAddress,
    OUT PUINT pBufferLength,
    OUT BUFFER *pBuffer,
    IN  LONG    Timeout
    )
/*++

Routine Description:

    Used to wait for a datagram from a server.  Returns the data
    returned and the address of the machine which replied.

    This is a blocking API. It should only be called during sync
    client RPC threads.

Arguments:

    Endpoint - The endpoint to receive from.
    ReplyAddress - Contain the source address of the datagram if
        successful.
    BufferLength - The size of Buffer on input, the size of the
        datagram received on output.
    Timeout - Milliseconds to wait for a datagram.

Return Value:

    RPC_S_OK

    RPC_P_OVERSIZE_PACKET - Datagram > BufferLength arrived,
        first BufferLength bytes of Buffer contain the partial datagram.

    RPC_P_RECEIVE_FAILED

    RPC_P_TIMEOUT

--*/
{
    RPC_STATUS Status = RPC_P_TIMEOUT;
    DWORD      dwBytes;
    BOOL       fRetry = TRUE;
    HRESULT    hr;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;
    MQ_DATAGRAM          *pDatagram = &pEndpoint->aDatagrams[0];

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->aDatagrams[0].Read.ol.hEvent);

#if TRUE
    while (fRetry)
       {
       fRetry = FALSE;

       if (pDatagram->Busy == 0)
          {
          Status = MQ_SubmitReceive(pEndpoint,pDatagram);
          if (Status != RPC_P_IO_PENDING)
             {
             return Status;
             }

          pDatagram->Busy = TRUE;
          }
       else
          {
          ASSERT(pDatagram->Busy);
          ASSERT(pDatagram->pPacket);

          Status = RPC_P_IO_PENDING;
          }


       if (Status == RPC_P_IO_PENDING)
          {
          Status = WaitForSingleObjectEx(pDatagram->Read.ol.hEvent,
                                         Timeout,
                                         TRUE);

          if (Status != STATUS_WAIT_0)
             {
             // In the timeout case we just want to return.
             if (Status == WAIT_IO_COMPLETION)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "MQ_ReceivePacket() cancelled.\n"));
                }
             else
                {
                ASSERT(Status == STATUS_TIMEOUT);
                }

             ASSERT(pDatagram->Busy);

             return RPC_P_TIMEOUT;
             }
          }


       MQ_FillInAddress(pDatagram->pAddress,pDatagram->Read.aMsgPropVar);
       }

    ASSERT((Status == RPC_S_OK)||(Status == RPC_P_OVERSIZE_PACKET));

    ASSERT(pDatagram->Busy);
    ASSERT(pDatagram->pPacket);
    // ASSERT(dwBytes <= pDatagram->dwPacketSize);

    *pBuffer = (BUFFER)pDatagram->pPacket;
    *pBufferLength = pDatagram->Read.aMsgPropVar[1].ulVal;
                     // dwBytes;
    *pReplyAddress = pDatagram->pAddress;

    pDatagram->pPacket = 0;
    pDatagram->dwPacketSize = 0;
    pDatagram->Busy = 0;

    return Status;

#else
    if (pDatagram->Busy == 0)
        {
        hr = PeekQueue( pEndpoint, Timeout, &dwBytes );

        Status = MQ_MapStatusCode(hr,RPC_P_RECEIVE_FAILED);

        if (Status != RPC_S_OK)
            {
            return Status;
            }

        if ( (pDatagram->pPacket) && (pDatagram->dwPacketSize < dwBytes) )
            {
            Status = I_RpcTransDatagramFree( pEndpoint,
                                             (BUFFER)pDatagram->pPacket,
                                             (PVOID) pDatagram->pAddress);
            pDatagram->pPacket = 0;
            pDatagram->dwPacketSize = 0;
            if (Status != RPC_S_OK)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            }

        if (!pDatagram->pPacket)
            {
            pDatagram->dwPacketSize = dwBytes;
            Status = I_RpcTransDatagramAllocate2( pEndpoint,
                                                  (BUFFER *)&pDatagram->pPacket,
                                                  (PUINT)   &pDatagram->dwPacketSize,
                                                  (PVOID *) &pDatagram->pAddress);
            if (Status != RPC_S_OK)
                {
                return RPC_S_OUT_OF_MEMORY;
                }

            pDatagram->cRecvAddr = sizeof(MQ_ADDRESS);

            ASSERT( pDatagram->pPacket );
            }

        pDatagram->Busy = TRUE;
        dwBytes = pDatagram->dwPacketSize;
        hr = ReadQueue( pEndpoint, Timeout, pDatagram->pAddress, pDatagram->pPacket, &dwBytes );
        Status = MQ_MapStatusCode(hr,RPC_P_RECEIVE_FAILED);
        if (FAILED(hr))
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "ReadQueue() failed: 0x%x\n",
                           hr));

            pDatagram->Busy = FALSE;
            return Status;
            }
        }

    #ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "MQ_ReceivePacket():\n"));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    Receive on: %S\n",
                   pEndpoint->wsQName));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    From: %S\n",
                   pDatagram->pAddress->wsQName));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    Size: %d\n",
                   dwBytes));

    DG_DbgPrintPacket(pDatagram->pPacket);
    #endif

    ASSERT((Status == RPC_S_OK)||(Status == RPC_P_OVERSIZE_PACKET));

    ASSERT(pDatagram->Busy);
    ASSERT(pDatagram->pPacket);
    ASSERT(dwBytes <= pDatagram->dwPacketSize);

    *pBuffer = (BUFFER)pDatagram->pPacket;
    *pBufferLength = dwBytes;
    *pReplyAddress = pDatagram->pAddress;

    pDatagram->pPacket = 0;
    pDatagram->dwPacketSize = 0;
    pDatagram->Busy = 0;

    return Status;
#endif
}


RPC_STATUS
MQ_CreateEndpoint(
    OUT MQ_DATAGRAM_ENDPOINT *pEndpoint,
    IN  MQ_ADDRESS           *pAddress,
    IN  void                 *pSecurityDescriptor,
    IN  DWORD                 dwEndpointFlags,
    IN  PROTOCOL_ID           id,
    IN  BOOL                  fClient,
    IN  BOOL                  fAsync
    )
/*++

Routine Description:

    Creates a new endpoint.

Arguments:

    pEndpoint - The runtime allocated endpoint structure to
        filled in.

    pSockAddr - An initialized sockaddr with the correct
        (or no) endpoint.

    id - The id of the protocol to use in creating the address.

    fClient - If TRUE this is a client endpoint

    fAsync  - If TRUE this endpoint is "async" which means that
        a) It should be added to the IO completion port and
        b) that the transport should pend a number of receives
        on the endpoint automatically.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    MQ_DATAGRAM *pDatagram;
    int        i;
    int        err;
    int        length;
    RPC_STATUS Status = RPC_S_OK;
    HRESULT    hr;
    UUID       uuid;
    DWORD      dwSize;
    RPC_CHAR     *pwsUuid;
    RPC_CHAR      wsQName[MQ_MAX_Q_NAME_LEN];
    RPC_CHAR      wsMachine[MAX_COMPUTERNAME_LEN];


    pEndpoint->type = DATAGRAM | ADDRESS;
    pEndpoint->id = id;
    pEndpoint->pAddressVector = 0;
    pEndpoint->SubmitListen = MQ_SubmitReceives;
    pEndpoint->InAddressList = NotInList;
    pEndpoint->pNext = 0;
    pEndpoint->fSubmittingIos = 0;
    pEndpoint->cPendingIos = 0;
    pEndpoint->cMinimumIos = 0;
    pEndpoint->cMaximumIos = 0;
    pEndpoint->aDatagrams  = 0;
    pEndpoint->pFirstAddress = pEndpoint;
    pEndpoint->pNextAddress = 0;

    pEndpoint->hQueue = 0;
    pEndpoint->hAdminQueue = 0;

    // If we're told not to listen, then we won't allow receives
    // until we are specifically told to do so...
    #ifdef RPC_C_MQ_DONT_LISTEN
    pEndpoint->fAllowReceives = !(dwEndpointFlags & RPC_C_MQ_DONT_LISTEN);
    #else
    pEndpoint->fAllowReceives = TRUE;
    #endif

    pEndpoint->fAck     = FALSE;
    pEndpoint->ulDelivery = RPC_C_MQ_EXPRESS;
    pEndpoint->ulPriority = DEFAULT_PRIORITY;
    pEndpoint->ulJournaling = RPC_C_MQ_JOURNAL_NONE;
    pEndpoint->ulTimeToReachQueue = INFINITE;
    pEndpoint->ulTimeToReceive = INFINITE;

    pEndpoint->fAuthenticate = FALSE;
    pEndpoint->fEncrypt = FALSE;
    pEndpoint->ulPrivacyLevel = 0;

    // Machine name:
    dwSize = sizeof(wsMachine);
    if (!GetComputerName((RPC_SCHAR *)wsMachine,&dwSize))
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    // Get the name of the machine that the QM (mqsvc.exe)
    // is running on:
    dwSize = sizeof(pEndpoint->wsMachine);
    hr = QueryQM(pEndpoint->wsMachine,&dwSize);
    if (FAILED(hr))
       {
       Status = MQ_MapStatusCode(hr,RPC_S_CANT_CREATE_ENDPOINT);
       return Status;
       }

    //
    // See if this is a call from an RPC server or RPC client:
    //
    if (fClient)
        {
        pEndpoint->type |= CLIENT;

        // Queue name (a unique string...):
        Status = UuidCreate(&uuid);
        if ((Status != RPC_S_OK) && (Status != RPC_S_UUID_LOCAL_ONLY))
            {
            return Status;
            }

        if (UuidToString(&uuid,&pwsUuid) != RPC_S_OK)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpStringCopy(wsQName,TEXT("RpcCl-"));
        RpcpStringCat(wsQName,pwsUuid);

        // Function UuidCreate() allocated a string, free it:
        RpcStringFree(&pwsUuid);

        //
        // Create the queue for this endpoint:
        //
        hr = ClientSetupQueue( pEndpoint, pEndpoint->wsMachine, wsQName );
        Status = MQ_MapStatusCode(hr,RPC_S_CANT_CREATE_ENDPOINT);

        if (Status == RPC_S_OK)
           {
           MQ_RegisterQueueToDelete(pEndpoint->wsQFormat,wsMachine);
           }
        }
    else
        {
        pEndpoint->type |= SERVER;

        //
        // Create the queue for this server endpoint:
        //
        hr = ServerSetupQueue( pEndpoint,
                               pEndpoint->wsMachine,
                               pEndpoint->wsQName,
                               pSecurityDescriptor,
                               dwEndpointFlags );

        Status = MQ_MapStatusCode(hr,RPC_S_CANT_CREATE_ENDPOINT);

        //
        // Check to see if this queue is temporary. If so, then
        // register it with RPCSS to delete.
        //
        if ((Status == RPC_S_OK) && !(RPC_C_MQ_PERMANENT & dwEndpointFlags))
           {
           MQ_RegisterQueueToDelete(pEndpoint->wsQFormat,wsMachine);
           }
        }

    //
    // If the endpoint is going to async initialize async part
    // and add the socket to the IO completion port.
    //

    if (Status == RPC_S_OK)
        {
        int cMaxIos;
        int cMinIos;

        ASSERT(fAsync || fClient);

        // Step one, figure out the high and low mark for ios.

        if (fAsync)
            {
            // PERF REVIEW these parameters.
            cMaxIos = 2
                      + (gfServerPlatform == TRUE) * 2
                      + (fClient == FALSE) * gNumberOfProcessors;

            // This should be larger than zero so that we'll generally submit new
            // recvs during idle time rather then just after receiving a datagram.
            cMinIos = 1 + (fClient == FALSE ) * (gNumberOfProcessors/2);

            cMinIos = 1;
            cMaxIos = 1;
            }
        else
            {
            // For sync endpoints we need to allocate a single datagram
            // object for the receive.
            cMinIos = 0;
            cMaxIos = 1;
            }

        // ASSERT(cMinIos < cMaxIos); Not currently true...

        pEndpoint->cMinimumIos = cMinIos;
        pEndpoint->cMaximumIos = cMaxIos;

        // Allocate a chunk on memory to hold the array of datagrams

        // PERF: For clients, allocate larger array but don't submit all
        // the IOs unless we determine that the port is "really" active.

        pEndpoint->aDatagrams = new MQ_DATAGRAM[cMaxIos];

        if (pEndpoint->aDatagrams)
            {
            UINT type;
            type = DATAGRAM | RECEIVE;
            type |= (fClient) ? CLIENT : SERVER;

            for (i = 0; i < cMaxIos; i++)
                {
                pDatagram = &pEndpoint->aDatagrams[i];

                pDatagram->id = id;
                pDatagram->type = type;
                pDatagram->pEndpoint = pEndpoint;
                pDatagram->Busy = 0;
                pDatagram->pPacket = 0;
                pDatagram->dwPacketSize = 0;
                memset(&pDatagram->Read, 0, sizeof(pDatagram->Read));
                pDatagram->Read.pAsyncObject = pDatagram;
                }

            if (fAsync)
                {
                Status = COMMON_PrepareNewHandle((HANDLE)pEndpoint->hQueue);
                }
            else
                {
                // The receive operation on sync endpoints will may span
                // several receives.  This means it can't use the thread
                // event, so allocate an event for the receive.
                HANDLE hEvent = CreateEvent(0, TRUE, FALSE, 0);
                if (!hEvent)
                    {
                    Status = RPC_S_OUT_OF_RESOURCES;
                    }
                else
                    {
                    ASSERT(pDatagram == &pEndpoint->aDatagrams[0]);
                    pDatagram->Read.ol.hEvent = hEvent;
                    }
                }
            }
        else
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        }

    // If adding a new failure case here, add code to close the sync receive event.

    if (Status != RPC_S_OK)
        {
        delete pEndpoint->aDatagrams;

        return Status;
        }

    return(RPC_S_OK);
}


void RPC_ENTRY
MQ_ServerAbortListen(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Callback after DG_CreateEndpoint has completed successfully
    but the runtime for some reason is not going to be able to
    listen on the endpoint.

--*/
{
    HRESULT     hr;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;

    #ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "MQ_ServerAbortListen(): %S\n",
                   pEndpoint->wsQName));
    #endif

    ASSERT(pEndpoint->cPendingIos == 0);
    ASSERT(pEndpoint->hQueue);
    ASSERT(pEndpoint->pNext == 0);
    ASSERT(pEndpoint->type & SERVER);

    if (pEndpoint->pAddressVector)
        {
        delete pEndpoint->pAddressVector;
        }

    if (pEndpoint->aDatagrams)
        {
        delete pEndpoint->aDatagrams;
        }

    hr = ServerCloseQueue(pEndpoint);

    return;
}


RPC_STATUS RPC_ENTRY
MQ_ClientCloseEndpoint(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Called on sync client endpoints when they are no longer needed.

Arguments:

    ThisEndpoint

Return Value:

    RPC_S_OK

--*/
{
    HRESULT      hr;
    PMQ_DATAGRAM_ENDPOINT pEndpoint = (PMQ_DATAGRAM_ENDPOINT)ThisEndpoint;
    PMQ_DATAGRAM pDatagram = &pEndpoint->aDatagrams[0];

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->hQueue);           // MQOpenQueue must have worked
    ASSERT(pEndpoint->cMinimumIos == 0);
    ASSERT(pEndpoint->cMaximumIos == 1); // Must not be async!
    ASSERT(pEndpoint->aDatagrams);
    // ASSERT(pEndpoint->Endpoint == 0);
    ASSERT(pEndpoint->pAddressVector == 0);
    // ASSERT(pEndpoint->pNext == 0);

    // Close & delete the client queue:
    hr = ClientCloseQueue(pEndpoint);

    // Free the receive buffer if allocated
    if (pDatagram->pPacket)
        {
        I_RpcTransDatagramFree(pEndpoint,
                               (BUFFER)pDatagram->pPacket,
                               pDatagram->pAddress
                               );
        }

    if (pDatagram->Read.ol.hEvent)
        {
        CloseHandle(pDatagram->Read.ol.hEvent);
        }

    delete pDatagram;

    pEndpoint->aDatagrams = 0;

    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
MQ_ServerListen(
    IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
    IN     RPC_CHAR                *NetworkAddress,
    IN OUT RPC_CHAR               **ppEndpoint,
    IN     void                    *pSecurityDescriptor,
    IN     ULONG                    EndpointFlags,
    IN     ULONG                    NICFlags,
    OUT    NETWORK_ADDRESS_VECTOR **ppNetworkAddressVector
    )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    ppEndpoint - The RPC_CHAR name of the endpoint to listen
        on or a pointer to 0 if the transport should choose
        the address. Contains the endpoint listened to on
        output. The caller should free this.
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS  Status;
    DWORD       dwSize;
    UUID        uuid;
    RPC_CHAR   *pUuidStr;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;


    *ppNetworkAddressVector = 0;

    if (*ppEndpoint)
        {
        // Known Endpoint:
        RpcpStringCopy(pEndpoint->wsQName,*ppEndpoint);
        }
    else
        {
        // Dynamic Endpoint:
        Status = UuidCreate(&uuid);
        if ((Status != RPC_S_OK) && (Status != RPC_S_UUID_LOCAL_ONLY))
           {
           return Status;
           }

        Status = UuidToString(&uuid,&pUuidStr);
        if (Status != RPC_S_OK)
           {
           return Status;
           }

        RpcpStringCopy(pEndpoint->wsQName,TEXT("RpcSvr-"));
        RpcpStringCat(pEndpoint->wsQName,pUuidStr);
        RpcStringFree(&pUuidStr);

        dwSize = (1+RpcpStringLength(pEndpoint->wsQName))*(sizeof(RPC_CHAR));
        *ppEndpoint = (RPC_CHAR*)I_RpcAllocate(dwSize);
        if (!*ppEndpoint)
           {
           return RPC_S_OUT_OF_MEMORY;
           }

        RpcpStringCopy(*ppEndpoint,pEndpoint->wsQName);
        }

    //
    // Actually create the endpoint
    //
    Status = MQ_CreateEndpoint( pEndpoint,
                                NULL,
                                pSecurityDescriptor,
                                EndpointFlags,
                                MSMQ,
                                FALSE,     // Server
                                TRUE   );  // Async

    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = MQ_BuildAddressVector(&pEndpoint->pAddressVector);

    if (Status != RPC_S_OK)
        {
        MQ_ServerAbortListen(ThisEndpoint);
        return Status;
        }

    *ppNetworkAddressVector = pEndpoint->pAddressVector;

    #if FALSE
    // If needed, figure out the dynamically allocated endpoint.

    if (!*pPort)
        {
        *pPort = new RPC_CHAR[IP_MAXIMUM_ENDPOINT];
        if (!*pPort)
            {
            MQ_ServerAbortListen(ThisEndpoint);
            return(RPC_S_OUT_OF_MEMORY);
            }

        port = ntohs(addr.inetaddr.sin_port);

        PortNumberToEndpoint(port, *pPort);
        }

    // Figure out the network addresses

    status = IP_BuildAddressVector(&pEndpoint->pAddressVector);

    if (status != RPC_S_OK)
        {
        MQ_ServerAbortListen(ThisEndpoint);
        return(status);
        }

    *ppNetworkAddressVector = pEndpoint->pAddressVector;
    #endif

    return RPC_S_OK;
}


RPC_STATUS
MQ_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    MQ_ADDRESS *pAddress = (MQ_ADDRESS*)pOriginalEndpoint;

    if (!RpcpStringLength(pAddress->wsQName))
        {
        ParseQueuePathName(pAddress->wsMsgLabel,
                           pAddress->wsMachine,
                           pAddress->wsQName);
        }

    RpcpStringCopy(pClientEndpoint,pAddress->wsQName);

    return RPC_S_OK;
}


RPC_STATUS
MQ_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientAddress
    )
{
    MQ_ADDRESS *pAddress = (MQ_ADDRESS*)pOriginalEndpoint;

    if (!RpcpStringLength(pAddress->wsMachine))
        {
        ParseQueuePathName(pAddress->wsMsgLabel,
                           pAddress->wsMachine,
                           pAddress->wsQName);
        }

    RpcpStringCopy(pClientAddress,pAddress->wsMachine);

    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
MQ_ClientInitializeAddress
     (
     OUT DG_TRANSPORT_ADDRESS pvAddress,
     IN  RPC_CHAR *pNetworkAddress,
     IN  RPC_CHAR *pEndpoint,
     IN  BOOL fUseCache,
     IN  BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    pvAddress - Storage for the address
    pNetworkAddress - The address of the server or 0 if local
    pEndpoint - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    RPC_STATUS  Status = RPC_S_OK;
    MQ_ADDRESS *pAddress = (MQ_ADDRESS*)pvAddress;

    ASSERT(pvAddress);

    Status = ConnectToServerQueue(pAddress,pNetworkAddress,pEndpoint);

    return Status;
}


RPC_STATUS
RPC_ENTRY
MQ_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD Flags
    )
{
    RPC_STATUS Status;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;

    Status = MQ_CreateEndpoint(pEndpoint, NULL, NULL, 0, MSMQ, TRUE, fAsync);

    return Status;
}

RPC_STATUS
RPC_ENTRY
MQ_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    pStats->PreferredPduSize = MQ_PREFERRED_PDU_SIZE;
    pStats->MaxPduSize = MQ_MAX_PDU_SIZE;
    pStats->MaxPacketSize = MQ_MAX_PACKET_SIZE;
    pStats->ReceiveBufferSize = MQ_RECEIVE_BUFFER_SIZE;

    return RPC_S_OK;
}

//----------------------------------------------------------------
//  MQ_InquireAuthClient()
//
//  Fill out security information for the transport.
//
//  NOTE: The returned SID (ppSid) is a pointer to the one in the
//        client endpoint. The caller can't free it and should make
//        its own copy...
//----------------------------------------------------------------
RPC_STATUS
RPC_ENTRY
MQ_InquireAuthClient( void      *pvClientEndpoint,
                      RPC_CHAR **ppPrincipal,
                      SID      **ppSid,
                      ULONG     *pulAuthnLevel,
                      ULONG     *pulAuthnService,
                      ULONG     *pulAuthzService )
{
   RPC_STATUS   Status = RPC_S_OK;
   MQ_ADDRESS  *pClientEndpoint = (MQ_ADDRESS*)(pvClientEndpoint);
   SID         *pClientSid;
   DWORD        dwSize;

   ASSERT(pulAuthnLevel);
   ASSERT(pulAuthnService);
   ASSERT(pulAuthzService);

   if (pClientEndpoint)
      {
      *ppPrincipal = NULL;
      *pulAuthnService = RPC_C_AUTHN_MQ;
      *pulAuthzService = RPC_C_AUTHZ_NONE;

      //
      //  The authentication level:
      //
      if (pClientEndpoint->fAuthenticated)
         {
         if (pClientEndpoint->ulPrivacyLevel == MQMSG_PRIV_LEVEL_BODY_BASE)
            *pulAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
         else
            *pulAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
         }
      else if (pClientEndpoint->ulPrivacyLevel == MQMSG_PRIV_LEVEL_BODY_BASE)
         {
         *pulAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
         }
      else
         {
         *pulAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
         }

      if ( IsValidSid((PSID)(pClientEndpoint->aSidBuffer)) )
         *ppSid = (SID*)(pClientEndpoint->aSidBuffer);
      else
         *ppSid = NULL;

      }
   else
      Status = RPC_S_BINDING_HAS_NO_AUTH;

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\loader.cxx ===
/*++

  Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    loader.cxx

Abstract:

    Configuration and loading of RPC transports

Revision History:
  MarioGo      03-18-96    Cloned from parts of old common.c
  MarioGo      10-31-96    Async RPC

--*/

#include <precomp.hxx>
#include <loader.hxx>
#include <trans.hxx>
#include <cotrans.hxx>
#include <dgtrans.hxx>
#include <selbinding.hxx>

extern "C" {
#include <iphlpapi.h>
}

// Globals - see loader.hxx

DWORD     gdwComputerNameLength = 0;
RPC_CHAR  gpstrComputerName[MAX_COMPUTERNAME_LENGTH + 1];

UINT gPostSize = CO_MIN_RECV;

#ifdef _INTERNAL_RPC_BUILD_
RPCLT_PDU_FILTER_FUNC gpfnFilter = NULL;
#endif

//
// Used to convert numbers to hex strings
//

const RPC_CHAR HexDigits[] =
{
    RPC_CONST_CHAR('0'),
    RPC_CONST_CHAR('1'),
    RPC_CONST_CHAR('2'),
    RPC_CONST_CHAR('3'),
    RPC_CONST_CHAR('4'),
    RPC_CONST_CHAR('5'),
    RPC_CONST_CHAR('6'),
    RPC_CONST_CHAR('7'),
    RPC_CONST_CHAR('8'),
    RPC_CONST_CHAR('9'),
    RPC_CONST_CHAR('A'),
    RPC_CONST_CHAR('B'),
    RPC_CONST_CHAR('C'),
    RPC_CONST_CHAR('D'),
    RPC_CONST_CHAR('E'),
    RPC_CONST_CHAR('F')
};

// WARNING: The order of these protocols must be consistent with the
//          definition of PROTOCOL_ID.

const
TRANSPORT_TABLE_ENTRY TransportTable[] = {
    {
    0,
    0,
    0
    },

    // TCP/IP
    {
    TCP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&TCP_TransportInterface
    },

#ifdef SPX_ON
    // SPX
    {
    SPX_TOWER_ID,
    IPX_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&SPX_TransportInterface
    },
#else
    {
    0,
    0,
    NULL
    },
#endif

    // Named pipes
    {
    NMP_TOWER_ID,
    UNC_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NMP_TransportInterface
    },

#ifdef NETBIOS_ON
    // Netbeui
    {
    NB_TOWER_ID,
    NBF_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NBF_TransportInterface
    },

    // Netbios over TCP/IP
    {
    NB_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NBT_TransportInterface
    },

    // Netbios over IPX
    {
    NB_TOWER_ID,
    IPX_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NBI_TransportInterface
    },
#else
    // Netbeui
    {
    0,
    0,
    NULL
    },

    // Netbios over TCP/IP
    {
    0,
    0,
    NULL
    },

    // Netbios over IPX
    {
    0,
    0,
    NULL
    },
#endif

#ifdef APPLETALK_ON
    // Appletalk Datastream protocol
    {
    DSP_TOWER_ID,
    NBP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&DSP_TransportInterface
    },
#else
    // Appletalk Datastream protocol
    {
    0,
    0,
    NULL
    },
#endif

    // Banyan Vines SSP
    {
    0,
    0,
    NULL
    },

    // Hyper-Text Tranfer Protocol (HTTP)
    {
    HTTP_TOWER_ID,
    HTTP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&HTTP_TransportInterface
    },

    // UDP/IP
    {
    UDP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&UDP_TransportInterface
    },

#ifdef IPX_ON
    // IPX
    {
    IPX_TOWER_ID,
    IPX_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&IPX_TransportInterface
    },
#else
    // IPX
    {
    0,
    0,
    0
    },
#endif

    // CDP/UDP/IP
    {
    CDP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&CDP_TransportInterface
    },

#ifdef NCADG_MQ_ON
    // MSMQ (Falcon/RPC)
    {
    MQ_TOWER_ID,
    MQ_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&MQ_TransportInterface
    },
#else
    // MSMQ (Falcon/RPC)
    {
    0,
    0,
    NULL
    },
#endif

    // TCP over IPv6
    {
    TCP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&TCP_TransportInterface
    },

    // HTTP2 - same as HTTP in terms of contents.
    {
    HTTP_TOWER_ID,
    HTTP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&HTTP_TransportInterface
    }
};

const DWORD cTransportTable = sizeof(TransportTable)/sizeof(TRANSPORT_TABLE_ENTRY);


inline
BOOL CompareProtseqs(
    IN const CHAR *p1,
    IN const RPC_CHAR *p2)
// Note: protseqs use only ANSI characters so this is ok.
{
    while(*p1)
        {
        if (*p1 != *p2)
            {
            return FALSE;
            }
        p1++;
        p2++;
        }

    return(*p2 == 0);
}

PROTOCOL_ID
MapProtseq(
    IN const RPC_CHAR *RpcProtocolSequence
    )
{
    PROTOCOL_ID index;

    for(index = 1; index < cTransportTable; index++)
        {
        if (TransportTable[index].pInfo != NULL)
            {
            if (RpcpStringCompare(RpcProtocolSequence,
                                TransportTable[index].pInfo->ProtocolSequence) == 0)
                {
                return(index);
                }
            }
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "Called with unknown protseq %S\n",
                   RpcProtocolSequence));

    ASSERT(0);
    return(0);
}

PROTOCOL_ID
MapProtseq(
    IN const CHAR *RpcProtocolSequence
    )
{
    PROTOCOL_ID index;

    for(index = 1; index < cTransportTable; index++)
        {
        if (TransportTable[index].pInfo != NULL)
            {
            if (CompareProtseqs(RpcProtocolSequence,
                        TransportTable[index].pInfo->ProtocolSequence))
                {
                return(index);
                }
            }
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "Called with unknown protseq %S\n",
                   RpcProtocolSequence));

    ASSERT(0);
    return(0);
}

// NB: must be called before RpcCompletionPort is zeroed out, because it is used for comparison
void FreeCompletionPortHashTable(void)
{
    DWORD i;
    HANDLE hCurrentHandle;

    // walk through the table, not closing if there is next entry, and it is the same as this
    for (i = 0; i < gNumberOfProcessors * 2; i ++)
        {
        hCurrentHandle = RpcCompletionPorts[i];

        if (hCurrentHandle && (hCurrentHandle != RpcCompletionPort))
            {
            CloseHandle(hCurrentHandle);
            }
        }
}

HANDLE GetCompletionPortHandleForThread(void)
{
    DWORD i;
    DWORD nMinLoad = (DWORD) -1;
    int nMinLoadIndex = -1;

    for (i = 0; i < gNumberOfProcessors * 2; i ++)
        {
        if ((DWORD)CompletionPortHandleLoads[i] < nMinLoad)
            {
            nMinLoadIndex = i;
            nMinLoad = CompletionPortHandleLoads[i];
            }
        }

    ASSERT (nMinLoadIndex >= 0);
    InterlockedIncrement(&CompletionPortHandleLoads[nMinLoadIndex]);
    ASSERT(RpcCompletionPorts[nMinLoadIndex] != 0);
    return RpcCompletionPorts[nMinLoadIndex];
}

void ReleaseCompletionPortHandleForThread(HANDLE h)
{
    DWORD i;

    for (i = 0; i < gNumberOfProcessors * 2; i ++)
        {
        if (h == RpcCompletionPorts[i])
            {
            InterlockedDecrement((long *)&CompletionPortHandleLoads[i]);
            ASSERT(CompletionPortHandleLoads[i] >= 0);
            return;
            }
        }

    ASSERT(0);
}

//
// The firewall table settings:
//
// DoFirewallInit() initializes and updates the data structure.
//
// Syncronization needs are:
// - DoFirewallInit() is not thread-safe and should execute inside a critical section.
// - Access to pFirewallTable should be syncronized against update in DoFirewallInit().
//
// The rules are:
// - The table is initialized during the first UseProtseq*.  Subsequent UseProtseq*'s will be noops for
// the initialized table.
// - Update happens on PnP notification.  The table gets re-created and replaced during an address change.
// - Access happens on PnP notification and on UseProtseq* path.
// - Access on PnP notification happens after the update to the table.  Since a UseProtseq* call must have
// been already made, this path does not have to syncronize against modification by UseProtseq*.  Since
// we are doing an access after updating the table, and PnP state change occurs within a critical section,
// access on PnP event does not have to syncronize with anyone.
// - Therefore we only need to syncronize the access on UseProtseq* agains an update on address change.
// The access thread will make a local copy inside a mutex and the update will modify table inside a mutex.
//
FIREWALL_INFO *pFirewallTable = 0;

// Set to TRUE when all interfaces have addresses assigned
// and the table does not have un-initialized addresses.
// Untill all interfaces get addresses, we will monitor for
// address change.
BOOL fFirewallTableFullyInitialized = FALSE;

// The number of interfaces that have addresses assigned.
DWORD FirewallTableNumActiveEntries = 0;

// Has the firewall table been initialized.
// We are protected by the GlobalMutex when we are in DoFirewallInit, so this is OK
BOOL fFirewallInited = FALSE;

typedef DWORD (*PGETIPADDRTABLE)
    (
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PDWORD           pdwSize,
    IN     BOOL             bOrder
    );


DWORD
GetIpAddrTableHelper(
    OUT PMIB_IPADDRTABLE *ppIpAddrTable
    )
{
    HMODULE hDll;
    PGETIPADDRTABLE pGetIpAddrTable = NULL;
    DWORD dwSize, dwStatus;
    
    hDll = LoadLibrary(RPC_CONST_SSTRING("iphlpapi.dll"));
    if (hDll == 0)
        {
        return FALSE;
        }

    pGetIpAddrTable = (PGETIPADDRTABLE)GetProcAddress(hDll, "GetIpAddrTable");
    if (pGetIpAddrTable == 0)
        {
        FreeLibrary(hDll);
        return FALSE;
        }

    // Query for the size
    *ppIpAddrTable = NULL;    
    dwSize = 0;
    dwStatus = pGetIpAddrTable(*ppIpAddrTable,  
                              &dwSize,
                              TRUE);

    if (dwStatus != ERROR_INSUFFICIENT_BUFFER)
        {
        VALIDATE(dwStatus)
            {
            ERROR_OUTOFMEMORY
            } END_VALIDATE;

        FreeLibrary(hDll);
        return FALSE;
        }

    *ppIpAddrTable = (PMIB_IPADDRTABLE) new char [dwSize];
    if (*ppIpAddrTable == NULL)
        {
        FreeLibrary(hDll);
        return FALSE;
        }

    // Get the interfaces for the machine
    dwStatus = pGetIpAddrTable(*ppIpAddrTable,  
                              &dwSize,
                              TRUE);

    FreeLibrary(hDll);

    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT(0);
        delete [] *ppIpAddrTable;
        return FALSE;
        }

    return TRUE;

}

BOOL
ConvertAndSaveHelper(
    IN VER_INDICES_SETTINGS *Settings,
    IN PMIB_IPADDRTABLE IpAddrTable
    )
{

    DWORD IdxToSubnetCnt = 0;
    LPDWORD SubnetArray = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    
    SubnetArray = new DWORD[IpAddrTable->dwNumEntries];
    if (SubnetArray == NULL)
        {
        return FALSE;
        }
    
    for (DWORD idx = 0; idx < IpAddrTable->dwNumEntries; idx++)
        {
        PMIB_IPADDRROW pRow = &IpAddrTable->table[idx];
        for (DWORD idx2 = 0; idx2 < Settings->dwCount; idx2++)
            {
            DWORD dwDeviceIndex = pRow->dwIndex;
            if (dwDeviceIndex == Settings->dwIndices[idx2])
                {                    
                SubnetArray[IdxToSubnetCnt] = pRow->dwAddr & pRow->dwMask;
                IdxToSubnetCnt++;
                break;
                }
            }
        }

    // We have the subnets based off the index settings, commit them as subnet settings
    if (IdxToSubnetCnt == 0)
        {
        (void) DeleteSelectiveBinding();
        }
    else
        {
        dwStatus = SetSelectiveBindingSubnets(IdxToSubnetCnt, SubnetArray, TRUE);
        VALIDATE(dwStatus)
            {
            ERROR_SUCCESS,
            ERROR_OUTOFMEMORY,
            ERROR_ACCESS_DENIED
            } END_VALIDATE;
        }

    delete [] SubnetArray;
    return (dwStatus == ERROR_SUCCESS);
    }

BOOL
DoFirewallInit (
    )
/*++

Routine Description:

    Initializes the firewall address table.

Arguments:

Return Value:

    TRUE - Initialization suceeded and pFirewallTable has been initialized or updated.
    FALSE - Initialization has failed and the table is in the state
    it was in prior to the call.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwSize = 1;
    LPVOID lpSettings = NULL;
    SB_VER sbVer = SB_VER_UNKNOWN;
    PMIB_IPADDRTABLE pIpAddrTable = NULL;
    FIREWALL_INFO *pNewFirewallTable = 0;

#ifdef MAJOR_TRANS_DEBUG
    DbgPrint("RPC: DoFirewallInit\n");
#endif

    // If we already initialized, then just return success
    if (fFirewallInited)
        {
        return TRUE;
        }

    // We will return from this loop if there are unknown settings (return with failure), if there
    // are default settings (return with success), or if there is a failure converting the indicies settings
    // to subnet settings.

    // We will break from this loop only when we have read in subnet settings (which means they were there originially
    // or we read in index settings, wrote them back out as subnet settings and then read the new subnet settings in.
    for(;;)
        {
        // Retrieve the selective binding setting from the registry.
        dwStatus = GetSelectiveBindingSettings(&sbVer, &dwSize, &lpSettings);
        if (dwStatus != ERROR_SUCCESS)
            {
            VALIDATE(dwStatus)
                {
                ERROR_OUTOFMEMORY
                } END_VALIDATE;
            return FALSE;
            }

        switch (sbVer)
            {
            case SB_VER_UNKNOWN:
                //this means the selective binding settings are corrupt, fatal failure
                delete [] pIpAddrTable;
                return FALSE;
            
            case SB_VER_DEFAULT:
                // pFirewallTable == NULL in the beginning, so there is nothign to be done in that case.
                // If we have already initialized the table, we can't delete it now since folks
                // may have references to it.  We will just ignore the new settings.
                fFirewallInited = TRUE;
                delete [] pIpAddrTable;
                delete lpSettings;                
                return TRUE;
            
            case SB_VER_INDICES:
                // We need to convert this to subnet settings and commit it to the registry
                // Get the pIpAddrTable.  Note: The pIpAddrTable may not be avaliable if the system
                // is being installed, we assume that if there are selective binding settings in the registry
                // then the pIpAddrTable is avaliable.

                if (!GetIpAddrTableHelper(&pIpAddrTable))
                    {
                    delete lpSettings;                    
                    return FALSE;
                    }
                
                if (!ConvertAndSaveHelper((VER_INDICES_SETTINGS *)lpSettings, pIpAddrTable))
                    {
                    delete [] pIpAddrTable;
                    delete lpSettings;                    
                    return FALSE;
                    }
                delete [] lpSettings;
                continue;

            case SB_VER_SUBNETS:
                break;

            default:
                ASSERT(0);
                delete [] pIpAddrTable;
                return FALSE;
            }

        break;
    }


    ASSERT(sbVer == SB_VER_SUBNETS);
    ASSERT(lpSettings != NULL);

    // If we didn't retrieve the Ip Address Table, get it now.  We would have already retrieved it if we originally read in
    // index format settings.

    if (pIpAddrTable == NULL)
        {
        if (!GetIpAddrTableHelper(&pIpAddrTable))
            {
            return FALSE;
            }
        }

    
    // Allocate the subnet table, for simplicity allocate enough space to fit all the interfaces on the system
    // and a flag for each interface.  The array of addresses and flags will follow the FIREWALL_INFO structure
    // in memory.
    // We are using the following procedure to update pFirewallTable:
    // Req: If the function fails, pFirewallTable is unchanged.
    // Req: If the function suceeds, pFirewallTable is updated to the new copy atomically.
    // Rule: Work on a temp copy of the firewall table without touching the original.
    // Rule: On sucess update the original.
    pNewFirewallTable = (FIREWALL_INFO*) new char[sizeof(FIREWALL_INFO)
                                                  + sizeof(FIREWALL_INFO_ENTRY) * (pIpAddrTable->dwNumEntries - 1)];
    if (pNewFirewallTable == NULL)
        {
        delete [] pIpAddrTable;
        delete [] lpSettings;
        return FALSE;
        }

    pNewFirewallTable->NumAddresses = pIpAddrTable->dwNumEntries;

    // Step through the interfaces, add enabled interfaces to our firewall table
    // for subnets: if admit list: if the interface & mask is in the list of subnets
    //              it is enabled. for deny list, if it is a member of any of the subnets
    //              then it not enabled
    
    VER_SUBNETS_SETTINGS *pSubnetSettings = (VER_SUBNETS_SETTINGS*) lpSettings;

    for (DWORD idx = 0; idx < pIpAddrTable->dwNumEntries; idx++)
        {
        PMIB_IPADDRROW pRow = &pIpAddrTable->table[idx];
        BOOL bEnabled = !(pSubnetSettings->bAdmit);

        pNewFirewallTable->Entries[idx].Address = pRow->dwAddr;

        for (DWORD idx2 = 0; idx2 < pSubnetSettings->dwCount; idx2++)
            {
            DWORD dwSubnet = pRow->dwAddr & pRow->dwMask;

            if (dwSubnet == pSubnetSettings->dwSubnets[idx2])
                {
                bEnabled = pSubnetSettings->bAdmit;
                break;
                }
            }

        if (pNewFirewallTable->Entries[idx].Address == 0x0100007F){
            // The loopback address must always be enabled, regardless
            // of the selective binding settings.
            pNewFirewallTable->Entries[idx].fEnabled = TRUE;
            }
        else {
            pNewFirewallTable->Entries[idx].fEnabled = bEnabled;
            }        
        }
    

    // If some interfaces have not yet been initialized and do not have an address,
    // mark them as such with the flag.
    // Un-initialized interfaces will have a NULL address in the table.  This
    // may happen if a DHCP address has not yet been assigned to the corresponding NIC.
    // If there are no un-initialized interfaces left, the table is now fully initialized
    // and we will set fFirewallTableFullyInitialized.
    fFirewallTableFullyInitialized = TRUE;
    FirewallTableNumActiveEntries = 0;

    for (DWORD i = 0; i < pNewFirewallTable->NumAddresses; i++)
        {
        if (pNewFirewallTable->Entries[i].Address == NULL)
            {
            pNewFirewallTable->Entries[i].fInitialized = FALSE;
            fFirewallTableFullyInitialized = FALSE;
            }
        else
            {
            pNewFirewallTable->Entries[i].fInitialized = TRUE;
            if (pNewFirewallTable->Entries[i].fEnabled == TRUE)
                {
                FirewallTableNumActiveEntries++;
                }
            }
        }


#ifdef MAJOR_TRANS_DEBUG
    DbgPrint("RPC: DoFirewallInit: pNewFirewallTable = 0x%x pNewFirewallTable->NumAddresses = 0x%x\n",
        pNewFirewallTable,
        pNewFirewallTable->NumAddresses
        );
    for (DWORD i = 0; i < pNewFirewallTable->NumAddresses; i++)
        {
        DbgPrint("RPC: DoFirewallInit: pNewFirewallTable->Entries[0x%x]: Address = 0x%x fInitialized = 0x%x fEnabled = 0x%x fNewAddress = 0x%x\n",
            i,
            pNewFirewallTable->Entries[i].Address,
            pNewFirewallTable->Entries[i].fInitialized,
            pNewFirewallTable->Entries[i].fEnabled,
            pNewFirewallTable->Entries[i].fNewAddress,
            );
        }
    DbgPrint("RPC: DoFirewallInit: Initialized pNewFirewallTable:\n");
#endif

    // Figure out which addresses in the table are new ones.
    for (DWORD i = 0; i < pNewFirewallTable->NumAddresses; i++)
        {
        // If this is a new table then all addresses are new ones.
        if (pFirewallTable == NULL)
            {
            pNewFirewallTable->Entries[i].fNewAddress = TRUE;
            }
        else
            {
            // If we are updating the table, see if the address appeared some place
            // in the old table.
            pNewFirewallTable->Entries[i].fNewAddress = TRUE;
            for (DWORD j = 0; j < pFirewallTable->NumAddresses; j++)
                {
                // If it does, then this entry is not a new one.
                if (pNewFirewallTable->Entries[i].Address == pFirewallTable->Entries[j].Address)
                    {
                    pNewFirewallTable->Entries[i].fNewAddress = FALSE;
                    }
                }
            }
        }    

    // We have completed the initialization of pNewFirewallTable.
    // Replace the old copy of the table with the new one.
    delete [] pFirewallTable;
    pFirewallTable = pNewFirewallTable;

    fFirewallInited = TRUE;

    delete [] pIpAddrTable;
    delete [] lpSettings;

    return TRUE;
}

void
DoFirewallUpdate (
    )
/*++

Routine Description:

    Updates the firewall address table and any addresses that have not
    yet been initialized.
    
    This function is called on an address change PnP event.
    We re-load the firewall address table and then scan all transport addresses.
    We initialize and listen on the addresses that received an IP address.

Arguments:
    
    None

Return Value:

    None

--*/
{
    BOOL fRes;
    BOOL fFirewallInitedSaved;

    // We have received a PnP event that signals an address change.

    // Re-initialize the firewall address table since it may now
    // have addresses assigned to interfaces that previously were
    // uninitialized.
    // DoFirewallInit() is not thread safe so we will take the global mutex.
    RequestGlobalMutex();

    // Remember the current state of the table.
    fFirewallInitedSaved = fFirewallInited;

    // Force an update to the table.
    fFirewallInited = FALSE;
    fRes = DoFirewallInit();

    // If the update has failed, we will continue using the old table, so
    // restore the flag.  The call should have left the table untouched.
    if (fFirewallInitedSaved && !fFirewallInited)
        {
        fFirewallInited = TRUE;
        }

    ClearGlobalMutex();

    // If we could not update the firewall table, bail out.
    // The table should remain with the original entries and
    // we will not listen on the new or modified addresses.
    if (!fRes)
        {
#ifdef DBG
        DbgPrint("RPC: Could not update pFirewallTable.  The server may not listen on some interfaces.\n");
#endif
        return;
        }

    // Go through the list of the available transport addresses, initialize them,
    // and make them listen on the new network address.
    GetTransportProtocol(TCP)->InitNewAddresses(TCP);
}

FIREWALL_INFO *
GetFirewallTableCopy (
    void
    )
/*++

Routine Description:

    Allocates and returns a copy of the firewall table.
    The caller must free the table after finishing using it.

    The function must be protected against racing with DoFirewallInit().
    The function must be called after the table has been initialized.

Arguments:

    None

Return Value:

    Pointer to a copy of the firewall table.

--*/
{
    FIREWALL_INFO *pCopyOfFirewallTable = NULL;
    DWORD size;

    ASSERT(fFirewallInited);

    if (pFirewallTable == NULL)
        {
        return NULL;
        }

    size = sizeof(FIREWALL_INFO) + sizeof(FIREWALL_INFO_ENTRY) * (pFirewallTable->NumAddresses - 1);
    pCopyOfFirewallTable = (FIREWALL_INFO*) new char[size];

    if (pCopyOfFirewallTable == NULL)
        {
        return NULL;
        }

    RpcpMemoryCopy(pCopyOfFirewallTable, pFirewallTable, size);

    return pCopyOfFirewallTable;
}

RPC_TRANSPORT_INTERFACE
TransportLoad (
    IN const RPC_CHAR * RpcProtocolSequence
    )
{
    static fLoaded = FALSE;
    RPC_STATUS RpcStatus;

    PROTOCOL_ID index;
    RPC_STATUS status;
    RPC_TRANSPORT_INTERFACE pInfo;

    if (fLoaded == FALSE)
        {

        RpcStatus = InitTransportProtocols();
        if (RpcStatus != RPC_S_OK)
            return NULL;

        //
        // Query the computer name - used by most protocols.
        //

        gdwComputerNameLength = sizeof(gpstrComputerName)/sizeof(RPC_CHAR);

        if (!GetComputerName((RPC_SCHAR *)gpstrComputerName, &gdwComputerNameLength))
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           "RPCTRANS: GetComputerNameW failed: %d\n",
                           GetLastError()));
            return(0);
            }

        gdwComputerNameLength++; // Include the null in the count.

        // Create initial IO completion port.  This saves us from a race
        // assigning the global io completion port.
        ASSERT(RpcCompletionPort == 0);
        RpcCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                                   0,
                                                   0,
                                                   0); // PERF REVIEW

        if (RpcCompletionPort == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL, RPCTRANS "Failed to create initial completion port: %d\n",
                           GetLastError()));

            return(0);
            }

        InactiveRpcCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                                   0,
                                                   0,
                                                   MAXULONG); // PERF REVIEW

        if (InactiveRpcCompletionPort == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL, RPCTRANS "Failed to create initial completion port: %d\n",
                           GetLastError()));

            CloseHandle(RpcCompletionPort);
            RpcCompletionPort = 0;
            return(0);
            }

        HANDLE hCurrentCompletionPortHandle;
        DWORD i;
        BOOL fSuccess = TRUE;
        HANDLE hSourceProcessHandle = GetCurrentProcess();

        RpcCompletionPorts = new HANDLE[gNumberOfProcessors * 2];
        CompletionPortHandleLoads = new long[gNumberOfProcessors * 2];

        if ((RpcCompletionPorts == NULL) || (CompletionPortHandleLoads == NULL))
            {
            CloseHandle(RpcCompletionPort);
            RpcCompletionPort = 0;
            return 0;
            }

        for (i = 0; i < gNumberOfProcessors * 2; i ++)
            {
            RpcCompletionPorts[i] = 0;
            CompletionPortHandleLoads[i] = 0;
            }

        RpcCompletionPorts[0] = RpcCompletionPort;
        for (i = 1; i < gNumberOfProcessors * 2; i ++)
            {
            fSuccess = DuplicateHandle(hSourceProcessHandle, RpcCompletionPort,
                hSourceProcessHandle, &hCurrentCompletionPortHandle, 0, FALSE, DUPLICATE_SAME_ACCESS);
            if (!fSuccess)
                break;

            ASSERT(hCurrentCompletionPortHandle != 0);
            RpcCompletionPorts[i] = hCurrentCompletionPortHandle;
            }

        if (!fSuccess)
            {
            FreeCompletionPortHashTable();
            CloseHandle(RpcCompletionPort);
            RpcCompletionPort = 0;
            return 0;
            }

        //
        // Initalize locks, use Rtl* so we don't need to catch exception.
        //

        NTSTATUS NtStatus;

        NtStatus = RtlInitializeCriticalSectionAndSpinCount(&AddressListLock, PREALLOCATE_EVENT_MASK);
        if (!NT_SUCCESS(NtStatus))
            {
            FreeCompletionPortHashTable();
            CloseHandle(RpcCompletionPort);
            RpcCompletionPort = 0;
            return 0;
            }

        if (gBCacheMode == BCacheModeDirect)
            {
            // allocate minimum post size. This guarantees that buffer
            // will always be at the end.
            gPostSize = sizeof(CONN_RPC_HEADER);
            }

        fLoaded = TRUE;
        }

    index = MapProtseq(RpcProtocolSequence);

    if (!index)
        {
        return(0);
        }

    pInfo = 0;

    switch (index)
        {
        case NMP:
            pInfo = (RPC_TRANSPORT_INTERFACE) NMP_TransportLoad();
            break;

#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
            pInfo = (RPC_TRANSPORT_INTERFACE) NB_TransportLoad(index);
            break;
#endif

        case TCP:
#ifdef SPX_ON
        case SPX:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
        case HTTP:
            pInfo = (RPC_TRANSPORT_INTERFACE) WS_TransportLoad(index);
            break;

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif
        case CDP:
        case UDP:
#ifdef IPX_ON
        case IPX:
#endif
            pInfo = (RPC_TRANSPORT_INTERFACE) DG_TransportLoad(index);
            break;
        }

    if (pInfo == 0)
        {
#ifdef UNICODE
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Load of %S failed\n",
                       RpcProtocolSequence));
#else
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Load of %s failed\n",
                       RpcProtocolSequence));
#endif
        return(0);
        }

    // When running with corruption injection for the client receives,
    // we may overwrite the default transport interfaces with costom Avrf versions.
    CORRUPTION_ASSERT(pInfo == TransportTable[index].pInfo);

    return(pInfo);
}

void
UnjoinCompletionPort (
    void
    )
{
    DWORD NumberOfBytes;
    ULONG_PTR CompletionKey;
    LPOVERLAPPED Overlapped;
    BOOL b;

    // The kernel today doesn't have the functionality to
    // unjoin a thread from a completion port. Therefore
    // we fake unjoining by joining another completion port which has
    // unlimited concurrency called the inactive completion port. 
    // Thus threads unjoined from the main completion port will not
    // affect its concurrency. One undesirable effect is that each
    // time a thread joined to the inactive completion port blocks,
    // it will try to wake up another thread, and there won't be any
    // there, which is a waste of CPU. Ideally, we should have had
    // a capability to set KTHREAD::Queue to NULL, but we don't
    b = GetQueuedCompletionStatus(InactiveRpcCompletionPort,
        &NumberOfBytes,
        &CompletionKey,
        &Overlapped,
        0
        );

    // this operation should either timeout or fail - it should never
    // succeed. If it does, this means somebody has erroneously posted
    // an IO on the inactive completion port
    ASSERT(b == FALSE);
}

void RPC_CLIENT_IP_ADDRESS::ZeroOut (
    void
    )
/*++

Routine Description:

    Create an empty IP address.

Arguments:

Return Value:

--*/
{
    SOCKADDR_IN *EmptyAddr = (SOCKADDR_IN *) Data;

    EmptyAddr->sin_family = AF_INET;
    EmptyAddr->sin_addr.S_un.S_addr = 0;
    EmptyAddr->sin_port = 0;
    RpcpMemorySet(&EmptyAddr->sin_zero, 0, sizeof(EmptyAddr->sin_zero));
    DataSize = 0;
}

#ifdef _INTERNAL_RPC_BUILD_
void
I_RpcltDebugSetPDUFilter (
    IN RPCLT_PDU_FILTER_FUNC pfnFilter
    )
{
    gpfnFilter = pfnFilter;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\ipxname.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ipxname.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    gethost.c

Abstract:

    Maps a server name to SPX address by consulting the Netware Bindery.
    Attach/Detach/FindFileServer, and ReadPropertyValue were all borrowed
    from the SQL 6.0 code base.

Author:

    Jeff Roberts (jroberts)  20-Nov-1995

Revision History:

     20-Nov-1995 (jroberts) Took code from AndreasK of SQL Server, and modified
                            it for RPC.
        
     24-Jan-1997  (MarioGo) C++ and cache cleanup work.

--*/

#include <precomp.hxx>
#include <CharConv.hxx>

const GUID SERVICE_TYPE = { 0x000b0640, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } };

#define CRITICAL_SECTION_WRAPPER RTL_CRITICAL_SECTION

#define MAX_FILESRVS            5               /* try 5 servers (chicago uses this same number) */

/*****  NETWARE MAGIC NUMBERS   *****/

#define NSPROTO_NCP                     (NSPROTO_IPX+0x11)

/* NCP Request Types */
#define CREATE_CONN_REQTYPE             0x1111
#define DESTROY_CONN_REQYPE             0x5555
#define GENERAL_REQTYPE                 0x2222

/* NCP Request Codes */
#define NCP_SCAN_BINDERY                0x17
#define NCP_END_OF_TASK                 0x18
#define NCP_LOGOUT                      0x19
#define NCP_NEG_BUFFER_SIZE             0x21

/* NCP Function codes */
#define SCAN_BINDERY_FUNC               0x37
#define READ_PROP_VALUE_FUNC            0x3D

/* SAP protocol request codes */
#define SAP_GENERAL_QUERY               0x0100  /* general query hi-lo   */
#define SAP_GENERAL_RESPONSE            0x0200  /* general response hi-lo            */
#define SAP_NEAREST_QUERY               0x0300  /* nearest query hi-lo   */
#define SAP_NEAREST_RESPONSE            0x0400  /* nearest response hi-lo   */


/* Socket Numbers       */
#define NCP_SOCKET                      0x5104  /* SAP socket hi-lo              */
#define SAP_SOCKET                      0x5204  /* SAP socket hi-lo              */
#define GUEST_SOCKET                    0x1840

/* SAP Service Types */
#define FILE_SERVER                     0x0400  /* netware file server hi-lo     */
#define SNA_SERVER                      0x4404  /* SNA Server type 0x0444        */
#define BRIDGE_SERVER                   0x2400

#define SAP_SERVICE_STOPPED             0x1000  /* invalid hub count, hi-lo      */
#define SAP_TIMEOUT                     60000   /* SAP timeout, one minute       */
#define NCP_CONNECTION_ERROR            0x15    /* connection error mask         */

#define BINDERY_FAILURE                 0x00FF  /* bindery call failed           */

#define RPC_SAP_TYPE                    0x0640

#define SWAP(x) RpcpByteSwapShort(x)

typedef struct
{
  CSADDR_INFO   info;
  SOCKADDR_IPX  addr1;
  SOCKADDR_IPX  addr2;
} CSADDR_BUFFER;

#pragma pack(1)

typedef struct _sip_entry
{
    char           server_name[48];
    unsigned long  network;
    char           node[6];
    unsigned short socket;
    unsigned short hops;
} SIP_ENTRY;

typedef struct _sip             /* Service Information Packet */
{
    unsigned short response_type;
    unsigned short server_type;
    SIP_ENTRY      entries[7];
} SIP;

typedef struct          /* Service Query Packet */
{
    unsigned short query_type;
    unsigned short server_type;
} SQP;

typedef struct  /* NCP Request Header */
{
    unsigned short req_type;
    unsigned char seq_no;
    unsigned char conn_no_low;
    unsigned char task_no;
    unsigned char conn_no_high;
    unsigned char req_code;

} NCPHDR;

typedef struct  /* NCP Response Header */
{
    unsigned short req_type;
    unsigned char seq_no;
    unsigned char conn_no_low;
    unsigned char task_no;
    unsigned char conn_no_high;
    unsigned char ret_code;
    unsigned char conn_status;
} NCPRSP;

typedef struct  /* Scan Bindery Request */
{
    NCPHDR hdr;
    unsigned short length;
    unsigned char  func_code;
    unsigned long  last_id;
    unsigned short obj_type;
    unsigned char sstring[49];
} SCANREQ;
#define SCANSIZE        56

typedef struct  /* Scan Bindery Response */
{
    NCPRSP hdr;
    unsigned long  obj_id;
    unsigned short obj_type;
    unsigned char  obj_name[48];
    unsigned char  obj_status;
    unsigned char  sec_status;
    unsigned char  status_flags;
} SCANRSP;

typedef struct  /* Read Propery Value */
{
    NCPHDR hdr;
    unsigned short length;
    unsigned char  func_code;
    unsigned short obj_type;
    unsigned char  obj_name[49];
    unsigned char  seg_no;
    unsigned char  prop_name[17];
} RVALREQ;
#define RVALSIZE        70

typedef struct  /* Read Propery Value Response */
{
    NCPRSP hdr;
    unsigned char  prop_value[128];
    unsigned char  more_flag;
    unsigned char  prop_flags;
} RVALRSP;

#pragma pack()

#define BUFFER_SIZE                 1024    /* Size of send and recv buffer         */

struct
{
    SOCKADDR_IPX nsRemote[MAX_FILESRVS];    /* Remote IPX addresses                 */
    unsigned     ServerCount;               /* number of valid entries in nsRemote  */
    unsigned     ActiveServer;              /* index of the the address in use      */
    SOCKET       s;                         /* Socket handle                        */
    unsigned short ConnectionId;
    NCPHDR       *nhHeader;                 /* Last NCP header sent                 */
    char         *RcvBuffer;
}
nsStatus;

typedef struct IPXAddress
{
   char                 network[4];
   char                 node[6];
   unsigned short       socket;
} IPXAddress;


int     FindFileServers();
BOOL    AttachToFileServer();
BOOL    ConnectToActiveServer();
BOOL    DetachFromActiveServer();
int     SendPacket( SOCKET, char *, int, SOCKADDR *, DWORD );
USHORT  ReadPropertyValue( char *, USHORT, char *, USHORT, UCHAR *,
                          UCHAR *, UCHAR * );
int
NcpTransaction(
    int iSize
    );

DWORD
InitializeCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlInitializeCriticalSection(Mutex);

    if (!NT_SUCCESS(NtStatus))
        {
        return RtlNtStatusToDosError(NtStatus);
        }
    return(NO_ERROR);
}

DWORD
DeleteCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlDeleteCriticalSection(Mutex);

    if (!NT_SUCCESS(NtStatus))
        {
        return RtlNtStatusToDosError(NtStatus);
        }
    return(NO_ERROR);
}

DWORD
EnterCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlEnterCriticalSection(Mutex);

    if (!NT_SUCCESS(NtStatus))
        {
        return RtlNtStatusToDosError(NtStatus);
        }
    return(NO_ERROR);
}

DWORD
LeaveCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlLeaveCriticalSection(Mutex);
    ASSERT (NT_SUCCESS(NtStatus));

    return(NO_ERROR);
}


BOOL
AttachToFileServer(
    )
//**************************************************************************
//
// This function creates an attachment between an NT workstation and
// a Novell Netware file server.
//
// Params:
//      USHORT *pConectionID - Receives the connection ID for the newly
//                             attached file server
//                             LOBYTE(ConnectionID) = conn_no_low
//                             HIBYTE(ConnectionID) = conn_no_high
//
// Return Values:
//
//      TRUE  - successful
//      FALSE - unsuccessful
//
//***************************************************************************
{
    DWORD IDThread;
    unsigned i;
    char scratch[2];

    SOCKET s;
    SOCKADDR_IPX nsAddr;
    unsigned Timeout;

    s = socket( AF_NS, SOCK_DGRAM, NSPROTO_NCP );
    if ( s == INVALID_SOCKET )
        {
        return FALSE;
        }

    //
    // Set the receive timeout.
    //
    Timeout = 3000;
    if (SOCKET_ERROR == setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *) &Timeout, sizeof(Timeout)))
        {
        closesocket(s);
        return FALSE;
        }

    memset( &nsAddr, '\0', sizeof(SOCKADDR_IPX) );
    nsAddr.sa_family = AF_NS;
    if (SOCKET_ERROR == bind(s, (SOCKADDR *)&nsAddr, sizeof(SOCKADDR_IPX)) )
        {
        closesocket(s);
        return FALSE;
        }

    nsStatus.s = s;

    /* Find the nearest file server. */

    if( nsStatus.ServerCount )
        {
        for (i=0; i < nsStatus.ServerCount; i++)
            {
            nsStatus.ActiveServer = i;
            if( ConnectToActiveServer() )
                {
                nsStatus.ConnectionId = nsStatus.nhHeader->conn_no_low + (nsStatus.nhHeader->conn_no_high << 8);
                return TRUE;
                }
            }
        }

    FindFileServers();

    if( nsStatus.ServerCount )
        {
        for (i=0; i < nsStatus.ServerCount; i++)
            {
            nsStatus.ActiveServer = i;
            if( ConnectToActiveServer() )
                {
                nsStatus.ConnectionId = nsStatus.nhHeader->conn_no_low + (nsStatus.nhHeader->conn_no_high << 8);
                return TRUE;
                }
            }
        }

    closesocket(s);
    nsStatus.s = 0;

    return FALSE;
}


int
FindFileServers(
    )
/****************************************************************************/
/*                                                                          */
/* This function uses the SAP (Service Advertise Protocol) Find Nearest     */
/* query to find a netware file server.                                     */
/*                                                                          */
/* Returns:                                                                 */
/*      Number of servers found (0 - MAX_FILESRVS)                          */
/*                                                                          */
/****************************************************************************/
{
    SOCKET s;
    BOOL bBcst;
    SQP sqp;
    SIP sip;
    unsigned Timeout;

    SOCKADDR_IPX raddr;
    SOCKADDR_IPX nsAddr;


    //
    // Create a socket for the SAP broadcast.
    //
    s = socket( AF_NS, SOCK_DGRAM, NSPROTO_IPX );
    if( s == INVALID_SOCKET )
        {
        return 0;
        }

    memset( &nsAddr, '\0', sizeof(SOCKADDR_IPX) );
    nsAddr.sa_family = AF_NS;
    if(SOCKET_ERROR ==  bind(s, (SOCKADDR *)&nsAddr, sizeof(SOCKADDR_IPX)) )
        {
        closesocket(s);
        return 0;
        }

    //
    // Enable broadcasts.
    //
    bBcst = TRUE;
    if (SOCKET_ERROR ==  setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&bBcst, sizeof(BOOL)))
        {
        closesocket(s);
        return 0;
        }

    //
    // Set the receive timeout.
    //
    Timeout = 2000;
    if (SOCKET_ERROR == setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *) &Timeout, sizeof(Timeout)))
        {
        closesocket(s);
        return 0;
        }

    //
    // Build a SAP query packet.
    //
    sqp.query_type = SAP_NEAREST_QUERY;
    sqp.server_type = FILE_SERVER;

    raddr.sa_family = AF_NS;
    *((unsigned long UNALIGNED *) &raddr.sa_netnum) = 0;
    memset( &raddr.sa_nodenum, 0xff, 6 );
    raddr.sa_socket = SAP_SOCKET;

    //
    // Send the SAP request.
    //
    if (SOCKET_ERROR == sendto( s, (char *) &sqp, sizeof(SQP), 0, (SOCKADDR *) &raddr, sizeof(SOCKADDR_IPX) ))
        {
        closesocket(s);
        return 0;
        }

    //
    // Collate responses.
    //
    nsStatus.ServerCount = 0;
    do
        {
        unsigned length;

irrelevant_packet:

        length = recvfrom(s, (char *) &sip, sizeof(sip), 0, 0, 0);
        if (SOCKET_ERROR == length)
            {
            break;
            }

        //
        // IPX router spec says find nearest responses can contain only one
        // entry.
        //
        if (length != sizeof(sip) - sizeof(sip.entries) + sizeof(SIP_ENTRY))
            {
            goto irrelevant_packet;
            }

        if (sip.response_type != SAP_NEAREST_RESPONSE)
            {
            goto irrelevant_packet;
            }

        if (sip.server_type != FILE_SERVER)
            {
            goto irrelevant_packet;
            }

        nsStatus.nsRemote[nsStatus.ServerCount].sa_family = AF_NS;
        nsStatus.nsRemote[nsStatus.ServerCount].sa_socket = NCP_SOCKET;
        memcpy( &nsStatus.nsRemote[nsStatus.ServerCount].sa_netnum,
                &sip.entries[0].network,
                sizeof(sip.entries[0].network)+sizeof(sip.entries[0].node)
                );
        }
    while ( ++nsStatus.ServerCount < MAX_FILESRVS );

    closesocket(s);
    return nsStatus.ServerCount;
}


BOOL
ConnectToActiveServer(
    )
/****************************************************************************/
/*                                                                          */
/* This function creates a NCP connection between the local workstation     */
/* and the specified file server. It sends the following NCP packets to     */
/* the file server:                                                         */
/*      1. Create Connection                                                */
/*      2. Negotiate Buffer Size                                            */
/*                                                                          */
/* Params:                                                                  */
/*      SOCKADDR_IPX *ipxDest     - server's IPX address                    */
/*                                                                          */
/* Returns:                                                                 */
/*      TRUE    - SUCCEEDED                                                 */
/*      FALSE   - FAILED                                                    */
/*                                                                          */
/****************************************************************************/
{
    SOCKADDR_IPX nsAddr;
    NCPHDR *pnhReq;
    NCPRSP *pnrResp;
    USHORT UNALIGNED *pwBufSize;
    BOOL fSuccess;

    //
    // Build a CREATE_CONNECTION request.
    //
    memset( nsStatus.nhHeader, '\0', sizeof(NCPHDR));

    pnhReq = nsStatus.nhHeader;
    pnhReq->req_type = CREATE_CONN_REQTYPE;
    pnhReq->seq_no = 0;                     /* reset sequence number */
    pnhReq->conn_no_low = 0xFF;             /* no connection yet     */
    pnhReq->conn_no_high = 0xFF;            /* no connection yet     */
    pnhReq->task_no = 0;
    pnhReq->req_code = 0;

    //
    // Send the packet and wait for response.
    //
    fSuccess = FALSE;
    if (SOCKET_ERROR != NcpTransaction(sizeof(NCPHDR)) )
        {
        /* Save our connection number, it is used in all the subsequent */
        /* NCP packets.                                                                                                 */
        pnrResp = (NCPRSP *)nsStatus.RcvBuffer;
        if ( pnrResp->ret_code == 0 )
            {
            nsStatus.nhHeader->conn_no_low = pnrResp->conn_no_low;
            nsStatus.nhHeader->conn_no_high = pnrResp->conn_no_high;

            fSuccess = TRUE;
            }
        }

    return fSuccess;
}


BOOL
DetachFromActiveServer(
    )
/****************************************************************************/
/*                                                                          */
/* This function logs out the bindery object and detaches the workstation   */
/* from the specified file server.                                          */
/*                                                                          */
/* Params:                                                                  */
/*      none
/*                                                                          */
/* Returns:                                                                 */
/*      TRUE       - Always                                                    */
/*                                                                          */
/****************************************************************************/
{
    int iret;

    if (0 == nsStatus.s)
        {
        return TRUE;
        }

    nsStatus.nhHeader->req_type = DESTROY_CONN_REQYPE;
    nsStatus.nhHeader->seq_no++;
    nsStatus.nhHeader->req_code = 0;

    NcpTransaction(sizeof(NCPHDR));

    closesocket( nsStatus.s );
    nsStatus.s = 0;

    return TRUE;
}


USHORT
ReadPropertyValue(
    char *ObjectName,
    USHORT ObjectType,
    char *PropertyName,
    USHORT SegmentNumber,
    UCHAR *PropertyValue,
    UCHAR *MoreSegments,
    UCHAR *PropertyFlags
    )
{
/*++

Routine Description:



Arguments:



Return Value:



--*/

    RVALREQ *pReq;
    RVALRSP *pRsp;
    int iRet;

    if ( !nsStatus.s )
        {
        return BINDERY_FAILURE;
        }

    /* Build a SCAN_BINDERY request */
    pReq = (RVALREQ *) nsStatus.nhHeader;
    pReq->hdr.seq_no++;
    pReq->hdr.req_code = NCP_SCAN_BINDERY;
    pReq->hdr.req_type = GENERAL_REQTYPE;
    pReq->func_code = READ_PROP_VALUE_FUNC;
    pReq->length = SWAP(RVALSIZE);

    pReq->obj_type = SWAP(ObjectType);
    memset( pReq->obj_name, '\0', sizeof(pReq->obj_name));
    strcpy((PCHAR)pReq->obj_name+1, ObjectName );
    pReq->obj_name[0] = (UCHAR)(sizeof(pReq->obj_name)-1);
    pReq->seg_no = (UCHAR)SegmentNumber;
    memset( pReq->prop_name, '\0', sizeof(pReq->prop_name));
    strcpy((PCHAR)pReq->prop_name+1, PropertyName );
    pReq->prop_name[0] = (UCHAR)strlen(PropertyName);

    /* Send the request and wait for response */
    iRet = NcpTransaction(sizeof(RVALREQ));

    /* If OK set output parameter values from the response packet */
    if ( iRet != SOCKET_ERROR )
        {
        pRsp = (RVALRSP *) nsStatus.RcvBuffer;
        if ( pRsp->hdr.ret_code == 0 )
            {
            *MoreSegments = pRsp->more_flag;
            *PropertyFlags = pRsp->prop_flags;
            memcpy( PropertyValue, pRsp->prop_value, sizeof(pRsp->prop_value));
            }

        return((USHORT)pRsp->hdr.ret_code);
        }

    return(BINDERY_FAILURE);
}


int
NcpTransaction(
    int iSize
    )
{
/*++

Routine Description:

    Send an NCP request to the active file server and wait for a response.
    Most necessary data has been stored in the nsStatus structure by
    the caller.

Arguments:

    iSize - size of buffer to send.

Return Value:

    SOCKET_ERROR if the fn failed,
    anything else if successful

--*/

    NCPRSP * pRsp;
    SOCKADDR_IPX SockAddr;
    int SockAddrLength;
    int Bytes;
    int Attempts = 0;

    /* Send the packet and retry three times if the response doesn't */
    /* arrive within the specified timeout                           */

    SockAddrLength = sizeof(SOCKADDR_IPX);
    pRsp = (NCPRSP *) nsStatus.RcvBuffer;

    do
        {
        if (SOCKET_ERROR == sendto( nsStatus.s,
                                    (char *) nsStatus.nhHeader,
                                    iSize,
                                    0,
                                    (SOCKADDR *) &nsStatus.nsRemote[nsStatus.ActiveServer],
                                    sizeof(SOCKADDR_IPX)
                                    ))
            {
            return SOCKET_ERROR;
            }

irrelevant_packet:

        Bytes = recvfrom( nsStatus.s,
                         nsStatus.RcvBuffer,
                         BUFFER_SIZE,
                         0,
                         (SOCKADDR *) &SockAddr,
                         &SockAddrLength
                         );

        //
        // If we get a packet, compare the source address and sequence #.
        // We also compare the connection number except on the initial
        // connection request.
        //
        if (Bytes != SOCKET_ERROR)
            {
            if (0 != memcmp(SockAddr.sa_nodenum,
                            nsStatus.nsRemote[nsStatus.ActiveServer].sa_nodenum,
                            6))
                {
                goto irrelevant_packet;
                }

            if (0 != memcmp(SockAddr.sa_netnum,
                            nsStatus.nsRemote[nsStatus.ActiveServer].sa_netnum,
                            4))
                {
                goto irrelevant_packet;
                }

            if (nsStatus.nhHeader->req_type != CREATE_CONN_REQTYPE)
                {
                if (pRsp->conn_no_low != nsStatus.nhHeader->conn_no_low ||
                    pRsp->conn_no_high != nsStatus.nhHeader->conn_no_high)
                    {
                    goto irrelevant_packet;
                    }
                }

            if (pRsp->seq_no != nsStatus.nhHeader->seq_no )
                {
                goto irrelevant_packet;
                }
            }
        }
    while ( Bytes == SOCKET_ERROR && WSAGetLastError() == WSAETIMEDOUT && ++Attempts < 3 );

    return Bytes;
}


CRITICAL_SECTION_WRAPPER FileServerMutex;

BOOL fCsnwCheckCompleted  = FALSE;
BOOL fCsnwInstalled       = FALSE;

DWORD
GetCsnwStatus(
    LPSERVICE_STATUS pServiceStatus
    )
{
    SC_HANDLE ServiceController;
    SC_HANDLE Csnw;
    DWORD status;

    ServiceController = OpenSCManager (NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (NULL == ServiceController)
        {
        return GetLastError();
        }

    Csnw = OpenService(ServiceController, L"NWCWorkstation", SERVICE_QUERY_STATUS);
    
    status = GetLastError();

    CloseServiceHandle(ServiceController);

    if (NULL == Csnw)
        {
        return(status);
        }

    if (FALSE == QueryServiceStatus(Csnw, pServiceStatus))
        {
        status = GetLastError();
        }
    else
        {
        status = 0;
        }

    CloseServiceHandle(Csnw);

    return status;
}


void
CheckForCsnw(
    )
/*++

Routine Description:

   Asks the service controller whether Client Services for Netware is installed.

Arguments:

    none

Return Value:

    no explicit return value

    updates fKnowCsnwInstallState and fCsnwInstalled

--*/

{
    DWORD Status;
    SERVICE_STATUS ServiceStatus;

    Status = GetCsnwStatus(&ServiceStatus);

    if (Status && Status != ERROR_SERVICE_DOES_NOT_EXIST)
        {
        return;
        }

    if (!Status)
        {
        if (ServiceStatus.dwCurrentState == SERVICE_RUNNING          ||
            ServiceStatus.dwCurrentState == SERVICE_START_PENDING    ||
            ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING )
            {
            fCsnwInstalled = TRUE;
            }
        }

    fCsnwCheckCompleted  = TRUE;
}


struct
{
    PCHAR        Name;
    SOCKADDR_IPX Address;
    unsigned     Time;
}
ServerCache[CACHE_SIZE];

CRITICAL_SECTION_WRAPPER CacheMutex;

RPC_STATUS
InitializeIpxNameCache(
    )
{
    static BOOL fInitialized = FALSE;

    if (fInitialized)
        {
        return(RPC_S_OK);
        }

    RPC_STATUS Status;
    PVOID Buffer0, Buffer1;

    Buffer0 = I_RpcAllocate(1024);
    if (Buffer0 == NULL)
        return(RPC_S_OUT_OF_MEMORY);

    Buffer1 = I_RpcAllocate(1024);
    if (Buffer1 == NULL)
        {
        I_RpcFree(Buffer0);
        return(RPC_S_OUT_OF_MEMORY);
        }

    Status = InitializeCriticalSectionWrapper(&CacheMutex);

    if (!Status)
        {
        Status = InitializeCriticalSectionWrapper(&FileServerMutex);

        if (Status)
            {
            DeleteCriticalSectionWrapper(&CacheMutex);
            }
        }

    if (Status)
        {
        I_RpcFree(Buffer0);
        I_RpcFree(Buffer1);
        return(Status);
        }

    nsStatus.nhHeader = (NCPHDR *)Buffer0;
    nsStatus.RcvBuffer = (PCHAR) Buffer1;
    
    ASSERT(nsStatus.ServerCount == 0);
    ASSERT(nsStatus.s == 0);

    ASSERT(!fInitialized);
    fInitialized = TRUE;

    return Status;
}


RPC_STATUS
AddServerToCache(
    IN char  * Name,
    IN SOCKADDR_IPX * Address
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return Status;
        }

    //
    // Check if the name is already in the cache, we might be re-resolving
    // the name or another thread might have put the name in the cache
    // since we last checked.
    //
    for (i=0; i < CACHE_SIZE; ++i)
        {
        if (     ServerCache[i].Name &&
            0 == RpcpStringCompareA(ServerCache[i].Name, Name))
            {
            // Check if entry already matches our address.
            if (   memcmp(Address->sa_netnum, ServerCache[i].Address.sa_netnum, 4)
                || memcmp(Address->sa_nodenum, ServerCache[i].Address.sa_nodenum, 6))
                {
                // New information, update cache.
                memcpy(&ServerCache[i].Address, Address, sizeof(SOCKADDR_IPX));
                Status = RPC_S_OK;
                }
            else
                {
                Status = RPC_P_MATCHED_CACHE;
                }
            LeaveCriticalSectionWrapper(&CacheMutex);
            return(Status);
            }
        }

    //
    // If it is not in the table, try to find an empty entry to fill.
    //
    if (i == CACHE_SIZE)
        {
        for (i=0; i < CACHE_SIZE; ++i)
            {
            if (ServerCache[i].Name == 0)
                {
                break;
                }
            }
        }

    //
    // If all entries are full, overwrite the oldest one.
    //
    if (i == CACHE_SIZE)
        {
        unsigned BestIndex = 0;
        LONG now = GetTickCount();
        LONG BestDiff = now - ServerCache[0].Time;

        ASSERT(CACHE_SIZE > 1);

        for (i = 1; i < CACHE_SIZE; ++i)
            {
            LONG diff = now - ServerCache[i].Time;
            if (diff > BestDiff)
                {
                BestIndex = i;
                BestDiff = diff;
                }
            }

        i = BestIndex;
        }

    //
    // Update the entry's information.
    //

    ASSERT(strlen(Name) <= IPX_MAXIMUM_PRETTY_NAME);

    if (NULL == ServerCache[i].Name)
        {
        ServerCache[i].Name = new CHAR[IPX_MAXIMUM_PRETTY_NAME + 1];
        }

    if (ServerCache[i].Name)
        {
        strcpy(ServerCache[i].Name, Name);
        memcpy(&ServerCache[i].Address, Address, sizeof(SOCKADDR_IPX));

        ServerCache[i].Time = GetTickCount();

        Status = RPC_S_OK;
        }
    else
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    LeaveCriticalSectionWrapper(&CacheMutex);

    return (Status);
}


BOOL
FindServerInCache(
    char  * Name,
    SOCKADDR_IPX * Address,
    unsigned * Time
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return FALSE;
        }

    for (i = 0; i < CACHE_SIZE; ++i)
        {
        if (   ServerCache[i].Name 
            && (0 == RpcpStringCompareA(ServerCache[i].Name, Name)) )
            {
            memcpy(Address, &ServerCache[i].Address, sizeof(SOCKADDR_IPX));
            *Time = ServerCache[i].Time;

            LeaveCriticalSectionWrapper(&CacheMutex);

            return TRUE;
            }
        }

    LeaveCriticalSectionWrapper(&CacheMutex);

    return FALSE;
}


BOOL
CachedServerNotContacted(
    char  * Name
    )
{
    unsigned i;
    BOOL Flushed = FALSE;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return Flushed;
        }

    for (i=0; i < CACHE_SIZE; ++i)
        {
        if (   ServerCache[i].Name
            && 0 == RpcpStringCompareA(ServerCache[i].Name, Name))
            {
            if (GetTickCount() - ServerCache[i].Time > CACHE_EXPIRATION_TIME)
                {
                delete ServerCache[i].Name;
                ServerCache[i].Name = 0;
                Flushed = TRUE;
                }

            break;
            }
        }

    LeaveCriticalSectionWrapper(&CacheMutex);

    return Flushed;
}

void
CachedServerContacted(
    char  * Name
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return;
        }

    for (i=0; i < CACHE_SIZE; ++i)
        {
        if (   ServerCache[i].Name
            && 0 == RpcpStringCompareA(ServerCache[i].Name, Name))
            {
            ServerCache[i].Time = GetTickCount();
            break;
            }
        }

    LeaveCriticalSectionWrapper(&CacheMutex);
}


RPC_STATUS
LookupViaRnr(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    CSADDR_BUFFER csaddr[2];
    int           num;
    INT           protocol_list[2];
    DWORD         csaddr_size = sizeof(csaddr);

    protocol_list[0] = NSPROTO_IPX ;
    protocol_list[1] = 0;
    num = GetAddressByNameA(NS_SAP,
                            (GUID *)&SERVICE_TYPE,
                            Name,
                            protocol_list,
                            0,
                            FALSE,
                            &csaddr,
                            &csaddr_size,
                            NULL,
                            0);
    if (num <= 0)
        {
        return RPC_S_SERVER_UNAVAILABLE;
        }

    memcpy( Address, csaddr[0].info.RemoteAddr.lpSockaddr, sizeof(SOCKADDR_IPX) );
    
    return(AddServerToCache(Name, Address));
}


RPC_STATUS
LookupViaBindery(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    USHORT      Connection;
    USHORT      NwStatus;
    UCHAR       MoreSegments;
    UCHAR       PropertyFlags;
    UCHAR       buffer[128];

    RPC_STATUS  Status;

    Status = EnterCriticalSectionWrapper(&FileServerMutex);
    if (Status)
        {
        return Status;
        }

    //
    // Find a Netware server and connect to it.
    //
    if (FALSE == AttachToFileServer())
        {
        LeaveCriticalSectionWrapper(&FileServerMutex);

        return RPC_S_SERVER_UNAVAILABLE;
        }

    //
    // Read from the bindery.
    //
    NwStatus = ReadPropertyValue( Name,
                                  RPC_SAP_TYPE,
                                  "NET_ADDRESS",
                                  1,
                                  buffer,
                                  &MoreSegments,
                                  &PropertyFlags
                                  );

    //
    // Disconnect from the file server.
    //
    DetachFromActiveServer();

    LeaveCriticalSectionWrapper(&FileServerMutex);

    if (!NwStatus)
        {
        memcpy(&Address->sa_netnum, buffer, 12);
        return(AddServerToCache(Name, Address));
        }

    return RPC_S_SERVER_UNAVAILABLE;
}


RPC_STATUS
IpxNameToAddress(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    RPC_STATUS Status = RPC_S_OK;

    Status = EnterCriticalSectionWrapper(&FileServerMutex);
    if (Status)
        {
        return Status;
        }

    if (!fCsnwCheckCompleted)
        {
        CheckForCsnw();
        }

    LeaveCriticalSectionWrapper(&FileServerMutex);

    if (fCsnwInstalled)
        {
        Status = LookupViaRnr(Name, Address, Timeout);
        }
    else
        {
        Status = LookupViaBindery(Name, Address, Timeout);
        if (   Status != RPC_S_OK
            && Status != RPC_P_MATCHED_CACHE)
            {
            Status = LookupViaRnr(Name, Address, Timeout);
            }
        }

    return Status;
}

void IPX_AddressToName(
   IN SOCKADDR_IPX *pAddr,
   OUT RPC_CHAR *pName
)
/*++

Routine Description:

    Converts a raw IPX address into the string address format used
    by RPC.
    
    ~NNNNNNNNAAAAAAAAAAAA
    N - network number in hex
    A - network address (IEEE 802) in hex

Arguments:

    pAddr - The sockaddr containing the address to convert
    pName - Will contain the string address on return, assumed
        to be IPX_MAXIMUM_RAW_NAME characters.

Return Value:

    None

--*/
{
    int i;

    *pName++ = '~';
    for (i = 0; i < sizeof(pAddr->sa_netnum); i++)
        {
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_netnum[i]) >> 4 ];
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_netnum[i]) & 0x0F ];
        }
    for (i = 0; i < sizeof(pAddr->sa_nodenum); i++)
        {
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_nodenum[i]) >> 4 ];
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_nodenum[i]) & 0x0F ];
        }
    *pName = 0;
}


RPC_STATUS
IPX_NameToAddress(
    RPC_CHAR *Name,
    BOOL fUseCache,
    OUT SOCKADDR_IPX *pAddr
    )
/*++

Routine Description:

    Converts a name into an IPX address if possible.  Handles the
    case of ~ names and pretty names.

Arguments:

    Name - The name to convert
    fUseCache - Usually TRUE, if which case a value cached from
        a previous call with the same name maybe used.  If FALSE,
        then full name resolution must be used.
    pAddr - Will overwrite the sa_netnum and sa_nodenum with the
        IPX address if successful.

Return Value:

    RPC_S_OK - Full lookup, completed ok.
    RPC_S_FOUND_IN_CACHE - Lookup completed and found in cache.
    RPC_S_MATCHED_CACHE - Full lookup required (fUseCache == FALSE) but
        results didn't change.
        
    RPC_S_SERVER_UNAVAILABLE - Lookup failed.
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    int length;

    ASSERT(pAddr->sa_family == AF_IPX);
    ASSERT(pAddr->sa_socket == 0);

    //
    // First see if the address is local.
    //
    if (Name == 0 || *Name == 0)
        {
        //
        // Use the cached local address, if valid.
        //
        if (fIpxAddrValid == TRUE)
            {
            memcpy(pAddr->sa_netnum, IpxAddr.sa_netnum, 4);
            memcpy(pAddr->sa_nodenum, IpxAddr.sa_nodenum, 6);
            return(RPC_S_OK);
            }

        //
        // Figure out the loopback address, not a easy task on IPX.
        //

        SOCKET sock;
        sock = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
        if (sock == INVALID_SOCKET)
            {
            //
            switch(GetLastError())
                {
                case WSAEAFNOSUPPORT:
                case WSAEPROTONOSUPPORT:
                    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
                    break;

                case WSAENOBUFS:
                case WSAEMFILE:
                    return(RPC_S_OUT_OF_MEMORY);
                    break;

                default:    
                    ASSERT(0);
                    return(RPC_S_OUT_OF_MEMORY);
                    break;
                }
            }

        // zero-out the netnum and nodenum members
        memset(pAddr->sa_netnum, 0, sizeof(pAddr->sa_netnum));
        memset(pAddr->sa_nodenum, 0, sizeof(pAddr->sa_nodenum));

        if ( bind(sock, (PSOCKADDR)pAddr, sizeof(SOCKADDR_IPX)) == SOCKET_ERROR)
            {
            closesocket(sock);
            return(RPC_S_OUT_OF_RESOURCES);
            }
        int len = sizeof(SOCKADDR_IPX);
        if ( getsockname(sock, (PSOCKADDR)pAddr, &len) == SOCKET_ERROR)
            {
            closesocket(sock);
            return(RPC_S_OUT_OF_RESOURCES);
            }

        // Update cache
        memcpy(IpxAddr.sa_netnum, pAddr->sa_netnum, sizeof(IpxAddr.sa_netnum));
        memcpy(IpxAddr.sa_nodenum, pAddr->sa_nodenum, sizeof(IpxAddr.sa_nodenum));
        fIpxAddrValid = TRUE;

        closesocket(sock);

        return(RPC_S_OK);
        }

    //
    // Must resolve the name, validate and convert to ansi.
    //
    length = RpcpStringLength(Name) + 1;

    if (length > IPX_MAXIMUM_PRETTY_NAME)
        {
        return(RPC_S_SERVER_UNAVAILABLE);
        }

    if (   *Name == RPC_T('~')
        && length != IPX_MAXIMUM_RAW_NAME)
        {
        return(RPC_S_SERVER_UNAVAILABLE);
        }


    CHAR AnsiName[IPX_MAXIMUM_PRETTY_NAME + 1];
    RpcpMemorySet(&(AnsiName[0]), 0x00, IPX_MAXIMUM_PRETTY_NAME + 1);
    PlatformToAnsi(Name, AnsiName);

    //
    // If the name starts with ~, convert it directly to a network address.
    //
    if (AnsiName[0] == '~')
        {

        ASSERT(Name[0] == RPC_T('~'));

        int i;
        PCHAR p = AnsiName;


        p++; // Skip ~

        for (i = 0; i < 4; i++)
            {
            pAddr->sa_netnum[i] = HexDigitsToBinary(*p, *(p+1));
            p += 2;
            }
        for (i = 0; i < 6; i++)
            {
            pAddr->sa_nodenum[i] = HexDigitsToBinary(*p, *(p+1));
            p += 2;
            }

        if (fUseCache)
            {
            return(RPC_S_OK);
            }
        else
            {
            return(RPC_P_MATCHED_CACHE);
            }
        }

    if (fUseCache)
        {
        UINT t = 0;
        //
        // Look up the server in the name cache.
        //
        if (FindServerInCache(AnsiName, pAddr, &t))
            {
            return(RPC_P_FOUND_IN_CACHE);
            }
        }

    //
    // Gotta go look for it.
    //

    RPC_STATUS status = IpxNameToAddress(AnsiName, pAddr, 0);

    if (   (status == RPC_P_MATCHED_CACHE)
        && fUseCache)
        {
        // Race - another thread added the name to the cache
        // while we did the lookup.
        return(RPC_S_OK);
        }

    return(status);
}

BOOL         fIpxAddrValid = FALSE;
SOCKADDR_IPX IpxAddr;    

RPC_STATUS
IPX_BuildAddressVector(
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    Use by both IPX and SPX RPC servers to build the network
    address structure to be returned to the RPC runtime.
    Before calling this the caller must make sure the global
    fIpxAddrValid is TRUE.

Arguments:

    ppAddressVector - The place to store the constructed address
        vector.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + gdwComputerNameLength * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (NULL == pVector)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR*)&pVector->NetworkAddresses[1];
    RpcpStringCopy(pVector->NetworkAddresses[0], gpstrComputerName);

    *ppAddressVector = pVector;

    return(RPC_S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\httpreg.cxx ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  httpreg.c
//
//    HTTP/RPC protocol specific functions.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#define  FD_SETSIZE  1

#include <precomp.hxx>


//-------------------------------------------------------------------------
//  HttpParseServerPort()
//
//  Parse strings of the form:  <svr>[:<port>]
//-------------------------------------------------------------------------
static BOOL HttpParseServerPort( IN  char *pszServerPort,
                                 IN  char *pszDefaultPort,
                                 OUT char *pszServer,
                                 OUT char *pszPort  )
{
   char *psz;
   char *pszColon;
   char *CurrentPosition;
   char ch;

   if (pszColon=strchr(pszServerPort,':'))
      {
      *pszColon = 0;
      psz = pszColon;
      psz++;
      strcpy(pszServer,pszServerPort);
      *pszColon = ':';
      if (*psz)
         {
         // take the string until the end or until a space which
         // indicates another entry (probably for another protocol).
         CurrentPosition = psz;
         while (*CurrentPosition && (*CurrentPosition != ' '))
             CurrentPosition ++;
         ch = *CurrentPosition;
         *CurrentPosition = 0;
         strcpy(pszPort,psz);
         *CurrentPosition = ch;
         }
      else
         {
         strcpy(pszPort,pszDefaultPort);
         }
      }
   else
      {
      strcpy(pszServer,pszServerPort);
      strcpy(pszPort,pszDefaultPort);
      }

   return TRUE;
}

//-------------------------------------------------------------------------
//  HttpParseProxyName()
//
//-------------------------------------------------------------------------

const char *HttpProxyPrefix = "http://";
const int HttpProxyPrefixSize = sizeof("http://") - 1;

BOOL HttpParseProxyName( IN  char *pszProxyList,
                         IN BOOL UseSSLProxyPortAsDefault,
                         OUT char *pszHttpProxy,
                         OUT char *pszHttpProxyPort )
{
   BOOL  fStatus;
   char *psz;
   char *pszSemiColon;
   int StringLength;
   char *ProtocolType;
   char *DefaultPort;

   strcpy(pszHttpProxy,"");
   strcpy(pszHttpProxyPort,"");

   // Check for no configured proxy:
   if ((!pszProxyList)||(!*pszProxyList))
      {
      return TRUE;
      }

   // if the string is large enough to contain the prefix, check
   // whether it has a prefix
   StringLength = strlen(pszProxyList);
   if (StringLength >= HttpProxyPrefixSize)
       {
       if (RpcpStringNCompareA(pszProxyList, HttpProxyPrefix, HttpProxyPrefixSize) == 0)
           pszProxyList += HttpProxyPrefixSize;
       }

   if (!strstr(pszProxyList,EQUALS_STR))
      {
      return HttpParseServerPort(pszProxyList,DEF_HTTP_PORT,pszHttpProxy,pszHttpProxyPort);
      }

   if (UseSSLProxyPortAsDefault)
       {
       ProtocolType = HTTPS_EQUALS_STR;
       DefaultPort = DEF_HTTP_SSL_PORT;
       }
   else
       {
       ProtocolType = HTTP_EQUALS_STR;
       DefaultPort = DEF_HTTP_PORT;
       }

   if (psz=strstr(pszProxyList,ProtocolType))
      {
      psz += strlen(ProtocolType);
      if (pszSemiColon=strstr(psz,SEMICOLON_STR))
         {
         *pszSemiColon = 0;
         fStatus = HttpParseServerPort(psz,DefaultPort,pszHttpProxy,pszHttpProxyPort);
         *pszSemiColon = CHAR_SEMICOLON;
         return fStatus;
         }
      else
         {
         return HttpParseServerPort(psz,DefaultPort,pszHttpProxy,pszHttpProxyPort);
         }
      }
   else
      {
      return TRUE;
      }
}

//-------------------------------------------------------------------------
//  HttpFreeProxyOverrideList()
//
//-------------------------------------------------------------------------
static void HttpFreeProxyOverrideList( IN char **ppszOverrideList )
{
   char **ppszTmp = ppszOverrideList;

   if (ppszOverrideList)
      {
      while (*ppszTmp)
         {
         I_RpcFree(*ppszTmp);
         ppszTmp++;
         }

      I_RpcFree(ppszOverrideList);
      }
}

//-------------------------------------------------------------------------
//  HttpParseProxyOverrideList()
//
//-------------------------------------------------------------------------
static char **HttpParseProxyOverrideList( IN char *pszProxyOverrideList )
{
   int    i;
   int    iLen;
   int    count = 1;
   DWORD  dwSize = 1+strlen(pszProxyOverrideList);
   char  *pszList;
   char  *psz;
   char **ppszPatternList;

   if (!dwSize)
      {
      return NULL;
      }

   // Make a local copy of the pattern list, to work with:
   pszList = (char *) alloca(dwSize);

   strcpy(pszList,pszProxyOverrideList);

   // See how many separate patterns ther are in the override list:
   //
   // NOTE: That count may be too high, if either the list contains
   //       double semicolons or the list ends with a semicolon. If
   //       either/both of these happen that's Ok.
   psz = pszList;
   while (psz=strstr(psz,";"))
      {
      count++;
      psz++;
      }

   ppszPatternList = (char**)RpcpFarAllocate( (1+count)*sizeof(char*) );
   if (!ppszPatternList)
      {
      // Out of memory.
      return NULL;
      }

   memset(ppszPatternList,0,(1+count)*sizeof(char*));

   i = 0;
   while (i<count)
      {
      if (!*pszList)
         {
         // End of list. This happens when the list contained empty
         // patterns.
         break;
         }

      psz = strstr(pszList,";");
      if (psz)
         {
         *psz = 0;

         if ( (iLen=strlen(pszList)) == 0)
            {
            // Zero length pattern.
            pszList = ++psz;
            continue;
            }

         ppszPatternList[i] = (char*)RpcpFarAllocate(1+iLen);
         if (!ppszPatternList[i])
            {
            HttpFreeProxyOverrideList(ppszPatternList);
            return NULL;
            }
         strcpy(ppszPatternList[i++],pszList);
         pszList = ++psz;
         }
      else
         {
         ppszPatternList[i] = (char*)RpcpFarAllocate(1+strlen(pszList));
         if (!ppszPatternList[i])
            {
            HttpFreeProxyOverrideList(ppszPatternList);
            return NULL;
            }
         strcpy(ppszPatternList[i++],pszList);
         }
      }

   return ppszPatternList;
}

//-------------------------------------------------------------------------
//  HttpCheckRegistry()
//
//  With IE and WinInet you can setup a list of proxies to use to go through
//  with an HTTP (or other) internet request. We need to support this as
//  well. There are three registry entries of interest, which are located
//  at:
//
//  \HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings
//
//  They are:
//
//  ProxyEnable: REG_BINARY
//     A flag (TRUE/FALSE) to enable/disable proxies.
//
//  ProxyServer: REG_SZ
//     On of: an empty string (no proxy specified), a single proxy server
//     name (for any format), or a list of proxy servers to use by format.
//     The list is of the form:
//
//     ftp=<svr:port>,gopher=<svr:port>,http=<svr:port>,...
//
//     Note that not all protocols need to be in the list. And the port#
//     does not need to be specifed. If not present then default the port#
//     to the default for that internet protocol (scheme).
//
//  ProxyOverride: REG_SZ
//     A semicolon separated list of server names, internet addresses or
//     patterns which, if specified are used to denote machines that you
//     want to directly access, without using the proxy server. Examples
//     would be:
//
//     12.34.56.78;MySvr*;111.222.*;*green*
//
//-------------------------------------------------------------------------
BOOL HttpCheckRegistry( IN  char  *pszServer,
                        IN BOOL UseSSLProxyPortAsDefault,
                        OUT char **ppszHttpProxy,
                        OUT char **ppszHttpProxyPort,
                        OUT RPCProxyAccessType *AccessType
                        )
{
   int    i;
   long   lStatus;
   DWORD  dwType;
   DWORD  dwEnabled;
   DWORD  dwSize;
   HKEY   hKey;
   HKEY   hUserKey;
   char   szProxyList[256];
   char   szProxyOverrideList[256];
   char   szHttpProxy[MAX_HTTP_COMPUTERNAME_SIZE];
   char   szHttpProxyPort[MAX_HTTP_PORTSTRING_SIZE];
   char  *pszDotServer;
   char **ppszOverrideList;
   struct hostent UNALIGNED *pHostEnt;
   struct in_addr   ServerInAddr;
   BOOL LocalDirect;

   *ppszHttpProxy = NULL;
   *ppszHttpProxyPort = NULL;
   *AccessType = rpcpatDirect;

   lStatus = RegOpenCurrentUser( KEY_READ, &hUserKey );

   if (lStatus != ERROR_SUCCESS)
      {
      return TRUE;
      }

    lStatus = RegOpenKeyEx( hUserKey,
                            REG_PROXY_PATH_STR,
                            0,
                            KEY_READ,
                            &hKey );

    RegCloseKey(hUserKey);

    if (lStatus != ERROR_SUCCESS)
        {
        return TRUE;
        }

   dwSize = sizeof(dwEnabled);
   lStatus = RegQueryValueEx(
                 hKey,
                 REG_PROXY_ENABLE_STR,
                 0,
                 &dwType,
                 (LPBYTE)&dwEnabled,
                 &dwSize
                 );
   if (lStatus != ERROR_SUCCESS)
      {
      RegCloseKey(hKey);
      return TRUE;
      }

#ifdef DBG_REGISTRY
   if (dwType == REG_BINARY)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     "HttpCheckRegistry(): Proxy Enabled: %s\n",
                     (dwEnabled)? "TRUE" : "FALSE"));
      }
#endif // DBG_REGISTRY

   if (!dwEnabled)
      {
      // IE proxies are disabled, no need to go on.
      RegCloseKey(hKey);
      return TRUE;
      }

   dwSize = sizeof(szProxyList);
   lStatus = RegQueryValueExA(  // Needs to be ANSI
                 hKey,
                 REG_PROXY_SERVER_STR,
                 0,
                 &dwType,
                 (LPBYTE)szProxyList,
                 &dwSize
                 );
   if (lStatus != ERROR_SUCCESS)
      {
      RegCloseKey(hKey);
      return TRUE;
      }

#ifdef DBG_REGISTRY
   if (dwType == REG_SZ)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     "HttpCheckRegistry(): Proxy List: %s\n",
                     szProxyList));
      }
#endif // DBG_REGISTRY

   if (!HttpParseProxyName(szProxyList, UseSSLProxyPortAsDefault, szHttpProxy,szHttpProxyPort))
      {
      RegCloseKey(hKey);
      return TRUE;
      }

   dwSize = sizeof(szProxyOverrideList);
   lStatus = RegQueryValueExA(  // Needs to be ANSI
                 hKey,
                 REG_PROXY_OVERRIDE_STR,
                 0,
                 &dwType,
                 (LPBYTE)szProxyOverrideList,
                 &dwSize
                 );
   if (lStatus != ERROR_SUCCESS)
      {
      // Don't quit if the ProxyOverride entry is missing, that's Ok...
      szProxyOverrideList[0] = 0;
      }

#ifdef DBG_REGISTRY
   if (dwType == REG_SZ)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     "HttpCheckRegistry(): Proxy Override List: %s\n",
                     szProxyOverrideList));
      }
#endif // DBG_REGISTRY

   RegCloseKey(hKey);

   ppszOverrideList = HttpParseProxyOverrideList(szProxyOverrideList);

   if (ppszOverrideList)
      {
      LocalDirect = MatchExactList(
                           (unsigned char *) LOCAL_ADDRESSES_STR,
                           (unsigned char **) ppszOverrideList
                           );

      if (!LocalDirect)
          *AccessType = rpcpatHTTPProxy;
      else
          {
          // we don't know. <local> is in the list of overrides,
          // but we don't know whether the server is local
          *AccessType = rpcpatUnknown;
          }

      // Check the server name to see if it's in the override list:
      if (MatchREList(
             (unsigned char *) pszServer,
             (unsigned char **) ppszOverrideList
             ))
         {
         // The server name is in the override list.
         HttpFreeProxyOverrideList(ppszOverrideList);
         *AccessType = rpcpatDirect;
         return TRUE;
         }

      // Convert the server name to dot notation and see if its in
      // the override list:
      pHostEnt = gethostbyname(pszServer);
      if (pHostEnt)
         {
         // Note that the server may actually have several addresses in
         // a (NULL terminated) array. Need to check each one...
         i = 0;
         while (pHostEnt->h_addr_list[i])
            {
            memcpy(&ServerInAddr,pHostEnt->h_addr_list[i++],pHostEnt->h_length);
            pszDotServer = inet_ntoa(ServerInAddr);
#ifdef DBG_REGISTRY
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           "HttpCheckRegistry(): Server: %s  Address: %s\n",
                           pszServer,
                           pszDotServer));
#endif // DBG_REGISTRY
            if (   (pszDotServer)
                && MatchREList(
                       (unsigned char *) pszDotServer,
                       (unsigned char **) ppszOverrideList
                       ) )
               {
               // The server name (in dot notation) is in the override list.
               HttpFreeProxyOverrideList(ppszOverrideList);
               *AccessType = rpcpatDirect;
               return TRUE;
               }
            }
         }

      HttpFreeProxyOverrideList(ppszOverrideList);
      }


   *ppszHttpProxy = (char *)RpcpFarAllocate(1+strlen(szHttpProxy));
   if (!*ppszHttpProxy)
      {
      return FALSE;
      }

   strcpy(*ppszHttpProxy,szHttpProxy);

   *ppszHttpProxyPort = (char*)RpcpFarAllocate(1+strlen(szHttpProxyPort));
   if (!*ppszHttpProxyPort)
      {
      I_RpcFree(*ppszHttpProxy);
      *ppszHttpProxy = NULL;
      return FALSE;
      }

   strcpy(*ppszHttpProxyPort,szHttpProxyPort);

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\mq.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    mq.cxx

Abstract:

    This is the code that actually makes Falcon API calls. It is
    used by the Falcon/RPC transport (mqtrans.cxx)

Author:

    Edward Reus (edwardr)    05-Jul-1997

Revision History:

--*/

#include <precomp.hxx>
#include <trans.hxx>
#include <dgtrans.hxx>
#include <wswrap.hxx>
#include <rpc.h>
#include <rpcdce.h>
#include <mqmgr.h>
#include "mqtrans.hxx"

static HINSTANCE   g_hMqRt = 0;
FALCON_API *g_pMqApi = 0;
static CQueueMap  *g_pQueueMap = 0;

char placeHolder[sizeof(MUTEX)];    // provide placeholder for the mutex
MUTEX *gp_csContext = (MUTEX *)placeHolder;    // the mutex itself

#ifdef UNICODE
#define ptszVal     pwszVal
#define VT_LPTSTR   VT_LPWSTR
#else
#define ptszVal     pszVal
#define VT_LPTSTR   VT_LPSTR
#endif

static PCONTEXT_HANDLE       g_pContext = 0;

//  WARNING: the size and ordering of g_arszMqApis is dependent
//  on the definition of the FALCON_API structure in mqtrans.hxx
//  WARNING: When you are freeing Falcon allocated strings, do
//  *not* use MQFreeMemory. Use MQFreeStringFromProperty. Otherwise
//  you will break Win98 code.

const static char *g_arszMqApis[] = {
                                    "MQLocateBegin",
                                    "MQLocateNext",
                                    "MQLocateEnd",
                                    "MQInstanceToFormatName",
                                    "MQOpenQueue",
                                    "MQFreeMemory",
                                    "MQSendMessage",
                                    "MQReceiveMessage",
                                    "MQCloseQueue",
                                    "MQDeleteQueue",
                                    "MQPathNameToFormatName",
                                    "MQCreateQueue",
                                    "MQGetMachineProperties",
                                    "MQGetQueueProperties",
                                    "MQSetQueueProperties",
                                    NULL };

//  Error mappings for MQ_MapStatusCode():

typedef struct _STATUS_MAPPING
   {
   HRESULT    hr;
   RPC_STATUS status;
   } STATUS_MAPPING;

const static STATUS_MAPPING g_StatusMap[] =
   {
      { MQ_OK,                            RPC_S_OK },
      { MQ_ERROR_IO_TIMEOUT,              RPC_P_TIMEOUT },
      { MQ_ERROR_INSUFFICIENT_RESOURCES,  RPC_S_OUT_OF_MEMORY },
      { MQ_ERROR_QUEUE_NOT_FOUND,         RPC_S_SERVER_UNAVAILABLE },
      { MQ_ERROR,                         RPC_S_INTERNAL_ERROR },
      { MQMSG_CLASS_NACK_BAD_DST_Q,       RPC_S_SERVER_UNAVAILABLE },
      { MQMSG_CLASS_NACK_PURGED,          RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_Q_EXCEED_QUOTA,  RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_ACCESS_DENIED,   RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED,  RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_BAD_SIGNATURE,   RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_BAD_ENCRYPTION,  RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT,   RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q, RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG,RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_Q_DELETED,       RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_Q_PURGED,        RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_RECEIVE_TIMEOUT, RPC_S_CALL_FAILED_DNE },
      { MQ_ERROR_ILLEGAL_QUEUE_PATHNAME,  RPC_S_INVALID_ENDPOINT_FORMAT}
   };


//----------------------------------------------------------------
//  MQ_Initialize()
//
//  Called by DG_TransportLoad() to initialize the ncadg_mq
//  transport. This function does a dynamic load of the Falcon
//  runtime DLL (MQRT.DLL) and creates a call table to access
//  the Falcon API. If successful, return TRUE, else return
//  FALSE.
//----------------------------------------------------------------
BOOL
MQ_Initialize()
{
    BOOL   fStatus = TRUE;
    RPC_STATUS RpcStatus = RPC_S_OK;

    // Make sure the function count is correct...
    ASSERT( sizeof(g_arszMqApis)-sizeof(PVOID) == sizeof(FALCON_API) );

    //
    gp_csContext = new (gp_csContext) MUTEX(&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        return FALSE;
        }

    // Get the MSMQ runtime library:
    g_hMqRt = LoadLibrary(TEXT("mqrt.dll"));
    if (!g_hMqRt)
        {
        fStatus = FALSE;
        }

    // Build up the MSMQ call table that we will use to access
    // the MSMQ C API:
    if (fStatus)
        {
        g_pMqApi = (FALCON_API*)I_RpcAllocate(sizeof(FALCON_API));
        if (!g_pMqApi)
            {
            fStatus = FALSE;
            }
        }

    if (fStatus)
        {
        FARPROC *ppFn = (FARPROC*)g_pMqApi;
        int i = 0;

        while (g_arszMqApis[i])
            {
            *ppFn = GetProcAddress(g_hMqRt,g_arszMqApis[i++]);
            if (!*ppFn)
                {
                fStatus = FALSE;
                break;
                }

            ppFn++;
            }
        }

    if (fStatus)
        {
        g_pQueueMap = new CQueueMap;
        if (!g_pQueueMap)
            {
            fStatus = FALSE;
            }
        else
            {
            fStatus = g_pQueueMap->Initialize();
            }
        }

    if (!fStatus)
        {
        gp_csContext->Free();

        if (g_hMqRt)
            {
            FreeLibrary(g_hMqRt);
            g_hMqRt = 0;
            }

        if (g_pQueueMap)
            {
            delete g_pQueueMap;
            g_pQueueMap = 0;
            }

        if (g_pMqApi)
            {
            I_RpcFree(g_pMqApi);
            g_pMqApi = 0;
            }
        }

    return fStatus;
}

//----------------------------------------------------------------
//  MQ_MapStatusCode()
//
//  Convert a MQ HRESULT status to a RPC_STATUS code.
//----------------------------------------------------------------
RPC_STATUS MQ_MapStatusCode( HRESULT hr, RPC_STATUS defaultStatus )
{
   int         iSize = sizeof(g_StatusMap)/sizeof(STATUS_MAPPING);
   RPC_STATUS  status = defaultStatus;

   for (int i=0; i<iSize; i++)
      {
      if (hr == g_StatusMap[i].hr)
         {
         status = g_StatusMap[i].status;
         break;
         }
      }

   return status;
}

//----------------------------------------------------------------
//  MQ_InitOptions()
//
//  Initialize transport specific binding handle options structure.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_InitOptions( IN void PAPI *pvTransportOptions )
{
  RPC_STATUS  status = RPC_S_OK;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;

  if (pOpts)
     {
     memset(pOpts,0,sizeof(MQ_OPTIONS));
     pOpts->ulPriority = DEFAULT_PRIORITY;
     pOpts->ulTimeToReachQueue = INFINITE;
     pOpts->ulTimeToReceive = INFINITE;
     }
  else
     {
     status = RPC_S_OUT_OF_MEMORY;
     }

  return status;
}


//----------------------------------------------------------------
//  MQ_SetOption()
//
//  Set transport specific binding handle options.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_SetOption( IN void PAPI    *pvTransportOptions,
                                   IN unsigned long option,
                                   IN ULONG_PTR optionValue )
{
  RPC_STATUS  status =  RPC_S_OK;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;

  switch (option)
     {
     case RPC_C_OPT_MQ_DELIVERY:
        if (  (optionValue == RPC_C_MQ_EXPRESS)
           || (optionValue == RPC_C_MQ_RECOVERABLE) )
           pOpts->ulDelivery = (unsigned long) optionValue;
        else
           status = RPC_S_INVALID_ARG;
        break;

     case RPC_C_OPT_MQ_PRIORITY:
        if (optionValue <= MQ_MAX_PRIORITY)
           pOpts->ulPriority = (unsigned long) optionValue;
        else
           pOpts->ulPriority = MQ_MAX_PRIORITY;
        break;

     case RPC_C_OPT_MQ_JOURNAL:
        if (  (optionValue == RPC_C_MQ_JOURNAL_NONE)
           || (optionValue == RPC_C_MQ_JOURNAL_ALWAYS)
           || (optionValue == RPC_C_MQ_JOURNAL_DEADLETTER) )
           pOpts->ulJournaling = (unsigned long) optionValue;
        else
           status = RPC_S_INVALID_ARG;
        break;

     case RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE:
        pOpts->ulTimeToReachQueue = (unsigned long) optionValue;
        break;

     case RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED:
        pOpts->ulTimeToReceive = (unsigned long) optionValue;
        break;

     case RPC_C_OPT_MQ_ACKNOWLEDGE:
        pOpts->fAck = (optionValue != FALSE);
        break;

     case RPC_C_OPT_MQ_AUTHN_SERVICE:
        if (optionValue == RPC_C_AUTHN_MQ)
           {
           status = RPC_S_OK;
           }
        else if (optionValue == RPC_C_AUTHN_NONE)
           {
           pOpts->fAuthenticate = FALSE;
           pOpts->fEncrypt = FALSE;
           status = RPC_S_OK;
           }
        else
           {
           status = RPC_S_UNKNOWN_AUTHN_SERVICE;
           }
        break;

     case RPC_C_OPT_MQ_AUTHN_LEVEL:
        if (optionValue > RPC_C_AUTHN_LEVEL_NONE)
           {
           pOpts->fAuthenticate = TRUE;
           pOpts->fEncrypt = (optionValue == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)? TRUE : FALSE;
           }
        else
           {
           pOpts->fAuthenticate = FALSE;
           pOpts->fEncrypt = FALSE;
           }
        break;

     default:
        status = RPC_S_CANNOT_SUPPORT;
        break;
     }

  // The following is some code to make sure the RPC_C_xxx
  // constants always have the correct values:
  #if  ( (RPC_C_MQ_EXPRESS != MQMSG_DELIVERY_EXPRESS) \
       || (RPC_C_MQ_RECOVERABLE != MQMSG_DELIVERY_RECOVERABLE) )
  #error "RPC constants wrong"
  #endif

  #if (  (RPC_C_MQ_JOURNAL_NONE != MQMSG_JOURNAL_NONE)  \
      || (RPC_C_MQ_JOURNAL_ALWAYS != MQMSG_JOURNAL)     \
      || (RPC_C_MQ_JOURNAL_DEADLETTER != MQMSG_DEADLETTER) )
  #error "RPC constants wrong"
  #endif

  return status;
}


//----------------------------------------------------------------
//  MQ_InqOption()
//
//  Get transport specific binding handle options.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_InqOption( IN  void PAPI     *pvTransportOptions,
                                   IN  unsigned long  option,
                                   OUT ULONG_PTR *pOptionValue )
{
  RPC_STATUS  status =  RPC_S_OK;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;

  switch (option)
     {
     case RPC_C_OPT_MQ_DELIVERY:
        *pOptionValue = pOpts->ulDelivery;
        break;

     case RPC_C_OPT_MQ_PRIORITY:
        *pOptionValue = pOpts->ulPriority;
        break;

     case RPC_C_OPT_MQ_JOURNAL:
        *pOptionValue = pOpts->ulJournaling;
        break;

     case RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE:
        *pOptionValue = pOpts->ulTimeToReachQueue;
        break;

     case RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED:
        *pOptionValue = pOpts->ulTimeToReceive;
        break;

     case RPC_C_OPT_MQ_ACKNOWLEDGE:
        *pOptionValue = pOpts->fAck;
        break;

     default:
        status = RPC_S_INVALID_ARG;
        *pOptionValue = 0;
        break;
     }

  return status;
}



//----------------------------------------------------------------
//  MQ_ImplementOptions()
//
//  Apply transport specific binding handle options to the
//  specified server.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_ImplementOptions(
                         IN DG_TRANSPORT_ENDPOINT pvTransEndpoint,
                         IN void             *pvTransportOptions )
{
  RPC_STATUS  Status =  RPC_S_OK;
  HRESULT     hr;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;
  MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)pvTransEndpoint;

  pEndpoint->fAck     = pOpts->fAck;
  pEndpoint->ulDelivery = pOpts->ulDelivery;
  pEndpoint->ulPriority = pOpts->ulPriority;
  pEndpoint->ulJournaling = pOpts->ulJournaling;
  pEndpoint->ulTimeToReachQueue = pOpts->ulTimeToReachQueue;
  pEndpoint->ulTimeToReceive = pOpts->ulTimeToReceive;
  pEndpoint->fAuthenticate = pOpts->fAuthenticate;
  pEndpoint->fEncrypt = pOpts->fEncrypt;

  //
  // If the fAck flag is set, then we want to get an acknowledgement
  // for each call (message) as it gets to the destination (server)
  // queue. So, setup an admin queue to receive Falcon ACK messages.
  //
  if ( (pEndpoint->fAck) && (pEndpoint->hAdminQueue == 0) )
     {
     hr = SetupAdminQueue(pEndpoint);
     Status = MQ_MapStatusCode(hr,RPC_S_INTERNAL_ERROR);

     if (Status == RPC_S_OK)
        {
        MQ_RegisterQueueToDelete(pEndpoint->wsAdminQFormat,pEndpoint->wsMachine);
        }
     }

  return Status;
}

//----------------------------------------------------------------
//  MQ_BuildAddressVector()
//
//----------------------------------------------------------------
RPC_STATUS MQ_BuildAddressVector( OUT NETWORK_ADDRESS_VECTOR **ppVector )
{
    DWORD  dwSize;
    RPC_CHAR  wsMachine[MAX_COMPUTERNAME_LEN];
    NETWORK_ADDRESS_VECTOR *pVector;


    dwSize = sizeof(wsMachine)/sizeof(RPC_CHAR);
    GetComputerName((RPC_SCHAR *)wsMachine,&dwSize);

    *ppVector = 0;

    pVector = new( sizeof(RPC_CHAR*)
                   + sizeof(RPC_CHAR)*(1+RpcpStringLength(wsMachine)) )
                   NETWORK_ADDRESS_VECTOR;

    if (!pVector)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR*)(&pVector->NetworkAddresses[1]);
    RpcpStringCopy(pVector->NetworkAddresses[0],wsMachine);

    *ppVector = pVector;

    return RPC_S_OK;
}

//----------------------------------------------------------------
//  MQ_FillInAddress()
//
//----------------------------------------------------------------
RPC_STATUS MQ_FillInAddress( MQ_ADDRESS    *pAddress,
                             MQPROPVARIANT *pMsgProps )
{
    pAddress->fAuthenticated = pMsgProps[I_AUTHENTICATED].bVal;
    pAddress->ulPrivacyLevel = pMsgProps[I_PRIVACY_LEVEL].ulVal;

    ParseQueuePathName( (RPC_CHAR *)pMsgProps[I_MESSAGE_LABEL].ptszVal,
                        pAddress->wsMachine,
                        pAddress->wsQName );

    return RPC_S_OK;
}

#ifdef TRANSPORT_DLL
//----------------------------------------------------------------
//  MIDL_user_allocate()
//
//  Used by Mq_RegisterQueueToDelete().
//----------------------------------------------------------------
void __RPC_FAR * __RPC_USER MIDL_user_allocate( size_t len )
{
  return (I_RpcAllocate(len));
}


//----------------------------------------------------------------
//  MIDL_user_free()
//
//  Used by Mq_RegisterQueueToDelete().
//----------------------------------------------------------------
void __RPC_USER MIDL_user_free( void __RPC_FAR *ptr )
{
  I_RpcFree(ptr);
}
#endif


//----------------------------------------------------------------
//  MQ_RegisterQueueToDelete()
//
//----------------------------------------------------------------
RPC_STATUS MQ_RegisterQueueToDelete( RPC_CHAR  *pwsQFormat,
                                     RPC_CHAR  *pwsMachine )
{
   RPC_STATUS  Status;
   RPC_CHAR      *pwsStringBinding;
   RPC_BINDING_HANDLE  hBinding = 0;

   ASSERT(pwsQFormat);

   gp_csContext->Request();

   // This is a long critical section... but only for the first call.

   if (!g_pContext)
      {
      Status = RpcStringBindingCompose( NULL,
                                        Q_SVC_PROTSEQ,
                                        pwsMachine,
                                        Q_SVC_ENDPOINT,
                                        NULL,
                                        &pwsStringBinding );
      if (RPC_S_OK == Status)
         {
         Status = RpcBindingFromStringBinding( pwsStringBinding,
                                               &hBinding );
         if (RPC_S_OK != Status)
            {
            gp_csContext->Clear();
            return Status;
            }

         RpcStringFree(&pwsStringBinding);

         RpcTryExcept
             {
             Status = MqGetContext(hBinding,&g_pContext);
             Status = RpcBindingFree(&hBinding);
             }
         RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
             Status = RpcExceptionCode();
             }
         RpcEndExcept
         }
      }

   gp_csContext->Clear();

   if (g_pContext)
      {
      Status = MqRegisterQueue(g_pContext,pwsQFormat);
      }

   return Status;
}


//----------------------------------------------------------------
//  ConstructQueuePathName()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructQueuePathName( IN  RPC_CHAR *pwsMachine,
                             IN  RPC_CHAR *pwsQName,
                             OUT RPC_CHAR *pwsPathName,
                             IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD len = sizeof(RPC_CHAR) * (1 + RpcpStringLength(pwsMachine)
                                  + RpcpStringLength(WS_SEPARATOR)
                                  + RpcpStringLength(pwsQName) );

   if (*pdwSize < len)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_SEPARATOR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = len;
   return status;
}


//----------------------------------------------------------------
//  ConstructPrivateQueuePathName()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructPrivateQueuePathName( IN  RPC_CHAR *pwsMachine,
                                    IN  RPC_CHAR *pwsQName,
                                    OUT RPC_CHAR *pwsPathName,
                                    IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD dwSize = sizeof(RPC_CHAR) * (1 + RpcpStringLength(pwsMachine)
                                     + RpcpStringLength(WS_PRIVATE_DOLLAR)
                                     + RpcpStringLength(pwsQName) );

   if (*pdwSize < dwSize)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_PRIVATE_DOLLAR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = dwSize;
   return status;
}

#ifdef USE_PRIVATE_QUEUES
//----------------------------------------------------------------
//  ConstructPrivateDirectFormat()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructPrivateDirectFormat( IN  RPC_CHAR *pwsMachine,
                                   IN  RPC_CHAR *pwsQName,
                                   OUT RPC_CHAR *pwsPathName,
                                   IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD dwSize = sizeof(RPC_CHAR) * (1 + RpcpStringLength(WS_DIRECT),
                                     + RpcpStringLength(pwsMachine)
                                     + RpcpStringLength(WS_PRIVATE_DOLLAR)
                                     + RpcpStringLength(pwsQName) );

   if (*pdwSize < dwSize)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,WS_DIRECT);
      RpcpStringCat(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_PRIVATE_DOLLAR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = dwSize;
   return status;
}
#endif

#if FALSE
//----------------------------------------------------------------
//  ConstructDirectFormat()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructDirectFormat( IN  RPC_CHAR *pwsMachine,
                            IN  RPC_CHAR *pwsQName,
                            OUT RPC_CHAR *pwsPathName,
                            IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD dwSize = sizeof(RPC_CHAR) * (1 + RpcpStringLength(WS_DIRECT)
                                     + RpcpStringLength(pwsMachine)
                                     + RpcpStringLength(WS_SEPARATOR)
                                     + RpcpStringLength(pwsQName) );

   if (*pdwSize < dwSize)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,WS_DIRECT);
      RpcpStringCat(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_SEPARATOR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = dwSize;
   return status;
}
#endif

//----------------------------------------------------------------
//  ParseQueuePathName()
//
//  For RPC's use of MQ, a queue path name is of the form:
//  "machine_name\queue_name" or "machine\PRIVATE$\queue_name".
//  This routine extracts the machine name and queue name from
//  a given queue path name.
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Can't find the "\" separator).
//----------------------------------------------------------------
BOOL ParseQueuePathName(
                    IN  RPC_CHAR *pwsPathName,
                    OUT RPC_CHAR  wsMachineName[MAX_COMPUTERNAME_LEN],
                    OUT RPC_CHAR  wsQueueName[MQ_MAX_Q_NAME_LEN]  )
{
    BOOL   status = TRUE;
    RPC_CHAR *pSlash;

    pSlash = (RPC_CHAR *)RpcpCharacter(pwsPathName,*(WS_SEPARATOR));

    if (pSlash)
        {
        *pSlash = (RPC_CHAR)0;
        RpcpStringCopy(wsMachineName,pwsPathName);
        *pSlash = *(WS_SEPARATOR);
        }
    else
        status = FALSE;

    if (status)
        {
        pSlash = (RPC_CHAR *)RpcpCharacter(pwsPathName,*(WS_SEPARATOR));

        if (pSlash)
            {
            RpcpStringCopy(wsQueueName,++pSlash);
            }
        else
            status = FALSE;
        }

    return status;
}


//--------------------------------------------------------------------
//  LocateQueueViaQName()
//
//  Try to find a MQ queue of type specified by the Queue UUID (the
//  queue type) with the specified queue name. The first one that is
//  found (if any) is returned.
//--------------------------------------------------------------------
HRESULT LocateQueueViaQName( IN OUT MQ_ADDRESS *pAddress )
{
   HRESULT       hr = MQ_OK;
   HANDLE        hEnum;
   int           iSize;
   DWORD         dwSize;
   DWORD         cProps;
   DWORD         cQueue;
   UUID          QUuid;
   QUEUEPROPID   aqPropId[MAX_VAR];
   MQPROPVARIANT aPropVar[MAX_VAR];
   MQPROPERTYRESTRICTION aPropRestrict[MAX_VAR];
   MQRESTRICTION restrict;
   MQCOLUMNSET   column;
   RPC_CHAR         wsMachine[MAX_COMPUTERNAME_LEN];
   RPC_CHAR         wsQName[MQ_MAX_Q_NAME_LEN];

   if (RPC_S_OK != UuidFromString(SVR_QTYPE_UUID_STR,&QUuid))
      {
      return MQ_ERROR;
      }

   // Set up the restriction properties such that we will
   // only find our queue (of type pQUuid):

   cProps = 0;
   aPropRestrict[cProps].rel = PREQ;
   aPropRestrict[cProps].prop = PROPID_Q_TYPE;
   aPropRestrict[cProps].prval.vt = VT_CLSID;
   aPropRestrict[cProps].prval.puuid = &QUuid;
   cProps++;

   ASSERT(cProps < MAX_VAR);

   restrict.cRes = cProps;
   restrict.paPropRes = aPropRestrict;

   cProps = 0;
   aqPropId[cProps++] = PROPID_Q_INSTANCE;
   aqPropId[cProps++] = PROPID_Q_PATHNAME;

   ASSERT(cProps < MAX_VAR);

   column.cCol = cProps;
   column.aCol = aqPropId;

   // Ok, do a locate enumeration:

   hr = MQLocateBegin(NULL,&restrict,&column,NULL,&hEnum);
   if (FAILED(hr))
      {
      return hr;
      }

   cQueue = cProps;
   while (cQueue > 0)
      {
      hr = MQLocateNext( hEnum, &cQueue, aPropVar );
      if (FAILED(hr))
         {
         MQLocateEnd(hEnum);
         return hr;
         }

      if (cQueue > 0)
         {
         // Now extract the queue name from the path name:
         if (ParseQueuePathName((RPC_CHAR *)(aPropVar[1].ptszVal),wsMachine,wsQName))
            {
            if (!RpcpStringCompare(pAddress->wsQName,wsQName))
               {
               // We have a match! Ok, get the format name,
               // cleanup then return...

               // Transform the queue instance UUID into a
               // format name:
               dwSize = sizeof(pAddress->wsQFormat);
               hr = MQInstanceToFormatName( aPropVar[0].puuid, pAddress->wsQFormat, &dwSize);
               if (FAILED(hr))
                  {
                  break;
                  }

               // Free memory allocated by MQLocateNext():
               MQFreeMemory(aPropVar[0].puuid);    // From: PROPID_Q_INSTANCE
               MQFreeStringFromProperty(&aPropVar[1]);  // From: PROPID_Q_PATHNAME

               // Machine name:
               RpcpStringCopy(pAddress->wsMachine,wsMachine);

               break;
               }
            }

         // Free memory allocated by MQLocateNext():
         MQFreeMemory(aPropVar[0].puuid);    // From: PROPID_Q_INSTANCE
         MQFreeStringFromProperty(&aPropVar[1]);  // From: PROPID_Q_PATHNAME
         }
      }


   MQLocateEnd(hEnum);

   if (cQueue == 0)
      {
      return MQ_ERROR_QUEUE_NOT_FOUND;
      }

   return hr;
}


//----------------------------------------------------------------
//  CreateQueue()
//
//  Create a MQ queue of the specified path name.
//
//  Return Value:  MQ HRESULT value.
//
//----------------------------------------------------------------
HRESULT CreateQueue( IN  SECURITY_DESCRIPTOR  *pSecurityDescriptor,
                     IN  UUID     *pQueueUuid,
                     IN  RPC_CHAR *pwsPathName,
                     IN  RPC_CHAR *pwsQueueLabel,
                     IN  ULONG     ulQueueFlags,
                     OUT RPC_CHAR *pwsFormat,
                     IN OUT DWORD *pdwFormatSize )
{
   HRESULT       hr;
   DWORD         cProps;
   DWORD         dwSize;
   MQQUEUEPROPS  qProps;
   MQPROPVARIANT aPropVar[MAX_VAR];
   QUEUEPROPID   aqPropId[MAX_VAR];


   //
   // Setup properties to create a queue on this machine:
   //
   cProps = 0;

   // Set the PathName:
   aqPropId[cProps] = PROPID_Q_PATHNAME;
   aPropVar[cProps].vt =	VT_LPTSTR;
   aPropVar[cProps].ptszVal = (RPC_SCHAR *)pwsPathName;
   cProps++;

   // Set the type of the queue (this is a UUID).
   // This can be used to locate RPC specific queues.
   if (pQueueUuid)
   {
     aqPropId[cProps] = PROPID_Q_TYPE;
     aPropVar[cProps].vt = VT_CLSID;
     aPropVar[cProps].puuid = pQueueUuid;
     cProps++;
   }

   // Do we want to force authentication of messages
   // on the queue?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY)
      {
      aqPropId[cProps] = PROPID_Q_AUTHENTICATE;
      aPropVar[cProps].vt = VT_UI1;
      aPropVar[cProps].bVal = TRUE;
      cProps++;
      }

   // Do we want to force encrypted messages?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY)
      {
      aqPropId[cProps] = PROPID_Q_PRIV_LEVEL;
      aPropVar[cProps].vt = VT_UI4;
      aPropVar[cProps].ulVal = MQ_PRIV_LEVEL_BODY;
      cProps++;
      }

   // Put a description to the queue.
   // Useful for administration purposes (through the MSMQ admin tools).
   aqPropId[cProps] = PROPID_Q_LABEL;
   aPropVar[cProps].vt =	VT_LPTSTR;
   aPropVar[cProps].ptszVal = (RPC_SCHAR *)pwsQueueLabel;
   cProps++;

   ASSERT(cProps < MAX_VAR);

   // Assemble the QUEUEPROPS structure:
   qProps.cProp = cProps;
   qProps.aPropID = aqPropId;
   qProps.aPropVar = aPropVar;
   qProps.aStatus = 0;

   //-------------------------------------------------------
   // Create the queue
   hr = MQCreateQueue( pSecurityDescriptor,// Queue permissions.
                       &qProps,            // Queue properties.
                       pwsFormat,          // Format Name [out].
                       pdwFormatSize );    // Size of Format Name [in,out].

   return hr;
}


//----------------------------------------------------------------
//  ConnectToServerQueue()
//
//----------------------------------------------------------------
RPC_STATUS ConnectToServerQueue( MQ_ADDRESS  *pAddress,
                                 RPC_CHAR    *pNetworkAddress,
                                 RPC_CHAR    *pEndpoint )
{
    HRESULT     hr;
    DWORD       dwSize;
    RPC_CHAR       wsQPathName[MAX_PATHNAME_LEN];


    //
    // First, check the end point:
    //
    if ( (pEndpoint == NULL)
         || (*pEndpoint == '\0')
         || (RpcpStringLength(pEndpoint) >= MQ_MAX_Q_NAME_LEN) )
        {
        return RPC_S_INVALID_ENDPOINT_FORMAT;
        }

    memset(pAddress,0,sizeof(MQ_ADDRESS));

    RpcpStringCopy(pAddress->wsQName,pEndpoint);


    //
    // Now, if the server was specified, then use it as is,
    // otherwise use the local machine name:
    //
    if ( (pNetworkAddress == NULL) || (*pNetworkAddress == '\0') )
        {
        dwSize = sizeof(pAddress->wsMachine);
        GetComputerName((RPC_SCHAR *)pAddress->wsMachine,&dwSize);
        }
    else if (RpcpStringLength(pNetworkAddress) >= MAX_COMPUTERNAME_LEN)
        {
        return RPC_S_INVALID_ENDPOINT_FORMAT;
        }
    else
        {
        RpcpStringCopy(pAddress->wsMachine,pNetworkAddress);
        }


    //
    // If the server name is a "*", then locate a server (andy) that
    // has the specified queue name:
    //
    if (!RpcpStringCompare(pAddress->wsMachine,WS_ASTRISK))
       {
       hr = LocateQueueViaQName(pAddress);
       if (FAILED(hr))
          {
          return RPC_S_SERVER_UNAVAILABLE;
          }
       }

#if FALSE
    //
    // Try to use a direct format to get to the server queue:
    //
    dwSize = sizeof(pAddress->wsQFormat);
    if (!ConstructDirectFormat( pAddress->wsMachine,
                                pAddress->wsQName,
                                pAddress->wsQFormat,
                                &dwSize))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ConnectToServerQueue(): ConstructDirectFormat() failed.\n"));

        return RPC_S_SERVER_UNAVAILABLE;
        }


    hr = MQOpenQueue( pAddress->wsQFormat,
                                MQ_SEND_ACCESS, 0, &(pAddress->hQueue) );

    if (!FAILED(hr))
        {
        return RPC_S_OK;
        }
#endif


    //
    // If we get here, then the direct format failed, so try using
    // a lookup (MQPathNameToFormatName()):
    //
    dwSize = sizeof(wsQPathName);
    if (!ConstructQueuePathName( pAddress->wsMachine,
                                 pAddress->wsQName,
                                 wsQPathName,
                                 &dwSize ))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ConnectToServerQueue(): ConstructQueuePathName() failed.\n"));

        return RPC_S_SERVER_UNAVAILABLE;
        }

    dwSize = sizeof(pAddress->wsQFormat);
    hr = MQPathNameToFormatName( wsQPathName,
                                 pAddress->wsQFormat,
                                 &dwSize );
    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL, RPCTRANS "ConnectToServerQueue(): MQPathNameToFormatName() failed: 0x%x\n",
                       hr));

        return RPC_S_SERVER_UNAVAILABLE;
        }



    hr = MQOpenQueue( pAddress->wsQFormat,
                      MQ_SEND_ACCESS, 0, &(pAddress->hQueue) );

    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ConnectToServerQueue(): MQOpenQueue() failed: 0x%x\n",
                       hr));

        return RPC_S_SERVER_UNAVAILABLE;
        }

    return RPC_S_OK;
}


//----------------------------------------------------------------
//  DisconnectFromServer()
//
//----------------------------------------------------------------
RPC_STATUS DisconnectFromServer( IN OUT MQ_ADDRESS  *pAddress )
{
    DWORD       Status = NO_ERROR;

    if ((pAddress) && (pAddress->hQueue))
        {
        MQCloseQueue(pAddress->hQueue);
        pAddress->hQueue = 0;
        }

    return Status;
}

//----------------------------------------------------------------
//  SetQueueProperties()
//
//  Set the properties for an already existing queue. Currently
//  the only two Falcon queue properties that need to be set are
//  for forcing message authentication and encryption.
//
//  Return Value:  MQ HRESULT value.
//
//----------------------------------------------------------------
HRESULT SetQueueProperties( IN  RPC_CHAR *pwsQFormat,
                            IN  ULONG  ulQueueFlags )
{
   HRESULT       hr = MQ_OK;
   DWORD         cProps = 0;
   DWORD         dwSize;
   MQQUEUEPROPS  qProps;
   MQPROPVARIANT aPropVar[MAX_VAR];
   QUEUEPROPID   aqPropId[MAX_VAR];
   HRESULT       aStatus[MAX_VAR];

   // Do we want to force authentication of messages
   // on the queue?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY)
      {
      aqPropId[cProps] = PROPID_Q_AUTHENTICATE;
      aPropVar[cProps].vt = VT_UI1;
      aPropVar[cProps].bVal = TRUE;
      cProps++;
      }
   else
      {
      aqPropId[cProps] = PROPID_Q_AUTHENTICATE;
      aPropVar[cProps].vt = VT_UI1;
      aPropVar[cProps].bVal = FALSE;
      cProps++;
      }

   // Do we want to force encrypted messages?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY)
      {
      aqPropId[cProps] = PROPID_Q_PRIV_LEVEL;
      aPropVar[cProps].vt = VT_UI4;
      aPropVar[cProps].ulVal = MQ_PRIV_LEVEL_BODY;
      cProps++;
      }
   else
      {
      aqPropId[cProps] = PROPID_Q_PRIV_LEVEL;
      aPropVar[cProps].vt = VT_UI4;
      aPropVar[cProps].ulVal = MQ_PRIV_LEVEL_OPTIONAL;
      cProps++;
      }

   // Assemble the QUEUEPROPS structure:
   qProps.cProp = cProps;
   qProps.aPropID = aqPropId;
   qProps.aPropVar = aPropVar;
   qProps.aStatus = 0;

   // Set the new queue properties:
   hr = MQSetQueueProperties(pwsQFormat,&qProps);

   return hr;
}


//--------------------------------------------------------------------
//  ClearQueue()
//
//  Clear out all waiting messages from the specified queue (if
//  any).
//
//--------------------------------------------------------------------
HRESULT ClearQueue( QUEUEHANDLE hQueue )
{
   HRESULT       hr;
   DWORD         cProps = 0;
   MQMSGPROPS    msgProps;
   MSGPROPID     aMsgPropID[MAX_RECV_VAR];
   MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
   RPC_CHAR         wsMsgLabel[MQ_MAX_MSG_LABEL_LEN];


   //
   // MQ doesn't seem to let me clear out the queue (by reading
   // messages) unless we have at least one queue property.
   //
   aMsgPropID[cProps] = PROPID_M_LABEL;
   aMsgPropVar[cProps].vt = VT_LPTSTR;
   aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)wsMsgLabel;
   cProps++;

   aMsgPropID[cProps] = PROPID_M_LABEL_LEN;
   aMsgPropVar[cProps].vt = VT_UI4;
   aMsgPropVar[cProps].ulVal = sizeof(wsMsgLabel);
   cProps++;

   msgProps.cProp = cProps;
   msgProps.aPropID = aMsgPropID;
   msgProps.aPropVar = aMsgPropVar;
   msgProps.aStatus = 0;

   //
   // pull up all pending MQ messages.
   //
   while (TRUE)
      {
      hr = MQReceiveMessage(hQueue,0,MQ_ACTION_RECEIVE,
                                      &msgProps,NULL,NULL,NULL,NULL);
      if (FAILED(hr))
         break;
      }

   //
   // A timeout means the queue is empty:
   //
   if (hr == MQ_ERROR_IO_TIMEOUT)
      hr = MQ_OK;

   return hr;
}


//----------------------------------------------------------------
//  ClientSetupQueue()
//
//  Called by MQ_CreateEndpoint() to create and initialize the
//  client's message queue (to read server responses).
//
//  pEP         -- The structure that will hold information about
//                 the queue being created and setup.
//
//  pwsMachine  -- The machine to create the queue on.
//
//  pwsEndpoint -- RPC_CHAR string name of the endpoint. This will
//                 be used as the queue name.
//
//----------------------------------------------------------------
HRESULT ClientSetupQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint,
                          RPC_CHAR                *pwsMachine,
                          RPC_CHAR                *pwsEndpoint )
{
  HRESULT  hr;
  DWORD    dwSize;


  // The computer name for the server process:
  if (pEndpoint->wsMachine != pwsMachine)
     {
     RpcpStringCopy(pEndpoint->wsMachine,pwsMachine);
     }

  // The endpoint string (RPC_CHAR) is used as the queue name:
  RpcpStringCopy(pEndpoint->wsQName,pwsEndpoint);


  // Build the path name for the server queue:
  dwSize = sizeof(pEndpoint->wsQPathName);
  ConstructQueuePathName( pEndpoint->wsMachine,    // [in]
                          pEndpoint->wsQName,      // [in]
                          pEndpoint->wsQPathName,  // [out]
                          &dwSize );               // [in,out]

  // Try to create the client process's receive queue (for
  // responses back from the RPC server):
  UuidFromString( CLNT_QTYPE_UUID_STR, &(pEndpoint->uuidQType) );
  dwSize = sizeof(pEndpoint->wsQFormat);
  hr = CreateQueue( NULL,                    // [in] No security descriptor.
                    &(pEndpoint->uuidQType), // [in]
                    pEndpoint->wsQPathName,  // [in]
                    pEndpoint->wsQName,      // [in] Use QName as the QLabel.
                    0x00000000,              // [in] Flags
                    pEndpoint->wsQFormat,    // [out]
                    &dwSize );               // [in,out]

    if ( (FAILED(hr)) && (hr != MQ_ERROR_QUEUE_EXISTS) )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ClientSetupQueue(): CreateQueue(): 0x%x\n",
                       hr));

        return hr;
        }

    //
    // If the queue already exists, then locate it.
    //
    // NOTE: Currently client queues are temporary, but if cases
    //       are added in the future where client queues can be
    //       presistent, then this code will be needed.
    //
    if (hr == MQ_ERROR_QUEUE_EXISTS)
       {
       dwSize = sizeof(pEndpoint->wsQFormat);
       hr = MQPathNameToFormatName( pEndpoint->wsQPathName,
                                    pEndpoint->wsQFormat,
                                    &dwSize );
       if (FAILED(hr))
          return hr;
       }

    //
    // Ok, open the receive queue:
    //
    hr = MQOpenQueue( pEndpoint->wsQFormat, MQ_RECEIVE_ACCESS, 0, &(pEndpoint->hQueue));

    #if FALSE
    if (!FAILED(hr))
        {
        pEndpoint->fInitialized = TRUE;
        }
    #endif

    #ifdef DBG
    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ClientSetupQueue(): MQOpenQueueFailed(): 0x%x\n",
                       hr));
        }
    #endif

    return hr;
}

//----------------------------------------------------------------
//  ClientCloseQueue()
//
//----------------------------------------------------------------
HRESULT ClientCloseQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
    ASSERT(pEndpoint);

    if (pEndpoint->hQueue)
        {
        MQCloseQueue(pEndpoint->hQueue);
        pEndpoint->hQueue = 0;
        }

    g_pQueueMap->Remove(pEndpoint->wsQFormat);

    MQDeleteQueue(pEndpoint->wsQFormat);

    return MQ_OK;
}

//----------------------------------------------------------------
//  QueryQM()
//
//----------------------------------------------------------------
HRESULT QueryQM( RPC_CHAR *pwsMachine,
                 DWORD *pdwSize     )
{
  DWORD         cProps = 0;
  HRESULT       hr;
  MQQMPROPS     msgProps;
  MSGPROPID     aMsgPropID[MAX_RECV_VAR];
  MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];


  aMsgPropID[cProps] = PROPID_QM_PATHNAME;                // 0
  aMsgPropVar[cProps].vt = VT_NULL;
  cProps++;

  ASSERT( cProps < MAX_RECV_VAR );

  msgProps.cProp = cProps;
  msgProps.aPropID = aMsgPropID;
  msgProps.aPropVar = aMsgPropVar;
  msgProps.aStatus = 0;

  // The following receive should always fail, we're just calling
  // it to get the size of the message body:
  hr = MQGetMachineProperties( NULL, NULL, &msgProps );

  if (FAILED(hr))
     {
     return hr;
     }

  RpcpStringCopy(pwsMachine,aMsgPropVar[0].pwszVal);

  MQFreeStringFromProperty(&aMsgPropVar[0]);

  #ifdef MAJOR_DBG
  TransDbgPrint((DPFLTR_RPCPROXY_ID,
                 DPFLTR_WARNING_LEVEL,
                 RPCTRANS "QueryQM(): wsMachine: %S\n",
                 pwsMachine));
  #endif

  return hr;
}


//----------------------------------------------------------------
//  ServerSetupQueue()
//
//  Called by MQ_CreateEndpoint() to create and initialize the
//  server process's message queue (endpoint).
//
//  pEP        -- The struct to hold information about the queue
//                that is being set up.
//
//  pwsMachine -- The machine to create the queue on. For RPC this
//                is always the machine that the server process is
//                running on.
//
//  pwsEndpoint - The name of the endpoint. This will be used as
//                the queue name.
//
//  pSecurityDescriptor -- User may specify a security descriptor
//                to apply to this queue (may be NULL).
//
//  dwEndpointFlags -- Flags to control queue properties.
//
//----------------------------------------------------------------
HRESULT ServerSetupQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint,
                          RPC_CHAR   *pwsMachine,
                          RPC_CHAR   *pwsEndpoint,
                          void       *pSecurityDescriptor,
                          DWORD       dwEndpointFlags )
{
  HRESULT  hr;
  DWORD    dwSize;


  // The computer name for the server process:
  if (pEndpoint->wsMachine != pwsMachine)
     {
     RpcpStringCopy(pEndpoint->wsMachine,pwsMachine);
     }

  // The endpoint string (RPC_CHAR) is used as the queue name:
  if (pEndpoint->wsQName != pwsEndpoint)
      {
      RpcpStringCopy(pEndpoint->wsQName,pwsEndpoint);
      }

  // Build the path name for the server queue:
  dwSize = sizeof(pEndpoint->wsQPathName);
  if (!ConstructQueuePathName( pEndpoint->wsMachine,    // [in]
                               pEndpoint->wsQName,      // [in]
                               pEndpoint->wsQPathName,  // [out]
                               &dwSize ))         // [in,out]
     {
     return MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
     }

  // Try to create the server process receive queue;
  UuidFromString( SVR_QTYPE_UUID_STR, &(pEndpoint->uuidQType) );
  dwSize = sizeof(pEndpoint->wsQFormat);
  hr = CreateQueue( (SECURITY_DESCRIPTOR*)pSecurityDescriptor,
                    &(pEndpoint->uuidQType), // [in]
                    pEndpoint->wsQPathName,  // [in]
                    pEndpoint->wsQName,      // [in] Use QName as the QLabel.
                    dwEndpointFlags,         // [in]
                    pEndpoint->wsQFormat,    // [out]
                    &dwSize );               // [in,out]

  // If the queue already exists, then locate it:
  if (hr == MQ_ERROR_QUEUE_EXISTS)
     {
     dwSize = sizeof(pEndpoint->wsQFormat);
     hr = MQPathNameToFormatName( pEndpoint->wsQPathName,
                                            pEndpoint->wsQFormat,
                                            &dwSize );
     if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ServerSetupQueue(): MQPathNameToFormatName() failed: 0x%x\n",
                       hr));

        return hr;
        }

     if ( !(dwEndpointFlags & RPC_C_MQ_USE_EXISTING_SECURITY) )
        {
        hr = SetQueueProperties(pEndpoint->wsQFormat,dwEndpointFlags);
        if (FAILED(hr))
           {
           return hr;
           }
        }
     }
  else if (FAILED(hr))
     {
     TransDbgPrint((DPFLTR_RPCPROXY_ID,
                    DPFLTR_WARNING_LEVEL,
                    RPCTRANS "ServerSetupQueue(): CreateQueue() failed: 0x%x\n",
                    hr));

     return hr;
     }

  //
  // Ok, open the receive queue:
  //
  hr = MQOpenQueue( pEndpoint->wsQFormat, MQ_RECEIVE_ACCESS, 0, &(pEndpoint->hQueue));

  //
  // Does the user want to make sure the queue is empty (in case it
  // was a perminent queue):
  //
  if ( (hr == MQ_OK) && (dwEndpointFlags & RPC_C_MQ_CLEAR_ON_OPEN) )
      {
      hr = ClearQueue(pEndpoint->hQueue);
      }

  #ifdef DBG
  if (FAILED(hr))
     {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     RPCTRANS "ServerSetupQueue(): MQOpenQueue() failed: 0x%x\n",
                     hr));
     }
  #endif

  return hr;
}


//----------------------------------------------------------------
//  ServerCloseQueue()
//
//----------------------------------------------------------------
HRESULT ServerCloseQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
    ASSERT(pEndpoint);

    if (pEndpoint->hQueue)
        {
        MQCloseQueue(pEndpoint->hQueue);
        pEndpoint->hQueue = 0;
        }

    // MQDeleteQueue(pEndpoint->wsQFormat);

    return MQ_OK;
}


//----------------------------------------------------------------
//  AsyncPeekQueue()
//
//----------------------------------------------------------------
HRESULT AsyncPeekQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                        IN  MQ_OVERLAPPED        *pOl      )
{
    DWORD         cProps = 0;
    HRESULT       hr;

    pOl->aMsgPropID[cProps] = PROPID_M_BODY_SIZE;
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = 0;
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    pOl->msgProps.cProp = cProps;
    pOl->msgProps.aPropID = pOl->aMsgPropID;
    pOl->msgProps.aPropVar = pOl->aMsgPropVar;
    pOl->msgProps.aStatus = pOl->aStatus;

    hr = MQReceiveMessage( pEndpoint->hQueue,
                                     INFINITE,
                                     MQ_ACTION_PEEK_CURRENT,
                                     &pOl->msgProps,
                                     &pOl->ol,        // Asynchronous.
                                     NULL,            // No callback.
                                     NULL,            // Message filter.
                                     NULL   );        // Transaction object.
    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "AsyncPeekQueue() failed: 0x%x\n",
                       hr));
        }

    return hr;
}

//----------------------------------------------------------------
//  AsyncReadQueue()
//
//----------------------------------------------------------------
HRESULT AsyncReadQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                        IN  MQ_OVERLAPPED *pOl,
                        OUT MQ_ADDRESS    *pAddress,
                        OUT UCHAR         *pBuffer,
                        IN  DWORD          dwBufferSize )
{
    DWORD         cProps = 0;
    HRESULT       hr;

    pOl->aMsgPropID[cProps] = PROPID_M_BODY;           // [0]
    pOl->aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
    pOl->aMsgPropVar[cProps].caub.cElems = dwBufferSize;
    pOl->aMsgPropVar[cProps].caub.pElems = pBuffer;
    cProps++;

    ASSERT(cProps == I_MESSAGE_SIZE);
    pOl->aMsgPropID[cProps] = PROPID_M_BODY_SIZE;      // [1]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    cProps++;

    ASSERT(cProps == I_MESSAGE_LABEL);
    pOl->aMsgPropID[cProps] = PROPID_M_LABEL;          // [2]
    pOl->aMsgPropVar[cProps].vt = VT_LPWSTR;
    pOl->aMsgPropVar[cProps].pwszVal = (WCHAR *)pAddress->wsMsgLabel;
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_LABEL_LEN;      // [3]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = sizeof(pAddress->wsMsgLabel);
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_RESP_QUEUE;     // [4]
    pOl->aMsgPropVar[cProps].vt = VT_LPWSTR;
    pOl->aMsgPropVar[cProps].pwszVal = (WCHAR *)pAddress->wsQFormat;
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_RESP_QUEUE_LEN; // [5]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = sizeof(pAddress->wsQFormat);
    cProps++;

    //
    // These message properties are for authentication and privacy:
    //
    ASSERT(cProps == I_AUTHENTICATED);
    pOl->aMsgPropID[cProps] = PROPID_M_AUTHENTICATED;  // [6]
    pOl->aMsgPropVar[cProps].vt = VT_UI1;
    pOl->aMsgPropVar[cProps].bVal = 0;
    cProps++;

    ASSERT(cProps == I_PRIVACY_LEVEL);
    pOl->aMsgPropID[cProps] = PROPID_M_PRIV_LEVEL;     // [7]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = 0;
    cProps++;

    //
    // WARNING: these always need to be the last two properties
    // in the arrays (see the while loop below):
    //
    pOl->aMsgPropID[cProps] = PROPID_M_SENDERID_TYPE;  // [8]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = 0;
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_SENDERID;       // [9]
    pOl->aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
    pOl->aMsgPropVar[cProps].caub.cElems = sizeof(pAddress->aSidBuffer);
    pOl->aMsgPropVar[cProps].caub.pElems = pAddress->aSidBuffer;
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    pOl->msgProps.cProp = cProps;
    pOl->msgProps.aPropID = pOl->aMsgPropID;
    pOl->msgProps.aPropVar = pOl->aMsgPropVar;
    pOl->msgProps.aStatus = pOl->aStatus;

    hr = MQReceiveMessage( pEndpoint->hQueue,
                                     INFINITE,
                                     MQ_ACTION_RECEIVE,
                                     &pOl->msgProps,
                                     &pOl->ol,        // Asynchronous.
                                     NULL,            // No callback.
                                     NULL,            // Message filter.
                                     NULL   );        // Transaction object.
    #ifdef DBG
    if (  (hr != MQ_OK)
          && (hr != MQ_INFORMATION_OPERATION_PENDING)
          && (hr != MQ_ERROR_BUFFER_OVERFLOW) )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "AsyncReadQueue() failed: 0x%x\n",
                       hr));
        }
    #endif

    return hr;
}


//----------------------------------------------------------------
//  MQ_SendToQueue()
//
//  Send a PDU to somebody (specified by pAddress).
//
//  pEndpoint -- My (endpoint) for responses.
//
//  pAddress  -- The destination queue.
//
//  pBuffer   -- The data PDU to send.
//
//  dwBufferSize The size of the PDU (bytes).
//
//----------------------------------------------------------------
HRESULT MQ_SendToQueue( IN MQ_DATAGRAM_ENDPOINT *pEndpoint,
                        IN MQ_ADDRESS           *pAddress,
                        IN UCHAR                *pBuffer,
                        IN DWORD                 dwBufferSize )
{
  HRESULT       hr;
  DWORD         cProps = 0;
  MQMSGPROPS    msgProps;
  MSGPROPID     aMsgPropID[MAX_SEND_VAR];
  MQPROPVARIANT aMsgPropVar[MAX_SEND_VAR];
  HRESULT       aStatus[MAX_SEND_VAR];

  // NOTE: If you add MQ properties to be sent, make sure that
  // MAX_SEND_VAR is large enough...

  // Message body contains the packet being sent:
  aMsgPropID[cProps] = PROPID_M_BODY;
  aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
  aMsgPropVar[cProps].caub.cElems = dwBufferSize;
  aMsgPropVar[cProps].caub.pElems = pBuffer;
  cProps++;

  // The size of the packet:
  #if FALSE
  aMsgPropID[cProps] = PROPID_M_BODY_SIZE;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = dwBufferSize;
  cProps++;
  #endif

  // Pass the sender (me) as the queue label. The queue label
  // holds the my Queue Path Name:
  aMsgPropID[cProps] = PROPID_M_LABEL;
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pEndpoint->wsQPathName;
  cProps++;

  // Delivery (express or recoverable):
  aMsgPropID[cProps] = PROPID_M_DELIVERY;
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = (unsigned char)(pEndpoint->ulDelivery);
  cProps++;

    // Priority (MQ_MIN_PRIORITY to MQ_MAX_PRIORITY):
  aMsgPropID[cProps] = PROPID_M_PRIORITY;
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = (unsigned char)(pEndpoint->ulPriority);
  cProps++;

  // Journaling (none, deadletter or journal):
  aMsgPropID[cProps] = PROPID_M_JOURNAL;
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = (unsigned char)(pEndpoint->ulJournaling);
  cProps++;

  // Time limit to reach destination queue (seconds):
  aMsgPropID[cProps] = PROPID_M_TIME_TO_REACH_QUEUE;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = pEndpoint->ulTimeToReachQueue;
  cProps++;

  // Time limit for call to be received (seconds):
  aMsgPropID[cProps] = PROPID_M_TIME_TO_BE_RECEIVED;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = pEndpoint->ulTimeToReceive;
  cProps++;

  // Response Queue:
  aMsgPropID[cProps] = PROPID_M_RESP_QUEUE;
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pEndpoint->wsQFormat;
  cProps++;

  // Authentication:
  aMsgPropID[cProps] = PROPID_M_AUTH_LEVEL;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = (pEndpoint->fAuthenticate)? MQMSG_AUTH_LEVEL_ALWAYS : MQMSG_AUTH_LEVEL_NONE;
  cProps++;

    // Encryption:
  aMsgPropID[cProps] = PROPID_M_PRIV_LEVEL;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = (pEndpoint->fEncrypt)? MQMSG_PRIV_LEVEL_BODY_BASE : MQMSG_PRIV_LEVEL_NONE;
  cProps++;

  // Call (message) acknowledgment:
  if (pEndpoint->fAck)
      {
      aMsgPropID[cProps] = PROPID_M_ACKNOWLEDGE;
      aMsgPropVar[cProps].vt = VT_UI1;
      aMsgPropVar[cProps].bVal = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
      cProps++;

      aMsgPropID[cProps] = PROPID_M_ADMIN_QUEUE;
      aMsgPropVar[cProps].vt = VT_LPTSTR;
      aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pEndpoint->wsAdminQFormat;
      cProps++;
      }

  ASSERT( cProps < MAX_SEND_VAR );


  msgProps.cProp = cProps;
  msgProps.aPropID = aMsgPropID;
  msgProps.aPropVar = aMsgPropVar;
  msgProps.aStatus = aStatus;

  if ( (!pAddress->hQueue)
       && !(pAddress->hQueue = g_pQueueMap->Lookup(pAddress->wsQFormat)) )
      {
      hr = MQOpenQueue( pAddress->wsQFormat,
                                  MQ_SEND_ACCESS, 0, &(pAddress->hQueue) );
      if (FAILED(hr))
          {
          TransDbgPrint((DPFLTR_RPCPROXY_ID,
                         DPFLTR_WARNING_LEVEL,
                         RPCTRANS "MQ_SendToQueue(): MQOpenQueue() failed: 0x%x\n",
                         hr));

          return hr;
          }

      if (!g_pQueueMap->Add(pAddress->wsQFormat, pAddress->hQueue))
          {
          return MQ_ERROR_INSUFFICIENT_RESOURCES;
          }
      }

  hr = MQSendMessage( pAddress->hQueue, &msgProps, NULL );

  if ( (!FAILED(hr)) && (pEndpoint->fAck) )
     {
     hr = WaitForAck(pEndpoint);

     if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
        {
        MQCloseQueue(pEndpoint->hQueue);
        pEndpoint->hQueue = 0;
        }
     }

  #ifdef DBG
  if (hr != MQ_OK)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     RPCTRANS "MQ_SendToQueue(): MQSendMessage() failed: 0x%x\n",
                     hr));
      }
  #endif

  return hr;
}


//----------------------------------------------------------------
//  ReadQueue()
//
//  Blocking read of the next message from the queue in pEndpoint.
//  If there is no pending message on the queue, wait around for
//  timeoutMsec.
//
//  pInfo       -- Holds information about the queue that we are
//                 doing a read on.
//
//  timeoutMsec -- How long to wait around if there are no messages
//                 pending.
//
//  pAddress    -- Where to replace information about the queue to
//                 respond queue (who sent the message).
//
//  pBuffer     -- The MQ message body is returned in the memory
//                 pointed to by pBuffer. This is the RPC packet.
//
//  pdwBufferSize  On entry it is passed in as the total size of
//                 pBuffer, and it is returned with the actual
//                 number of bytes in the message.
//
//----------------------------------------------------------------
HRESULT ReadQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                   IN  DWORD       timeoutMsec,
                   OUT MQ_ADDRESS *pAddress,
                   OUT UCHAR      *pBuffer,
                   IN OUT DWORD   *pdwBufferSize )
{
  DWORD         cProps = 0;
  HRESULT       hr;
  MQMSGPROPS    msgProps;
  MSGPROPID     aMsgPropID[MAX_RECV_VAR];
  MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
  HRESULT       aStatus[MAX_RECV_VAR];


  aMsgPropID[cProps] = PROPID_M_BODY;                // [0]
  aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
  aMsgPropVar[cProps].caub.cElems = *pdwBufferSize;
  aMsgPropVar[cProps].caub.pElems = pBuffer;
  cProps++;

  ASSERT(cProps == I_MESSAGE_SIZE);
  aMsgPropID[cProps] = PROPID_M_BODY_SIZE;           // [1]
  aMsgPropVar[cProps].vt = VT_UI4;
  cProps++;

  ASSERT(cProps == I_MESSAGE_LABEL);
  aMsgPropID[cProps] = PROPID_M_LABEL;               // [2]
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pAddress->wsMsgLabel;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_LABEL_LEN;           // [3]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = sizeof(pAddress->wsMsgLabel);
  cProps++;

  aMsgPropID[cProps] = PROPID_M_RESP_QUEUE;          // [4]
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pAddress->wsQFormat;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_RESP_QUEUE_LEN;      // [5]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = MAX_FORMAT_LEN;
  cProps++;

  //
  // These message properties are for authentication and privacy:
  //
  ASSERT(cProps == I_AUTHENTICATED);
  aMsgPropID[cProps] = PROPID_M_AUTHENTICATED;       // [6]
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = 0;
  cProps++;

  ASSERT(cProps == I_PRIVACY_LEVEL);
  aMsgPropID[cProps] = PROPID_M_PRIV_LEVEL;          // [7]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = 0;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_SENDERID_TYPE;       // [8]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = 0;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_SENDERID;            // [9]
  aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
  aMsgPropVar[cProps].caub.cElems = sizeof(pAddress->aSidBuffer);
  aMsgPropVar[cProps].caub.pElems = pAddress->aSidBuffer;
  cProps++;


  ASSERT( cProps < MAX_RECV_VAR );

  msgProps.cProp = cProps;
  msgProps.aPropID = aMsgPropID;
  msgProps.aPropVar = aMsgPropVar;
  msgProps.aStatus = aStatus;

  hr = MQReceiveMessage( pEndpoint->hQueue,
                                   timeoutMsec,
                                   MQ_ACTION_RECEIVE,
                                   &msgProps,
                                   NULL,            // No overlap (synchronous).
                                   NULL,            // No callback.
                                   NULL,            // Message filter.
                                   NULL   );        // Transaction object.

  #ifdef DBG
  if ( (hr != MQ_OK) && (hr != MQ_ERROR_IO_TIMEOUT) )
     {
     DbgPrint("ReadQueue(): ERROR: hr: 0x%x\n",hr);
     }
  #endif

  if (!FAILED(hr))
  {
    pAddress->hQueue = 0;
    *pdwBufferSize = msgProps.aPropVar[I_MESSAGE_SIZE].ulVal;
  }

  return hr;
}


//----------------------------------------------------------------
//  PeekQueue()
//
//  Do a peek on the queue for the specified endpoint in order to
//  find out how big the next message is.  If there are no messages
//  in the queue, wait around for dwTimeoutMsec.  Return the size
//  of the message in *pdwSize.
//
//----------------------------------------------------------------
HRESULT PeekQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                   IN  DWORD       dwTimeoutMsec,
                   OUT DWORD      *pdwSize        )
{
    DWORD         cProps = 0;
    BOOL          bSuccess;
    HRESULT       hr;
    MQMSGPROPS    msgProps;
    MSGPROPID     aMsgPropID[MAX_RECV_VAR];
    MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
    RPC_CHAR         wsMsgLabel[MQ_MAX_MSG_LABEL_LEN];


    aMsgPropID[cProps] = PROPID_M_BODY;                     // 0
    aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
    aMsgPropVar[cProps].caub.cElems = 0;
    aMsgPropVar[cProps].caub.pElems = NULL;
    cProps++;

    aMsgPropID[cProps] = PROPID_M_BODY_SIZE;                // 1
    aMsgPropVar[cProps].vt = VT_UI4;
    cProps++;

    aMsgPropID[cProps] = PROPID_M_LABEL;                    // 2
    aMsgPropVar[cProps].vt = VT_LPTSTR;
    aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)wsMsgLabel;
    cProps++;

    aMsgPropID[cProps] = PROPID_M_LABEL_LEN;                // 3
    aMsgPropVar[cProps].vt = VT_UI4;
    aMsgPropVar[cProps].ulVal = sizeof(wsMsgLabel);
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    msgProps.cProp = cProps;
    msgProps.aPropID = aMsgPropID;
    msgProps.aPropVar = aMsgPropVar;
    msgProps.aStatus = 0;

    // The following receive should always fail, we're just calling
    // it to get the size of the message body:
    hr = MQReceiveMessage( pEndpoint->hQueue,
                                     dwTimeoutMsec,
                                     MQ_ACTION_RECEIVE,
                                     &msgProps,
                                     NULL,            // No overlap (synchronous).
                                     NULL,            // No callback.
                                     NULL,            // Message filter.
                                     NULL   );        // Transaction object.

    if (hr == MQ_ERROR_BUFFER_OVERFLOW)
    {
      *pdwSize = aMsgPropVar[1].ulVal;
      hr = MQ_OK;
    }
    else
      *pdwSize = 0;

    #ifdef DBG
    if ( (hr != MQ_OK) && (hr != MQ_ERROR_IO_TIMEOUT) )
       {
       DbgPrint("ClntPeekQueue(): ERROR: hr: 0x%x (%d)\n",hr,hr);
       }
    #endif

    return hr;
}


//----------------------------------------------------------------
//  EvaluateAckMessage()
//
//----------------------------------------------------------------
HRESULT EvaluateAckMessage( IN USHORT msgClass )
{
  HRESULT  hr = msgClass;

  switch (msgClass)
  {
     case MQMSG_CLASS_ACK_REACH_QUEUE:
     case MQMSG_CLASS_ACK_RECEIVE:
        hr = MQ_OK;
        break;

     case MQMSG_CLASS_NACK_BAD_DST_Q:
        hr = MQ_ERROR_QUEUE_NOT_FOUND;
        break;

     // All other cases are handled in MQ_MapStatusCode()...
  }

  return hr;
}

//----------------------------------------------------------------
//  ClntWaitForAck()
//
//  Used by the client side to wait for a MQ acknowledgement when
//  ClntSendToQueue() sends a call. An ACK is sent when the call
//  message reaches the destination (server) queue.
//
//----------------------------------------------------------------
HRESULT WaitForAck( IN MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
    HRESULT       hr;
    DWORD         cProps = 0;
    UCHAR         msgClass;
    MQMSGPROPS    msgProps;
    MSGPROPID     aMsgPropID[MAX_RECV_VAR];
    MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
    HRESULT       aMsgHr[MAX_RECV_VAR];
    RPC_CHAR         wsMsgLabel[MQ_MAX_MSG_LABEL_LEN];


    // The message class will tell us the message acknowledgement:
    aMsgPropID[cProps] = PROPID_M_CLASS;
    aMsgPropVar[cProps].vt = VT_UI2;
    aMsgPropVar[cProps].uiVal = 0;
    aMsgHr[cProps] = MQ_OK;
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    msgProps.cProp = cProps;
    msgProps.aPropID = aMsgPropID;
    msgProps.aPropVar = aMsgPropVar;
    msgProps.aStatus = aMsgHr;

    hr = MQReceiveMessage( pEndpoint->hAdminQueue,
                                     INFINITE,
                                     MQ_ACTION_RECEIVE,
                                     &msgProps,
                                     NULL, NULL, NULL, NULL );

    if (!FAILED(hr))
        {
        hr = EvaluateAckMessage( aMsgPropVar[0].uiVal );
        }
# ifdef DBG
    else
        {
        DbgPrint("WaitForAck(): FAILED: hr: 0x%x  aMsgHr[0]: 0x%x\n", hr, aMsgHr[0] );
        }
# endif

  return hr;
}

//----------------------------------------------------------------
//  SetupAdminQueue()
//
//
//----------------------------------------------------------------
HRESULT SetupAdminQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
  HRESULT  hr;
  DWORD    dwSize;
  UUID     uuidQType;
  RPC_CHAR    wsQName[MQ_MAX_Q_NAME_LEN];
  RPC_CHAR    wsQPathName[MAX_PATHNAME_LEN];


  RpcpStringCopy(wsQName,TEXT("Admin"));
  RpcpStringCat(wsQName,pEndpoint->wsQName);

  // Build the path name for the admin queue (NOTE: that this
  // is a private queue):
  dwSize = sizeof(pEndpoint->wsQPathName);
  ConstructPrivateQueuePathName( pEndpoint->wsMachine, // [in]
                                 wsQName,              // [in]
                                 wsQPathName,          // [out]
                                 &dwSize );            // [in,out]


  // Try to create the server process receive queue;
  UuidFromString( CLNT_ADMIN_QTYPE_UUID_STR, &uuidQType );
  dwSize = sizeof(pEndpoint->wsAdminQFormat);
  hr = CreateQueue( NULL,                       // [in] No security descriptor.
                    &uuidQType,                 // [in]
                    wsQPathName,                // [in]
                    wsQName,                    // [in] Use QName as the QLabel.
                    0x00000000,                 // [in] Flags
                    pEndpoint->wsAdminQFormat,  // [out]
                    &dwSize );                  // [in,out]

  if ( (FAILED(hr)) && (hr != MQ_ERROR_QUEUE_EXISTS) )
     {
     #ifdef DBG
     DbgPrint("SetupAdminQueue(): %S FAILED: 0x%x (%d)\n", wsQPathName, hr, hr );
     #endif
     return hr;
     }

  //
  // If the queue already exists, then locate it.
  //
  if (hr == MQ_ERROR_QUEUE_EXISTS)
  {
    dwSize = sizeof(pEndpoint->wsQPathName);
    hr = MQPathNameToFormatName( pEndpoint->wsQPathName,
                                           pEndpoint->wsQFormat,
                                           &dwSize );
    if (FAILED(hr))
       {
       #ifdef DBG
       DbgPrint("SetupAdminQueue(): %S FAILED: 0x%x (%d)\n", wsQPathName, hr, hr );
       #endif
       return hr;
       }
  }

  //
  // Ok, open the admin queue for receive:
  //
  hr = MQOpenQueue( pEndpoint->wsAdminQFormat,
                              MQ_RECEIVE_ACCESS, 0, &(pEndpoint->hAdminQueue));

  #ifdef DBG
  if (FAILED(hr))
     {
     DbgPrint("SetupAdminQueue(): %S FAILED: 0x%x (%d)\n", wsQPathName, hr, hr );
     }
  #endif

  return hr;
}


//----------------------------------------------------------------
//  Debug test code -- DG_DbgPrintPacket().
//----------------------------------------------------------------

#ifdef MAJOR_DBG

const static char *packetTypeStrs[] =
  {
    "REQUEST",
    "PING   ",
    "RESP   ",
    "FAULT  ",
    "WORKING",
    "NOCALL ",
    "REJECT ",
    "ACK    ",
    "QUIT   ",
    "FACK   ",
    "QUACK  ",
    "Unknown",
  };

const static char asciiByteChars[] =
  {
    '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'
  };

#define HIGH_NIBBLE(uc)  ((uc) >> 4)
#define LOW_NIBBLE(uc)   ((uc) & 0x0f)

//----------------------------------------------------------------
//  DbgPacketType()
//
//----------------------------------------------------------------
static char *DbgPacketType( unsigned char *pPacket )
{
   if ( (pPacket[1] >= 0) && (pPacket[1] < 11) )
      return packetTypeStrs[pPacket[1]];
   else
      return packetTypeStrs[11];
}

//----------------------------------------------------------------
//  DbgUuidToStr()
//
//----------------------------------------------------------------
static char *DbgUuidToStr( unsigned char *pUuidArg, char *pszUuid )
{
   int  i = 0;
   int  j;
   GUID uuid;
   unsigned char *pUuid;

   // Work with local copy of the UUID:
   pUuid = (unsigned char*)&uuid;
   CopyMemory(pUuid,pUuidArg,sizeof(GUID));

   // Assume this is intel and byte-swap it...
   uuid.Data1 = RpcpByteSwapLong(uuid.Data1);
   uuid.Data2 = RpcpByteSwapShort(uuid.Data2);
   uuid.Data3 = RpcpByteSwapShort(uuid.Data3);

   for (j=0; j<16; j++)
      {
      pszUuid[i++] = asciiByteChars[HIGH_NIBBLE(pUuid[j])];
      pszUuid[i++] = asciiByteChars[LOW_NIBBLE(pUuid[j])];
      if ( (j==3)||(j==5)||(j==7)||(j==9) )
         pszUuid[i++] = '-';
      }

   pszUuid[i] = '\0';
   return pszUuid;
}

//----------------------------------------------------------------
//  DbgPrintPacket()
//
//----------------------------------------------------------------
void DG_DbgPrintPacket( unsigned char *pPacket )
{
   char  szIf[50];
   char  szAct[50];
   ULONG ulSequenceNumber;

   if (pPacket)
      {
      ulSequenceNumber = *((unsigned long*)(&(pPacket[56])));
      ulSequenceNumber = RpcpByteSwapLong(ulSequenceNumber);

      DbgPrint("    Type: %s:0x%x:0x%x:0x%x:0x%x\n    Intferface: %s\n    Activity  : %s\n    SequenceNumber: %d\n",
               DbgPacketType(pPacket),
               pPacket[0], pPacket[1], pPacket[2], pPacket[3],
               DbgUuidToStr(&(pPacket[24]),szIf),
               DbgUuidToStr(&(pPacket[40]),szAct),
               ulSequenceNumber     );
      }
   else
      {
      DbgPrint("    NULL Packet.\n" );
      }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\httptran.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    httptran.cxx

Abstract:

    HTTP transport-specific functions.

Author:

    GopalP      06-25-97    Cloned from EdwardR's NT 4.0 RPC version.

Revision History:

    EdwardR     01-26-98    Rewrite NetworkOptions parsing.


--*/

#define  FD_SETSIZE  1

#include <precomp.hxx>

#include <CharConv.hxx>

#define  SPACE    ' '
#define  TAB      '\t'
#define  EQUALS   '='
#define  COMMA    ','
#define  COLON    ':'
#define  ZERO     '0'
#define  NINE     '9'

#define  KEYWORD_HTTPPROXY  "httpproxy"
#define  KEYWORD_RPCPROXY   "rpcproxy"

#define  KID_NONE            0
#define  KID_HTTPPROXY       1
#define  KID_RPCPROXY        2



//-------------------------------------------------------------
//  SkipWhiteSpace()
//
//  Routine Description:
//
//  Skip over spaces and tabs, return new string position.
//  Return NULL on end-of-string.
//-------------------------------------------------------------
inline static CHAR *SkipWhiteSpace( IN CHAR *psz )
    {
    if (psz)
        {
        while ((*psz)&&((*psz==SPACE)||(*psz==TAB))) psz++;

        if (!*psz)
            {
            psz = NULL;  // Return NULL on end-of-string.
            }
        }

    return psz;
    }



inline static char *
NextToken(
    IN char *psz
    )
/*++

Routine Description:

    This routine skips whitespace characters to the start of the
    next token in the string.

Arguments:

    psz - The string in question.

Return Value:

    NULL, if there is no next token.

    Pointer to the next token, otherwise.

--*/
{
    while ((*psz != CHAR_SPACE) &&
           (*psz != CHAR_TAB)   &&
           (*psz != CHAR_NL)    &&
           (*psz != CHAR_NUL))
        {
        psz++;
        }

    if ((*psz == CHAR_NL) || (*psz == CHAR_NUL))
        {
        return NULL;
        }

    psz = SkipWhiteSpace(psz);

    return psz;
}




inline unsigned int
HttpMessageLength(
    IN char *pBuffer
    )
/*++

--*/
{
    unsigned int len = 0;
    char *p = pBuffer;

    ASSERT(p);
    if (p == NULL)
        {
        return (0);
        }

    //
    // Look for a <CR><LF> sequence.
    //
    while ((*p     != CHAR_CR) &&
           (*(p+1) != CHAR_LF) &&
           (len <= MAX_HTTP_MESSAGE_LENGTH))
        {
        p++;
        len++;
        }

    return (len);
}




DWORD
HttpParseResponse(
    IN char *pBuffer
    )
/*++

Routine Description:

    This routine looks for a string of the form:
        HTTP/1.0 nnnn message_string
    Ex: "HTTP/1.0 200 Connection established"

Arguments:

    pBuffer - The response buffer.

Return Value:

    HTTP status code (nnnn), if successful.

    -1, if there is no next token yet.

     0, otherwise.

--*/
{
    DWORD  dwStatus = 0;
    char  *psz = pBuffer;

    psz = NextToken(psz);

    if (psz)
        {
        dwStatus = atoi(psz);
        }
    else
        {
        return (-1);
        }

    // Make sure a connection is established:
    if ( (dwStatus < 200) || (dwStatus > 299) )
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpParseResponse(): Connection Failed: %d\n",
                       dwStatus));
#endif // DBG
        dwStatus = 0;
        }

    return dwStatus;
}



//-------------------------------------------------------------
//  ParseLiteral()
//
//  Routine Description:
//
//  Check the next non-whitespace literal character to see if
//  its equal to cLiteral. If yes, the advance the string pointer
//  past it to the next character in the string. If no, then
//  return status set to RPC_S_INVALID_NETWORK_OPTIONS and return
//  the string pointer pointing to the invalid character.
//
//-------------------------------------------------------------
CHAR *ParseLiteral( IN  CHAR *psz,
                    IN  CHAR  cLiteral,
                    OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);

    if (psz)
        {
        if (*psz == cLiteral)
            {
            psz++;
            }
        else
            {
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            }
        }

    return psz;
    }


//-------------------------------------------------------------
//  ParsePort()
//
//  Routine Description:
//
//  Parse the next token as a "port-number", return its value
//  in the out parameter ppszPort.
//
//  Note: Use I_RpcFree() to release the memory for ppszPort
//        when you are finished with it.
//-------------------------------------------------------------
CHAR *ParsePort( IN  CHAR  *psz,
                 OUT CHAR **ppszPort,
                 OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);
    if (psz)
        {
        CHAR *p = psz;
        while ((*p >= ZERO) && (*p <= NINE))
            {
            p++;
            }

        if (p == psz)
            {
            // The next token isn't a number...
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            return psz;
            }

        CHAR cSave = *p;
        *p = 0;
        *ppszPort = (CHAR*)RpcpFarAllocate(1+strlen(psz));
        if (!*ppszPort)
            {
            *p = cSave;
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            return psz;
            }
        strcpy(*ppszPort,psz);
        *p = cSave;
        psz = p;
        }

    return psz;
    }


//-------------------------------------------------------------
//  ParseMachine()
//
//  Routine Description:
//
//  Parse the next token as a machine name. The machine name
//  is returned in ppszMachine, and psz is advance to point to
//  the next character after the machine name.
//
//  Note: That the machine name cannot contain any of ':' (colon),
//        ',' (comma), or ' ' (space). These are used in finding
//        the end of the machine name sub-string.
//
//  Note: Use I_RpcFree() to release the memory for ppszMachine
//        when you are finished with it.
//-------------------------------------------------------------
CHAR *ParseMachine( IN  CHAR  *psz,
                    OUT CHAR **ppszMachine,
                    OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);
    if (psz)
        {
        CHAR *p = psz;
        while ((*p) && (*p != COLON) && (*p != COMMA) && (*p != SPACE))
            {
            p++;
            }

        if (p == psz)
            {
            // zero length machine name...
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            return psz;
            }

        CHAR cSave = *p;
        *p = 0;
        *ppszMachine = (CHAR*)RpcpFarAllocate(1+strlen(psz));
        if (!*ppszMachine)
            {
            *p = cSave;
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            return psz;
            }

        strcpy(*ppszMachine,psz);
        *p = cSave;
        psz = p;
        }
    else
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        }

    return psz;
    }


//-------------------------------------------------------------
//  KeywordMatch()
//
//  Routine Description:
//
//  Compare the starting characters of the string (psz) with
//  the specified keyword (pszKeyword). If they match independent
//  of case, then return TRUE. If they don't match, return FALSE.
//-------------------------------------------------------------
BOOL KeywordMatch( CHAR *psz,
                   CHAR *pszKeyword )
    {
    DWORD dwLen1 = strlen( (char*)psz);
    DWORD dwLen2 = strlen( (char*)pszKeyword);
    BOOL  fMatch;

    if (dwLen1 < dwLen2)
        {
        return FALSE;    // String is not long enough to hold
        }                // the keyword.

    CHAR cSave = psz[dwLen2];
    psz[dwLen2] = 0;

    if (!RpcpStringCompareA((char*)psz,(char*)pszKeyword))
        {
        // Keyword matches the start of the string.
        fMatch = TRUE;
        }
    else
        {
        // Not a match.
        fMatch = FALSE;
        }

    psz[dwLen2] = cSave;
    return fMatch;
    }


//-------------------------------------------------------------
//  ParseKeyword()
//
//  Routine Description:
//
//  Parse the next token as a keyword, return its keyword ID
//  in pdwKid. There are currently two keywords to look for
//  "HttpProxy" (ID is KID_HTTPPROXY) and "RpcProxy" (ID is
//  KID_RPCPROXY). If the next text token doesn't match either
//  of these, then return KID_NONE (no match) and status is
//  returned as RPC_S_INVALID_NETWORK_OPTIONS.
//
//  If there is a match return the string pointer (psz) updated
//  to point to the next character after the end of the keyword.
//-------------------------------------------------------------
CHAR *ParseKeyword( IN  CHAR  *psz,
                    OUT DWORD *pdwKid,
                    OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);
    if (psz)
        {
        if (KeywordMatch(psz,(CHAR*)KEYWORD_HTTPPROXY))
            {
            // Keyword is "HttpProxy".
            *pdwKid = KID_HTTPPROXY;
            psz += strlen(KEYWORD_HTTPPROXY);
            }
        else if (KeywordMatch(psz,(CHAR*)KEYWORD_RPCPROXY))
            {
            // Keyword is "RpcProxy".
            *pdwKid = KID_RPCPROXY;
            psz += strlen(KEYWORD_RPCPROXY);
            }
        else
            {
            *pdwKid = KID_NONE;
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            }
        }

    return psz;
    }

//-------------------------------------------------------------
//  ParseOptValue()
//
//  Routine Description:
//
//  Parse strings of the following form:
//
//     OptValue <- machine ':' port
//              <- machine
//
//  If the parse is successful, then return the machine name
//  in ppszProxy, and the port in ppszPort. These are both new
//  strings allocated via RpcpFarAllocate().
//
//  The production ends with either the end of the string (null
//  terminated), the end of the port number (non-digit), or a
//  comma (which will start the begining of a new OptValue string.
//
//  On successful parse, return updated string position to the
//  next character after the end of the OptValue sub-string.
//-------------------------------------------------------------
CHAR *ParseOptValue( IN  CHAR  *psz,
                     OUT CHAR **ppszProxy,
                     OUT CHAR **ppszPort,
                     OUT DWORD *pdwStatus )
    {
    //
    // Get the machine name:
    //
    psz = ParseMachine(psz,ppszProxy,pdwStatus);
    if (*pdwStatus != NO_ERROR)
        {
        return psz;
        }

    //
    // If we're at the end of the string, or we've run into a
    // comma (start of another option) then we are done.
    //
    if ((!psz) || (*psz == 0) || (*psz == COMMA))
        {
        return psz;
        }

    psz = ParseLiteral(psz,COLON,pdwStatus);
    if (*pdwStatus != NO_ERROR)
        {
        return psz;
        }

    if (!psz)
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        return psz;
        }

    psz = ParsePort(psz,ppszPort,pdwStatus);

    return psz;
    }


//-------------------------------------------------------------
//  ParseOpt()
//
//  Routine Description:
//
//      Opt <- Keyword '=' OptValue
//
//  Parse an option, which is a keywork equals value pair.
//
//  If the parse is successful, then return the machine name
//  in ppszProxy, and the port in ppszPort. These are both new
//  strings allocated via RpcpFarAllocate(), and are represented
//  in the OptValue non-terminal.
//
//  The production ends with either the end of the string (null
//  terminated), the end of the port number (non-digit), or a
//  comma (which will start the begining of a new Opt string.
//
//  On successful parse, return updated string position to the
//  next character after the end of the Opt (option) sub-string.
//-------------------------------------------------------------
CHAR *ParseOpt( IN  CHAR  *psz,
                OUT DWORD *pdwKid,
                OUT CHAR **ppszProxy,
                OUT CHAR **ppszPort,
                OUT DWORD *pdwStatus )
    {
    if (psz)
        {
        psz = ParseKeyword(psz,pdwKid,pdwStatus);
        if (*pdwStatus != NO_ERROR)
            {
            return psz;
            }
        }

    if (!psz)
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        return psz;
        }

    psz = ParseLiteral(psz,EQUALS,pdwStatus);
    if (*pdwStatus != NO_ERROR)
        {
        return psz;
        }

    if (!psz)
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        return psz;
        }

    psz = ParseOptValue(psz,ppszProxy,ppszPort,pdwStatus);

    if ((psz) && (*psz == 0))
        {
        psz = NULL;
        }

    return psz;
    }


//-------------------------------------------------------------
//  ParseOptList()
//
//  Routine Description:
//
//  Parse ncacn_http network options strings. These are of the
//  following form:
//
//  OptList <- Opt
//          <- Opt ',' Opt
//
//  Opt <- Keyword '=' OptValue
//
//  OptValue <- Machine ':' PortNumber
//           <- Machine ':'
//           <- Machine
//
//  Keyword <- 'HttpProxy'
//          <- 'RpcProxy'
//
//  Machine and PortNumber are terminal strings.
//-------------------------------------------------------------
DWORD ParseOptList( IN  CHAR  *pszOptList,
                    OUT CHAR **ppszRpcProxy,
                    OUT CHAR **ppszRpcProxyPort,
                    OUT CHAR **ppszHttpProxy,
                    OUT CHAR **ppszHttpProxyPort )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwKid = KID_NONE;
    CHAR  *psz = pszOptList;
    CHAR  *pszProxy = NULL;
    CHAR  *pszPort = NULL;

    psz = ParseOpt(psz,&dwKid,&pszProxy,&pszPort,&dwStatus);
    if (dwStatus != NO_ERROR)
        {
        return dwStatus;
        }

    if (dwKid == KID_RPCPROXY)
        {
        *ppszRpcProxy = pszProxy;
        *ppszRpcProxyPort = pszPort;
        }
    else if (dwKid == KID_HTTPPROXY)
        {
        *ppszHttpProxy = pszProxy;
        *ppszHttpProxyPort = pszPort;
        }

    if (psz)
        {
        psz = ParseLiteral(psz,COMMA,&dwStatus);
        if (dwStatus != NO_ERROR)
            {
            return dwStatus;
            }
        }

    if (psz)
        {
        pszProxy = pszPort = NULL;
        psz = ParseOpt(psz,&dwKid,&pszProxy,&pszPort,&dwStatus);
        if (dwStatus != NO_ERROR)
            {
            return dwStatus;
            }

        if (dwKid == KID_RPCPROXY)
            {
            *ppszRpcProxy = pszProxy;
            *ppszRpcProxyPort = pszPort;
            }
        else if (dwKid == KID_HTTPPROXY)
            {
            *ppszHttpProxy = pszProxy;
            *ppszHttpProxyPort = pszPort;
            }
        }

    psz = SkipWhiteSpace(psz);

    if (psz)
        {
        dwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        }

    return dwStatus;
    }




BOOL
HttpParseNetworkOptions(
    IN RPC_CHAR *pNetworkOptions,
    IN char *pszDefaultServer,
    OUT char **ppszRpcProxy,
    OUT char **ppszRpcProxyPort,
    IN BOOL UseSSLProxyPortAsDefault,
    OUT char **ppszHttpProxy,
    OUT char **ppszHttpProxyPort,
    OUT RPCProxyAccessType *AccessType,
    OUT DWORD *pdwStatus
    )
/*++

Routine Description:

    Parse the Http network options specified in the string binding. The
    options would look like:

        HttpProxy=<Server_Name>:<Port>,RpcProxy=<Server_Name>:<Port>

    That is, two separate proxy servers, each with an optional port.

    The HttpProxy=<> specification is optional, if not specified then use
    the specified default server name. Its default Port is 80.

    If RpcProxy is optional as well, if not specified then use the
    default server name and Port 80.

Arguments:

    pNetworkOptions  - Network options string

    pszDefaultServer - Default Server.

    ppszRpcProxy     - RpcProxy, if specified in the options string.

    ppszRpcProxyPort - RpcProxyPort, if specified in the options string.

    UseSSLProxyPortAsDefault - if non-zero, the SSL port will be used as
        default if a port is not specified in the network options.

    ppszHttpProxy    - HttpProxy, if specified in the options string.

    ppszHttpProxyPort- HttpProxyPort, if specified in the options string.

    AccessType       - if we should try direct access, proxy access, or unknown yet.

    pdwStatus - Pointer to a DWORD where the return status will be put.

Notes:

    Returned strings should be free'd with I_RpcFree().

Return Value:

    TRUE, if successful.

    FALSE, otherwise. *pdwStatus will have the exact cause.

--*/
{
    char   szNetworkOptions[MAX_NETWORK_OPTIONS_SIZE];
    char  *pszNetworkOptions;
    char *DefaultRpcProxyPortToUse;

    // OUT variable initialization.
    *ppszRpcProxy = *ppszRpcProxyPort = NULL;
    *ppszHttpProxy = *ppszHttpProxyPort = NULL;
    *AccessType = rpcpatUnknown;
    *pdwStatus = 0;

    // Make sure we have and options string to parse:
    if ( (pNetworkOptions) && (*pNetworkOptions) )
        {
        // Make sure the Network Options is not too long.
        if (RpcpStringLength(pNetworkOptions) > MAX_NETWORK_OPTIONS_SIZE)
            {
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            goto Cleanup;
            }

        // Convert it to ANSI, since HTTP is ANSI (actually ASCII I think...):
		SimplePlatformToAnsi(pNetworkOptions, szNetworkOptions);

        //
        // Parse out the options:
        //
        pszNetworkOptions = szNetworkOptions;

        *pdwStatus = ParseOptList(pszNetworkOptions,
                                  ppszRpcProxy,
                                  ppszRpcProxyPort,
                                  ppszHttpProxy,
                                  ppszHttpProxyPort );
        if (*pdwStatus != RPC_S_OK)
            {
            goto Cleanup;
            }

#if FALSE
        psz = RpcStrTok(pszNetworkOptions, ",", &pszNetworkOptions);
        if (!ParseKeywordEqValue(
                psz,
                HTTP_PROXY_OPTION_STR,
                ppszHttpProxy,
                ppszHttpProxyPort,
                pdwStatus
                ))
            {
            if (*pdwStatus != RPC_S_OK)
                {
                goto Cleanup;
                }
            }

        if (*ppszHttpProxy)
            {
            psz = RpcStrTok(NULL, ",", &pszNetworkOptions);
            }

        if (!ParseKeywordEqValue(
                psz,
                RPC_PROXY_OPTION_STR,
                ppszRpcProxy,
                ppszRpcProxyPort,
                pdwStatus
                ))
            {
            if (*pdwStatus != RPC_S_OK)
                {
                *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
                goto Cleanup;
                }
            }
#endif
        }

    // Make sure that we have an RPC Proxy (IIS machine):
    if (!*ppszRpcProxy)
        {
        *ppszRpcProxy = (char*)RpcpFarAllocate(1+strlen(pszDefaultServer));
        if (!*ppszRpcProxy)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }

        strcpy(*ppszRpcProxy, pszDefaultServer);
        }
    else
        {
        // Length validation for RpcProxy name.
        if (strlen(*ppszRpcProxy) > MAX_HTTP_COMPUTERNAME_SIZE)
            {
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            goto Cleanup;
            }
        }

    // Make sure we have a port for the RPC Proxy.
    if (!*ppszRpcProxyPort)
        {
        if (UseSSLProxyPortAsDefault)
            DefaultRpcProxyPortToUse = DEF_HTTP_SSL_PORT;
        else
            DefaultRpcProxyPortToUse = DEF_HTTP_PORT;
        *ppszRpcProxyPort = (char*)RpcpFarAllocate(1+strlen(DefaultRpcProxyPortToUse));
        if (!*ppszRpcProxyPort)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }

        strcpy(*ppszRpcProxyPort, DefaultRpcProxyPortToUse);
        }

    // If no HTTP proxy was specified in the options string, check the
    // registry to see if IE has configured one:
    if (!*ppszHttpProxy)
        {
        if (!HttpCheckRegistry(
            *ppszRpcProxy,
            UseSSLProxyPortAsDefault,
            ppszHttpProxy,
            ppszHttpProxyPort,
            AccessType
            ) )
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }
    else
        {
        if (!*ppszHttpProxyPort)
            {
            *ppszHttpProxyPort = (char*)RpcpFarAllocate(1+strlen(DEF_HTTP_PORT));
            if (!*ppszHttpProxyPort)
                {
                *pdwStatus = RPC_S_OUT_OF_MEMORY;
                goto Cleanup;
                }

            strcpy(*ppszHttpProxyPort, DEF_HTTP_PORT);
            }
        }

    // Length validation for HttpProxy name.
    if ((*ppszHttpProxy) &&
        (strlen(*ppszHttpProxy) > MAX_HTTP_COMPUTERNAME_SIZE))
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        goto Cleanup;
        }

#ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "ParseNetworkOptions(): RpcProxy: %s  RpcProxyPort: %s\n",
                   *ppszRpcProxy,
                   *ppszRpcProxyPort));
#endif // MAJOR_DBG

    if (*AccessType != rpcpatDirect)
        {
        ASSERT(*ppszHttpProxy);
        }

    return TRUE;


Cleanup:

    if (*ppszRpcProxy)
        {
        I_RpcFree(*ppszRpcProxy);
         *ppszRpcProxy = NULL;
        }

    if (*ppszRpcProxyPort)
        {
        I_RpcFree(*ppszRpcProxyPort);
        *ppszRpcProxyPort = NULL;
        }

    if (*ppszHttpProxy)
        {
        I_RpcFree(*ppszHttpProxy);
        *ppszHttpProxy = NULL;
        }

    if (*ppszHttpProxyPort)
        {
        I_RpcFree(*ppszHttpProxyPort);
        *ppszHttpProxyPort = NULL;
        }

    return FALSE;
}




static BOOL
HttpSetupTunnel(
    IN SOCKET Socket,
    IN char *pszConnect
    )
/*++

Routine Description:

    Try to setup a connection to the IIS RPC Proxy.

Arguments:

    Socket - Socket on which to contact the IIS RPC Proxy.

    pszConnect - The message to send.

Return Value:

    TRUE, if successful

    FALSE, otherwise

--*/
{
    int   retval;
    DWORD dwStatus;
    DWORD dwSize;
    char szBuffer[MAX_HTTP_CHAT_BUFFER_SIZE];

    // Ok, try to connect to the IIS RPC proxy process:
    retval = send( Socket, pszConnect, 1+strlen(pszConnect), 0 );
    if (retval == SOCKET_ERROR)
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSetupTunnel(): send() failed: %d\n",
                       WSAGetLastError()));
#endif // DBG
        return FALSE;
        }

    dwSize = sizeof(szBuffer) - 1;
    retval = recv( Socket, szBuffer, dwSize, 0 );
    if ((retval == SOCKET_ERROR)||(retval == 0))
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSetupTunnel(): recv() failed: %d\n",
                       WSAGetLastError()));
#endif
        return FALSE;
        }

    szBuffer[dwSize] = 0;  // Note: dwSize is already sizeof()-1.

    dwStatus = HttpParseResponse(szBuffer);
#ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "HttpSetupTunnel(): response: %s",
                   szBuffer));
#endif

    // Make sure a connection is established:
    if ( (dwStatus < 200) || (dwStatus > 299) )
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSetupTunnel(): Connection Failed: %d\n",
                       dwStatus));
#endif
        return FALSE;
        }

    return TRUE;
}




inline BOOL
HttpTunnelToRpcProxy(
    IN SOCKET Socket,
    IN char *pszRpcProxy,
    IN char *pszRpcProxyPort
    )
/*++

Routine Description:

    This function is called to setup the HTTP chat to do a CONNECT
    through a proxy (like MSProxy). This will get you a tunnel to
    the IIS Server that you really want to get to. The call at the
    end, HttpSetupTunnel() does the connection.

Arguments:

    Socket - Socket on which to contact the IIS RPC Proxy.

    pszRpcProxy - The RPC Proxy to connect to.

    pszRpcProxyPort - RPC Proxy's port.

Return Value:

    Status from HttpSetupTunnel()

--*/
{
    char  szBuffer[MAX_HTTP_CHAT_BUFFER_SIZE];

    // make sure strings use \r\n instead of \n only. \n goes on the wire
    // as LF only, and some firewalls drop packets that use LF only
    strcpy(szBuffer, "CONNECT ");
    lstrcatA(szBuffer, pszRpcProxy);
    lstrcatA(szBuffer, ":");
    lstrcatA(szBuffer, pszRpcProxyPort);
    lstrcatA(szBuffer, " HTTP/1.0\r\nUser-Agent: RPC\r\nConnection: Keep-Alive\r\n\r\n");
    // Was:
    //
    // lstrcatA(szBuffer, " HTTP/1.1\nUser-Agent: RPC\nPragma: No-Cache\n\n");
    //
    // Some proxy servers (like MSProxy2.0 don't seem to like the version
    // number to be greater that 1.0.

    ASSERT(strlen(szBuffer) < MAX_HTTP_CHAT_BUFFER_SIZE);

    return HttpSetupTunnel(Socket, szBuffer);
}




inline BOOL
HttpTunnelToRpcServer(
    IN SOCKET Socket,
    IN char *pszRpcServer,
    IN char *pszRpcServerPort
    )
/*++

Routine Description:

    Open the socket to the IIS on which the RpcProxy resides.

Arguments:

    Socket - Socket on which to contact the IIS RPC Proxy.

    pszRpcServer - The RPC Server to connect to.

    pszRpcServerPort - RPC Server's port.

Return Value:

    Status from HttpSetupTunnel()

--*/
{
    int   retval;
    DWORD dwStatus;
    char  szBuffer[MAX_HTTP_CHAT_BUFFER_SIZE];

    strcpy(szBuffer, "RPC_CONNECT ");
    lstrcatA(szBuffer, pszRpcServer);
    lstrcatA(szBuffer, ":");
    lstrcatA(szBuffer, pszRpcServerPort);
    lstrcatA(szBuffer, " HTTP/1.1\nUser-Agent: RPC\nPragma: No-Cache\n\n");

    ASSERT(strlen(szBuffer) < MAX_HTTP_CHAT_BUFFER_SIZE);

    // Ok, try to connect to the RPC server process:
    return HttpSetupTunnel(Socket, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\muteximp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       muteximp.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File: muteximp.cxx

Description:

This file contains the system independent mutex class for NT.

History:

    kamenm - import (include) the mtrt version of mutex to avoid code cut
        and paste
-------------------------------------------------------------------- */

#include <precomp.hxx>

#include <mutex.cxx>

#define LogEvent(a,b,c,d,e,f,g)
#include <eventwrp.cxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\nbtrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nbtrans.cxx

Abstract:

    Netbios connection transport interface.  Parts are similar
    to wstran.cxx but there are major differences due to
    addresses supporting multiple listen sockets.

Author:

    Mario Goertzel    [MarioGo]


Revision History:

    MarioGo     3/28/1996   Based and depends on wstrans.cxx
    MarioGo     2/04/1997   Updated for async and client

--*/

#include <precomp.hxx>
#include <CharConv.hxx>

// Globals

BOOL fNetbiosLoaded = FALSE;

const DWORD MAX_LANA = 256;
const DWORD MAX_RESERVED_EPT = 32; // LanMan uses ports < 32.

typedef struct
{
    RPC_CHAR *Protseq;
    UINT ProtseqLength;
    PROTOCOL_ID id;
    BYTE MinEndpoint;
    BYTE MaxEndpoint;
} NB_PROTSEQ_CONFIG;

const NB_PROTSEQ_CONFIG NbProtseqConfig[] =
{
    {
    RPC_STRING_LITERAL("ncacn_nb_nb"),
    11,
    NBF,
    33,
    105
    },

    {
    RPC_STRING_LITERAL("ncacn_nb_tcp"),
    12,
    NBT,
    106,
    180
    },

    {
    RPC_STRING_LITERAL("ncacn_nb_ipx"),
    12,
    NBI,
    181,
    255
    }
};

const DWORD cNetbiosProtseqs = sizeof(NbProtseqConfig)/sizeof(NB_PROTSEQ_CONFIG);

typedef struct
{
    UCHAR ProtocolId;
    UCHAR Lana;
} NB_PROTOCOL_MAP;

DWORD cLanas;
NB_PROTOCOL_MAP *pNetbiosLanaMap = 0;

BOOL *afUsedEndpoints = 0;

const RPC_CHAR *NetbiosRegistryKey =
    RPC_CONST_STRING("Software\\Microsoft\\Rpc\\NetBios");

// enough to contain ncacn_nb_tcp#\0
const size_t MaxNbProtseqLength = 16;


RPC_STATUS
LoadNetbios()
/*++

Routine Description:

    Loads RPC netbios configuration data from the registry.

Note:

    Unlike wsock32.dll, advapi32.dll (required for registry APIs)
    is already loaded by rpcrt4.dll.  So it is okay to link
    directly to advapi32.dll.

Arguments:

    None

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    HKEY hKey;
    RPC_STATUS status;
    int i;
    PROTOCOL_ID id;

    RPC_CHAR protseq[MaxNbProtseqLength];
    DWORD cProtseq;
    DWORD datatype;
    DWORD lana;
    DWORD cLana;

    ASSERT(fNetbiosLoaded == FALSE);

    if (!pNetbiosLanaMap)
        {
        // Alloc space for the lana to RPC protocol mapping
        cLanas = 0;
        pNetbiosLanaMap = new NB_PROTOCOL_MAP[MAX_LANA];
        if (!pNetbiosLanaMap)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    if (!afUsedEndpoints)
        {
        // Alloc space to keep track of which endpoints are in use.
        afUsedEndpoints = new BOOL[256];
        if (!afUsedEndpoints)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        for (int i = 0; i <= MAX_RESERVED_EPT; i++)
            {
            afUsedEndpoints[i] = TRUE;
            }

        for (i = MAX_RESERVED_EPT + 1; i < 256; i++)
            {
            afUsedEndpoints[i] = FALSE;
            }
        }

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           NetbiosRegistryKey,
                           0,
                           KEY_READ,
                           &hKey);

    if (status)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Unable to open netbios key: %d\n",
                       GetLastError()));

        return(RPC_S_OUT_OF_RESOURCES);
        }

    ASSERT(hKey);

    for(i = 0, cLanas = 0; cLanas < MAX_LANA; i++)
        {
        cProtseq = MaxNbProtseqLength;
        cLana = sizeof(lana);

        status = RegEnumValueW(hKey,
                               i,
                               protseq,
                               &cProtseq,
                               0,
                               &datatype,
                               (PBYTE)&lana,
                               &cLana);

        if (status == ERROR_NO_MORE_ITEMS)
            {
            // This is the normal exit path.
            break;
            }

        if (status)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Unable to read netbios key %d, %d\n",
                           i,
                           GetLastError()));

            return(RPC_S_OUT_OF_RESOURCES);
            }

        if (datatype != REG_DWORD || lana >= MAX_LANA)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Invalid config for netbios entry %d\n",
                           i));

            ASSERT(0);
            continue;
            }

        for (int j = 0; j < cNetbiosProtseqs; j++)
            {
            if (wcsncmp(protseq,
                        NbProtseqConfig[j].Protseq,
                        NbProtseqConfig[j].ProtseqLength) == 0)
                {
                id = NbProtseqConfig[j].id;
                break;
                }
            }

        if (j == cNetbiosProtseqs)
            {
            // Unknown protsrq.
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Invalid config for netbios entry %S %d\n",
                           protseq,
                           i));

            ASSERT(0);
            continue;
            }

        pNetbiosLanaMap[cLanas].ProtocolId = (UCHAR)id;
        pNetbiosLanaMap[cLanas].Lana = (UCHAR)lana;
        cLanas++;
        }

    ASSERT(cLanas < MAX_LANA); // If this gets hit we may want to
                               // grow the table size or fix setup.

    if (cLanas == 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Invalid NETBIOS configuration\n"));

        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    return(RPC_S_OK);
}


void RPC_ENTRY WS_ServerAbortListen(RPC_TRANSPORT_ADDRESS);

RPC_STATUS
NB_ServerListenHelper(
    IN  PWS_ADDRESS pAddress,
    IN  USHORT port,
    IN  const NB_PROTSEQ_CONFIG *pConfig,
    IN  unsigned int PendingQueueSize
    )
/*++

Routine Description:

    This routine does the work of actually creating a server address.

Arguments:

    pAddress - A pointer to the loadable transport interface address.
        Will contain the newly allocated listen socket when finished.

    port - The port number to use, never zero here.

    pConfig - Config data for the protseq we're using.

    PendingQueueSize - Supplies the size of the queue of pending
        requests which should be created by the transport.
        In this case it is simply passed to listen().

ReturnValue:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT

--*/
{
    int retval, length;
    RPC_STATUS status;
    WS_SOCKADDR sockaddr;
    PWS_ADDRESS pList, pOld;
    SOCKET sock;
    PROTOCOL_ID index = pConfig->id;
    BOOL found = FALSE;
    DWORD dwLastError;

    pList = pAddress;

    status = RPC_S_CANT_CREATE_ENDPOINT;

    ASSERT(cLanas > 0 && cLanas < MAX_LANA);

    for (unsigned i = 0; i < cLanas; i++)
        {
        if (pNetbiosLanaMap[i].ProtocolId == (UCHAR)index)
            {
            //
            // Open a socket.
            //
            sock = WSASocketT(WsTransportTable[index].AddressFamily,
                              WsTransportTable[index].SocketType,
                              WsTransportTable[index].Protocol * pNetbiosLanaMap[i].Lana,
                              0,
                              0,
                              WSA_FLAG_OVERLAPPED);

            if (sock == INVALID_SOCKET)
                {
                switch(GetLastError())
                    {
                    case WSAEAFNOSUPPORT:
                    case WSAEPROTONOSUPPORT:
                    case WSAENETDOWN:
                    case WSAESOCKTNOSUPPORT:
                    case WSAEINVAL:     // when registry is not yet setup.
                        status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                        break;

                    case WSAENOBUFS:
                    case WSAEMFILE:
                        status = RPC_S_OUT_OF_MEMORY;
                        break;

                    default:
                        ASSERT(0);
                        status = RPC_S_OUT_OF_RESOURCES;
                        break;
                    }
                break;
                }

            //
            // Try to bind to the lana.
            //
            {
            DWORD Size = 1+MAX_COMPUTERNAME_LENGTH;
            char AsciiComputerName[1+MAX_COMPUTERNAME_LENGTH];

            if (!GetComputerNameA( AsciiComputerName, &Size) )
                {
                status = RPC_S_CANT_CREATE_ENDPOINT;
                closesocket(sock);
                break;
                }

            SET_NETBIOS_SOCKADDR(&sockaddr.nbaddr,
                                 NETBIOS_UNIQUE_NAME,
                                 AsciiComputerName,
                                 (char) port);
            }

            if ( bind(sock,&sockaddr.generic,sizeof(WS_SOCKADDR)) )
                {
                dwLastError = GetLastError();
                if (dwLastError == WSAEADDRINUSE)
                    {
                    //
                    // If the caller is trying use a dynamic endpoint
                    // then we may want to retry with another port.
                    //
                    status = ERROR_RETRY;
                    }
                else if(dwLastError == WSAENETDOWN)
                    {
                    closesocket(sock);
                    continue;
                    }
                else
                    status = RPC_S_CANT_CREATE_ENDPOINT;
                closesocket(sock);
                break;
                }

            if(listen(sock, PendingQueueSize) == SOCKET_ERROR)
                {
                status = RPC_S_OUT_OF_MEMORY;
                closesocket(sock);
                break;
                }

            //
            // Allocate a new address object, if needed.
            //
            found = TRUE;

            if (0 == pList)
                {
                // >1 lana, need to allocate another address.
                pList = new WS_ADDRESS;
                if (pList == 0)
                    {
                    status = RPC_S_OUT_OF_MEMORY;
                    break;
                    }

                // Insert new address into list of nb addresses.
                pOld->pNextAddress = pList;
                }

            pList->type = ADDRESS;
            pList->id = index;
            pList->ConnectionSocket = 0;
            SetProtocolMultiplier(pList, pNetbiosLanaMap[i].Lana);
            pList->NewConnection = WS_NewConnection;
            pList->SubmitListen = WS_SubmitAccept;
            pList->InAddressList = NotInList;
            pList->pFirstAddress = pAddress;
            pList->ListenSocket = 0;
            pList->ConnectionSocket = 0;
            pList->pNextAddress = 0;
            pList->Endpoint = 0;
            pList->pAddressVector = 0;
            pList->pNext = 0;
            memset(&pList->Listen, 0, sizeof(BASE_OVERLAPPED));
            pList->Listen.pAsyncObject = pList;
            pList->ListenSocket = sock;
            RpcpInitializeListHead(&pList->ObjectList);

            retval = pList->GetExtensionFunctionPointers(sock);

            if (!retval)
                {
                switch (GetLastError())
                    {
                    case WSAEFAULT:
                    case WSAEINVAL:
                        status = RPC_S_INTERNAL_ERROR;
                        break;

                    case WSAEOPNOTSUPP:
                        status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                        break;

                    default:
                        status = RPC_S_OUT_OF_RESOURCES;
                    }
                closesocket(sock);
                break;
                }

            status = COMMON_PrepareNewHandle((HANDLE)sock);

            if (status != RPC_S_OK)
                {
                closesocket(sock);
                break;
                }

            ASSERT(status == RPC_S_OK);

            pOld = pList;
            pList = 0;

            }
        }

    //
    // Cleanup only if we find something
    //
    if ((TRUE == found) && (status != RPC_S_OK))
        {
        WS_ServerAbortListen(pAddress);
        }

    return(status);
}


RPC_STATUS
NB_ServerListen(
    IN PROTOCOL_ID index,
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    This routine allocates a netbios server address receive new client
    connections.  If successful a call to NB_CompleteListen() will actually
    allow new connection callbacks to the RPC runtime to occur.  If the
    runtime is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (0-255) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    ppAddressVector - Network address of this machine.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS status;
    NTSTATUS NtStatus;
    USHORT port, maxport;
    const NB_PROTSEQ_CONFIG *pConfig;
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;

    // Figure out which flavor of Netbios we're going to use.

    pConfig = 0;

    for (int i = 0; i < cNetbiosProtseqs; i++)
        {
        if (index == NbProtseqConfig[i].id)
            {
            pConfig = &NbProtseqConfig[i];
            break;
            }
        }

    if (0 == pConfig)
        {
        ASSERT(0);
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    // Figure out what ports to try to listen on.

    if (*pEndpoint)
        {
        status = EndpointToPortNumber(*pEndpoint, port);

        if (status != RPC_S_OK)
            {
            return(status);
            }

        if (port > 255)
            {
            return(RPC_S_INVALID_ENDPOINT_FORMAT);
            }

        // Static endpoint, only try the one endpoint.

        status = NB_ServerListenHelper(pAddress,
                                       port,
                                       pConfig,
                                       PendingQueueSize);

        afUsedEndpoints[port] = TRUE;
        }
    else
        {
        port = pConfig->MinEndpoint;
        maxport = pConfig->MaxEndpoint;

        // Try to listen to a port.  This is iterative for dynamic endpoints.

        for(; port <= maxport; port++)
            {

            if (InterlockedExchange((PLONG)&afUsedEndpoints[port], TRUE) == FALSE)
                {

                status = NB_ServerListenHelper(pAddress,
                                               port,
                                               pConfig,
                                               PendingQueueSize);

                if (status == RPC_S_OK)
                    {
                    break;
                    }

                if (status != ERROR_RETRY)
                    {
                    return(status);
                    }
                }
            else
                {
                status = ERROR_RETRY;
                }
            }
        }

    if (status != RPC_S_OK)
        {
        if (status == ERROR_RETRY)
            {
            if (*pEndpoint)
                {
                return(RPC_S_DUPLICATE_ENDPOINT);
                }
            return(RPC_S_CANT_CREATE_ENDPOINT);
            }
        return(status);
        }

    //
    // Build address vector
    //

    ASSERT(pAddress->pAddressVector == 0);

    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + gdwComputerNameLength * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (pVector)
        {
        pVector->Count = 1;
        pVector->NetworkAddresses[0] = (RPC_CHAR *)&pVector->NetworkAddresses[1];

        wcscpy(pVector->NetworkAddresses[0], gpstrComputerName);

        pAddress->pAddressVector = pVector;
        *ppAddressVector = pVector;
        }
    else
        {
        WS_ServerAbortListen(ThisAddress);
        return(RPC_S_OUT_OF_MEMORY);
        }

    //
    // If needed, return the dynamic endpoint as a string.
    //
    if (!*pEndpoint)
        {
        *pEndpoint = new RPC_CHAR[NB_MAXIMUM_ENDPOINT];
        if (!*pEndpoint)
            {
            WS_ServerAbortListen(ThisAddress);
            return(RPC_S_OUT_OF_MEMORY);
            }
        PortNumberToEndpoint(port, *pEndpoint);
        }

    return(RPC_S_OK);
}

C_ASSERT(FIELD_OFFSET(NB_CONNECTION, fReceivePending) == FIELD_OFFSET(WS_CLIENT_CONNECTION, fReceivePending));


RPC_STATUS
RPC_ENTRY
NB_ClientOpen(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT Timeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_nb_*"
    NetworkAddress - The name of the server, a 1-15 character netbios name
    NetworkOptions - Ignored
    Timeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    PNB_CONNECTION p = (PNB_CONNECTION)ThisConnection;
    unsigned i;
    PROTOCOL_ID id = 0;
    USHORT port;
    RPC_STATUS status;
    UCHAR nbname[NB_MAXIMUM_NAME];
    SOCKET sock;
    WS_SOCKADDR addr;
    BOOL fIsUserModeConnection;

    // Figure out which specific Netbios protocol we're using
    for (i = 0; i < cNetbiosProtseqs; i++)
        {
        if (wcscmp(NbProtseqConfig[i].Protseq, ProtocolSequence) == 0)
            {
            id = NbProtseqConfig[i].id;
            break;
            }
        }

    ASSERT(id);

    // Initialize common part of the connection object

    // use explicit placement to initialize vtable
    p = new (p) NB_CONNECTION;

    p->id = id;
    p->type = CLIENT | CONNECTION;
    p->Conn.Socket = 0;
    p->fAborted = 0;
    p->pReadBuffer = 0;
    p->maxReadBuffer = 0;
    p->iPostSize = CO_MIN_RECV;
    p->iLastRead = 0;
    memset(&p->Read.ol, 0, sizeof(p->Read.ol));
    p->Read.pAsyncObject = p;
    p->Read.thread       = 0;
    p->SequenceNumber    = 0;
    p->InitIoCounter();
    p->fReceivePending = 0;
    RpcpInitializeListHead(&p->ObjectList);

    // The netbios endpoint is really just the 16th character in the
    // netbios name registered by the server.  The value is 1-255.

    status = EndpointToPortNumber(Endpoint, port);

    if (status != RPC_S_OK)
        {
        return status;
        }

    if (port > 255)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    // Build the uppercase netbios name we're looking for.

    if (NetworkAddress && *NetworkAddress)
        {
        if (wcslen(NetworkAddress) >= NB_MAXIMUM_NAME)
            {
            return(RPC_S_INVALID_NET_ADDR);
            }
        PlatformToAnsi(NetworkAddress, (PCHAR)nbname);
        }
    else
        {
        PlatformToAnsi(gpstrComputerName, (PCHAR)nbname);
        }

    _strupr((PCHAR)nbname);

    // Loop over every lana until we run out or succeed.
    unsigned ErrorCount = 0;

    for (i = 0; i < cLanas; i++)
        {

        if (pNetbiosLanaMap[i].ProtocolId != id)
            {
            continue;
            }

        UCHAR lana = pNetbiosLanaMap[i].Lana;

        //
        // Open socket
        //

        sock = WSASocketT(AF_NETBIOS,
                          SOCK_SEQPACKET,
                          -1 * lana,
                          0,
                          0,
                          WSA_FLAG_OVERLAPPED);

        if (sock == INVALID_SOCKET)
            {
            switch(GetLastError())
                {
                case WSAEAFNOSUPPORT:
                case WSAEPROTONOSUPPORT:
                case WSAESOCKTNOSUPPORT:
                case WSAEINVAL:     // when registry is not yet setup.
                    ErrorCount++;
                    break;

                default:
                    break;
                }
            // Keep trying until we run out of lana's.

            // This was a 4.0 hot fix for exchange, they had an invalid lana
            // in the configuration and it caused us to abort too early.

            continue;
            }

        DWORD option = TRUE;
        int retval;

        retval = setsockopt( sock, SOL_SOCKET, SO_REUSEADDR,
                             (PCHAR)&option, sizeof(option) );

        ASSERT(0 == retval);


        SET_NETBIOS_SOCKADDR( (&addr.nbaddr),
                              NETBIOS_UNIQUE_NAME,
                              nbname,
                              (CHAR)port );

        //
        // Connect the socket to the server.  This is where we expect to block
        // and/or fail.
        //

        if (connect(sock, &addr.generic, sizeof(addr)) == SOCKET_ERROR)
            {
            closesocket(sock);
            // Keep trying until we run out of lana's.
            continue;
            }

        status = COMMON_PrepareNewHandle((HANDLE)sock);
        if (status != RPC_S_OK)
            {
            closesocket(sock);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Connected, life is good.
        p->Conn.Socket = sock;

        fIsUserModeConnection = IsUserModeSocket(sock, &status);
        if (status)
            {
            closesocket(sock);
            ErrorCount ++;
            continue;
            }
        // if this is a user mode connection, use Winsock functions ...
        if (fIsUserModeConnection)
            p = new (p) NB_SAN_CONNECTION;

        return(RPC_S_OK);
        }

    // Either no lana's configured or none of them worked.
    if (ErrorCount == cLanas)
        {
        return (RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    return(RPC_S_SERVER_UNAVAILABLE);
}

RPC_STATUS
RPC_ENTRY
NB_Send(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Length,
    BUFFER Buffer,
    PVOID SendContext
    )
/*++

Routine Description:

    Submits a send of the buffer on the connection.  Will complete with
    ConnectionServerSend or ConnectionClientSend event either when
    the data has been sent on the network or when the send fails.

    This routine is specific to netbios since it supports sending
    sequence numbers.

Arguments:

    ThisConnection - The connection to send the data on.
    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer to use as the CO_SEND_CONTEXT for
        this operation.

Return Value:

    RPC_S_OK

    RPC_P_SEND_FAILED - Connection aborted

--*/
{
    PNB_CONNECTION pConnection = (PNB_CONNECTION)ThisConnection;
    CO_SEND_CONTEXT *pSend = (CO_SEND_CONTEXT *)SendContext;
    BOOL b;
    DWORD ignored;
    RPC_STATUS status;

    pConnection->StartingWriteIO();

    if (pConnection->fAborted)
        {
        pConnection->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    pSend->maxWriteBuffer = Length;
    pSend->pWriteBuffer = Buffer;
    pSend->Write.pAsyncObject = pConnection;
    pSend->Write.ol.hEvent = 0;
    pSend->Write.ol.Offset = 0;
    pSend->Write.ol.OffsetHigh = 0;
    pSend->Write.thread = I_RpcTransProtectThread();

    if ((pConnection->type & TYPE_MASK) == CLIENT)
        {
        // Client sends need to be prefixed with the sequence number.

        // Note: this depends on having only a single client side
        // send pending on a connection at a time.  If this changes
        // we can move the sequence number into the SEND_CONTEXT.

        WSABUF bufs[2];

        bufs[0].buf = (PCHAR)&pConnection->SequenceNumber;
        bufs[0].len = sizeof(ULONG);
        bufs[1].buf = (PCHAR)Buffer;
        bufs[1].len = Length;

        status = RPC_S_OK;

        if (WSASend(pConnection->Conn.Socket,
                             bufs,
                             2,
                             &ignored,
                             0,
                             &pSend->Write.ol,
                             0))
            {
            status = GetLastError();
            }
        }
    else
        {
        status = pConnection->Send(pConnection->Conn.Handle,
                                Buffer,
                                Length,
                                &ignored,
                                &pSend->Write.ol
                                );
        }

    ASSERT(WSA_IO_PENDING == ERROR_IO_PENDING);

    pConnection->WriteIOFinished();

    if (   status != RPC_S_OK
        && status != ERROR_IO_PENDING)
        {

        if (   status != ERROR_NETNAME_DELETED
            && status != ERROR_GRACEFUL_DISCONNECT
            && status != WSAESHUTDOWN
            && status != WSAECONNRESET
            && status != WSAECONNABORTED
            && status != WSAENETRESET
               )
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "NB Send failed %d on %p\n",
                           status,
                           pConnection));
            }

        I_RpcTransUnprotectThread(pSend->Write.thread);

        pConnection->WS_CONNECTION::Abort();
        return(RPC_P_SEND_FAILED);
        }

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
NB_Recv(
    RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    Called be the runtime on a connection without a currently
    pending recv.  This will submit the first recv on the
    connection.  Later recv's maybe posted by CO_Recv.  This is
    required to strip the sequence number off of fragments.

Arguments:

    ThisConnection - A connection without a read pending on it.

Return Value:

    RPC_S_OK
    RPC_P_RECEIVE_FAILED

--*/
{
    PNB_CONNECTION pConnection = (PNB_CONNECTION)ThisConnection;

    // Reply fragments don't have a sequence number, so we'll
    // just let the standard code deal with them.
    if ((pConnection->type & TYPE_MASK) == CLIENT)
        {
        pConnection->SequenceNumber = 0;
        return(CO_Recv(ThisConnection));
        }

    ASSERT(pConnection->iLastRead == 0);

    static ULONG NetbiosSequenceNumber;
    BOOL b;
    DWORD ignored;
    DWORD bytes;
    RPC_STATUS status;
    WSABUF bufs[2];
    int retval;

    if (pConnection->pReadBuffer == 0)
        {
        pConnection->pReadBuffer = TransConnectionAllocatePacket(pConnection,
                                                                 pConnection->iPostSize);

        if (NULL == pConnection->pReadBuffer)
            {
            pConnection->WS_CONNECTION::Abort();
            return(RPC_P_RECEIVE_FAILED);
            }

        pConnection->maxReadBuffer = pConnection->iPostSize;
        }

    pConnection->StartingReadIO();
    if (pConnection->fAborted)
        {
        pConnection->ReadIOFinished();
        return(RPC_P_RECEIVE_FAILED);
        }

    pConnection->Read.thread = I_RpcTransProtectThread();
    pConnection->Read.ol.hEvent = 0;

    bufs[0].buf = (PCHAR)&NetbiosSequenceNumber;
    bufs[0].len = sizeof(ULONG);
    bufs[1].buf = (PCHAR)pConnection->pReadBuffer;
    bufs[1].len = pConnection->maxReadBuffer;

    ignored = 0;

    retval = WSARecv(pConnection->Conn.Socket,
                     bufs,
                     2,
                     &bytes,
                     &ignored,
                     &pConnection->Read.ol,
                     0);

    pConnection->ReadIOFinished();

    if (   (0 != retval)
        && ((status = GetLastError()) != ERROR_IO_PENDING)
        && (status != WSAEMSGSIZE) )
        {

        TransDbgDetail((DPFLTR_RPCPROXY_ID,
                        DPFLTR_INFO_LEVEL,
                        RPCTRANS "NB WSARecv failed %d on %p\n",
                        status,
                        pConnection));

        I_RpcTransUnprotectThread(pConnection->Read.thread);

        pConnection->WS_CONNECTION::Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    // Even if the read completed here, it will also be posted to the
    // completion port.  This means we don't need to handle the read here.

    return(RPC_S_OK);
}

RPC_STATUS NB_CONNECTION::ProcessRead(IN  DWORD bytes, OUT BUFFER *pBuffer,
                                      OUT PUINT pBufferLength)
/*++

Routine Description:

    Wrapper for BASE_CONNECTION::ProcessRead.  This removes alls signs of the sequence
    number and return the results of BASE_CONNECTION::ProcessRead.

Arguments:
Return Value:

    See BASE_CONNECTION::ProcessRead

--*/
{
    // If this is the first read on the server then we need to substract
    // four from the bytes read since reading the sequence number doesn't count.

    if (type & SERVER)
        {
        // Server
        if (iLastRead == 0)
            {
            // First read

            if (bytes <= 4)
                {
                ASSERT(0);
                WS_CONNECTION::Abort();
                return(RPC_P_RECEIVE_FAILED);
                }

            bytes -= sizeof(ULONG);
            }
        }
    else
        {
        SequenceNumber = 0;
        }

    return(WS_CONNECTION::ProcessRead(bytes,
                                      pBuffer,
                                      pBufferLength));
}


RPC_STATUS
RPC_ENTRY
NB_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Sends a message on the connection.  This method must appear
    to be synchronous from the callers perspective.

Arguments:

    Connection - The connection of send to.
    BufferLength - The size of the buffer.
    Buffer - The data to sent.
    fDisableShutdownCheck - N/A to netbios.

Return Value:

    RPC_P_SEND_FAILED - Connection will be closed if this is returned.

    RPC_S_OK - Data sent

--*/

{
    PNB_CONNECTION p = (PNB_CONNECTION)Connection;
    ULONG bytes;
    INT retval;
    RPC_STATUS status;
    WSABUF bufs[2];
    int count;
    HANDLE hEvent = I_RpcTransGetThreadEvent();
    BOOL fWaitAlertably;

    p->StartingWriteIO();

    if (p->fAborted)
        {
        p->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    // Setting the low bit of the event indicates that the write
    // completion should NOT be sent to the i/o completion port.
    OVERLAPPED olWrite;
    olWrite.Internal = 0;
    olWrite.InternalHigh = 0;
    olWrite.Offset = 0;
    olWrite.OffsetHigh = 0;
    olWrite.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

    if ((p->type & TYPE_MASK) == CLIENT)
        {
        bufs[0].buf = (PCHAR)&p->SequenceNumber;
        bufs[0].len = sizeof(ULONG);
        bufs[1].buf = (PCHAR)Buffer;
        bufs[1].len = BufferLength;

        count = 2;
        BufferLength += sizeof(ULONG);
        }
    else
        {
        bufs[0].buf = (PCHAR)Buffer;
        bufs[0].len = BufferLength;
        count = 1;
        }

    retval = WSASend(p->Conn.Socket,
                     bufs,
                     count,
                     &bytes,
                     0,
                     &olWrite,
                     0);

    p->WriteIOFinished();

    if (retval == 0)
        {
        ASSERT(bytes == BufferLength);
        p->SequenceNumber++;
        return(RPC_S_OK);
        }

    status = GetLastError();
    if (status == WSA_IO_PENDING)
        {
        fWaitAlertably = !fDisableCancelCheck;
        status = UTIL_GetOverlappedResultEx(p,
                                          &olWrite,
                                          &bytes,
                                          fWaitAlertably,
                                          Timeout);

        if (status == RPC_S_OK)
            {
            ASSERT(bytes == BufferLength);
            p->SequenceNumber++;
            return(RPC_S_OK);
            }
        }

    p->WS_CONNECTION::Abort();

    if (status == RPC_S_CALL_CANCELLED)
        {
        // Wait for the write to finish.  Since we closed the
        // connection this won't take very long.
        UTIL_WaitForSyncIO(&olWrite,
                           FALSE,
                           INFINITE);
        }
    else
        {
        if (status != RPC_P_TIMEOUT)
            status = RPC_P_SEND_FAILED;
        }

    return(status);
}


RPC_STATUS
RPC_ENTRY
NBF_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
// See NB_ServerListen
{
    return( NB_ServerListen(NBF,
                            ThisAddress,
                            pEndpoint,
                            PendingQueueSize,
                            ppAddressVector) );
}


RPC_STATUS
RPC_ENTRY
NBT_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
// See NB_ServerListen
{
    return( NB_ServerListen(NBT,
                            ThisAddress,
                            pEndpoint,
                            PendingQueueSize,
                            ppAddressVector) );
}


RPC_STATUS
RPC_ENTRY
NBI_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
// See NB_ServerListen
{
    return( NB_ServerListen(NBI,
                            ThisAddress,
                            pEndpoint,
                            PendingQueueSize,
                            ppAddressVector) );
}


//
// Transport interface definitions
//

const RPC_CONNECTION_TRANSPORT
NBF_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NB_TOWER_ID,
    NBF_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_nb_nb"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    sizeof(NB_CONNECTION),
    sizeof(NB_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NBF_MAX_SEND,
    0,
    0,
    NB_ClientOpen,
    0, // No SendRecv on winsock
    CO_SyncRecv,
    WS_Abort,
    WS_Close,
    NB_Send,
    NB_Recv,
    NB_SyncSend,
    0,  // turn on/off keep alives
    NBF_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0, // query client address support.
    0, // query local address
    0, // query client id support.
    0, // Impersonate
    0  // Revert
    };

const RPC_CONNECTION_TRANSPORT
NBT_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NB_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_nb_tcp"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    sizeof(NB_CONNECTION),
    sizeof(NB_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NBT_MAX_SEND,
    0,
    0,
    NB_ClientOpen,
    0, // No SendRecv on winsock
    CO_SyncRecv,
    WS_Abort,
    WS_Close,
    NB_Send,
    NB_Recv,
    NB_SyncSend,
    0,  // turn on/off keep alives
    NBT_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0, // query client address support.
    0, // query local address
    0, // query client id support.
    0, // Impersonate
    0  // Revert
    };

const RPC_CONNECTION_TRANSPORT
NBI_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NB_TOWER_ID,
    IPX_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_nb_ipx"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    sizeof(NB_CONNECTION),
    sizeof(NB_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NBI_MAX_SEND,
    0,
    0,
    NB_ClientOpen,
    0, // No SendRecv on winsock
    CO_SyncRecv,
    WS_Abort,
    WS_Close,
    NB_Send,
    NB_Recv,
    NB_SyncSend,
    0,  // turn on/off keep alives
    NBI_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0, // query client address support.
    0, // query local address
    0, // query client id support.
    0, // Impersonate
    0  // Revert
    };



const RPC_CONNECTION_TRANSPORT *
NB_TransportLoad (
    IN PROTOCOL_ID index
    )
{
    RPC_STATUS status;

    if (fWinsockLoaded == FALSE)
        {
        if (RPC_WSAStartup() == FALSE)
            {
            return 0;
            }
        fWinsockLoaded = TRUE;
        }

    if (fNetbiosLoaded == FALSE)
        {
        status = LoadNetbios();

        if (status != RPC_S_OK)
            {
            return 0;
            }

        fNetbiosLoaded = TRUE;
        }

    switch(index)
        {
        case NBF:
            return(&NBF_TransportInterface);
            break;
        case NBT:
            return(&NBT_TransportInterface);
            break;
        case NBI:
            return(&NBI_TransportInterface);
            break;
        default:
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "NB_TransportLoad called with index: %d\n",
                           index));

            ASSERT(0);
        }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\regexp.cxx ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  regexp.c
//
//    Simple regular expression matching.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#include <precomp.hxx>

//-------------------------------------------------------------------------
//  MatchRE()
//
//  Match the test string (pszString) against the specifed pattern. If they
//  match return TRUE, else return FALSE.
//
//  In this function patterns are made up from "literal" characters plus
//  some control characters, "*", "?", "[" and "]". Asterix (*) is a place
//  holder for "zero or more" of any character. Question Mark (?) is a place
//  holder for "any single character". The square brackets ([]) contain a
//  list of matching characters, in this case "-" is used to denote a range
//  of characters (i.e. [a-zA-Z] matches any alpha character).
//
//  Note: Currently there is no support for "or" (|) operator.
//
//  Note: Ranges are simple, there is no support for dash at the begining
//        of a range to denote the dash itself.
//-------------------------------------------------------------------------
BOOL MatchRE( unsigned char *pszString,
              unsigned char *pszPattern )
{
    unsigned char ch;
    unsigned char chPattern;
    unsigned char chRangeLow;

    while (TRUE)
       {
       // Walk throuh the pattern, matching it against the string.
       switch (chPattern = *pszPattern++)
          {
          case '*':
             // Match zero or more characters.
             while (*pszString)
                {
                if (MatchRE(pszString++,pszPattern))
                   {
                   return TRUE;
                   }
                }
                return MatchRE(pszString,pszPattern);

          case '?':
             // Match any single character.
             if (*pszString++ == 0)
                {
                // Not at end of string, so no match.
                return FALSE;
                }
             break;

          case '[':
             // Match a set of characters.
             if ( (ch = *pszString++) == 0)
                {
                // Syntax error, no matching close bracket "]".
                return FALSE;
                }

             // ch = toupper(ch);
             chRangeLow = 0;
             while (chPattern = *pszPattern++)
                {
                if (chPattern == ']')
                   {
                   // End of char set, no match found.
                   return FALSE;
                   }

                if (chPattern == '-')
                   {
                   // check a range of chars?
                   chPattern = *pszPattern;           // get high limit of range
                   if ((chPattern == 0)||(chPattern == ']'))
                      {
                      // Syntax error.
                      return FALSE;
                      }

                   if ((ch >= chRangeLow)&&(ch <= chPattern))
                      {
                      // In range, go to next character.
                      break;
                      }
                   }

                chRangeLow = chPattern;
                // See if character matches this pattern element.
                if (ch == chPattern)
                   {
                   // Character match, go on.
                   break;
                   }
                }

             // Have a match in the character set, skip to the end of the set.
             while ((chPattern)&&(chPattern != ']'))
                {
                chPattern = *pszPattern++;
                }

             break;

          case 0:
             // End of pattern, return TRUE if at end of string.
             return ((*pszString)? FALSE : TRUE);

          default:
             ch = *pszString++;
             // Check for exact character match.
             // Note: CASE matters...
             if (ch != chPattern)
                {
                // No match.
                return FALSE;
                }
             break;
          }
       }

    // Can never exit from here.
}

//-------------------------------------------------------------------------
//  MatchREList()
//
//  Match a string against a list (array) of RE pattens, return TRUE iff
//  the string matches one of the RE patterns. The list of patterns is a
//  NULL terminated array of pointers to RE pattern strings.
//-------------------------------------------------------------------------
BOOL MatchREList( unsigned char  *pszString,
                  unsigned char **ppszREList  )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (MatchRE(pszString,pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}

//-------------------------------------------------------------------------
//  MatchExactList()
//
//-------------------------------------------------------------------------
BOOL MatchExactList( unsigned char  *pszString,
                     unsigned char **ppszREList )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (!lstrcmpA((char *) pszString, (char *) pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\protocol.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Protocol.cxx

Abstract:

    Transport Protocol abstraction used mainly by PnP.
    The following is a brief description of the current RPC PnP mechanism:
    Whenever a non-local transport level object (a socket, or an address) is opened
        for a given protocol, it is added to the list of objects for the given protocol.
        This alllows all objects for a given protocol to be tracked down and closed if
        the protocol is unloaded. By the same token, objects closed are removed from
        the list of the given protocol.
    When a PnP notification arrives, the lower level transport code call into this PnP module
        to tell it that there may be a change of state. For each PnP protocol, the PnP code
        examines whether the protocol is active, and what was its last state. Depending of
        the outcome of this comparison, it will take appropriate action. Here's the finite
        state automaton with the transitions:

        Currently, RPC differentiates between four networking states of each protocol -
            protocol is not loaded, protocol is partially loaded (i.e. it is active, but
            does not have an address on it yet), it is fully loaded (or functional), and
            it is fully loaded and network address change monitoring is required. The
            fully loaded state with address change monitoring may be abbreviated to
            FunctionalMon for the purpose of this document.
            Note that Partially Loaded, and loaded without address are equivalent terms
            for the purpose of this module. Also, note that currently the networking
            code does not allow reloading of a protocol, so some of the code paths will
            never get exercised.
        RPC in turn maintains the following RPC (as opposed to networking) states:
            ProtocolNotLoaded
            ProtocolLoadedWithoutAddress
            ProtocolWasLoadedOrNeedsActivation
            ProtocolLoaded
            ProtocolWasLoadedOrNeedsActivationWithoutAddress
            ProtocolLoadedAndMonitored
        Depending on the last RPC state, and the new networking state, the following changes
            and state transitions are effected:
    If a PnP notification fails asynchronously, the completion port code will call into PnP
        code to try to resubmit the queries.
    Note that the threads on which overlapped WSAIoctl's are submitted are not protected.
        If a thread dies, the IO will fail, and the thread that picks the failure will resubmit
        the WSAIoctl. This strategy allows up to keep the thread pool smaller.

                                    Networking State        Action
RPC State
ProtocolNotLoaded                   NotLoaded               No-op
                                    PartiallyLoaded         Submit a WSAIoctl to be notified
                                                                when the protocol becomes
                                                                functional.
                                                            State = ProtocolLoadedWithoutAddress
                                    Functional              State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolLoadedWithoutAddress        NotLoaded               Cancel WSAIoctl
                                                            State = ProtocolNotLoaded
                                    PartiallyLoaded         No-op
                                    Functional              CancelWSAIoctl
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl if necessary
                                                            State = ProtocolLoadedAndMonitored
ProtocolWasLoadedOrNeedsActivation  NotLoaded               No-op
                                    PartiallyLoaded         Submit a WSAIoctl to be notified
                                                                when the protocol becomes
                                                                functional.
                                                            State = ProtocolWasLoadedOrNeedsActivationWithoutAddress
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolLoaded                      NotLoaded               Unload protocol
                                                            State = ProtocolWasLoadedOrNeedsActivation
                                    PartiallyLoaded         Invalid
                                    Functional              No-op
                                    FunctionalMon           Invalid transition
ProtocolWasLoadedOrNeedsActivationWithoutAddress     
                                    NotLoaded               Cancel WSAIoctl
                                                            State = ProtocolWasLoadedOrNeedsActivation
                                    PartiallyLoaded         No-op
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolLoadedAndMonitored          NotLoaded               Cancel address change WSAIoctl
                                                            Unload protocol
                                                            State = ProtocolWasLoadedOrNeedsActivation
                                    PartiallyLoaded         Resubmit address change WSAIoclt if necessary
                                    Functional              Invalid transition
                                    FunctionalMon           No-op
ProtocolNeedToLoadWhenReady         NotLoaded               No-op
                                    PartiallyLoaded         Submit a WSAIoctl to be notified
                                                                when the protocol becomes
                                                                functional.
                                                            State = ProtocolNeedToLoadWhenReadyWithoutAddress
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolNeedToLoadWhenReadyWithoutAddress
                                    NotLoaded               Cancel WSAIoctl
                                                            State = ProtocolNeedToLoadWhenReady
                                    PartiallyLoaded         No-op
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored



Author:

    Kamen Moutafov    [KamenM]


Revision History:

    KamenM      12/22/1998   Creation
    KamenM      03/05/1999   Adding state ProtocolLoadedAndMonitored and support for it.
    KamenM      07/17/2000   Adding support for ProtocolWasLoadedOrNeedsActivation/
                                ProtocolWasLoadedOrNeedsActivationWithoutAddress

--*/

#include <precomp.hxx>
#include <Protocol.hxx>

void RPC_ENTRY NullAddressChangeFn( PVOID arg )
{
}

RPC_ADDRESS_CHANGE_FN * AddressChangeFn = NullAddressChangeFn;

#ifdef MAJOR_PNP_DEBUG

const char *ProtocolStateNames[];

#endif

void TransportProtocol::DetectedAsFunctional(PROTOCOL_ID ProtocolId)
{
    if (IsAddressChangeMonitoringOn(ProtocolId))
        {
        EnterCriticalSection(&AddressListLock);

        // monitor functional protocols for address change will
        // set the state
        MonitorFunctionalProtocolForAddressChange(ProtocolId);

        LeaveCriticalSection(&AddressListLock);
        }
    else
        {
        // we also need to take the critical section, and cancel any address change
        // notification (if any), to avoid race between a successful listen making
        // the protocol functional, and the address change notification completing
        EnterCriticalSection(&AddressListLock);
        CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
        SetState(ProtocolLoaded, ProtocolId);
        LeaveCriticalSection(&AddressListLock);
        }
}

void TransportProtocol::HandleProtocolChange(IN WSAPROTOCOL_INFO *lpProtocolBuffer,
                                             IN int ProtocolCount,
                                             IN PROTOCOL_ID thisProtocolId)
/*++
Function Name: HandleProtocolChange

Parameters:
    lpProtocolBuffer - an array of WSAPROTOCOL_INFO structures as returned by EnumProtocols
    ProtocolCount - the number of elements in the lpProtocolBuffer array
    thisProtocolId - the ID of the protocol for this object

Description:
    This handles protocol state change for a particular protocol. The function is idempotent - it
    can be called many times safely, regardless of previous calls. It will turn into no-op if
    it is redundant.

Returns:

--*/
{
    int i;
    BOOL fProtocolActive = FALSE;
    const WS_TRANS_INFO *pInfo;

    ASSERT(ProtocolCount >= 0);
    ASSERT(lpProtocolBuffer != NULL);
    ASSERT_TRANSPORT_PROTOCOL_STATE(thisProtocolId);

    if (
#ifdef NETBIOS_ON
        (thisProtocolId == NBF) || (thisProtocolId == NBT) || (thisProtocolId == NBI) ||
#endif

#ifdef NCADG_MQ_ON
        (thisProtocolId == MSMQ) ||
#endif

        (thisProtocolId == CDP)
       )
        return;

    if (IsTrailingProtocol(thisProtocolId))
        return;

    for (i = 0; i < ProtocolCount; i ++)
        {
        // if the enumerated protocol is the current protocol, break out of the loop
        if (MapProtocolId(lpProtocolBuffer[i].iProtocol, lpProtocolBuffer[i].iAddressFamily) == thisProtocolId)
            {
            fProtocolActive = TRUE;
            break;
            }
        }

    pInfo = &WsTransportTable[thisProtocolId];

    switch(State)
        {

        case ProtocolNotLoaded:
        case ProtocolLoadedWithoutAddress:
            // if the protocol was not loaded, but now it is active, attempt to verify
            // it is operational
            if (fProtocolActive)
                {
#ifdef MAJOR_PNP_DEBUG
                if (State == ProtocolNotLoaded)
                    {
                    DbgPrint("Protocol %d was just loaded\n", thisProtocolId);
                    }
#endif
                // If the protocol is not fully functional, we will submit an address change
                // request to get notified when it does
                if (VerifyProtocolIsFunctional(thisProtocolId) == TRUE)
                    {
                    // we succeeded in changing the state of the protocol
                    ASSERT((State == ProtocolLoaded) || (State == ProtocolLoadedAndMonitored));
                    if (IsAddressChangeMonitoringOn(thisProtocolId))
                        {
                        if (FirewallTableNeedsUpdating())
                            {
                            DoFirewallUpdate();
                            }

                        // If the only reason we were monitoring this protocol
                        // is to finish initializing the firewall table, then
                        // we may not continue monitoring for address change if
                        // the table has finished initializing after DoFirewallUpdate().
                        if(IsAddressChangeMonitoringOn(thisProtocolId))
                            {
                            MonitorFunctionalProtocolForAddressChange(thisProtocolId);
                            }

                        if (IsAddressChangeFnDefined())
                            {
                            (*AddressChangeFn)((PVOID) State);
                            }
                        }
                    }
#ifdef MAJOR_PNP_DEBUG
                if (State == ProtocolLoadedWithoutAddress)
                    {
                    DbgPrint("Protocol %d was without an address\n", thisProtocolId);
                    }
#endif
                }
            else
                {
                if (State == ProtocolLoadedWithoutAddress)
                    {
                    // a protocol was removed without being fully initialized
                    // cancel the pending query if any, and reset the state to not loaded
                    CancelAddressChangeRequestIfNecessary(TRUE, thisProtocolId);
                    SetState(ProtocolNotLoaded, thisProtocolId);
#ifdef MAJOR_PNP_DEBUG
                    DbgPrint("Protocol %d was removed without being fully initialized\n", thisProtocolId);
#endif
                    }
                // else - don't care. The protocol state is not loaded, and will remain so
                }
            break;

        case ProtocolWasLoadedOrNeedsActivation:
        case ProtocolWasLoadedOrNeedsActivationWithoutAddress:
            if (fProtocolActive)
                {
                // If the protocol is not fully functional, we will submit an address change
                // request to get notified when it does
                if (VerifyProtocolIsFunctional(thisProtocolId))
                    {
                    // if a protocol was loaded, and now is active, restart the addresses on it
                    RestartProtocol(thisProtocolId);
                    if (thisProtocolId == TCP)
                        {
                        GetTransportProtocol(HTTP)->RestartProtocol(HTTP);
                        }

                    // we succeeded in changing the state of the protocol
                    ASSERT(State == ProtocolLoaded);
                    if (IsAddressChangeMonitoringOn(thisProtocolId))
                        {
                        MonitorFunctionalProtocolForAddressChange(thisProtocolId);
                        }
                    }
                }
            else
                {
                // if the protocol was loaded, but it's not active, we don't care;
                // if it was trying to get an address, but then it was unloaded,
                // cancel the request
                if (State == ProtocolWasLoadedOrNeedsActivationWithoutAddress)
                    {
                    CancelAddressChangeRequestIfNecessary(TRUE, thisProtocolId);
                    SetState(ProtocolWasLoadedOrNeedsActivation, thisProtocolId);
#ifdef MAJOR_PNP_DEBUG
                    DbgPrint("Protocol %d was removed without being fully initialized\n", thisProtocolId);
#endif
                    }
                }
            break;

        case ProtocolLoaded:
            ASSERT(IsAddressChangeMonitoringOn(thisProtocolId) == FALSE);
            // if the protocol was loaded, and it is active, we don't need to do anything;
            // if it was loaded, but is not active currently, we need to unload the protocol
            if (!fProtocolActive)
                {
#ifdef MAJOR_PNP_DEBUG
                DbgPrint("Protocol %d was just unloaded\n", thisProtocolId);
#endif
                UnloadProtocol(thisProtocolId);
                if (thisProtocolId == TCP)
                    {
                    GetTransportProtocol(HTTP)->UnloadProtocol(HTTP);
                    }
                SetState(ProtocolWasLoadedOrNeedsActivation, thisProtocolId);
                }
            break;

        case ProtocolLoadedAndMonitored:
            // if it was loaded, but is not active currently, we need to unload the protocol
            if (!fProtocolActive)
                {
#ifdef MAJOR_PNP_DEBUG
                DbgPrint("Protocol %d was just unloaded\n", thisProtocolId);
#endif

                if (FirewallTableNeedsUpdating())
                    {
                    DoFirewallUpdate();
                    }

                CancelAddressChangeRequestIfNecessary(TRUE, thisProtocolId);
                UnloadProtocol(thisProtocolId);
                if (thisProtocolId == TCP)
                    {
                    GetTransportProtocol(HTTP)->UnloadProtocol(HTTP);
                    }
                SetState(ProtocolWasLoadedOrNeedsActivation, thisProtocolId);

                if (IsAddressChangeFnDefined())
                    {
                    (*AddressChangeFn)((PVOID) State);
                    }
                }
            else
                {
#ifdef MAJOR_PNP_DEBUG
                DbgPrint("Protocol %d is monitored and received event\n", thisProtocolId);
#endif
                if (FirewallTableNeedsUpdating())
                    {
                    DoFirewallUpdate();
                    }

                if (IsAddressChangeFnDefined())
                    {
                    (*AddressChangeFn)((PVOID) State);
                    }
                }
            break;

#if defined(DBG) || defined(_DEBUG)
        default:
            ASSERT(!"Invalid State");
#endif
        }

    ASSERT_TRANSPORT_PROTOCOL_STATE(thisProtocolId);
}

void TransportProtocol::AddObjectToList(IN OUT BASE_ASYNC_OBJECT *pObj)
/*++
Function Name: AddObjectToList

Parameters:
    pObj - the object to be added

Description:
    Add the object to the list of transport objects for this protocol.

Returns:

--*/
{
    EnterCriticalSection(&AddressListLock);
    RpcpfInsertHeadList(&ObjectList, &pObj->ObjectList);
    LeaveCriticalSection(&AddressListLock);
}

void TransportProtocol::RemoveObjectFromList(IN OUT BASE_ASYNC_OBJECT *pObj)
/*++
Function Name: RemoveObjectFromList

Parameters:
    pObj - the object to be removed

Description:
    Removes the object from the list of transport objects for this protocol.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *Prev, *Cur;

    Prev = NULL;

    EnterCriticalSection(&AddressListLock);

    RpcpfRemoveEntryList(&pObj->ObjectList);

    LeaveCriticalSection(&AddressListLock);
}

BOOL TransportProtocol::ResubmitQueriesIfNecessary(PROTOCOL_ID ProtocolId)
/*++
Function Name: ResubmitQueriesIfNecessary

Parameters:
    ProtocolId - the ID of the current protocol

Description:
    If there was a WSAIoctl pending that failed, it will be resubmitted.
    If this protocol was being monitored, try to restart monitoring if necessary

Returns:
    FALSE if the WSAIoctl was not resubmitted successfully.
    TRUE if the WSAIoctl was resubmitted successfully, or there was no need to resubmit it.

--*/
{
    if (addressChangeSocket)
        {
        if ((addressChangeOverlapped.Internal != 0) && (addressChangeOverlapped.Internal != STATUS_PENDING))
            {
            if (SubmitAddressChangeQuery() == FALSE)
                return FALSE;
            }
        }

    if (State == ProtocolLoadedAndMonitored)
        {
        if (MonitorFunctionalProtocolForAddressChange(ProtocolId) == FALSE)
            return FALSE;
        }

    return TRUE;
}

PROTOCOL_ID 
MapProtocolId (
    IN UINT ProtocolId,
    IN UINT AddressFamily
    )
/*++
Function Name: MapProtocolId

Parameters:
    ProtocolId - Winsock protocol ID
    AddressFamily - Winsock address family

Description:
    Converts a Winsock Protocol ID to a RPC Transport protocol ID.

Returns:
    The RPC Transport Protocol ID if successfull, or -1 if no mapping can be found

--*/
{
    unsigned id;

    for (id = 1; id < cWsTransportTable; id++)
        {
        if ((WsTransportTable[id].Protocol == (int) ProtocolId)
            && (WsTransportTable[id].AddressFamily == (int) AddressFamily))
            {
            return id;
            }
        }

    return -1;
}

BOOL TransportProtocol::HandlePnPStateChange(void)
/*++
Function Name: HandlePnPNotification

Parameters:

Description:
    Whenever a PnP notification (NewAddress) arrives, the completion port will direct it
    to this routine, which will handle all state management and all handling of the PnP
    notification.

Returns:
    TRUE if the runtime should be notified that a protocol state change has occurred.
    FALSE if the run time should not be notified, or need not be notified that a
        protocol state change has occurred.

--*/
{
    int i;

    //
    // Enumerate the currently loaded protocols
    //
    WSAPROTOCOL_INFO *lpProtocolBuffer;
    DWORD dwBufferLength = 512;
    int ProtocolCount;
    PROTOCOL_ID ProtocolId;
    TransportProtocol *pCurrentProtocol;
    BOOL fRetVal;

    EnterCriticalSection(&AddressListLock);

    ASSERT(hWinsock2);

    while (1)
        {
        lpProtocolBuffer = (WSAPROTOCOL_INFO *) I_RpcAllocate(dwBufferLength);
        if (lpProtocolBuffer == 0)
            {
            fRetVal = FALSE;
            goto CleanupAndReturn;
            }

        ProtocolCount = WSAEnumProtocolsT(
                              0,
                              lpProtocolBuffer,
                              &dwBufferLength
                              );
        if (ProtocolCount != SOCKET_ERROR)
            {
            break;
            }

        I_RpcFree(lpProtocolBuffer);

        if (GetLastError() != WSAENOBUFS)
            {
            fRetVal = FALSE;
            goto CleanupAndReturn;
            }
        }

    for (i = 1; i < MAX_PROTOCOLS; i++)
        {
        pCurrentProtocol = GetTransportProtocol(i);
        pCurrentProtocol->HandleProtocolChange(lpProtocolBuffer, ProtocolCount, i);
        }

    I_RpcFree(lpProtocolBuffer);

    fRetVal = g_NotifyRt;

CleanupAndReturn:
    LeaveCriticalSection(&AddressListLock);
#ifdef MAJOR_PNP_DEBUG
    DumpProtocolState();
#endif
    return fRetVal;
}

BOOL TransportProtocol::ResubmitQueriesIfNecessary(void)
/*++
Function Name: ResubmitQueriesIfNecessary

Parameters:

Description:
    Iterates through all protocols and calls their ResubmitQueriesIfNecessary

Returns:
    FALSE if at least one protocol needed to resubmit a query, but failed to do so
    TRUE otherwise

--*/
{
    int i;
    BOOL fAllResubmitsSucceeded = TRUE;
    TransportProtocol *pCurrentProtocol;

#ifdef MAJOR_PNP_DEBUG
    DbgPrint("Resubmitting queries for process %d\n", GetCurrentProcessId());
#endif

    EnterCriticalSection(&AddressListLock);

    for (i = 1; i < MAX_PROTOCOLS; i++)
        {
        pCurrentProtocol = GetTransportProtocol(i);
        if (!pCurrentProtocol->ResubmitQueriesIfNecessary(i))
            fAllResubmitsSucceeded = FALSE;
        }

    LeaveCriticalSection(&AddressListLock);

    return fAllResubmitsSucceeded;
}

void TransportProtocol::AddObjectToProtocolList(BASE_ASYNC_OBJECT *pObj)
{
    GetTransportProtocol(pObj->id)->AddObjectToList(pObj);
}

#if defined(DBG) || defined(_DEBUG)
void TransportProtocol::AssertProtocolListIntegrity(IN BASE_ASYNC_OBJECT *pObj)
{
    GetTransportProtocol(pObj->id)->AssertListIntegrity(pObj->id);
}
#endif  // DBG || _DEBUG

void TransportProtocol::RemoveObjectFromProtocolList(IN OUT BASE_ASYNC_OBJECT *pObj)
{
    // in some cases, we can legally have the id set to INVALID_PROTOCOL_ID
    // this happens when we have initialized the connection, but have failed
    // before calling Open on it, and then we attempt to destroy it
    if (pObj->id != INVALID_PROTOCOL_ID)
        {
        GetTransportProtocol(pObj->id)->RemoveObjectFromList(pObj);
        }
}

BOOL TransportProtocol::VerifyProtocolIsFunctional(IN PROTOCOL_ID ProtocolId)
/*++
    Function Name: VerifyProtocolIsFunctional

    Parameters: ProtocolId - the protocol which we're attempting to verify as functional or not

    Description: Tries to find out the listening address for a loaded protocol. The address
        itself is not used anywhere. It just testifies that the protocol is fully operational.
        Depending on how far it gets with testing whether the protocol is operational,
        it will change the State to ProtocolLoaded, ProtocolLoadedWithoutAddress or
        ProtocolWasLoadedOrNeedsActivationWithoutAddress. It will return TRUE iff the state is moved to
        ProtocolLoaded.

    Returns: TRUE if the address was found and the protocol was fully operational
             FALSE if the address could not be found, and the protocol is not
                fully operational. Note that there are two subcases here. One is when
                the protocol is not operational (or we cannot confirm that for lack of
                resources for example) and it has no sign of becoming operational. The
                second is when the protocol is not operational, but there are chances of
                it becoming operational. This happens with protocols that take some
                time to initialize. In the second case, this function will arrange for
                a retry attempt by posting an async WSAIoctl request to the completion
                port. In the current code base, we don't differentiate between the two
                cases because we don't need to. We may need to do so in the future.

--*/
{
    ASSERT((State == ProtocolNotLoaded) 
        || (State == ProtocolWasLoadedOrNeedsActivation) 
        || (State == ProtocolLoadedWithoutAddress) 
        || (State == ProtocolWasLoadedOrNeedsActivationWithoutAddress));

    ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);

    if (OpenAddressChangeRequestSocket(ProtocolId) == FALSE)
        goto AbortAndCleanup;

    // if the socket already has an address, skip further checks
    // NOTE: this check provides a fast way to check initialization state of
    // protocols that initialize quickly, but more importantly, it provides a
    // handling path for protocols that have submitted an address list change query
    // and now are getting back the result
    if (DoesAddressSocketHaveAddress())
        {

#ifdef MAJOR_PNP_DEBUG
        DbgPrint("Protocol %d is functional (1)\n", ProtocolId);
#endif

        CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
        SetStateToLoadedAndMonitorProtocolIfNecessary(ProtocolId);
        ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
        return TRUE;
        }

    // if there isn't a pending request, and there isn't a successful request (i.e. there is either
    // a failed request, or no request has been submitted so far)
    if ((addressChangeOverlapped.Internal != 0) && (addressChangeOverlapped.Internal != STATUS_PENDING))
        {
#ifdef MAJOR_PNP_DEBUG
        DbgPrint("Submitting WSAIoclt for protocol %d\n", ProtocolId);
#endif

        if (!SubmitAddressChangeQuery())
            goto AbortAndCleanup;
        }

    // check once more whether we have address - this takes care of the race where the
    // address did arrive between the time we checked for it in the beginning of this
    // function and the time we submitted the address change query
    if (DoesAddressSocketHaveAddress())
        {
#ifdef MAJOR_PNP_DEBUG
        DbgPrint("Protocol %d is functional (2)\n", ProtocolId);
#endif
        CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
        SetStateToLoadedAndMonitorProtocolIfNecessary(ProtocolId);
        ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
        return TRUE;
        }

    // regardless of whether we succeeded immediately or we are pending, advance the
    // state to ProtocolLoadedWithoutAddress and return not loaded. The completion at the
    // completion port will take care of the rest
    if (State == ProtocolWasLoadedOrNeedsActivation)
        SetState(ProtocolWasLoadedOrNeedsActivationWithoutAddress, ProtocolId);
    else if (State == ProtocolNotLoaded)
        SetState(ProtocolLoadedWithoutAddress, ProtocolId);
#ifdef MAJOR_PNP_DEBUG
    else
        {
        DbgPrint("VerifyProtocolIsFunctional did not change state for protocol %d, state: %s\n", ProtocolId,
            ProtocolStateNames[State]);
        }
#endif

    ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
    return FALSE;

AbortAndCleanup:
    // TRUE or FALSE for this argument doesn't matter here -
    // the operation has failed
    CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
    ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
    return FALSE;
}

BOOL TransportProtocol::DoesAddressSocketHaveAddress(void)
/*++
Function Name: DoesAddressSocketHaveAddress

Parameters:

Description:
    Checks if a valid address can be obtained for this protocol.

Returns:
    TRUE - a valid address could be obtained for this protocol
    FALSE - otherwise

--*/
{
    DWORD byteRet = 0;
    char buf[40];

    ASSERT(addressChangeSocket != 0);

    if (WSAIoctl(addressChangeSocket, SIO_ADDRESS_LIST_QUERY,
                 0, 0, buf, sizeof(buf), &byteRet, NULL, NULL) == SOCKET_ERROR)
        {
        return FALSE;
        }

    // if the result has non-zero length ...
    if (byteRet != 0)
        {
#if 0
        int i;
        DbgPrint("WSAIoctl returned:\n");
        for (i = 0; i < byteRet; i ++)
            {
            DbgPrint(" %X", (unsigned long) buf[i]);
            }
        DbgPrint("\nWSAIoctl with ADDRESS_LIST_QUERY returned addresses success\n");
#endif

        // ... and the resulting value is non zero ...
        if (*(long *)buf != 0)
            {
            // ... we have managed to get the true address
            return TRUE;
            }
        }

    return FALSE;
}

void TransportProtocol::CancelAddressChangeRequestIfNecessary(BOOL fForceCancel, IN PROTOCOL_ID ProtocolId)
/*++
Function Name: CancelAddressChangeRequestIfNecessary

Parameters:

Description:
    If there's an active WSAIoctl on the protocol, cancel it by closing the socket.

Returns:

--*/
{
    if (addressChangeSocket != 0)
        {
        // if the address change monitoring is off, or cancel is
        // forced, do the actual cancelling. That is, we don't
        // cancel if this is a monitored protocol and cancel is
        // optional
        if (!IsAddressChangeMonitoringOn(ProtocolId) || fForceCancel)
            {
#ifdef MAJOR_PNP_DEBUG
            DbgPrint("Address change request cancelled\n");
#endif
            closesocket(addressChangeSocket);
            addressChangeSocket = 0;
            addressChangeOverlapped.Internal = -1;
            }
        }
}

void TransportProtocol::RestartProtocol(PROTOCOL_ID ProtocolId)
/*++
Function Name: RestartProtocol

Parameters:
    ProtocolId - the protocol to be restarted.

Description:
    Restarts all addresses on this protocol.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *Obj;
    BOOL fAddressFound = 0;
    RPC_STATUS Status;
    LIST_ENTRY *CurrentEntry;

    VALIDATE(ProtocolId)
        {
        TCP,
#ifdef SPX_ON
        SPX,
#endif
#ifdef APPLETALK_ON
        DSP,
#endif
        HTTP,
        UDP,
#ifdef IPX_ON
        IPX,
#endif
        TCP_IPv6
        } END_VALIDATE;

    CurrentEntry = ObjectList.Flink;

    while(CurrentEntry != &ObjectList)
        {
        Obj = CONTAINING_RECORD(CurrentEntry, BASE_ASYNC_OBJECT, ObjectList);
        ASSERT(Obj->id == (int) ProtocolId);

        if (Obj->type & ADDRESS)
            {
            if (Obj->type & DATAGRAM)
                {
                Status = DG_ReactivateAddress((WS_DATAGRAM_ENDPOINT *) Obj);
                }
            else
                {
                Status = WS_ReactivateAddress((WS_ADDRESS *) Obj);
                }

            if (Status == RPC_S_OK)
                {
                fAddressFound = 1;
                COMMON_AddressManager((BASE_ADDRESS *) Obj);
                }
            }
        CurrentEntry = CurrentEntry->Flink;
        }

    if (fAddressFound)
        {
        COMMON_PostNonIoEvent(TRANSPORT, 0, NULL);
        }
}


void TransportProtocol::InitNewAddresses(PROTOCOL_ID ProtocolId)
/*++
Function Name: RestartProtocol

Parameters:
    ProtocolId - the protocol for which the addresses are to be
    initialized.

Description:
    Initializes transport address objects that listen on
    interfaces that were assigned addresses.  Works for TCP only.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *Obj;
    WS_ADDRESS *WsAddr;
    BASE_ADDRESS *pSavedFirstAddress, *pSavedNextAddress;
    BOOL fAddressFound = FALSE;
    RPC_STATUS Status;
    LIST_ENTRY *CurrentEntry;

    ASSERT(ProtocolId == TCP);

    // For each new address in the firewall table, find tranport address
    // objects that have not been initialized and make them listen on
    // the net address.  Make sure that a given transport address list
    // listens on all the available network addresses.

    // Go through the firewall table
    for (DWORD j = 0; j < pFirewallTable->NumAddresses; j++)
        {
        // Pick a newly-initialized and enabled address from the table.
        if (pFirewallTable->Entries[j].fNewAddress == FALSE
            || pFirewallTable->Entries[j].fEnabled == FALSE)
            {
            continue;
            }

        // Go through the list of transport addresses.
        CurrentEntry = ObjectList.Flink;
        while(CurrentEntry != &ObjectList)
            {
            Obj = CONTAINING_RECORD(CurrentEntry, BASE_ASYNC_OBJECT, ObjectList);

            ASSERT(Obj->id == (int) ProtocolId);

            WsAddr = (WS_ADDRESS *)Obj;

#ifdef MAJOR_TRANS_DEBUG
            DbgPrint("RPC: TransportProtocol::InitNewAddresses: Processing address 0x%x.\n", WsAddr);
#endif

            // Initialize the object if it is a TCP address that has not yet been initialized
            // and if the address list that it is a part of is not listening on all of the available
            // network addresses yet.
            if (Obj->type & ADDRESS
                && Obj->id == TCP
                && WsAddr->fAddressInitialized == FALSE
                && FirewallTableNumActiveEntries > ((WS_ADDRESS *)WsAddr->pFirstAddress)->NumActiveAddresses)
                {
                // Initialize the address from the firewall table entry.
                //
                // Note that we do not have to syncronize with the other users of
                // pFirewallTable since the only possible update would come from a PnP
                // notification and this function will be executing during a notification
                // after the table update.  UseProtseq* path does not modify an initialized table
                // and can't race with this path.

#ifdef MAJOR_TRANS_DEBUG
                DbgPrint("RPC: TransportProtocol::InitNewAddresses: Initializing address 0x%x from pFirewalTable entry with index 0x%x.\n", WsAddr, j);
#endif
                WsAddr->ListenAddr.inetaddr.sin_addr.s_addr = pFirewallTable->Entries[j].Address;

                // Pass in fResetAddressListEntries = FALSE since the address is already in the list
                // and the fields have been initialized.
                Status = WS_ReactivateAddress(WsAddr, FALSE);

#ifdef MAJOR_TRANS_DEBUG
                DbgPrint("RPC: TransportProtocol::InitNewAddresses: WS_ReactivateAddress for address 0x%x returned 0x%x.\n", WsAddr, Status);
#endif

                if (Status == RPC_S_OK)
                    {
                    WsAddr->fAddressInitialized = TRUE;
                    fAddressFound = TRUE;

                    ((WS_ADDRESS *)WsAddr->pFirstAddress)->NumActiveAddresses++;

                    COMMON_AddressManager((BASE_ADDRESS *) Obj);
                    }

                // Re-build the address vector.
                Status = IP_BuildAddressVector(
                               &(WsAddr->pFirstAddress->pAddressVector),
                               0, //OsfAddress->NICFlags,
                               NULL, // Not listening on a specific address.
                               (WS_ADDRESS *)WsAddr->pFirstAddress);

                // If we were not able to find an entry in the pFirewallTable to initialize this address,
                // there is nothing to do - wait for another address change event when the
                // NIC may finish initializing.
                //
                // Note that if an interface gets disabled, it may disapper from the pFirewallTable during
                // an update.  In this case, we will remain with un-initialized transport address objects,
                // but there is nothing that we can do about this since the interface on which they should have
                // listened is not up.
                }
            CurrentEntry = CurrentEntry->Flink;
            }
        }

    if (fAddressFound)
        {
        COMMON_PostNonIoEvent(TRANSPORT, 0, NULL);
        }
}

void TransportProtocol::UnloadProtocol(PROTOCOL_ID ProtocolId)
/*++
Function Name: UnloadProtocol

Parameters:
    ProtocolId - the protocol to be unloaded.

Description:
    Walks the list of the protocol transport objects. Closes the connections, and removes the
        addresses from the list. Thus failing requests on addresses will not be retried.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *Obj;
    LIST_ENTRY *CurrentEntry;

    VALIDATE(ProtocolId)
        {
        TCP,
#ifdef SPX_ON
        SPX,
#endif
#ifdef APPLETALK_ON
        DSP,
#endif
        HTTP,
        UDP,
#ifdef IPX_ON
        IPX,
#endif
        TCP_IPv6,
        HTTPv2
        } END_VALIDATE;

    CurrentEntry = ObjectList.Flink;

    //
    // - Cleanup all the objects (ie: close the socket).
    // - Remove all objects other than address objects
    //   from the list.
    //
    while(CurrentEntry != &ObjectList)
        {
        Obj = CONTAINING_RECORD(CurrentEntry, BASE_ASYNC_OBJECT, ObjectList);

        ASSERT(Obj->id == (int)ProtocolId);

        if (Obj->type & ADDRESS)
            {
            COMMON_RemoveAddress((BASE_ADDRESS *) Obj);
            }
        else
            {
            RpcpfRemoveEntryList(&Obj->ObjectList);
            
            if (ProtocolId != HTTPv2)
                WS_Abort(Obj);
            else
                HTTP_Abort(Obj);
            }

        CurrentEntry = CurrentEntry->Flink;
        }
}

BOOL TransportProtocol::SubmitAddressChangeQuery(void)
/*++
Function Name: SubmitAddressChangeQuery

Parameters:

Description:
    Submits an address change query (WSAIoctl)

Returns:
    TRUE if the WSAIoctl was successfully posted.
    FALSE otherwise

--*/
{
    ASSERT(addressChangeSocket != 0);
    static DWORD dwBytesReturned;

    //
    // Post an address list change request
    //
    addressChangeOverlapped.hEvent = 0;
    addressChangeOverlapped.Offset = 0;
    addressChangeOverlapped.OffsetHigh = 0;
    addressChangeOverlapped.Internal = 0;

    // submit the address change request - it will always complete on the completion port
    // we don't care about the dwBytesReturned. The provider requires a valid address, or
    // it rejects the request
    if (WSAIoctl(addressChangeSocket, SIO_ADDRESS_LIST_CHANGE,
                 0, 0, 0, 0, &dwBytesReturned, &addressChangeOverlapped, 0) == SOCKET_ERROR)
        {
        if (WSAGetLastError() != ERROR_IO_PENDING)
            {
#ifdef MAJOR_PNP_DEBUG
            DbgPrint("Submitting WSAIoclt failed with: %d\n", GetLastError());
#endif
            return FALSE;
            }
        }

    return TRUE;
}

void TransportProtocol::SetState(TransportProtocolStates newState, PROTOCOL_ID ProtocolId)
/*++
Function Name: SetState

Parameters:
    newState - the new state that the protocol needs to move to
    ProtocolId - the protocol number of this protocol

Description:
    Sets the state of the protocol. Nobody should write the state directly, because
        protocol state mirroring will stop working.

Returns:

--*/
{
    TransportProtocol *CurrentProtocol;

#ifdef MAJOR_PNP_DEBUG
    DbgPrint("Protocol %d moved from state: %s to state: %s\n", ProtocolId, ProtocolStateNames[State],
        ProtocolStateNames[newState]);
#endif

    // either the address change monitoring is not on for this protocol, or
    // the protocol doesn't move to loaded state, but not both
    ASSERT(!IsAddressChangeMonitoringOn(ProtocolId) || (newState != ProtocolLoaded));
    State = newState;
    if (ProtocolId == TCP)
        {
        // if a base protocols is moved into loaded and monitored, make sure
        // the trailing protocols doesn't follow it there. In such a case
        // the trailing protocol becomes only loaded
        if (newState == ProtocolLoadedAndMonitored)
            {
            GetTransportProtocol(HTTP)->State = ProtocolLoaded;
            }
        else
            {
            GetTransportProtocol(HTTP)->State = newState;
            }

        MirrorProtocolState(TCP_IPv6);
        }
    else if (ProtocolId == TCP_IPv6)
        {
        MirrorProtocolState(TCP);
        }
}

void TransportProtocol::SetStateToLoadedAndMonitorProtocolIfNecessary(PROTOCOL_ID ProtocolId)
{
    if (IsAddressChangeMonitoringOn(ProtocolId))
        {
        // monitor functional protocols for address change will
        // set the state
        MonitorFunctionalProtocolForAddressChange(ProtocolId);
        }
    else
        SetState(ProtocolLoaded, ProtocolId);
}

RPC_STATUS InitTransportProtocols(void)
/*++
Function Name: InitTransportProtocols

Parameters:

Description:
    Initializes all transport level protocols. This function should be called before
    any of the TransportProtocol functions.

Returns:

--*/
{
    TransportProtocolArray = new TransportProtocol[MAX_PROTOCOLS];
    if (TransportProtocolArray == NULL)
        return (RPC_S_OUT_OF_MEMORY);
    else
        return RPC_S_OK;
}

#if defined(DBG) || defined(_DEBUG)
void TransportProtocol::AssertTransportProtocolState(void)
/*++
Function Name: AssertTransportProtocolState

Parameters:

Description:
    Loops through all protocols and calls AssertState on them

Returns:

--*/
{
    int i;

    for (i = 1; i < MAX_PROTOCOLS; i ++)
        {
        GetTransportProtocol(i)->AssertState(i);
        }
}

void TransportProtocol::AssertState(PROTOCOL_ID ProtocolId)
/*++
Function Name: AssertState

Parameters:
    ProtocolId - the protocol number of the this protocol

Description:
    Currently this includes that addressChangeSocket is set only in the *WithoutAddress states
        and that all the objects in this protocol list are of the same protocol as this protocol.

Returns:

--*/
{
    // make sure that the internal state of the object is consistent
    ASSERT (State >= ProtocolNotLoaded);
    ASSERT (State <= ProtocolLoadedAndMonitored);

    if (IsTrailingProtocol(ProtocolId))
        {
        ASSERT(addressChangeSocket == 0);
        }
    else
        {
        // if we are in one of these states, there should be no address change request pending
        if ((State == ProtocolNotLoaded) 
            || (State == ProtocolWasLoadedOrNeedsActivation) 
            || (State == ProtocolLoaded))
            {
            ASSERT(addressChangeSocket == 0);
            }
        else
            {
            // if we are in one of the else states, there must be address change request pending
            ASSERT(addressChangeSocket != 0);
            }
        }

    AssertListIntegrity(ProtocolId);
}

void 
TransportProtocol::AssertListIntegrity (
    IN PROTOCOL_ID ProtocolId
    )
/*++

Routine Description:

    Verifies the integrity of the protocol list by walking
    through every entry and making sure it has the same (and
    expected) protocol id.

Arguments:

    ProtocolId - the protocol id of the current protocol

Return Value:

--*/
{
    BASE_ASYNC_OBJECT *pObject;
    LIST_ENTRY *CurrentEntry;
  
    EnterCriticalSection(&AddressListLock);

    // walk the object list and make sure every object is of the same protocol
    CurrentEntry = ObjectList.Flink;

    while (CurrentEntry != &ObjectList)
        {
        pObject = CONTAINING_RECORD(CurrentEntry, BASE_ASYNC_OBJECT, ObjectList);
        ASSERT(pObject->id == ProtocolId);
        CurrentEntry = CurrentEntry->Flink;
        }

    LeaveCriticalSection(&AddressListLock);
}

#endif

BOOL TransportProtocol::MonitorFunctionalProtocolForAddressChange(PROTOCOL_ID ProtocolId)
/*++
Function Name: MonitorFunctionalProtocolForAddressChange

Parameters:
    ProtocolId - the protocol id of the current protocol

Description:
    Makes sure that an already functional protocol is monitored for address change. This is done
    by:
    - if an address change socket does not exist, one is opened.
    - if no address change WSAIoctl is pending on the socket, one is posted.

Returns:
    TRUE if the posting of address change was successful
    FALSE if it wasn't

--*/
{
    BOOL bRetVal = FALSE;

    // OpenAddressChangeRequestSocket will take care to check whether there's already
    // a socket opened
    if (OpenAddressChangeRequestSocket(ProtocolId) == FALSE)
        goto Cleanup;

    if (addressChangeOverlapped.Internal != STATUS_PENDING)
        {
        if (SubmitAddressChangeQuery() == FALSE)
            goto Cleanup;
        }

    bRetVal = TRUE;
Cleanup:
    if (State != ProtocolLoadedAndMonitored)
        SetState(ProtocolLoadedAndMonitored, ProtocolId);

    return bRetVal;
}

BOOL TransportProtocol::OpenAddressChangeRequestSocket(PROTOCOL_ID ProtocolId)
/*++
Function Name: OpenAddressChangeRequestSocket

Parameters:
    ProtocolId - the protocol id of the current protocol

Description:
    Makes sure that an address change request socket is opened.

Returns:
    TRUE if the opening was successful
    FALSE if it wasn't

--*/
{
    const WS_TRANS_INFO *pInfo = &WsTransportTable[ProtocolId];
    HANDLE h;

    // we may end up with non-zero addressChangeSocket if this is an address change query
    // request coming back to us. In this case we don't need to open up another socket
    if (addressChangeSocket == 0)
        {
        ASSERT((State == ProtocolNotLoaded) 
            || (State == ProtocolWasLoadedOrNeedsActivation) 
            || (State == ProtocolLoaded));

        //
        // Create a socket
        //
        addressChangeSocket = WSASocketT(pInfo->AddressFamily,
                          pInfo->SocketType,
                          pInfo->Protocol,
                          0,
                          0,
                          WSA_FLAG_OVERLAPPED);
        if (addressChangeSocket == INVALID_SOCKET)
            {
            //
            // We should be able to at least open a socket on the protocol,
            // if not we got a bogus notification or we're out of resources
            addressChangeSocket = 0;
            return FALSE;
            }

        //
        // make the handle non-inheritable so it goes away when we close it.
        //
        if (FALSE == SetHandleInformation( (HANDLE) addressChangeSocket, HANDLE_FLAG_INHERIT, 0))
            {
            closesocket(addressChangeSocket);
            addressChangeSocket = 0;
            return FALSE;
            }

        // associate the socket with the completion port so that we get the notification there
        h = CreateIoCompletionPort((HANDLE)addressChangeSocket,
                               RpcCompletionPort,
                               NewAddress,
                               0);
        if (h == 0)
            {
            closesocket(addressChangeSocket);
            addressChangeSocket = 0;
            return FALSE;
            }
        else if (RpcCompletionPort != h)
            {
            ASSERT(RpcCompletionPort == h);
            CloseHandle(h);
            closesocket(addressChangeSocket);
            addressChangeSocket = 0;
            return FALSE;
            }
        
        }
    else
        {
        // we may have a protocol in state ProtocolNotLoaded, because we are just trying
        // to bring it to loaded state
        ASSERT((State == ProtocolLoadedWithoutAddress) 
            || (State == ProtocolWasLoadedOrNeedsActivationWithoutAddress) 
            || (State == ProtocolLoadedAndMonitored) || (State == ProtocolNotLoaded));
        }

#ifdef MAJOR_PNP_DEBUG
    DbgPrint("Socket was successfully opened for protocol %d\n", ProtocolId);
#endif

    return TRUE;
}

void 
TransportProtocol::MirrorProtocolState (
    IN PROTOCOL_ID MirrorProtocolId
    )
/*++
Function Name: MirrorProtocolState

Parameters:
    MirrorProtocolId - the protocol which is mirrored

Description:
    If this is one of the protocols in a dual stack configuration, change
    the other protocol into appropriate state

Returns:

--*/
{
    TransportProtocol *MirrorProtocol;

    MirrorProtocol = GetTransportProtocol(MirrorProtocolId);
    if ((State == ProtocolLoadedAndMonitored) || (State == ProtocolLoaded))
        {
        if (MirrorProtocol->State == ProtocolNotLoaded)
            {
            MirrorProtocol->SetState(ProtocolWasLoadedOrNeedsActivation, MirrorProtocolId);
            }
        else if (MirrorProtocol->State == ProtocolLoadedWithoutAddress)
            {
            MirrorProtocol->SetState(ProtocolWasLoadedOrNeedsActivationWithoutAddress, MirrorProtocolId);
            }
        }
}

#ifdef MAJOR_PNP_DEBUG
void TransportProtocol::DumpProtocolState(void)
/*++
Function Name: DumpProtocolState

Parameters:

Description:
    Iterates through all protocol and calls their DumpProtocolState

Returns:

--*/
{
    int i;

    DbgPrint("Dumping protocol state for process %d\n", GetCurrentProcessId());

    for (i = 1; i < MAX_PROTOCOLS; i ++)
        {
        GetTransportProtocol(i)->DumpProtocolState(i);
        }
}

const char *ProtocolStateNames[] = {"ProtocolNotLoaded", "ProtocolLoadedWithoutAddress" ,
                                    "ProtocolWasLoadedOrNeedsActivation", "ProtocolLoaded", 
                                    "ProtocolWasLoadedOrNeedsActivationWithoutAddress",
                                    "ProtocolLoadedAndMonitored"};


void TransportProtocol::DumpProtocolState(PROTOCOL_ID ProtocolId)
/*++
Function Name: DumpProtocolState

Parameters:
    ProtocolId - the protocol number for this protocol.

Description:
    Dumps all significant information for this protcool on the debugger

Returns:

--*/
{
    BASE_ASYNC_OBJECT *pCurrentObject;
    LIST_ENTRY *pCurrentEntry = ObjectList.Flink;
    int fFirstTime = TRUE;
    const RPC_CHAR *Protseq;

    if (TransportTable[ProtocolId].pInfo)
        Protseq = TransportTable[ProtocolId].pInfo->ProtocolSequence;
    else
        Protseq = L"(null)";

    DbgPrint("Protocol: %S\n", Protseq);
    DbgPrint("State: %s, Addr Change Socket: %X, Addr Change Overlapped: %X\n",
        ProtocolStateNames[State], addressChangeSocket, (ULONG_PTR)&addressChangeOverlapped);
    while (pCurrentEntry != &ObjectList)
        {
        if (fFirstTime)
            {
            DbgPrint("Object List:\n");
            fFirstTime = FALSE;
            }
        pCurrentObject = CONTAINING_RECORD(pCurrentEntry, BASE_ASYNC_OBJECT, ObjectList);
        DbgPrint("\t%X\n", (ULONG_PTR)pCurrentObject);
        pCurrentEntry = pCurrentEntry->Flink;
        }
}
#endif

TransportProtocol *TransportProtocolArray;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\nptrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nptrans.cxx

Abstract:

    Named pipes specific transport interface layer.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/18/1996    Bits 'n pieces
    MarioGo    10/30/1996    ASync RPC + client side

--*/

#include <precomp.hxx>

#include <rpcqos.h> // mtrt for I_RpcParseSecurity

//
// Support functions not exported to the runtime
//

// Hard coded world (aka EveryOne) SID
const SID World = { 1, 1, { 0, 0, 0, 0, 0, 1}, 0};

// Hard coded world (aka EveryOne) SID
const SID AnonymousLogonSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID};

RPC_STATUS
NMP_SetSecurity(
    IN NMP_ADDRESS *pAddress,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    If the caller supplies an SD this validates and makes a copy of the
    security descriptor.  Otherwise is generates a good default SD.

Arguments:

    ThisAddress - Supplies the address which will own the security descriptor.

    SecurityDescriptor - Supplies the security descriptor to be copied.

Return Value:

    RPC_S_OK - Everyone is happy; we successfully duplicated the security
        descriptor.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is invalid.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to duplicate the
        security descriptor.

--*/
{
    BOOL b;
    SECURITY_DESCRIPTOR_CONTROL    Control;
    DWORD Revision;
    DWORD BufferLength;

    if ( SecurityDescriptor == 0 )
        {
        // By default, RPC will create a SD which only allows the process owner to
        // create more pipe instances.  This prevents other users from stealing
        // the pipe.

        pAddress->SecurityDescriptor = new SECURITY_DESCRIPTOR;
        if (   pAddress->SecurityDescriptor == 0
            || !InitializeSecurityDescriptor(pAddress->SecurityDescriptor,
                                           SECURITY_DESCRIPTOR_REVISION) )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        // Open our thread token and pull out the owner SID.  This is SID will be
        // added to the DACL below.

        ASSERT(GetSidLengthRequired(SID_MAX_SUB_AUTHORITIES) <= 0x44);

        DWORD cTokenOwner = sizeof(TOKEN_OWNER) + 0x44;
        PVOID buffer[sizeof(TOKEN_OWNER) + 0x44];
        PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER)buffer;
        HANDLE hToken;

        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }

        b = GetTokenInformation(hToken, TokenOwner, pTokenOwner, cTokenOwner, &cTokenOwner);

        ASSERT(cTokenOwner <= sizeof(buffer));

        CloseHandle(hToken);

        if (!b)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }

        // Now allocate the ACL and add the owner and EveryOne (world) ACEs and Anonymous Logon ACESs

        DWORD size = 3*sizeof(ACCESS_ALLOWED_ACE) + sizeof(World) + sizeof(AnonymousLogonSid) + 0x44;
        PACL pdacl = new(size) ACL;
        ULONG ldacl = size + sizeof(ACL);

        if (NULL == pdacl)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        ASSERT(IsValidSid((PVOID)&World));
        ASSERT(IsValidSid((PVOID)&AnonymousLogonSid));

        InitializeAcl(pdacl, ldacl, ACL_REVISION);

        if (!AddAccessAllowedAce(pdacl, ACL_REVISION,
                                 (FILE_GENERIC_READ|FILE_GENERIC_WRITE)&(~FILE_CREATE_PIPE_INSTANCE),
                                 (PVOID)&World))
            {
            ASSERT(0);
            return(RPC_S_OUT_OF_RESOURCES);
            }
        if (!AddAccessAllowedAce(pdacl, ACL_REVISION,
                                 (FILE_GENERIC_READ|FILE_GENERIC_WRITE)&(~FILE_CREATE_PIPE_INSTANCE),
                                 (PVOID)&AnonymousLogonSid ))
            {
            ASSERT(0);
            return(RPC_S_OUT_OF_RESOURCES);
            }

        if (!AddAccessAllowedAce(pdacl, ACL_REVISION, FILE_ALL_ACCESS, pTokenOwner->Owner))
            {
            ASSERT(0);
            return(RPC_S_OUT_OF_RESOURCES);
            }

        if (!SetSecurityDescriptorDacl(pAddress->SecurityDescriptor, TRUE, pdacl, FALSE))
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }

        return(RPC_S_OK);
        }

    // Caller supplied SecurityDescriptor.  Make sure it is valid and, if needed, make a
    // self relative copy.

    if ( IsValidSecurityDescriptor(SecurityDescriptor) == FALSE )
        {
        return(RPC_S_INVALID_SECURITY_DESC);
        }

    if (FALSE == GetSecurityDescriptorControl(SecurityDescriptor, &Control, &Revision))
        {
        return(RPC_S_INVALID_SECURITY_DESC);
        }

    if (Control & SE_SELF_RELATIVE)
        {
        // Already self-relative, just copy it.

        BufferLength = GetSecurityDescriptorLength(SecurityDescriptor);
        ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR));
        pAddress->SecurityDescriptor = new(BufferLength
                                           - sizeof(SECURITY_DESCRIPTOR))
                                           SECURITY_DESCRIPTOR;
        if (pAddress->SecurityDescriptor == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        memcpy(pAddress->SecurityDescriptor, SecurityDescriptor, BufferLength);
        return(RPC_S_OK);
        }

    // Make self-relative and copy it.
    BufferLength = 0;
    b = MakeSelfRelativeSD(SecurityDescriptor, 0, &BufferLength);
    ASSERT(b == FALSE);
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
        return(RPC_S_INVALID_SECURITY_DESC);
        }

    //
    // self-relative SD's can be of different size than the original SD.
    //

    ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR_RELATIVE));
    pAddress->SecurityDescriptor = new(BufferLength
                                       - sizeof(SECURITY_DESCRIPTOR_RELATIVE))
                                   SECURITY_DESCRIPTOR;

    if (pAddress->SecurityDescriptor == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    b = MakeSelfRelativeSD(SecurityDescriptor,
                           pAddress->SecurityDescriptor,
                           &BufferLength);

    if (b == FALSE)
        {
        ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        delete pAddress->SecurityDescriptor;
        return(RPC_S_OUT_OF_MEMORY);
        }

    return(RPC_S_OK);
}

//
// Functions exported to the RPC runtime.
//

RPC_STATUS RPC_ENTRY
NMP_AbortHelper(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Closes a connection, will be called only before NMP_Close() and
    maybe called by several threads at once.  It must also handle
    the case where another thread is about to start IO on the connection.

Arguments:

    Connection - pointer to a server connection object to abort.

Return Value:

    RPC_S_OK

--*/
{
    HANDLE h;
    BOOL b;
    PNMP_CONNECTION p = (PNMP_CONNECTION)Connection;

    if (InterlockedIncrement(&p->fAborted) != 1)
        {
        // Another thread beat us to it.  Normal during a call to NMP_Close.
        return(RPC_S_OK);
        }

    I_RpcLogEvent(SU_TRANS_CONN, EV_ABORT, Connection, 0, 0, 1, 2);


    // Wait for any threads which are starting IO to do so.
    while(p->IsIoStarting())
        Sleep(1);

    RTL_SOFT_ASSERT(p->fAborted != 0 && p->IsIoStarting() == 0);

    if (p->type & SERVER)
        {
        if (fDontFlush == 0)
            {
            // This will block until all pending writes on the connection
            // have been read. Needed on the server which writes (example: a
            // a fault) and closes the connection.
            b = FlushFileBuffers(p->Conn.Handle);

            //
            // the above call can fail if the pipe was disconnected
            //
            }

        // Once a pipe instance has been disconnected, it can be reused
        // for a future client connection.  Each NMP address keeps a
        // small cache of free pipe instances.  This is a performance
        // optimization.

        ASSERT(p->pAddress);

        b = DisconnectNamedPipe(p->Conn.Handle);
        if (b)
            {
            // will zero out Conn.Handle if it fits in the cache
            p->pAddress->sparePipes.CheckinHandle(&(p->Conn.Handle));
            }
        // else nothing - code down below will close it

        h = p->Conn.Handle;
        }
    else
        {
        ASSERT(p->pAddress == 0);
        h = p->Conn.Handle;
        }

    if (h)
        {
        b = CloseHandle(h);
        ASSERT(b);
        }

    return(RPC_S_OK);
}

RPC_STATUS NMP_CONNECTION::Abort(void)
{
    return NMP_AbortHelper(this, 0);
}


RPC_STATUS
RPC_ENTRY
NMP_Close(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Actually cleans up the resources associated with a connection.
    This is called exactly once one any connection.  It may or
    may not have previously been aborted.

Arguments:

    ThisConnection - pointer to the connection object to close.

Return Value:

    RPC_S_OK

--*/
{
    BOOL b;
    HANDLE h;

    PNMP_CONNECTION p = (PNMP_CONNECTION)ThisConnection;

    NMP_AbortHelper(ThisConnection, fDontFlush);

    if (p->iLastRead)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Closing connection %p with left over data (%d) %p \n",
                       p,
                       p->iLastRead,
                       p->pReadBuffer));
        }

    TransConnectionFreePacket(p, p->pReadBuffer);
    p->pReadBuffer = 0;

    return(RPC_S_OK);
}

void RPC_ENTRY
NMP_ServerAbortListen(
    IN RPC_TRANSPORT_ADDRESS Address
    )
/*++

Routine Description:

    This routine will be called if an error occurs in setting up the
    address between the time that SetupWithEndpoint or SetupUnknownEndpoint
    successfully completed and before the next call into this loadable
    transport module.  We need to do any cleanup from Setup*.

Arguments:

    pAddress - The address which is being aborted.

Return Value:

    None

--*/
{
    NMP_ADDRESS *p = (NMP_ADDRESS *)Address;

    // p->Endpoint is actually a pointer into p->LocalEndpoint

    delete p->SecurityDescriptor;
    delete p->LocalEndpoint;
    delete p->pAddressVector;

    // These are zero except when everything is setup ok.

    ASSERT(p->hConnectPipe == 0);
    ASSERT(p->sparePipes.IsSecondHandleUsed() == FALSE);

    return;
}


RPC_STATUS
NMP_CreatePipeInstance(
    NMP_ADDRESS *pAddress
    )
/*++

Routine Description:

    Wrapper around CreateNamedPipe.

Return Value:

    RPC_S_OK - A new pipe instance created.
    RPC_P_FOUND_IN_CACHE - Found a pipe instance to recycle.

    RPC_S_OUT_OF_MEMORY
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INTERNAL_ERROR

--*/
{
    RPC_STATUS status;
    SECURITY_ATTRIBUTES sa;


    ASSERT(pAddress->hConnectPipe == 0);

    sa.lpSecurityDescriptor = pAddress->SecurityDescriptor;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);

    // See if there are any cached pipe instances to reuse.

    pAddress->hConnectPipe = pAddress->sparePipes.CheckOutHandle();
    if (pAddress->hConnectPipe)
        return(RPC_P_FOUND_IN_CACHE);

    // The cache is empty, create a new pipe instance

    pAddress->hConnectPipe = CreateNamedPipeW(pAddress->LocalEndpoint,
                                              PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                                              PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE,
                                              PIPE_UNLIMITED_INSTANCES,
                                              2048,
                                              2048,
                                              NMPWAIT_USE_DEFAULT_WAIT,
                                              &sa);

    if (pAddress->hConnectPipe != INVALID_HANDLE_VALUE)
        {
        return(RPC_S_OK);
        }

    pAddress->hConnectPipe = 0;
    switch(GetLastError())
        {
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_NOT_ENOUGH_QUOTA:
        case ERROR_NO_SYSTEM_RESOURCES:
            {
            status = RPC_S_OUT_OF_MEMORY;
            break;
            }
        case ERROR_FILE_NOT_FOUND:
        case ERROR_INVALID_NAME:
        case ERROR_PATH_NOT_FOUND:
            {
            status = RPC_S_INVALID_ENDPOINT_FORMAT;
            break;
            }
        case ERROR_ACCESS_DENIED:
            {
            // An odd mapping, but this error means the pipe already exists
            // which is what this error means.
            status = RPC_S_DUPLICATE_ENDPOINT;
            break;
            }
        default:
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "CreateNamedPipe failed: %d\n",
                           GetLastError() ));

            ASSERT(0);
            status = RPC_S_INTERNAL_ERROR;
            }
        }

    return(status);
}


inline
RPC_STATUS
NMP_ConnectNamedPipe(
    NMP_ADDRESS *pAddress
    )
/*++

Routine Description:

    Inline wrapper for ConnectNamedPipe.

Arguments:

    pAddress - The address to use to connect.

Return Value:

    RPC_S_OK
    ConnectNamedPipe() error
--*/
{
    RPC_STATUS status;

    BOOL b = ConnectNamedPipe(pAddress->hConnectPipe,
                              &pAddress->Listen.ol);

    if (!b)
        {
        status = GetLastError();

        switch(status)
            {
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_IO_PENDING:
            case ERROR_PIPE_CONNECTED:
            case ERROR_NO_SYSTEM_RESOURCES:
                {
                break;
                }

            case ERROR_NO_DATA:
                {
                b = CloseHandle(pAddress->hConnectPipe);
                ASSERT(b);
                pAddress->hConnectPipe = 0;
                break;
                }

            default:
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "ConnectNamedPipe failed: %d\n",
                               status));

                ASSERT(0);
                }
            }
        }
    else
        {
        status = RPC_S_OK;
        }

    return(status);
}


void
NMP_SubmitConnect(
    IN BASE_ADDRESS *Address
    )
/*++

Routine Description:

    Called on an address without a pending connect pipe or on an address
    who previous connect pipe has been aborted.

Arguments:

    Address - The address to submit the connect on.

Return Value:

    None

--*/
{
    RPC_STATUS status;
    NMP_ADDRESS *pAddress = (NMP_ADDRESS *)Address;
    BOOL b;

    //
    // We may or may not need to create a new instance.  If a previous
    // ConnectNamedPipe was aborted then the existing instance is ok.
    //

    if (pAddress->hConnectPipe == 0)
        {

        status = NMP_CreatePipeInstance(pAddress);

        if (status == RPC_S_OK)
            {
            status = COMMON_PrepareNewHandle(pAddress->hConnectPipe);
            }
        else
            {
            if (status == RPC_P_FOUND_IN_CACHE)
                {
                status = RPC_S_OK;
                }
            }

        if (status != RPC_S_OK)
            {
            if (pAddress->hConnectPipe)
                {
                b = CloseHandle(pAddress->hConnectPipe);
                ASSERT(b);
                pAddress->hConnectPipe = 0;
                }

            COMMON_AddressManager(pAddress);
            return;
            }
        }

    status = NMP_ConnectNamedPipe(pAddress);

    if (status == ERROR_PIPE_CONNECTED)
        {
        // When a client connects here means that there will not be an IO
        // completion notification for this connection. We could call
        // NMP_NewConnection here but that makes error handling hard.  We'll
        // just post the notification directly.

        b = PostQueuedCompletionStatus(RpcCompletionPort,
                                       0,
                                       TRANSPORT_POSTED_KEY,
                                       &pAddress->Listen.ol);

        if (!b)
            {
            // Give up on this connection.
            b = CloseHandle(pAddress->hConnectPipe);
            ASSERT(b);
            pAddress->hConnectPipe = 0;
            COMMON_AddressManager(pAddress);
            }
        return;
        }

    if (status != ERROR_I