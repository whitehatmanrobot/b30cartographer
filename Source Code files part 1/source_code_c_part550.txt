hineGuid,
                  &lpszGuid ) ;

    LogMigrationEvent(MigLog_Info, MQMig_I_MACHINE_MIGRATED,
                                     iIndex,
                                     wszMachineName,
                                     lpszGuid) ;
    RpcStringFree( &lpszGuid ) ;
#endif
       
    HRESULT hr = MQMig_OK;

    if (!IsObjectNameValid(wszMachineName))
    {
        //
        // machine name is invalid
        //
        hr = _HandleMachineWithInvalidName (wszMachineName, pMachineGuid);
        if (FAILED(hr))
        {
            return hr ;        
        }
    }

    if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return MQMig_OK ;
    }
    
    BOOL fIsInsertPKey = IsInsertPKey (pMachineGuid);

    #define MAX_MACHINE_PROPS 19   
    PROPID propIDs[ MAX_MACHINE_PROPS ];
    PROPVARIANT propVariants[ sizeof(propIDs) / sizeof(propIDs[0]) ];
    DWORD iProperty =0;   
                   
    //
    // get OS from pColumns
    // 
    DWORD dwOS = (DWORD) pColumns[ e_OSIndex ].nColumnValue;

    propIDs[iProperty] = PROPID_QM_MACHINE_TYPE;
    propVariants[iProperty].vt = VT_LPWSTR;
    propVariants[iProperty].pwszVal = (LPWSTR) pColumns[ e_MTypeIndex ].nColumnValue;
	iProperty++;
                
    propIDs[iProperty] = PROPID_QM_OS;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = dwOS ;
	iProperty++;
          
    propIDs[iProperty] = PROPID_QM_QUOTA;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = (DWORD) pColumns[ e_QuotaIndex].nColumnValue;
	iProperty++;

    propIDs[iProperty] = PROPID_QM_JOURNAL_QUOTA;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = (DWORD) pColumns[ e_JQuotaIndex].nColumnValue;
	iProperty++;
     
    //
    // BUG 5307: handle in/out frss.
    // init out and in frss arrays. There is no more than 3 out/in frss.
    //      
    AP<GUID> pguidOutFRS = NULL;
    AP<GUID> pguidInFRS = NULL;    
    UINT uiFrsCount = 0;    

    //
    // get service and foreign flag from pColumns
    //     
    DWORD dwService = (DWORD) pColumns[ e_ServiceIndex ].nColumnValue ;
    BOOL fForeign = (BOOL)  pColumns[ e_ForeignIndex ].nColumnValue;

    if (dwService == SERVICE_NONE && !fForeign)
    {       
        hr = GetFRSs (pColumns, e_OutFrs1Index, &uiFrsCount, &pguidOutFRS);                 

        propIDs[iProperty] = PROPID_QM_OUTFRS;
        propVariants[iProperty].vt = VT_CLSID | VT_VECTOR ;
        propVariants[iProperty].cauuid.cElems = uiFrsCount ;
        propVariants[iProperty].cauuid.pElems = pguidOutFRS ;
        iProperty++;

        hr = GetFRSs (pColumns, e_InFrs1Index, &uiFrsCount, &pguidInFRS);                 

        propIDs[iProperty] = PROPID_QM_INFRS;
        propVariants[iProperty].vt = VT_CLSID | VT_VECTOR ;
        propVariants[iProperty].cauuid.cElems = uiFrsCount ;
        propVariants[iProperty].cauuid.pElems = pguidInFRS ;
        iProperty++;
    }       
    
    P<BYTE> pSignKey = NULL; 
    P<BYTE> pEncrptKey = NULL; 

    if (fIsInsertPKey)
    {
        //
        // fIsInsertPKey may be set to FALSE in the only case:
        // migration tool run on the PEC not at first time
        // (i.e. PEC machine object already exist in ADS) and
        // current machine pwzMachineName is the PEC machine.        
        //
        // Bug 5328: create computer with all properties including public keys
        //        
        ULONG ulSize = 0;        

        hr = PreparePBKeysForNT5DS( 
                    pColumns,
                    e_Sign1Index,
                    e_Sign2Index,
                    &ulSize,
                    (BYTE **) &pSignKey
                    );

        if (SUCCEEDED(hr))
        {
            propIDs[iProperty] = PROPID_QM_SIGN_PKS;
            propVariants[iProperty].vt = VT_BLOB;
            propVariants[iProperty].blob.pBlobData = pSignKey ;
            propVariants[iProperty].blob.cbSize = ulSize ;
            iProperty++;
        }
        else if (hr != MQMig_E_EMPTY_BLOB)        
        {
            //
            // I don't change the logic:
            // in the previous version if returned error is MQMig_E_EMPTY_BLOB 
            // we return MQMig_OK but did not set properties.
            // For any other error we return hr as is.
            //
            // return here: we don't create machine without its public key
            //            
            LogMigrationEvent(MigLog_Error, MQMig_E_PREPARE_PKEY, wszMachineName, hr) ;
            return hr;
        }

        ulSize = 0;        

        hr = PreparePBKeysForNT5DS( 
                    pColumns,
                    e_Encrpt1Index,
                    e_Encrpt1Index,
                    &ulSize,
                    (BYTE **) &pEncrptKey
                    );
        
        if (SUCCEEDED(hr))
        {
            propIDs[iProperty] = PROPID_QM_ENCRYPT_PKS,  
            propVariants[iProperty].vt = VT_BLOB;
            propVariants[iProperty].blob.pBlobData = pEncrptKey ;
            propVariants[iProperty].blob.cbSize = ulSize ;
            iProperty++;
        }
        else if (hr != MQMig_E_EMPTY_BLOB)        
        {
            //
            // I don't change the logic:
            // in the previous version if returned error is MQMig_E_EMPTY_BLOB 
            // we return MQMig_OK but did not set properties.
            // For any other error we return hr as is.
            //
            // return here: we don't create machine without its public key
            // 
            LogMigrationEvent(MigLog_Error, MQMig_E_PREPARE_PKEY, wszMachineName, hr) ;  
            return hr;
        }
    }
    
    //
    // we have to set this property too. It is good for foreign machines and solve 
    // connector problem when we run migtool with switch /w.
    //

    DWORD     dwNumSites = 0;    	
    AP<GUID>  pguidSites = NULL ;

    hr = GetAllMachineSites (   pMachineGuid,
                                wszMachineName,
                                pOwnerGuid,
                                fForeign,
                                &dwNumSites,
                                &pguidSites,
                                pfIsConnector) ;
    CHECK_HR(hr) ;
    ASSERT(dwNumSites > 0) ;

    propIDs[iProperty] = PROPID_QM_SITE_IDS;
	propVariants[iProperty].vt = VT_CLSID | VT_VECTOR ;
    propVariants[iProperty].cauuid.cElems = dwNumSites ;
    propVariants[iProperty].cauuid.pElems = pguidSites ;
	iProperty++;
    
    DWORD SetPropIdCount = iProperty;

    //
    // all properties below are for create object only!
    //

    BOOL fWasServerOnCluster = FALSE;
    if (g_fClusterMode &&			    // it is cluster mode
	    dwService == g_dwMyService) 	// current machine is former PEC/PSC on cluster

    {
        //
        // we have to change service to SERVICE_SRV since
        // this local machine will be PEC and former PEC on cluster will be FRS.
        //
        dwService = SERVICE_SRV;
        //
        // we need guid of former PEC for the future purpose (see database.cpp)
        //
        memcpy (&g_FormerPECGuid, pMachineGuid, sizeof(GUID));
        fWasServerOnCluster = TRUE;

        //
        // This fixes the problem of PEC + only ONE PSC. Otherwise, the
        // migration tool won't start the replication service.
        //
        g_iServerCount++;
    }
    propIDs[iProperty] = PROPID_QM_OLDSERVICE;    
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = dwService ;
	iProperty++;
    
    propIDs[iProperty] = PROPID_QM_SERVICE_ROUTING;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = ((dwService == SERVICE_SRV) ||
                                    (dwService == SERVICE_BSC) ||
                                    (dwService == SERVICE_PSC) ||
                                    (dwService == SERVICE_PEC));
	iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DSSERVER;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = ((dwService == SERVICE_PEC) ||
                                    (dwService == SERVICE_BSC) ||
                                    (dwService == SERVICE_PSC));
	iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (dwService != SERVICE_NONE);
	iProperty++;    

    if (fWasServerOnCluster)
    {
        //
        // bug 5423.
        // We try to set properties if we run on PSC. In case of PSC on cluster
        // we have to change all service properties of former PSC on cluster
        // when we run migtool on new installed DC (instead of PSC).
        //
        SetPropIdCount = iProperty;
    }

    propIDs[iProperty] = PROPID_QM_NT4ID ;
    propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = pMachineGuid ;
	iProperty++;
       
    if (fForeign)
    {
        propIDs[iProperty] = PROPID_QM_FOREIGN ;
        propVariants[iProperty].vt = VT_UI1 ;
        propVariants[iProperty].bVal = 1 ;
	    iProperty++;
    }
                                     
    propIDs[iProperty] = PROPID_QM_MASTERID;
	propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = pOwnerGuid ;
	iProperty++;

    //
    // get security descriptor from pColumns
    // 
    P<BYTE> pSD = NULL ;        
    DWORD  dwSDIndexs[3] = { e_SecD1Index, e_SecD2Index, e_SecD3Index } ;
    hr =  BlobFromColumns( pColumns,
                           dwSDIndexs,
                           3,
                           (BYTE**) &pSD ) ;
    CHECK_HR(hr) ;
    SECURITY_DESCRIPTOR *pMsd =
                      (SECURITY_DESCRIPTOR*) (pSD + sizeof(DWORD)) ;

    if (pMsd)
    {
        propIDs[iProperty] = PROPID_QM_SECURITY ;
        propVariants[iProperty].vt = VT_BLOB ;
    	propVariants[iProperty].blob.pBlobData = (BYTE*) pMsd ;
    	propVariants[iProperty].blob.cbSize =
                                     GetSecurityDescriptorLength(pMsd) ;
	    iProperty++ ;
    }   

    ASSERT(iProperty <= MAX_MACHINE_PROPS) ;
    
    if (dwService >= SERVICE_BSC)
    {
        g_iServerCount++;
    }

    hr = CreateMachineObjectInADS (
            dwService,
            fWasServerOnCluster,
            pOwnerGuid,
            pMachineGuid,
            wszSiteName,
            wszMachineName,
            SetPropIdCount,
            iProperty,
            propIDs,
            propVariants
            );

    return hr ;
}


//+--------------------------------------------------------------
//
//  HRESULT GetDemoteService()
//
//+--------------------------------------------------------------

static DWORD GetDemoteService()
{
	//
	// Demote the servers to FRS.
	//
	return SERVICE_SRV;
}


//------------------------------------------------------
//
//  static HRESULT _CreateSiteLinkForConector
//
//  This machine is connector. The routine create site links
//  between original NT4 site and each machine's foreign site.
//
//------------------------------------------------------
static HRESULT _CreateSiteLinkForConnector (
                        IN LPWSTR   wszMachineName,
                        IN GUID     *pOwnerId,
                        IN GUID     *pMachineId
                        )
{    
    TCHAR *pszFileName = GetIniFileName ();

    TCHAR tszSectionName[50];

    _stprintf(tszSectionName, TEXT("%s - %s"), 
        MIGRATION_CONNECTOR_FOREIGNCN_NUM_SECTION, wszMachineName);

    ULONG ulForeignCNCount = GetPrivateProfileInt(
							      tszSectionName,	// address of section name
							      MIGRATION_CONNECTOR_FOREIGNCN_NUM_KEY,    // address of key name
							      0,							// return value if key name is not found
							      pszFileName					// address of initialization filename);
							      );
    if (ulForeignCNCount == 0)
    {
	    LogMigrationEvent(MigLog_Error, MQMig_E_GET_CONNECTOR_FOREIGNCN, 
            pszFileName, wszMachineName) ;        
        return MQMig_E_GET_CONNECTOR_FOREIGNCN;
    }

    //
    // get full machine name
    //
    AP<WCHAR> wszFullPathName = NULL;
    HRESULT hr = GetFullPathNameByGuid ( *pMachineId,
                                         &wszFullPathName );
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_FULLPATHNAME, wszMachineName, hr) ;        
        return hr;
    }

    BOOL fIsCreated = FALSE;

    unsigned short *lpszOwnerId ;	        
    UuidToString( pOwnerId, &lpszOwnerId ) ;  

    for (ULONG ulCount=0; ulCount<ulForeignCNCount; ulCount++)
    {		        				
        //
        // get guid of foreign cn: it is neigbor2 in the site link 
        // neighbor1 is OwnerId.
        //
        GUID Neighbor2Id = GUID_NULL;
        TCHAR szGuid[50];

        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_CONNECTOR_FOREIGNCN_KEY, ulCount + 1);  

        DWORD dwRetSize =  GetPrivateProfileString(
                                  wszMachineName,			// points to section name
                                  tszKeyName,	// points to key name
                                  TEXT(""),                 // points to default string
                                  szGuid,          // points to destination buffer
                                  50,                 // size of destination buffer
                                  pszFileName               // points to initialization filename);
                                  );
        UNREFERENCED_PARAMETER(dwRetSize);

        if (_tcscmp(szGuid, TEXT("")) == 0)
        {			
            LogMigrationEvent(MigLog_Error, MQMig_E_GET_CONNECTOR_FOREIGNCN, 
                pszFileName, wszMachineName) ;  
            hr = MQMig_E_GET_CONNECTOR_FOREIGNCN;
            break;
        }	
        UuidFromString(&(szGuid[0]), &Neighbor2Id);


        //
        // create new site link between NT4 site and current foreign site
        //                 
        hr = MigrateASiteLink (
                    NULL,
                    pOwnerId,     //neighbor1
                    &Neighbor2Id,   //neighbor2
                    1,      //DWORD dwCost, What is the default value?
                    1,      // number of site gate
                    wszFullPathName,    // site gate
                    ulCount 
                    );

        if (SUCCEEDED(hr))
        {
            LogMigrationEvent(MigLog_Event, 
                    MQMig_I_CREATE_SITELINK_FOR_CONNECTOR, 
                    wszMachineName, lpszOwnerId, szGuid) ; 
            fIsCreated = TRUE;
        }
        else            
        {                          
            LogMigrationEvent(MigLog_Error, 
                MQMig_E_CANT_CREATE_SITELINK_FOR_CONNECTOR, 
                wszMachineName, lpszOwnerId, szGuid, hr) ; 
            break;
        }
    }

    //
    // remove these sections from .ini
    //
    BOOL f = WritePrivateProfileString( 
                            tszSectionName,
                            NULL,
                            NULL,
                            pszFileName ) ;
    ASSERT(f) ;

    f = WritePrivateProfileString( 
                        wszMachineName,
                        NULL,
                        NULL,
                        pszFileName ) ;
    ASSERT(f) ;    

    if (fIsCreated)
    {
        //
        // save NT4 site name in .ini file to replicate site gate later 
        // 
        ULONG ulSiteNum = GetPrivateProfileInt(
                                    MIGRATION_CHANGED_NT4SITE_NUM_SECTION,	// address of section name
                                    MIGRATION_CHANGED_NT4SITE_NUM_KEY,      // address of key name
                                    0,							    // return value if key name is not found
                                    pszFileName					    // address of initialization filename);
                                    );

        //
        // save new number of changed NT4 site in .ini file
        //
        ulSiteNum ++;
        TCHAR szBuf[10];
        _ltot( ulSiteNum, szBuf, 10 );
        f = WritePrivateProfileString(  MIGRATION_CHANGED_NT4SITE_NUM_SECTION,
                                        MIGRATION_CHANGED_NT4SITE_NUM_KEY,
                                        szBuf,
                                        pszFileName ) ;
        ASSERT(f) ;

        //
        // save site name in .ini file
        //
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), 
	        MIGRATION_CHANGED_NT4SITE_KEY, ulSiteNum);

        f = WritePrivateProfileString( 
                                MIGRATION_CHANGED_NT4SITE_SECTION,
                                tszKeyName,
                                lpszOwnerId,
                                pszFileName ) ;
        ASSERT(f);
    }

    RpcStringFree( &lpszOwnerId ) ;

    return hr;
}


static BOOL ParseDn(LPWSTR Dn, LPWSTR* ppName, DWORD* pLength)
{
	ASSERT(Dn != NULL);
	ASSERT(pLength != NULL);
	
	*ppName = wcschr(Dn, DS_SERVER_SEPERATOR_SIGN);
	if (*ppName == NULL)
	{
		return FALSE;
	}

    *ppName = wcschr(*ppName, L'=');
    if (*ppName == NULL)
	{
		return FALSE;
	}

	(*ppName)++;
	if (*ppName == NULL)
	{
		return FALSE;
	}
    
	LPWSTR EndName = wcschr(*ppName, DS_SERVER_SEPERATOR_SIGN);
	if (EndName == NULL)
	{
		return FALSE;
	}
	
	*pLength = static_cast<DWORD> (EndName-*ppName+1);
	return TRUE;
}

//+--------------------------------------------------------------
//
//  HRESULT GetMQISName()
//
//+--------------------------------------------------------------

static wstring GetMQISName()
{	
	//
	// Max length for Win95, Win98 and WinMe
	//
	#define MAX_KEY_LENGTH 255
	const NumOfLoops = 5;
	static WCHAR s_MQISServerList[MAX_KEY_LENGTH] = L"";
	static bool s_fInitialized = false;
	static DWORD s_LoopCounter = 0;

	
	if (s_LoopCounter == NumOfLoops)
	{	
		//
		// Scramble names for load balancing.
		//
		LPWSTR StartString = wcschr(s_MQISServerList, DS_SERVER_SEPERATOR_SIGN);
		if (StartString != NULL)
		{
			//
			// This means that we have more than one name in the list. Scramble names. 
			//
			*StartString = L'\0';
			StartString++;

			LPWSTR EndString = s_MQISServerList;
			
			wstring NewServersList = StartString;
			NewServersList += L",";
			NewServersList += EndString;

			wcsncpy(s_MQISServerList, NewServersList.c_str(), STRLEN(s_MQISServerList));
			s_MQISServerList[STRLEN(s_MQISServerList)] = L'\0';			
		}
	}

	s_LoopCounter = s_LoopCounter%NumOfLoops;
	s_LoopCounter++;
	
	if (s_fInitialized)
	{
		return s_MQISServerList;
	}

	wstring TempList = L"10";
	TempList +=  g_MachineName;
    
    CColumns   Colset;
	Colset.Add(PROPID_SET_FULL_PATH);

    CRestriction Restriction;
	Restriction.AddRestriction(SERVICE_BSC, PROPID_SET_SERVICE, PREQ);
	Restriction.AddRestriction((SHORT)FALSE, PROPID_SET_NT4, PRGE);

	HANDLE hQuery;

	CDSRequestContext requestDsServerInternal1(e_DoNotImpersonate, e_IP_PROTOCOL);

	//
	// Get all BSCs
	//
    HRESULT hr = DSCoreLookupBegin(
					0,
					Restriction.CastToStruct(), 
					Colset.CastToStruct(),
					NULL,
					&requestDsServerInternal1,
					&hQuery
					);

	DWORD dwProps = 1;
    PROPVARIANT Result[1];
    while (SUCCEEDED(hr = DSCoreLookupNext(hQuery, &dwProps, Result)))
    {
		if (dwProps == 0)
		{
			DSCoreLookupEnd(hQuery);
			break;
		}

		if (Result->vt == VT_LPWSTR)
		{
		    AP<WCHAR> pCleanup = Result->pwszVal;	
		    
		    LPWSTR pStartName;
		    DWORD NameLength;
		    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH];
		    if (ParseDn(Result->pwszVal, &pStartName, &NameLength) )
		    {
		    	ASSERT(NameLength < MAX_COMPUTERNAME_LENGTH);
				wcsncpy(ComputerName, pStartName, NameLength-1);
				ComputerName[NameLength-1] = L'\0';
		    }
		    
			if (_wcsicmp(ComputerName, g_MachineName) != 0)
			{
				TempList += L",";
				TempList +=  L"10";
				TempList += ComputerName;
			}
		}
    }

	ASSERT(wcscmp(TempList.c_str(), L"") != 0);
	
    _snwprintf(s_MQISServerList, STRLEN(s_MQISServerList), L"%s", TempList.c_str());
	s_MQISServerList[STRLEN(s_MQISServerList)] = L'\0';
	s_fInitialized = true;
    return s_MQISServerList;
}


//-------------------------------------------
//
//  HRESULT UpdateMachineRegistry(LPWSTR MachineName)
//
//-------------------------------------------

static HRESULT UpdateMachineRegistry(LPWSTR MachineName, DWORD Service)
{	
	if (_wcsicmp(MachineName, g_MachineName) == 0)
	{
		//
		// No need to update
		//
		return MQ_OK;
	}

	DWORD ErrorMsg;
	if (Service == SERVICE_NONE)
	{
		ErrorMsg = MQMig_E_CANT_UPDATE_REMOTE_REGISTRY_CLIENT;
	}
	else
	{
		ErrorMsg = MQMig_E_CANT_UPDATE_REMOTE_REGISTRY_SERVER;
	}

	wstring MQISServerValue = GetMQISName();
	
	CAutoCloseRegHandle hMainKey;
	LONG rc = RegConnectRegistry(MachineName, HKEY_LOCAL_MACHINE, &hMainKey);
	if (rc != ERROR_SUCCESS)
	{
		LogMigrationEvent(MigLog_Error, ErrorMsg, MQISServerValue.c_str(), MachineName, HRESULT_FROM_WIN32(rc));
		return (HRESULT_FROM_WIN32(rc));
	}

	CAutoCloseRegHandle hKey; 
	rc = RegOpenKey(hMainKey, L"Software\\Microsoft\\MSMQ\\Parameters\\MachineCache", &hKey);
	if (rc != ERROR_SUCCESS)
	{
		LogMigrationEvent(MigLog_Error, ErrorMsg, MQISServerValue.c_str(), MachineName, HRESULT_FROM_WIN32(rc));
		return (HRESULT_FROM_WIN32(rc));
	}

	
	rc = RegSetValueEx(hKey, L"MQISServer", 0, REG_SZ, (BYTE*)MQISServerValue.c_str(), sizeof(WCHAR)*wcslen(MQISServerValue.c_str())+1);
	if (rc != ERROR_SUCCESS)
	{
		LogMigrationEvent(MigLog_Error, ErrorMsg, MQISServerValue.c_str(), MachineName, HRESULT_FROM_WIN32(rc));
		return (HRESULT_FROM_WIN32(rc));
	}

	if ((Service != SERVICE_SRV) && (Service != SERVICE_NONE))
	{
		//
		// Demote - Change to FRS
		//
		DWORD MQSValue = GetDemoteService();
		rc = RegSetValueEx(hKey, L"MQS", 0, REG_DWORD, (BYTE*)&MQSValue, sizeof(DWORD));
		if (rc != ERROR_SUCCESS)
		{
			LogMigrationEvent(MigLog_Error, ErrorMsg, MQISServerValue.c_str(), MachineName, HRESULT_FROM_WIN32(rc));
			return (HRESULT_FROM_WIN32(rc));
		}
	}
	
	return MQ_OK;
}



#define INIT_MACHINE_COLUMN(_ColName, _Index)            \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    _Index++ ;


//-------------------------------------------
//
//  HRESULT MigrateMachines(UINT cMachines)
//
//-------------------------------------------

HRESULT MigrateMachines(IN UINT   cMachines,
                        IN GUID  *pSiteGuid,
                        IN LPWSTR pwszSiteName)
{
    ASSERT(cMachines != 0) ;

    LONG cAlloc = 22 ;
    LONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;                    

    ASSERT(e_GuidIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_QMID,           cbColumns) ;
    
    ASSERT(e_Name1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_NAME1,          cbColumns) ;    

    ASSERT(e_Name2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_NAME2,          cbColumns) ;
    
    ASSERT(e_ServiceIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_SERVICES,       cbColumns) ;    

    ASSERT(e_QuotaIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_QUOTA,          cbColumns) ;
      
    ASSERT(e_JQuotaIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_JQUOTA,         cbColumns) ;

    ASSERT(e_OSIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_OS,             cbColumns) ;

    ASSERT(e_MTypeIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_MTYPE,          cbColumns) ;         

    ASSERT(e_ForeignIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_FOREIGN,        cbColumns) ;

    ASSERT(e_Sign1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SIGNCRT1,       cbColumns) ;

    ASSERT(e_Sign2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SIGNCRT2,       cbColumns) ;

    ASSERT(e_Encrpt1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_ENCRPTCRT1,     cbColumns) ;

    ASSERT(e_Encrpt2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_ENCRPTCRT2,     cbColumns) ;   

    ASSERT(e_SecD1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SECURITY1,      cbColumns) ;

    ASSERT(e_SecD2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SECURITY2,      cbColumns) ;

    ASSERT(e_SecD3Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SECURITY3,      cbColumns) ;    

    //
    // BUGBUG: save this column order for out and in frss!   
    // we based on such order later!
    //        
    ASSERT(e_OutFrs1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_OUTFRS1,        cbColumns) ;

    ASSERT(e_OutFrs2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_OUTFRS2,        cbColumns) ;

    ASSERT(e_OutFrs3Index == cbColumns);
    INIT_MACHINE_COLUMN(M_OUTFRS3,        cbColumns) ;

    ASSERT(e_InFrs1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_INFRS1,         cbColumns) ;

    ASSERT(e_InFrs2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_INFRS2,         cbColumns) ;

    ASSERT(e_InFrs3Index == cbColumns);
    INIT_MACHINE_COLUMN(M_INFRS3,         cbColumns) ;

    #undef  INIT_MACHINE_COLUMN

    //
    // Restriction. query by machine guid.
    //
    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = M_OWNERID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = M_OWNERID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cbColumns == cAlloc) ;

    //
    // We need sorting since we have to migrate servers and only then clients. 
    // The order is important because of Out/In FRS.
    // When Out/InFRS is created for client code replaces machine guid by 
    // full DN name. It means that if for specific server msmqConfiguration 
    // does not yet exist and we try to migrate client with this server 
    // that is defined as its Out/InFRS, we failed with MACHINE_NOT_FOUND    
    //
    MQDBSEARCHORDER ColSort;
    ColSort.lpszColumnName = M_SERVICES_COL;        
    ColSort.nOrder = DESC;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hMachineTable,
                                       pColumns,
                                       cbColumns,
                                       ColSearch,
                                       NULL,
                                       &ColSort,
                                       1,
                                       &hQuery,
							           TRUE ) ;     
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    HRESULT hr1 = MQMig_OK;

    while(SUCCEEDED(status))
    {
        if (iIndex >= cMachines)
        {
            status = MQMig_E_TOO_MANY_MACHINES ;
            break ;
        }

        //
        // Migrate each machine
        //                
        //
        // get machine name from pColumns
        //    
        P<BYTE> pwzBuf = NULL ;       
        DWORD  dwIndexs[2] = { e_Name1Index, e_Name2Index } ;
        HRESULT hr =  BlobFromColumns( pColumns,
                                       dwIndexs,
                                       2,
                                       (BYTE**) &pwzBuf ) ;
        CHECK_HR(hr) ;
        WCHAR *pwzMachineName = (WCHAR*) (pwzBuf + sizeof(DWORD)) ;
        
        BOOL fConnector = FALSE;

		DWORD dwService = (DWORD) pColumns[ e_ServiceIndex ].nColumnValue ;
        

		if (dwService > SERVICE_SRV && (_wcsicmp(pwzMachineName, g_MachineName) != 0))
		{
			//
			// Demote all servers
			//
			pColumns[ e_ServiceIndex ].nColumnValue = GetDemoteService();
		}
		
		if (g_fUpdateRegistry)
		{
	        hr = UpdateMachineRegistry(pwzMachineName, dwService);
	        if (FAILED(hr))
	        {
				g_fAllMachinesDemoted = FALSE;
	        }
		}

        hr = _CreateMachine(
                    pSiteGuid,
                    pwszSiteName,
                    pwzMachineName,
                    pColumns,
                    iIndex,
                    &fConnector
                    ) ;   
        
        if (fConnector)
        {
            //
            // Bug 5012.
            // Connector machine migration
            //      
            
            //
            // we got this error if we tryed to create machine object. In case of Set 
            // (to run mqmig /w or on PSC) it must be succeeded
            //

            if (hr == MQDS_E_COMPUTER_OBJECT_EXISTS ||
                hr == MQ_ERROR_MACHINE_NOT_FOUND)
            {
                //
                // It is possible for connector machine.
                //
                // If connector machine is in the PEC domain, create msmqSetting object
                // under foreign site failed with error MQ_ERROR_MACHINE_NOT_FOUND. 
                // When this error is returned from DSCoreCreateMigratedObject, 
                // _CreateMachine tries to create computer object. 
                // This object already exists and hence _CreateComputerObject returns
                // MQDS_E_COMPUTER_OBJECT_EXISTS.
                //
                // If connector machine is not in the PEC domain, 
                // DSCoreCreateMigratedObject failed with MQ_ERROR_MACHINE_NOT_FOUND.
                // Then _CreateMachine tries to create computer object. It succeeded.
                // Now _CreateMachine calls DSCoreCreateMigratedObject again.
                // It failed with MQ_ERROR_MACHINE_NOT_FOUND (because of foreign site)
                //
                // We have to verify that msmqSetting object was created under 
                // real NT4 site. 
                //
                // Try to touch msmqSetting attribute. If it will be succeeded,
                // it means that msmq Setting object exists.
                //
                hr = ResetSettingFlag(  1,                  //dwNumSites,
                                        pSiteGuid,         //pguidSites,
                                        pwzMachineName,
                                        const_cast<WCHAR*> (MQ_SET_MIGRATED_ATTRIBUTE),
                                        L"FALSE");                
            }
            
            //
            // In any case (even if we failed before) try to complete connector migration.
            //
            // Create site link for connector machine.
            //
            HRESULT hrTmp = _CreateSiteLinkForConnector (
                                    pwzMachineName,
                                    pSiteGuid,
                                    (GUID*) pColumns[ e_GuidIndex ].nColumnValue
                                    );
            if (FAILED(hrTmp))
            {
                hr = hrTmp;
            }
        }

		
        MQDBFreeBuf((void*) pColumns[ e_GuidIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Name1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Name2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_SecD1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_SecD2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_SecD3Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_MTypeIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Sign1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Sign2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Encrpt1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Encrpt2Index ].nColumnValue) ;

        for ( LONG i = 0 ; i < cbColumns ; i++ )
        {
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        if (!g_fReadOnly && hr == MQMig_E_INVALID_MACHINE_NAME)
        {
            //
            // re-define this error to finish migration process
            //
            hr = MQMig_I_INVALID_MACHINE_NAME;
        }

        if (FAILED(hr))
        {
            if (hr == MQ_ERROR_CANNOT_CREATE_ON_GC)
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_MACHINE_REMOTE_DOMAIN_OFFLINE, pwzMachineName, hr) ;
            }
            else
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_MACHINE, pwzMachineName, hr) ;
            }
            hr1 = hr;
        }

        g_iMachineCounter ++;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != cMachines)
    {
        //
        // Mismatch in number of sites.
        //
        HRESULT hr = MQMig_E_FEWER_MACHINES ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, cMachines) ;
        return hr ;
    }   

    return hr1 ;
}

//+---------------------------------------------------
//
//  HRESULT MigrateMachinesInSite(GUID *pSiteGuid)
//
//+---------------------------------------------------

HRESULT MigrateMachinesInSite(GUID *pSiteGuid)
{
    //
    // Enable multiple queries.
    // this is necessary to retrieve CN of foreign machine.
    //
    HRESULT hr = EnableMultipleQueries(TRUE) ;
    ASSERT(SUCCEEDED(hr)) ;

    //
    // get site name from database
    //
    LONG cAlloc = 1 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_NAME_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_NAME_CTYPE ;
    LONG iSiteNameIndex = cColumns ;
    cColumns++ ;

    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = S_ID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = S_ID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT cMachines = 0 ;
    hr =  GetMachinesCount(  pSiteGuid,
                            &cMachines ) ;
    CHECK_HR(hr) ;

    if (cMachines != 0)
    {
        LogMigrationEvent(MigLog_Info, MQMig_I_MACHINES_COUNT,
                  cMachines, pColumns[ iSiteNameIndex ].nColumnValue ) ;

        hr = MigrateMachines( cMachines,
                              pSiteGuid,
                    (WCHAR *) pColumns[ iSiteNameIndex ].nColumnValue ) ;
    }
    else
    {
        //
        // That's legitimate, to have a site without machines.
        // This will happen when running the tool on a PSC, where
        // it already has (in its MQIS database) Windows sites without
        // MSMQ machine. Or in crash mode.
        //
        LogMigrationEvent(MigLog_Warning, MQMig_I_NO_MACHINES_AVAIL,
                               pColumns[ iSiteNameIndex ].nColumnValue ) ;
    }

    MQDBFreeBuf((void*) pColumns[ iSiteNameIndex ].nColumnValue ) ;
    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    HRESULT hr1 = EnableMultipleQueries(FALSE) ;
    DBG_USED(hr1);
    ASSERT(SUCCEEDED(hr1)) ;

    return hr;
}



//+---------------------------------------------------
//
//  HRESULT OnlyUpdateComputers(bool fUpdateClients)
//
//+---------------------------------------------------

#define INIT_MACHINE_COLUMN(_ColName, _ColIndex, _Index)            \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;


HRESULT OnlyUpdateComputers(bool fUpdateClients)
{
	ULONG cAlloc = 3;
    ULONG cbColumns = 0;
    AP<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[cAlloc];

    INIT_MACHINE_COLUMN(M_NAME1,          iName1Index,      cbColumns);
    INIT_MACHINE_COLUMN(M_NAME2,          iName2Index,      cbColumns);
    INIT_MACHINE_COLUMN(M_SERVICES,       iServiceIndex,    cbColumns);
    
#undef  INIT_MACHINE_COLUMN
    
    //
    // Restriction. query by machine service.
    //
    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = M_SERVICES_COL;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = M_SERVICES_CTYPE;
    ColSearch[0].mqdbColumnVal.nColumnValue = (ULONG) SERVICE_NONE;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(ULONG);
	if (fUpdateClients)
	{
		ColSearch[0].mqdbOp = EQ;
	}
	else
	{
		ColSearch[0].mqdbOp = NE;
	}

    ASSERT(cbColumns == cAlloc);

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( 
    							g_hMachineTable,
                               	pColumns,
                               	cbColumns,
                               	ColSearch,
                               	NULL,
                               	NULL,
                               	0,
                               	&hQuery,
					          	TRUE
					          	);
    CHECK_HR(status);

	HRESULT hrFail = S_OK;
    while(SUCCEEDED(status))
    {

        //
        // Get one name buffer from both name columns.
        //
        AP<BYTE> pwzBuf;
        DWORD  dwIndexs[2] = { iName1Index, iName2Index };
        HRESULT hr =  BlobFromColumns( 
        						pColumns,
                                dwIndexs,
                                2,
                                (BYTE**) &pwzBuf );
        CHECK_HR(hr) ;
        
        LPWSTR pwzMachineName = (WCHAR*) (pwzBuf + sizeof(DWORD));

        
        

        //
        // we check version on all PSCs and on all BSCs of PEC
        //
        if (wcscmp(pwzMachineName, g_MachineName) != 0)
        {
         	HRESULT hr = UpdateMachineRegistry(pwzMachineName, (DWORD)pColumns[iServiceIndex].nColumnValue);  	
         	if (FAILED(hr))
		    {
				hrFail = hr;
			}
        }

        g_iMachineCounter ++;

        MQDBFreeBuf((void*) pColumns[ iName1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iName2Index ].nColumnValue) ; 
        
        for ( ULONG i = 0 ; i < cbColumns; i++ )
        {		
            pColumns[i].nColumnValue  = 0 ;
            pColumns[i].nColumnLength  = 0 ;
        }

        status = MQDBGetData(hQuery, pColumns) ;
    }

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_SQL_FAIL, status) ;
        return status ;
    }

    return hrFail;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migqueue.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migqueue.cpp

Abstract:

    Migration NT4 Queue objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include "mqtypes.h"
#include "mqprops.h"

#include "migqueue.tmh"

//-------------------------------------------------
//
//  HRESULT InsertQueueInNT5DS( GUID *pQueueGuid )
//
//-------------------------------------------------
HRESULT InsertQueueInNT5DS(
               IN LPWSTR                pwszQueueName ,
               IN SECURITY_DESCRIPTOR   *pQsd,
               IN GUID                  *pQueueGuid,
               IN LPWSTR                pwszLabel,
               IN GUID                  *pType,
               IN BOOL                  fJournal,
               IN ULONG                 ulQuota,
               IN short                 iBaseP,
               IN DWORD                 dwJQuota,
               IN BOOL                  fAuthn,
               IN DWORD                 dwPrivLevel,
               IN GUID                  *pOwnerGuid,
               IN BOOL                  fTransact,
               IN UINT                  iIndex,
               IN BOOL                  fIsTheSameMachine
               )

{
    DBG_USED(iIndex);
#ifdef _DEBUG
    unsigned short *lpszGuid ;
    UuidToString( pQueueGuid,
                  &lpszGuid ) ;

    LogMigrationEvent(MigLog_Info, MQMig_I_QUEUE_MIGRATED,
                                        iIndex,
                                        pwszQueueName,
                                        pwszLabel,
                                        lpszGuid ) ;
    RpcStringFree( &lpszGuid ) ;
#endif
    if (g_fReadOnly)
    {
        return S_OK;
    }
    //
    // Prepare the properties for DS call.
    //
    LONG cAlloc = 13;
    P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];
    P<PROPID>      paPropId  = new PROPID[ cAlloc ];
    DWORD          PropIdCount = 0;

    paPropId[ PropIdCount ] = PROPID_Q_LABEL;    //PropId
    paVariant[ PropIdCount ].vt = VT_LPWSTR;     //Type
    paVariant[ PropIdCount ].pwszVal = pwszLabel;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_TYPE;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
    paVariant[ PropIdCount ].puuid = pType;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_JOURNAL;
    paVariant[ PropIdCount ].vt = VT_UI1;
    paVariant[ PropIdCount ].bVal = (unsigned char) fJournal;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_QUOTA;
    paVariant[ PropIdCount ].vt = VT_UI4;
    paVariant[ PropIdCount ].ulVal = ulQuota;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_BASEPRIORITY;
    paVariant[ PropIdCount ].vt = VT_I2;
    paVariant[ PropIdCount ].iVal = iBaseP;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_JOURNAL_QUOTA;
    paVariant[ PropIdCount ].vt = VT_UI4;
    paVariant[ PropIdCount ].ulVal = dwJQuota;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_AUTHENTICATE ;
    paVariant[ PropIdCount ].vt = VT_UI1;
    paVariant[ PropIdCount ].bVal = (unsigned char) fAuthn;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_PRIV_LEVEL ;
    paVariant[ PropIdCount ].vt = VT_UI4;
    paVariant[ PropIdCount ].ulVal = dwPrivLevel ;
    PropIdCount++;
    DWORD SetPropIdCount = PropIdCount;

    //
    // all properties below are for create object only!
    //
    paPropId[ PropIdCount ] = PROPID_Q_PATHNAME;    //PropId
    paVariant[ PropIdCount ].vt = VT_LPWSTR;        //Type
    paVariant[PropIdCount].pwszVal = pwszQueueName ;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_MASTERID;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
    paVariant[ PropIdCount ].puuid = pOwnerGuid;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_TRANSACTION ;
    paVariant[ PropIdCount ].vt = VT_UI1;
    paVariant[ PropIdCount ].bVal = (unsigned char) fTransact;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_NT4ID ;
    paVariant[ PropIdCount ].vt = VT_CLSID;
    paVariant[ PropIdCount ].puuid = pQueueGuid ;
    PropIdCount++;

    ASSERT((LONG) PropIdCount <= cAlloc) ;

    ASSERT(pQsd && IsValidSecurityDescriptor(pQsd)) ;
    if (pQsd)
    {
        paPropId[ PropIdCount ] = PROPID_Q_SECURITY ;
        paVariant[ PropIdCount ].vt = VT_BLOB ;
        paVariant[ PropIdCount ].blob.pBlobData = (BYTE*) pQsd ;
        paVariant[ PropIdCount ].blob.cbSize =
                                     GetSecurityDescriptorLength(pQsd) ;
        PropIdCount++;
    }

    ASSERT((LONG) PropIdCount <= cAlloc) ;

    static LPWSTR s_pwszFullPathName = NULL;
    static ULONG  s_ulProvider = 0;

    HRESULT hr = MQMig_OK;
    if (g_dwMyService == SERVICE_PSC)
    {
        //
        // this is PSC, assume that object exist, try to set properties
        //
        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);

        hr = DSCoreSetObjectProperties (  MQDS_QUEUE,
                                          NULL,
                                          pQueueGuid,
                                          SetPropIdCount,
                                          paPropId,
                                          paVariant,
                                          &requestContext,
                                          NULL );
    }

    if ((hr == MQ_ERROR_QUEUE_NOT_FOUND) ||
        (g_dwMyService == SERVICE_PEC))
    {
        if (FAILED(hr))
        {
            //
            // we are here only if this machine is PSC. In that case we have
            // reset flag fIsTheSameMachine since it is possible the next situation:
            // migrate queue1 of PSC succeded
            // queue2 of PSC exists only on PSC (not yet replicated to PEC)
            // it means that Set failed, it is the same machine that was at the
            // previous step but we don't know its full path name
            //
            ASSERT (g_dwMyService == SERVICE_PSC);
            fIsTheSameMachine = FALSE;
        }

        if (fIsTheSameMachine)
        {
            //
            // we can use machine properties we got before
            //
            ASSERT (g_dwMyService == SERVICE_PEC);
            ASSERT (s_pwszFullPathName);
        }
        else
        {
            //
            // we have to get machine properties
            //
            if (s_pwszFullPathName)
            {
                delete s_pwszFullPathName;
                s_pwszFullPathName = NULL;
            }
        }

        hr = DSCoreCreateMigratedObject( MQDS_QUEUE,
                                         pwszQueueName,
                                         PropIdCount,
                                         paPropId,
                                         paVariant,
                                         0,        // ex props
                                         NULL,     // ex props
                                         NULL,     // ex props
                                         NULL,
                                         NULL,
                                         NULL,
                                         fIsTheSameMachine, //use full path name
                                         !fIsTheSameMachine,//return full path name
                                         &s_pwszFullPathName,
                                         &s_ulProvider
                                        );

        if (hr == MQ_ERROR_QUEUE_EXISTS)
        {
            hr = MQMig_OK ;
        }
        if (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM) ||
            hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX) ||
            hr == HRESULT_FROM_WIN32(E_FAIL) ||
            hr == MQ_ERROR_CANNOT_CREATE_ON_GC ||
            hr == MQ_ERROR_ILLEGAL_QUEUE_PATHNAME)
        {
            //
            // Error "ERROR_DS_UNWILLING_TO_PERFORM" can be returned if queue path name
            // or queue label contain illegal symbols (like "+").
            // Error "ERROR_DS_INVALID_DN_SYNTAX" can be returned if queue path name
            // or queue label contain illegal symbols (like ",").
            // Error "E_FAIL" can be returned if queue path name
            // or queue label contain illegal symbols (like """ - quota).
            //
            // In case of PSC instead of all these errors return code is
            // MQ_ERROR_CANNOT_CREATE_ON_GC if msmqConfiguration object is in another
            // domain than PSC domain.
            // Exapmle: PEC and PSC are both DC, PSC's msmqConfiguration object is
            // in the PEC domain under msmqComputers container.
            //


            LogMigrationEvent(MigLog_Event, MQMig_E_ILLEGAL_QUEUENAME, pwszQueueName, hr) ;
            hr = MQMig_E_ILLEGAL_QUEUENAME;
        }
    }

    return hr ;
}

//-------------------------------------------
//
//  HRESULT MigrateQueues()
//
//-------------------------------------------


#define INIT_QUEUE_COLUMN(_ColName, _ColIndex, _Index)              \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateQueues()
{
    UINT cQueues = 0 ;
    HRESULT hr;
    if (g_dwMyService == SERVICE_PSC)
    {
        hr = GetAllQueuesInSiteCount( &g_MySiteGuid,
                                      &cQueues );
    }
    else
    {
        hr =  GetAllQueuesCount(&cQueues ) ;
    }
    CHECK_HR(hr) ;

#ifdef _DEBUG
    LogMigrationEvent(MigLog_Info, MQMig_I_QUEUES_COUNT, cQueues) ;
#endif

    if (cQueues == 0)
    {
        return MQMig_I_NO_QUEUES_AVAIL ;
    }

    LONG cAlloc = 17 ;
    LONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_QUEUE_COLUMN(Q_INSTANCE,      iGuidIndex,      cbColumns) ;
    INIT_QUEUE_COLUMN(Q_TYPE,          iTypeIndex,      cbColumns) ;
    INIT_QUEUE_COLUMN(Q_OWNERID,       iOwnerIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_PATHNAME1,     iName1Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_PATHNAME2,     iName2Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_LABEL,         iLabelIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_JOURNAL,       iJournalIndex,   cbColumns) ;
    INIT_QUEUE_COLUMN(Q_QUOTA,         iQuotaIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_BASEPRIORITY,  iBasePIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_JQUOTA,        iJQuotaIndex,    cbColumns) ;
    INIT_QUEUE_COLUMN(Q_AUTH,          iAuthnIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_PRIVLVL,       iPrivLevelIndex, cbColumns) ;
    INIT_QUEUE_COLUMN(Q_TRAN,          iTransactIndex,  cbColumns) ;
    INIT_QUEUE_COLUMN(Q_SECURITY1,     iSecD1Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_SECURITY2,     iSecD2Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_SECURITY3,     iSecD3Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_QMID,          iQMIDIndex,      cbColumns) ;

    #undef  INIT_QUEUE_COLUMN

    ASSERT(cbColumns == cAlloc) ;

    //
    // Restriction. query by machine guid.
    //
    MQDBCOLUMNSEARCH *pColSearch = NULL ;
    MQDBCOLUMNSEARCH ColSearch[1] ;

    if (g_dwMyService == SERVICE_PSC)
    {
        INIT_COLUMNSEARCH(ColSearch[0]) ;
        ColSearch[0].mqdbColumnVal.lpszColumnName = Q_OWNERID_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = Q_OWNERID_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) &g_MySiteGuid ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
        ColSearch[0].mqdbOp = EQ ;

        pColSearch = ColSearch ;
    }

    MQDBSEARCHORDER ColSort;
    ColSort.lpszColumnName = Q_QMID_COL;
    ColSort.nOrder = ASC;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hQueueTable,
                                       pColumns,
                                       cbColumns,
                                       pColSearch,
                                       NULL,
                                       &ColSort,
                                       1,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    HRESULT hr1 = MQMig_OK;
    HRESULT hrPrev = MQMig_OK;

    GUID PrevId = GUID_NULL;
    GUID CurId = GUID_NULL;
    BOOL fTryToCreate = TRUE;

    while(SUCCEEDED(status))
    {
        if (iIndex >= cQueues)
        {
            status = MQMig_E_TOO_MANY_QUEUES ;
            break ;
        }

        //
        // Migrate each queue.
        //
        //
        // Get one name buffer from both name columns.
        //
        P<BYTE> pwzBuf = NULL ;
        DWORD  dwIndexs[2] = { iName1Index, iName2Index } ;
        HRESULT hr =  BlobFromColumns( pColumns,
                                       dwIndexs,
                                       2,
                                       (BYTE**) &pwzBuf ) ;
        CHECK_HR(hr) ;
        WCHAR *wszQueueName = (WCHAR*) (pwzBuf + sizeof(DWORD)) ;

        DWORD dwSize;
        memcpy (&dwSize, pwzBuf, sizeof(DWORD)) ;
        dwSize = (dwSize / sizeof(TCHAR)) - 1;
        ASSERT (wszQueueName[dwSize] == _T('\0'));
        wszQueueName[dwSize] = _T('\0');

        P<BYTE> pSD = NULL ;
        DWORD  dwSDIndexs[3] = { iSecD1Index, iSecD2Index, iSecD3Index } ;
        hr =  BlobFromColumns( pColumns,
                               dwSDIndexs,
                               3,
                               (BYTE**) &pSD ) ;
        CHECK_HR(hr) ;

        SECURITY_DESCRIPTOR *pQsd =
                         (SECURITY_DESCRIPTOR*) (pSD + sizeof(DWORD)) ;        

        BOOL fIsTheSameMachine = TRUE;
        memcpy (&CurId, (GUID*) pColumns[ iQMIDIndex ].nColumnValue, sizeof(GUID));
        if (memcmp (&CurId, &PrevId, sizeof(GUID)) != 0 )
        {
            //
            // it means we move to the queues on the next machine
            // we have to get all needed properties of this machine
            //
            fIsTheSameMachine = FALSE;
            memcpy (&PrevId, &CurId, sizeof(GUID));

            //
            // verify if machine was not migrated because of invalid name.
            // If machine was not migrated we don't try to create this queue
            //
            if (IsObjectGuidInIniFile (&CurId, MIGRATION_MACHINE_WITH_INVALID_NAME))
            {
                fTryToCreate = FALSE;
            }
            else
            {
                fTryToCreate = TRUE;
            }
        }

        if (FAILED(hrPrev))
        {
            //
            // BUG 5230.
            // if previous create failed we can't use full path name and provider,
            // so reset fIsTheSameMachine flag to try to get these values again.
            //
            // It is very important if we failed to create first queue for specific
            // machine and we are going to create the second etc queue for that machine.
            //
            // BUGBUG: if we already successfully created some queues for specific
            // machine and failed at the previous step only, in general we don't need
            // to reset this flag. It decreases performance. Is it important to handle
            // this case too?
            //
            fIsTheSameMachine = FALSE;
        }

        if (!fTryToCreate)
        {
            hr = MQMig_E_INVALID_MACHINE_NAME;
        }
        else
        {
            ASSERT (MQ_MAX_Q_LABEL_LEN ==
                (((DWORD) pColumns[ iLabelIndex ].nColumnLength) / sizeof(TCHAR)) - 1);

            TCHAR *pszLabel = (WCHAR*) pColumns[ iLabelIndex ].nColumnValue;
            ASSERT (pszLabel[MQ_MAX_Q_LABEL_LEN] == _T('\0'));
            pszLabel[MQ_MAX_Q_LABEL_LEN] = _T('\0');

            hr = InsertQueueInNT5DS(
                        wszQueueName,                                   //Queue Name
                        pQsd,                                           //SecurityDescriptor
                        (GUID*) pColumns[ iGuidIndex ].nColumnValue,    //Queue Guid
                        (WCHAR*) pColumns[ iLabelIndex ].nColumnValue,  //Label
                        (GUID*) pColumns[ iTypeIndex ].nColumnValue,    //Type
                        (UCHAR) pColumns[ iJournalIndex ].nColumnValue, //Journal
                        (ULONG) pColumns[ iQuotaIndex ].nColumnValue,   //Quota
                        (short) pColumns[ iBasePIndex ].nColumnValue,   //BasePriority
                        (ULONG) pColumns[ iJQuotaIndex ].nColumnValue,  //JQuota
                        (UCHAR) pColumns[ iAuthnIndex ].nColumnValue,   //Authentication
                        (ULONG) pColumns[ iPrivLevelIndex ].nColumnValue,   //PrivLevel
                        (GUID*) pColumns[ iOwnerIndex ].nColumnValue,   //OwnerId
                        (UCHAR) pColumns[ iTransactIndex ].nColumnValue,//Transaction
                        iIndex,
                        fIsTheSameMachine
                        ) ;
        }

        hrPrev = hr;

        MQDBFreeBuf((void*) pColumns[ iGuidIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iName1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iName2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iLabelIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iOwnerIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iTypeIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iSecD1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iSecD2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iSecD3Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iQMIDIndex ].nColumnValue) ;

        for ( LONG i = 0 ; i < cbColumns ; i++ )
        {
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        //
        // we have to re-define error before saving hr in hr1 in order to save
        // and return real error (skip all errors those allow to continue).
        //
        if (hr == MQMig_E_ILLEGAL_QUEUENAME ||
            hr == MQMig_E_INVALID_MACHINE_NAME)
        {
            //
            // re-define this error to finish migration process
            //
            hr = MQMig_I_ILLEGAL_QUEUENAME;
        }

        if (FAILED(hr))
        {
            if (hr == MQDS_OBJECT_NOT_FOUND)
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_NON_MIGRATED_MACHINE_QUEUE, wszQueueName, hr) ;
            }
            else
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_QUEUE, wszQueueName, hr) ;
            }
            hr1 = hr;
        }
        g_iQueueCounter ++;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);
    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_QUEUES_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != cQueues)
    {
        //
        // Mismatch in number of queues.
        //
        hr = MQMig_E_FEWER_QUEUES ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, cQueues) ;
        return hr ;
    }

    return hr1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migrat.h ===
//
// file: migrat.h
//

#include <_stdh.h>
#include <stdio.h>
#include <tchar.h>
#include <wchar.h>

#include <mqtypes.h>
#include <mqdbmgr.h>
#include <uniansi.h>
#include <mqprops.h>
#include <_mqini.h>

#include "migratui.h"
//#include "resource.h"

#include "mqmigui.h"

#ifndef _NO_SEQNUM_
#include <dscore.h>
#include <seqnum.h>
#endif

#include "..\..\ds\h\mqiscol.h"
#include "..\migrepl.h"
#include "..\rptempl.h"

#ifndef _NO_NT5DS_

#include <wincrypt.h>

#include <winldap.h>
#include <activeds.h>
#include "..\..\ds\h\mqattrib.h"
#include "..\..\ds\h\mqdsname.h"
#endif

#include "mqsymbls.h"

//---------------------------------
//
//  Functions prototypes
//
//---------------------------------

HRESULT MakeMQISDsn(LPSTR lpszServerName, BOOL fMakeAlways = FALSE) ;

HRESULT ConnectToDatabase(BOOL fConnectAlways = FALSE) ;
void    CleanupDatabase() ;

#ifndef _NO_NT5DS_
HRESULT  InitLDAP( PLDAP *ppLdap,
                   TCHAR **ppwszDefName,
                   ULONG ulPort = LDAP_PORT) ;

HRESULT ModifyAttribute(
             WCHAR       wszPath[],
             WCHAR       pAttr[],
             WCHAR       pAttrVal[],
             PLDAP_BERVAL *ppBVal = NULL
             );
#endif

HRESULT OpenEntTable() ;
HRESULT MigrateEnterprise() ;

HRESULT OpenCNsTable() ;
HRESULT OpenMachineCNsTable() ;
HRESULT MigrateCNs() ;

HRESULT EnableMultipleQueries(BOOL fEnable) ;

UINT    GetNT5SitesCount() ;
HRESULT GetSitesCount(UINT *pcSites) ;
HRESULT MigrateSites( IN UINT  cSites,
                      IN GUID *pSitesGuid ) ;

HRESULT GetMachinesCount(IN  GUID *pSiteGuid,
                         OUT UINT *pcMachines) ;

HRESULT MigrateMachines(IN UINT   cMachines,
                        IN GUID  *pSiteGuid,
                        IN LPWSTR wszSiteName) ;

HRESULT GetQueuesCount( IN  GUID *pMachineGuid,
                        OUT UINT *pcQueues ) ;

HRESULT GetAllMachinesCount(UINT *pcMachines);
HRESULT GetAllQueuesCount(UINT *pcQueues);
HRESULT GetAllQueuesInSiteCount( IN  GUID *pSiteGuid,
                                 OUT UINT *pcQueues );

HRESULT GetAllObjectsNumber (IN  GUID *pSiteGuid,
                             IN  BOOL    fPecfPec,
                             OUT UINT *pulAllObjectNumber ) ;

HRESULT MigrateMachinesInSite(IN GUID *pSiteGuid);

HRESULT MigrateQueues() ;

HRESULT MigrateUsers(LPTSTR lpszDcName) ;
HRESULT OpenUsersTable() ;
HRESULT GetUserCount(UINT *pcUsers) ;

HRESULT  BlobFromColumns( MQDBCOLUMNVAL *pColumns,
                          DWORD          adwIndexs[],
                          DWORD          dwIndexSize,
                          BYTE**         ppOutBuf ) ;

TCHAR *GetIniFileName ();

HRESULT GetSiteIdOfPEC (IN LPTSTR pszRemoteMQISName,
                        OUT ULONG *pulService,
                        OUT GUID  *pSiteId);

#ifndef _NO_SEQNUM_
HRESULT  FindLargestSeqNum( GUID    *pMasterId,
                            CSeqNum &snMaxLsn,
                            BOOL    fPec ) ;
#endif

UINT  ReadDebugIntFlag(WCHAR *pwcsDebugFlag, UINT iDefault) ;

HRESULT  ReadFirstNT5Usn(TCHAR *pszUsn) ;
HRESULT  FindMinMSMQUsn(TCHAR *wszMinUsn) ;

BOOL  MigWriteRegistrySz( LPTSTR  lpszRegName,
                          LPTSTR  lpszValue ) ;

BOOL  MigWriteRegistryDW( LPTSTR  lpszRegName,
                          DWORD   dwValue ) ;

BOOL  MigWriteRegistryGuid( LPTSTR  lpszRegName,
                            GUID    *pGuid ) ;

BOOL  MigReadRegistryGuid( LPTSTR  lpszRegName,
                           GUID    *pGuid ) ;

BOOL  MigReadRegistryDW( LPTSTR  lpszRegName,
                         DWORD   *pdwValue ) ;

BOOL  MigReadRegistrySz( LPTSTR  lpszRegName,
                         LPTSTR  lpszValue,
                         DWORD   dwSize);

BOOL  MigReadRegistrySzErr( LPTSTR  lpszRegName,
                            LPTSTR  lpszValue,
                            DWORD   dwSize,
                            BOOL    fShowError );

HRESULT  UpdateRegistry( IN UINT  cSites,
                         IN GUID *pSitesGuid ) ;

HRESULT  CreateMsmqContainer(TCHAR wszContainerName[]) ;

HRESULT  CreateSite( GUID   *pSiteGuid,
                     LPTSTR  pszSiteName,
                     BOOL    fForeign,
                     USHORT  uiInterval1 = DEFAULT_S_INTERVAL1,
                     USHORT  uiInterval2 = DEFAULT_S_INTERVAL2
                     ) ;

HRESULT OpenSiteLinkTable();

HRESULT MigrateSiteLinks();

HRESULT MigrateASiteLink (
            IN GUID     *pLinkId,
            IN GUID     *pNeighbor1Id,
            IN GUID     *pNeighbor2Id,
            IN DWORD    dwCost,
            IN DWORD    dwSiteGateNum,
            IN LPWSTR   lpwcsSiteGates,
            IN UINT     iIndex
            );

HRESULT MigrateSiteGates();

HRESULT GetFullPathNameByGuid ( GUID   MachineId,
                                LPWSTR *lpwcsFullPathName );

HRESULT LookupBegin(
			MQCOLUMNSET *pColumnSet,
			HANDLE *phQuery
			);
HRESULT LookupNext (
			HANDLE hQuery,
			DWORD *pdwCount,
			PROPVARIANT paVariant[]
			);
HRESULT LookupEnd (HANDLE hQuery) ;

HRESULT GrantAddGuidPermissions() ;

HRESULT RestorePermissions() ;

void InitLogging( LPTSTR  szLogFile,
                  ULONG   ulTraceFlags,
				  BOOL	  fReadOnly) ;

void EndLogging() ;

HRESULT  GetMachineCNs(IN  GUID    *pMachineGuid,
                       OUT DWORD   *pdwNumofCNs,
                       OUT GUID   **pCNGuids ) ;

MQDBSTATUS APIENTRY  MQDBGetTableCount(IN MQDBHANDLE  hTable,
                                       OUT UINT       *puCount,
                         IN MQDBCOLUMNSEARCH  *pWhereColumnSearch = NULL,
                                       IN LONG        cWhere  = 1,
                                       IN MQDBOP      opWhere = AND) ;
HRESULT CheckVersion (
              OUT UINT   *piOldVerServersCount,
              OUT LPTSTR *ppszOldVerServers
              );

HRESULT AnalyzeMachineType (
            IN LPWSTR wszMachineType,
            OUT BOOL  *pfOldVersion
            );

HRESULT ChangeRemoteMQIS ();

DWORD CalHashKey( IN LPCWSTR pwcsPathName );

void BuildServersList(LPTSTR *ppszNonUpdatedServerName, ULONG *pulServerCount);

void RemoveServersFromList(LPTSTR *ppszUpdatedServerName,
                           LPTSTR *ppszNonUpdatedServerName);

BOOL IsObjectNameValid(TCHAR *pszObjectName);

BOOL IsObjectGuidInIniFile(IN GUID      *pObjectGuid,
                           IN LPWSTR    pszSectionName);

HRESULT GetCurrentUserSid ( IN HANDLE    hToken, 
                            OUT TCHAR    **ppUserSid);

HRESULT  GetSchemaNamingContext ( PLDAP pLdap,
                                  TCHAR **ppszSchemaDefName );

HRESULT HandleAUser(PLDAP           pLdap,
                    LDAPMessage     *pEntry);

HRESULT TouchAUser (PLDAP           pLdap,
                    LDAPMessage     *pEntry );

HRESULT QueryDS(
            IN  PLDAP           pLdap,
            IN  TCHAR           *pszDN,
            IN  TCHAR           *pszFilter,			
            IN  DWORD           dwObjectType,
            IN  PWSTR           *rgAttribs,
            IN  BOOL            fTouchUser
            );

BOOL IsInsertPKey (GUID *pMachineGuid);

HRESULT GetFRSs (IN MQDBCOLUMNVAL    *pColumns,
                 IN UINT             uiFirstIndex,
                 OUT UINT            *puiFRSCount, 
                 OUT GUID            **ppguidFRS );

HRESULT PreparePBKeysForNT5DS( 
                   IN MQDBCOLUMNVAL *pColumns,
                   IN UINT           iIndex1,
                   IN UINT           iIndex2,
                   OUT ULONG         *pulSize,
                   OUT BYTE          **ppPKey
                   );

HRESULT  ResetSettingFlag( IN DWORD   dwNumSites,
                           IN GUID*   pguidSites,
                           IN LPWSTR  wszMachineName,
                           IN WCHAR   *wszAttributeName,
                           IN WCHAR   *wszValue);

HRESULT GetAllMachineSites ( IN GUID    *pMachineGuid,
                             IN LPWSTR  wszMachineName,
                             IN GUID    *pOwnerGuid,
                             IN BOOL    fForeign,
                             OUT DWORD  *pdwNumSites,
                             OUT GUID   **ppguidSites,
                             OUT BOOL   *pfIsConnector) ;

HRESULT CreateMachineObjectInADS (
                IN DWORD    dwService,
                IN BOOL     fWasServerOnCluster,
                IN GUID     *pOwnerGuid,
                IN GUID     *pMachineGuid,
                IN LPWSTR   wszSiteName,
                IN LPWSTR   wszMachineName,
                IN DWORD    SetPropIdCount,
                IN DWORD    iProperty,
                IN PROPID   *propIDs,
                IN PROPVARIANT *propVariants
                );

void SaveMachineWithInvalidNameInIniFile (LPWSTR wszMachineName, GUID *pMachineGuid);

BOOL _ReadRegistryValue(
			    IN const LPCTSTR szEntryName,
			    IN       DWORD   *pdwNumBytes,
			    IN       DWORD   *pdwValueType,
			    IN const PVOID   pValueData
			    );

HRESULT OnlyUpdateComputers(bool fUpdateClients);
	
#define EMPTY_DEFAULT_CONTEXT       TEXT("")

//+------------------
//
//  Logging
//
//+------------------

//
// enum match values of DBGLVL_* in mqreport.h
//
enum MigLogLevel
{
    MigLog_Event = 0,
    MigLog_Error,
    MigLog_Warning,
    MigLog_Trace,
    MigLog_Info
} ;

void LogMigrationEvent(MigLogLevel eLevel, DWORD dwMsgId, ...) ;


//---------------------------------
//
//  Macros
//
//---------------------------------

#define CHECK_HR(hR)    \
    if (FAILED(hR))     \
    {                   \
        return hR ;     \
    }

//---------------------------------
//
//  Definitions
//
//---------------------------------

#define DSN_NAME  "RemoteMQIS"

//
// from MSMQ1.0 mqis.h
// when a field is composed of two SQL columns, the first 2 bytes of
// the fixed length column is the total length of the data.
// (e.g., PATHNAME1 and PATHNAME2).
//
#define MQIS_LENGTH_PREFIX_LEN  (2)

//---------------------------------
//
//  Global variables
//
//---------------------------------

extern MQDBHANDLE g_hDatabase ;
extern MQDBHANDLE g_hSiteTable ;
extern MQDBHANDLE g_hEntTable ;
extern MQDBHANDLE g_hCNsTable ;
extern MQDBHANDLE g_hMachineTable ;
extern MQDBHANDLE g_hMachineCNsTable ;
extern MQDBHANDLE g_hQueueTable ;
extern MQDBHANDLE g_hUsersTable ;
extern MQDBHANDLE g_hSiteLinkTable ;

extern BOOL  g_fReadOnly ;
extern BOOL  g_fRecoveryMode ;
extern BOOL  g_fClusterMode ;

extern DWORD    g_dwMyService ;
extern GUID     g_MySiteGuid  ;
extern GUID     g_MyMachineGuid ;

extern GUID     g_FormerPECGuid ;

extern UINT g_iServerCount ;

extern UINT g_iSiteCounter ;
extern UINT g_iMachineCounter ;
extern UINT g_iQueueCounter ;
extern UINT g_iUserCounter;

//-----------------------------
//
//  Auto delete pointer
//
//-----------------------------

// A helper class for automatically closing a query.
//
class CHQuery
{
public:
    CHQuery() : m_hQuery(NULL) {}
    ~CHQuery() { if (m_hQuery) MQDBCloseQuery(m_hQuery) ; }
    MQDBHANDLE * operator &() { return &m_hQuery ; }
    operator MQDBHANDLE() { return m_hQuery ; }
    CHQuery &operator =(MQDBHANDLE hQuery) { m_hQuery = hQuery; return *this; }

private:
    MQDBHANDLE m_hQuery ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migrate.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migrat.cpp

Abstract:

    Entry point for migration dll.

Author:

    Doron Juster  (DoronJ)  03-Feb-1998

--*/

#include "migrat.h"
#include <mixmode.h>
#include <mqsec.h>
#include "_mqres.h"

#include <Ev.h>
#include <Cm.h>
#include <Tr.h>

#include "migrate.tmh"

//
// DLL module instance handle
//
HINSTANCE  g_hResourceMod  = MQGetResourceHandle();
BOOL       g_fReadOnly       = TRUE ;
DWORD      g_dwMyService     = 0 ;
GUID       g_MySiteGuid  ;
GUID       g_MyMachineGuid  ;

GUID	   g_FormerPECGuid   = GUID_NULL ;	//used only in cluster mode

BOOL       g_fRecoveryMode   = FALSE ;
BOOL	   g_fClusterMode    = FALSE ;	
BOOL 	   g_fUpdateRegistry = FALSE;

UINT       g_iServerCount    = 0;

WCHAR	   g_MachineName[MAX_COMPUTERNAME_LENGTH+1];

BOOL 	   g_fAllMachinesDemoted = TRUE;

//
// for progress bar purposes
//
UINT g_iSiteCounter = 0;
UINT g_iMachineCounter = 0;
UINT g_iQueueCounter = 0;
UINT g_iUserCounter = 0;


enum MigrationState
{
	msScanMode,
	msMigrationMode,
	msUpdateClientsMode,
	msUpdateServersMode,
	msQuickMode,
	msUpdateOnlyRegsitryMode
};


//+----------------------------------
//
//  HRESULT _InitializeMigration()
//
//+----------------------------------

static HRESULT _InitializeMigration()
{
    static BOOL s_fInitialized = FALSE;
    if (s_fInitialized)
    {
        return TRUE;
    }

    HRESULT hr = MQMig_OK;

    BOOL f = MigReadRegistryDW( 
				MSMQ_MQS_REGNAME,
				&g_dwMyService 
				);
    if (f)
    {
        if ((g_dwMyService != SERVICE_PSC) &&
            (g_dwMyService != SERVICE_PEC))
        {
            hr = MQMig_E_WRONG_MQS_SERVICE;
            LogMigrationEvent(MigLog_Error, hr, g_dwMyService);
            return hr;
        }
    }
    else
    {
        return  MQMig_E_GET_REG_DWORD;
    }

    f = MigReadRegistryGuid( 
			MSMQ_MQIS_MASTERID_REGNAME,
			&g_MySiteGuid 
			);
    if (!f)
    {
        //
        // may be we are either in recovery or in cluster mode
        //
        f = MigReadRegistryGuid( 
				MIGRATION_MQIS_MASTERID_REGNAME,
				&g_MySiteGuid 
				);
        if (!f)
        {
            return  MQMig_E_GET_REG_GUID;
        }
    }

    f = MigReadRegistryGuid( 
			MSMQ_QMID_REGNAME,
			&g_MyMachineGuid 
			);
    if (!f)
    {
       return  MQMig_E_GET_REG_GUID;
    }

	DWORD MachineNameLength = MAX_COMPUTERNAME_LENGTH+1;
    f = GetComputerName(g_MachineName, &MachineNameLength);
    if (!f)
    {
		DWORD gle = GetLastError();
		return (HRESULT_FROM_WIN32(gle));
    }

    //
    // Initialize the MQDSCORE dll
    //
    hr = DSCoreInit( 
			TRUE  	// setup
			);

    s_fInitialized = TRUE;
    return hr;
}


class CAddGuidMode
{
public:
	CAddGuidMode()
	{
		DSCoreUpdateAddGuidMode(true);
	}

	~CAddGuidMode()
	{
		DSCoreUpdateAddGuidMode(false);
	}
};


//+----------------------------------------------------
//
// static HRESULT _MigrateInternal()
//
//+----------------------------------------------------

static 
HRESULT 
_MigrateInternal( 
	LPTSTR  szMQISName,
	LPTSTR  szDcName,
	BOOL    fReadOnly,
	BOOL    fRecoveryMode,
	BOOL	fClusterMode,
	DWORD   CurrentState,
	BOOL    *pfIsOneServer
	
	)
{
    HRESULT hr = _InitializeMigration();
    if (FAILED(hr))
    {
        return hr;
    }

    g_fReadOnly = fReadOnly;

    g_fRecoveryMode = fRecoveryMode;

    g_fClusterMode = fClusterMode;

	DWORD OnlyUpdateRegistry = 0;

	DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;

	_ReadRegistryValue( MIGRATION_UPDATE_REGISTRY_ONLY, &dwSize, &dwType, &OnlyUpdateRegistry);
	if ((OnlyUpdateRegistry == 1) && (CurrentState == msUpdateServersMode || CurrentState == msUpdateClientsMode))
	{
		g_fUpdateRegistry = TRUE;
		HRESULT hr = OnlyUpdateComputers(CurrentState == msUpdateClientsMode);
		return hr;
	}
    
	if (!g_fReadOnly && (CurrentState == msQuickMode))
	{
		//
		// We only want to update the registry. This means that we're in ReadOnly mode for all objects 
		// except registry values.
		//
		g_fUpdateRegistry = TRUE;
	}

    if (!fReadOnly)
    {
        //
        // Read highest USN (the one before starting migration) from DS and
        // save in registry.
        //
        TCHAR wszReplHighestUsn[SEQ_NUM_BUF_LEN];
        hr = ReadFirstNT5Usn(wszReplHighestUsn);
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_GET_FIRST_USN, hr);
            return hr;
        }

        TCHAR wszPrevFirstHighestUsn[SEQ_NUM_BUF_LEN];
        if (!MigReadRegistrySzErr( 
					FIRST_HIGHESTUSN_MIG_REG,
					wszPrevFirstHighestUsn,
					SEQ_NUM_BUF_LEN,
					FALSE /* fShowError */ 
					))
        {
            BOOL f = MigWriteRegistrySz(FIRST_HIGHESTUSN_MIG_REG, wszReplHighestUsn);
            if (!f)
            {
               return  MQMig_E_UNKNOWN;
            }
        }
    }

    char szDSNServerName[MAX_PATH];
    ConvertToMultiByteString(
		szMQISName,
		szDSNServerName,
		(sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) 
		);

    hr =  MakeMQISDsn(szDSNServerName);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szMQISName, hr);
        return hr;
    }

    hr =  ConnectToDatabase();
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szMQISName, hr);
        return hr;
    }

    //
    // Grant myself the RESTORE privilege. This is needed to create objects
    // with owner that differ from my process owner.
    //
    hr = MQSec_SetPrivilegeInThread(SE_RESTORE_NAME, TRUE);
    if (FAILED(hr))
    {
        return hr;
    }

	//
	// This class enable add guid mode on the ctor
	// and disable add guid mode in the dtor
	//
	CAddGuidMode AutoEnableDisableAddGuid;

    //
    // hr1 record the last error, in case that we continue with the
    // migration process. We'll always try to continue as much as possible.
    // we'll abort migration only if error is so severe such that we can't
    // continue.
    //
    HRESULT hr1 = MQMig_OK;

    //
    // It is important to save order of object migration.
    // 1. Enterprise object: do not continue if failed.
    // 2. CNs object: it is important to save all foreign CN before machine migration
    // 3. Sites: it is mandatory to create site object in ADS before machine migration
    // 4. Machines
    // 5. Queues: can be migrated only when machine object is created.
    // 6. Site links
    // 7. Site Gates: 
    //      only after site link migration; 
    //      only after machine migration: because connector machine set site gate, 
    //      and we have to copy SiteGate to SiteGateMig attribute
    // 8. Users
    //

	
    if (g_dwMyService == SERVICE_PEC)
    {
        hr = MigrateEnterprise();
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_ENT, hr);
            return hr;
        }        
    }

    //
    // BUG 5012.
    // We have "to migrate" CNs on both PEC and PSC to know all foreign CNs
    // when connector machine is migrated.
    // On PEC we write all CNs to .ini file and create foreign sites
    // On PSC we only write all CNs to .ini file.
    //
    hr = MigrateCNs();
    if (FAILED(hr))
    {
        ASSERT(0);
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_CNS, hr);
        hr1 = hr;
    }

    //
    // BUG 5321.
    // We have to create this container on both PEC and PSC if they are in
    // different domain.
    // To make life easier we can try to create the container always. If PEC 
    // and PSC are in the same domain, the creation on PSC returned warning.
    // 
    // If creation failed on PEC we have to return immediately (as it was before)
    // If creation failed on PSC we can continue. In the worth case we don't fix this bug:
    // - migrated PEC is offline
    // - setup computers (Win9x) against PSC
    // - migrate PSC. All new computers will not be migrated.
    //
    // Create a default container for computers objects which are
    // not in the DS at present (for exmaple: Win9x computers, or
    // computers from other NT4 domains). We always create this container
    // during migration even if not needed now. We can't later create
    // this container from the replication service (if it need to create
    // it) if the replication service run under the LocalSystem
    // account. So create it now, for any case.
    //
    hr = CreateMsmqContainer(MIG_DEFAULT_COMPUTERS_CONTAINER);
    
    if (FAILED(hr))    
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CREATE_CONTAINER, MIG_DEFAULT_COMPUTERS_CONTAINER, hr);                
        //
        // BUGBUG: return, if failed on PSC?
        //
        return hr;        
    }   
	
    UINT cSites = 0;
    hr = GetSitesCount(&cSites);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SITES_COUNT, hr);
        return hr;
    }
    LogMigrationEvent(MigLog_Info, MQMig_I_SITES_COUNT, cSites);

    P<GUID> pSiteGuid = new GUID[cSites];
    if (g_dwMyService == SERVICE_PEC)
    {
        hr =  MigrateSites(cSites, pSiteGuid);
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_SITES, hr);
            hr1 = hr;
        }
    }
    else
    {
        cSites = 1;
        memcpy(&pSiteGuid[0], &g_MySiteGuid, sizeof(GUID));
        g_iSiteCounter++;
    }
	
    for (UINT i=0; i<cSites; i++)
    {
        hr = MigrateMachinesInSite(&pSiteGuid[i]);
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_MACHINES, hr);
            hr1 = hr;
        }
    }

    if (g_iServerCount == 1)
    {
        *pfIsOneServer = TRUE;
    }
    else
    {
        *pfIsOneServer = FALSE;
    }
    
    hr = MigrateQueues();
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_QUEUES, hr);
        hr1 = hr;
    }

    if (g_dwMyService == SERVICE_PEC)
    {
	    hr = MigrateSiteLinks();
	    if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_SITELINKS, hr);
            hr1 = hr;
        }
	
	    hr = MigrateSiteGates();
	    if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_SITEGATES, hr);
            hr1 = hr;
        }
		
		hr =  MigrateUsers(szDcName);
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_USERS, hr);
            hr1 = hr;
        }
    }

    hr = UpdateRegistry(cSites, pSiteGuid);  

    //
    // that's it ! migration of MQIS is done.
    //
    if (SUCCEEDED(hr))
    {
        BOOL f = MigWriteRegistryDW(FIRST_TIME_REG, 1);
        DBG_USED(f);
        ASSERT(f);
    }

    if (fReadOnly)
    {
        return hr1;
    }

    //
    // not read-only mode
    //
    if (g_fClusterMode)
    {
        LONG cAlloc = 2;
        P<PROPVARIANT> propVar = new PROPVARIANT[cAlloc];
        P<PROPID>      propIds  = new PROPID[cAlloc];
        DWORD          PropIdCount = 0;
        
        //
        // change service of this computer in DS
        //
        propIds[PropIdCount] = PROPID_QM_OLDSERVICE;        
        propVar[PropIdCount].vt = VT_UI4;
        propVar[PropIdCount].ulVal = g_dwMyService;
        PropIdCount++;

        //
        // change msmqNT4Flags to 0 for msmq setting object. We can do it
        // by setting PROPID_QM_SERVICE_DSSERVER 
        //
        // Bug 5264. We need that flag because BSC and PSC using it to find PEC. 
        // After normal migration we set the flag to 0 while the computer is created.
        // Here, in cluster mode, we have to define it explicitly.
        //
        propIds[PropIdCount] = PROPID_QM_SERVICE_DSSERVER;        
        propVar[PropIdCount].vt = VT_UI1;
        propVar[PropIdCount].bVal = TRUE;
        PropIdCount++;
        
        ASSERT((LONG) PropIdCount <= cAlloc);

        CDSRequestContext requestContext(e_DoNotImpersonate, e_ALL_PROTOCOLS);  

        hr = DSCoreSetObjectProperties( 
                    MQDS_MACHINE,
                    NULL, // pathname
                    &g_MyMachineGuid,
                    PropIdCount,
                    propIds,
                    propVar,
                    &requestContext,
                    NULL 
                    );
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_SET_SERVICE, hr);
            return hr;
        }        
        
        if (g_dwMyService == SERVICE_PEC)   //to update remote database only for PEC
        {
            hr = ChangeRemoteMQIS ();
        }
    }

    if (g_dwMyService == SERVICE_PSC)
    {
        return hr1;
    }

    //
    // we are here only if this machine is PEC
    //	

	//
    // Set registry so msmq service, after boot, relax the security
    // of the active directiry, to support nt4 machines.
    // We have to weaken security even if the Enterprise contains
	// only one server (PEC)
	//
    BOOL f = MigWriteRegistryDW(MSMQ_ALLOW_NT4_USERS_REGNAME, 1);
    DBG_USED(f);
    ASSERT(f) ;

    if (*pfIsOneServer)
    {
        return hr1;
    }

    //
    // there is more than one server in Enterprise
    //

    //
    // if we are in recovery mode, change HIGHESTUSN_REPL_REG to
    // FIRST_HIGHESTUSN_MIG_REG.
    // So we'll replicate all PEC's object at the first replication cycle
    //
    if (g_fRecoveryMode)
    {
        DWORD dwAfterRecovery = 1;
        BOOL f = MigWriteRegistryDW( AFTER_RECOVERY_MIG_REG, dwAfterRecovery);
        ASSERT (f);

        //
        // we have to replace FirstMigUsn to the minimal MSMQ Usn
        // since we can lost NT5 MSMQ objects that was not replicated
        // to NT4 before crash.
        //
        TCHAR wszMinUsn[SEQ_NUM_BUF_LEN];
        hr = FindMinMSMQUsn(wszMinUsn);
        f = MigWriteRegistrySz(FIRST_HIGHESTUSN_MIG_REG, wszMinUsn);
        ASSERT(f);
    }
   
    return hr1;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_MigrateFromMQIS(LPTSTR szMQISName)
//
//  Input parameters:
//      fReadOnly- TRUE if user wants only to read MQIS database.
//          Relevant in debug mode.
//      fAlreadyExist- TRUE if we allow migration to continue if MSMQ
//          objects are already found in NT5 DS. By default, FALSE when
//          migrating the PEC and TRUE afterward, when migrating PSCs.
//
//+--------------------------------------------------------------------

HRESULT  MQMig_MigrateFromMQIS( LPTSTR  szMQISName,
                                LPTSTR  szDcName,
                                BOOL    fReadOnly,
                                BOOL    fRecoveryMode,
                                BOOL	fClusterMode,
                                LPTSTR  szLogFile,
                                ULONG   ulTraceFlags,
                                BOOL    *pfIsPEC,
                                DWORD   CurrentState,
                                BOOL    *pfIsOneServer
								)
{
    g_iSiteCounter = 0;
    g_iMachineCounter = 0;
    g_iQueueCounter = 0;
	g_iUserCounter = 0;

    InitLogging( szLogFile, ulTraceFlags, fReadOnly ) ;

    HRESULT hr =  _MigrateInternal( szMQISName,
                                    szDcName,
                                    fReadOnly,
                                    fRecoveryMode,
                                    fClusterMode,
                                    CurrentState,
                                    pfIsOneServer
                                    ) ;
    *pfIsPEC = (g_dwMyService == SERVICE_PEC) ;
    CleanupDatabase() ;

    EndLogging() ;

    if (!g_fReadOnly)
    {
        //
        // remove section: MIGRATION_MACHINE_WITH_INVALID_NAME from .ini
        // ???Does we need to leave this section?
        //
        TCHAR *pszFileName = GetIniFileName ();
        BOOL f = WritePrivateProfileString( 
                        MIGRATION_MACHINE_WITH_INVALID_NAME,
                        NULL,
                        NULL,
                        pszFileName ) ;
        DBG_USED(f);
        ASSERT(f) ;
    }

	if (!g_fReadOnly && SUCCEEDED(hr))
	{
	    if (!MigWriteRegistryDW(MIGRATION_UPDATE_REGISTRY_ONLY, 1))
	    {
			return MQMig_E_SET_REG_DWORD;
	    }
	    if (!g_fAllMachinesDemoted)
	    {
			return MQMig_E_SET_REG_SZ;
	    }
	}

    return hr ;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_CheckMSMQVersionOnServers()
//
//  Input parameters:
//      LPTSTR szMQISName
//
//  Output parameters:
//      piCount- number of all servers with version less than MSMQ SP4
//      ppszServers- list of all servers with version less than MSMQ SP4
//
//+--------------------------------------------------------------------

HRESULT  MQMig_CheckMSMQVersionOfServers( IN  LPTSTR  szMQISName,
                                          IN  BOOL    fIsClusterMode,
                                          OUT UINT   *piCount,
                                          OUT LPTSTR *ppszServers )
{
    HRESULT hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (g_dwMyService == SERVICE_PSC)
    {
        return MQMig_OK;
    }	

    char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
    ConvertToMultiByteString(szMQISName,
                             szDSNServerName,
                 (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
    lstrcpy(szDSNServerName, szMQISName) ;
#endif

    hr = MakeMQISDsn(szDSNServerName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szMQISName, hr) ;
        return hr ;
    }

    hr =  ConnectToDatabase() ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szMQISName, hr) ;
        return hr ;
    }

    g_fClusterMode = fIsClusterMode ;

    hr = CheckVersion (piCount, ppszServers);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CHECK_VERSION, hr) ;
        return hr ;
    }

    return hr;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_GetObjectsCount( LPTSTR  szMQISName,
//                                  UINT   *piSiteCount,
//                                  UINT   *piMachineCount,
//                                  UINT   *piQueueCount )
//
//  Input parameters:
//      LPTSTR szMQISName
//
//  Output parameters:
//      number of all sites in enterprise, if it is PEC; otherwise 1
//      number of all machines in enterprise, if it is PEC;
//       otherwise all machines in this SITE
//      number of all queues in enterprise, if it is PEC;
//       otherwise all queues in this SITE
//
//+--------------------------------------------------------------------

HRESULT  MQMig_GetObjectsCount( IN  LPTSTR  szMQISName,
                                OUT UINT   *piSiteCount,
                                OUT UINT   *piMachineCount,
                                OUT UINT   *piQueueCount,
								OUT UINT   *piUserCount
							   )
{
    HRESULT hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return hr ;
    }

    char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
    ConvertToMultiByteString(szMQISName,
                             szDSNServerName,
                 (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
    lstrcpy(szDSNServerName, szMQISName) ;
#endif

    hr = MakeMQISDsn(szDSNServerName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szMQISName, hr) ;
        return hr ;
    }

    hr =  ConnectToDatabase() ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szMQISName, hr) ;
        return hr ;
    }

    if (g_dwMyService == SERVICE_PSC)
    {
        *piSiteCount = 1;

        hr =  GetMachinesCount(&g_MySiteGuid,
                               piMachineCount) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_COUNT, hr) ;
            return hr ;
        }

        //
        // get all queues in site
        //
        hr = GetAllQueuesInSiteCount( &g_MySiteGuid,
                                      piQueueCount );
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_QUEUES_COUNT, hr) ;
            return hr;
        }

        return MQMig_OK;
    }

    hr = GetSitesCount(piSiteCount) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SITES_COUNT, hr) ;
        return hr ;
    }
    LogMigrationEvent(MigLog_Info, MQMig_I_SITES_COUNT, *piSiteCount) ;

    //
    // get all machines in Enterprise
    //
    hr = GetAllMachinesCount(piMachineCount);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_COUNT, hr) ;
        return hr ;
    }

    //
    // get all queues in Enterprise
    //
    hr = GetAllQueuesCount(piQueueCount);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_QUEUES_COUNT, hr) ;
        return hr;
    }

	hr = GetUserCount(piUserCount);
	if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_USERS_COUNT, hr) ;
        return hr ;
    }
    LogMigrationEvent(MigLog_Info, MQMig_I_USERS_COUNT, *piUserCount) ;

    return MQMig_OK;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_GetAllCounters( UINT   *piSiteCount,
//                                 UINT   *piMachineCount,
//                                 UINT   *piQueueCount,
//								   UINT   *piUserCount )
//
//  Output parameters:
//      current SiteCounter
//      current MachineCounter
//      current QueueCounter
//		current UserCounter
//
//+--------------------------------------------------------------------

HRESULT  MQMig_GetAllCounters( OUT UINT   *piSiteCounter,
                               OUT UINT   *piMachineCounter,
                               OUT UINT   *piQueueCounter,
							   OUT UINT	  *piUserCounter
							 )
{
    *piSiteCounter =    g_iSiteCounter;
    *piMachineCounter = g_iMachineCounter;
    *piQueueCounter =   g_iQueueCounter;
	*piUserCounter =	g_iUserCounter;

    return MQMig_OK;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_SetSiteIdOfPEC( IN  LPTSTR  szRemoteMQISName )
//
//  Function is called in recovery mode only. We have to replace
//  PEC machine 's SiteID we got from setup to its correct NT4 SiteId
//
//+--------------------------------------------------------------------

HRESULT  MQMig_SetSiteIdOfPEC( IN  LPTSTR  szRemoteMQISName,
                               IN  BOOL	   fIsClusterMode,		
                               IN  DWORD   dwInitError,
                               IN  DWORD   dwConnectDatabaseError,
                               IN  DWORD   dwGetSiteIdError,
                               IN  DWORD   dwSetRegistryError,
                               IN  DWORD   dwSetDSError)
{    
    char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
    ConvertToMultiByteString(szRemoteMQISName,
                             szDSNServerName,
                 (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
    lstrcpy(szDSNServerName, szRemoteMQISName) ;
#endif

    HRESULT hr = MakeMQISDsn(szDSNServerName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szRemoteMQISName, hr) ;
        return dwConnectDatabaseError ;
    }

    hr =  ConnectToDatabase() ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szRemoteMQISName, hr) ;
        return dwConnectDatabaseError ;
    }

    ULONG ulService = 0;
    g_fClusterMode = fIsClusterMode;
    
    hr = GetSiteIdOfPEC (szRemoteMQISName, &ulService, &g_MySiteGuid);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_GET_SITEID, szRemoteMQISName, hr) ;
        return dwGetSiteIdError ;
    }

    //
    // update registry:
    // MasterId entry will be created (it does not exist after setup)
    // SiteId entry will be updated to the correct value
    //
    g_fReadOnly = FALSE;    //we write to registry only if this flag is FALSE
	
    //
    // write MasterId in Migration section to know later that migration tool 
    // added this registry
    //
    BOOL f = MigWriteRegistryGuid( MIGRATION_MQIS_MASTERID_REGNAME,
			                       &g_MySiteGuid ) ;
    if (!f)
    {
        return  dwSetRegistryError ;
    }
   
    if (fIsClusterMode)
    {
        ASSERT (ulService >= SERVICE_PSC);
    }
    else
    {
        ASSERT (ulService==SERVICE_PEC);    //recovery mode
    }
    
    f = MigWriteRegistryDW( MSMQ_MQS_REGNAME,
			                ulService ) ;

    if (fIsClusterMode)
    {
        //
        // in cluster mode we leave site id of this server as we got it after the setup
        // we don't need update DS too (more than that: on this stage we can't
        // change SiteIDs in DS since this site does not exist in DS. It is possible
        // only in recovery mode)
        //
        return MQMig_OK;
    }

    f = MigWriteRegistryGuid( MSMQ_SITEID_REGNAME,
						      &g_MySiteGuid ) ;
    if (!f)
    {
       return  dwSetRegistryError ;
    }	

    //
    // update DS information
    //
    hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return dwInitError ;
    }
    
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                      e_ALL_PROTOCOLS);


    PROPID       SiteIdsProp = PROPID_QM_SITE_IDS;
    PROPVARIANT  SiteIdsVar;
    SiteIdsVar.vt = VT_CLSID|VT_VECTOR;
    SiteIdsVar.cauuid.cElems = 1;
    SiteIdsVar.cauuid.pElems = &g_MySiteGuid;

    hr = DSCoreSetObjectProperties (
                MQDS_MACHINE,
                NULL,             //path name
                &g_MyMachineGuid,	 // guid
                1,
                &SiteIdsProp,
                &SiteIdsVar,
                &requestContext,
                NULL );    

    if (FAILED(hr))
    {
       return dwSetDSError;
    }

    return MQMig_OK;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_UpdateRemoteMQIS()
//
//  Function is called in update mode only. It means that we ran migration
//  tool to migrate all objects from MQIS database of clustered PEC. 
//  While the clustered PEC was upgraded there were several off-line
//  servers. We are going to update them.
//  We have to update remote MQIS database on specified server (szRemoteMQISName)
//  or on all servers are written in .ini file
//
//+--------------------------------------------------------------------
HRESULT  MQMig_UpdateRemoteMQIS( 
                      IN  DWORD   dwGetRegistryError,
                      IN  DWORD   dwInitError,
                      IN  DWORD   dwUpdateMQISError,  
                      OUT LPTSTR  *ppszUpdatedServerName,
                      OUT LPTSTR  *ppszNonUpdatedServerName
                      )
{
    //
    // first, check if have all needed registry key
    //
    HRESULT hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return dwInitError ;
    }
    
    if (g_dwMyService == SERVICE_PSC)
    {
        return MQMig_OK;
    }

    //
    // get guid of former PEC from registry
    //    
    BOOL f = MigReadRegistryGuid( MIGRATION_FORMER_PEC_GUID_REGNAME,
                                  &g_FormerPECGuid ) ;
    if (!f)
    {
       return  dwGetRegistryError ;
    }    
    
    ULONG ulBeforeUpdate = 0;
    BuildServersList(ppszUpdatedServerName, &ulBeforeUpdate);
    hr = ChangeRemoteMQIS ();       

    if (FAILED(hr))
    {        
        ULONG ulAfterUpdate = 0;
        BuildServersList(ppszNonUpdatedServerName, &ulAfterUpdate);
        if (ulBeforeUpdate == ulAfterUpdate)
        {
            //
            // there are no servers which were updated
            //
            delete *ppszUpdatedServerName;
            *ppszUpdatedServerName = NULL;
        }
        else if (ulBeforeUpdate > ulAfterUpdate)
        {
            //
            // several servers (not all) were updated
            //
            RemoveServersFromList(ppszUpdatedServerName, ppszNonUpdatedServerName);
        }
        else
        {
            ASSERT(0);
        }
        return dwUpdateMQISError;
    }    

    return MQMig_OK;
}

//+----------------------------
//
//  Function:   DllMain
//
//-----------------------------

BOOL WINAPI DllMain( IN HANDLE ,
                     IN DWORD  Reason,
                     IN LPVOID Reserved )
{
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )
    {
        case DLL_PROCESS_ATTACH:
        {
		CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ", KEY_READ);
		TrInitialize();
		EvInitialize(QM_DEFAULT_SERVICE_NAME);
          //DisableThreadLibraryCalls( MyModuleHandle );
            break;
        }

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migratui.h ===
//
// file: migratui.h
//

const UINT cwcResBuf = 2048;

extern HINSTANCE g_hResourceMod;

class CResString
{
public:
    CResString() { _awc[ 0 ] = 0; }

    CResString( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
    }

    BOOL Load( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
        return ( 0 != _awc[ 0 ] );
    }

    TCHAR const * Get() { return _awc; }

private:
    TCHAR _awc[ cwcResBuf ];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migrat.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migrat.cpp

Abstract:

    Entry point for migration dll.

Author:

    Doron Juster  (DoronJ)  03-Feb-1998

--*/

#include "migrat.h"
#include <mixmode.h>
#include <mqsec.h>

#include "migrat.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migsites.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migsites.cpp

Abstract:

    Migration NT4 CN objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "migsites.tmh"

//-------------------------------------------------
//
//  HRESULT _InsertSiteInNT5DS()
//
//-------------------------------------------------

static HRESULT _InsertSiteInNT5DS( GUID   *pSiteGuid,
                                   UINT   iIndex,                                   
                                   BOOL   fMySite = FALSE )
{
    UNREFERENCED_PARAMETER(fMySite);
    //
    // Read site properties from MQIS database.
    //
    LONG cAlloc = 4 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_NAME_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_NAME_CTYPE ;
    LONG iSiteNameIndex = cColumns ;
    cColumns++ ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_PSC_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_PSC_CTYPE ;
    LONG iPSCNameIndex = cColumns ;
    cColumns++ ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_INTREVAL1_COL ; //must be S_INTERVAL, ds\h\mqiscol.h
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_INTREVAL1_CTYPE ;  
    LONG iInterval1Index = cColumns;
    cColumns++ ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_INTERVAL2_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_INTERVAL2_CTYPE ;    
    LONG iInterval2Index = cColumns;
    cColumns++ ;

    MQDBCOLUMNSEARCH ColSearch[2] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = S_ID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = S_ID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    //
    // Create "stub" site in NT5 DS, for compatibility of guids.
    //
    HRESULT hr= CreateSite(
                    pSiteGuid,
                    (LPWSTR) pColumns[ iSiteNameIndex ].nColumnValue,
                    FALSE,    // fForeign   
                    (USHORT) pColumns[ iInterval1Index ].nColumnValue,
                    (USHORT) pColumns[ iInterval2Index ].nColumnValue
                    ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    LogMigrationEvent( MigLog_Info, MQMig_I_SITE_MIGRATED,
                                        iIndex,
                                  pColumns[ iSiteNameIndex ].nColumnValue,
                                  pColumns[ iPSCNameIndex ].nColumnValue ) ;

    MQDBFreeBuf((void*) pColumns[ iPSCNameIndex ].nColumnValue ) ;    
    MQDBFreeBuf((void*) pColumns[ iSiteNameIndex ].nColumnValue ) ;

    return S_OK ;
}

//-----------------------------------------
//
//  HRESULT MigrateSites(UINT cSites)
//
//-----------------------------------------

HRESULT MigrateSites( IN UINT  cSites,
                      IN GUID  *pSiteGuid )
{
    if (cSites == 0)
    {
        return MQMig_E_NO_SITES_AVAILABLE ;
    }

    //
    // Prepare a list of guids of all sites.
    //

    LONG cAlloc = 1 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_ID_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_ID_CTYPE ;
    UINT iGuidIndex = cColumns ;
    cColumns++ ;

    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    while(SUCCEEDED(status))
    {
        if (iIndex >= cSites)
        {
            status = MQMig_E_TOO_MANY_SITES ;
            break ;
        }

        memcpy(&pSiteGuid[ iIndex ],
                (void*) pColumns[ iGuidIndex ].nColumnValue,
                sizeof(GUID) ) ;

        for ( LONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    HRESULT hr = MQMig_E_UNKNOWN ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_SITES_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != cSites)
    {
        //
        // Mismatch in number of sites.
        //
        hr = MQMig_E_FEWER_SITES ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, cSites) ;
        return hr ;
    }

    BOOL fFound = FALSE ;
    
    //
    // This is the first time migration tool is run on this NT5
    // enterprise. Migrating the entire MQIS database into NT5 DS.
    // First migrate the PEC site, then all the other.
    //
    for ( UINT j = 0 ; j < cSites ; j++ )
    {
        if (memcmp(&pSiteGuid[j], &g_MySiteGuid, sizeof(GUID)) == 0)
        {
            if (j != 0)
            {
                pSiteGuid[j] = pSiteGuid[0] ;
                pSiteGuid[0] = g_MySiteGuid ;
            }
            fFound = TRUE ;
            break ;
        }
    }
    if (!fFound)
    {
        hr = MQMig_E_PECSITE_NOT_FOUND ;
        LogMigrationEvent(MigLog_Error, hr) ;
        return hr ;
    }
    
    hr = _InsertSiteInNT5DS( &pSiteGuid[ 0 ], 0, TRUE );

    CHECK_HR(hr) ;
    g_iSiteCounter++;

    //
    // Now migrate all other sites.
    //
    for ( j = 1 ; j < cSites ; j++ )
    {        
        hr = _InsertSiteInNT5DS( &pSiteGuid[ j ], j);                                     

        CHECK_HR(hr) ;
        g_iSiteCounter++;
    }    

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migusers.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    migusers.cpp

Abstract:

    Handle migration of users certificates into active directory.

Author:

    Doron Juster  (DoronJ)

--*/

#include "migrat.h"
#include <mixmode.h>

#include "migusers.tmh"

//+------------------------------
//
//  HRESULT TouchAUser()
//
//  Touch current logged on user to replicate it to nT4 World later
//
//+------------------------------

HRESULT TouchAUser (PLDAP           pLdap,
					LDAPMessage		*pEntry )
{
    WCHAR **ppPath = ldap_get_values( pLdap,
                                      pEntry,
                        const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE) ) ;
    ASSERT(ppPath) ;

    WCHAR **ppDesc = ldap_get_values( pLdap,
                                      pEntry,
                    const_cast<LPWSTR> (MQ_U_DESCRIPTION_ATTRIBUTE) ) ;

    HRESULT hr = MQMig_OK;

    if (ppDesc)
    {
        //
        // description was defined: change it and return to initial value
        //
        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             NULL,
             NULL
             );

        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             *ppDesc,
             NULL
             );

    }
    else
    {
        //
        // description was not set: change to something and reset it
        //
        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             L"MSMQ",
             NULL
             );

        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             NULL,
             NULL
             );
    }

    //
    // delete mig attributes (if they are defined) to replicate
    // all certificates and digests of this user
    // see replserv\rpusers.cpp: we replicate only such digests and certificates
    // which are presented in Digest and Certificate attributes
    // and not presented in mig attributes.
    //
    hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DIGEST_MIG_ATTRIBUTE),
             NULL,
             NULL
             );

    hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_SIGN_CERT_MIG_ATTRIBUTE),
             NULL,
             NULL
             );

    int i = ldap_value_free( ppDesc ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    i = ldap_value_free( ppPath ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    return hr;
}
//-------------------------------------------------------------------------
//
//  HRESULT HandleAUser
//
//  Copy the MSMQ certificates in the specific user object to the "mig" attributes.
//  These attributes mirror the  "normal" msmq attributes in the user
//  object and are used in the replication service, to enable replication
//  of changes to MSMQ1.0.
//
//-------------------------------------------------------------------------

HRESULT HandleAUser(PLDAP           pLdap,
					LDAPMessage		*pEntry )
{
    HRESULT hr = MQMig_OK;

    WCHAR **ppPath = ldap_get_values( pLdap,
                                          pEntry,
                        const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE) ) ;
    ASSERT(ppPath) ;

    PLDAP_BERVAL *ppVal = ldap_get_values_len( pLdap,
                                               pEntry,
                   const_cast<LPWSTR> (MQ_U_DIGEST_ATTRIBUTE) ) ;
    ASSERT(ppVal) ;
    if (ppVal && ppPath)
    {
        hr = ModifyAttribute(
                 *ppPath,
                 const_cast<WCHAR*> (MQ_U_DIGEST_MIG_ATTRIBUTE),
                 NULL,
                 ppVal
                 );
    }
    int i = ldap_value_free_len( ppVal ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    ppVal = ldap_get_values_len( pLdap,
                                 pEntry,
                   const_cast<LPWSTR> (MQ_U_SIGN_CERT_ATTRIBUTE) ) ;
    ASSERT(ppVal) ;
    if (ppVal && ppPath)
    {
        hr = ModifyAttribute(
                 *ppPath,
                 const_cast<WCHAR*> (MQ_U_SIGN_CERT_MIG_ATTRIBUTE),
                 NULL,
                 ppVal
                 );
    }

    i = ldap_value_free_len( ppVal ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    i = ldap_value_free( ppPath ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    return hr;
}

//-------------------------------------------------------------------------
//
//  HRESULT  _CopyUserValuesToMig()
//
//  Copy the MSMQ certificates in the user object to the "mig" attributes.
//  These attributes mirror the  "normal" msmq attributes in the user
//  object and are used in the replication service, to enable replication
//  of changes to MSMQ1.0.
//
//-------------------------------------------------------------------------

HRESULT _CopyUserValuesToMig(BOOL fMSMQUserContainer)
{
    HRESULT hr;

    PLDAP pLdapGC = NULL ;
    TCHAR *pszDefName = NULL ;

    hr =  InitLDAP(&pLdapGC, &pszDefName, LDAP_GC_PORT) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // to get schema naming context we need pLdap opened with LDAP_PORT
    // we can use the same variable pszDefName since then we re-define it
    //
    PLDAP pLdap = NULL;
    hr =  InitLDAP(&pLdap, &pszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdap, &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // we are looking for all users and msmq users in GC,
    // so we need to start from the root
    // => redefine default context to empty string
    //
    pszDefName = EMPTY_DEFAULT_CONTEXT;

    DWORD dwDNSize = wcslen(pszDefName) ;
    P<WCHAR> pwszDN  = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, pszDefName);

    TCHAR *pszCategoryName;
    if (fMSMQUserContainer)
    {
        pszCategoryName = const_cast<LPTSTR> (x_MQUserCategoryName);
    }
    else
    {
        pszCategoryName = const_cast<LPTSTR> (x_UserCategoryName);
    }

    TCHAR wszFullName[256];
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName,pszSchemaDefName);

    TCHAR  wszFilter[ 512 ] ;
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;
    _tcscat(wszFilter, wszFullName);

    _tcscat(wszFilter, TEXT(")(")) ;
    _tcscat(wszFilter, MQ_U_SIGN_CERT_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=*))")) ;

    PWSTR rgAttribs[4] = {NULL, NULL, NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (MQ_U_SIGN_CERT_ATTRIBUTE);
    rgAttribs[1] = const_cast<LPWSTR> (MQ_U_DIGEST_ATTRIBUTE);
    rgAttribs[2] = const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE);

    hr = QueryDS(   pLdapGC,			
                    pwszDN,
                    wszFilter,			
                    MQDS_USER,
                    rgAttribs,
                    FALSE
                );

    return hr;
}

//-------------------------------------------
//
//  HRESULT  _InsertUserInNT5DS()
//
//-------------------------------------------

HRESULT _InsertUserInNT5DS(
			PBYTE pSID,	
			ULONG ulSidLength,
			PBYTE pSignCert,
			ULONG ulSignCertLength,
			GUID* pDigestId,
			GUID* pUserId
			)
{
    PSID pSid = (PSID) pSID ;
    if (!IsValidSid(pSid))
    {
        HRESULT hr = MQMig_E_SID_NOT_VALID ;
        LogMigrationEvent(MigLog_Error, hr) ;
        return hr ;
    }

    DWORD dwSidLen = GetLengthSid(pSid) ;
    if (dwSidLen > ulSidLength)
    {
        HRESULT hr = MQMig_E_SID_LEN ;
        LogMigrationEvent(MigLog_Error, hr) ;
        return hr ;
    }

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

	//
    // Prepare the properties for DS call.
    //
    LONG cAlloc = 4;
    P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];
    P<PROPID>      paPropId  = new PROPID[ cAlloc ];
    DWORD          PropIdCount = 0;

    paPropId[ PropIdCount ] = PROPID_U_ID;		//PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
    paVariant[PropIdCount].puuid = pUserId ;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_U_SID;			//PropId
    paVariant[ PropIdCount ].vt = VT_BLOB;          //Type
	paVariant[ PropIdCount ].blob.cbSize = dwSidLen ;
	paVariant[ PropIdCount ].blob.pBlobData = pSID;
    PropIdCount++;

	paPropId[ PropIdCount ] = PROPID_U_SIGN_CERT;   //PropId
    paVariant[ PropIdCount ].vt = VT_BLOB;          //Type
	paVariant[ PropIdCount ].blob.cbSize = ulSignCertLength;
	paVariant[ PropIdCount ].blob.pBlobData = pSignCert;
    PropIdCount++;

	paPropId[ PropIdCount ] = PROPID_U_DIGEST;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;       //Type
    paVariant[ PropIdCount ].puuid = pDigestId;
    PropIdCount++;

	ASSERT((LONG) PropIdCount == cAlloc) ;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

	HRESULT hr = DSCoreCreateObject( MQDS_USER,
            						 NULL,
			            			 PropIdCount,
						             paPropId,
            						 paVariant,
                                     0,
                                     NULL,
                                     NULL,
                                     &requestContext,
                                     NULL,
                                     NULL ) ;

    if ((hr == MQDS_CREATE_ERROR)                               ||
        (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))        ||
        (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)) ||    //BUGBUG alexdad to throw away after transition
        (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS)))
    {
        //
        // For user object, the mqdscore library return MQDS_CREATE_ERROR
        // if the record (certificate) already exist in the DS.
        // In this case, this is OK.
        //
        hr = MQMig_OK ;
    }

	return hr;
}

//-------------------------------------------
//
//  HRESULT MigrateUsers()
//
//-------------------------------------------

#define INIT_USER_COLUMN(_ColName, _ColIndex, _Index)               \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateUsers(LPTSTR lpszDcName)
{
    HRESULT hr = OpenUsersTable() ;
    CHECK_HR(hr) ;

    ULONG cColumns = 0 ;
	ULONG cAlloc = 4 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_USER_COLUMN(U_SID,			iSIDIndex,			cColumns) ;
	INIT_USER_COLUMN(U_DIGEST,		iDigestIndex,		cColumns) ;
	INIT_USER_COLUMN(U_SIGN_CERT,	iSignCertIndex,		cColumns) ;
	INIT_USER_COLUMN(U_ID,			iIdIndex,			cColumns) ;

    ASSERT(cColumns == cAlloc);

    MQDBHANDLE hQuery = NULL ;
    MQDBSTATUS status = MQDBOpenQuery( g_hUsersTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    if (status == MQDB_E_NO_MORE_DATA)
    {
        LogMigrationEvent(MigLog_Warning, MQMig_I_NO_USERS) ;
        return MQMig_OK ;
    }
    CHECK_HR(status) ;
    
    DWORD dwErr = 0 ;
    HRESULT hr1 = MQMig_OK;

    while(SUCCEEDED(status))
    {
#ifdef _DEBUG
        UINT iIndex = g_iUserCounter ;
        static BOOL s_fIniRead = FALSE ;
        static BOOL s_fPrint = FALSE ;

        if (!s_fIniRead)
        {
            s_fPrint = (UINT)  ReadDebugIntFlag(TEXT("PrintUsers"), 1) ;
            s_fIniRead = TRUE ;
        }

        if (s_fPrint)
        {
            TCHAR  szUserName[ 512 ] = {TEXT('\0')} ;
            DWORD  cUser = sizeof(szUserName) / sizeof(szUserName[0]) ;
            TCHAR  szDomainName[ 512 ] = {TEXT('\0')} ;
            DWORD  cDomain = sizeof(szDomainName) / sizeof(szDomainName[0]) ;
            SID_NAME_USE  se ;

            BOOL f = LookupAccountSid(
                            lpszDcName,
                            (PSID) pColumns[ iSIDIndex ].nColumnValue,
                            szUserName,
                            &cUser,
                            szDomainName,
                            &cDomain,
                            &se ) ;
            if (!f)
            {
                dwErr = GetLastError() ;
                szUserName[0] = TEXT('\0') ;
                szDomainName[0] = TEXT('\0') ;
            }

            unsigned short *lpszGuid ;
            UuidToString((GUID*) pColumns[ iDigestIndex ].nColumnValue,
                          &lpszGuid ) ;

            LogMigrationEvent( MigLog_Info,
                               MQMig_I_USER_MIGRATED,
                               iIndex,
                               szDomainName,
                               szUserName,
                               lpszGuid ) ;
            RpcStringFree( &lpszGuid ) ;
            iIndex++ ;
        }
#endif
	
		HRESULT hr = _InsertUserInNT5DS(
					        (PBYTE) pColumns[ iSIDIndex ].nColumnValue,			//"SID"
					        pColumns[ iSIDIndex ].nColumnLength,
					        (PBYTE) pColumns[ iSignCertIndex ].nColumnValue,	//"SignCert"
					        pColumns[ iSignCertIndex ].nColumnLength,
					        (GUID*) pColumns[ iDigestIndex ].nColumnValue,		//"Digest"
					        (GUID*) pColumns[ iIdIndex ].nColumnValue			//"UserId"
					        );
        
        if (FAILED (hr))
        {
            //
            // log the error
            //
            TCHAR  szUserName[ 512 ] = {TEXT('\0')} ;
            DWORD  cUser = sizeof(szUserName) / sizeof(szUserName[0]) ;
            TCHAR  szDomainName[ 512 ] = {TEXT('\0')} ;
            DWORD  cDomain = sizeof(szDomainName) / sizeof(szDomainName[0]) ;
            SID_NAME_USE  se ;

            BOOL f = LookupAccountSid(
                            lpszDcName,
                            (PSID) pColumns[ iSIDIndex ].nColumnValue,
                            szUserName,
                            &cUser,
                            szDomainName,
                            &cDomain,
                            &se ) ;
            if (!f)
            {
                dwErr = GetLastError() ;
                szUserName[0] = TEXT('\0') ;
                szDomainName[0] = TEXT('\0') ;
            }

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_REFERRAL))
            {                
                LogMigrationEvent( MigLog_Error,
                                   MQMig_E_USER_REMOTE_DOMAIN_OFFLINE,
                                   szDomainName ) ;
            }
            else
            {
                LogMigrationEvent( MigLog_Error,
                                   MQMig_E_CANT_MIGRATE_USER,
                                   szUserName, szDomainName, hr ) ;
            }

            //
            // save error to return it and continue with the next user
            //
            hr1 = hr ;  
        }

        for ( ULONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
      
		g_iUserCounter++;

        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;
    
    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_USERS_SQL_FAIL, status) ;

        return status ;
    }

    ASSERT(g_iUserCounter != 0) ;

    if (FAILED(hr1))
    {
        return hr1 ;
    }

    //
    // for each created user copy Digest and Certificates to
    // DigestMig and CertificatesMig
    //
    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    hr1 = _CopyUserValuesToMig(FALSE);   //modify user objects
    hr = _CopyUserValuesToMig(TRUE);             //modify mquser objects

    if ((hr1 == MQMig_OK) || (hr == MQMig_OK))
    {
        return MQMig_OK;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migreg.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migreg.cpp

Abstract:

    Handle registry.

Author:

    Doron Juster  (DoronJ)  22-Mar-1998

--*/

#include "migrat.h"
#include "mqtypes.h"
#include "_mqreg.h"
#include "..\..\setup\msmqocm\service.h"

#include "migreg.tmh"

//============================================
//
//   BOOL GenerateSubkeyValue()
//
//============================================

BOOL _GenerateSubkeyValue(
                	IN     const BOOL    fWriteToRegistry,
                	IN     const LPCTSTR szEntryName,
                	IN OUT       PTCHAR  szValueName,
                	IN OUT       HKEY    &hRegKey)
{
    //
    // Store the full subkey path and value name
    //
    TCHAR szKeyName[256 * MAX_BYTES_PER_CHAR];
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    if (szValueName)
    {
        _tcscpy(szValueName, _tcsinc(pLastBackslash));
        _tcscpy(pLastBackslash, TEXT(""));
    }

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;
    HRESULT hResult = RegCreateKeyEx( FALCON_REG_POS,
                                      szKeyName,
                                      0,
                                      NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &hRegKey,
                                      &dwDisposition);

	if (hResult != ERROR_SUCCESS && fWriteToRegistry)
	{
        LogMigrationEvent(MigLog_Error, MQMig_E_CREATE_REG,
                                                szKeyName, hResult) ;
		return FALSE;
	}

	return TRUE;
}

//============================================
//
//  _WriteRegistryValue()
//
//============================================

BOOL
_WriteRegistryValue(
    IN const LPCTSTR szEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData)
{
    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
	HKEY hRegKey;

	if (!_GenerateSubkeyValue( TRUE, szEntryName, szValueName, hRegKey))
    {
        return FALSE;
    }

    //
    // Set the requested registry value
    //
    LONG rc = ERROR_SUCCESS ;
    if (!g_fReadOnly)
    {
        rc = RegSetValueEx( hRegKey,
                            szValueName,
                            0,
                            dwValueType,
                            (BYTE *)pValueData,
                            dwNumBytes);
    }
    RegFlushKey(hRegKey);
    RegCloseKey(hRegKey);

    return (rc == ERROR_SUCCESS);
}

//============================================
//
//  _ReadRegistryValue()
//
//============================================

BOOL
_ReadRegistryValue(
    IN const LPCTSTR szEntryName,
    IN       DWORD   *pdwNumBytes,
    IN       DWORD   *pdwValueType,
    IN const PVOID   pValueData)
{
    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
	HKEY hRegKey;

	if (!_GenerateSubkeyValue( TRUE, szEntryName, szValueName, hRegKey))
    {
        return FALSE;
    }

    //
    // Set the requested registry value
    //
    LONG rc = RegQueryValueEx( hRegKey,
                               szValueName,
                               0,
                               pdwValueType,
                               (BYTE *)pValueData,
                               pdwNumBytes );
    RegCloseKey(hRegKey);

    return (rc == ERROR_SUCCESS);
}

//============================================
//
//  BOOL MigWriteRegistrySz()
//
//============================================

BOOL  MigWriteRegistrySz( LPTSTR  lpszRegName,
                          LPTSTR  lpszValue )
{
    if (!_WriteRegistryValue( lpszRegName,
                              (_tcslen(lpszValue) * sizeof(TCHAR)),
		                      REG_SZ,
                              lpszValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_SZ,
                                                lpszRegName, lpszValue) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigWriteRegistryDW()
//
//============================================

BOOL  MigWriteRegistryDW( LPTSTR  lpszRegName,
                          DWORD   dwValue )
{
    if (!_WriteRegistryValue( lpszRegName,
                              sizeof(DWORD),
		                      REG_DWORD,
                              &dwValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_DWORD,
                                                lpszRegName, dwValue) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigWriteRegistryGuid()
//
//============================================

BOOL  MigWriteRegistryGuid( LPTSTR  lpszRegName,
                            GUID    *pGuid )
{
    if (!_WriteRegistryValue( lpszRegName,
                              sizeof(GUID),
		                      REG_BINARY,
                              pGuid ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_GUID, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistryGuid()
//
//  Memory for guid must be allocated by caller.
//
//============================================

BOOL  MigReadRegistryGuid( LPTSTR  lpszRegName,
                           GUID    *pGuid )
{
    DWORD dwSize = sizeof(GUID) ;
    DWORD dwType = REG_BINARY ;

    if (!_ReadRegistryValue( lpszRegName,
                             &dwSize,
		                     &dwType,
                             pGuid ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_REG_GUID, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistryDW()
//
//  Memory for dword must be allocated by caller.
//
//============================================

BOOL  MigReadRegistryDW( LPTSTR  lpszRegName,
                         DWORD   *pdwValue )
{
    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;

    if (!_ReadRegistryValue( lpszRegName,
                             &dwSize,
		                     &dwType,
                             pdwValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_REG_DWORD, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistrySz()
//
//  Memory for string must be allocated by caller.
//
//============================================

BOOL  MigReadRegistrySz( LPTSTR  lpszRegName,
                         LPTSTR  lpszValue,
                         DWORD   dwSize)
{
    DWORD dwType = REG_SZ ;

    if (!_ReadRegistryValue( lpszRegName,
                             &dwSize,
		                     &dwType,
                             lpszValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_REG_SZ, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistrySzErr()
//
//  Memory for string must be allocated by caller.
//
//============================================

BOOL  MigReadRegistrySzErr( LPTSTR  lpszRegName,
                            LPTSTR  lpszValue,
                            DWORD   dwSize,
                            BOOL    fShowError )
{
    BOOL fRead ;

    if ( fShowError )
    {
        fRead = MigReadRegistrySz( lpszRegName,
                                   lpszValue,
                                   dwSize ) ;
    }
    else
    {
        DWORD dwType = REG_SZ ;

        fRead = _ReadRegistryValue( lpszRegName,
                                   &dwSize,
	                               &dwType,
                                    lpszValue ) ;
    }

    return fRead ;
}

//-------------------------------------------------
//
//  HRESULT _WriteSeqNumInINIFile()
//
//-------------------------------------------------

HRESULT _WriteSeqNumInINIFile( GUID   *pSiteGuid,
                               __int64 i64HighestUSN,
                               BOOL    fPec )
{
    CSeqNum snMaxLsn ;
    HRESULT hr =  FindLargestSeqNum( pSiteGuid,
                                     snMaxLsn,
                                     fPec ) ;
    CHECK_HR(hr) ;

    unsigned short *lpszGuid ;
    UuidToString( pSiteGuid,
                  &lpszGuid ) ;

    //
    // in cluster mode we have to add this local machine to remote MQIS database.
    // So, we have to increment uiAllObjectNumber for SiteId = MySiteID
    // and to increment SN for this SiteId. We have to do it only for PEC
    // since only PEC machine we'll add later to all remote MQIS databases.
    //
    UINT uiAllObjectNumber = 0;
    if (g_fClusterMode &&                                       // it is cluster mode
        g_dwMyService == SERVICE_PEC &&                         // this machine is PEC
        memcmp(pSiteGuid, &g_MySiteGuid, sizeof(GUID)) == 0)	// it is my site
    {
        snMaxLsn.Increment() ;
        uiAllObjectNumber ++ ;
    }

    TCHAR tszSeqNum[ SEQ_NUM_BUF_LEN ] ;
    snMaxLsn.GetValueForPrint( tszSeqNum ) ;

    //
    // Write the SeqNumber in the ini file.
    //
    TCHAR *pszFileName = GetIniFileName ();
    BOOL f = WritePrivateProfileString( RECENT_SEQ_NUM_SECTION_IN,
                                        lpszGuid,
                                        tszSeqNum,
                                        pszFileName ) ;
    ASSERT(f) ;

    f = WritePrivateProfileString( RECENT_SEQ_NUM_SECTION_OUT,
                                   lpszGuid,
                                   tszSeqNum,
                                   pszFileName ) ;
    ASSERT(f) ;

    f = WritePrivateProfileString( MIGRATION_SEQ_NUM_SECTION,
                                   lpszGuid,
                                   tszSeqNum,
                                   pszFileName ) ;
    ASSERT(f) ;

    __int64 i64SiteSeqNum = 0 ;
    _sntscanf(tszSeqNum, SEQ_NUM_BUF_LEN, TEXT("%I64x"), &i64SiteSeqNum) ;

    //
    // when pre-migration objects are replicated we have to use as initial
    // SN the SN that we got in SyncRequest. We have to be sure that
    // all MSMQ1.0 objects can be replicated and we have sufficient places
    // from the given SN to the first SN of post-migrated objects. To make this,
    // add to delta number of all objects are belonging to the given Master.
    // So,
    // delta = (MaxSN in SQL of this Master) - (Highest USN in NT5 DS) +
    //         (Number of All Objects of this Master)
    //    
    hr = GetAllObjectsNumber (  pSiteGuid,
                                fPec,
                                &uiAllObjectNumber
                             ) ;
    CHECK_HR(hr) ;
	
    __int64 i64Delta = i64SiteSeqNum - i64HighestUSN + uiAllObjectNumber;
    TCHAR wszDelta[ SEQ_NUM_BUF_LEN ] ;
    _stprintf(wszDelta, TEXT("%I64d"), i64Delta) ;

    f = WritePrivateProfileString( MIGRATION_DELTA_SECTION,
                                   lpszGuid,
                                   wszDelta,
                                   pszFileName ) ;
    ASSERT(f) ;

    RpcStringFree( &lpszGuid ) ;

    return MQMig_OK ;
}

//+-------------------------------
//
//  HRESULT  UpdateRegistry()
//
//  This function is called when migration of objects from MQIS to NT5
//  DS is done, to update several values in local registry and in ini file.
//  These values are later used by the replication service.
//
//+-------------------------------

HRESULT  UpdateRegistry( IN UINT  cSites,
                         IN GUID *pSitesGuid )
{
    //
    // Read present highest USN and write it to registry.
    //
    TCHAR wszReplHighestUsn[ SEQ_NUM_BUF_LEN ] ;
    HRESULT hr = ReadFirstNT5Usn(wszReplHighestUsn) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_FIRST_USN, hr) ;
        return hr ;
    }
    BOOL f = MigWriteRegistrySz( HIGHESTUSN_REPL_REG,
                                 wszReplHighestUsn ) ;
    ASSERT(f) ;

    f = MigWriteRegistrySz( LAST_HIGHESTUSN_MIG_REG,
                                 wszReplHighestUsn ) ;
    ASSERT(f) ;

    //
    // Compute delta values to be used by the replication service.
    //
    __int64 i64HighestUSN = 0 ;
    _sntscanf(wszReplHighestUsn, SEQ_NUM_BUF_LEN, TEXT("%I64u"), &i64HighestUSN) ;
    ASSERT(i64HighestUSN > 0) ;

    for ( UINT j = 0 ; j < cSites ; j++ )
    {
        hr = _WriteSeqNumInINIFile( &pSitesGuid[ j ],
                                    i64HighestUSN,
                                    FALSE ) ;
    }

    if (g_dwMyService == SERVICE_PEC)
    {
        //
        // Find and save the highest seq number of the PEC guid (NULL_GUID) ;
        //
        GUID PecGuid ;
        memset(&PecGuid, 0, sizeof(GUID)) ;

        hr = _WriteSeqNumInINIFile( &PecGuid,
                                    i64HighestUSN,
                                    TRUE ) ;
    }

    //
    // Update site id. During migration, the PSC may change site, to match
    // its IP address. It's necessary to "remember" its old NT4 site id,
    // so replication service can find its BSCs.
    // Also, update PSC present site id (NT5 objectGuid of present site).
    //
    LPTSTR szRegName;
    if (g_fRecoveryMode || g_fClusterMode)
    {
        szRegName = MIGRATION_MQIS_MASTERID_REGNAME ;
    }
    else
    {
        szRegName = MSMQ_MQIS_MASTERID_REGNAME ;
    }
    f = MigWriteRegistryGuid( szRegName,
                              &g_MySiteGuid ) ;    
    ASSERT(f) ;

    if (g_fClusterMode && 
        !g_fReadOnly && 
        g_dwMyService == SERVICE_PEC)
    {
        ASSERT(g_FormerPECGuid != GUID_NULL);
        //
        // save guid of former PEC in registry (only on PEC)
        //
        f = MigWriteRegistryGuid( MIGRATION_FORMER_PEC_GUID_REGNAME,
                                  &g_FormerPECGuid ) ;   
        ASSERT(f) ;
    }

    //
    // Remember old NT4 site.
    //
    f = MigWriteRegistryGuid( MSMQ_NT4_MASTERID_REGNAME,
                              &g_MySiteGuid ) ;
    ASSERT(f) ;

    // [adsrv] Adding server functionality keys
    f = MigWriteRegistryDW(MSMQ_MQS_DSSERVER_REGNAME, TRUE);
    ASSERT(f) ;
    // We assume that migration is called only on old PEC/PSC which is now DC/GC so we surely have DS

    f = MigWriteRegistryDW(MSMQ_MQS_ROUTING_REGNAME, TRUE);
    ASSERT(f) ;
    // We assume that old crazy K2 DS/non-router will be router in NT5

    f = MigWriteRegistryDW(MSMQ_MQS_DEPCLINTS_REGNAME, TRUE);
    ASSERT(f) ;
    // All servers support Dep Clients now.

    return MQMig_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\resource.h ===
#include "..\..\mqutil\res\migtools\mqmigres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\stdafx.cpp ===
//
// file: migrat.cpp
//

#include "migrat.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migutils.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migutils.cpp

Abstract:

    Utility code.

Author:

    Doron Juster  (DoronJ)  08-Mar-1998

--*/

#include "migrat.h"

#include "migutils.tmh"

//
// define the range of legal DNS characters.
//
#define  NUM_DNS_RANGES  4
static const  TCHAR  sx_chDNSLegal[ NUM_DNS_RANGES ][2] =
                                         { TEXT('0'), TEXT('9'),
                                           TEXT('a'), TEXT('z'),
                                           TEXT('A'), TEXT('Z'),
                                           TEXT('-'), TEXT('-') } ;

//-----------------------------
//
//  Auto delete of ADs allocated string
//
class ADsFree {
private:
    WCHAR * m_p;

public:
    ADsFree() : m_p(0)            {}
    ADsFree(WCHAR* p) : m_p(p)    {}
   ~ADsFree()                     {FreeADsStr(m_p);}

    operator WCHAR*() const   { return m_p; }
    WCHAR** operator&()       { return &m_p;}
    WCHAR* operator->() const { return m_p; }
};

//+-------------------------------------------------------------------
//
//  HRESULT  BlobFromColumns()
//
//  Description: combine several SQL columns into one blob buffer.
//      First DWORD in the buffer is the buffer size, in bytes,
//      NOT including the DWORD itself.
//
//+-------------------------------------------------------------------

HRESULT  BlobFromColumns( MQDBCOLUMNVAL *pColumns,
                          DWORD          adwIndexs[],
                          DWORD          dwIndexSize,
                          BYTE**         ppOutBuf )
{
    //
    // First compute total length.
    //
    DWORD dwTotalSize = 0 ;
    for ( DWORD j = 0 ; j < dwIndexSize ; j++ )
    {
        if (pColumns[ adwIndexs[ j ] ].nColumnValue)
        {
            WORD  wSize = *(
                     (WORD *) pColumns[ adwIndexs[ j ] ].nColumnValue ) ;
            ASSERT( (DWORD) wSize <=
                    (DWORD) pColumns[ adwIndexs[ j ] ].nColumnLength ) ;
            dwTotalSize += (DWORD) wSize ;
        }
    }

    if (dwTotalSize == 0)
    {
        //
        // OK, property does not exist.
        //
        return MQMig_E_EMPTY_BLOB ;
    }

    *ppOutBuf = new BYTE[ dwTotalSize + sizeof(DWORD) ] ;

    //
    // return size of buffer.
    //
    DWORD *pSize = (DWORD*) *ppOutBuf ;
    *pSize = dwTotalSize ;

    //
    // Now copy the columns into the buffer.
    //
    BYTE *pOut = *ppOutBuf + sizeof(DWORD) ;

    for ( j = 0 ; j < dwIndexSize ; j++ )
    {
        if (pColumns[ adwIndexs[ j ] ].nColumnValue)
        {
            BYTE *pBuf = ((BYTE *) pColumns[ adwIndexs[ j ] ].nColumnValue)
                                            + MQIS_LENGTH_PREFIX_LEN ;
            WORD  wSize = *(
                     (WORD *) pColumns[ adwIndexs[ j ] ].nColumnValue ) ;

            memcpy( pOut,  pBuf, wSize ) ;

            pOut += wSize ;
        }
    }

    return MQMig_OK ;
}

//+-------------------------------------------------------------------
//
//  TCHAR *GetIniFileName ()
//
//  By default, mqseqnum.ini file is the system directory.
//
//+-------------------------------------------------------------------

TCHAR *GetIniFileName ()
{
    static BOOL   s_fIniRead = FALSE ;
    static TCHAR  s_wszIniName[ MAX_PATH ] = {TEXT('\0')} ;

    if (!s_fIniRead)
    {
        DWORD dw = GetSystemDirectory( s_wszIniName, MAX_PATH ) ;
        if (dw != 0)
        {
            _tcscat( s_wszIniName, TEXT("\\")) ;
            _tcscat( s_wszIniName, SEQ_NUMBERS_FILE_NAME) ;
        }
        else
        {
            ASSERT(dw != 0) ;
        }
        s_fIniRead = TRUE ;
    }

    return s_wszIniName;
}

//+-------------------------------------------------------------------
//
//  HRESULT AnalyzeMachineType (LPWSTR wszMachineType, BOOL *pfOldVersion)
//
//  fOldVersion is TRUE iff old version of MSMQ 1.0 DS Server installed on the machine
//  old version == version with number less than 280
//
//+-------------------------------------------------------------------

#define MSMQ_SP4_VERSION    280
#define MSMQ_STRING         L"MSMQ"
#define BUILD_STRING        L"Build"
#define BLANK_STRING        L" "

HRESULT AnalyzeMachineType (IN LPWSTR wszMachineType,
                            OUT BOOL  *pfOldVersion)
{
    *pfOldVersion = FALSE;
    WCHAR *ptr = wcsstr( wszMachineType, MSMQ_STRING );
    if (ptr == NULL)
    {
        return MQMig_E_WRONG_MACHINE_TYPE;
    }
    ptr = wcsstr( ptr, BUILD_STRING );
    if (ptr == NULL)
    {
        return MQMig_E_WRONG_MACHINE_TYPE;
    }

    ptr += wcslen(BUILD_STRING) + wcslen(BLANK_STRING);
    WCHAR wszVer[10];
    wszVer[0] = L'\0';

    for (UINT i=0; iswdigit(*ptr); ptr++, i++)
    {
        wszVer[i] = *ptr;
    }
    wszVer[i] = L'\0';
    UINT iVer = _wtoi( wszVer );
    if (iVer == 0)
    {
        return MQMig_E_WRONG_MACHINE_TYPE;
    }

    if (iVer < MSMQ_SP4_VERSION)
    {
        *pfOldVersion = TRUE;
    }

    return MQMig_OK;
}

//+-------------------------
//
//  void StringToSeqNum()
//
//+-------------------------

void StringToSeqNum( IN TCHAR    pszSeqNum[],
                     OUT CSeqNum *psn )
{
    BYTE *pSN = const_cast<BYTE*> (psn->GetPtr()) ;
    DWORD dwSize = psn->GetSerializeSize() ;
    ASSERT(dwSize == 8) ;

    WCHAR wszTmp[3] ;

    for ( DWORD j = 0 ; j < dwSize ; j++ )
    {
        memcpy(wszTmp, &pszSeqNum[ j * 2 ], (2 * sizeof(TCHAR))) ;
        wszTmp[2] = 0 ;

        DWORD dwTmp ;
        _sntscanf(wszTmp,STRLEN(wszTmp), TEXT("%2x"), &dwTmp) ;
        *pSN = (BYTE) dwTmp ;
        pSN++ ;
    }
}

/*====================================================

CalHashKey()

Arguments:

Return Value:

=====================================================*/

DWORD CalHashKey( IN LPCWSTR pwcsPathName )
{
    ASSERT( pwcsPathName ) ;

    DWORD   dwHashKey = 0;
    WCHAR * pwcsTmp;

    AP<WCHAR> pwcsUpper = new WCHAR[ lstrlen(pwcsPathName) + 1];
    lstrcpy( pwcsUpper, pwcsPathName);
    CharUpper( pwcsUpper);
    pwcsTmp = pwcsUpper;


    while (*pwcsTmp)
        dwHashKey = (dwHashKey<<5) + dwHashKey + *pwcsTmp++;

    return(dwHashKey);
}

//+-------------------------------------------------------------------------
//
//  Function:  BuildServersList
//
//  Synopsis:  Get all non-updated servers from .ini
//
//+-------------------------------------------------------------------------
void BuildServersList(LPTSTR *ppszServerName, ULONG *pulServerCount)
{
    TCHAR *pszFileName = GetIniFileName ();
    ULONG ulServerNum = GetPrivateProfileInt(
                                MIGRATION_ALLSERVERSNUM_SECTION,	// address of section name
                                MIGRATION_ALLSERVERSNUM_KEY,      // address of key name
                                0,							    // return value if key name is not found
                                pszFileName					    // address of initialization filename);
                                );

    if (ulServerNum == 0)
    {
        return;
    }

    ULONG ulNonUpdatedServers = GetPrivateProfileInt(
                                        MIGRATION_NONUPDATED_SERVERNUM_SECTION,
                                        MIGRATION_ALLSERVERSNUM_KEY,
                                        0,
                                        pszFileName
                                        ) ;
    if (ulNonUpdatedServers == 0)
    {
        return ;
    }

    TCHAR *pszList = new TCHAR[ulNonUpdatedServers * MAX_PATH];
    _tcscpy(pszList, TEXT(""));

    ULONG ulCounter = 0;
    for (ULONG i=0; i<ulServerNum; i++)
    {
        TCHAR szCurServerName[MAX_PATH];
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_ALLSERVERS_NAME_KEY, i+1);
        DWORD dwRetSize =  GetPrivateProfileString(
                                    MIGRATION_ALLSERVERS_SECTION ,			// points to section name
                                    tszKeyName,	// points to key name
                                    TEXT(""),                 // points to default string
                                    szCurServerName,          // points to destination buffer
                                    MAX_PATH,                 // size of destination buffer
                                    pszFileName               // points to initialization filename);
                                    );
        if (_tcscmp(szCurServerName, TEXT("")) == 0 ||
            dwRetSize == 0)     //low resources
        {
            continue;
        }

        _tcscat(pszList, szCurServerName);
        _tcscat(pszList, TEXT("\n"));

        ulCounter++;
    }

    ASSERT(ulCounter == ulNonUpdatedServers);
    *pulServerCount = ulCounter;

    *ppszServerName = pszList;
}

//+-------------------------------------------------------------------------
//
//  Function:  RemoveServersFromList
//
//  Synopsis:  remove non-updated servers from the list of updated servers
//
//+-------------------------------------------------------------------------
void RemoveServersFromList(LPTSTR *ppszUpdatedServerName,
                           LPTSTR *ppszNonUpdatedServerName)
{
    ASSERT(*ppszUpdatedServerName);
    ASSERT(*ppszNonUpdatedServerName);

    TCHAR *pcNextChar = *ppszUpdatedServerName;

    DWORD dwLen = _tcslen(*ppszUpdatedServerName) + 1;
    AP<TCHAR> pszNewServerList = new TCHAR[dwLen];
    _tcscpy(pszNewServerList, TEXT(""));

    while (*pcNextChar != _T('\0'))
    {
        TCHAR *pcEnd = _tcschr( pcNextChar, _T('\n') );
        ASSERT(pcEnd != NULL);

        TCHAR szCurServer[MAX_PATH];
        _tcsncpy(szCurServer, pcNextChar, pcEnd-pcNextChar+1);
        szCurServer[pcEnd-pcNextChar+1] = _T('\0');

        BOOL fFound = FALSE;
        TCHAR *pcNextNonUpd = *ppszNonUpdatedServerName;
        while (*pcNextNonUpd != _T('\0'))
        {
            TCHAR *pcEndNonUpd = _tcschr( pcNextNonUpd, _T('\n') );
            ASSERT(pcEndNonUpd != NULL);

            TCHAR szCurNonUpdServer[MAX_PATH];
            _tcsncpy(szCurNonUpdServer, pcNextNonUpd, pcEndNonUpd-pcNextNonUpd+1);
            szCurNonUpdServer[pcEndNonUpd-pcNextNonUpd+1] = _T('\0');

            if (_tcscmp(szCurNonUpdServer, szCurServer) == 0)
            {
                //
                // we found this server in non-updated list
                //
                fFound = TRUE;
                break;
            }
            pcNextNonUpd = pcEndNonUpd+1;
        }
        if (!fFound)
        {
            //
            // this server was updated
            //
            _tcscat(pszNewServerList,szCurServer);
        }

        pcNextChar = pcEnd + 1;
    }

    _tcscpy(*ppszUpdatedServerName, pszNewServerList);
}

//+-------------------------------------------------------------------------
//
//  Function:  IsObjectNameValid
//
//  Synopsis:  return TRUE if object name (name of site, foreign CN or machine) is valid
//
//+-------------------------------------------------------------------------
BOOL IsObjectNameValid(TCHAR *pszObjectName)
{
    //
    // check if object name (as read from MQIS) is a legal DNS name (as defined
    // in rfc 1035). If not, change it.
    // In MSMQ1.0, any string is a legal object name. In NT5 DS, site/machine name must
    // conform to rfc 1035, containing only letters and digits.
    //
    BOOL fOk = FALSE ;
    DWORD dwLen = _tcslen(pszObjectName) ;

    for ( DWORD j = 0 ; j < dwLen ; j++ )
    {
        fOk = FALSE ;
        TCHAR ch = pszObjectName[j] ;

        //
        // Inner loop on all legal ranges.
        //
        for ( DWORD k = 0 ; k < NUM_DNS_RANGES ; k++ )
        {
            if ((ch >= sx_chDNSLegal[k][0]) && (ch <= sx_chDNSLegal[k][1]))
            {
                fOk = TRUE ;
                break ;
            }
        }

        if (!fOk)
        {
            break ;
        }
    }

    return fOk;
}

//+--------------------------------------------------------------
//
//  HRESULT IsObjectGuidInIniFile
//	Return TRUE if given guid is found under the specific section in .ini file
//
//+--------------------------------------------------------------

BOOL IsObjectGuidInIniFile(IN GUID      *pObjectGuid,
                           IN LPWSTR    pszSectionName)
{
    TCHAR *pszFileName = GetIniFileName ();

    unsigned short *lpszGuid ;
    RPC_STATUS rc = UuidToString( pObjectGuid, &lpszGuid ) ;
	if (rc != RPC_S_OK)
		return FALSE;
	
    TCHAR szValue[50];
    DWORD dwRetSize;
    dwRetSize =  GetPrivateProfileString(
                      pszSectionName,     // points to section name
                      lpszGuid,                 // points to key name
                      TEXT(""),                 // points to default string
                      szValue,                  // points to destination buffer
                      50,                       // size of destination buffer
                      pszFileName               // points to initialization filename);
                      );

    RpcStringFree( &lpszGuid ) ;

    if (_tcscmp(szValue, TEXT("")) == 0)
    {
        //
        // the entry does not exist
        //
        return FALSE;
    }

    return TRUE;
}

//+--------------------------------------------------------------
//
//  HRESULT GetCurrentUserSid
//
//+--------------------------------------------------------------

HRESULT GetCurrentUserSid ( IN HANDLE    hToken,
                            OUT TCHAR    **ppszSid)
{
    HRESULT hr = MQMig_OK;

    BYTE rgbBuf[128];
    DWORD dwSize = 0;
    P<BYTE> pBuf;
    TOKEN_USER * pTokenUser = NULL;

    if (GetTokenInformation( hToken,
                             TokenUser,
                             rgbBuf,
                             sizeof(rgbBuf),
                             &dwSize))
    {
        pTokenUser = (TOKEN_USER *) rgbBuf;
    }
    else if (dwSize > sizeof(rgbBuf))
    {
        pBuf = new BYTE [dwSize];
        if (GetTokenInformation( hToken,
                                 TokenUser,
                                 (BYTE *)pBuf,
                                 dwSize,
                                 &dwSize))
        {
            pTokenUser = (TOKEN_USER *)((BYTE *)pBuf);
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            LogMigrationEvent(MigLog_Error, MQMig_E_GET_TOKEN_INFORMATION, hr);						
            return hr;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_TOKEN_INFORMATION, hr);						
        return hr;
    }

    if (!pTokenUser)
    {
        hr = MQMig_E_GET_TOKEN_INFORMATION;
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_TOKEN_INFORMATION, hr);						
        return hr;
    }

    //
    // This is the SID of the user running the process !!!
    //
    SID *pSid = (SID*) pTokenUser->User.Sid ;
    DWORD dwSidLen = GetLengthSid(pSid) ;
    ASSERT (dwSidLen);
    ASSERT (IsValidSid(pSid));

    ADsFree  pwcsSid;
    hr = ADsEncodeBinaryData(
                  (unsigned char *) pSid,
                  dwSidLen,
                  &pwcsSid
                );

    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_ENCODE_BINARY_DATA, hr);
        return hr;
    }

    *ppszSid = new WCHAR[ wcslen( pwcsSid) + 1];
    wcscpy( *ppszSid, pwcsSid);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\rpcclistub.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    rpcclistub.cpp

Abstract:
    Rpc client stub function

Author:
    Ilan Herbst (ilanh) 25-July-2000

Environment:
    Platform-independent,

--*/

#include "migrat.h"
#include "mqmacro.h"
#include "qformat.h"

#include "rpcclistub.tmh"

HRESULT 
GetRpcClientHandle(
	handle_t * /*phBind*/
	)
{
    ASSERT(("MQMIGRAT dont suppose to call GetRpcClientHandle", 0));
    return MQ_OK;
}

HRESULT 
QMRpcSendMsg(
    IN handle_t /*hBind*/,
    IN QUEUE_FORMAT* /* pqfDestination */,
    IN DWORD /*dwSize*/,
    IN const unsigned char * /*pBuffer*/,
    IN DWORD /*dwTimeout*/,
    IN unsigned char /*bAckMode*/,
    IN unsigned char /*bPriority*/,
    IN LPWSTR /*lpwszAdminResp*/
	)
{
    ASSERT(("MQMIGRAT dont suppose to call QMRpcSendMsg", 0));
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\mqmigui.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name: mqmigui.h

Abstract:
1. Definition of functions in mqmigrat.dll  that are used by the UI tool.
2. Definition of callback functions in the migration tool that are called
   from mqmigrat.dll.

Author:

    Doron Juster  (DoronJ)   25-Oct-98

--*/

//+---------------------------------------------------------
//
//  Functions in mqmig.exe, called from mqmigrat.dll
//
//+---------------------------------------------------------

UINT  MQMigUI_DisplayMessageBox(
         ULONG ulTextId,
         UINT  ulMsgBoxType = (MB_YESNO | MB_ICONWARNING | MB_TASKMODAL) ) ;

typedef UINT  (*MQMigUI_DisplayMessageBox_ROUTINE) (
         ULONG ulTextId,
         UINT  ulMsgBoxType /*= (MB_YESNO | MB_ICONWARNING | MB_TASKMODAL)*/ ) ;

//+---------------------------------------------------------
//
//  Functions in mqmigrat.dll, called from mqmig.exe
//
//+---------------------------------------------------------

HRESULT  MQMig_MigrateFromMQIS( LPTSTR  szMQISName,
                                LPTSTR  szDcName,
                                BOOL    fReadOnly,
                                BOOL    fRecoveryMode,
                                BOOL	fClusterMode,
                                LPTSTR  szLogFile,
                                ULONG   ulTraceFlags,
                                BOOL    *pfIsPEC,
                                DWORD 	CurrentState,
                                BOOL    *pfIsOneServer) ;

typedef HRESULT (*MQMig_MigrateFromMQIS_ROUTINE) (
                             LPWSTR szMQISName,
                             LPWSTR  szDcName,
                             BOOL    fReadOnly,
                             BOOL    fRecoveryMode,
                             BOOL    fClusterMode,
                             LPWSTR  szLogFile,
                             ULONG   ulTraceFlags,
                             BOOL    *pfIsPEC,
                             DWORD   CurrentState,
                             BOOL    *pfIsOneServer 
                             ) ;

HRESULT  MQMig_CheckMSMQVersionOfServers( IN  LPTSTR  szMQISName,
                                          IN  BOOL    fIsClusterMode,
                                          OUT UINT   *piCount,
                                          OUT LPTSTR *ppszServers ) ;

typedef HRESULT (*MQMig_CheckMSMQVersionOfServers_ROUTINE) (
                                                LPWSTR szMQISName,
                                                BOOL   fIsClusterMode,
                                                UINT   *piCount,
                                                LPWSTR *ppszServers) ;

HRESULT  MQMig_GetObjectsCount( IN  LPTSTR  szMQISName,
                                OUT UINT   *piSiteCount,
                                OUT UINT   *piMachineCount,
                                OUT UINT   *piQueueCount,
                                OUT UINT   *piUserCount	) ;

typedef HRESULT (*MQMig_GetObjectsCount_ROUTINE) (
                                LPWSTR  szMQISName,
                                UINT   *piSiteCount,
                                UINT   *piMachineCount,
                                UINT   *piQueueCount,
                                UINT   *piUserCount) ;

HRESULT  MQMig_GetAllCounters( OUT UINT   *piSiteCounter,
                               OUT UINT   *piMachineCounter,
                               OUT UINT   *piQueueCounter,
                               OUT UINT   *piUserCounter) ;

typedef HRESULT  (*MQMig_GetAllCounters_ROUTINE) (
                               OUT UINT   *piSiteCounter,
                               OUT UINT   *piMachineCounter,
                               OUT UINT   *piQueueCounter,
                               OUT UINT   *piUserCounter) ;

HRESULT  MQMig_SetSiteIdOfPEC( IN  LPTSTR  szRemoteMQISName,
                               IN  BOOL	   fIsClusterMode,
                               IN  DWORD   dwInitError,
                               IN  DWORD   dwConnectDatabaseError,
                               IN  DWORD   dwGetSiteIdError,
                               IN  DWORD   dwSetRegistryError,
                               IN  DWORD   dwSetDSError);

typedef HRESULT (*MQMig_SetSiteIdOfPEC_ROUTINE) ( IN  LPWSTR  szRemoteMQISName,
                                                  IN  BOOL    fIsClusterMode,
												  IN  DWORD   dwInitError,
												  IN  DWORD   dwConnectDatabaseError,
												  IN  DWORD   dwGetSiteIdError,
												  IN  DWORD   dwSetRegistryError,
												  IN  DWORD   dwSetDSError);

HRESULT  MQMig_UpdateRemoteMQIS( 
                      IN  DWORD   dwGetRegistryError,
                      IN  DWORD   dwInitError,
                      IN  DWORD   dwUpdateMQISError, 
                      OUT LPTSTR  *ppszUpdatedServerName,
                      OUT LPTSTR  *ppszNonUpdatedServerName
                      );

typedef HRESULT (*MQMig_UpdateRemoteMQIS_ROUTINE) ( 
                          IN  DWORD   dwGetRegistryError,
                          IN  DWORD   dwInitError,
                          IN  DWORD   dwUpdateMQISError,
                          OUT LPWSTR  *ppszUpdatedServerName,
                          OUT LPWSTR  *ppszNonUpdatedServerName
                          );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\dss.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Dss.cpp

Abstract:
    Mqds service main

Author:
    Ilan Herbst (ilanh) 26-Jun-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "Dssp.h"
#include "Cm.h"
#include "mqutil.h"
#include "Svc.h"
#include "Ev.h"

#include "dss.tmh"

extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/ [])
{
	try
	{
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

		CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ", KEY_ALL_ACCESS);
		TrInitialize();
		EvInitialize(QM_DEFAULT_SERVICE_NAME);

		SvcInitialize(L"MQDS");
	}
	catch(const exception&)
	{
		//
		// Cannot initialize the service, bail-out with an error.
		//
		return -1;
	}

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\dssp.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Dss.h

Abstract:
    Mqdssvc private functions.

Author:
    Ilan Herbst (ilanh) 26-Jun-2000

--*/

#ifndef _MQDSSVC_DSSP_H_
#define _MQDSSVC_DSSP_H_

#include "tr.h"
#include <mqexception.h>

void MainDSInit(void);

BOOL IsLocalSystem(void);


#endif // _MQDSSVC_DSSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\dssutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dssutil.h

Abstract:

    Mq ds service utilities interface

Author:

    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef _MQDSSVC_DSSUTIL_
#define _MQDSSVC_DSSUTIL_

#include "_ta.h"

const 
GUID*
GetQMGuid(
	void
	);

void ScheduleTimeToUpdateDsServerList();

extern DWORD GetDsServerList(OUT WCHAR *pwcsServerList,IN DWORD dwLen);

class CAddressList : public CList<TA_ADDRESS*, TA_ADDRESS*&> {/**/};

extern BOOLEAN IsDSAddressExist(const CAddressList* AddressList,
                                TA_ADDRESS*     ptr,
                                DWORD AddressLen);

extern BOOL IsDSAddressExistRemove(IN const TA_ADDRESS*     ptr,
                                   IN DWORD AddressLen,
                                   IN OUT CAddressList* AddressList);

extern void SetAsUnknownIPAddress(IN OUT TA_ADDRESS * ptr);

extern CAddressList* GetIPAddresses(void);

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);
void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint);
void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine);

#endif //_MQDSSVC_DSSUTIL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\dsssecutl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dsssecutl.cpp

Abstract:

    Various QM security related functions.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include <mqsec.h>
#include <mqcrypt.h>
#include "mqutil.h"
#include <mqlog.h>
#include <dssp.h>
#include <tr.h>
#include <dsproto.h>

#include "dsssecutl.tmh"

static WCHAR *s_FN=L"dsssecutl";


BOOL IsLocalSystem(void)
/*++

Routine Description:
    Check if the process is local system.

Arguments:
	None.    

Returned Value:
	TRUE for if the process is Local System, FALSE otherwise

--*/
{
	return MQSec_IsSystemSid(MQSec_GetProcessSid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\stdh.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file used for precompilation.

Author:

    Ilan Herbst  (ilanh)  26-Jun-2000

Environment:

    Platform-independent

Revision History:

--*/


#ifndef _MQDSSVC_STDH_H_
#define _MQDSSVC_STDH_H_

#include <_Stdh.h>

#include "mqtypes.h"

#endif // _MQDSSVC_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\dssinit.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    DssInit.cpp

Abstract:
    The functions in this file based on functions from qm\qmds.cpp
	they are taking care of dcpromo\dcunpromo
	and topology recognition.

Author:
    Ilan Herbst (ilanh) 11-July-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "topology.h"
#include "safeboot.h"
#include "ds.h"
#include "mqsocket.h"
#include "mqprops.h"
#include "_mqdef.h"
#include "mqutil.h"
#include <mqsec.h>
#include "ex.h"
#include "dssp.h"
#include "svc.h"
#include "cm.h"
#include "adsiutil.h"
#include "ad.h"
#include "Ev.h"

#include <strsafe.h>

#include "dssinit.tmh"

AP<WCHAR> g_szMachineName = NULL;
AP<WCHAR> g_szComputerDnsName = NULL;

//
// Registry Keys
//
const LPCWSTR xMqdssvcRootKey = L"Parameters\\Mqdssvc";
const LPCWSTR xMachineCache = L"Parameters\\MachineCache";
const LPCWSTR xParameters = L"Parameters";

//
// MachineCache values
//
const LPCWSTR xMQS_DsServer = L"MQS_DsServer";
const LPCWSTR xMQS = L"MQS";

//
// Parameters values
//
const LPCWSTR xWorkGroup = L"Workgroup";
const LPCWSTR xAllowNT4 = L"AllowNt4Users";
const LPCWSTR xDisableWeakenSecurity = L"DisableWeakenSecurity";

//
// Mqdssvc values
//
const LPCWSTR xDummyException = L"DummyException";
const LPCWSTR xStopBeforeInit = L"StopBeforeInit";


static
void
AllowNT4users(
	void
	)
/*++

Routine Description:
	Check if need to call DSRelaxSecurity.
	This call should be done once (after setup update the registry key).
	If the registry exist and its value is TRUE we delete this registry.	

Arguments:
	None.

Returned Value:
	None

--*/
{
	//
	//  ISSUE-2000/07/28-ilanh
	//	MSMQ_ALLOW_NT4_USERS_REGNAME was previously used name. keep it ?
    //
	DWORD AllowNT4 = 0;
	const RegEntry xAllowNT4Entry(xParameters, xAllowNT4);
	CmQueryValue(xAllowNT4Entry, &AllowNT4);

    if(!AllowNT4)
		return;

	//
	// This set the attribute mSMQNameStyle to TRUE in msmq services
	//
    HRESULT hr = DSRelaxSecurity(AllowNT4);
    if (FAILED(hr))
    {
		TrERROR(DS, "DSRelaxSecurity failed hr = 0x%x", hr);
		throw bad_hresult(hr);
    }

	TrTRACE(DS, "DSRelaxSecurity completed");

	//
	// This operation should be done once after setup update that value.
    //
	CmDeleteValue(xAllowNT4Entry);
}


static
void
DisableWeakenSecurity(
	void
	)
/*++

Routine Description:
	Check if need to call DSRelaxSecurity. in order to DisableWeakenSecurity
	This call should be done once (after the user create this reg key).
	If the registry exist and its value is TRUE we delete this registry.	

Arguments:
	None.

Returned Value:
	None

--*/
{
	DWORD DisableWeakenSecurity = 0;
	const RegEntry xDisableWeakenSecurityEntry(xParameters, xDisableWeakenSecurity);
	CmQueryValue(xDisableWeakenSecurityEntry, &DisableWeakenSecurity);

    if(!DisableWeakenSecurity)
		return;

	//
	// This set the attribute mSMQNameStyle to FALSE in msmq services
	//
    HRESULT hr = DSRelaxSecurity(0);
    if (FAILED(hr))
    {
		TrERROR(DS, "DisableWeakenSecurity, DSRelaxSecurity failed hr = 0x%x", hr);
		throw bad_hresult(hr);
    }

	TrTRACE(DS, "DSRelaxSecurity(0) completed");

	//
	// This operation should be done once after the user create this reg value
    //
	CmDeleteValue(xDisableWeakenSecurityEntry);
}


static
bool
IsSafeMode(
	void
    )
/*++

Routine Description:
    Determines if the server is booted in safe mode or not where
    safe mode == directory service repair.

    based on nt\private\ds\src\util\ntdsutil\util.cxx

Parameters:
    None.

Return Values:

    TRUE if in safe mode, FALSE otherwise.

--*/
{
    static bool  s_fIsSafeMode = false;
    static bool  s_fAlreadyAsked = false;

    if (s_fAlreadyAsked)
    {
        return s_fIsSafeMode;
    }

    DWORD   cbData;
    WCHAR   data[100];
    WCHAR  * key = L"%SAFEBOOT_OPTION%";

    cbData = ExpandEnvironmentStrings(key, data, TABLE_SIZE(data));

    if ( cbData
         && (cbData <= TABLE_SIZE(data))
         && !_wcsicmp(data, SAFEBOOT_DSREPAIR_STR_W) )
    {
        s_fIsSafeMode = true;
    }

    s_fAlreadyAsked = true;

	TrTRACE(DS, "SafeMode status = %d", s_fIsSafeMode);
    
	return(s_fIsSafeMode);
}


bool
IsDsServer(
	void
	)
/*++

Routine Description:
	Retrieve Machine service type from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	TRUE for DsServer, FALSE otherwise

--*/
{
	static bool s_fDsServerInitialize = false;
	static bool s_fIsDsServer = false;

    if (s_fDsServerInitialize)
		return s_fIsDsServer;

	DWORD dwDef = 0xfffe;
	DWORD dwMQSDsServer;
	const RegEntry xMQS_DsServerEntry(xMachineCache, xMQS_DsServer, dwDef);
	CmQueryValue(xMQS_DsServerEntry, &dwMQSDsServer);

	if (dwMQSDsServer == dwDef)
	{
		TrERROR(DS, "Failed to get MSMQ_MQS_DSSERVER from registry");

		return s_fIsDsServer;
	}

	s_fIsDsServer = (dwMQSDsServer != 0);
	s_fDsServerInitialize = true;

	TrTRACE(DS, "DS Server registry status = %d", s_fIsDsServer);

	return s_fIsDsServer;
}


bool
IsWorkGroupMode(
	void
	)
/*++

Routine Description:
	Retrieve WorkGroupMode from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	TRUE for WorkGroupMode, FALSE otherwise

--*/
{
	static bool s_fWorkGroupModeInitialize = false;
	static bool s_fWorkGroupMode = false;

    if (s_fWorkGroupModeInitialize)
		return s_fWorkGroupMode;

	DWORD dwWorkGroupMode;
	const RegEntry xWorkGroupEntry(xParameters, xWorkGroup);
	CmQueryValue(xWorkGroupEntry, &dwWorkGroupMode);

	s_fWorkGroupMode = (dwWorkGroupMode != 0);
	s_fWorkGroupModeInitialize = true;

	TrTRACE(DS, "WorkGroupMode registry status = %d", s_fWorkGroupMode);

	return s_fWorkGroupMode;
}


static
void  
UpdateDSFunctionalityDCUnpromo(
	void
	)
/*++

Routine Description:
	There are 2 possible ways to get here:
    1) DC unpromo was performed	on w2k (and not SafeMode).
    2) BSC/PSC/PEC upgrade, when dcpromo was not perform.
	   the DSServer registry is on. the registry is written in the upgrade 
	   according to MSMQ_MQS_REGNAME value.

	after dcunpromo. That's exactly like the case of upgrade
    from nt4 and boot before dcpromo. So reuse same code.

	we update the active directory, reseting our ds flag in the
    msmqConfiguration object and msmqSetting object. and resetting
	the ds settings in the registry.

Arguments:
	None.

Returned Value:
	None

--*/
{
	ASSERT(!MQSec_IsDC());

	//
	// Must CoInitialize before AD* api
	//
    CCoInit cCoInit;
    HRESULT hr = cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));

	//
	// First update in DS.
	// We are not DS Server can not use DS api
	// need to use for this case only the AD api.
	//
	PROPID prop[1] = {PROPID_QM_SERVICE_DSSERVER};
	MQPROPVARIANT var[1];
	var[0].vt = VT_UI1;
	var[0].bVal = false;

	hr = ADSetObjectPropertiesGuid(
				eMACHINE,
				NULL,  // pwcsDomainController
				false, // fServerName
				GetQMGuid(),
				1,
				prop,
				var
				);
	//
    // make sure we use only one property here. There is special
    // code in mqads (wrterq.cpp) to support this special setting,
    // so always use this property alone, and do not add it to
    // others.
    //
    ASSERT((sizeof(prop) / sizeof(prop[0])) == 1);

	//
	// ISSUE-2000/08/03-ilanh 
	// currently we will surely fail, since we don't have permissions to
	// set the bit in MSMQ Settings in the AD. (only service on DC has the permission).
	// in the past we used mqdssrv on the DC did the job, now we try to go directly to the AD
	// and don't have enough permissions.
	// The correct solution is to give permissions to the machine account. 
	//
	// ISSUE-2000/08/03-ilanh 
	// Need to look carefully on all upgrade senarios from NT4 clients.
    // And see all limitations we have.
    // a NT4 BSC will return MQ_ERROR or ACCESS_DENIED when calling
    // ADSetObjectPropertiesGuid. In that case, look for the ex-PEC. For all
    // other failures, just return. (the code that handle this was in
	// qm\qmds.cpp\UpdateQMSettingInformation().
	// we need to decide if we want that code (there are bizare situations when we need
	// to load mqdscli in AD enviroment ....)
	//
	// The reason we get MQ_ERROR if working in MQIS enviroment is because we try to reset 
	// PROPID_QM_SERVICE_DSSERVER property which does not exist.
	// We get MQ_ERROR_ACCESS_DENIED because we are not a service that runs on DC
	// so we don't have permissions to do 
    //

	if (FAILED(hr))
    {
		//
		// ISSUE-2000/08/03-ilanh need to check for no ds
		//
		TrERROR(DS, "Failed to update server functionality (dcunprom) in DS, hr = 0x%x", hr);
		EvReport(MQDS_DCUNPROMO_UPDATE_FAIL);
		return;
	}

	TrTRACE(DS, "DCUnpromo clear PROPID_QM_SERVICE_DSSERVER in AD");

    //
    // change MQS_DsServer value to 0: this server is not DS server
    //
    DWORD  dwType = REG_DWORD;
    DWORD  dwValue = false;
    DWORD  dwSize = sizeof(dwValue);
    DWORD dwErr = SetFalconKeyValue( 
						MSMQ_MQS_DSSERVER_REGNAME,
						&dwType,
						&dwValue,
						&dwSize
						);

	//
	// Not fatal, the service is not register at the DS as DS server.
	// if we failed to update MQS_DSSERVER registry. 
	// next time we boot, it will trigger again DsFunctionalityChange and we repeat those operations again.
	//
    if (dwErr != ERROR_SUCCESS)
    {
		TrWARNING(DS, "DCUnpromo: Could not set MQS_DsServer in registry. Error: %lut", dwErr);
    }
	else
	{
		TrTRACE(DS, "DCUnpromo clear MSMQ_MQS_DSSERVER_REGNAME");
	}

    dwErr = DeleteFalconKeyValue(MSMQ_DS_SERVER_REGNAME);
    if (dwErr != ERROR_SUCCESS)
    {
		TrWARNING(DS, "DCUnpromo: Could not delete MSMQ_DS_SERVER_REGNAME registry value. Error: %lut", dwErr);
    }		
	else
	{
		TrTRACE(DS, "DCUnpromo clear MSMQ_DS_SERVER_REGNAME");
	}

    dwErr = DeleteFalconKeyValue(MSMQ_DS_CURRENT_SERVER_REGNAME);
    if (dwErr != ERROR_SUCCESS)
    {
		TrWARNING(DS, "DCUnpromo: Could not delete MSMQ_DS_CURRENT_SERVER_REGNAME registry value. Error: %lut", dwErr);
    }		
	else
	{
		TrTRACE(DS, "DCUnpromo clear MSMQ_DS_CURRENT_SERVER_REGNAME");
	}
}


static
void  
UpdateDSFunctionalityDCPromo(
	void
	)
/*++

Routine Description:
	Perform updates regarding DS Server dcpromo.
	Write to DS that we are DS Server, update registry values
	If failed the function throw bad_hresult()

Arguments:
	None.

Returned Value:
	None

--*/
{
	PROPID prop[1] = {PROPID_QM_SERVICE_DSSERVER};
    MQPROPVARIANT var[1];
    var[0].vt = VT_UI1;
    var[0].bVal = true;

    HRESULT hr = DSSetObjectPropertiesGuid( 
					MQDS_MACHINE,
					GetQMGuid(),
					1,
					prop,
					var
					);
	//
    // make sure we use only one property here. There is special
    // code in mqads (wrterq.cpp) to support this special setting,
    // so always use this property alone, and do not add it to
    // others.
    //
    ASSERT((sizeof(prop) / sizeof(prop[0])) == 1);

    if (FAILED(hr))
    {
		TrERROR(DS, "Failed to update server functionality (dcpromo) in DS, hr = 0x%x", hr);
        EvReport(MQDS_DCPROMO_UPDATE_FAIL);
		throw bad_hresult(hr);
	}

	TrTRACE(DS, "DCPromo set PROPID_QM_SERVICE_DSSERVER in AD");

    //
    // Change list of DS Servers in registry to include
    // only our own name. We're a DS, aren't we ?
    //
    LPWSTR lpszMyMachineName = g_szMachineName;
    
	if (g_szComputerDnsName)
    {
        lpszMyMachineName = g_szComputerDnsName;
    }

	int SizeToAllocate = wcslen(lpszMyMachineName) + 5;
    P<WCHAR> wszList = new WCHAR[SizeToAllocate];
    hr = StringCchPrintf(wszList, SizeToAllocate, TEXT("10%ls"), lpszMyMachineName); 
    if (FAILED(hr))
    {
        TrERROR(DS, "StringCchPrintf failed unexpectedly , error = %!winerr!",hr);
		throw bad_hresult(hr);
    }

    DWORD dwSize = (wcslen(wszList) + 1) * sizeof(WCHAR);
    DWORD dwType = REG_SZ;

    LONG rc = SetFalconKeyValue( 
					MSMQ_DS_SERVER_REGNAME,
					&dwType,
					 wszList,
					&dwSize
					);

	TrTRACE(DS, "DCPromo Set MSMQ_DS_SERVER_REGNAME = %ls", wszList);

    rc = SetFalconKeyValue( 
			MSMQ_DS_CURRENT_SERVER_REGNAME,
			&dwType,
			wszList,
			&dwSize
			);

	TrTRACE(DS, "DCPromo Set MSMQ_DS_CURRENT_SERVER_REGNAME = %ls", wszList);

    //
    //  Update the registry with new service functionality ( only
    //  if succeeded to update ds ). Make this update after all
    //  the above were done, in order to "implementation" a
    //  transaction semantic on this change of functinoality.
    //  If we crash somewhere before this point, then after boot
    //  the DS flag in registry is still 0 and we'll perform this
    //  code again.
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD  dwVal = true;

    rc = SetFalconKeyValue( 
			MSMQ_MQS_DSSERVER_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);

	//
	// Not fatal, the service is register at the DS as DS server.
	// if we failed to update MQS_DSSERVER registry. 
	// next time we boot, it will trigger again DsFunctionalityChange and we repeat those operations again.
	//
    if (rc != ERROR_SUCCESS)
    {
		TrWARNING(DS, "Failed to set MSMQ_MQS_DSSERVER_REGNAME hr = 0x%x", rc);
    }
	else
	{
		TrTRACE(DS, "DCPromo set MSMQ_MQS_DSSERVER_REGNAME");
	}
}



const 
GUID*
GetQMGuid(
	void
	)
/*++

Routine Description:
	Retrieve QM Guid from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	pointer to QM GUID, or pointer to GUID_NULL if failed.

--*/
{
	static bool s_fQmGuidInitialize = false;
	static GUID s_QmGuid = GUID_NULL;

    if (s_fQmGuidInitialize)
		return &s_QmGuid;

    DWORD dwValueType = REG_BINARY;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue(
					MSMQ_QMID_REGNAME,
					&dwValueType,
					&s_QmGuid,
					&dwValueSize
					);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(DS, "Failed to get QMID from registry");

        ASSERT(("BUGBUG: Failed to read QM GUID from registry!", 0));
        return &s_QmGuid;
    }

	s_fQmGuidInitialize = true;

    ASSERT((dwValueType == REG_BINARY) && (dwValueSize == sizeof(GUID)));

    return &s_QmGuid;
}


static
void 
ServerTopologyRecognitionInit( 
	void
	)
/*++

Routine Description:
    Initialize the Topology recognition Server
	and create the thread to listen to client topology recognition requests.
	If failed the function throw bad_hresult()

Arguments:
	None.

Returned Value:
	None

--*/
{
	//
	// This must be first initialization
	//
	ASSERT(g_pServerTopologyRecognition == NULL);

    g_pServerTopologyRecognition = new CServerTopologyRecognition();

    //
    // Check status of IP.
    //
    HRESULT hr = g_pServerTopologyRecognition->Learn();
    if (FAILED(hr))
    {
		TrERROR(DS, "ServerTopologyRecognition->Learn failed, hr = 0x%x", hr);
		throw bad_hresult(hr);
    }
    
    //
    // After Learn we are always resolved.
    //

	TrTRACE(DS, "ServerTopologyRecognitionInit: Successfully Server address resolution");

    //
    // Server starts listening to broadcasts from client.
    // At this phase it can return correct responses even if it
    // didn't yet update the DS.
    //
    DWORD dwThreadId;
    HANDLE hThread = CreateThread( 
						NULL,
						0,
						ServerRecognitionThread,
						g_pServerTopologyRecognition,
						0,
						&dwThreadId
						);

    if (hThread == NULL)
    {
    	DWORD gle = GetLastError();
		TrERROR(DS, "Failed to create the ServerRecognitionThread. %!winerr!", gle);
		throw bad_hresult(MQ_ERROR_INSUFFICIENT_RESOURCES);
	}
    else
    {
		TrTRACE(DS, "ServerRecognitionThread created successfully");
        CloseHandle(hThread);
    }
}


void 
InitComputerNameAndDns(
	void
	)
/*++

Routine Description:
    Initialize g_szMachineName and g_szComputerDnsName
	If failed the function throw bad_hresult()

Arguments:
    None.

Returned Value:
    None.

--*/
{
	//
    // Retrieve name of the machine (Always UNICODE)
    //
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    g_szMachineName = new WCHAR[dwSize];

    HRESULT hr = GetComputerNameInternal(g_szMachineName, &dwSize);
    if(FAILED(hr))
    {
		TrERROR(DS, "Failed to get machine name hr = 0x%x", hr);
		throw bad_hresult(hr);
    }

	TrTRACE(DS, "ComputerName = %ls", g_szMachineName);

	//
	// Retrieve the DNS name of this computer (in unicode).
	// Clustered QM does not have DNS name.
	//

	//
	// Get ComputerDns Size, ignore the returned error
	// 
	dwSize = 0;
	GetComputerDnsNameInternal(NULL, &dwSize);

	g_szComputerDnsName = new WCHAR[dwSize];

	hr = GetComputerDnsNameInternal(g_szComputerDnsName, &dwSize);
	if(FAILED(hr))
	{
		//
		//	this can be a valid situation, where a computer doesn't
		//	have DNS name.
		//	ISSUE-2000/08/03-ilanh - is this really valid situation.
		//
		TrWARNING(DS, "Cannot retrieve computer DNS name hr = 0x%x", hr);
		g_szComputerDnsName.free();
	}

	TrTRACE(DS, "ComputerDnsName = %ls", g_szComputerDnsName);
}


void 
CheckExit( 
	void
	)
/*++

Routine Description:
    Check Exit conditions from mqdssvc service.
	the possible situations the service should exit are:
		workgroup mode
		SafeMode
		the service is running as LocalUser

	If failed the function throw bad_hresult()

Arguments:
    None.

Returned Value:
	None.    

--*/
{
	//
	// Check exit condition - workgroup or SafeMode
	//

	if(IsWorkGroupMode())
	{
		TrERROR(DS, "MainDsInit, mqdssvc can not run in workgroup mode");
        EvReport(EVENT_WARN_MQDS_NOT_DC);
		throw bad_hresult(EVENT_WARN_MQDS_NOT_DC);
	}

	if (IsSafeMode())
    {
		//
        //  In DS safe mode we don't want to change any thing in the DS
        //  so exit here
		//
		TrERROR(DS, "MainDsInit, we are in safe mode");
		throw bad_hresult(MQ_ERROR_UNSUPPORTED_OPERATION);
    }

	if(!IsLocalSystem())
	{
		TrERROR(DS, "DS Service not run as local system");
        EvReport(MQDS_NOT_RUN_AS_LOCAL_SYSTEM);
	}

#ifdef _DEBUG
	//
	// Dummy Exception
	//
	DWORD fDummyException = 0;
	const RegEntry xDummyExceptionEntry(xMqdssvcRootKey, xDummyException);
	CmQueryValue(xDummyExceptionEntry, &fDummyException);
	if(fDummyException)
	{
		TrERROR(DS, "Dummy execption to check exit");
		throw bad_hresult(MQ_ERROR_NO_DS);
	}
#endif
}


void 
MainDSInit( 
	void
	)
/*++

Routine Description:
    Main ds Initialize routine.
	this routine check for changed in ds functionality.
	if ds changed was detected and we are not in safe mode
	perform the update.
	start the Thread to listen to clients topology recognition requests.
	If failed the function throw bad_hresult()

Arguments:
    None.

Returned Value:
	TRUE if initialization ok, FALSE otherwise.    

--*/
{

#ifdef _DEBUG
	DWORD fStopBeforeInit = 0;
	const RegEntry xStopBeforeInitEntry(xMqdssvcRootKey, xStopBeforeInit);
	CmQueryValue(xStopBeforeInitEntry, &fStopBeforeInit);
	if(fStopBeforeInit)
	{
		//
		// to debug init report SERVICE_RUNNING and cause ASSERT
		//
		SvcReportState(SERVICE_RUNNING);
		ASSERT(("Assert before start of mqdssvc init", 0));
	}
#endif

	//
	// Check workgroup, SafeMode, running as LocalSystem
	//
	CheckExit(); 

    //
    // Max time for next progress report
    //
    const DWORD xTimeToNextReport = 3000;

	SvcReportProgress(xTimeToNextReport);

	//
	// initialize g_szMachineName, g_szComputerDnsName
	//
    InitComputerNameAndDns();
	
    //
    //  Check if the server have changed the "DS functionality"
    //  ( i.e. was DCpromo or DCunpromo performed)
    //
    bool fIsDC = MQSec_IsDC();

	//
	// No need to be cluster aware.
	// The Ds service can run only on the default QM machine according to shaik
	//

	if(fIsDC)
	{
		SvcReportProgress(xTimeToNextReport);

		//
		// ISSUE-2000/07/27-ilanh we should depend on kds service here at runtime
		// KDC_STARTED_EVENT - BUG 4349
		// This dependency must be done after handling dcpromo/dcunpromo
		// and before making any DS operation.
		//

		//
		// Init Ds, RPC
		//
		HRESULT hr = DSServerInit();

		if(FAILED(hr))
		{
			TrERROR(DS, "DSServerInit failed 0x%x", hr);
			throw bad_hresult(hr);
		}

		TrTRACE(DS, "DSServerInit completed succesfully");

		SvcReportProgress(xTimeToNextReport);
	}

	if (fIsDC && !IsDsServer())
    {
        //
        // dcpromom was performed. We're now a domain controller.
		//
        UpdateDSFunctionalityDCPromo();
		TrTRACE(DS, "MainDsInit: Server functionality has changed, now supports DS");
    }
    else if (!fIsDC && IsDsServer())
    {
        //
		//  There are 2 possible ways to get here:
        //  1) DC unpromo was performed	on w2k (and not SafeMode).
        //  2) BSC/PSC/PEC upgrade, when dcpromo was not perform.
		//	   the DSServer registry is on. the registry is written in the upgrade 
		//     according to MSMQ_MQS_REGNAME value.
        //
        // after dcunpromo. That's exactly like the case of upgrade
        // from nt4 and boot before dcpromo. So reuse same code.
        //
        UpdateDSFunctionalityDCUnpromo();
		TrTRACE(DS, "MainDsInit: Server functionality has changed, now doesn't supports DS");
    }

	//
	// fIsDC == FALSE we should exit here!
	// The service runs only on DC
	//
	if(!fIsDC)
	{
		//
		// event not DS server
		//
		TrERROR(DS, "MainDsInit, we are not DC");
		EvReport(EVENT_WARN_MQDS_NOT_DC);
		throw bad_hresult(MQ_ERROR_NO_DS);
	}

	//
	// Check for registry value to allow NT4 users
	// Relax Security if we allow NT4 users
	//
	AllowNT4users();

	//
	// Check if the user want to disable the weaken security
	//
	DisableWeakenSecurity();

	ServerTopologyRecognitionInit(); 

	SvcReportProgress(xTimeToNextReport);
    if(!MQSec_CanGenerateAudit())
    {
        EvReport(EVENT_WARN_MQDS_CANNOT_GENERATE_AUDITS);
    }

    //
    // Schedule TimeToUpdateDsServerList
    // This is needed in order to support mobile clients.
    //
	ScheduleTimeToUpdateDsServerList();
	
	EvReport(EVENT_INFO_MQDS_SERVICE_STARTED);

	if(DSIsWeakenSecurity())
	{
		//
		// Weaken security is set
		//
		EvReport(EVENT_INFO_MQDS_WEAKEN_SECURITY);
	}
	else
	{
		EvReport(EVENT_INFO_MQDS_DEFAULT_SECURITY);
	}
		
	TrTRACE(DS, "MainDsInit completed successfully");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\service.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Service.cpp

Abstract:
    Service control entry points to the Mqdssvc

Author:
    Ilan Herbst (ilanh) 26-Jun-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "Dssp.h"
#include "Svc.h"
#include "ds.h"

#include "service.tmh"

static
VOID
ApppExit(
    VOID
    ) throw()
{
    SvcReportState(SERVICE_STOPPED);
	Sleep(1000);
    exit(-1);

} // ApppExit


VOID
AppRun(
	LPCWSTR /*ServiceName*/
	)
/*++

Routine Description:
    Stub implementation for application Run function. It should immidiatly
	report it state and enable the controls it accepts.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
	try
	{
		MainDSInit();
	}
    catch (const bad_win32_error& exp)
    {
        TrERROR(DS, "Failed to initialize service, win32_api_error = 0x%x", exp.error());
        ApppExit();
    }
	catch (const bad_hresult& exp)
	{
		TrERROR(DS, "Failed to initialize service, error = 0x%x", exp.error());
        ApppExit();
	}
    catch (const bad_alloc&)
    {
        TrERROR(DS, "Failed to initialize service, insufficient resources");
        ApppExit();
    }
    catch (const exception& exp)
    {
        TrERROR(DS, "Failed to initialize service, what = %s", exp.what());
        ASSERT(("Need to know the real reason for failure here!", 0));
        ApppExit();
    }

	SvcReportState(SERVICE_RUNNING);
    SvcEnableControls(
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_SHUTDOWN
		);

	Sleep(INFINITE);
}


VOID
AppStop(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Stop function. It should immidiatly
	report it state back, and take the procedure to stop the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_STOP_PENDING);
	DSTerminate();
	SvcReportState(SERVICE_STOPPED);
}


VOID
AppPause(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Pause function. MSDS service does
    not implement pause control.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(("MQDS Service unexpectedly got Pause control from SCM", 0));
}


VOID
AppContinue(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Continue function. MSDS service does
    not implement continue control.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(("MQDS Service unexpectedly got Continue control from SCM", 0));
}


VOID
AppShutdown(
	VOID
	)
{
	AppStop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\dssutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dssutil.cpp

Abstract:

    mq ds service utilities

Author:

    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include "dssutil.h"
#include "topology.h"
#include "mqsocket.h"
#include <wsnwlink.h>
#include "mqprops.h"
#include "mqutil.h"
#include "ds.h"
#include "mqmacro.h"
#include "ex.h"

#include <strsafe.h>

#include "dssutil.tmh"

extern AP<WCHAR> g_szMachineName;

static void WINAPI TimeToUpdateDsServerList(CTimer* pTimer);
static CTimer s_UpdateDSSeverListTimer(TimeToUpdateDsServerList);


bool IsServersCacheEmpty()
/*++

Routine Description:
    Check if ServersCache registry is empty.

Arguments:
    None.

Returned Value:
	true if ServersCache registry is empty, false otherwise.    

--*/
{
    WCHAR  ServersKeyName[256] = {0};
    HRESULT hr = StringCchPrintf(ServersKeyName, TABLE_SIZE(ServersKeyName), TEXT("%s\\%s"),FALCON_REG_KEY,MSMQ_SERVERS_CACHE_REGNAME);
    if (FAILED(hr))
    {
        TrERROR(DS, "Server key name too small to fit the key , error = %!winerr!",hr);
		return true;
    }

    CAutoCloseRegHandle hKeyCache;
    DWORD rc = RegOpenKeyEx( 
					FALCON_REG_POS,
					ServersKeyName,
					0L,
					KEY_QUERY_VALUE,
					&hKeyCache 
					);

    if(rc != ERROR_SUCCESS)
    {
        TrERROR(DS, "Failed to open %ls registry, error = %!winerr!", ServersKeyName, rc);
		return true;
	}

    WCHAR szName[1000];
	DWORD dwSizeVal  = TABLE_SIZE(szName);  // size in chars
    WCHAR  data[MAX_REG_DSSERVER_LEN];
	DWORD dwSizeData = sizeof(data);		// size in bytes

	rc = RegEnumValue( 
			hKeyCache,		// handle of key to query
			0,				// index of value to query
			szName,			// address of buffer for value string
			&dwSizeVal,		// address for size of value buffer
			0L,				// reserved
			NULL,			// type
			(BYTE*) data,   // address of buffer for value data
			&dwSizeData     // address for size of value data
			);

    if(rc != ERROR_SUCCESS)
	{
        TrERROR(DS, "%ls is empty, First index was not found, error = %!winerr!", ServersKeyName, rc);
		return true;
	}

    TrTRACE(DS, "%ls is not empty, First index '%ls' was found", ServersKeyName, szName);
	return false;
}


void ScheduleTimeToUpdateDsServerList()
/*++

Routine Description:
    Schedule call to TimeToUpdateDsServerList.

Arguments:
    None.

Returned Value:
	None.    

--*/
{
	//
	// If ServerCache registry is empty schedule update in 1 minute
	// otherwise 4 hours
	//
    const DWORD x_dwFirstInitInterval = 60 * 1000;				// 1 minute
    const DWORD x_dwFirstRefreshInterval = 60 * 60 * 4 * 1000;	// 4 hours

    DWORD dwFirstUpdateInterval = x_dwFirstRefreshInterval;

    if(IsServersCacheEmpty())
    {
		//
		// ServersCache key is empty, schedule refresh in 1 minute. 
		//
        TrERROR(DS, "'ServersCache' registry is empty, schedule update in 1 minute");
		dwFirstUpdateInterval = x_dwFirstInitInterval;
	}

    DSExSetTimer(&s_UpdateDSSeverListTimer, CTimeDuration::FromMilliSeconds(dwFirstUpdateInterval));
}

/*======================================================

Function:         TimeToUpdateDsServerList()

Description:      This routine updates the list of ds
                  servers in the registry

========================================================*/

void
WINAPI
TimeToUpdateDsServerList(
    CTimer* pTimer
    )
{
    //
    // Success refresh interval is 24 hours.
	// Failure refresh interval is 2 hours.
    //
    const DWORD x_dwErrorRefreshInterval = 60 * 60 * 2 * 1000;   // 2 hours
	const DWORD x_dwRefreshInterval = 60 * 60 * 24 * 1000;		 // 24 hours

    DWORD dwNextUpdateInterval = x_dwRefreshInterval;

    try
    {
        //
        //  Update the registry key of server cache - each Enterprise refresh 
        //  interval. 
        //        
        HRESULT hr = DSCreateServersCache();

        if SUCCEEDED(hr)
        {
			TrTRACE(DS, "'ServersCache' registry was updated succesfully");
        }
        else
        {
			TrERROR(DS, "Failed to update 'ServersCache' registry, schedule retry in 2 hours");
            dwNextUpdateInterval = x_dwErrorRefreshInterval;
        }

    }
    catch(const bad_alloc&)
    {
		TrERROR(DS, "Failed to update 'ServersCache' registry due to low resources, schedule retry in 2 hours");
        dwNextUpdateInterval = x_dwErrorRefreshInterval;
    }

    DSExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(dwNextUpdateInterval));
}


/*======================================================

Function:         GetDsServerList

Description:      This routine gets the list of ds
                  servers from the DS

========================================================*/
DWORD 
GetDsServerList(
	OUT WCHAR *pwcsServerList,
	IN  DWORD dwLen
	)
{

//
// Since we are retreiving property pairs, Ths number of props should be even
//
#define MAX_NO_OF_PROPS 20

    //
    //  Get the names of all the servers that
    //  belong to the site
    //

    ASSERT (dwLen >= MAX_REG_DSSERVER_LEN);
	DBG_USED(dwLen);

    HRESULT       hr = MQ_OK;
    HANDLE        hQuery;
    DWORD         dwProps = MAX_NO_OF_PROPS;
    PROPVARIANT   result[MAX_NO_OF_PROPS];
    PROPVARIANT*  pvar;
    CRestriction  Restriction;
    GUID          guidSite;
    DWORD         index = 0;

    GUID          guidEnterprise;

   guidSite = g_pServerTopologyRecognition->GetSite();
   guidEnterprise = g_pServerTopologyRecognition->GetEnterprise();

    //
    // DS server only
    //
    Restriction.AddRestriction(
					SERVICE_SRV,                 // [adsrv] old request - DS will interpret
					PROPID_QM_SERVICE,
					PRGT
					);

    //
    // In  this machine's Site
    //
    Restriction.AddRestriction(
					&guidSite,
					PROPID_QM_SITE_ID,
					PREQ
					);

	//
	//	First assume NT5 DS server, and ask for the DNS names
	//	of the DS servers
	//
    CColumns      Colset;
    Colset.Add(PROPID_QM_PATHNAME_DNS);
	Colset.Add(PROPID_QM_PATHNAME);

    DWORD   lenw;

    // This search request will be recognized and specially simulated by DS
    hr = DSLookupBegin(
			0,
			Restriction.CastToStruct(),
			Colset.CastToStruct(),
			0,
			&hQuery
			);

	if(FAILED(hr))
	{
		//
		// Possibly the DS server is not NT5, try without PROPID_QM_PATHNAME_DNS
		//

		CColumns      ColsetNT4;
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		hr = DSLookupBegin(
				0,
				Restriction.CastToStruct(),
				ColsetNT4.CastToStruct(),
				0,
				&hQuery
				);
	}

    if(FAILED(hr))
        return 0;

    BOOL fAlwaysLast = FALSE;
    BOOL fForceFirst = FALSE;

    while(SUCCEEDED(hr = DSLookupNext(hQuery, &dwProps, result)))
    {
        //
        //  No more results to retrieve
        //
        if (!dwProps)
            break;

        pvar = result;

        for (DWORD i = 0; i < (dwProps/2); i++, pvar+=2)
        {
            //
            //  Add the server name to the list
            //  For load balancing, write sometimes at the
            //  beginning of the string, sometimes at the end. Like
            //  that we will have  BSCs and PSC in a random order
            //
            WCHAR * p;
			WCHAR * pwszVal;
			AP<WCHAR> pCleanup1;
			AP<WCHAR> pCleanup2 = (pvar+1)->pwszVal;

			if ( pvar->vt != VT_EMPTY)
			{
				//
				// there may be cases where server will not have DNS name
				// ( migration)
				//
				pwszVal = pvar->pwszVal;
				pCleanup1 = pwszVal;
			}
			else
			{
				pwszVal = (pvar+1)->pwszVal;
			}
            lenw = wcslen( pwszVal);

            if ( index + lenw + 4 <  MAX_REG_DSSERVER_LEN)
            {
               if (!_wcsicmp(g_szMachineName, pwszVal))
               {
                  //
                  // Our machine should be first on the list.
                  //
                  ASSERT(!fForceFirst) ;
                  fForceFirst = TRUE ;
               }
               if(index == 0)
               {
                  //
                  // Write the 1st string
                  //
                  p = &pwcsServerList[0];
                  if (fForceFirst)
                  {
                     //
                     // From now on write all server at the end
                     // of the list is our machine remain the
                     // first in the list.
                     //
                     fAlwaysLast = TRUE;
                  }
               }
               else if (fAlwaysLast ||
                         ((rand() > (RAND_MAX / 2)) && !fForceFirst))
               {
                  //
                  // Write at the end of the string
                  //
                  pwcsServerList[index] = DS_SERVER_SEPERATOR_SIGN;
                  index ++;
                  p = &pwcsServerList[index];
               }
               else
               {
                  if (fForceFirst)
                  {
                     //
                     // From now on write all server at the end
                     // of the list is our machine remain the
                     // first in the list.
                     //
                     fAlwaysLast = TRUE;
                  }

                  //
                  // Write at the beginning of the string
                  //
                  DWORD dwListSize = lenw                   +
									 2 /* protocol flags */ +
									 1 /* Separator    */ ;
                  //
                  // Must use memmove because buffers overlap.
                  //
                  memmove( 
						&pwcsServerList[dwListSize],
						&pwcsServerList[0],
						index * sizeof(WCHAR)
						);

                  pwcsServerList[dwListSize - 1] = DS_SERVER_SEPERATOR_SIGN;
                  p = &pwcsServerList[0];
                  index++;
               }

               //
               // Mark only IP as supported protocol
               //
               *p++ = TEXT('1');
               *p++ = TEXT('0');

               memcpy(p, pwszVal, lenw * sizeof(WCHAR));
               index += lenw + 2;

            }
        }
    }
    pwcsServerList[ index] = '\0';
    //
    // close the query handle
    //
    hr = DSLookupEnd(hQuery);

    return((index) ? index+1 : 0);
}


/*====================================================

IsDSAddressExist

Arguments:

Return Value:


=====================================================*/
BOOLEAN 
IsDSAddressExist(
	const CAddressList* AddressList,
	TA_ADDRESS*     ptr,
	DWORD AddressLen
	)
{
    POSITION        pos;
    TA_ADDRESS*     pAddr;

    if (AddressList)
    {
        pos = AddressList->GetHeadPosition();
        while(pos != NULL)
        {
            pAddr = AddressList->GetNext(pos);

            if (memcmp(&(ptr->Address), &(pAddr->Address), AddressLen) == 0)
            {
                //
                // Same IP address
                //
               return TRUE;
            }
        }
    }

    return FALSE;
}


/*====================================================

IsDSAddressExistRemove

Arguments:

Return Value:


=====================================================*/
BOOL 
IsDSAddressExistRemove( 
	IN const TA_ADDRESS*     ptr,
	IN DWORD AddressLen,
	IN OUT CAddressList* AddressList
	)
{
    POSITION        pos, prevpos;
    TA_ADDRESS*     pAddr;
    BOOLEAN         rc = FALSE;

    pos = AddressList->GetHeadPosition();
    while(pos != NULL)
    {
        prevpos = pos;
        pAddr = AddressList->GetNext(pos);

        if (memcmp(&(ptr->Address), &(pAddr->Address), AddressLen) == 0)
        {
            //
            // Same address
            //
           AddressList->RemoveAt(prevpos);
           delete pAddr;
           rc = TRUE;
        }
    }

    return rc;
}


/*====================================================

SetAsUnknownIPAddress

Arguments:

Return Value:

=====================================================*/

void SetAsUnknownIPAddress(IN OUT TA_ADDRESS * pAddr)
{
    pAddr->AddressType = IP_ADDRESS_TYPE;
    pAddr->AddressLength = IP_ADDRESS_LEN;
    memset(pAddr->Address, 0, IP_ADDRESS_LEN);
}


/*====================================================

Function: void GetLocalMachineIPAddresses()

Arguments:

Return Value:

=====================================================*/

static
void 
GetLocalMachineIPAddresses(
	OUT CAddressList* plIPAddresses
	)
{
    TrTRACE(ROUTING, "GetMachineIPAddresses for local machine");
	
    //
    // Obtain the IP information for the machine
    //
    PHOSTENT pHostEntry = gethostbyname(NULL);

    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
	    TrWARNING(ROUTING, "gethostbyname found no IP addresses for local machine");
        return;
    }

    //
    // Add each IP address to the list of IP addresses
    //
    TA_ADDRESS * pAddr;
    for (DWORD uAddressNum = 0;
         pHostEntry->h_addr_list[uAddressNum] != NULL;
         uAddressNum++)
    {
        //
        // Keep the TA_ADDRESS format of local IP address
        //
        pAddr = (TA_ADDRESS *)new char [IP_ADDRESS_LEN + TA_ADDRESS_SIZE];
        pAddr->AddressLength = IP_ADDRESS_LEN;
        pAddr->AddressType = IP_ADDRESS_TYPE;
        memcpy( &(pAddr->Address), pHostEntry->h_addr_list[uAddressNum], IP_ADDRESS_LEN);

	    TrTRACE(ROUTING, "QM: gethostbyname found IP address %hs ",
        	  inet_ntoa(*(struct in_addr *)pHostEntry->h_addr_list[uAddressNum]));

        plIPAddresses->AddTail(pAddr);
    }
}


/*====================================================

GetIPAddresses

Arguments:

Return Value:


=====================================================*/
CAddressList* GetIPAddresses(void)
{
    CAddressList* plIPAddresses = new CAddressList;
    GetLocalMachineIPAddresses(plIPAddresses);

    return plIPAddresses;
}


void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), NT STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), Illegal point", wszFileName, usPoint);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topoldat.cpp ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

    topoldat.cpp

Abstract:

    Implementation of cached data class for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/


#include "stdh.h"
#include "dssutil.h"
#include "topoldat.h"
#include "ds.h"
#include "mqprops.h"
#include "mqutil.h"
#include <mqlog.h>

#include "topoldat.tmh"

static WCHAR *s_FN=L"topoldat";

extern AP<WCHAR> g_szMachineName;
extern AP<WCHAR> g_szComputerDnsName;

HRESULT CTopologyData::LoadFromRegistry()
{
    TrTRACE(ROUTING, "QM: CTopologyData::LoadFromRegistry");


    DWORD dwSize = sizeof(GUID);
    DWORD dwType = REG_BINARY;

    LONG rc = GetFalconKeyValue(
                    MSMQ_ENTERPRISEID_REGNAME,
                    &dwType,
                    &m_guidEnterprise,
                    &dwSize
                    );
    if (rc != ERROR_SUCCESS)
    {
        LogIllegalPoint(s_FN, 10);
        return HRESULT_FROM_WIN32(rc);
    }

    ASSERT(dwSize == sizeof(GUID)) ;
    ASSERT(dwType == REG_BINARY) ;

    return MQ_OK;
}


/*============================================================

HRESULT CServerTopologyData::Load()

Description:  Load last known topology of a server from MQIS database.

=============================================================*/

HRESULT CServerTopologyData::Load()
{
    TrTRACE(ROUTING, "QM: CTopologyData::Load");
    
    HRESULT hr = LoadFromRegistry();
    if(FAILED(hr))
    {
       return LogHR(hr, s_FN, 150);
    }

    PROPID      propId[3];
    PROPVARIANT var[3];
    DWORD nProp = 3;

    propId[0] = PROPID_QM_ADDRESS;
    var[0].vt = VT_NULL;
    propId[1] = PROPID_QM_CNS;
    var[1].vt = VT_NULL;
    propId[2] = PROPID_QM_SITE_ID;
    var[2].vt = VT_NULL;

    hr = DSGetObjectPropertiesGuid( 
            MQDS_MACHINE,
            GetQMGuid(),
            nProp,
            propId,
            var 
            );

	if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    m_cbAddress = var[0].blob.cbSize;
    delete [] m_blobAddress;
    m_blobAddress = var[0].blob.pBlobData;
    m_nCNs = var[1].cauuid.cElems;
    delete [] m_aguidCNs;
    m_aguidCNs = var[1].cauuid.pElems;
    m_guidSite =  *var[2].puuid;
    delete var[2].puuid;

    return(MQ_OK);
}


//+------------------------------------------------------------
//
//  HRESULT  CServerTopologyData::FindOrphanDsAddress()
//
//  Find a DS address that do not appear in the hardware list.
//
//+------------------------------------------------------------

HRESULT  CServerTopologyData::FindOrphanDsAddress(
                                     IN  CAddressList  *pAddressList,
                                     IN  DWORD          dwAddressLen,
                                     IN  DWORD          dwAddressType,
                                     OUT TA_ADDRESS   **pUnfoundAddress,
                                     OUT BOOL          *pfResolved )
{
    TrTRACE(ROUTING, "QM: CTopologyData::FindOrphanDsAddress");
    
    TA_ADDRESS* unFoundAddress = NULL;
    TA_ADDRESS* ptr = NULL ;

    for ( DWORD len = 0;
         (*pfResolved && (len < m_cbAddress));
         len += TA_ADDRESS_SIZE + ptr->AddressLength )
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        if (ptr->AddressType == dwAddressType)
        {
            ASSERT (ptr->AddressLength == dwAddressLen) ;

            if ( ! IsDSAddressExist( pAddressList,
                                     ptr,
                                     dwAddressLen ))
            {
                //
                // DS Address was not found in hardware list.
                // Remember this unfound DS address.
                //
                if (unFoundAddress == NULL)
                {
                    //
                    // First Address that was not found
                    //
                    unFoundAddress = ptr;
                }
                else if (memcmp( &(ptr->Address),
                                 &(unFoundAddress->Address),
                                 dwAddressLen ) == 0)
                {
                    //
                    // Same address that already was not found.
                    // Note: win2k servers can return same address with
                    // several CNs. so same address can appear multiple
                    // times in the list returned from DS.
                    //
                }
                else
                {
                    //
                    // Two addresses changed.
                    // We can't recover from this situation.
                    //
                    *pfResolved = FALSE ;
                }
            }
        }
    }

    *pUnfoundAddress = unFoundAddress ;

    return MQ_OK ;
}

//+--------------------------------------------------------
//
//  HRESULT  CServerTopologyData::MatchOneAddress()
//
//+--------------------------------------------------------

HRESULT  CServerTopologyData::MatchOneAddress(
                                 IN  CAddressList  *pAddressList,
                                 IN  TA_ADDRESS    *pUnfoundAddressIn,
                                 IN  DWORD          dwAddressLen,
                                 IN  DWORD          dwAddressType,
                                 OUT BOOL          *pfResolved )
{
    TrTRACE(ROUTING, "QM: CTopologyData::MatchOneAddress");
    
    if (pUnfoundAddressIn == NULL)
    {
        return MQ_OK ;
    }

    //
    // Matching is done in-place, and pUnfoundAddressIn is also a pointer
    // to same in-place buffer. So to avoid overwrites, copy it to a
    // different buffer and use that other buffer.
    //
    DWORD dwSize = TA_ADDRESS_SIZE + pUnfoundAddressIn->AddressLength ;
    P<TA_ADDRESS> pUnfoundAddress = (TA_ADDRESS*) new BYTE[ dwSize ] ;
    memcpy(pUnfoundAddress, pUnfoundAddressIn, dwSize) ;

    if (pAddressList->GetCount() == 1)
    {
        BOOL fChanged = FALSE ;

        //
        // We have one "orphan" DS address (that was not found in the
        // hardware list) and one "orphan" hardware address (that was not
        // found in the Ds list). So make a match...
        //
        POSITION pos = pAddressList->GetHeadPosition();
        ASSERT (pos != NULL);
        TA_ADDRESS *pAddr = pAddressList->GetNext(pos);
        TA_ADDRESS *ptr = NULL ;

        for ( DWORD len = 0;
              len < m_cbAddress ;
              len += TA_ADDRESS_SIZE + ptr->AddressLength )
        {
            ptr = (TA_ADDRESS*) (m_blobAddress + len);

            if (ptr->AddressType == dwAddressType)
            {
                ASSERT (ptr->AddressLength == dwAddressLen) ;

                if (memcmp( &(pUnfoundAddress->Address),
                            &(ptr->Address),
                            dwAddressLen ) == 0)
                {
                    memcpy( &(ptr->Address),
                            &(pAddr->Address),
                            dwAddressLen );
                    fChanged = TRUE ;
                }
            }
        }
        //
        // Assert that a match indeed happen...
        //
        ASSERT(fChanged) ;
    }
    else
    {
        //
        // We can reach here in one of two cases:
        // 1. The hardware list is empty, i.e., all hardware addresses were
        //    found in the DS list, while there is one (and only one) DS
        //    address that was not found in the hardware list.
        // 2. There are several candidate hardware addresses to replace
        //    the unfound address. We don't know which one to use.
        // In both cases, calling function will log an event and do nothing
        // more. In theory, we could handle case 1 too, but that means to
        // develop new code that didn't exist in msmq1.0. Too costly and
        // risky so late in the game (before rc2 of rtm)...
        //
        *pfResolved = FALSE ;
    }

    return MQ_OK ;
}

/*=================================================================

HRESULT  CServerTopologyData::CompareUpdateServerAddress()

Arguments:   IN OUT CAddressList  *pIPAddressList
             List of network addresses on local server, retieved using
             winsock apis.

Return Value:

===================================================================*/

HRESULT  CServerTopologyData::CompareUpdateServerAddress(
                                    IN OUT CAddressList  *pIPAddressList,
                                    OUT    BOOL          *pfResolved )
{
    TrTRACE(ROUTING, "QM: CTopologyData::CompareUpdateServerAddress");
    
    //
    // By default, on Windows our addresses are aleays resolved.
    //
    *pfResolved = TRUE ;

    {
		//
		// remove IP loopback address
		//
        AP<char> ptrAddr = new char [TA_ADDRESS_SIZE + IP_ADDRESS_LEN];

        TA_ADDRESS *pAddr = (TA_ADDRESS *) (char*)ptrAddr;
        pAddr->AddressLength = IP_ADDRESS_LEN;
        pAddr->AddressType = IP_ADDRESS_TYPE;
		DWORD dwLoopBack = INADDR_LOOPBACK;
        memcpy( &(pAddr->Address), &dwLoopBack, IP_ADDRESS_LEN);

        IsDSAddressExistRemove(pAddr, IP_ADDRESS_LEN, pIPAddressList) ;
	}

    //
    // Now compare our addresses, as known by our ds server, with the
    // addresses that were retreived from local hardware. If only one
    // address changed, then "fix" the list and update the DS. If more
    // addresses changed, log an event.
    //
    TA_ADDRESS* unFoundIPAddress = NULL;

    HRESULT hr = FindOrphanDsAddress( pIPAddressList,
                                      IP_ADDRESS_LEN,
                                      IP_ADDRESS_TYPE,
                                     &unFoundIPAddress,
                                      pfResolved ) ;
    ASSERT(SUCCEEDED(hr)) ;

    if (!(*pfResolved))
    {
	    TrTRACE(ROUTING, "CompareUpdateServerAddress: Resolved IP address");
        return MQ_OK ;
    }


    //
    // Here we know that only one DS address was not found in hardware list.
    // Now remove from hardware list all those addresses that appear in DS
    // list. These addresses are OK.
    //
    TA_ADDRESS* ptr = NULL ;

    for ( DWORD len = 0;
          len < m_cbAddress ;
          len += TA_ADDRESS_SIZE + ptr->AddressLength )
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        switch(ptr->AddressType)
        {
        case IP_ADDRESS_TYPE:
            ASSERT (ptr->AddressLength == IP_ADDRESS_LEN);

            IsDSAddressExistRemove( ptr,
                                    IP_ADDRESS_LEN,
                                    pIPAddressList ) ;
            break;

        case FOREIGN_ADDRESS_TYPE:
        default:
            break;

        } // case
    } // for

    //
    // Now see if we can resolve the changed address. i.e., if only one
    // DS address was not found in the hardware list, and one hardware
    // address was not found in the DS list, then replace the obsolete
    // DS address with the one left in the hardware list.
    //
    hr = MatchOneAddress( pIPAddressList,
                          unFoundIPAddress,
                          IP_ADDRESS_LEN,
                          IP_ADDRESS_TYPE,
                          pfResolved ) ;
    ASSERT(SUCCEEDED(hr)) ;

    return MQ_OK ;
}

//+------------------------------------------------------
//
//  void CServerTopologyData::GetAddressesSorted()
//
//+------------------------------------------------------

void CServerTopologyData::GetAddressesSorted(
                                 OUT IPADDRESS ** paIPAddress,
                                 OUT GUID **  paguidIPCN,
                                 OUT DWORD *  pnIP
								 ) const
{
     TrTRACE(ROUTING, "CServerTopologyData::GetAddressesSorted");
     
    *paIPAddress = 0;
    *paguidIPCN = 0;
    *pnIP = 0;

    DWORD nIP = 0;
    BOOL fSingleIPCN=TRUE;
    GUID guidIP;
    DWORD iSrc = 0;

    TA_ADDRESS* ptr;

    for (DWORD len = 0; len < m_cbAddress && iSrc < m_nCNs; len += TA_ADDRESS_SIZE + ptr->AddressLength,iSrc++)
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        switch(ptr->AddressType)
        {
        case IP_ADDRESS_TYPE:
        case IP_RAS_ADDRESS_TYPE:
            ASSERT(ptr->AddressLength == IP_ADDRESS_LEN);
            if (nIP == 0)
            {
                guidIP = m_aguidCNs[iSrc];
            }
            else
            {
                fSingleIPCN = fSingleIPCN && guidIP == m_aguidCNs[iSrc];
            }
            nIP++;
            break;

        case FOREIGN_ADDRESS_TYPE:
            ASSERT(ptr->AddressLength == FOREIGN_ADDRESS_LEN);
            break;
        default:
            ASSERT(0);
        }      // case
    } // for

    if (nIP > 0 && fSingleIPCN)
    {
        //
        // We have a limit of only one CN in the same protocol
		// for servers with RAS.
		// we listen on address 0, in order to avoid implementation of RAS notifications.
		// The server replies to RAS Falcon client broadcasts only
		// if it has only one CN in the same protocol
        //
        nIP = 1;
    }

    if (nIP > 0)
    {
        *paIPAddress  = new IPADDRESS[nIP];
        *paguidIPCN   = new GUID [nIP];
    }

    iSrc = 0;
    DWORD iIP = 0;

    for (len = 0; len < m_cbAddress && iSrc < m_nCNs; len += TA_ADDRESS_SIZE + ptr->AddressLength, iSrc++)
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        switch(ptr->AddressType)
        {
        case IP_ADDRESS_TYPE:
        case IP_RAS_ADDRESS_TYPE:
			if (iIP < nIP)
			{
				if (fSingleIPCN)
				{
	                (*paIPAddress)[iIP] = INADDR_ANY;
				}
				else
				{
					memcpy(&(*paIPAddress)[iIP],ptr->Address,sizeof(IPADDRESS));
				}
				(*paguidIPCN)[iIP] = m_aguidCNs[iSrc];
				iIP++;
			}
            break;

        case FOREIGN_ADDRESS_TYPE:
            break;

        default:
            ASSERT(0);
        }      // case
    } // for

    *pnIP         = nIP;
}


bool
CServerTopologyData::GetDSServers(
    OUT unsigned char ** pblobDSServers,
    OUT DWORD * pcbDSServers
    ) const
{
    //
    // PSC, BSC get from DS, also FRS and RAS service that failed to get from registry
    //
    AP<WCHAR> pwcsServerList = new WCHAR[MAX_REG_DSSERVER_LEN];

    DWORD   len = GetDsServerList(pwcsServerList,MAX_REG_DSSERVER_LEN);

    //
    //  Write into registry, if succeeded to retrieve any servers
    //
    if ( len)
    {
        *pcbDSServers = len * sizeof(WCHAR);
        *pblobDSServers = (unsigned char*)pwcsServerList.detach();
        return true;
    }
    LogIllegalPoint(s_FN, 180);
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topoldat.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topoldat.h

Abstract:

  Include file for cached data class for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef __TOPOLDAT_H__
#define __TOPOLDAT_H__

#include "dssutil.h"
typedef DWORD   IPADDRESS;

//***********************************************************
//
//   base class  CTopologyData
//
//***********************************************************

class CTopologyData
{
    public:
        CTopologyData();
        ~CTopologyData();

        HRESULT LoadFromRegistry();

        const GUID& GetEnterprise() const;
        const GUID& GetSite() const;

        BOOL GetAddresses(OUT DWORD                * pcbAddress,
                          OUT const unsigned char ** pblobAddress,
                          OUT DWORD                * pnCNs,
                          OUT const GUID          ** paguidCNs ) const;

    protected:

        DWORD           m_cbAddress;
        unsigned char * m_blobAddress;
        DWORD           m_nCNs;
        GUID *          m_aguidCNs;
        GUID            m_guidEnterprise;
        GUID            m_guidSite;
};


inline CTopologyData::CTopologyData():
                                m_cbAddress(0),
                                m_blobAddress(NULL),
                                m_nCNs(0),
                                m_aguidCNs(NULL)
{
    memset(&m_guidEnterprise,0,sizeof(GUID));
    memset(&m_guidSite,0,sizeof(GUID));
}

inline CTopologyData::~CTopologyData()
{
    delete [] m_blobAddress;
    delete [] m_aguidCNs;
}

inline const GUID& CTopologyData::GetEnterprise() const
{
    return(m_guidEnterprise);
}

inline const GUID& CTopologyData::GetSite() const
{
    return(m_guidSite);
}

inline  BOOL CTopologyData::GetAddresses(
                               OUT DWORD * pcbAddress,
                               OUT const unsigned char ** pblobAddress,
                               OUT DWORD         * pnCNs,
                               OUT const GUID **         paguidCNs) const
{
    if (m_cbAddress > 0 && m_blobAddress != NULL
        && m_nCNs   > 0 && m_aguidCNs != NULL)
    {

        *pcbAddress = m_cbAddress;
        *pblobAddress = m_blobAddress;
        *pnCNs = m_nCNs;
        *paguidCNs = m_aguidCNs;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


//***********************************************************
//
//   class CServerTopologyData : public CTopologyData
//
//***********************************************************

class CServerTopologyData : public CTopologyData
{
    public:
        CServerTopologyData();
        ~CServerTopologyData();

        HRESULT Load();

        HRESULT CompareUpdateServerAddress(
                                    IN OUT CAddressList  *pIPAddressList,
                                    OUT    BOOL          *pfResolved ) ;

        bool
        GetDSServers(
            OUT unsigned char ** pblobDSServers,
            OUT DWORD * pcbDSServers
            ) const;

        void GetAddressesSorted( OUT IPADDRESS ** paIPAddress,
                                 OUT GUID **  paguidIPCN,
                                 OUT DWORD *  pnIP
								 ) const;

    private:

        HRESULT MatchOneAddress( IN  CAddressList  *pAddressList,
                                 IN  TA_ADDRESS    *pUnfoundAddress,
                                 IN  DWORD          dwAddressLen,
                                 IN  DWORD          dwAddressType,
                                 OUT BOOL          *pfResolved ) ;

        HRESULT FindOrphanDsAddress( IN  CAddressList  *pAddressList,
                                     IN  DWORD          dwAddressLen,
                                     IN  DWORD          dwAddressType,
                                     OUT TA_ADDRESS   **pUnfoundAddress,
                                     OUT BOOL          *pfResolved ) ;

};


inline CServerTopologyData::CServerTopologyData()
{
}

inline CServerTopologyData::~CServerTopologyData()
{
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topology.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topology.cpp

Abstract:

    Implementation of Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include "topolpkt.h"
#include "topology.h"
#include "mqsymbls.h"
#include <mqlog.h>
#include "Ev.h"

#include "topology.tmh"

CServerTopologyRecognition*  g_pServerTopologyRecognition = NULL;

static WCHAR *s_FN=L"topology";

/*====================================================

void CTopologyRecognition::ReleaseAddressLists()

Arguments:

Return Value:


=====================================================*/
void CTopologyRecognition::ReleaseAddressLists(CAddressList * pIPAddressList)
{
    POSITION        pos;
    TA_ADDRESS*     pAddr;
    pos = pIPAddressList->GetHeadPosition();
    while(pos != NULL)
    {
        pAddr = pIPAddressList->GetNext(pos);
        delete []pAddr;
    }
}

//+=========================================================================
//
//  CServerTopologyRecognition::Learn()
//
//  Description:
//    On MSMQ1.0 (NT4), we assumed that server have fix addresses.
//    If more than one network address changed at boot then an event was
//    issued and initialization was not completed until administrator
//    used mqxplore to assign CNs to new addresses (or remove CNs).
//    The MQIS kept the old addresses and this function compared them to
//    new machine addresses at boot. If nothing changed (or only one
//    address changed) then initialization completed OK.
//
//    On Windows, the DS do not keep machine addresses anymore and
//    we don't assume that server has fix address. We also do not have
//    CNs anymore. Server can change/add/remove addresses at will.
//    However, in mixed mode, to be compatible with MSMQ1.0 servers, we
//    must replicate address changes of servers to the NT4 world.
//    So, at boot we check if there is any change in our local addresses.
//    If there is a change we touch the msmqConfiguration object in the DS
//    (by re-setting its quota value). This causes the replication service
//    that run on the ex-PEC machine to replicate the changes to NT4.
//
//    There are two ways to check for change in addresses:
//    1. read our own address from NT4 MQIS server, and compare to local
//       network  addresses that are retrieve from hardware.
//    2. read cached addresses from registry (these ones are saved by the
//       msmq service after boot) and compare to hardware.
//    We use both methods as we may query either a NT4 MQIS server or a
//    win2k ds server.
//
//    The above theory is Ok as long as local server is not owned by a
//    NT4 PSC. If it is owned by a NT4 PSC, then tough luck. The PSC store
//    addresses and CNs and local server must update the PSC with correct
//    data. So we must use msmq1.0 style code to handle change in one address.
//    what happen if more than one address changed ? that's really bad.
//    With msmq1.0, we used local mqxplore. Now we'll have to log an event
//    that tell user to use mqxplore on the PSC to update the addresses
//    and CNs of local server. In any case, local server continue to run
//    as usual. See below in the code.
//
//  Return Value:
//
//+=========================================================================

HRESULT CServerTopologyRecognition::Learn()
{
    TrTRACE(ROUTING, "QM: CServerTopologyRecognition::Learn");

    //
    // Retrieve machine addresses and CNs.
    //
    HRESULT rc = m_Data.Load();
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 110);
    }

    //
    // Retrieve Current machine address
    //
    P<CAddressList> pIPAddressList;

    pIPAddressList = GetIPAddresses();

    BOOL fResolved = FALSE;
    try
    {
        rc = m_Data.CompareUpdateServerAddress(pIPAddressList, &fResolved);
    }
    catch(...)
    {
        //
        // the reason for this try/catch is that this code was added
        // quite late in the game, before win2k rtm. It has too many loops
        // that depend on the proper structure of data. Anything can fail
        // and gpf. We don't have the time to test all possible scenario.
        // So to be on the safe side, catch any exception and consider them
        // as "everything is just fine"...
        //
        LogIllegalPoint(s_FN, 130);

        rc = MQ_OK ;
        fResolved = TRUE ;
    }

    LogHR(rc, s_FN, 120);
    if (SUCCEEDED(rc))
    {
        if(!fResolved)
        {
            EvReport(DS_ADDRESS_NOT_RESOLVED);
        }
    }

    //
    // We're always resolved, even if several addresses changed and
    // an event is logged. there is nothing more we can do, and win2k
    // admin tool can not be used to resolve addresses. So let's go on
    // and do the best we can.
    // Actually, this server can communicate with the outside world.
    // The outside world may have problems communicating with us.
    //
    ReleaseAddressLists(pIPAddressList) ;

    return rc ;
}


/*====================================================

ServerRecognitionThread

Arguments:

Return Value:

=====================================================*/

DWORD WINAPI ServerRecognitionThread(LPVOID Param)
{

    const CServerTopologyRecognition * pServerTopologyRecognition = (CServerTopologyRecognition *) Param;

    for(;;)
    {
        try
        {
            pServerTopologyRecognition->ServerThread();
            EvReport(EVENT_ERROR_RECOGNITION_SERVER_FAILED);
            LogIllegalPoint(s_FN, 30);
            return 1;
        }
        catch(const bad_alloc&)
        {
            LogIllegalPoint(s_FN, 83);
        }
    }

    return 0;
}

/*====================================================

CServerTopologyRecognition::ServerThread

Arguments:

Return Value:

=====================================================*/

void CServerTopologyRecognition::ServerThread() const
{
    for(;;)
    {

        //
        // Retrieve Current machine address
        //

        AP<IPADDRESS> aIPAddress;
        AP<GUID> aIPCN;
        DWORD nIP = 0;
        m_Data.GetAddressesSorted(&aIPAddress,&aIPCN,&nIP);
        DWORD nSock = nIP;
        if (nSock == 0)
        {
            TrERROR(DS, "ServerRecognitionThread: does not have any address");
	    	LogIllegalPoint(s_FN, 23);
            return;
        }


        CTopologyArrayServerSockets ServerSockets;

        if(!ServerSockets.CreateIPServerSockets(nIP,aIPAddress,aIPCN))
        {
	    	LogIllegalPoint(s_FN, 24);
            return;
        }

        SOCKADDR hFrom;
        DWORD cbRecv;

        AP<unsigned char> blobDSServers;
        DWORD cbDSServers = 0;

        const GUID& rguidEnterprise = m_Data.GetEnterprise();
        const GUID& rguidSite = m_Data.GetSite();

        if(!m_Data.GetDSServers(&blobDSServers, &cbDSServers))
        {
	    	LogIllegalPoint(s_FN, 26);
            return;
        }

        DWORD cbSend;
        AP<char> bufSend = CTopologyServerReply::AllocBuffer(cbDSServers,&cbSend);

#ifdef _DEBUG
#undef new
#endif
        CTopologyServerReply * pReply =
            new (bufSend) CTopologyServerReply();
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

        DWORD cbMaxRecv = CTopologyClientRequest::GetMaxSize();
        AP<char> bufRecv = new char[cbMaxRecv];

        BOOL fOtherSite;

        const CTopologyServerSocket * pSocket;

        P<GUID> pGuidCN = new GUID;
        GUID guidRequest;

        for(;;)
        {
            if(!ServerSockets.ServerRecognitionReceive(bufRecv,cbMaxRecv,&cbRecv,&pSocket,&hFrom))
            {
                //
                // cannot receive, rebuild sockets
                //
		    	LogIllegalPoint(s_FN, 27);
                break;
            }

            bool fParsed = CTopologyClientRequest::Parse( bufRecv,
                                                    cbRecv,
                                                    rguidEnterprise,
                                                    rguidSite,
                                                    &guidRequest,
                                                    &fOtherSite
												    ) ;
            if(!fParsed)
            {
		    	LogIllegalPoint(s_FN, 28);
                continue;
            }

			//
			// We "know" GetCN will return one CN. ilanh 02-August-2000
			// 
            pSocket->GetCN(pGuidCN);

            pReply->SetSpecificInfo(
                                guidRequest,
                                pGuidCN,
                                fOtherSite,
                                cbDSServers,
                                rguidSite,
                                (const char*) (unsigned char*)blobDSServers,
                                &cbSend
								);

            if(!pSocket->ServerRecognitionReply(bufSend,cbSend,hFrom))
            {
                //
                // cannot send, rebuild sockets
                //
		    	LogIllegalPoint(s_FN, 29);
                break;
            }

        }
    }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topolpkt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topology.cpp

Abstract:

    Implementation of Automatic recognition Packets

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/


#include "stdh.h"
#include "topolpkt.h"
#include "ds.h"
#include "mqsymbls.h"
#include "mqprops.h"
#include <mqlog.h>

#include "topolpkt.tmh"

static WCHAR *s_FN=L"topolpkt";

static
bool
IsValidSite(
    const GUID& id
    )
{
    if (id == GUID_NULL)
        return false;

    PROPID prop[] = {
                PROPID_S_FOREIGN,
                };

    MQPROPVARIANT var[TABLE_SIZE(prop)] = {{VT_NULL,0,0,0,0}};

	HRESULT hr = DSGetObjectPropertiesGuid(
						MQDS_SITE,				
						&id,
						TABLE_SIZE(prop),
						prop,
						var
						);

	return (SUCCEEDED(hr));
}

bool
CTopologyClientRequest::Parse(
    IN const char * bufrecv,
    IN DWORD cbrecv,
    IN const GUID& guidEnterprise,
    IN const GUID& guidMySite,
    OUT GUID * pguidRequest,
    OUT BOOL * pfOtherSite
    )
{
    TrTRACE(ROUTING, "QM: CTopologyClientRequest::Parse");
    
    //
    // check that received from a Falcon machine
    //
    DWORD cbMin = GetMinSize();

    if (cbrecv < cbMin)
    {
        LogIllegalPoint(s_FN, 10);
        return false;
    }

    const CTopologyClientRequest *pRequest = (const CTopologyClientRequest *) bufrecv;

    if (!pRequest->m_Header.Verify(QM_RECOGNIZE_CLIENT_REQUEST,guidEnterprise))
    {
        LogIllegalPoint(s_FN, 20);
        return false;
    }

    //
    //  Is the client site a known site in this server enterprise ?
    //  Since in Win2k we removed the verification of enterprise-id, let's
    //  verify that the client "old" site belongs to this enterprise.
    //
    //  NT4 mobile clients provide a correct site-guid only on the first call,
    //  afterward they send GUID_NULL as the site guid.
    //  Therefore if a NT4 client sends a GUID_NULL, we will verify its
    //  enterprise id.
    //  Win2k clients always send the site id, so win2k servers never
    //  check enterprise id for them.
    //
    if ( !IsValidSite(pRequest->m_guidSite))
    {
        if (pRequest->m_guidSite != GUID_NULL)
        {
            LogIllegalPoint(s_FN, 30);
            return false;
        }

        if ( guidEnterprise != *pRequest->m_Header.GetEnterpriseId() )
        {
            LogIllegalPoint(s_FN, 40);
            return false;
        }
    }

    *pguidRequest = pRequest->m_guidRequest;
    *pfOtherSite = pRequest->m_guidSite != guidMySite;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topology.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    recogniz.h

Abstract:

  Include file for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef __TOPOLOGY_H__
#define __TOPOLOGY_H__

#include "topoldat.h"
#include "topolsoc.h"
#include "topolpkt.h"
#include "cs.h"

DWORD WINAPI ServerRecognitionThread(LPVOID Param);

//***********************************************************
//
//   base class  CTopologyRecognition
//
//***********************************************************

class CTopologyRecognition
{
public:
    CTopologyRecognition();
    ~CTopologyRecognition();

protected:
    void ReleaseAddressLists(CAddressList * pIPAddressList);
};


inline CTopologyRecognition::CTopologyRecognition()
{
}

inline CTopologyRecognition::~CTopologyRecognition()
{
}

//*******************************************************************
//
//  class  CServerTopologyRecognition : public CTopologyRecognition
//
//*******************************************************************

class CServerTopologyRecognition : public CTopologyRecognition
{
public:
    CServerTopologyRecognition();

    ~CServerTopologyRecognition();


    HRESULT Learn();
    const GUID& GetSite() const;

    void ServerThread() const;

    const GUID& GetEnterprise() const;

private:

    CServerTopologyData m_Data;
};


inline CServerTopologyRecognition::CServerTopologyRecognition()
{
}

inline CServerTopologyRecognition::~CServerTopologyRecognition()
{
}

inline const GUID& CServerTopologyRecognition::GetSite() const
{
    return(m_Data.GetSite()) ;
}


inline const GUID& CServerTopologyRecognition::GetEnterprise() const
{
    return(m_Data.GetEnterprise()) ;
}

extern CServerTopologyRecognition  *g_pServerTopologyRecognition ;

#endif // __TOPOLOGY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topolsoc.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topolsoc.cpp

Abstract:

  Implementation of sockets for Automatic recognition

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include <winsock.h>
#include <nspapi.h>
#include <wsnwlink.h>
#include "topolsoc.h"
#include "mqutil.h"
#include <mqlog.h>
#include "cm.h"

#include "topolsoc.tmh"

static WCHAR *s_FN=L"topolsoc";

const LPCWSTR xParameters = L"Parameters";
const LPCWSTR xMsmqIpPort = L"MsmqIpPort";


bool
CTopologySocket::CreateIPSocket(
    IN BOOL fbroad,
    IN IPADDRESS IPAddress
    )
{
    TrTRACE(ROUTING, "QM: CTopologySocket::CreateIPSocket");
   
    int rc;

    if (m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
    }

    m_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (m_socket == INVALID_SOCKET)
    {
        TrERROR(DS, "CN recognition: failed to create IP socket");
        LogIllegalPoint(s_FN, 10);
        return false;
    }

    BOOL exclusive = TRUE;
    rc = setsockopt( m_socket, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&exclusive, sizeof(exclusive));
    if (rc != 0)
    {
        rc = WSAGetLastError();
        TrERROR(DS, "CN recognition: setsocketopt SO_EXCLUSIVEADDRUSE failed rc = %d for IP socket",rc);
        LogNTStatus(rc, s_FN, 20);
        return false;
    }
    if (fbroad)
    {
        rc = setsockopt( m_socket, SOL_SOCKET, SO_BROADCAST, (char *)&exclusive, sizeof(exclusive));
        if (rc != 0)
        {
            rc = WSAGetLastError();
            TrERROR(DS, "CN recognition: setsocketopt SO_BROADCAST failed rc = %d for IP socket",rc);
            LogNTStatus(rc, s_FN, 30);
            return false; 
        }
    }

    //
    // Keep the TA_ADDRESS format of local IP address
    //
    SOCKADDR_IN local_sin;  // Local socket - internet style

    local_sin.sin_family = AF_INET;


    //
    // read IP port from registry.
    //
	DWORD  dwIPPort = 0 ;
    DWORD dwDef = FALCON_DEFAULT_IP_PORT;
	const RegEntry xMsmqIpPortEntry(xParameters, xMsmqIpPort, dwDef);
	CmQueryValue(xMsmqIpPortEntry, &dwIPPort);

    ASSERT(("IP Port was not found", dwIPPort));
    local_sin.sin_port = htons(DWORD_TO_WORD(dwIPPort));  // Convert to network ordering

    //
    //  Bind to IP address
    //
    memcpy(&local_sin.sin_addr.s_addr,&IPAddress,IP_ADDRESS_LEN);

    rc = bind( m_socket, (struct sockaddr FAR *) &local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        rc = WSAGetLastError();
        TrERROR(DS, "CN recognition: bind failed rc = %d for IP socket",rc);
        LogNTStatus(rc, s_FN, 40);
        return false;
    }

    TrTRACE(ROUTING, "Topology socket (broadcast=%d) has been bound to port %d, IP %hs", 
       fbroad, dwIPPort, inet_ntoa(local_sin.sin_addr));

    return true;
}


bool
CTopologyArrayServerSockets::CreateIPServerSockets(
    DWORD  nSock,
    const IPADDRESS aIPAddresses[],
    const GUID aguidCNs[]
    )
{
    TrTRACE(ROUTING, "QM: CTopologyArrayServerSockets::CreateIPServerSockets");

    if (nSock ==0)
    {
        return(MQ_OK);
    }

    m_nIPSock = nSock;
    m_aServerIPSock = new CTopologyServerIPSocket[m_nIPSock];

    for (DWORD i=0; i< nSock ; i++)
    {
        if(!m_aServerIPSock[i].Create(aIPAddresses[i],aguidCNs[i]))
        {
            TrERROR(DS, "CN recognition: failed in IP socket num %d",i);
            LogIllegalPoint(s_FN, 82);
            return false;
        }
    }
    return true;

}


bool
CTopologyArrayServerSockets::ServerRecognitionReceive(
    OUT char *bufrecv,
    IN DWORD cbbuf,
    OUT DWORD *pcbrecv,
    OUT const CTopologyServerSocket **ppSocket,
    OUT SOCKADDR *phFrom
    )
{
    TrTRACE(ROUTING, "QM: CTopologyArrayServerSockets::ServerRecognitionReceive");

    fd_set sockset;

    DWORD nSock = m_nIPSock;

    FD_ZERO(&sockset);
    for(DWORD i=0;i<nSock;i++)
    {
        FD_SET((GetSocketAt(i))->GetSocket(),&sockset);
    }

    int rc = select(0,&sockset,NULL,NULL,NULL);
    if (rc == SOCKET_ERROR)
    {
        rc = WSAGetLastError();
        TrERROR(DS, "Server broadcast listen: select failed rc = %d",rc);
        LogNTStatus(rc, s_FN, 90);
        return false;
    }

    BOOL found=FALSE;
    for(i=0;i<nSock;i++)
    {
        if (FD_ISSET((GetSocketAt(i))->GetSocket(),&sockset))
        {
            TrTRACE(ROUTING, "Server broadcast listen: received on index %d",i);
            *ppSocket = GetSocketAt(i);
            found = TRUE;
            break;
        }

    }

    if (!found)
    {
        TrERROR(DS, "Server broadcast listen: select returned with no sockets");
        LogIllegalPoint(s_FN, 100);
        return false;
    }


    int fromlen = sizeof(SOCKADDR);

    *pcbrecv = recvfrom((*ppSocket)->GetSocket(),bufrecv,cbbuf,0,phFrom,&fromlen);
    if (*pcbrecv == SOCKET_ERROR)
    {
        rc = WSAGetLastError();
        TrERROR(DS, "Server broadcast listen: recvfrom failed, rc = %d",i);
        LogNTStatus(rc, s_FN, 110);
        return false;
    }
    TrTRACE(ROUTING, "Server broadcast listen: recvfrom returned with %d bytes",*pcbrecv);

    return true;
}

bool
CTopologyServerSocket::ServerRecognitionReply(
    IN const char *bufsend,
    IN DWORD cbsend,
    IN const SOCKADDR& hto
    ) const
{
    TrTRACE(ROUTING, "QM: CTopologyServerSocket::ServerRecognitionReply");

    int rc = sendto(GetSocket(),bufsend,cbsend,0,(PSOCKADDR)&hto,sizeof(SOCKADDR));
    if (rc == SOCKET_ERROR)
    {
        rc = WSAGetLastError();
        TrERROR(DS, "Server broadcast listen: sendto failed, rc = %d", rc);
        LogNTStatus(rc, s_FN, 120);
        return false;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topolpkt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topology.cpp

Abstract:

    Include file of Automatic recognition Packets

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/


#ifndef __TOPOLPKT_H__
#define __TOPOLPKT_H__

#include "dssutil.h"

#define QM_RECOGNIZE_VERSION         0

#define QM_RECOGNIZE_CLIENT_REQUEST    1
#define QM_RECOGNIZE_SERVER_REPLY      2

//
// CTopologyPacketHeader
//

#pragma pack(push, 4)

class CTopologyPacketHeader
{
    public:
        CTopologyPacketHeader(IN unsigned char ucType);
        CTopologyPacketHeader(IN unsigned char ucType,
                              IN const GUID& guidIdentifier);
        ~CTopologyPacketHeader();

        void SetIdentifier(IN const GUID& guid);

        BOOL Verify(IN unsigned char ucType,
                    IN const GUID& guid) const;
        const GUID * GetEnterpriseId() const { return &m_guidIdentifier;};


    private:
        unsigned char  m_ucVersion;
        unsigned char  m_ucType;
        unsigned short m_usReserved;
        GUID           m_guidIdentifier;
};
#pragma pack(pop)

inline CTopologyPacketHeader::CTopologyPacketHeader(IN unsigned char ucType):
                        m_ucVersion(QM_RECOGNIZE_VERSION),
                        m_ucType(ucType),
                        m_usReserved(0)
{
    memset(&m_guidIdentifier,0,sizeof(GUID));
}

inline CTopologyPacketHeader::CTopologyPacketHeader(IN unsigned char ucType,
                                             IN const GUID& guidIdentifier):
                        m_ucVersion(QM_RECOGNIZE_VERSION),
                        m_ucType(ucType),
                        m_usReserved(0),
                        m_guidIdentifier(guidIdentifier)
{
}

inline CTopologyPacketHeader::~CTopologyPacketHeader()
{
}

inline void CTopologyPacketHeader::SetIdentifier(IN const GUID& guid)
{
    m_guidIdentifier = guid;
}


inline BOOL CTopologyPacketHeader::Verify(IN unsigned char ucType,
                                   IN const GUID& guid) const
{
    switch( ucType)
    {
    case QM_RECOGNIZE_CLIENT_REQUEST:
        //
        //  check version ( ignore enterprise)
        //
        return(
                 m_ucVersion == QM_RECOGNIZE_VERSION &&
                 m_ucType == ucType 
              );
        break;  
    case QM_RECOGNIZE_SERVER_REPLY:
        //
        // check version, sending enterprise and type
        //
        return(
                 m_ucVersion == QM_RECOGNIZE_VERSION &&
                 m_ucType == ucType &&
                 m_guidIdentifier == guid
              );
        break;
    default:
        ASSERT(0);
        return( FALSE);
        break;

    }
}


//
// CTopologyClientRequest
//

#pragma pack(push, 4)

class CTopologyClientRequest
{
public:
    CTopologyClientRequest(IN const GUID& guidEnterprise,
                           IN const GUID& guidSite);

    ~CTopologyClientRequest();

    const char * GetBuffer(OUT DWORD *pcbIPBuf);

    static DWORD GetMaxSize();

    static
    bool
    Parse(
        IN const char * bufrecv,
        IN DWORD cbrecv,
        IN const GUID& guidEnterprise,
        IN const GUID& guidMySite,
        OUT GUID * pguidRequest,
        OUT BOOL * pfOtherSite
        );

private:

    static DWORD GetMinSize();

    CTopologyPacketHeader  m_Header;
    GUID                   m_guidRequest;
    GUID                   m_guidSite;
};
#pragma pack(pop)


inline CTopologyClientRequest::CTopologyClientRequest(IN const GUID& guidEnterprise,
                                                      IN const GUID& guidSite):
                               m_Header(QM_RECOGNIZE_CLIENT_REQUEST,guidEnterprise),
                               m_guidSite(guidSite)
{
    memset(&m_guidRequest,0,sizeof(GUID));
}

inline CTopologyClientRequest::~CTopologyClientRequest()
{
}

inline const char * CTopologyClientRequest::GetBuffer(OUT DWORD *pcbIPBuf)
{
    *pcbIPBuf =  GetMinSize();
    return ((const char *) this);
}

inline DWORD CTopologyClientRequest::GetMaxSize()
{
    return (sizeof(CTopologyClientRequest));
}

inline DWORD CTopologyClientRequest::GetMinSize()
{
    return (sizeof(CTopologyClientRequest));
}

//
// CTopologyServerReply
//

#pragma pack(push, 4)

class CTopologyServerReply
{
public:
    CTopologyServerReply();
    ~CTopologyServerReply();

    static char* AllocBuffer(IN DWORD cbDSServers,
                             OUT DWORD *pcbBuf);

    void SetSpecificInfo(IN const GUID& guidRequest,
                         IN const GUID* pGuidCN,
                         IN BOOL fOtherSite,
                         IN DWORD  cbDSServers,
                         IN const GUID& guidSite,
                         IN const char* blobDSServers,
                         OUT DWORD *pcbsend);

private:
    static DWORD GetSize(IN DWORD cbDSServers);

	//
	// Don't touch or rearrange this structure.
	// This is the ServerReply structure that need to be compatible for msmq1.0
	// and msmq2.0 clients requests. ilanh 10-Aug-2000
	//
    CTopologyPacketHeader  m_Header;
    DWORD          m_nCN;
    DWORD          m_maskCN;
    DWORD          m_cbDSServers;
    GUID           m_aguidCN[1];           
    //GUID           m_guidSite;           // site right after CNs if cbDSservers > 0
    //char*          m_blobDSServers;      // DSServer only if cbDSServers > 0
};
#pragma pack(pop)

inline CTopologyServerReply::CTopologyServerReply():
                             m_Header(QM_RECOGNIZE_SERVER_REPLY),
                             m_nCN(0),
                             m_maskCN(0),                                 
                             m_cbDSServers(0)
{
    memset(&m_aguidCN,0,sizeof(m_aguidCN));
}

inline DWORD CTopologyServerReply::GetSize(IN DWORD cbDSServers)
{
    //
	// We are using the information that 
	// CTopologyServerIPSocket::GetCN return always 1 CN so we "know" we have only 1 site.
	// Some more cleanups need to do regarding this ilanh 2-August-2000
	//
	DWORD size = sizeof(CTopologyServerReply);
    if (cbDSServers)
    {
        size+= sizeof(GUID) + cbDSServers;
    }
    return(size);

}

inline char* CTopologyServerReply::AllocBuffer(
                                IN DWORD cbDSServers,
                                OUT DWORD *pcbBuf)
{
    //
    //
    //
    *pcbBuf = GetSize(cbDSServers);

    return new char[*pcbBuf];
}


inline void CTopologyServerReply::SetSpecificInfo(
                                IN const GUID& guidRequest,
                                IN const GUID* pGuidCN,
                                IN BOOL fOtherSite,
                                IN DWORD  cbDSServers,
                                IN const GUID& guidSite,
                                IN const char* blobDSServers,
                                OUT DWORD *pcbsend)
{
    //
    // write CN
    //
    m_Header.SetIdentifier(guidRequest);

    //
	// We are using the information that 
	// CTopologyServerIPSocket::GetCN return always 1 CN
	// Some more cleanups need to do regarding this ilanh 2-August-2000
	//
	m_nCN = 1;
    memcpy(m_aguidCN,pGuidCN,sizeof(GUID));
    
    //
    // expose site info if needed
    //
    if (fOtherSite)
    {
        m_cbDSServers = cbDSServers ;
        //
        // guid Site is after the last CN
        //
        m_aguidCN[m_nCN] = guidSite;
        //
        // DSServers are after the Site
        //
        memcpy(&m_aguidCN[m_nCN+1],blobDSServers,cbDSServers);
    }
    else
    {
         m_cbDSServers = 0;
    }

    *pcbsend = GetSize(m_cbDSServers);

}



#endif	// __TOPOLPKT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqise\ise2qm_c_.c ===
#pragma warning(push, 3)
#include <ise2qm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqise\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:
--*/


#pragma once

#ifndef __STDH_H
#define __STDH_H

#include <libpch.h>

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqise\test\ise2qm_s_.c ===
#pragma warning(push, 3)
#include <ise2qm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqdssvc\topolsoc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topolsoc.h

Abstract:

  Include file sockets for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef __TOPOLSOC_H__
#define __TOPOLSOC_H__

#include <winsock.h>
#include "mqsymbls.h"
#include "_mqdef.h"

typedef DWORD   IPADDRESS;

class CTopologySocket
{
public:
    CTopologySocket();
    ~CTopologySocket();

    SOCKET GetSocket() const;

protected:
    bool CreateIPSocket(IN BOOL fbroad, IN IPADDRESS IPAddress);
private:
    SOCKET m_socket;
};


inline CTopologySocket::CTopologySocket():
                                    m_socket(INVALID_SOCKET)
{
}

inline CTopologySocket::~CTopologySocket()
{
    if (m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
    }
}

inline SOCKET CTopologySocket::GetSocket() const
{
    return(m_socket);
}

class CTopologyServerSocket : public CTopologySocket
{
public:
    CTopologyServerSocket();
    ~CTopologyServerSocket();

    bool
    ServerRecognitionReply(
        IN const char *bufsend,
        IN DWORD cbsend,
        IN const SOCKADDR& hto
        ) const;

    virtual DWORD GetCN(OUT GUID* pGuidCN) const =0;
};

inline CTopologyServerSocket::CTopologyServerSocket()
{
}

inline CTopologyServerSocket::~CTopologyServerSocket()
{
}

class CTopologyServerIPSocket : public CTopologyServerSocket
{
public:
    CTopologyServerIPSocket();
    ~CTopologyServerIPSocket();

    bool Create(IN IPADDRESS IPAddress, IN const GUID& guidCN);

    DWORD GetCN(OUT GUID* pGuidCN) const;

private:
    GUID m_guidCN;
};

inline CTopologyServerIPSocket::CTopologyServerIPSocket()
{
    memset(&m_guidCN,0,sizeof(GUID));
}

inline CTopologyServerIPSocket::~CTopologyServerIPSocket()
{
}

inline
bool
CTopologyServerIPSocket::Create(
    IN IPADDRESS IPAddress,
    IN const GUID & guidCN
    )
{
    m_guidCN = guidCN;
    return(CTopologySocket::CreateIPSocket(FALSE,IPAddress));
}

inline DWORD CTopologyServerIPSocket::GetCN(
                               OUT GUID* pGuidCN) const
{
    *pGuidCN = m_guidCN;
    return(1);
}


class CTopologyArrayServerSockets
{
public:
    CTopologyArrayServerSockets();
    ~CTopologyArrayServerSockets();

    bool
    CreateIPServerSockets(
        DWORD  nSock,
        const IPADDRESS aIPAddresses[],
        const GUID aguidCNs[]
        );

    bool
    ServerRecognitionReceive(
        OUT char *bufrecv,
        IN DWORD cbbuf,
        OUT DWORD *pcbrecv,
        OUT const CTopologyServerSocket **ppSocket,
        OUT SOCKADDR *phFrom
        );

private:

    const CTopologyServerSocket * GetSocketAt(IN DWORD n) const;

    DWORD m_nIPSock;
    CTopologyServerIPSocket* m_aServerIPSock;
};

inline CTopologyArrayServerSockets::CTopologyArrayServerSockets() :
                            m_nIPSock(0),
                            m_aServerIPSock(NULL)
{
}

inline CTopologyArrayServerSockets::~CTopologyArrayServerSockets()
{
    delete [] m_aServerIPSock;
}


inline const CTopologyServerSocket * CTopologyArrayServerSockets::GetSocketAt(IN DWORD n) const
{
    ASSERT(("support only IP", n < m_nIPSock));
    return(&m_aServerIPSock[n]);
}

#endif	// __TOPOLSOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqise\test\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:
--*/


#pragma once

#ifndef __STDH_H
#define __STDH_H

#include <libpch.h>

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqise\mqise.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    mqise.cpp

Abstract:
    MSMQ ISAPI extension with asynchronous read

	Forwards http requests from IIS to the QM through RPC interface

Author:
    Nir Aides (niraides) 03-May-2000
	Modification: Gal Marwitz (t-galm) 25-April-2002

--*/

#include "stdh.h"

#include <httpext.h>
#include <_mqini.h>
#include <buffer.h>
#include <bufutl.h>
#include "ise2qm.h"
#include <mqcast.h>
#include <mqexception.h>
#include <autoreln.h>
#include <Aclapi.h>
#include <autohandle.h>
#include <windns.h>
#include <mqsec.h>
#include <rwlock.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include "_registr.h"
#include "_mqrpc.h"
#include "_stdh.h"
#include "mqise.tmh"

static WCHAR *s_FN=L"mqise/mqise";

using namespace std;

extern bool
IsLocalSystemCluster(
    VOID
    );


//
// Globals and constants
//
LPCSTR HTTP_STATUS_SERVER_ERROR_STR = "500 Internal server error";
LPCSTR HTTP_STATUS_DENIED_STR = "401 Unauthorized";

CReadWriteLock s_rwlockRpcTable;
typedef std::map<string, RPC_BINDING_HANDLE> HOSTIP2RPCTABLE;
static 	HOSTIP2RPCTABLE s_RPCTable;
const DWORD xBUFFER_ADDITION_UPPER_LIMIT = 16384;
const DWORD xHTTPBodySizeMaxValue = 10485760;  // 10MB = 10 * 1024 * 1024


static
RPC_BINDING_HANDLE
GetLocalRPCConnection2QM(
	LPCSTR  pszEntry
	);

static
void
RemoveRPCCacheEntry(
	char *pszEntry
	);

static
LPSTR
RPCToServer(
	EXTENSION_CONTROL_BLOCK *pECB,
	LPCSTR Headers,
	size_t BufferSize,
	PBYTE Buffer
	);

static
BOOL
SendResponse(
	EXTENSION_CONTROL_BLOCK* pECB,
	LPCSTR szStatus,
	BOOL fKeepConn
	);


BOOL
WINAPI
GetExtensionVersion(
	HSE_VERSION_INFO* pVer
	)
/*++
Routine Description:
    This function is called only once when the DLL is loaded into memory
--*/
{
	//
	// Create the extension version string.
	//
	pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

	//
	// Copy description string into HSE_VERSION_INFO structure.
	//
	const char xDescription[] = "MSMQ ISAPI extension";
	C_ASSERT(HSE_MAX_EXT_DLL_NAME_LEN > STRLEN(xDescription));

	strncpy(pVer->lpszExtensionDesc, xDescription,HSE_MAX_EXT_DLL_NAME_LEN );

	return TRUE;
}


static
void
FreeRpcBindHandle(
	RPC_BINDING_HANDLE hRPC
	)
{
    if(hRPC)
    {
	    TrTRACE(NETWORKING, "Removed RPC handle for cache entry.");
	
        RPC_STATUS status = RpcBindingFree(&hRPC);
        if(status != RPC_S_OK)
        {
            TrERROR(NETWORKING, "RpcBindingFree failed: return code = 0x%x", status);
        }
    }
}


BOOL
WINAPI
TerminateExtension(
	DWORD /*dwFlags*/
	)
{
	CSW lock(s_rwlockRpcTable);
	
    //
    // Unbind all RPC connections and erase all Cache entries
    //
    HOSTIP2RPCTABLE::iterator RPCIterator = s_RPCTable.begin();
    while( RPCIterator != s_RPCTable.end() )
    {
    	FreeRpcBindHandle(RPCIterator->second);

        //
        // Remove the current item and advance to next item
        //
        RPCIterator = s_RPCTable.erase(RPCIterator);
    }

    return TRUE;
}

/*++
Struct Context
Description:
	passes request information to
	completion function "getHttpBody
--*/
struct Context
{
	CStaticResizeBuffer<char, 2048> Headers;
	CStaticResizeBuffer<BYTE, 8096> csBuffer;
    CPreAllocatedResizeBuffer<BYTE>* Buffer ;		
};	



static
VOID
cleanUp(
	Context *pContext,
	LPEXTENSION_CONTROL_BLOCK pECB
	)	
/*++
Routine Description:
	Informs IIS that the current request session is over

Arguments: pECB - control block of current request session
	pContext - structure with cirrent session info
	
Returned Value:
--*/
{
	BOOL fRes = pECB->ServerSupportFunction(pECB->ConnID,
	    				                    HSE_REQ_DONE_WITH_SESSION,
										    NULL,
										    NULL,
											NULL
										   );
	if(!fRes)		
	{
		TrERROR(NETWORKING,"Failure informing IIS about completion of current session.");
		ASSERT(("Failure informing IIS about completion of current session.", 0));
	}	
    if(NULL != pContext)
    {
		delete(pContext);
	}
}


static
DWORD
AdjustBuffer(
	Context* pContext,
	LPEXTENSION_CONTROL_BLOCK pECB
	)
/*++
Routine description :
	Adjusts sizes of the data buffer according to current read results

Arguments:
	pECB - control block of current request session
    pContext - structure with cirrent session info
	
Returned Value:
	Number of bytes left to read on next call
--*/
{
	DWORD RemainsToRead = static_cast<DWORD>(pECB->cbTotalBytes - pContext->Buffer->size());
	DWORD ReadSize = min(RemainsToRead, xBUFFER_ADDITION_UPPER_LIMIT);

	if(ReadSize > pContext->Buffer->capacity() - pContext->Buffer->size())
	{
		//
		// Need to grow buffer to make space for next read.
		// Max grow buffer is xHTTPBodySizeMaxValue (10MB)
		//
		DWORD ReserveSize = min(numeric_cast<DWORD>(pContext->Buffer->capacity() * 2 + ReadSize), xHTTPBodySizeMaxValue);
		pContext->Buffer->reserve(ReserveSize);
		ASSERT(pContext->Buffer->capacity() - pContext->Buffer->size() >= ReadSize);
	}

	return ReadSize;
}

static
BOOL
HandleEndOfRead(
	Context* pContext,
	EXTENSION_CONTROL_BLOCK* pECB
	)
/*++
Routine Description:
	The routine is called when the entire message  has been read.
	it passes the message forward, and sends a response to the sender.

Arguments: pECB - request session control block
           pContext  -  holds the request buffer and header
		
Returned Value:

--*/
{

	//
	// Pad last four bytes of the buffer with zero. It is needed
	// for the QM parsing not to fail. four bytes padding and not two
	// are needed because we don't have currently solution to the problem
	// that the end of the buffer might be not alligned on WCHAR bouderies.
	//
    const BYTE xPadding[4] = {0, 0, 0, 0};
	pContext->Buffer->append(xPadding, sizeof(xPadding));

	TrTRACE(NETWORKING, "HTTP Body size = %d", numeric_cast<DWORD>(pContext->Buffer->size()));
	AP<char> Status = RPCToServer(pECB,pContext->Headers.begin(),pContext->Buffer->size(),pContext->Buffer->begin());

	//
	// Set server error if Status is empty
	//
	if(Status.get() == NULL)
	{
		Status = (LPSTR)newstr(HTTP_STATUS_SERVER_ERROR_STR);
	}
	
	BOOL fKeepConnection = atoi(Status) < 500 ? TRUE : FALSE;
    BOOL fRes = SendResponse(pECB,
						  	 Status,		
							 fKeepConnection
							);

	return fRes;
}


VOID
WINAPI
GetHttpBody(
	LPEXTENSION_CONTROL_BLOCK  pECB,
	PVOID pcontext,
	DWORD ReadSize,
	DWORD dwError
	)
/*++
Routine Description:
    Completion function of asynchronous read request
	Builds message body buffer.

	Normally, message bodies smaller than 64KB are allready pointed to by
	the pECB. Bigger Message bodies need to be read from the IIS chunk by
	chunk into a buffer within the Context structure.

Arguments: pECB - request session control block
           pcontext  -  holds the request buffer and header
		   ReadSize  -  size of newly read chunk of information
		   dwError   -  indication to success of the read request
	
Returned Value:

--*/

{
	Context* pContext = (Context*)pcontext;
	try
	{
		if((ERROR_SUCCESS != dwError) ||
		   (NULL == pECB) ||
		   (NULL == pcontext) ||
		   (NULL == &(pContext->csBuffer)) ||
		   (NULL == pContext->Buffer) ||
		   (NULL == &(pContext->Headers)))
		{
			//
			// Read failed
			//
			SetLastError(dwError);
			TrERROR(NETWORKING,"Failure reading data.Error code : %d.",dwError);
			throw exception();
		}

		//
		// Read successfully, so update current
		// total bytes read (aka index of grand data holder)
		//
		pContext->Buffer->resize(pContext->Buffer->size() + ReadSize);
		ASSERT(xHTTPBodySizeMaxValue >= pContext->Buffer->size());

		//
		// If there is more data to be read go on reading it from IIS server.
		//
		if(pContext->Buffer->size() < pECB->cbTotalBytes)
		{
			ReadSize = AdjustBuffer(pContext,pECB);

			//
			// Fire off another call to perform an asynchronus read from the client.
			//
			DWORD dwFlags = HSE_IO_ASYNC;
			BOOL fRes = pECB->ServerSupportFunction(
								pECB->ConnID,
								HSE_REQ_ASYNC_READ_CLIENT,
								(LPVOID)pContext->Buffer->end(),
								&ReadSize,
								&dwFlags
								);
			if(!fRes)
			{
				TrERROR(NETWORKING, "Failure re-calling asynchronous read request.");
				throw exception();
			}
			return;
		}

		BOOL fRes = HandleEndOfRead(pContext,
	                                pECB
								   );
		if(!fRes)
		{
			TrERROR(NETWORKING,"Failure sending response.");
			throw exception();
		}
			
		cleanUp(pContext,pECB);

	}
	catch(const exception&)
	{
		SendResponse(pECB,
					 HTTP_STATUS_SERVER_ERROR_STR,
					 FALSE
					 );
	
        cleanUp(pContext,pECB);	

	}

    return;
}


static
void
AppendVariable(
	EXTENSION_CONTROL_BLOCK* pECB,
	const char* VariableName,
	CPreAllocatedResizeBuffer<char>& Buffer
	)
{
	LPVOID pBuffer = Buffer.begin() + Buffer.size();
	DWORD BufferSize = numeric_cast<DWORD>(Buffer.capacity() - Buffer.size());

	BOOL fResult = pECB->GetServerVariable(
							pECB->ConnID,
							(LPSTR) VariableName,
							pBuffer,
							&BufferSize
							);
	if(fResult)
	{
		Buffer.resize(Buffer.size() + BufferSize - 1);
		return;
	}

	if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		throw exception("GetServerVariable() failed, in AppendVariable()");
	}
	
	Buffer.reserve(Buffer.capacity() * 2);
	AppendVariable(pECB, VariableName, Buffer);
}


static
void
GetHTTPHeader(
	EXTENSION_CONTROL_BLOCK* pECB,
	CPreAllocatedResizeBuffer<char>& Buffer
	)
{
	UtlSprintfAppend(&Buffer, "%s ", pECB->lpszMethod);
	AppendVariable(pECB, "URL", Buffer);
	UtlSprintfAppend(&Buffer, " HTTP/1.1\r\n");
	AppendVariable(pECB, "ALL_RAW", Buffer);
	UtlSprintfAppend(&Buffer, "\r\n");
}



static
RPC_BINDING_HANDLE
LookupRPCConnectionFromCache(
	LPCSTR pszString
	)
/*++
Routine Description:
    This routine will look for any cached RPC connection corresponding to
    the given string, either NONCLUSTERQM, or IP address in the form of
    xx.xx.xx.xx

Arguments:
    pszString - pointer to entry name for lookup
	
Returned Value:
    RPC_BINDING_HANDLE - handle of the RPC connection

--*/
{
    ASSERT(pszString);
	CSR lock(s_rwlockRpcTable);

    HOSTIP2RPCTABLE::iterator RPCIterator = s_RPCTable.find(pszString);
    if(RPCIterator  != s_RPCTable.end())
    {
        TrTRACE(NETWORKING, "Found cached RPC Connection for %s", pszString);
        return RPCIterator->second;
    }

    return NULL;
}


static
LPWSTR
GetNetBiosNameFromIPAddr(
	LPCSTR pszIPAddress
	)
/*++
Routine Description:
    This routine will resolve the Netbios name from the give IP address
    in the form of xx.xx.xx.xx

Arguments:
    pszIPAddress - pointer to entry name for lookup
	
Returned Value:
    LPWSTR  - pointer to the unicode netbios name

Remark:
    Caller need to free the memory on the return pointer after finish with it.

--*/
{
    ASSERT(pszIPAddress);

    unsigned long ulNetAddr = inet_addr(pszIPAddress);
    HOSTENT* pHostInfo = gethostbyaddr((char *)&ulNetAddr, sizeof(ulNetAddr), AF_INET);

    if(!pHostInfo)
    {
        TrERROR(NETWORKING,"gethostbyaddr failed with error = 0x%x", WSAGetLastError());
        return NULL;
    }

    TrTRACE(NETWORKING," pHostInfo->h_name = <%s>", pHostInfo->h_name);

    WCHAR wszDNSComputerName[DNS_MAX_NAME_LENGTH + 1];

    int nNameSize= MultiByteToWideChar(
    								CP_ACP,
									0,
									pHostInfo->h_name,
									-1,
									wszDNSComputerName,
									TABLE_SIZE(wszDNSComputerName)
									);

     ASSERT(nNameSize <= TABLE_SIZE(wszDNSComputerName));

     //
     // Check for failure
     // if the return size is 0
     //
     if(nNameSize == 0)
     {
        TrERROR(NETWORKING, "Failed to convert to unicode charater, Error = 0x%x", GetLastError());
        return NULL;
     }

	 TrTRACE(NETWORKING, "wszDNSComputerName = <%S>",wszDNSComputerName);

     AP<WCHAR> wszComputerNetBiosName = new WCHAR[MAX_COMPUTERNAME_LENGTH+1];
     DWORD dwNameSize=MAX_COMPUTERNAME_LENGTH;

     BOOL fSucc = DnsHostnameToComputerName(
     	                           wszDNSComputerName,              // DNS name
                                   wszComputerNetBiosName,          // name buffer
                                   &dwNameSize
                                   );
     if(!fSucc)
     {
        TrERROR(NETWORKING, "Failed to get the NetBios name from the DNS name, error = 0x%x", GetLastError());
        return NULL;
     }

     ASSERT(dwNameSize <= MAX_COMPUTERNAME_LENGTH);
     TrTRACE(NETWORKING, "Convert to NetBiosName = %S",wszComputerNetBiosName);

     return wszComputerNetBiosName.detach();
}


static
RPC_BINDING_HANDLE
CreateLocalRPCConnection2QM(
	LPCWSTR  pwszMachineName
	)
/*++
Routine Description:
    This routine creates an Local RPC connection to Local QM.


Arguments:
    pwszMachineName - machine NetBios Name
                      If pwszMachine name is NULL, create an RPC connection to the local machine.
	
Returned Value:
    RPC_BINDING_HANDLE  - RPC binding handle

--*/
{
    WCHAR wszTempComputerName[MAX_COMPUTERNAME_LENGTH+1];
	LPWSTR	pwszComputerName = NULL;

    //
    // The name is always lower case
    // Copy it locally to wszTempComputerName
    //
    if(pwszMachineName)
    {
        ASSERT( lstrlen(pwszMachineName) <= MAX_COMPUTERNAME_LENGTH );
        wcsncpy(wszTempComputerName, const_cast<LPWSTR>(pwszMachineName),MAX_COMPUTERNAME_LENGTH+1);
        wszTempComputerName[MAX_COMPUTERNAME_LENGTH] = L'\0';
		CharLower(wszTempComputerName);
		pwszComputerName = wszTempComputerName;
    }


    READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);

    //
    // Generate RPC endpoint using local machine name
    //
    AP<WCHAR> QmLocalEp;
    ComposeRPCEndPointName(wzEndpoint, pwszComputerName, &QmLocalEp);

    TrTRACE(NETWORKING, "The QM RPC Endpoint name = <%S>",QmLocalEp);

    LPWSTR pszStringBinding=NULL;
    RPC_STATUS status  = RpcStringBindingCompose( NULL,		            //unsigned char *ObjUuid
                                                  RPC_LOCAL_PROTOCOL,	//unsigned char *ProtSeq
                                                  NULL,					//unsigned char *NetworkAddr
                                                  QmLocalEp,			//unsigned char *EndPoint
                                                  NULL,					//unsigned char *Options
                                                  &pszStringBinding);   //unsigned char **StringBinding


    if (status != RPC_S_OK)
    {
        TrERROR(NETWORKING, "RpcStringBindingCompose failed with error = 0x%x", status);
        throw exception();
    }

    RPC_BINDING_HANDLE hRPC;

    status = RpcBindingFromStringBinding(   pszStringBinding,	 //unsigned char *StringBinding
                                            &hRPC);	            //RPC_BINDING_HANDLE *Binding

    if(pszStringBinding)
        RpcStringFree(&pszStringBinding);

    if (status != RPC_S_OK)
    {
        TrERROR(NETWORKING, "RpcBindingFromStringBinding failed with error = 0x%x", status);
	    throw exception();
    }

    //
    // Windows bug 607793
    // add mutual authentication with local msmq service.
    //
    status = MQSec_SetLocalRpcMutualAuth(&hRPC) ;

    if (status != RPC_S_OK)
    {
        mqrpcUnbindQMService( &hRPC, &pszStringBinding );

        hRPC = NULL ;
        pszStringBinding = NULL ;

        throw exception();
    }

    return hRPC;
}



static
LPSTR
RPCToServer(
	EXTENSION_CONTROL_BLOCK *pECB,
	LPCSTR Headers,
	size_t BufferSize,
	PBYTE Buffer
	)
{
    char szDestinationAddr[MAX_PATH] = "NONCLUSTERQM";

    if(IsLocalSystemCluster())
    {
    	DWORD dwBufLen = TABLE_SIZE(szDestinationAddr);

        BOOL fSuccess = pECB->GetServerVariable(
        								pECB->ConnID,
	               		                "LOCAL_ADDR",
		            			        szDestinationAddr,
                               			&dwBufLen
                               			);

        ASSERT(dwBufLen <= TABLE_SIZE(szDestinationAddr));
        if(!fSuccess)
        {
	        TrERROR(NETWORKING, "GetServerVariable(LOCAL_ADDR) failed, GetLastError() = 0x%x", GetLastError());
	        return NULL;
	    }
    }

    TrTRACE(NETWORKING, "Destination address is <%s>", szDestinationAddr);

    //
    // At most call the server twice
    // to handle the case where the cache RPC connection to
    // MSMQ Queue Manager is invalid, e.g. Restart QM or failover and failback.
    //
    for(int i=0; i <= 1; i++)
    {
        handle_t hBind = GetLocalRPCConnection2QM(szDestinationAddr);
        
        RpcTryExcept  
    	{
	    	return R_ProcessHTTPRequest(hBind, Headers, static_cast<DWORD>(BufferSize), Buffer);
	    }
	    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()) )
	    {
	    	DWORD gle = RpcExceptionCode();
	        PRODUCE_RPC_ERROR_TRACING;
      	    TrERROR(NETWORKING, "RPC call R_ProcessHTTPRequest failed, error code = %!winerr!", gle);
	    }
        RpcEndExcept

        //
        // If fails, remove the RPC cache and try one more time
        //
        RemoveRPCCacheEntry(szDestinationAddr);
    }

    //
    // Don't throw exception, but ask the caller to
    // remove the RPC connection cache
    //
    return NULL;
}


static
RPC_BINDING_HANDLE
GetLocalRPCConnection2QM(
	LPCSTR  pszEntry
	)
/*++
Routine Description:
	Get the RPC connection to the local MSMQ QM (Either Cache RPC or create a new RPC connection).

Arguments:
	pszEntry -  pointer to the string in the following form
                NONCLUSTERQM    - running in a non-clustering environment
                xxx.xxx.xxx.xxx - IP address of the target machine

Returned Value:
	RPC_BINDING_HANDLE  - RPC handle

--*/
{
    ASSERT(pszEntry);

    RPC_BINDING_HANDLE hRPC = LookupRPCConnectionFromCache(pszEntry);

    if(hRPC)
        return hRPC;

    AP<WCHAR>  pwszNetBiosName;

    //
    // If this is a cluster environment,
    // use the IP to find the target machine netbios name
    //
    if(IsLocalSystemCluster())
    {
        pwszNetBiosName = GetNetBiosNameFromIPAddr(pszEntry);
        if(!pwszNetBiosName)
            return NULL;
    }

    hRPC = CreateLocalRPCConnection2QM(pwszNetBiosName);
	
    if(hRPC)
    {
    	CSW lock(s_rwlockRpcTable);
        s_RPCTable[pszEntry] = hRPC;
    }

	return hRPC;

}


static
void
RemoveRPCCacheEntry(
	char *pszEntry
	)
/*++
Routine Description:
	Remove RPC cache from the cache table.

Arguments:
	pszEntry -  pointer to the string in the following form
                NONCLUSTERQM    - running in a non-clustering environment
                xxx.xxx.xxx.xxx - IP address of the target machine

Returned Value:
	None

--*/
{

    ASSERT(pszEntry);
	CSW lock(s_rwlockRpcTable);
	
    HOSTIP2RPCTABLE::iterator RPCIterator = s_RPCTable.find(pszEntry);
    if(RPCIterator != s_RPCTable.end())
    {
        FreeRpcBindHandle(RPCIterator->second);
        s_RPCTable.erase(RPCIterator);
    }
}


static
BOOL
SendResponse(
	EXTENSION_CONTROL_BLOCK* pECB,
	LPCSTR szStatus,
	BOOL fKeepConn
	)
{
	//
	//  Populate SendHeaderExInfo struct
	//

	HSE_SEND_HEADER_EX_INFO  SendHeaderExInfo;

	LPCSTR szHeader = "Content-Length: 0\r\n\r\n";

	SendHeaderExInfo.pszStatus = szStatus;
	SendHeaderExInfo.cchStatus = strlen(szStatus);
	SendHeaderExInfo.pszHeader = szHeader;
	SendHeaderExInfo.cchHeader = strlen(szHeader);
	SendHeaderExInfo.fKeepConn = fKeepConn;

	return pECB->ServerSupportFunction(
					pECB->ConnID,						    //HCONN ConnID
					HSE_REQ_SEND_RESPONSE_HEADER_EX,	   //DWORD dwHSERRequest
					&SendHeaderExInfo,					  //LPVOID lpvBuffer
					NULL,								 //LPDWORD lpdwSize
					NULL);								//LPDWORD lpdwDataType
}


static
void
GetPhysicalDirectoryName(
	EXTENSION_CONTROL_BLOCK* pECB,
	LPSTR pPhysicalDirectoryName,
	DWORD BufferLen
	)
/*++
Routine Description:
	Get Physical Directory Name.
	In case of failure throw bad_win32_error.

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK
	pPhysicalDirectoryName - PhysicalDirectory buffer to be filled
	BufferLen - PhysicalDirectory buffer length

Returned Value:
	Physical Directory Name unicode string

--*/
{
	//
	// ISSUE-2001/05/23-ilanh
	// using APPL_PHYSICAL_PATH is expensive compare to APPL_MD_PATH.
	//
	// Get Physical Directory Name (ansi)
	//
    DWORD dwBufLen = BufferLen;
    BOOL fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"APPL_PHYSICAL_PATH",
						pPhysicalDirectoryName,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "GetServerVariable(APPL_PHYSICAL_PATH) failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
	}

	ASSERT(dwBufLen <= BufferLen);

	TrTRACE(NETWORKING, "APPL_PHYSICAL_PATH = %hs", pPhysicalDirectoryName);
}


static
bool
IsHttps(
	EXTENSION_CONTROL_BLOCK* pECB
	)
/*++
Routine Description:
	Check if the request arrived from https port or http port.

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK

Returned Value:
	true if https port, false otherwise

--*/
{
	char Answer[100];
    DWORD dwBufLen = sizeof(Answer);
    BOOL fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"HTTPS",
						Answer,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "GetServerVariable(HTTPS) failed, gle = 0x%x", gle);
		return false;
	}

	ASSERT(dwBufLen <= sizeof(Answer));

	if(_stricmp(Answer, "on") == 0)
	{
		TrTRACE(NETWORKING, "https request");
		return true;
	}

	TrTRACE(NETWORKING, "http request");
	return false;
}


static
void
TraceAuthInfo(
	EXTENSION_CONTROL_BLOCK* pECB
	)
/*++
Routine Description:
	Trace authentication information.
	AUTH_TYPE, AUTH_USER

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK

Returned Value:
	None

--*/
{
	char AuthType[100];
    DWORD dwBufLen = TABLE_SIZE(AuthType);

    BOOL fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"AUTH_TYPE",
						AuthType,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "GetServerVariable(AUTH_TYPE) failed, gle = 0x%x", gle);
		return;
	}

	ASSERT(dwBufLen <= TABLE_SIZE(AuthType));

	char AuthUser[MAX_PATH];
    dwBufLen = TABLE_SIZE(AuthUser);

    fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"AUTH_USER",
						AuthUser,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "GetServerVariable(AUTH_USER) failed, gle = 0x%x", gle);
		return;
	}

	ASSERT(dwBufLen <= TABLE_SIZE(AuthUser));

	TrTRACE(NETWORKING, "AUTH_USER = %hs, AUTH_TYPE = %hs", AuthUser, AuthType);
}


static
void
GetDirectorySecurityDescriptor(
	LPSTR DirectoryName,
	CAutoLocalFreePtr& pSD
	)
/*++
Routine Description:
	Get the security descriptor for the directory.
	In case of failure throw bad_win32_error.

Arguments:
	DirectoryName - Directoy name
	pSD - [out] auto free pointer to the security descriptor
Returned Value:
	None

--*/
{
    PACL pDacl = NULL;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;

    SECURITY_INFORMATION  SeInfo = OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION;

    //
    // Obtain owner and present DACL.
    //
    DWORD rc = GetNamedSecurityInfoA(
						DirectoryName,
						SE_FILE_OBJECT,
						SeInfo,
						&pOwnerSid,
						&pGroupSid,
						&pDacl,
						NULL,
						reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pSD)
						);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(NETWORKING, "GetNamedSecurityInfo failed, rc = 0x%x", rc);
		throw bad_win32_error(rc);
    }

	ASSERT((pSD != NULL) && IsValidSecurityDescriptor(pSD));
	ASSERT((pOwnerSid != NULL) && IsValidSid(pOwnerSid));
	ASSERT((pGroupSid != NULL) && IsValidSid(pGroupSid));
	ASSERT((pDacl != NULL) && IsValidAcl(pDacl));
}


static
void
GetThreadToken(
	CHandle& hAccessToken
	)
/*++
Routine Description:
	Get thread token.
	In case of failure throw bad_win32_error.

Arguments:
	hAccessToken - auto close handle

Returned Value:
	None

--*/
{
   if (!OpenThreadToken(
			GetCurrentThread(),
			TOKEN_QUERY,
			TRUE,  // OpenAsSelf
			&hAccessToken
			))
    {
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "OpenThreadToken failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
    }
}


static GENERIC_MAPPING s_FileGenericMapping = {
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};

static
void
VerifyWritePermission(
    PSECURITY_DESCRIPTOR pSD,
	HANDLE hAccessToken
	)
/*++
Routine Description:
	Verify if the thread has write file permissions.
	In case of failure or access denied throw bad_win32_error.

Arguments:
	pSD - PSECURITY_DESCRIPTOR
	hAccessToken - Thread Access Token

Returned Value:
	None

--*/
{
	//
	// Access Check for Write File
	//
    DWORD dwDesiredAccess = ACTRL_FILE_WRITE;
    DWORD dwGrantedAccess = 0;
    BOOL  fAccessStatus = FALSE;

    char ps_buff[sizeof(PRIVILEGE_SET) + ((2 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))];
    PPRIVILEGE_SET ps = reinterpret_cast<PPRIVILEGE_SET>(ps_buff);
    DWORD dwPrivilegeSetLength = sizeof(ps_buff);

    BOOL fSuccess = AccessCheck(
							pSD,
							hAccessToken,
							dwDesiredAccess,
							&s_FileGenericMapping,
							ps,
							&dwPrivilegeSetLength,
							&dwGrantedAccess,
							&fAccessStatus
							);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(NETWORKING, "AccessCheck failed, gle = 0x%x, status = %d", gle, fAccessStatus);
		throw bad_win32_error(gle);
	}

	if(!AreAllAccessesGranted(dwGrantedAccess, dwDesiredAccess))
	{
		TrERROR(NETWORKING, "Access was denied, desired access = 0x%x, grant access = 0x%x", dwDesiredAccess, dwGrantedAccess);
		throw bad_win32_error(ERROR_ACCESS_DENIED);
	}
}


static
void
CheckAccessAllowed(
	EXTENSION_CONTROL_BLOCK* pECB
	)
/*++
Routine Description:
	Check if the thread user has write file permission to the
	Physical Directory.
	normal termination means the user have permissions.
	In case of failure or access denied throw bad_win32_error.

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK

Returned Value:
	None

--*/
{
	if(WPP_LEVEL_COMPID_ENABLED(rsTrace, NETWORKING))
	{
		WCHAR  UserName[1000];
		DWORD size = TABLE_SIZE(UserName);
		BOOL fRes  = GetUserName(UserName,  &size);
		if(fRes)
		{

		   TrTRACE(NETWORKING, "the user for the currect request = %ls", UserName);
		}
	    TraceAuthInfo(pECB);
	}

	char pPhysicalDirectoryName[MAX_PATH];
	GetPhysicalDirectoryName(pECB, pPhysicalDirectoryName, MAX_PATH);

	//
	// ISSUE-2001/05/22-ilanh reading the Security Descriptor everytime
	// Should consider cache it for Physical Directory name and refresh it from time to time
	// or when getting notifications of Physical Directory changes.
	//
	CAutoLocalFreePtr pSD;
	GetDirectorySecurityDescriptor(pPhysicalDirectoryName, pSD);

	//
	// Get access Token
	//
	CHandle hAccessToken;
	GetThreadToken(hAccessToken);

	VerifyWritePermission(pSD, hAccessToken);
}

	
DWORD
WINAPI
HttpExtensionProc(
	EXTENSION_CONTROL_BLOCK *pECB
	)
/*++
Routine Description:
    Main extension routine.

Arguments:
    Control block generated by IIS.

Returned Value:
    Status code
--*/
{
	if(IsHttps(pECB))
	{
		try
		{
			//
			// For https perform access check on the physical directory.
			//
			CheckAccessAllowed(pECB);
			TrTRACE(NETWORKING, "Access granted");
		}
		catch (const bad_win32_error& e)
		{
			if(WPP_LEVEL_COMPID_ENABLED(rsError, NETWORKING))
			{
				WCHAR  UserName[1000];
				DWORD size = TABLE_SIZE(UserName);
				BOOL fRes = GetUserName(UserName,  &size);
				if(fRes)
				{
				    TrERROR(NETWORKING, "user = %ls denied access, bad_win32_error exception, error = 0x%x", UserName, e.error());
				}
			}

			if(!SendResponse(pECB, HTTP_STATUS_DENIED_STR, FALSE))
				return HSE_STATUS_ERROR;

			return HSE_STATUS_SUCCESS;
		}
	}

	try
	{
        if(pECB->cbTotalBytes > xHTTPBodySizeMaxValue)
	    {
		    //
			// Requested HTTPBody is greater than the maximum allowed 10MB
			//
			TrERROR(NETWORKING, "Requested HTTP Body %d is greater than the maximum buffer allowed %d", pECB->cbTotalBytes, xHTTPBodySizeMaxValue);
			throw exception("Requested HTTP Body is greater than xHTTPBodySizeMaxValue");
		}
		
		DWORD dwFlags;
		P<Context> pContext = new Context();

		GetHTTPHeader(pECB, *pContext->Headers.get());
        pContext->Buffer = pContext->csBuffer.get();		   	
		pContext->Buffer->append(pECB->lpbData, pECB->cbAvailable);

		ASSERT(pECB->cbTotalBytes >= pContext->Buffer->size());
		//
		// If there is more data to be read go on reading it from IIS server.
		//
		if(pContext->Buffer->size() < pECB->cbTotalBytes)
		{
			
			//
			// Read another message body chunk. usually ~2KB long
			// NOTE:For information regarding interaction with IIS,refer to:
			// mk:@MSITStore:\\hai-dds-01\msdn\MSDN\IISRef.chm::/asp/isre235g.htm
			//

            BOOL fRes = pECB->ServerSupportFunction(pECB->ConnID,
													HSE_REQ_IO_COMPLETION,
													GetHttpBody,
													0,
													(LPDWORD)pContext.get()
													);
			if(!fRes)
			{
				TrERROR(NETWORKING, "Failure to initialize completion function.");
				throw exception();
			}

		    DWORD ReadSize = AdjustBuffer(pContext,pECB);
			dwFlags = HSE_IO_ASYNC;
			fRes = pECB->ServerSupportFunction(pECB->ConnID,
											   HSE_REQ_ASYNC_READ_CLIENT,
											   (LPVOID)pContext->Buffer->end(),
											   &ReadSize,
											   &dwFlags
											   );
			if(!fRes)
			{
				TrERROR(NETWORKING, "Failure submittimg asynchronous read request.");
				throw exception();
			}

			//
			// ReadSize now holds number of bytes actually read.
			//

			//
			//Informing IIS that we're not done with current request session.\
			//
			pContext.detach();
			return HSE_STATUS_PENDING;
		}

		//
		// We've read all there is to read
		//
		BOOL fRes = HandleEndOfRead(pContext,
	                                pECB
								   );
		if(!fRes)
		{
			return HSE_STATUS_ERROR;
		}
	}
	catch(const exception&)
	{
			if(!SendResponse(pECB, HTTP_STATUS_SERVER_ERROR_STR, FALSE))
			{
				return HSE_STATUS_ERROR;
			}
	}
	
	return HSE_STATUS_SUCCESS;
}


BOOL WINAPI DllMain(HMODULE /*hMod*/, DWORD Reason, LPVOID /*pReserved*/)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");
            break;

        case DLL_THREAD_ATTACH:
			 break;

        case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return TRUE;
}


//
//-------------- MIDL allocate and free implementations ----------------
//


extern "C" void __RPC_FAR* __RPC_USER midl_user_allocate(size_t len)
{
	#pragma PUSH_NEW
	#undef new

	return new_nothrow char[len];

	#pragma POP_NEW
}


extern "C" void __RPC_USER midl_user_free(void __RPC_FAR* ptr)
{
    delete [] ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqise\test\rpcserver.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    RPCServer.cpp

Abstract:
    MSMQ ISAPI extension Server

	Acts as an RPC server for the MSMQ ISAPI extension.
	You can use it for debugging, instead of the QM RPC server.
	It dumps all request forwarded by the extension, to the console.

	Simply execute it.

Author:
    Nir Aides (niraides) 03-May-2000

--*/



#include "stdh.h"

#include "ise2qm.h"
#include <new>
#include <_mqini.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include "_registr.h"
#include "_mqrpc.h"


 
LPCSTR HTTP_STATUS_OK_STR = "200 OK";



LPSTR
R_ProcessHTTPRequest(
	handle_t /* hBind */,
    /* [in] */ LPCSTR Headers,
    DWORD BufferSize,
    /* [size_is][in] */ BYTE __RPC_FAR Buffer[  ])
{
	printf("<HEADERS>%s</HEADERS>\n",Headers);
	printf("<BUFFER_SIZE>%d</BUFFER_SIZE>", BufferSize);
	printf("<BUFFER>%.*s</BUFFER>", BufferSize, (char*)Buffer);

	DWORD size = strlen(HTTP_STATUS_OK_STR) + 1;
	LPSTR Status = (char*)midl_user_allocate(size);
	if(Status == NULL)
	{
		printf("R_ProcessHTTPRequest() Failed memory allocation.\n");
		throw std::bad_alloc();
	}

	strncpy(Status, HTTP_STATUS_OK_STR, size);

	Sleep(30);

	return Status;
}



INT __cdecl main()
{
    RPC_STATUS status = RPC_S_OK;

    unsigned int cMinCalls = 1;
    unsigned int cMaxCalls = 20;
    unsigned int fDontWait = FALSE;
 
    AP<WCHAR> QmLocalEp;
    READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);

    // 
    // Generate RPC endpoint using local machine name
    //
    ComposeRPCEndPointName(wzEndpoint, NULL, &QmLocalEp);

    status = RpcServerUseProtseqEp(
				RPC_LOCAL_PROTOCOL,		   //unsigned char *Protseq
                cMaxCalls,				  //unsigned int MaxCalls
                QmLocalEp,				 //unsigned char *Endpoint
                NULL);					//void *SecurityDescriptor
 
    if(status != RPC_S_OK) 
    {
        return status;
    }
 
    status = RpcServerRegisterIf2(
				ISE2QM_v1_0_s_ifspec,		      //RPC_IF_HANDLE IfSpec 
                NULL,							     //UUID *MgrTypeUuid   
                NULL,							    //RPC_MGR_EPV *MgrEpv 
				0,								   //unsigned int Flags
				RPC_C_PROTSEQ_MAX_REQS_DEFAULT,	  //unsigned int MaxCalls
				(unsigned int) -1,				 //unsigned int MaxRpcSize
				NULL							//RPC_IF_CALLBACK_FN *IfCallbackFn
				);
 
    if(status != RPC_S_OK) 
    {
        return status;
    }
 
    status = RpcServerListen(
				cMinCalls,	  //unsigned int MinimumCallThreads
				cMaxCalls,	 //unsigned int MaxCalls
                fDontWait);	//unsigned int DontWait
 
    if(status != RPC_S_OK) 
    {
        return status;
    }
 
   status = RpcMgmtStopServerListening(NULL);
 
    if (status != RPC_S_OK) 
    {
       exit(status);
    }
 
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
 
    if (status != RPC_S_OK) 
    {
       exit(status);
    }

	return RPC_S_OK;
}
 


//
//-------------- MIDL allocate and free implementations ----------------
//

void __RPC_FAR* __RPC_USER midl_user_allocate(size_t len)
{
    return malloc(len);
}
 


void __RPC_USER midl_user_free(void __RPC_FAR* ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqperf\perfcomn.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    perfcomn.cpp

Abstract:

    Defines common functions between the performance DLL and the performance application.

Prototype : perfctr.h

Author:

    Gadi Ittah (t-gadii)

--*/


#include "stdh.h"
#include <winperf.h>
#include "perfctr.h"
#include <align.h>




/*====================================================

MapObjects 

Description :Maps objects on to shared memory.
			 The functions updateds the objects postion in the pObjectDefs array

Arguments:
		   BYTE * pSharedMemBase 		 - pointer to start of shared memory 	   
		   DWORD dwObjectCount 	 		 - number of objects
		   PerfObjectDef * pObjects 	 - pointer to object array
		   PerfObjectInfo * pObjectDefs) - pointer to object defeinitions array

Return Value: void

=====================================================*/

void MapObjects (BYTE * pSharedMemBase,DWORD dwObjectCount,PerfObjectDef * pObjects,PerfObjectInfo * pObjectDefs)
{
	DWORD dwMemSize = 0;	

	for (unsigned i=0;i<dwObjectCount;i++)
	{
		//
        // Align object on pointer boundaries to avoid alignment faults.
        //
        pSharedMemBase = (BYTE*)ROUND_UP_POINTER(pSharedMemBase + dwMemSize, ALIGN_LPVOID);

		pObjectDefs[i].pSharedMem = pSharedMemBase;
		pObjectDefs[i].dwNumOfInstances =0;

		// calc postion of next object
		dwMemSize = pObjects[i].dwMaxInstances*INSTANCE_SIZE(pObjects[i].dwNumOfCounters)+OBJECT_DEFINITION_SIZE(pObjects[i].dwNumOfCounters);

		// if this object dosn't have instances then it has a counter block
		if (pObjects[i].dwMaxInstances == 0)
			dwMemSize += COUNTER_BLOCK_SIZE(pObjects[i].dwNumOfCounters);		
	
	}
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqperf\perfexpr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name     :perfexpr.c



Abstract        :Defines the DLL's exportable functions. These functions are called by the registery when the
             performance moniter requests.



Prototype       :

Author:

    Gadi Ittah (t-gadii)

--*/


//
//  Include Files
//


#include "stdh.h"
#include <string.h>
#include <string>
#include <winperf.h>
#include "perfutil.h"
#include "perfdata.h"
typedef LONG HRESULT;
#include "_registr.h"


// The follwoing global variables must be setup in this header file
PerfObjectDef * pObjects        = ObjectArray;  // A pointer to the objects array
WCHAR g_szPerfApp[128];
                                            // written in the registery


PerfObjectInfo * pObjectDefs = NULL;
HANDLE hSharedMem;
BYTE * pSharedMemBase;
BOOL   fInitOK = FALSE;

DWORD dwOpenCount;
#define DECL_C extern "C"

/*====================================================

PerfOpen

Routine Description:

    This routine will open and map the memory used by the application to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (the application)

Return Value:

    None.

=====================================================*/

DECL_C DWORD APIENTRY
    PerfOpen(
    LPWSTR
    )

/*++


--*/

{
    LONG status;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {

        pObjectDefs = new PerfObjectInfo [dwPerfObjectsCount];

		WCHAR ComputerName[MAX_PATH];
		DWORD length = TABLE_SIZE(ComputerName);
		BOOL fRes = GetComputerName(ComputerName, &length);
		if(!fRes)
		{
			status = GetLastError(); // return error
			goto OpenExitPoint;
		}

		std::wstring ObjectName = L"Global\\MSMQ";
		ObjectName += ComputerName;

        hSharedMem = OpenFileMapping(FILE_MAP_READ,FALSE, ObjectName.c_str());


    if (hSharedMem == NULL)
    {
        //
        // Bug Bug Error should be written to event log
        //

        // this is fatal, if we can't get data then there's no
        // point in continuing.
        status = GetLastError(); // return error
        goto OpenExitPoint;
    }


        //
        // Map the shared memory
        //
        pSharedMemBase = (PBYTE)MapViewOfFile(hSharedMem,FILE_MAP_READ,0,0,0);

        if (!pSharedMemBase)
    {
        //
        // Bug Bug Error should be written to event log
        //


        // this is fatal, if we can't get data then there's no
        // point in continuing.
        status = GetLastError(); // return error
        goto OpenExitPoint;
    }

        MapObjects (pSharedMemBase,dwPerfObjectsCount,pObjects,pObjectDefs);

    fInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}



/*====================================================



Description :helper function for copying an object to the performance monitors buuffer


Arguments       :
                IN      PPERF_OBJECT_TYPE pPerfObject - Pointer to object to copy
                IN OUT  PVOID & pDestBuffer     - Pointer to destination buffer returns the address of
                                              the destination for the next object to place in buffer.
                IN      long maxInstances       - The maximum number of instances the object has

Return Value:

=====================================================*/



DWORD CopyObjectToBuffer (IN PPERF_OBJECT_TYPE pPerfObject,IN OUT PVOID & pDestBuffer,IN long maxInstances,IN DWORD dwSpaceLeft)
{
    //
    // if GetCounters hasn't been called for the object then it isn't valid yet
    //

    if (pPerfObject->TotalByteLength == PERF_INVALID)
      return 0;

    PVOID pSourceBuffer;

    PPERF_OBJECT_TYPE pDestObject = (PPERF_OBJECT_TYPE)pDestBuffer;

    pSourceBuffer = (PVOID)pPerfObject;

    DWORD dwBytesToCopy = OBJECT_DEFINITION_SIZE(pPerfObject->NumCounters);

    if(dwSpaceLeft<dwBytesToCopy)
    {
        return (DWORD)-1;
    }

    dwSpaceLeft-=dwBytesToCopy;

    //
    // copy object defeinitions
    //
    memcpy (pDestBuffer,pSourceBuffer,dwBytesToCopy);
    pDestObject->TotalByteLength =dwBytesToCopy;

    pDestObject->NumInstances = 0;

    pSourceBuffer = (BYTE *) pSourceBuffer+dwBytesToCopy;
    pDestBuffer=(BYTE *)pDestBuffer+dwBytesToCopy;

    //
    //check all of objects possibale insatances and copy the valid ones to the dest buffer
    //

    for (LONG j=0;j<maxInstances;j++)
    {

        dwBytesToCopy = INSTANCE_SIZE(pPerfObject->NumCounters);

        //
        // We copy each instance that is valid
        //

        if (*(DWORD*)pSourceBuffer == PERF_VALID)
        {

            if(dwSpaceLeft<dwBytesToCopy)
            return (DWORD)-1;
            dwSpaceLeft-=dwBytesToCopy;

            memcpy(pDestBuffer,pSourceBuffer,dwBytesToCopy);

            ((PPERF_INSTANCE_DEFINITION)pDestBuffer)->ByteLength = INSTANCE_NAME_LEN_IN_BYTES+sizeof(PERF_INSTANCE_DEFINITION);
            pDestBuffer=(BYTE*)pDestBuffer+dwBytesToCopy;
            pDestObject->NumInstances++;
            pDestObject->TotalByteLength +=dwBytesToCopy;
        }
        pSourceBuffer=(BYTE*)pSourceBuffer+dwBytesToCopy;
    }


    if (pDestObject->NumInstances == 0)
    {

        //
        // If the object has no instances the standart is top place -1 in the NumIstances field
        //
        pDestObject->NumInstances = -1;


        //
        // if there are no instances we just follow the object with a PERF_COUNTER_BLOCK
        // and the data for the counters
        //

        dwBytesToCopy = COUNTER_BLOCK_SIZE(pPerfObject->NumCounters);

        if(dwSpaceLeft<dwBytesToCopy)
        {
            return (DWORD)-1;
        }

        dwSpaceLeft-=dwBytesToCopy;

        memcpy(pDestBuffer,pSourceBuffer,dwBytesToCopy);

        pDestBuffer     =(BYTE*)pDestBuffer+dwBytesToCopy;
        pSourceBuffer   =(BYTE*)pSourceBuffer+dwBytesToCopy;
        pDestObject->TotalByteLength +=dwBytesToCopy;
    }

	DWORD Padding = ROUND_UP_COUNT(pDestObject->TotalByteLength, ALIGN_QUAD) - pDestObject->TotalByteLength; 

	if(dwSpaceLeft < Padding)
		return (DWORD)-1;

	dwSpaceLeft -= Padding;
	pDestBuffer = (BYTE*)pDestBuffer + Padding;
	pDestObject->TotalByteLength += Padding;

    return pDestObject->TotalByteLength;
}



/*++

Routine Description:

    This routine will return the data for the counters.

Arguments:

   IN       LPWSTR   lpValueName
     pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
     IN: pointer to the address of the buffer to receive the completed
        PerfDataBlock and subordinate structures. This routine will
        append its data to the buffer starting at the point referenced
        by *lppData.
     OUT: points to the first byte after the data structure added by this
        routine. This routine updated the value at lppdata after appending
        its data.

   IN OUT   LPDWORD  lpcbTotalBytes
     IN: the address of the DWORD that tells the size in bytes of the
        buffer referenced by the lppData argument
     OUT: the number of bytes added by this routine is written to the
        DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
     IN: the address of the DWORD to receive the number of objects added
        by this routine
     OUT: the number of objects added by this routine is written to the
        DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
     any error conditions encountered are reported to the event log if
     event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
     also reported to the event log.
--*/


DECL_C DWORD APIENTRY
    PerfCollect(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)

{

    PVOID   pDestBuffer;// pointer used when copying the data structers to the buffer
    DWORD   i                  ;// loop control variable
    //
    // before doing anything else, see if data is valid Open went OK
    //
    if (!fInitOK)
    {
        //
        // unable to continue because open failed.
        //
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //

    DWORD dwQueryType;

    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        //
        // this routine does not service requests for data from
        // Non-NT computers
        //
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }


    DWORD dwSpaceNeeded = 0;

    //
    // Session and DS perf objects are not always mapped
    //
    DWORD dwMappedObjects = 0;

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    pDestBuffer = *lppData;


    if ((dwQueryType == QUERY_GLOBAL) || (dwQueryType == QUERY_COSTLY))
    {
    DWORD dwSpaceLeft = *lpcbTotalBytes;

    for (i=0;i<dwPerfObjectsCount;i++)
        {
            PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) pObjectDefs[i].pSharedMem;

        DWORD retVal = CopyObjectToBuffer (pPerfObject,pDestBuffer,pObjects[i].dwMaxInstances,dwSpaceLeft);

        if (retVal == (DWORD)-1)
        {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        if (retVal != 0)
        {
            //
            // Session and DS perf objects are not always mapped
            //
            ++dwMappedObjects;
        }

        dwSpaceNeeded+=retVal;
        dwSpaceLeft-=retVal;

        if ( *lpcbTotalBytes < dwSpaceNeeded )
        {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
            }
        }
    }


    if (dwQueryType == QUERY_ITEMS)
    {

        DWORD dwSpaceLeft = *lpcbTotalBytes;

        BOOL fAtLeastOne = FALSE;// a flag set to true if at least one of the objects requested
                                 // belongs to the application
        PPERF_OBJECT_TYPE pPerfObject;

        for (i=0;i<dwPerfObjectsCount;i++)
        {
            pPerfObject = (PPERF_OBJECT_TYPE) pObjectDefs[i].pSharedMem;

            if (IsNumberInUnicodeList (pPerfObject->ObjectNameTitleIndex, lpValueName))
            {
                fAtLeastOne = TRUE;

                DWORD retVal = CopyObjectToBuffer (pPerfObject,pDestBuffer,pObjects[i].dwMaxInstances,dwSpaceLeft);

                if (retVal == (DWORD)-1)
                {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    return ERROR_MORE_DATA;
                }

                if (retVal != 0)
                {
                    //
                    // Session and DS perf objects are not always mapped
                    //
                    ++dwMappedObjects;
                }

                dwSpaceNeeded+=retVal;
                dwSpaceLeft-=retVal;

                if ( *lpcbTotalBytes < dwSpaceNeeded )
                {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    return ERROR_MORE_DATA;
                }
            }
        }

        if (!fAtLeastOne)
        {
            // request received for data object not provided by this application
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }


    // update arguments for return

    *lpcbTotalBytes = DWORD_PTR_TO_DWORD((PBYTE) pDestBuffer - (PBYTE) *lppData);

    *lppData = pDestBuffer;


    *lpNumObjectTypes = dwMappedObjects;




    return ERROR_SUCCESS;
}




/*++

Routine Description:

    This routine closes the open handles to the performance counters

Arguments:

    None.

Return Value:
    ERROR_SUCCESS

--*/

DECL_C DWORD APIENTRY PerfClose()


{
    if (!(--dwOpenCount)) { // when this is the last thread...

        UnmapViewOfFile (pSharedMemBase);
    CloseHandle(hSharedMem);


        delete pObjectDefs;
        pObjectDefs = NULL;

    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqperf\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility


Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqperf\perfdata.cpp ===
//*********************************************************************
//*
//* perfdata.cpp
//*
//*********************************************************************


#include "stdh.h"
#include "perfdata.h"
#include "qmperf.h"

//
// QM General Counters
//
PerfCounterDef QMCountersArray[] =
{
    {NUMSESSIONS,				NUMSESSIONS,				0, PERF_COUNTER_RAWCOUNT},
    {NUMIPSESSIONS,				NUMIPSESSIONS,				0, PERF_COUNTER_RAWCOUNT},
	{NUM_OUTGOING_HTTP_SESSIONS,NUM_OUTGOING_HTTP_SESSIONS, 0, PERF_COUNTER_RAWCOUNT},
	{NUM_INCOMING_PGM_SESSIONS, NUM_INCOMING_PGM_SESSIONS,	0, PERF_COUNTER_RAWCOUNT},
	{NUM_OUTGOING_PGM_SESSIONS, NUM_OUTGOING_PGM_SESSIONS,	0, PERF_COUNTER_RAWCOUNT},

    {NUMINQMPACKETS,       NUMINQMPACKETS      ,0,PERF_COUNTER_COUNTER},
    {TOTALINQMPACKETS,     TOTALINQMPACKETS    ,0,PERF_COUNTER_RAWCOUNT},
    {NUMOUTQMPACKETS,      NUMOUTQMPACKETS     ,0,PERF_COUNTER_COUNTER},
    {TOTALOUTQMPACKETS,    TOTALOUTQMPACKETS   ,0,PERF_COUNTER_RAWCOUNT},

    {TOTALPACKETSINQUEUES, TOTALPACKETSINQUEUES, (DWORD)-2, PERF_COUNTER_RAWCOUNT},
    {TOTALBYTESINQUEUES,   TOTALBYTESINQUEUES  , (DWORD)-4, PERF_COUNTER_RAWCOUNT}
};


//
// Counters per active sessions
//
PerfCounterDef  SessionCountersArray[] =
{
    {NUMSESSINPACKETS,      NUMSESSINPACKETS,   0,  PERF_COUNTER_COUNTER},
    {NUMSESSOUTPACKETS,     NUMSESSOUTPACKETS,  0,  PERF_COUNTER_COUNTER},
    {NUMSESSINBYTES,        NUMSESSINBYTES,     0,  PERF_COUNTER_COUNTER},
    {NUMSESSOUTBYTES,       NUMSESSOUTBYTES,    0,  PERF_COUNTER_COUNTER},
    {TOTALSESSINPACKETS,    TOTALSESSINPACKETS, 0,  PERF_COUNTER_RAWCOUNT},
    {TOTALSESSOUTPACKETS,   TOTALSESSOUTPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {TOTALSESSINBYTES,      TOTALSESSINBYTES,   0,  PERF_COUNTER_RAWCOUNT},
    {TOTALSESSOUTBYTES,     TOTALSESSOUTBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};


//
// Counters per active sessions
//
PerfCounterDef  InHttpCountersArray[] =
{
    {IN_HTTP_NUMSESSINPACKETS,      IN_HTTP_NUMSESSINPACKETS,   0,  PERF_COUNTER_COUNTER},
    {IN_HTTP_NUMSESSINBYTES,        IN_HTTP_NUMSESSINBYTES,     0,  PERF_COUNTER_COUNTER},
    {IN_HTTP_TOTALSESSINPACKETS,    IN_HTTP_TOTALSESSINPACKETS, 0,  PERF_COUNTER_RAWCOUNT},
    {IN_HTTP_TOTALSESSINBYTES,      IN_HTTP_TOTALSESSINBYTES,   0,  PERF_COUNTER_RAWCOUNT},
};


//
// Counters per active Outgoing HTTP sessions
//
PerfCounterDef  OutHttpSessionCountersArray[] =
{
    {OUT_HTTP_NUMSESSOUTPACKETS,     OUT_HTTP_NUMSESSOUTPACKETS,  0,  PERF_COUNTER_COUNTER},
    {OUT_HTTP_NUMSESSOUTBYTES,       OUT_HTTP_NUMSESSOUTBYTES,    0,  PERF_COUNTER_COUNTER},
    {OUT_HTTP_TOTALSESSOUTPACKETS,   OUT_HTTP_TOTALSESSOUTPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {OUT_HTTP_TOTALSESSOUTBYTES,     OUT_HTTP_TOTALSESSOUTBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};

//
// Counters per active Outgoing Multicast sessions
//
PerfCounterDef  OutPgmSessionCountersArray[] =
{
    {OUT_PGM_NUMSESSOUTPACKETS,     OUT_PGM_NUMSESSOUTPACKETS,  0,  PERF_COUNTER_COUNTER},
    {OUT_PGM_NUMSESSOUTBYTES,       OUT_PGM_NUMSESSOUTBYTES,    0,  PERF_COUNTER_COUNTER},
    {OUT_PGM_TOTALSESSOUTPACKETS,   OUT_PGM_TOTALSESSOUTPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {OUT_PGM_TOTALSESSOUTBYTES,     OUT_PGM_TOTALSESSOUTBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};


//
// Counters per active Outgoing Multicast sessions
//
PerfCounterDef  InPgmSessionCountersArray[] =
{
    {IN_PGM_NUMSESSINPACKETS,     IN_PGM_NUMSESSINPACKETS,  0,  PERF_COUNTER_COUNTER},
    {IN_PGM_NUMSESSINBYTES,       IN_PGM_NUMSESSINBYTES,    0,  PERF_COUNTER_COUNTER},
    {IN_PGM_TOTALSESSINPACKETS,   IN_PGM_TOTALSESSINPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {IN_PGM_TOTALSESSINBYTES,     IN_PGM_TOTALSESSINBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};


//
// Counters per queue
//
PerfCounterDef  QueueCountersArray[] =
{
    {TOTALQUEUEINPACKETS,     TOTALQUEUEINPACKETS,     0,         PERF_COUNTER_RAWCOUNT},
    {TOTALQUEUEINBYTES,       TOTALQUEUEINBYTES,       (DWORD)-2, PERF_COUNTER_RAWCOUNT},
    {TOTALJOURNALINPACKETS,   TOTALJOURNALINPACKETS,   0,         PERF_COUNTER_RAWCOUNT},
    {TOTALJOURNALINBYTES,     TOTALJOURNALINBYTES,     (DWORD)-2, PERF_COUNTER_RAWCOUNT}
};

//
// DS Counters
//
PerfCounterDef  DSCountersArray[] =
{
    {NUMOFSYNCREQUESTS       ,NUMOFSYNCREQUESTS       ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFSYNCREPLIES        ,NUMOFSYNCREPLIES        ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFREPLREQRECV        ,NUMOFREPLREQRECV        ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFREPLREQSENT        ,NUMOFREPLREQSENT        ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFACCESSTOSRVR       ,NUMOFACCESSTOSRVR       ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFWRITEREQSENT       ,NUMOFWRITEREQSENT       ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFERRRETURNEDTOAPP   ,NUMOFERRRETURNEDTOAPP   ,0,  PERF_COUNTER_RAWCOUNT}
};



/*Set up the object array*/
PerfObjectDef ObjectArray [] =
{
    {PERF_QM_OBJECT,				0                      ,QMOBJ,					QMOBJ,					QMCountersArray        ,sizeof (QMCountersArray)/sizeof (PerfCounterDef)},
    {PERF_QUEUE_OBJECT,				MAX_MONITORED_QUEUES   ,QUEUEOBJ,				QUEUEOBJ,				QueueCountersArray     ,sizeof (QueueCountersArray)/sizeof (PerfCounterDef)},
    {PERF_SESSION_OBJECT,			MAX_MONITORED_SESSIONS ,SESSIONOBJ,				SESSIONOBJ,				SessionCountersArray   ,sizeof (SessionCountersArray)/sizeof (PerfCounterDef)},
	{PERF_IN_HTTP_OBJECT,			0,						IN_HTTP_OBJ,            IN_HTTP_OBJ,            InHttpCountersArray,    sizeof (InHttpCountersArray)/sizeof(PerfCounterDef)},
	{PERF_OUT_HTTP_SESSION_OBJECT,	MAX_MONITORED_SESSIONS, OUT_HTTP_SESSION_OBJ,	OUT_HTTP_SESSION_OBJ,	OutHttpSessionCountersArray, sizeof (OutHttpSessionCountersArray)/sizeof (PerfCounterDef) },
	{PERF_OUT_PGM_SESSION_OBJECT,	MAX_MONITORED_SESSIONS, OUT_PGM_SESSION_OBJ,	OUT_PGM_SESSION_OBJ,	OutPgmSessionCountersArray, sizeof (OutPgmSessionCountersArray)/sizeof (PerfCounterDef) },
	{PERF_IN_PGM_SESSION_OBJECT,	MAX_MONITORED_SESSIONS, IN_PGM_SESSION_OBJ,		IN_PGM_SESSION_OBJ,		InPgmSessionCountersArray, sizeof (InPgmSessionCountersArray)/sizeof (PerfCounterDef) },
    {PERF_DS_OBJECT,				0                      ,DSOBJ,					DSOBJ,					DSCountersArray        ,sizeof (DSCountersArray)/sizeof (PerfCounterDef)}
};



DWORD dwPerfObjectsCount = sizeof(ObjectArray) / sizeof(ObjectArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqperf\perfutil.h ===
//In the next file, PERFUTIL.H, are some useful declarations we have found handy for performance data 
//collection DLLs:
 
//__________________________________________________________________

 
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

 
    This file supports routines used to parse and create Performance Monitor Data 
    Structures. It actually supports Performance Object types with multiple instances
 

Revision History:

--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// 
//  Utility macro.  This is used to reserve a DWORD multiple of bytes for Unicode strings 
//  embedded in the definitional data, viz., object instance names. 
//
 
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
 

//    (assumes dword is 4 bytes long and pointer is a dword in size)
 
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))
 

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
 
extern WCHAR  NULL_STRING[];
 

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;




#endif  //_PERFUTIL_H_
 
//__________________________________________________________________
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqperf\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:
    precompiled header for msmq performance library

Author:
    Gadi Ittac (t-gadii) 27-Jun-96

--*/

#ifndef __STDH_H__
#define __STDH_H__


#include <_stdh.h>

#endif // __STDH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqperf\perfutil.cpp ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.


Revision History:

--*/
//
//  include files
//
#include "stdh.h"
#include <string.h>
#include <winperf.h>
#include "perfutil.h"



#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

extern	LPTSTR pszPerfApp;

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events

                              // initialized in Open... routines

DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string
    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted
    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimiter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\acssctrl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: acssctrl.h

Abstract:

    main header for access control code.

Author:

    Doron Juster  (DoronJ)  26-May-1998

--*/

#include <autorel.h>
#include "actempl.h"
#include "rightsg.h"
#include "..\inc\permit.h"

//
// constants.
//
#define  MQSEC_MAX_ACL_SIZE  (0x0fff0)

//
// This is the necessary mask to enable an extended right ACE.
//
#define MSMQ_EXTENDED_RIGHT_MASK  RIGHT_DS_CONTROL_ACCESS

//
// Tables to map permission righrs.
//
extern struct RIGHTSMAP  *g_psExtendRightsMap5to4[];
extern DWORD              g_pdwExtendRightsSize5to4[];
extern DWORD             *g_padwRightsMap5to4[ ];
extern DWORD              g_dwFullControlNT4[ ];
extern DWORD             *g_padwRightsMap4to5[ ];

extern GUID               g_guidCreateQueue;

//
// Well known sids and user tokens.
//
extern PSID   g_pSidOfGuest;
extern PSID   g_pWorldSid;
extern PSID   g_pAnonymSid;
extern PSID   g_pSystemSid;
extern PSID   g_pNetworkServiceSid;
extern PSID   g_pAdminSid;

extern bool   g_fDomainController;

//
// Internal functions.
//
void InitializeGenericMapping();

DWORD 
GetAccessToken( 
	OUT HANDLE *phAccessToken,
	IN  BOOL    fImpersonate,
	IN  DWORD   dwAccessType = TOKEN_QUERY,
	IN  BOOL    fThreadTokenOnly = FALSE 
	);

PGENERIC_MAPPING  GetObjectGenericMapping(DWORD dwObjectType);

HRESULT 
SetSpecificPrivilegeInAccessToken( 
	HANDLE  hAccessToken,
	LPCTSTR lpwcsPrivType,
	BOOL    bEnabled 
	);

void  
GetpSidAndObj( 
	IN  ACCESS_ALLOWED_ACE*   pAce,
	OUT PSID                 *ppSid,
	OUT BOOL                 *pfObj,
	OUT GUID                **ppguidObj = NULL 
	);

BOOL  
IsNewSid( 
	PSID pSid,
	SID** ppSids,
	DWORD* pdwNumofSids 
	);

BOOL InitializeGuestSid();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\acsschck.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: acsschck.cpp

Abstract:
    Code to checkk access permission.

Author:
    Doron Juster (DoronJ)  27-Oct-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include "mqnames.h"

#include "acsschck.tmh"

static WCHAR *s_FN=L"acssctrl/acsschck";

#define OBJECT_TYPE_NAME_MAX_LENGTH 32


static 
HRESULT 
ReplaceSidWithSystemService(
	IN OUT SECURITY_DESCRIPTOR  *pNewSD,
	IN     SECURITY_DESCRIPTOR  *pOldSD,
	IN     PSID                  pMachineSid,
	IN     PSID                  pSystemServiceSid,
	OUT    ACL                 **ppSysDacl,
	OUT    BOOL                 *pfReplaced 
	)
/*++
Routine Description:
	Replace existing security descriptor DACL with DACL that machine$ sid ACE is replaced with 
	SystemService (LocalSystem or NetworkService) sid ACE.
	If machine$ ACE was replaced, *pfReplaced will be set to TRUE.

Arguments:
	pNewSD - new security descriptor to be updated.
	pOldSD - previous security descriptor.
	pMachineSid - machine$ sid.
	pSystemServiceSid - SystemServiceSid. LocalSystem or NetworkService.
	ppSysDacl - new DACL (with system ACE instead of machine$ ACE)
	pfReplaced - set to TRUE if a machine$ ACE was indeed replaced. Otherwise, FALSE.

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    ASSERT((g_pSystemSid != NULL) && IsValidSid(g_pSystemSid));

    *pfReplaced = FALSE;

    BOOL fReplaced = FALSE;
    BOOL bPresent;
    BOOL bDefaulted;
    ACL  *pOldAcl = NULL;

    if(!GetSecurityDescriptorDacl( 
				pOldSD,
				&bPresent,
				&pOldAcl,
				&bDefaulted 
				))
	{
		DWORD gle = GetLastError();
		ASSERT(("GetSecurityDescriptorDacl failed", 0));
		TrERROR(SECURITY, "GetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
		return HRESULT_FROM_WIN32(gle);
	}
    
    if (!pOldAcl || !bPresent)
    {
        //
        // It's OK to have a security descriptor without a DACL.
        //
        return MQSec_OK;
    }
	else if (pOldAcl->AclRevision != ACL_REVISION)
    {
        //
        // we expect to get a DACL with  NT4 format.
        //
	    ASSERT(pOldAcl->AclRevision == ACL_REVISION);
		TrERROR(SECURITY, "Wrong DACL version %d", pOldAcl->AclRevision);
        return MQSec_E_WRONG_DACL_VERSION;
    }

    //
    // size of SYSTEM acl is not longer than original acl, as the
    // length of system SID is shorter then machine account sid.
    //
    ASSERT(GetLengthSid(g_pSystemSid) <= GetLengthSid(pMachineSid));

    DWORD dwAclSize = (pOldAcl)->AclSize;
    *ppSysDacl = (PACL) new BYTE[dwAclSize];
    if(!InitializeAcl(*ppSysDacl, dwAclSize, ACL_REVISION))
    {
		DWORD gle = GetLastError();
		ASSERT(("InitializeAcl failed", 0));
		TrERROR(SECURITY, "InitializeAcl failed, gle = %!winerr!", gle);
		return HRESULT_FROM_WIN32(gle);
    }

	//
	// Build the new DACL
	//
    DWORD dwNumberOfACEs = (DWORD) pOldAcl->AceCount;
    for (DWORD i = 0 ; i < dwNumberOfACEs ; i++)
    {
        PSID pSidTmp;
        ACCESS_ALLOWED_ACE *pAce;

        if(!GetAce(pOldAcl, i, (LPVOID* )&(pAce)))
        {
            TrERROR(SECURITY, "Failed to get ACE (index=%lu) while replacing SID with System SID. %!winerr!", i, GetLastError());
            return MQSec_E_SDCONVERT_GETACE;
        }

		//
		// Get the ACE sid
		//
        if (EqualSid((PSID) &(pAce->SidStart), pMachineSid))
        {
			//
			// Found MachineSid, replace it with SystemService sid.
			//
            pSidTmp = pSystemServiceSid;
            fReplaced = TRUE;
        }
        else
        {
            pSidTmp = &(pAce->SidStart);
        }

		//
		// Add ACE to DACL
		//
        if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            if(!AddAccessAllowedAce( 
					*ppSysDacl,
					ACL_REVISION,
					pAce->Mask,
					pSidTmp 
					))
            {
				DWORD gle = GetLastError();
				ASSERT(("AddAccessAllowedAce failed", 0));
				TrERROR(SECURITY, "AddAccessAllowedAce failed, gle = %!winerr!", gle);
				return HRESULT_FROM_WIN32(gle);
            }                                         
        }
        else
        {
            ASSERT(pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE);

            if(!AddAccessDeniedAceEx( 
					*ppSysDacl,
					ACL_REVISION,
					0,
					pAce->Mask,
					pSidTmp 
					))
            {
				DWORD gle = GetLastError();
				ASSERT(("AddAccessDeniedAceEx failed", 0));
				TrERROR(SECURITY, "AddAccessDeniedAceEx failed, gle = %!winerr!", gle);
				return HRESULT_FROM_WIN32(gle);
            }                                         
        }
    }

    if (fReplaced)
    {
		//
		// Set the new DACL with the replaced ACE (MachineSid was replaced with SystemSid)
		//
        if(!SetSecurityDescriptorDacl( 
				pNewSD,
				TRUE, // dacl present
				*ppSysDacl,
				FALSE 
				))
        {
			DWORD gle = GetLastError();
			ASSERT(("SetSecurityDescriptorDacl failed", 0));
			TrERROR(SECURITY, "SetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
			return HRESULT_FROM_WIN32(gle);
        }                                         
    }

    *pfReplaced = fReplaced;
    return MQ_OK;
}

//+---------------------------------------------------------
//
//  LPCWSTR  _GetAuditObjectTypeName(DWORD dwObjectType)
//
//+---------------------------------------------------------

static LPCWSTR _GetAuditObjectTypeName(DWORD dwObjectType)
{
    switch (dwObjectType)
    {
        case MQDS_QUEUE:
            return L"Queue";

        case MQDS_MACHINE:
            return L"msmqConfiguration";

        case MQDS_CN:
            return L"Foreign queue";

        default:
            ASSERT(0);
            return NULL;
    }
}

//+-----------------------------------
//
//  BOOL  MQSec_CanGenerateAudit()
//
//+-----------------------------------

inline BOOL operator==(const LUID& a, const LUID& b)
{
    return ((a.LowPart == b.LowPart) && (a.HighPart == b.HighPart));
}

BOOL APIENTRY  MQSec_CanGenerateAudit()
{
    static BOOL s_bInitialized = FALSE;
    static BOOL s_bCanGenerateAudits = FALSE ;

    if (s_bInitialized)
    {
        return s_bCanGenerateAudits;
    }
    s_bInitialized = TRUE;

    CAutoCloseHandle hProcessToken;
    //
    // Enable the SE_AUDIT privilege that allows the QM to write audits to
    // the events log.
    //
    BOOL bRet = OpenProcessToken( 
					GetCurrentProcess(),
					(TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES),
					&hProcessToken 
					);
    if (bRet)
    {
        HRESULT hr = SetSpecificPrivilegeInAccessToken( 
							hProcessToken,
							SE_AUDIT_NAME,
							TRUE 
							);
        if (SUCCEEDED(hr))
        {
            s_bCanGenerateAudits = TRUE;
        }
    }
    else
    {
        DWORD gle = GetLastError() ;
		TrERROR(SECURITY, "MQSec_CanGenerateAudit() fail to open process token, err- %!winerr!", gle);
    }

    if (s_bCanGenerateAudits)
    {
        s_bCanGenerateAudits = FALSE;

        LUID luidPrivilegeLUID;
        if(!LookupPrivilegeValue(NULL, SE_AUDIT_NAME, &luidPrivilegeLUID))
        {
	    	DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "Failed to Lookup Privilege Value %ls, gle = %!winerr!", SE_AUDIT_NAME, gle);
			return s_bCanGenerateAudits;
        }

        DWORD dwLen = 0;
        GetTokenInformation( 
				hProcessToken,
				TokenPrivileges,
				NULL,
				0,
				&dwLen 
				);
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	    {
	    	DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "Failed to GetTokenInformation(TokenPrivileges), gle = %!winerr!", gle);
			return s_bCanGenerateAudits;
	    }

        AP<char> TokenPrivs_buff = new char[dwLen];
        TOKEN_PRIVILEGES *TokenPrivs;
        TokenPrivs = (TOKEN_PRIVILEGES *)(char *)TokenPrivs_buff;
        if(!GetTokenInformation( 
					hProcessToken,
					TokenPrivileges,
					(PVOID)TokenPrivs,
					dwLen,
					&dwLen
					))
	    {
	    	DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "Failed to GetTokenInformation(TokenPrivileges), gle = %!winerr!", gle);
			return s_bCanGenerateAudits;
	    }
					
        for (DWORD i = 0; i < TokenPrivs->PrivilegeCount ; i++)
        {
            if (TokenPrivs->Privileges[i].Luid == luidPrivilegeLUID)
            {
                s_bCanGenerateAudits = (TokenPrivs->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) != 0;
		    	TrTRACE(SECURITY, "Found %ls luid", SE_AUDIT_NAME);
                break;
            }
        }
    }

	TrTRACE(SECURITY, "s_bCanGenerateAudits = %d", s_bCanGenerateAudits);
    return s_bCanGenerateAudits;
}


DWORD
GetAccessToken(
	OUT HANDLE *phAccessToken,
	IN  BOOL    fImpersonate,
	IN  DWORD   dwAccessType,
	IN  BOOL    fThreadTokenOnly
	)
/*++
Routine Description:
	Get thread\process access token

Arguments:
	phAccessToken - Access token.
	fImpersonate - flag for impersonating the calling thread.
	dwAccessType - Desired access.
	fThreadTokenOnly - Get Thread token only.

Returned Value:
	ERROR_SUCCESS, if successful, else error code.

--*/
{
    P<CImpersonate> pImpersonate = NULL;

    if (fImpersonate)
    {
        pImpersonate = new CImpersonate(TRUE, TRUE);
        if (pImpersonate->GetImpersonationStatus() != 0)
        {
			TrERROR(SECURITY, "Failed to impersonate client");
            return ERROR_CANNOT_IMPERSONATE;
        }
    }

    if (!OpenThreadToken(
			GetCurrentThread(),
			dwAccessType,
			TRUE,  // OpenAsSelf, use process security context for doing access check.
			phAccessToken
			))
    {
		DWORD dwErr = GetLastError();
        if (dwErr != ERROR_NO_TOKEN)
        {
            *phAccessToken = NULL; // To be on the safe side.
			TrERROR(SECURITY, "Failed to get thread token, gle = %!winerr!", dwErr);
            return dwErr;
        }

        if (fThreadTokenOnly)
        {
            //
            // We're interested only in thread token (for doing client
            // access check). If token not available then it's a failure.
            //
            *phAccessToken = NULL; // To be on the safe side.
			TrERROR(SECURITY, "Failed to get thread token, gle = %!winerr!", dwErr);
            return dwErr;
        }

        //
        // The process has only one main thread. IN this case we should
        // open the process token.
        //
        ASSERT(!fImpersonate);
        if (!OpenProcessToken(
				GetCurrentProcess(),
				dwAccessType,
				phAccessToken
				))
        {
			dwErr = GetLastError();
            *phAccessToken = NULL; // To be on the safe side.
			TrERROR(SECURITY, "Failed to get process token, gle = %!winerr!", dwErr);
            return dwErr;
        }
    }

    return ERROR_SUCCESS;
}


static 
HRESULT  
_DoAccessCheck( 
	IN  SECURITY_DESCRIPTOR *pSD,
	IN  DWORD                dwObjectType,
	IN  LPCWSTR              pwszObjectName,
	IN  DWORD                dwDesiredAccess,
	IN  LPVOID               pId,
	IN  HANDLE               hAccessToken 
	)
/*++
Routine Description:
	Perform access check and audit.

Arguments:
	pSD - Security descriptor.
	dwObjectType - Object type.
	pwszObjectName - Object name.
	dwDesiredAccess - Desired accessGet Thread token only.
	pId - uniqe id.
	hAccessToken - Access token
	
Returned Value:
	MQ_OK if access was granted, else error code.

--*/
{
	ASSERT(hAccessToken != NULL);

    DWORD dwGrantedAccess = 0;
    BOOL  fAccessStatus = FALSE;

	if (!MQSec_CanGenerateAudit() || !pwszObjectName)
    {
        char ps_buff[sizeof(PRIVILEGE_SET) +
                     ((2 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))];
        PPRIVILEGE_SET ps = (PPRIVILEGE_SET)ps_buff;
        DWORD dwPrivilegeSetLength = sizeof(ps_buff);

        if(!AccessCheck( 
					pSD,
					hAccessToken,
					dwDesiredAccess,
					GetObjectGenericMapping(dwObjectType),
					ps,
					&dwPrivilegeSetLength,
					&dwGrantedAccess,
					&fAccessStatus 
					))
        {
			DWORD gle = GetLastError();
			ASSERT(("AccessCheck failed", 0));
			TrERROR(SECURITY, "AccessCheck failed, gle = %!winerr!", gle);
			return MQ_ERROR_ACCESS_DENIED;
        }
    }
    else
    {
        BOOL bAuditGenerated;
        BOOL bCreate = FALSE;

        switch (dwObjectType)
        {
            case MQDS_QUEUE:
            case MQDS_CN:
                bCreate = FALSE;
                break;

            case MQDS_MACHINE:
                bCreate = (dwDesiredAccess & MQSEC_CREATE_QUEUE) != 0;
                break;

            default:
                ASSERT(0);
                break;
        }

        LPCWSTR pAuditSubsystemName = L"MSMQ";

        if(!AccessCheckAndAuditAlarm(
					pAuditSubsystemName,
					pId,
					const_cast<LPWSTR>(_GetAuditObjectTypeName(dwObjectType)),
					const_cast<LPWSTR>(pwszObjectName),
					pSD,
					dwDesiredAccess,
					GetObjectGenericMapping(dwObjectType),
					bCreate,
					&dwGrantedAccess,
					&fAccessStatus,
					&bAuditGenerated
					))
        {
			DWORD gle = GetLastError();
			ASSERT_BENIGN(("AccessCheckAndAuditAlarm failed", 0));
			TrERROR(SECURITY, "AccessCheckAndAuditAlarm failed, gle = %!winerr!", gle);
			return MQ_ERROR_ACCESS_DENIED;
        }

        if(!ObjectCloseAuditAlarm(pAuditSubsystemName, pId, bAuditGenerated))
        {
			//
			// Don't return error here, just trace that generates an audit message in the event log failed.
			//
			DWORD gle = GetLastError();
			ASSERT(("ObjectCloseAuditAlarm failed", 0));
			TrERROR(SECURITY, "ObjectCloseAuditAlarm failed, gle = %!winerr!", gle);
        }
    }

    if (fAccessStatus && AreAllAccessesGranted(dwGrantedAccess, dwDesiredAccess))
    {
        //
        // Access granted.
        //
		TrTRACE(SECURITY, "Access is granted: ObjectType = %d, DesiredAccess = 0x%x, ObjectName = %ls", dwObjectType, dwDesiredAccess, pwszObjectName);
        return MQSec_OK;
    }

	//
	// Access is denied
	//
    if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
    {
		TrERROR(SECURITY, "Privilage not held: ObjectType = %d, DesiredAccess = 0x%x, ObjectName = %ls", dwObjectType, dwDesiredAccess, pwszObjectName);
        return MQ_ERROR_PRIVILEGE_NOT_HELD;
    }

	TrERROR(SECURITY, "Access is denied: ObjectType = %d, DesiredAccess = 0x%x, ObjectName = %ls", dwObjectType, dwDesiredAccess, pwszObjectName);
    return MQ_ERROR_ACCESS_DENIED;
}


HRESULT
APIENTRY
MQSec_AccessCheck(
	IN  SECURITY_DESCRIPTOR *pSD,
	IN  DWORD                dwObjectType,
	IN  LPCWSTR              pwszObjectName,
	IN  DWORD                dwDesiredAccess,
	IN  LPVOID               pId,
	IN  BOOL                 fImpAsClient,
	IN  BOOL                 fImpersonate
	)
/*++
Routine Description:
  	Perform access check for the runnig thread. The access token is
	retreived from the thread token.

Arguments:
	pSD - Security descriptor.
	dwObjectType - Object type.
	pwszObjectName - Object name.
	dwDesiredAccess - Desired accessGet Thread token only.
	pId - uniqe id.
	fImpAsClient - Flag for how to impersonate, Rpc impersonation or ImpersonateSelf.
	fImpersonate - Flag indicating if we need to impersonate the client.
	
Returned Value:
	MQ_OK if access was granted, else error code.

--*/
{
    //
    // Bug 8567. AV due to NULL pSD.
    // Let's log this. At present we have no idea why pSD is null.
    // fix is below, when doing access check for service account.
    //
    if (pSD == NULL)
    {
        ASSERT(pSD);
		TrERROR(SECURITY, "MQSec_AccessCheck() got NULL pSecurityDescriptor");
    }

	//
	// Impersonate the client
	//
    P<CImpersonate> pImpersonate = NULL;
    if (fImpersonate)
    {
        pImpersonate = new CImpersonate(fImpAsClient, TRUE);
        if (pImpersonate->GetImpersonationStatus() != 0)
        {
			TrERROR(SECURITY, "Failed to impersonate client");
            return MQ_ERROR_CANNOT_IMPERSONATE_CLIENT;
        }

		TrTRACE(SECURITY, "Performing AccessCheck for the current thread");
		MQSec_TraceThreadTokenInfo();
	}

	//
	// Get thread access token
	//
    CAutoCloseHandle hAccessToken = NULL;
    DWORD rc = GetAccessToken(
					&hAccessToken,
					FALSE,
					TOKEN_QUERY,
					TRUE
					);

    if (rc != ERROR_SUCCESS)
    {
        //
        // Return this error for backward compatibility.
        //
		TrERROR(SECURITY, "Failed to get access token, gle = %!winerr!", rc);
        return MQ_ERROR_ACCESS_DENIED;
    }

	//
	// Access Check
	//
    HRESULT hr =  _DoAccessCheck(
						pSD,
						dwObjectType,
						pwszObjectName,
						dwDesiredAccess,
						pId,
						hAccessToken
						);

	PSID pSystemServiceSid = NULL;
    if (FAILED(hr) && 
    	(pSD != NULL) && 
    	pImpersonate->IsImpersonatedAsSystemService(&pSystemServiceSid))
    {
		TrTRACE(SECURITY, "Thread is impersonating as system service %!sid!", pSystemServiceSid);

        //
        // In all ACEs with the machine account sid, replace sid with
        // SYSTEM sid and try again. This is a workaround to problems in
        // Widnows 2000 where rpc call from service to service may be
        // interpreted as machine account sid or as SYSTEM sid. This depends
        // on either it's local rpc or tcp/ip and on using Kerberos.
        //
        PSID pMachineSid = MQSec_GetLocalMachineSid(FALSE, NULL);
        if (!pMachineSid)
        {
            //
            // Machine SID not available. Quit.
            //
			TrERROR(SECURITY, "Machine Sid not available, Access is denied");
            return hr;
        }
        ASSERT(IsValidSid(pMachineSid));

        SECURITY_DESCRIPTOR sd;
        if(!InitializeSecurityDescriptor(
						&sd,
						SECURITY_DESCRIPTOR_REVISION
						))
        {
            DWORD gle = GetLastError();
	        ASSERT(("InitializeSecurityDescriptor failed", 0));
    		TrERROR(SECURITY, "Fail to Initialize Security Descriptor security, gle = %!winerr!", gle) ;
            return hr;
        }

        //
        // use e_DoNotCopyControlBits at present, to be compatible with
        // previous code.
        //
        if(!MQSec_CopySecurityDescriptor(
				&sd,
				pSD,
				(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION),
				e_DoNotCopyControlBits
				))
        {
            DWORD gle = GetLastError();
	        ASSERT(("MQSec_CopySecurityDescriptor failed", 0));
    		TrERROR(SECURITY, "Fail to copy security descriptor, gle = %!winerr!", gle);
            return hr;
        }

        BOOL fReplaced = FALSE;
        P<ACL> pSysDacl = NULL;

        HRESULT hr1 = ReplaceSidWithSystemService(
							&sd,
							pSD,
							pMachineSid,
							pSystemServiceSid,
							&pSysDacl,
							&fReplaced
							);

        if (SUCCEEDED(hr1) && fReplaced)
        {
			TrTRACE(SECURITY, "Security descriptor was updated with System sid instead on machine$ sid");

            //
            // OK, retry the Access Check, with new security desctiptor that replaced
            // the machine account sid with the well-known SYSTEM sid.
            //
            hr =  _DoAccessCheck(
						&sd,
						dwObjectType,
						pwszObjectName,
						dwDesiredAccess,
						pId,
						hAccessToken
						);
        }
    }

    return LogHR(hr, s_FN, 120);
}


HRESULT
APIENTRY
MQSec_AccessCheckForSelf(
	IN  SECURITY_DESCRIPTOR *pSD,
	IN  DWORD                dwObjectType,
	IN  PSID                 pSelfSid,
	IN  DWORD                dwDesiredAccess,
	IN  BOOL                 fImpersonate
	)
/*++
Routine Description:
  	Perform access check for the runnig thread. 
  	The access is done for the thread sid and for selfSid.

Arguments:
	pSD - Security descriptor.
	dwObjectType - Object type.
	pSelfSid - Self sid (computer sid).
	dwDesiredAccess - Desired accessGet Thread token only.
	fImpersonate - Flag indicating if we need to impersonate the client.
	
Returned Value:
	MQ_OK if access was granted, else error code.

--*/
{
    if (dwObjectType != MQDS_COMPUTER)
    {
        //
        // Not supported. this function is clled only to check
        // access rights for join-domain.
        //
		TrERROR(SECURITY, "Object type %d, is not computer", dwObjectType);
        return MQ_ERROR_ACCESS_DENIED;
    }

    P<CImpersonate> pImpersonate = NULL;
    if (fImpersonate)
    {
        pImpersonate = new CImpersonate(TRUE, TRUE);
        if (pImpersonate->GetImpersonationStatus() != 0)
        {
			TrERROR(SECURITY, "Failed to impersonate client");
            return MQ_ERROR_CANNOT_IMPERSONATE_CLIENT;
        }
    }

    CAutoCloseHandle hAccessToken = NULL;

    DWORD rc = GetAccessToken(
					&hAccessToken,
					FALSE,
					TOKEN_QUERY,
					TRUE
					);

    if (rc != ERROR_SUCCESS)
    {
        //
        // Return this error for backward compatibility.
        //
		TrERROR(SECURITY, "Failed to get access token, gle = %!winerr!", rc);
        return MQ_ERROR_ACCESS_DENIED;
    }

    char ps_buff[sizeof(PRIVILEGE_SET) +
                    ((2 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))];
    PPRIVILEGE_SET ps = (PPRIVILEGE_SET)ps_buff;
    DWORD dwPrivilegeSetLength = sizeof(ps_buff);

    DWORD dwGrantedAccess = 0;
    DWORD fAccessStatus = 1;

    //
    // this is the guid of msmqConfiguration class.
    // Hardcoded here, to save the effort of querying schema.
    // taken from schemaIDGUID attribute of CN=MSMQ-Configuration object
    // in schema naming context.
    //
    BYTE  guidMsmqConfiguration[sizeof(GUID)] = {
			0x44,
			0xc3,
			0x0d,
			0x9a,
			0x00,
			0xc1,
			0xd1,
			0x11,
			0xbb,
			0xc5,
			0x00,
			0x80,
			0xc7,
			0x66,
			0x70,
			0xc0
			};

    OBJECT_TYPE_LIST objType = {
						ACCESS_OBJECT_GUID,
						0,
						(GUID*) guidMsmqConfiguration
						};

    if(!AccessCheckByTypeResultList(
				pSD,
				pSelfSid,
				hAccessToken,
				dwDesiredAccess,
				&objType,
				1,
				GetObjectGenericMapping(dwObjectType),
				ps,
				&dwPrivilegeSetLength,
				&dwGrantedAccess,
				&fAccessStatus
				))
    {
        DWORD gle = GetLastError();
        ASSERT(("AccessCheckByTypeResultList failed", 0));
		TrERROR(SECURITY, "Access Check By Type Result List failed, gle = %!winerr!", gle);
        return MQ_ERROR_ACCESS_DENIED;
    }

    if ((fAccessStatus == 0) && AreAllAccessesGranted(dwGrantedAccess, dwDesiredAccess))
    {
        //
        // Access granted.
        // for this api, fAccessStatus being 0 mean success. see msdn.
        //
		TrTRACE(SECURITY, "Access is granted: DesiredAccess = 0x%x", dwDesiredAccess);
        return MQSec_OK;
    }

	//
	// Access is denied
	//

    if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
    {
		TrERROR(SECURITY, "Privilage not held: DesiredAccess = 0x%x", dwDesiredAccess);
        return MQ_ERROR_PRIVILEGE_NOT_HELD;
    }

	TrERROR(SECURITY, "Access is denied: DesiredAccess = 0x%x", dwDesiredAccess);
    return MQ_ERROR_ACCESS_DENIED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\actempl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: actmepl.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Erez Haba    (erezh)   11-Mar-96
    Doron Juster (DoronJ)  30-June-98

Revision History:
--*/

#ifndef _ACTEMPL_H
#define _ACTEMPL_H

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

//-------------------------------------
//
//  Auto relese array of pointerss.
//
//-------------------------------------

template<class T>
class aPtrs
{
private:
    T       **m_p ;
    DWORD     m_dwSize ;

public:
    aPtrs(T **p, DWORD dwSize) :
                 m_p(p),
                 m_dwSize(dwSize)
    {
        ASSERT(m_dwSize > 0) ;
        for ( DWORD j = 0  ; j < m_dwSize ; j++ )
        {
            m_p[j] = NULL ;
        }
    }

    ~aPtrs()
    {
        for ( DWORD j = 0  ; j < m_dwSize ; j++ )
        {
            if (m_p[j])
            {
                delete m_p[j] ;
            }
        }

        ASSERT(m_p) ;
        delete m_p ;
    }
};

#endif // _ACTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\stdh_sec.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: stdh_sec.h

Abstract: Generic header file for mqsec.dll

Author: Doron Juster  (DoronJ)  03-Jun-1998

--*/

#ifndef __SEC_STDH_H
#define __SEC_STDH_H

#include <_stdh.h>
#include <rpc.h>
#include <autorel.h>

#include <wincrypt.h>

#include <mqprops.h>

#include <mqsec.h>
#include <mqcert.h>
#include <mqreport.h>
#include <mqlog.h>

//+----------------------------
//
//  Logging and debugging
//
//+----------------------------

extern void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine);
extern void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgDWORD(DWORD dw, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);

inline DWORD LogDWORD(DWORD dw, PWCHAR pwszFileName, USHORT usPoint)
{
    if (dw != ERROR_SUCCESS)
    {
        LogMsgDWORD(dw, pwszFileName, usPoint);
    }
    return dw;
}



extern HINSTANCE g_hInstance;


#endif // __SEC_STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\acssinit.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: acssinit.cpp

Abstract:
    Initialize the access control library.

Author:
    Doron Juster (DoronJ)  30-Jun-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include "mqnames.h"
#include <_registr.h>
#include <cs.h>
#include <dsrole.h>
#include <autoreln.h>

//
// The lm* header files are needed for the net api that are used to
// construct the guest sid.
//
#include <lmaccess.h>
#include <lmserver.h>
#include <LMAPIBUF.H>
#include <lmerr.h>

#include "acssinit.tmh"

static WCHAR *s_FN=L"acssctrl/acssinit";

static BYTE s_abGuestUserBuff[128];
PSID   g_pSidOfGuest = NULL;
PSID   g_pWorldSid = NULL;
PSID   g_pAnonymSid = NULL;
PSID   g_pSystemSid = NULL; // LocalSystem sid.
PSID   g_pNetworkServiceSid = NULL;	// NetworkService sid.
PSID   g_pAdminSid = NULL;  // local administrators group sid.

//
// This is the SID of the computer account, as defined in Active Directory.
// The MQQM.DLL cache it in local registry.
//
AP<BYTE> g_pOldLocalMachineSidAutoFree;
PSID   g_pLocalMachineSid = NULL;
DWORD  g_dwLocalMachineSidLen = 0;

//
// This is the SID of the account that run the MSMQ service (or replication
// service, or migration tool). By default (for the services), that's the
// LocalSystem account, but administrator may change it to any other account.
//
PSID   g_pProcessSid = NULL;

bool g_fDomainController = false;


//+------------------------------------------
//
//  PSID  MQSec_GetAnonymousSid()
//
//  See above for meaning of "UnknownUser".
//
//+------------------------------------------

PSID  MQSec_GetAnonymousSid()
{
    ASSERT((g_pAnonymSid != NULL) && IsValidSid(g_pAnonymSid));
    return g_pAnonymSid;
}


//+------------------------------------------
//
//  PSID  MQSec_GetAdminSid()
//
//+------------------------------------------

PSID MQSec_GetAdminSid()
{
    ASSERT((g_pAdminSid != NULL) && IsValidSid(g_pAdminSid));
    return g_pAdminSid;
}


//+------------------------------------------
//
//  PSID  MQSec_GetLocalSystemSid()
//
//+------------------------------------------

PSID MQSec_GetLocalSystemSid()
{
    ASSERT((g_pSystemSid != NULL) && IsValidSid(g_pSystemSid));
    return g_pSystemSid;
}

//+------------------------------------------
//
//  PSID  MQSec_GetNetworkServiceSid()
//
//+------------------------------------------

PSID MQSec_GetNetworkServiceSid()
{
    ASSERT((g_pNetworkServiceSid!= NULL) && IsValidSid(g_pNetworkServiceSid));
    return g_pNetworkServiceSid;
}




//+----------------------------------------------------------------------
//
//  void InitializeGuestSid()
//
// Construct well-known-sid for Guest User on the local computer
//
//  1) Obtain the sid for the local machine's domain
//  2) append DOMAIN_USER_RID_GUEST to the domain sid in GuestUser sid.
//
//+----------------------------------------------------------------------

BOOL InitializeGuestSid()
{
    ASSERT(!g_pSidOfGuest);

	PNETBUF<USER_MODALS_INFO_2> pUsrModals2;
    NET_API_STATUS NetStatus;

    NetStatus = NetUserModalsGet(
					NULL,   // local computer
					2,      // get level 2 information
					(LPBYTE *) &pUsrModals2
					);
    
	if (NetStatus != NERR_Success)
	{
		TrERROR(SECURITY, "NetUserModalsGet failed. Error: %!winerr!", NetStatus);
		return FALSE;
	}

	if (pUsrModals2 == NULL)
	{
		TrTRACE(SECURITY, "The computer isn't a member of a domain");
		return TRUE;
	}
    
    ASSERT((NetStatus == NERR_Success) && (pUsrModals2 != NULL));
    
    PSID pDomainSid = pUsrModals2->usrmod2_domain_id;
    PSID_IDENTIFIER_AUTHORITY pSidAuth;

    pSidAuth = GetSidIdentifierAuthority(pDomainSid);

    UCHAR nSubAuth = *GetSidSubAuthorityCount(pDomainSid);
    if (nSubAuth < 8)
    {
        DWORD adwSubAuth[8]; 
        UCHAR i;

        for (i = 0; i < nSubAuth; i++)
        {
            adwSubAuth[i] = *GetSidSubAuthority(pDomainSid, (DWORD)i);
        }
        adwSubAuth[i] = DOMAIN_USER_RID_GUEST;

        PSID pGuestSid;

        if (!AllocateAndInitializeSid(
				pSidAuth,
				nSubAuth + 1,
				adwSubAuth[0],
				adwSubAuth[1],
				adwSubAuth[2],
				adwSubAuth[3],
				adwSubAuth[4],
				adwSubAuth[5],
				adwSubAuth[6],
				adwSubAuth[7],
				&pGuestSid
				))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "AllocateAndInitializeSid failed. Error: %!winerr!", gle);
            return FALSE;
        }
     
        g_pSidOfGuest = (PSID)s_abGuestUserBuff;
        if (!CopySid( 
					sizeof(s_abGuestUserBuff),
					g_pSidOfGuest,
					pGuestSid 
					))
        {
	        FreeSid(pGuestSid);
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "CopySid failed. Error: %!winerr!", gle);
            return FALSE;
        }
        
        FreeSid(pGuestSid);
    }
    else
    {
        //
        //  There is no Win32 way to set a SID value with
        //  more than 8 sub-authorities. We will munge around
        //  on our own. Pretty dangerous thing to do :-(
        //
        g_pSidOfGuest = (PSID)s_abGuestUserBuff;
        if (!CopySid( 
					sizeof(s_abGuestUserBuff) - sizeof(DWORD),
					g_pSidOfGuest,
					pDomainSid 
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "CopySid failed. Error: %!winerr!", gle);
            return FALSE;
        }
        
        DWORD dwLenSid = GetLengthSid(g_pSidOfGuest);

        //
        // Increment the number of sub authorities
        //
        nSubAuth++;
        *((UCHAR *) g_pSidOfGuest + 1) = nSubAuth;

        //
        // Store the new sub authority (Domain User Rid for Guest).
        //
        *((ULONG *) ((BYTE *) g_pSidOfGuest + dwLenSid)) =
                                             DOMAIN_USER_RID_GUEST;
    }
    

#ifdef _DEBUG
    ASSERT(g_pSidOfGuest != NULL);

    //
	// Compare the guest SID that we got with the one that
    // LookupAccountName returns. We can do it only on English
    // machines.
    //
    if (PRIMARYLANGID(GetSystemDefaultLangID()) == LANG_ENGLISH)
    {
        char abGuestSid_buff[128];
        PSID pGuestSid = (PSID)abGuestSid_buff;
        DWORD dwSidLen = sizeof(abGuestSid_buff);
        WCHAR szRefDomain[128];
        DWORD dwRefDomainLen = sizeof(szRefDomain) / sizeof(WCHAR);
        SID_NAME_USE eUse;

        BOOL bRetDbg = LookupAccountName( 
							NULL,
							L"Guest",
							pGuestSid,
							&dwSidLen,
							szRefDomain,
							&dwRefDomainLen,
							&eUse 
							);
        if (!bRetDbg              ||
            (eUse != SidTypeUser) ||
            !EqualSid(pGuestSid, g_pSidOfGuest))
        {
        	DWORD gle = GetLastError();
            TrERROR(SECURITY, "MQSEC: LookupAccountName, Bad guest SID or function failure. gle=%!winerr!", gle);
        }
    }

    DWORD dwLen = GetLengthSid(g_pSidOfGuest);
    ASSERT(dwLen <= sizeof(s_abGuestUserBuff));
#endif

	return TRUE;
}

//+---------------------------------
//
//   InitWellKnownSIDs()
//
//+---------------------------------

static bool InitWellKnownSIDs()
{
	SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;

    //
    // Anonymous logon SID.
    //
    if(!AllocateAndInitializeSid( 
				&NtAuth,
				1,
				SECURITY_ANONYMOUS_LOGON_RID,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pAnonymSid 
				))
	{
		DWORD gle = GetLastError();
        TrERROR(SECURITY, "Fail to initialize Anonymous sid, gle = %!winerr!", gle);
		return false;
	}

    //
    // Initialize the LocalSystem account.
    //
    if(!AllocateAndInitializeSid( 
				&NtAuth,
				1,
				SECURITY_LOCAL_SYSTEM_RID,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pSystemSid
				))
	{
		DWORD gle = GetLastError();
        TrERROR(SECURITY, "Fail to initialize Local System sid, gle = %!winerr!", gle);
		return false;
	}

    //
    // Initialize NetworkService account.
    //
    if(!AllocateAndInitializeSid( 
				&NtAuth,
				1,
				SECURITY_NETWORK_SERVICE_RID,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pNetworkServiceSid
				))
	{
		DWORD gle = GetLastError();
        TrERROR(SECURITY, "Fail to initialize NetworkService sid, gle = %!winerr!", gle);
		return false;
	}

    //
    // Initialize local administrators group sid.
    //
    if(!AllocateAndInitializeSid(
				&NtAuth,
				2,
				SECURITY_BUILTIN_DOMAIN_RID,
				DOMAIN_ALIAS_RID_ADMINS,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pAdminSid
				))
	{
		DWORD gle = GetLastError();
        TrERROR(SECURITY, "Fail to initialize Local Admin sid, gle = %!winerr!", gle);
		return false;
	}

    //
    // Initialize the process sid.
    //
    DWORD dwLen = 0;
    CAutoCloseHandle hUserToken;

    DWORD gle = GetAccessToken(&hUserToken, FALSE);
    if (gle != ERROR_SUCCESS)
    {
		//
        // We can't get sid from thread/process token.
        //
        TrERROR(SECURITY, "Fail to Get Access Token, gle = %!winerr!", gle);
		return false;
    }
   
    //
    // Get the SID from the access token.
    //
    GetTokenInformation(hUserToken, TokenUser, NULL, 0, &dwLen);
    gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER )
    {
    	ASSERT(gle != ERROR_SUCCESS);
    	TrERROR(SECURITY, "Failed to get token infomation, gle = %!winerr!", gle);
		return false;
    }
    
    ASSERT(dwLen > 0);
    AP<BYTE> pBuf = new BYTE[dwLen];
    if(!GetTokenInformation( 
				hUserToken,
				TokenUser,
				pBuf,
				dwLen,
				&dwLen 
				))
	{
		gle = GetLastError();
		TrERROR(SECURITY, "Failed to Get Token information, gle = %!winerr!", gle);
		return false;
	}

    BYTE *pTokenUser = pBuf;
    PSID pSid = (PSID) (((TOKEN_USER*) pTokenUser)->User.Sid);
    dwLen = GetLengthSid(pSid);
    g_pProcessSid = (PSID) new BYTE[dwLen];
    if(!CopySid(dwLen, g_pProcessSid, pSid))
	{
		gle = GetLastError();
		TrERROR(SECURITY, "Fail to copy sid, gle = %!winerr!", gle);
		return false;
	}

#ifdef _DEBUG
    ASSERT(IsValidSid(g_pProcessSid));

    BOOL fSystemSid = MQSec_IsSystemSid(g_pProcessSid);
    if (fSystemSid)
    {
        TrTRACE(SECURITY, "processSID is LocalSystem");
    }
#endif

	TrTRACE(SECURITY, "Process Sid = %!sid!", g_pProcessSid);

	//
    // Initialize World (everyone) SID
    //
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    if(!AllocateAndInitializeSid( 
				&WorldAuth,
				1,
				SECURITY_WORLD_RID,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pWorldSid 
				))
	{
		gle = GetLastError();
        TrERROR(SECURITY, "Fail to initialize Everyone sid, gle = %!winerr!", gle);
		return false;
	}

	return true;
}

//+-------------------------------------------------
//
//  PSID  MQSec_GetProcessSid()
//
//+-------------------------------------------------

PSID APIENTRY  MQSec_GetProcessSid()
{
    ASSERT((g_pProcessSid != NULL) && IsValidSid(g_pProcessSid));
    return  g_pProcessSid;
}

//+-------------------------------------------------
//
//  PSID  MQSec_GetWorldSid()
//
//+-------------------------------------------------

PSID APIENTRY  MQSec_GetWorldSid()
{
    ASSERT((g_pWorldSid != NULL) && IsValidSid(g_pWorldSid));
    return  g_pWorldSid;
}


static bool s_fLocalMachineSidInitialized = false;
static CCriticalSection s_LocalMachineSidCS;

void APIENTRY MQSec_UpdateLocalMachineSid(PSID pLocalMachineSid)
/*++
Routine Description:
	Update LocalMachineSid if needed.

Arguments:
	pLocalMachineSid - new Local Machine sid that was updated in the registry.

Returned Value:
	None

--*/
{
    ASSERT((pLocalMachineSid != NULL) && IsValidSid(pLocalMachineSid));

	CS lock (s_LocalMachineSidCS);

	if((g_pLocalMachineSid != NULL) && (EqualSid(pLocalMachineSid, g_pLocalMachineSid)))
	{
		TrTRACE(SECURITY, "LocalMachineSid = %!sid! wasn't changed", g_pLocalMachineSid);
		return;
	}
	
	//
	// Need to update g_pLocalMachineSid.
	// Either it was NULL or we have a new LocalMachineSid
	//

    DWORD dwSize = GetLengthSid(pLocalMachineSid);
	AP<BYTE> pTempSid = new BYTE[dwSize];
    if(!CopySid(dwSize, pTempSid, pLocalMachineSid))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "Fail to copy sid, gle = %!winerr!", gle);
		return;
	}

	//
	// Save g_pLocalMachineSid, might still be in use so we can't delete it.
	//
	g_pOldLocalMachineSidAutoFree = reinterpret_cast<BYTE*>(g_pLocalMachineSid);

	//
	// Update LocalMachineSid
	//
	g_pLocalMachineSid = pTempSid.detach();
	g_dwLocalMachineSidLen = dwSize;
    s_fLocalMachineSidInitialized = true;

	TrTRACE(SECURITY, "LocalMachineSid = %!sid!", g_pLocalMachineSid);
}


static void InitializeMachineSidFromRegistry()
/*++
Routine Description:
	Initialize LocalMachineSid from registry if not already initialized.

Arguments:
	None

Returned Value:
	None

--*/
{
	PSID pLocalMachineSid = NULL;
    DWORD  dwSize = 0 ;
    DWORD  dwType = REG_BINARY;

    LONG rc = GetFalconKeyValue( 
					MACHINE_ACCOUNT_REGNAME,
					&dwType,
					pLocalMachineSid,
					&dwSize
					);
    if (dwSize > 0)
    {
        pLocalMachineSid = new BYTE[dwSize];

        rc = GetFalconKeyValue( 
				MACHINE_ACCOUNT_REGNAME,
				&dwType,
				pLocalMachineSid,
				&dwSize
				);

        if (rc != ERROR_SUCCESS)
        {
            delete[] reinterpret_cast<BYTE*>(pLocalMachineSid);
            pLocalMachineSid = NULL;
            dwSize = 0;
        }
    }

	g_pLocalMachineSid = pLocalMachineSid;
	g_dwLocalMachineSidLen = dwSize;

	if(g_pLocalMachineSid == NULL)
	{
		TrTRACE(SECURITY, "LocalMachineSid registry is empty");
		return;
	}

	TrTRACE(SECURITY, "LocalMachineSid = %!sid!", g_pLocalMachineSid);
}


//+-----------------------------------------------------------------------
//
//   PSID MQSec_GetLocalMachineSid()
//
//  Input:
//      fAllocate- When TRUE, allocate the buffer. Otherwise, just return
//                 the cached global pointer.
//
//+------------------------------------------------------------------------

PSID 
APIENTRY  
MQSec_GetLocalMachineSid( 
	IN  BOOL    fAllocate,
	OUT DWORD  *pdwSize 
	)
{
	CS lock (s_LocalMachineSidCS);

    if (!s_fLocalMachineSidInitialized)
    {
		InitializeMachineSidFromRegistry();
        s_fLocalMachineSidInitialized = true;
    }

    PSID pSid = g_pLocalMachineSid;

    if (fAllocate && g_dwLocalMachineSidLen)
    {
        pSid = (PSID) new BYTE[g_dwLocalMachineSidLen];
        memcpy(pSid, g_pLocalMachineSid, g_dwLocalMachineSidLen);
    }
    if (pdwSize)
    {
        *pdwSize = g_dwLocalMachineSidLen;
    }

    return pSid;
}


static BOOL InitDomainControllerFlag()
/*++

Routine Description:
	Init domain controller flag.

Arguments:
	None.

Returned Value:
	TRUE for succesfull operation, FALSE otherwise

--*/
{
	g_fDomainController = false;

	BYTE *pBuf = NULL;
    DWORD rc = DsRoleGetPrimaryDomainInformation(
						NULL,
						DsRolePrimaryDomainInfoBasic,
						&pBuf 
						);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(SECURITY, "DsRoleGetPrimaryDomainInformation failed, gle = %!winerr!", rc);
		return FALSE;
    }

    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pRole = (DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pBuf;
    g_fDomainController = !!(pRole->Flags & DSROLE_PRIMARY_DS_RUNNING);
    DsRoleFreeMemory(pRole);

	TrTRACE(SECURITY, "Domain Controller status = %d", g_fDomainController);
    return TRUE;
}


bool APIENTRY MQSec_IsDC()
{
	return g_fDomainController;
}

//+------------------------------------
//
//  void  _FreeSecurityResources()
//
//+------------------------------------

void  _FreeSecurityResources()
{
    if (g_pAnonymSid)
    {
        FreeSid(g_pAnonymSid);
        g_pAnonymSid = NULL;
    }

    if (g_pWorldSid)
    {
        FreeSid(g_pWorldSid);
        g_pWorldSid = NULL;
    }

    if (g_pSystemSid)
    {
        FreeSid(g_pSystemSid);
        g_pSystemSid = NULL;
    }

    if (g_pNetworkServiceSid)
    {
        FreeSid(g_pNetworkServiceSid);
        g_pNetworkServiceSid = NULL;
    }

    if (g_pAdminSid)
    {
        FreeSid(g_pAdminSid);
        g_pAdminSid = NULL;
    }

    if (g_pProcessSid)
    {
        delete g_pProcessSid;
        g_pProcessSid = NULL;
    }

    if (g_pLocalMachineSid)
    {
        delete g_pLocalMachineSid;
        g_pLocalMachineSid = NULL;
    }
}

/***********************************************************
*
* AccessControlDllMain
*
************************************************************/

BOOL 
WINAPI 
AccessControlDllMain (
	HMODULE /* hMod */,
	DWORD fdwReason,
	LPVOID /* lpvReserved */
	)
{
    BOOL bRet = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        if(!InitWellKnownSIDs())
		{
	        TrERROR(SECURITY, "mqsec failed to initialize Well known sids");
			return FALSE;
		}

        bRet = InitDomainControllerFlag();
		ASSERT_BENIGN(bRet);
		
        InitializeGenericMapping();

        bRet = InitializeGuestSid();
		if (!bRet)
        {
        	TrERROR(SECURITY, "InitializeGuestSid failed");
        	g_pSidOfGuest = NULL;
        	ASSERT_BENIGN(false);
        }

        //
        // For backward compatibility.
        // On MSMQ1.0, loading and initialization of mqutil.dll (that
        // included this code) always succeeded.
        //
        bRet = TRUE;
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        _FreeSecurityResources();
    }
    else if (fdwReason == DLL_THREAD_ATTACH)
    {
    }
    else if (fdwReason == DLL_THREAD_DETACH)
    {
    }

	return LogBOOL(bRet, s_FN, 20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\privilge.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: privilge.cpp

Abstract:
    Handle process and thread privileges.

Author:
    Doron Juster (DoronJ)  08-Jun-1998

Revision History:

--*/

#include <stdh_sec.h>

#include "privilge.tmh"

static WCHAR *s_FN=L"acssctrl/privilge";

//+-------------------------------------------------------------------
//
// Function:   SetSpecificPrivilegeInAccessToken()
//
// Description:
//      Enable/Disable a security privilege in the access token.
//
// Parameters:
//      hAccessToken - the access token on which the function should operate.
//          The token should be opened with the TOKEN_ADJUST_PRIVILEGES flag.
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//          disabled.
//
//+-------------------------------------------------------------------

HRESULT 
SetSpecificPrivilegeInAccessToken( 
	HANDLE  hAccessToken,
    LPCTSTR lpwcsPrivType,
    BOOL    bEnabled 
	)
{
    DWORD             dwErr = 0 ;
    HRESULT           hr = MQSec_OK ;
    LUID              luidPrivilegeLUID;
    TOKEN_PRIVILEGES  tpTokenPrivilege;

    if (!LookupPrivilegeValue( 
			NULL,
            lpwcsPrivType,
            &luidPrivilegeLUID
			))
    {
        TrERROR(SECURITY, "Failed to lookup privilege value. %!winerr!", GetLastError());
        return MQSec_E_LOOKUP_PRIV;
    }

    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes =
                                      bEnabled ? SE_PRIVILEGE_ENABLED : 0 ;

    if (!AdjustTokenPrivileges( 
			hAccessToken,
            FALSE,         // Do not disable all
            &tpTokenPrivilege,
            0,
            NULL,           // Ignore previous info
            NULL            // Ignore previous info
			))
    {
        TrERROR(SECURITY, "Failed to adjust token privileges. %!winerr!", GetLastError());
        return MQSec_E_ADJUST_TOKEN;
    }
    else
    {
        dwErr = GetLastError();
        ASSERT((dwErr == ERROR_SUCCESS) ||
               (dwErr == ERROR_NOT_ALL_ASSIGNED));
    }

    return LogHR(hr, s_FN, 30);
}


//+-------------------------------------------------------------------
//
// Function:  MQSec_SetPrivilegeInThread()
//
// Description:
//      Enable/Disable a security privilege in the access token of the
//      current thread.
//
// Parameters:
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//                 disabled.
//
//+-------------------------------------------------------------------

HRESULT
APIENTRY  
MQSec_SetPrivilegeInThread( 
			LPCTSTR lpwcsPrivType,
            BOOL    bEnabled 
			)
{
    HANDLE  hAccessToken = NULL;

    if (!OpenThreadToken( 
			GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES,
            TRUE,
            &hAccessToken 
			))
	{
        DWORD gle = GetLastError();
        if (gle == ERROR_NO_TOKEN)
        {
            if (!OpenProcessToken( 
					GetCurrentProcess(),
                    TOKEN_ADJUST_PRIVILEGES,
                    &hAccessToken 
					))
			{
                TrERROR(SECURITY, "Failed to open current process token. %!winerr!", GetLastError());
				return MQSec_E_OPEN_TOKEN;
            }
        }
        else
        {
            TrERROR(SECURITY, "Failed to open thread token. %!winerr!", gle);
			return MQSec_E_OPEN_TOKEN;
        }
    }

    HRESULT hr = SetSpecificPrivilegeInAccessToken( 
						hAccessToken,
                        lpwcsPrivType,
                        bEnabled 
						);

	CloseHandle(hAccessToken);
    hAccessToken = NULL;
    return LogHR(hr, s_FN, 40);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\imprsont.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: imprsont.cpp

Abstract:
    Code to handle impersonation and access tokens.
    First version taken from mqutil\secutils.cpp

Author:
    Doron Juster (DoronJ)  01-Jul-1998

Revision History:

--*/

#include <stdh_sec.h>
#include <rpcdce.h>
#include "acssctrl.h"

#include "imprsont.tmh"

static WCHAR *s_FN=L"acssctrl/imprsont";

//+------------------------------------
//
//  HRESULT _GetThreadUserSid()
//
//+------------------------------------

HRESULT 
_GetThreadUserSid( 
	IN  HANDLE hToken,
	OUT PSID  *ppSid,
	OUT DWORD *pdwSidLen 
	)
{
    DWORD dwTokenLen = 0;

    GetTokenInformation(hToken, TokenUser, NULL, 0, &dwTokenLen);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
    	DWORD gle = GetLastError();
    	TrERROR(SECURITY, "Failed to GetTokenInformation, gle = %!winerr!", gle);
		return MQSec_E_FAIL_GETTOKENINFO;
    }

    AP<char> ptu = new char[dwTokenLen];
    if(!GetTokenInformation( 
					hToken,
					TokenUser,
					ptu,
					dwTokenLen,
					&dwTokenLen 
					))
    {
    	DWORD gle = GetLastError();
    	TrERROR(SECURITY, "Failed to GetTokenInformation, gle = %!winerr!", gle);
		ASSERT(("GetTokenInformation failed", 0));
		return MQSec_E_FAIL_GETTOKENINFO;
    }

    PSID pOwner = ((TOKEN_USER*)(char*)ptu)->User.Sid;

    DWORD dwSidLen = GetLengthSid(pOwner);
    *ppSid = (PSID) new BYTE[dwSidLen];
    if(!CopySid(dwSidLen, *ppSid, pOwner))
    {
    	DWORD gle = GetLastError();
    	TrERROR(SECURITY, "Failed to CopySid, gle = %!winerr!", gle);
		ASSERT(("CopySid failed", 0));

        delete *ppSid;
        *ppSid = NULL;
		return HRESULT_FROM_WIN32(gle);
    }

    ASSERT(IsValidSid(*ppSid));
	TrTRACE(SECURITY, "Thread sid = %!sid!", *ppSid);

    if (pdwSidLen)
    {
        *pdwSidLen = dwSidLen;
    }

    return MQSec_OK;
}

//+-------------------------
//
//  CImpersonate class
//
//+-------------------------

//
// CImpersonate constructor.
//
// Parameters:
//      fClient - Set to TRUE when the client is an RPC client.
//      fImpersonate - Set to TRUE if impersonation is required upon object
//          construction.
//
CImpersonate::CImpersonate(
	BOOL fClient, 
	BOOL fImpersonateAnonymousOnFailure
	)
{
    m_fClient = fClient;
    m_hAccessTokenHandle = NULL;
    m_dwStatus = 0;
    m_fImpersonateAnonymous = false;

	Impersonate(fImpersonateAnonymousOnFailure);
}

//
// CImpersonate distructor.
//
CImpersonate::~CImpersonate()
{
    if (m_hAccessTokenHandle != NULL)
    {
        CloseHandle(m_hAccessTokenHandle);
    }

	//
	// Revert to self.
	//

    if (m_fClient)
    {
        if (m_fImpersonateAnonymous)
        {
			//
			// Revert ImpersonateAnonymousToken
			//
			if(!RevertToSelf())
			{
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "RevertToSelf() from anonymous failed, gle = %!winerr!", gle);
			}
			return;
        }

		//
		// Revert RpcImpersonateClient
		//
		RPC_STATUS rc = RpcRevertToSelf();
        if (rc != RPC_S_OK)
		{
			TrERROR(SECURITY, "RpcRevertToSelf() failed, RPC_STATUS = %!winerr!", rc);
		}
        return;
    }

	//
	// Revert ImpersonateSelf
	//
    if (!RevertToSelf())
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "RevertToSelf() failed, gle = %!winerr!", gle);
    }
}

//
// Impersonate the client.
//
BOOL 
CImpersonate::Impersonate(
	BOOL fImpersonateAnonymousOnFailure
	)
{
    if (m_fClient)
    {
        m_dwStatus = RpcImpersonateClient(NULL);

        if (m_dwStatus == RPC_S_OK)
        {
        	return TRUE;
        }

		TrERROR(SECURITY, "RpcImpersonateClient() failed, RPC_STATUS = %!winerr!, fRetryAnonymous = %d", m_dwStatus, fImpersonateAnonymousOnFailure);

		if(!fImpersonateAnonymousOnFailure)
		{
			return FALSE;
		}

		//
		// Try to impersonate the Guest user
		//
		BOOL fI = ImpersonateAnonymousToken(GetCurrentThread());
		if (fI)
		{
			m_fImpersonateAnonymous = true;
			m_dwStatus = RPC_S_OK;
			return TRUE;
		}

		m_dwStatus = GetLastError();
		if (m_dwStatus == 0)
		{
			m_dwStatus = RPC_S_CANNOT_SUPPORT;
		}

		TrERROR(SECURITY, "ImpersonateAnonymousToken() failed, gle = %!winerr!", m_dwStatus);
		return FALSE;
    }

    m_dwStatus = 0;

    if (!ImpersonateSelf(SecurityIdentification))
    {
        m_dwStatus = GetLastError();
		TrERROR(SECURITY, "ImpersonateSelf() failed, gle = %!winerr!", m_dwStatus);
		return FALSE;
    }

	return TRUE;
}


//+-------------------------------------------------------
//
//  BOOL CImpersonate::GetThreadSid( OUT BYTE **ppSid )
//
//  the caller must free the buffer allocated here for the sid.
//
//+-------------------------------------------------------

BOOL CImpersonate::GetThreadSid(OUT BYTE **ppSid)
{
    *ppSid = NULL;

    if (m_hAccessTokenHandle == NULL)
    {
        DWORD gle = ::GetAccessToken( 
						&m_hAccessTokenHandle,
						!m_fClient,
						TOKEN_QUERY,
						TRUE 
						);

		if(gle != ERROR_SUCCESS)
        {
			TrERROR(SECURITY, "Failed to Query Thread Access Token, %!winerr!", gle);
            return FALSE;
        }
    }

    ASSERT(m_hAccessTokenHandle != NULL);

    HRESULT hr = _GetThreadUserSid( 
						m_hAccessTokenHandle,
						(PSID*) ppSid,
						NULL 
						);

	if(FAILED(hr))
	{
		TrERROR(SECURITY, "Failed to get Thread user sid, %!hresult!", hr);
		return FALSE;
	}
	
	return TRUE;
}

//+-------------------------------------------------------
//
//  BOOL CImpersonate::IsImpersonateAsSystem()
//
// Check if thread is impersoanted as SYSTEM user or NetworkService user.
// Return TRUE for the SYSTEM or NetworkService case.
// In cases of error, we return FALSE by default.
//
//+-------------------------------------------------------

BOOL CImpersonate::IsImpersonatedAsSystemService(PSID* ppSystemServiceSid)
{
	*ppSystemServiceSid = NULL;
	
    AP<BYTE> pTokenSid;
    if(!GetThreadSid(&pTokenSid))
    {
		TrERROR(SECURITY, "Fail to get thread sid");
	    return FALSE;
    }

    ASSERT((pTokenSid != NULL) && IsValidSid(pTokenSid));
    ASSERT((g_pSystemSid != NULL) && IsValidSid(g_pSystemSid));
    ASSERT((g_pNetworkServiceSid != NULL) && IsValidSid(g_pNetworkServiceSid));

    if(EqualSid(pTokenSid, g_pSystemSid))
    {
    	*ppSystemServiceSid = g_pSystemSid;
    	return TRUE;
    }

    if(EqualSid(pTokenSid, g_pNetworkServiceSid))
    {
    	*ppSystemServiceSid = g_pNetworkServiceSid;
    	return TRUE;
    }

    return FALSE;
}


// Get impersonation status. Acording to the return value of this method it is
// possible to tell whether the impersonation was successful.
//
DWORD CImpersonate::GetImpersonationStatus()
{
    return(m_dwStatus);
}


//+-------------------------------------------------
//
//  HRESULT  MQSec_GetImpersonationObject()
//
//+-------------------------------------------------

void
APIENTRY  
MQSec_GetImpersonationObject(
	IN  BOOL fImpersonateAnonymousOnFailure,	
	OUT CImpersonate **ppImpersonate
	)
{
    CImpersonate *pImp = new CImpersonate(TRUE, fImpersonateAnonymousOnFailure);
    *ppImpersonate = pImp;
}


const LPCWSTR xTokenType[] = {
    L"",
    L"TokenPrimary",
    L"TokenImpersonation"
	};

static void TraceTokenTypeInfo(HANDLE hUserToken)
/*++
Routine Description:
	Trace TokenType info : Primary or Impersonation.

Arguments:
	hUserToken - Token Handle

Returned Value:
	None

--*/
{
	DWORD dwTokenLen = 0;
	TOKEN_TYPE ThreadTokenType;
	if(!GetTokenInformation(
			hUserToken, 
			TokenType, 
			&ThreadTokenType, 
			sizeof(TOKEN_TYPE), 
			&dwTokenLen
			))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetTokenInformation(TokenType) failed, gle = %!winerr!", gle);
		return;
	}

	if((ThreadTokenType >= TokenPrimary) && (ThreadTokenType <= TokenImpersonation))
	{
		TrTRACE(SECURITY, "TokenType = %ls", xTokenType[ThreadTokenType]); 
	}
	else
	{
		TrTRACE(SECURITY, "TokenType = %d", ThreadTokenType); 
	}
}


const LPCWSTR xSecurityImpersonationLevel[] = {
    L"SecurityAnonymous",
    L"SecurityIdentification",
    L"SecurityImpersonation",
    L"SecurityDelegation"
	};


static void TraceTokenImpLevelInfo(HANDLE hUserToken)
/*++
Routine Description:
	Trace TokenImpersonationLevel.

Arguments:
	hUserToken - Token Handle

Returned Value:
	None

--*/
{
	DWORD dwTokenLen = 0;
	SECURITY_IMPERSONATION_LEVEL SecImpersonateLevel;
	if(!GetTokenInformation(
			hUserToken, 
			TokenImpersonationLevel, 
			&SecImpersonateLevel, 
			sizeof(SECURITY_IMPERSONATION_LEVEL), 
			&dwTokenLen
			))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetTokenInformation(TokenImpersonationLevel) failed, gle = %!winerr!", gle);
		return;
	}
	
	if((SecImpersonateLevel >= SecurityAnonymous) && (SecImpersonateLevel <= SecurityDelegation))
	{
		TrTRACE(SECURITY, "ImpersonationLevel = %ls", xSecurityImpersonationLevel[SecImpersonateLevel]); 
	}
	else
	{
		TrTRACE(SECURITY, "ImpersonationLevel = %d", SecImpersonateLevel); 
	}
}


static void TraceTokenSidInfo(HANDLE hUserToken)
/*++
Routine Description:
	Trace Token Sid info.

Arguments:
	hUserToken - Token Handle

Returned Value:
	None

--*/
{
	//
	// Token Sid Info
	//

	DWORD dwTokenLen = 0;
	dwTokenLen = 0;
	GetTokenInformation(hUserToken, TokenUser, NULL, 0, &dwTokenLen);
	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetTokenInformation(TokenUser) failed, gle = %!winerr!", gle);
		return;
	}

    AP<char> ptu = new char[dwTokenLen];
    if(!GetTokenInformation( 
					hUserToken,
					TokenUser,
					ptu,
					dwTokenLen,
					&dwTokenLen 
					))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetTokenInformation(TokenUser) failed, gle = %!winerr!", gle);
		return;
    }

    PSID pOwner = ((TOKEN_USER*)(char*)ptu)->User.Sid;
	TrTRACE(SECURITY, "Sid = %!sid!", pOwner);

#ifdef _DEBUG
	//
	// map sid to domain\user account
	//
    WCHAR NameBuffer[128] = {0};
    WCHAR DomainBuffer[128] = {0};
    ULONG NameLength = TABLE_SIZE(NameBuffer);
    ULONG DomainLength = TABLE_SIZE(DomainBuffer);
    SID_NAME_USE SidUse;
    if (!LookupAccountSid( 
			NULL,
			pOwner,
			NameBuffer,
			&NameLength,
			DomainBuffer,
			&DomainLength,
			&SidUse
			))
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "LookupAccountSid failed, gle = %!winerr!", gle);
		return;
    }

	if(DomainBuffer[0] == '\0')
	{
		TrTRACE(SECURITY, "User = %ls", NameBuffer);
	}
	else
	{
		TrTRACE(SECURITY, "User = %ls\\%ls", DomainBuffer, NameBuffer);
	}
#endif // _DEBUG
}


void APIENTRY MQSec_TraceThreadTokenInfo()
/*++
Routine Description:
	Trace Thread Token info - TokenType, impersonation level, sid
	This function Trace the Thread Token info 
	only if RPC component is enabled at trace level

Arguments:
	None

Returned Value:
	None

--*/
{
	if(!WPP_LEVEL_COMPID_ENABLED(rsTrace, SECURITY))
	{
		return;
	}

	CAutoCloseHandle hUserToken;
	if (!OpenThreadToken(
			GetCurrentThread(),
			TOKEN_QUERY,
			TRUE,  // OpenAsSelf, use process security context for doing access check.
			&hUserToken
			))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "OpenThreadToken() failed, gle = %!winerr!", gle);
		return;
	}

	try
	{
		TraceTokenTypeInfo(hUserToken);
		TraceTokenImpLevelInfo(hUserToken);
		TraceTokenSidInfo(hUserToken);
	}
	catch(const exception&)
	{
		//
		// Ignore exceptions, this function is only for tracing
		//
	}
}			        	


//+---------------------------------------
//
//  HRESULT MQSec_GetUserType()
//
//+---------------------------------------

HRESULT 
APIENTRY  
MQSec_GetUserType( 
	IN  PSID pSid,
	OUT BOOL* pfLocalUser,
	OUT BOOL* pfLocalSystem,
	OUT BOOL* pfNetworkService	/* = NULL */
	)
{
    ASSERT(pfLocalUser);
    *pfLocalUser = FALSE;

    AP<BYTE> pSid1;
    DWORD dwSidLen;

    if (!pSid)
    {
        //
        // get the SID of the thread user.
        //
        HRESULT hr = MQSec_GetThreadUserSid( FALSE, reinterpret_cast<PSID*>(&pSid1), &dwSidLen, FALSE);
        if (FAILED(hr))
        {
			TrERROR(SECURITY, "Failed to get thread user sid, %!hresult!", hr);
            return hr;
        }
        pSid = pSid1;
    }
    ASSERT(IsValidSid(pSid));

    if (pfLocalSystem != NULL)
    {
        *pfLocalSystem = MQSec_IsSystemSid(pSid);
        if (*pfLocalSystem)
        {
            //
            // The local system account (on Win2000) is a perfectly
            // legitimate authenticated domain user.
            //
			if (pfNetworkService != NULL)
			{
				*pfNetworkService = FALSE;
			}

            return MQ_OK;
        }
    }

    if (pfNetworkService != NULL)
    {
        *pfNetworkService = MQSec_IsNetworkServiceSid(pSid);
        if (*pfNetworkService)
        {
            //
            // The NetworkService account is
            // legitimate authenticated domain user.
            //
            return MQ_OK;
        }
    }

    *pfLocalUser = MQSec_IsAnonymusSid(pSid);
    if (*pfLocalUser)
    {
        //
        // The anonymous logon user is a local user.
        //
        return MQ_OK;
    }

    //
    // Check if guest account.
    //
    if (!g_fDomainController)
    {
        //
        // On non-domain controllers, any user that has the same SID
        // prefix as the guest account, is a local user.
        //
        PSID_IDENTIFIER_AUTHORITY pSidAuth;
        SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;
        pSidAuth = GetSidIdentifierAuthority(pSid);

        *pfLocalUser = ((memcmp(pSidAuth, &NtSecAuth, sizeof(SID_IDENTIFIER_AUTHORITY)) != 0) ||
						(g_pSidOfGuest && EqualPrefixSid(pSid, g_pSidOfGuest)));
    }
    else
    {
        //
        // On domain and backup domain controllers a local user, in our
        // case can only be the guest user.
        //
        *pfLocalUser = MQSec_IsGuestSid(pSid);
    }

    return MQ_OK;
}

//+--------------------------------------------------
//
//  BOOL  MQSec_IsGuestSid()
//
//+--------------------------------------------------

BOOL APIENTRY MQSec_IsGuestSid(IN  PSID  pSid)
{
    BOOL fGuest = g_pSidOfGuest && EqualSid(g_pSidOfGuest, pSid);

    return fGuest;
}

//+--------------------------------------------------
//
//  BOOL   MQSec_IsSystemSid()
//
//+--------------------------------------------------

BOOL APIENTRY MQSec_IsSystemSid(IN  PSID  pSid)
{
    ASSERT((g_pSystemSid != NULL) && IsValidSid(g_pSystemSid));

    return EqualSid(g_pSystemSid, pSid);
}

//+--------------------------------------------------
//
//  BOOL   MQSec_IsNetworkServiceSid()
//
//+--------------------------------------------------

BOOL APIENTRY MQSec_IsNetworkServiceSid(IN  PSID  pSid)
{
    ASSERT((g_pNetworkServiceSid != NULL) && IsValidSid(g_pNetworkServiceSid));

    return EqualSid(g_pNetworkServiceSid, pSid);
}

//+--------------------------------------------------
//
//  BOOL   MQSec_IsAnonymusSid()
//
//+--------------------------------------------------

BOOL APIENTRY MQSec_IsAnonymusSid(IN  PSID  pSid)
{
    BOOL fAnonymus = g_pAnonymSid && EqualSid(g_pAnonymSid, pSid);

    return fAnonymus;
}

//+----------------------------------------------------
//
//  HRESULT  MQSec_IsUnAuthenticatedUser()
//
//+----------------------------------------------------

HRESULT 
APIENTRY  
MQSec_IsUnAuthenticatedUser(
	OUT BOOL *pfGuestOrAnonymousUser 
	)
{
    AP<BYTE> pbSid;

    CImpersonate Impersonate(TRUE, TRUE);
    if (Impersonate.GetImpersonationStatus() != 0)
    {
		TrERROR(SECURITY, "Failed to impersonate client");
        return MQ_ERROR_CANNOT_IMPERSONATE_CLIENT;
    }

    HRESULT hr = MQSec_GetThreadUserSid(TRUE, (PSID *) &pbSid, NULL, TRUE);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    *pfGuestOrAnonymousUser =
                MQSec_IsGuestSid( pbSid ) ||
               (g_pAnonymSid && EqualSid(g_pAnonymSid, (PSID)pbSid));

    return MQSec_OK;
}

//+---------------------------------------------------------------------
//
//  HRESULT  MQSec_GetThreadUserSid()
//
//  Get SID of client that called this server thread. This function
//  shoud be called only by RPC server threads. It impersonate the
//  client by calling RpcImpersonateClient().
//
//  Caller must free the buffer that is allocated here for the SId.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetThreadUserSid(
	IN  BOOL        fImpersonate,         
	OUT PSID  *     ppSid,
	OUT DWORD *     pdwSidLen,
    IN  BOOL        fThreadTokenOnly
	)
{
    *ppSid = NULL;

    CAutoCloseHandle hUserToken;
    DWORD rc =  GetAccessToken( 
					&hUserToken,
					fImpersonate,
					TOKEN_QUERY,
					fThreadTokenOnly
					); 

    if (rc != ERROR_SUCCESS)
    {
        HRESULT hr1 = HRESULT_FROM_WIN32(rc);
        return LogHR(hr1, s_FN, 170);
    }

    HRESULT hr = _GetThreadUserSid( 
						hUserToken,
						ppSid,
						pdwSidLen 
						);

    return LogHR(hr, s_FN, 180);
}

//+---------------------------------------------------------------------
//
//  HRESULT  MQSec_GetProcessUserSid()
//
//  Caller must free the buffer that is allocated here for the SId.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetProcessUserSid( 
	OUT PSID  *ppSid,
	OUT DWORD *pdwSidLen 
	)
{
    *ppSid = NULL;

    CAutoCloseHandle hUserToken;
    DWORD rc = GetAccessToken( 
					&hUserToken,
					FALSE,    // fImpersonate
					TOKEN_QUERY,
					FALSE		// fThreadTokenOnly 
					); 

    if (rc != ERROR_SUCCESS)
    {
        return LogHR(MQSec_E_UNKNOWN, s_FN, 190);
    }

    HRESULT hr = _GetThreadUserSid( 
						hUserToken,
						ppSid,
						pdwSidLen 
						);

    return LogHR(hr, s_FN, 200);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\rightsg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rightsg.h

Abstract:
    map NT5 rights guids to MSMQ1.0 permission bits.

Author:
    Doron Juster (DoronJ)  25-May-1998

Revision History:

--*/

//
// Map between extended rights guids (on NT5) to MSMQ1.0 specific rights.
//

struct RIGHTSMAP
{
    GUID  guidRight ;        // guid of NT5 DS extended right.
    DWORD dwPermission5to4 ; // NT5 guid is converted to this permission bits.
    DWORD dwPermission4to5 ; // MSMQ1.0 bit is converted to this extended right.
} ;

#if 0

Site
Following access right should be attached to "Site" object. it should be appear in the advance section.

Open Connector Queue
Entry name: msmq-Open-Conector
RightsGuid: b4e60130-df3f-11d1-9c86-006008764d0e
Display Name: Open Connector Queue
AppliesTo: bf967ab3-0de6-11d0-a285-00aa003049e2

#endif

//
// Map between DS specific rights and MSMQ1.0 specific rights. There
// are eight DS specific properties so all arrays size is 8.
// The index to this array is the DS specific right. The value in array
// is the MSMQ specific right. Separate maps for each MSMQ object.
// Value of 0 means there is no mapping.
//
//	ADS_RIGHT_DS_CREATE_CHILD	= 0x1,
//	ADS_RIGHT_DS_DELETE_CHILD	= 0x2,
//	ADS_RIGHT_ACTRL_DS_LIST  	= 0x4,
//	ADS_RIGHT_DS_SELF           = 0x8,
//	ADS_RIGHT_DS_READ_PROP      = 0x10,
//	ADS_RIGHT_DS_WRITE_PROP     = 0x20,
//	ADS_RIGHT_DS_DELETE_TREE	= 0x40,
//	ADS_RIGHT_DS_LIST_OBJECT	= 0x80
//	ADS_RIGHT_DS_CONTROL_ACCESS	= 0x100
//
// On Win2000, the "RIGHT_DS_CONTROL_ACCESS" bit in an ACE that is not
// OBJ-ACE mean that the sid has all the extended rights. So give it the
// proper msmq extended rights.
//
#define  QUEUE_EXTENDED_RIGHTS  ( MQSEC_DELETE_MESSAGE                 | \
                                  MQSEC_PEEK_MESSAGE                   | \
                                  MQSEC_WRITE_MESSAGE                  | \
                                  MQSEC_DELETE_JOURNAL_MESSAGE )

#define  MACHINE_EXTENDED_RIGHTS  ( MQSEC_DELETE_DEADLETTER_MESSAGE    | \
                                    MQSEC_PEEK_DEADLETTER_MESSAGE      | \
                                    MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE | \
                                    MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE )

//
// Bug 5819 - added MQSEC_CN_OPEN_CONNECTOR to site when "All extended rights"
//            is checked.
// YoelA - 10/31/01
// 
#define  CN_EXTENDED_RIGHTS  MQSEC_CN_OPEN_CONNECTOR

#define  NUMOF_ADS_SPECIFIC_RIGHTS    9
#define  NUMOF_MSMQ_SPECIFIC_RIGHTS   8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\secd4to5.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: secd4to5.cpp

Abstract:
    Conversion of NT4 security descriptor to NT5 DS format.

Author:
    Doron Juster (DoronJ)  01-Jun-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"

#include "secd4to5.tmh"

static WCHAR *s_FN=L"acssctrl/secd4to5";

//
// Make the "mandatory" permissions for localSystem differ from "full
// control", so by default the mandatory aces do not grant the right to read
// messages. Do so by reseting the "all extended rights" bit.
//
#define MANDATORY_ACE_PERMISSIONS   \
                       (GENERIC_ALL_MAPPING & (~RIGHT_DS_CONTROL_ACCESS))

#define MANDATORY_COMPUTER_ACE_PERMISSIONS   \
                      (RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY)

//+-----------------------------------------
//
//  BOOL  _ShrinkAcl(ACL **ppAcl5)
//
//+-----------------------------------------

static
BOOL  
_ShrinkAcl(
	ACL **ppAcl5, 
	DWORD *pdwSize
	)
/*++
Routine Description:
	Shrink ACL to its final size.
	The ACL is allocated initialy with a very big size, need to shrink it to the correct size.

Arguments:
	ppAcl5 - pointer to ACL to be shrinked.
	pdwSize - shrinked ACL size.

Returned Value:
	BOOL - success\failure

--*/
{
	ASSERT(ppAcl5 != NULL);
	ASSERT(pdwSize != NULL);
	
    //
    // compute size of ACL.
    //
    DWORD dwNewSize = sizeof(ACL);
    DWORD dwNumberOfACEs = (DWORD) (*ppAcl5)->AceCount;
    for (DWORD i = 0; i < dwNumberOfACEs; i++)
    {
        ACCESS_ALLOWED_ACE *pAce;
        if (!GetAce(*ppAcl5, i, (LPVOID* )&(pAce)))
        {
            TrERROR(SECURITY, "Failed to get NT5 ACE (index=%lu) while shrinking ACL. %!winerr!", i, GetLastError());
            return FALSE;
        }
        dwNewSize += pAce->Header.AceSize;
    }
    ASSERT(dwNewSize <= (*ppAcl5)->AclSize);

    PACL pAcl = (PACL) new BYTE[dwNewSize];
    memcpy(pAcl, *ppAcl5, dwNewSize);
    delete *ppAcl5;

    *ppAcl5 = pAcl;
    *pdwSize = dwNewSize;
    (*ppAcl5)->AclSize = (WORD) dwNewSize;
    ASSERT(IsValidAcl(*ppAcl5));

    return TRUE;
}

//+----------------------------------------------------------------
//
//  BOOL _CheckForMandatoryACEs()
//
//  Check if mandatory ACEs are included in the DACL.
//  Return TRUE if all mandatory ACEs are already included in the
//  ACL, FALSE if any of them is missing.
//
// Paramaters:
//    IN  GUID *pProperty - guid of the CN property.
//
//+----------------------------------------------------------------

static
BOOL 
_CheckForMandatoryACEs( 
	IN  PACL  pAcl,
	IN  PSID  pComputerSid,
	IN  GUID *pProperty,
	OUT BOOL *pfDenied,
	OUT BOOL *pfSystem,
	OUT BOOL *pfComputer 
	)
{
    BOOL  fSkipDeny = FALSE;
	DWORD dwNumberOfACEs = (DWORD) pAcl->AceCount;
    DWORD i = 0;

    do
    {
	    ACCESS_ALLOWED_ACE *pAce;
        if (!GetAce(pAcl, i, (LPVOID* )&(pAce)))
        {
            TrERROR(SECURITY, "Failed to get ACE (index=%lu) while looking for mandatory ACEs. %!winerr!", i, GetLastError());
            return FALSE;
        }

        BOOL fObj;
        PSID pSid = NULL;
        GUID *pObjType = NULL;

        GetpSidAndObj( 
			pAce,
			&pSid,
			&fObj,
			&pObjType 
			);

        ASSERT(pSid && IsValidSid(pSid));

        BOOL fObjDeny = (pAce->Header.AceType == ACCESS_DENIED_OBJECT_ACE_TYPE);

        if (!fObjDeny)
        {
            //
            // The mandatory "deny" ace must appear before any "allow" ace.
            // So don't look for the mandatory deny ace anymore.
            //
            fSkipDeny = TRUE;
        }

        //
        // Check for Access-Deny, Write-CN
        //
        if (!fSkipDeny     &&
            !(*pfDenied)   &&
             fObjDeny      &&
             pObjType      &&
             EqualSid(pSid, g_pWorldSid))
        {
            if ((memcmp(pObjType, pProperty, sizeof(GUID)) == 0) &&
                (pAce->Mask & RIGHT_DS_WRITE_PROPERTY))
            {
                //
                // OK, "everyone" sid, same property, and WriteProp is
                // included in the access mask of this deny ace.
                //
                *pfDenied = TRUE;
            }
        }

        //
        // Check for LocalSystem full-control
        //
        if (!(*pfSystem)  &&
             (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE))
        {
            if (((pAce->Mask & MANDATORY_ACE_PERMISSIONS) ==
                                          MANDATORY_ACE_PERMISSIONS) &&
                 EqualSid(pSid, g_pSystemSid))
            {
                *pfSystem = TRUE;
            }
        }

        //
        // Check for Computer ACE
        //
        if (!(*pfComputer)  &&
             (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE))
        {
            if (((pAce->Mask & MANDATORY_COMPUTER_ACE_PERMISSIONS) ==
                                    MANDATORY_COMPUTER_ACE_PERMISSIONS) &&
                 EqualSid(pSid, pComputerSid))
            {
                *pfComputer = TRUE;
            }
        }

        i++;
    }
    while (i < dwNumberOfACEs);

    BOOL bRet = *pfSystem && *pfDenied && *pfComputer;
    return LogBOOL(bRet, s_FN, 30);
}

//+-------------------------------------------------
//
//  HRESULT _AddMandatoryAllowACEs()
//
//+-------------------------------------------------

static
HRESULT 
_AddMandatoryAllowACEs( 
	IN  PSID    pComputerSid,
	IN  PACL    pAcl5,
	IN  BOOL    fSystemAce,
	IN  BOOL    fComputerAce 
	)
{
    if (!fSystemAce)
    {
        if (!AddAccessAllowedAce( 
					pAcl5,
					ACL_REVISION_DS,
					MANDATORY_ACE_PERMISSIONS,
					g_pSystemSid 
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "AddAccessAllowedAce failed. Error: %!winerr!", gle);
			ASSERT(("AddAccessAllowedAce failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }
    }

    if (!fComputerAce)
    {
        ASSERT(pComputerSid && IsValidSid(pComputerSid));

        if (!AddAccessAllowedAce( 
					pAcl5,
					ACL_REVISION_DS,
					MANDATORY_COMPUTER_ACE_PERMISSIONS,
					pComputerSid 
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "AddAccessAllowedAce failed. Error: %!winerr!", gle);
			ASSERT(("AddAccessAllowedAce failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }
    }

    return MQSec_OK;
}

//+------------------------------------------------------------------------
//
//   HRESULT _AddMandatoryDenyACEs()
//
//  Each DACL of MSMQ object must have two (or three) ACEs:
//  1. Deny Write CN for everyone.  All of MSMQ code depend on certain names
//     of objects, for example, the CN of the machine object must be "msmq".
//     We deny everyone the permission to set the "cn".
//  2. Allow LocalSystem account full control. This is necessary for the
//     replication service (in mixed mode) and for the MSMQ service itself
//     that must update objects attributes in special cases.
//  3. Allow the computer account to read and change properties of the
//     msmqConfiguration object.
//
//  This function first check for the presence of these aces. If not already
//  present, then we add here the deny ace. The allow aces will be added
//  after the dacl is converted. This is necessary for keeping the dacl
//  in the canonical form. Otherwise, access checl may fail and user may
//  get misleading warnings when displaying the object security in mmc.
//
//  Please note that you can use the DC mmc to change these permissions,
//  but that's your responsibility. We can't deny you the permission to
//  destroy your system, although we make it a little more difficult, and
//  set the proper defaults.
//
//  This function allocates the DACL and add the mandatory deny ACEs.
//
//+------------------------------------------------------------------------

static
HRESULT
_AddMandatoryDenyACEs( 
	IN  DWORD   dwObjectType,
	IN  PSID    pComputerSid,
	IN  PACL    pAcl4,
	OUT DWORD  *pdwAcl5Len,
	OUT PACL   *ppAcl5,
	OUT BOOL   *pfAlreadyNT5,
	OUT BOOL   *pfOnlyCopy,
	OUT BOOL   *pfSystemAce,
	OUT BOOL   *pfComputerAce 
	)
{
    *pfOnlyCopy = FALSE;

    //
    // When going from NT4 format to NT5, the ACL size grow because of the
    // object ACEs. so first allocate the maximum possible (64K), then,
    // after building the DACL we'll shrink it.
    //
    *pdwAcl5Len = MQSEC_MAX_ACL_SIZE;

    //
    // BUGBUG- is there an header file with the guid definitions ?
    // This is the guid of the CN property.
    //
    PTSTR  pwszCnGuid = {L"bf96793f-0de6-11d0-a285-00aa003049e2"};
    GUID   guidCN;
    RPC_STATUS status = UuidFromString(pwszCnGuid, &guidCN);
	DBG_USED(status);
    ASSERT(status == RPC_S_OK);

    if (pAcl4)
    {
        ASSERT(IsValidAcl(pAcl4));
    	*pfAlreadyNT5 =  (pAcl4->AclRevision == ACL_REVISION_DS);
    }

    BOOL fDeniedAce = FALSE;
    ASSERT(!(*pfSystemAce));
    ASSERT(!(*pfComputerAce));

    if (!pComputerSid)
    {
        //
        // If we don't have a computer sid, then don't look for it.
        // that's the reason for the TRUE value here.
        //
        *pfComputerAce = TRUE;
    }
    else
    {
        ASSERT(dwObjectType == MQDS_MACHINE);
        DBG_USED(dwObjectType);
    }

	if (*pfAlreadyNT5 && pAcl4)
    {
        BOOL fAllPresent = _CheckForMandatoryACEs( 
								pAcl4,
								pComputerSid,
								&guidCN,
								&fDeniedAce,
								pfSystemAce,
								pfComputerAce 
								);
        if (fAllPresent)
        {
            //
            // we're just copying old ACL into new buffer. No change
            // in size.
            //
            *pdwAcl5Len = pAcl4->AclSize;
            *pfOnlyCopy = TRUE;
        }
    }

	AP<ACL> TempAcl = (PACL) new BYTE[*pdwAcl5Len];
    *ppAcl5 = TempAcl;
    
    if(!InitializeAcl(*ppAcl5, *pdwAcl5Len, ACL_REVISION_DS))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "InitializeAcl failed, gle = %!winerr!", gle);
		ASSERT(("InitializeAcl failed", gle == ERROR_SUCCESS));
		return HRESULT_FROM_WIN32(gle);
	}

    if (!fDeniedAce)
    {
        ASSERT(!(*pfOnlyCopy));

        if(!AddAccessDeniedObjectAce( 
				*ppAcl5,
				ACL_REVISION_DS,
				0,
				RIGHT_DS_WRITE_PROPERTY,
				&guidCN,
				NULL,
				g_pWorldSid
				))
		{
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "AddAccessDeniedObjectAce failed, gle = %!winerr!", gle);
			ASSERT(("AddAccessDeniedObjectAce failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
		}
    }

	if (*pfAlreadyNT5 && pAcl4)
    {
        //
        // OK, now copy all ACEs from old DACL to new one.
        //
        PVOID  pACE5 = NULL;
        if(!FindFirstFreeAce(*ppAcl5, &pACE5))
		{
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "FindFirstFreeAce failed, gle = %!winerr!", gle);
			ASSERT(("FindFirstFreeAce failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
		}

        DWORD dwCopySize = pAcl4->AclSize - sizeof(ACL);
        BYTE *pACE4 = ((BYTE*) pAcl4) + sizeof(ACL);
        memcpy(pACE5, pACE4, dwCopySize);

        //
        // Update the ACL header.
        //
        ASSERT(((*ppAcl5)->AceCount) <= 1);
        (*ppAcl5)->AceCount = (*ppAcl5)->AceCount + pAcl4->AceCount;

#ifdef _DEBUG
        if (*pfOnlyCopy)
        {
            //
            // nothing changed in the ACL. Assert new one is same as old one.
            //
            ASSERT(memcmp(pAcl4, *ppAcl5, pAcl4->AclSize) == 0);
        }
#endif
    }

	TempAcl.detach();

    return MQSec_OK;
}

//+----------------------------
//
//  BOOL  _IsNewNt4Sid()
//
//+----------------------------

static
BOOL  
_IsNewNt4Sid( 
	ACCESS_ALLOWED_ACE*   pAce,
	SID                 **ppSids,
	DWORD                *pdwNumofSids 
	)
{
    PSID pSid = (PSID) &(pAce->SidStart);
    ASSERT(IsValidSid(pSid));

	return IsNewSid(pSid, ppSids, pdwNumofSids);
}

//+---------------------------------------------
//
//  static DWORD  _MapNt4RightsToNt5Ace()
//
//+---------------------------------------------

static
DWORD 
_MapNt4RightsToNt5Ace( 
	IN DWORD  dwObjectType,
	IN DWORD  dwMSMQRights 
	)
{
    if (dwMSMQRights == 0)
    {
        return 0;
    }

    DWORD dwMask = 0;

    if ((dwMSMQRights & g_dwFullControlNT4[ dwObjectType ]) ==
                                      g_dwFullControlNT4[ dwObjectType ])
    {
        //
        // map incoming bits to "full control". Ignore bits that are not
        // relevnat to MSMQ. When using msmq1.0 mqxplore, we can be sure
        // that nt4 format "full control" is indeed what we expect. But we
        // can't be sure for user code or nt5 ui. So to be on the safe side,
        // we just ignore extra bits that have no meaning for msmq.
        //
        dwMask = GENERIC_ALL_MAPPING;
    }
    else
    {
        //
        // Handle MSMQ1.0 specific rights which map to DS specific rights.
        //
        DWORD  *pdwMap = g_padwRightsMap4to5[dwObjectType];
        ASSERT(pdwMap);

        DWORD dwRightsIn =  dwMSMQRights;

        for (DWORD j = 0; j < NUMOF_MSMQ_SPECIFIC_RIGHTS; j++)
        {
            DWORD dwRight =  dwMSMQRights & 0x01;
            if (dwRight)
            {
                dwMask |= pdwMap[j];
            }
            dwMSMQRights >>= 1;
        }

        //
        // Copy the standard rights.
        //
        dwMSMQRights = dwRightsIn;
        DWORD dwStandard = dwMSMQRights & STANDARD_RIGHTS_ALL;
        dwMask |= dwStandard;
    }

    return dwMask;
}

//+--------------------------------
//
//  _BuildNt5ObjAce()
//
//+--------------------------------

static
HRESULT
_BuildNt5ObjAce( 
	DWORD  dwObjectType,
	BYTE   bType,
	BOOL   fSuccess,
	BOOL   fFail,
	PSID   pSid,
	DWORD  dwMSMQRights,
	PACL   pAcl5 
	)
{
    if (dwMSMQRights == g_dwFullControlNT4[dwObjectType])
    {
        //
        // for full-control ace, object aces are not needed.
        //
        return MQSec_OK;
    }

    struct RIGHTSMAP  *psMap = g_psExtendRightsMap5to4[dwObjectType];
    DWORD dwSize = g_pdwExtendRightsSize5to4[dwObjectType];

	//
	// The user can supply 0 rights. this is strange but acceptable
	//
//    ASSERT(dwMSMQRights != 0);
    DWORD dwMSMQBit = 0x01;

    for (DWORD j = 0; j < NUMOF_MSMQ_SPECIFIC_RIGHTS; j++)
    {
        DWORD dwRight =  dwMSMQRights & 0x01;
        if (dwRight)
        {
            for (DWORD k = 0; k < dwSize; k++)
            {
                if (psMap[k].dwPermission4to5 == dwMSMQBit)
                {
                    GUID *pRight = &(psMap[k].guidRight);
            
                    if (bType == ACCESS_ALLOWED_ACE_TYPE)
                    {
                        ASSERT(!fFail && !fSuccess);
                        if (!AddAccessAllowedObjectAce( 
								pAcl5,
								ACL_REVISION_DS,
								0,
								MSMQ_EXTENDED_RIGHT_MASK,
								pRight,
								NULL,
								pSid 
								))
                        {
							DWORD gle = GetLastError();
                    		TrERROR(SECURITY, "AddAccessAllowedObjectAce failed. Error: %!winerr!", gle);
                    		ASSERT(("AddAccessAllowedObjectAce failed", gle == ERROR_SUCCESS));
                    		return HRESULT_FROM_WIN32(gle);
                        }
                    }
                    else if (bType == ACCESS_DENIED_ACE_TYPE)
                    {
                        ASSERT(!fFail && !fSuccess);
                        if (!AddAccessDeniedObjectAce( 
								pAcl5,
								ACL_REVISION_DS,
								0,
								MSMQ_EXTENDED_RIGHT_MASK,
								pRight,
								NULL,
								pSid 
								))
                        {
							DWORD gle = GetLastError();
                    		TrERROR(SECURITY, "AddAccessDeniedObjectAce failed. Error: %!winerr!", gle);
                    		ASSERT(("AddAccessDeniedObjectAce failed", gle == ERROR_SUCCESS));
                    		return HRESULT_FROM_WIN32(gle);
                        }
                    }
                    else if (bType == SYSTEM_AUDIT_ACE_TYPE)
                    {
                        ASSERT(fFail || fSuccess);
                        if (!AddAuditAccessObjectAce( 
								pAcl5,
								ACL_REVISION_DS,
								0,
								MSMQ_EXTENDED_RIGHT_MASK,
								pRight,
								NULL,
								pSid,
								fSuccess,
								fFail 
								))
                        {
							DWORD gle = GetLastError();
                    		TrERROR(SECURITY, "AddAuditAccessObjectAce failed. Error: %!winerr!", gle);
                    		ASSERT(("AddAuditAccessObjectAce failed", gle == ERROR_SUCCESS));
                    		return HRESULT_FROM_WIN32(gle);
                        }
                    }
                    else
                    {
                        ASSERT(0);
                    }
                }
            }
        }

        dwMSMQRights >>= 1;
        dwMSMQBit <<= 1;
    }

    return MQSec_OK;
}

//+-------------------------------
//
//  void _SetAuditMasks()
//
//+-------------------------------

inline 
static
void 
_SetAuditMasks( 
	IN  SYSTEM_AUDIT_ACE *pAce,
	OUT ACCESS_MASK      *pdwFail,
	OUT ACCESS_MASK      *pdwSuccess 
	)
{
    BYTE bFlags = pAce->Header.AceFlags;

    if (bFlags & FAILED_ACCESS_ACE_FLAG)
    {
        *pdwFail = *pdwFail | pAce->Mask;
    }

    if (bFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
    {
        *pdwSuccess = *pdwSuccess | pAce->Mask;
    }
}

//+---------------------------------------------
//
//  static HRESULT _ConvertSaclToNT5Format()
//
//+---------------------------------------------

static
HRESULT 
_ConvertSaclToNT5Format( 
	IN  DWORD   dwObjectType,
	IN  PACL    pAcl4,
	OUT DWORD  *pdwAcl5Len,
	OUT PACL   *ppAcl5,
	OUT BOOL   *pfAlreadyNt5 
	)
{
    ASSERT(IsValidAcl(pAcl4));

	BOOL fAlreadyNT5 =  (pAcl4->AclRevision == ACL_REVISION_DS);
    *pfAlreadyNt5 = fAlreadyNT5;
    DWORD dwAclSize = (DWORD) pAcl4->AclSize;

	if (fAlreadyNT5)
    {
        //
        // Just copy the SACL to a new buffer.
        //
        *pdwAcl5Len = dwAclSize;
        *ppAcl5 = (PACL) new BYTE[*pdwAcl5Len];
        memcpy(*ppAcl5, pAcl4, *pdwAcl5Len);
        return MQSec_OK;
    }

    //
    // Allocate large buffer. We'll later shrink it.
    //
    *pdwAcl5Len = MQSEC_MAX_ACL_SIZE;
    AP<ACL> TempAcl = (PACL) new BYTE[*pdwAcl5Len];
    *ppAcl5 = TempAcl;
    if (!InitializeAcl(*ppAcl5, *pdwAcl5Len, ACL_REVISION_DS))
    {
		DWORD gle = GetLastError();
    	TrERROR(SECURITY, "InitializeAcl failed. Error: %!winerr!", gle);
    	ASSERT(("InitializeAcl failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }

    //
    // First, group aces by SID, then by audit type (fail or success).
    //
    // We build an array of SIDs that we handled up to now. We combine
    // aces of same sid into one ace. This operation does not change the
    // semantic of the acl, just make it more efficient.
    //
	DWORD dwNumberOfACEs = (DWORD) pAcl4->AceCount;
    SID  **ppSids4 = (SID**) new PSID[dwNumberOfACEs];
    aPtrs<SID> apSids(ppSids4, dwNumberOfACEs);
    DWORD    dwNumSids = 0;

    DWORD i = 0;

    do
    {
	    SYSTEM_AUDIT_ACE *pAce;
        if (!GetAce(pAcl4, i, (LPVOID* )&(pAce)))
        {
            TrERROR(SECURITY, "Failed to get ACE (index=%lu) while converting SACL from NT4 format. %!winerr!", i, GetLastError());
            return MQSec_E_SDCONVERT_GETACE ;
        }

        if (!_IsNewNt4Sid( 
				(ACCESS_ALLOWED_ACE*) pAce,
				ppSids4,
				&dwNumSids 
				))
        {
            i++;
            continue;
        }

        //
        // First ace in the group. Now look for contigous aces with same sid.
        //
        PSID pSid = (PSID) &(pAce->SidStart);

        ACCESS_MASK  dwMaskFail = 0;
        ACCESS_MASK  dwMaskSuccess = 0;
        _SetAuditMasks(pAce, &dwMaskFail, &dwMaskSuccess);

        i++;
        DWORD j = i;
        while (j < dwNumberOfACEs)
        {
            if (!GetAce(pAcl4, j, (LPVOID* )&(pAce)))
            {
                TrERROR(SECURITY, "Failed to get ACE (index=%lu) while looking for contigues ACE in the group. %!winerr!", i, GetLastError());
                return MQSec_E_SDCONVERT_GETACE ;
            }

            PSID pPresentSid = (PSID) &(pAce->SidStart);
            
            if (EqualSid(pSid, pPresentSid))
            {
                _SetAuditMasks(pAce, &dwMaskFail, &dwMaskSuccess);
            }
            j++;
        }

        //
        // Now we have a group of aces of same SID, and we have the masks.
        //
        BOOL fBuildObjAce = FALSE;
        do
        {
            if (fBuildObjAce)
            {
                if (dwMaskSuccess != 0)
                {
                    HRESULT hr = _BuildNt5ObjAce( 
							dwObjectType,
							SYSTEM_AUDIT_ACE_TYPE,
							TRUE,
							(dwMaskFail == dwMaskSuccess),
							pSid,
							dwMaskSuccess,
							*ppAcl5 
							);
                    if (FAILED(hr))
                    {
                    	TrERROR(SECURITY, "_BuildNt5ObjAce failed. Error: %!hresult!", hr);
                    	return hr;
                    }
                }

                if ((dwMaskFail != 0) && (dwMaskFail != dwMaskSuccess))
                {
                    HRESULT hr = _BuildNt5ObjAce( 
							dwObjectType,
							SYSTEM_AUDIT_ACE_TYPE,
							FALSE,    // success
							TRUE,     // failure
							pSid,
							dwMaskFail, 
							*ppAcl5 
							);
                    if (FAILED(hr))
                    {
						TrERROR(SECURITY, "_BuildNt5ObjAce failed. Error: %!hresult!", hr);
                    	return hr;
                    }
                }
            }
            else
            {
                DWORD dwMask = 0;

                if (dwMaskSuccess != 0)
                {
                    dwMask = _MapNt4RightsToNt5Ace(
								dwObjectType,
								dwMaskSuccess 
								);
                    if (dwMask != 0)
                    {
                        if (!AddAuditAccessAce( 
									*ppAcl5,
									ACL_REVISION_DS,
									dwMask,
									pSid,
									TRUE,     // success
									(dwMaskFail == dwMaskSuccess) 
									))
                        {
							DWORD gle = GetLastError();
	                    	TrERROR(SECURITY, "AddAuditAccessObjectAce failed. Error: %!winerr!", gle);
	                    	ASSERT(("AddAuditAccessObjectAce failed", gle == ERROR_SUCCESS));
	                    	return HRESULT_FROM_WIN32(gle);
                        }
                    }
                }

                if ((dwMaskFail != 0) && (dwMaskFail != dwMaskSuccess))
                {
                    dwMask = _MapNt4RightsToNt5Ace( 
									dwObjectType,
									dwMaskFail 
									);

                    if (dwMask != 0)
                    {
                        if (!AddAuditAccessAce( 
								*ppAcl5,
								ACL_REVISION_DS,
								dwMask,
								pSid,
								FALSE,     // success
								TRUE		// failure
								))
                        {
							DWORD gle = GetLastError();
	                    	TrERROR(SECURITY, "AddAuditAccessAce failed. Error: %!winerr!", gle);
	                    	return HRESULT_FROM_WIN32(gle);
                        }
                    }
                }
            }

            fBuildObjAce = !fBuildObjAce;
        }
        while (fBuildObjAce);
    }
    while (i < dwNumberOfACEs);

    BOOL fShrink = _ShrinkAcl(ppAcl5, pdwAcl5Len);
	DBG_USED(fShrink);
    ASSERT(fShrink);

    TempAcl.detach();

    return MQSec_OK;
}

//+--------------------------------
//
//  _BuildNt5Ace()
//
//+---------------------------------------------------------------------

static
HRESULT 
_BuildNt5Ace( 
	DWORD  dwObjectType,
	BYTE   bType,
	PSID   pSid,
	DWORD  dwMSMQRights,
	PACL   pAcl5 
	)
{
    DWORD dwMask = _MapNt4RightsToNt5Ace( 
						dwObjectType,
						dwMSMQRights 
						);

    if (dwMask == 0)
    {
		return LogHR(MQSec_E_CANT_MAP_NT5_RIGHTS, s_FN, 70);
    }
  
    //
    // Add MSMQ2.0 (NT5 DS) ACE.
    //
    if (bType == ACCESS_ALLOWED_ACE_TYPE)
    {
        if (!AddAccessAllowedAce( 
				pAcl5,
				ACL_REVISION_DS,
				dwMask,
				pSid 
				))
        {
			DWORD gle = GetLastError();
        	TrERROR(SECURITY, "AddAccessAllowedAce failed. Error: %!winerr!", gle);
        	ASSERT(("AddAccessAllowedAce failed", gle == ERROR_SUCCESS));
        	return HRESULT_FROM_WIN32(gle);
        }
    }
    else if (bType == ACCESS_DENIED_ACE_TYPE)
    {
        if (!AddAccessDeniedAce( 
				pAcl5,
				ACL_REVISION_DS,
				dwMask,
				pSid
				))
        {
			DWORD gle = GetLastError();
        	TrERROR(SECURITY, "AddAccessDeniedAce failed. Error: %!winerr!", gle);
        	ASSERT(("AddAccessDeniedAce failed", gle == ERROR_SUCCESS));
        	return HRESULT_FROM_WIN32(gle);
        }
    }
    else
    {
        ASSERT(0);
    }
   
    return MQSec_OK;
}

//+---------------------------------------
//
//  HRESULT _ConvertGroupOfDaclAces()
//
//  convert a group of ACEs, all of them having same type.
//
//+---------------------------------------

static
HRESULT 
_ConvertGroupOfDaclAces( 
	DWORD  dwObjectType,
	PACL   pAcl4,
	DWORD  iFirst,
	DWORD  iLast,
	PACL   pAcl5 
	)
{
    HRESULT hr = MQSec_OK;
	DWORD   dwNumberOfACEs = iLast - iFirst + 1;

    BOOL fBuildObjAce = FALSE;

    //
    // for each type (allow, deny, audit), the canonical form on NT5 is
    // first to put all ace then all object aces. So we have two phases:
    // one for ace, then the loop run again for obj aces.
    //

    do
    {
        //
        // We build an array of SIDs that we handled up to now. We combine
        // aces of same sid into one ace. This operation does not change the
        // semantic of the acl, just make it more efficient.
        //
        SID  **ppSids4 = (SID**) new PSID[dwNumberOfACEs];
        aPtrs<SID> apSids(ppSids4, dwNumberOfACEs);
        DWORD    dwNumSids = 0;

        DWORD i = iFirst;

        do
        {
	        ACCESS_ALLOWED_ACE *pAce;
            if (!GetAce(pAcl4, i, (LPVOID* )&(pAce)))
            {
                TrERROR(SECURITY, "Failed to get ACE (index=%lu) while combining same SID. %!winerr!", i, GetLastError());
                return MQSec_E_SDCONVERT_GETACE;
            }

            if (!_IsNewNt4Sid( 
					pAce,
					ppSids4,
					&dwNumSids 
					))
            {
                i++;
                continue;
            }

            //
            // this ace start a group of aces for a given sid.
            // on MSMQ1.0 we don't support inheritance of ace, so just OR the
            // masks of all  aces of this sid and create a NT5 ace.
            //
            BYTE bType = pAce->Header.AceType;
            PSID pSid = (PSID) &(pAce->SidStart);
            DWORD dwMSMQRights = pAce->Mask;

            DWORD j = i++;

            while (j <= iLast)
            {
                if (!GetAce(pAcl4, j, (LPVOID* )&(pAce)))
                {
                    TrERROR(SECURITY, "Failed to get ACE (index=%lu) while calculating NT5 ACE rights. %!winerr!", i, GetLastError());
                    return MQSec_E_SDCONVERT_GETACE;
                }

                PSID pPresentSid = (PSID) &(pAce->SidStart);
                if (EqualSid(pSid, pPresentSid))
                {
                    dwMSMQRights |= pAce->Mask;
                }
                j++;
            }

            if (fBuildObjAce)
            {
                hr = _BuildNt5ObjAce( 
							dwObjectType,
							bType,
							FALSE,
							FALSE,
							pSid,
							dwMSMQRights,
							pAcl5 
							);
            }
            else
            {
                hr = _BuildNt5Ace( 
							dwObjectType,
							bType,
							pSid,
							dwMSMQRights,
							pAcl5 
							);
            }
        }
        while (i <= iLast);

        fBuildObjAce = !fBuildObjAce;
    }
    while (fBuildObjAce);

    return MQSec_OK;
}

//+-----------------------------------------------------------------------
//
//  static HRESULT _ConvertDaclToNT5Format()
//
//  Parameters:
//      pfAlreadyNt5 - on input: status of SACL (TRUE if SACL is in nt5
//          format, FALSE otherwise).
//                     on return- status of DACL.
//
//+-----------------------------------------------------------------------

static
HRESULT 
_ConvertDaclToNT5Format( 
	IN  DWORD     dwObjectType,
	IN  PSID      pComputerSid,
	IN  PACL      pAcl4,
	OUT DWORD    *pdwAcl5Len,
	OUT PACL     *ppAcl5,
	IN OUT BOOL  *pfAlreadyNt5 
	)
{
    if (!pAcl4)
    {
        //
        // On NT4, NULL DACL mean full control to everyone.
        // From MSDN, AccessCheck():
        //    If the security descriptor's DACL is NULL, the AccessStatus
        //    parameter returns TRUE indicating that the client has the requested
        //    access
        //
        // Because the DACL is NULL, we don't have the revision flag, that
        // can tell us if caller meant NT4 format or NT5/DS format. So,
        // for backward compatibility, we'll translate this to full control
        // to everyone.
        // However, if SACL was Nt5 format then we don't add the full-control
        // ace. We assume the caller want nt5 semantic.
        //
    }

    HRESULT hr = MQSec_OK;

    BOOL fShrink ;
	BOOL fAlreadyNT5 = *pfAlreadyNt5;
    BOOL fOnlyCopy;
    BOOL fSystemAce = FALSE;
    BOOL fComputerAce = FALSE;

    hr = _AddMandatoryDenyACEs( 
				dwObjectType,
				pComputerSid,
				pAcl4,
				pdwAcl5Len,
				ppAcl5,
				&fAlreadyNT5,
				&fOnlyCopy,
				&fSystemAce,
				&fComputerAce 
				);

    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

	if (fAlreadyNT5)
    {
        *pfAlreadyNt5 = TRUE;
        if (!fOnlyCopy)
        {
            hr = _AddMandatoryAllowACEs( 
						pComputerSid,
						*ppAcl5,
						fSystemAce,
						fComputerAce 
						);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
            {
				TrERROR(SECURITY, "_AddMandatoryAllowACEs failed. Error: %!hresult!", hr);
				return hr;
            }

            fShrink = _ShrinkAcl(ppAcl5, pdwAcl5Len);
            ASSERT(fShrink);
        }
        ASSERT(IsValidAcl(*ppAcl5));
        return MQSec_OK;
    }
    *pfAlreadyNt5 = FALSE;

    DWORD dwNumberOfACEs = 0;

    if (pAcl4)
    {
        //
        // We're not assuming that the input acl is canonical. So we'll
        // handle groups of identical aces (i.e., aces of same type) at a
        // time. Each group will be converted to canonical NT5 format. So
        // if input is canonical, output will be canonical too.
        //
    	dwNumberOfACEs = (DWORD) pAcl4->AceCount;
    }
    else
    {
        ASSERT(*pfAlreadyNt5 == FALSE);

        //
        // NULL DACL. Transform into full control to everyone and anonymous.
		//

		//
		// everyone full control
        //
       if (!AddAccessAllowedAce( 
					*ppAcl5,
					ACL_REVISION_DS,
					GENERIC_ALL_MAPPING,
					g_pWorldSid 
					))
       	{
			DWORD gle = GetLastError();
        	TrERROR(SECURITY, "AddAccessAllowedAce failed. Error: %!winerr!", gle);
        	ASSERT(("AddAccessAllowedAce failed", gle == ERROR_SUCCESS));
        	return HRESULT_FROM_WIN32(gle);
       	}

		//
		// Anonymous full control
		//
        if (!AddAccessAllowedAce( 
					*ppAcl5,
					ACL_REVISION_DS,
					GENERIC_ALL_MAPPING,
					g_pAnonymSid
					))
        {
			DWORD gle = GetLastError();
        	TrERROR(SECURITY, "AddAccessAllowedAce failed. Error: %!winerr!", gle);
        	ASSERT(("AddAccessAllowedAce failed", gle == ERROR_SUCCESS));
        	return HRESULT_FROM_WIN32(gle);
        }
    }

    if (dwNumberOfACEs != 0)
    {
        DWORD i = 0;

        do
        {
            //
            // first ace in the group.
            //
	        ACCESS_ALLOWED_ACE *pAce;
            if (!GetAce(pAcl4, i, (LPVOID* )&(pAce)))
            {
                TrERROR(SECURITY, "Failed to get ACE (index=%lu) while converting DACL from NT4 format. %!winerr!", i, GetLastError());
                return MQSec_E_SDCONVERT_GETACE;
            }

            DWORD iFirst = i;
            DWORD iLast = i;
            BYTE bType = pAce->Header.AceType;
            i++;

            //
            // now look for other aces with same type.
            //
            while (i < dwNumberOfACEs)
            {
                if (!GetAce(pAcl4, i, (LPVOID* )&(pAce)))
                {
                    TrERROR(SECURITY, "Failed to get ACE (index=%lu) while looking for other ACEs with same type. %!winerr!", i, GetLastError());
                    return MQSec_E_SDCONVERT_GETACE ;
                }
                if (bType == pAce->Header.AceType)
                {
                    iLast = i;
                    i++;
                }
                else
                {
                    break;
                }
            }

            //
            // Handle all aces from iFirst to iLast.
            //
            hr = _ConvertGroupOfDaclAces( 
						dwObjectType,
						pAcl4,
						iFirst,
						iLast,
						*ppAcl5 
						);
        }
        while (i < dwNumberOfACEs);
    }

    hr = _AddMandatoryAllowACEs( 
				pComputerSid,
				*ppAcl5,
				fSystemAce,
				fComputerAce 
				);
	ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        TrERROR(SECURITY, "_AddMandatoryAllowACEs failed. Error: %!hresult!", hr);
        return hr;
    }

    fShrink = _ShrinkAcl(ppAcl5, pdwAcl5Len);
    ASSERT(fShrink);

    return MQSec_OK;
}

//+-----------------------------------------------------------------
//
//  HRESULT MQSec_ConvertSDToNT5Format()
//
//  Description: Convert a security descriptor from NT4 format to NT5
//      compatiblae format. Then add an DENIED_OBJECT_ACE, to deny
//      everyone the permission to change the "cn" attribute.
//      If security descriptor is already in NT5 format, then just add
//      the DENIED ace.
//
//  Parameters:
//      eUnDefaultDacl- When "e_MakeDaclNonDefaulted", the DaclDefaulted
//          flag will be set to FALSE. This is necessary when using
//          IDirectoryObject->CreateDSObject(). Otherwise, LDAP server will
//          ignore our dacl.
//      pComputerSid- SID of computer object. This sid must have read/write
//          rights on the msmqConfiguration object, in order for the msmq
//          service on that computer to boot correctly.
//
//+-----------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_ConvertSDToNT5Format(
	IN  DWORD                 dwObjectType,
	IN  SECURITY_DESCRIPTOR  *pSD4,
	OUT DWORD                *pdwSD5Len,
	OUT SECURITY_DESCRIPTOR **ppSD5,
	IN  enum  enumDaclDefault eUnDefaultDacl,
	IN  PSID                  pComputerSid 
	)
{
    HRESULT hr = MQSec_OK;

    if (!pSD4)
    {
        ASSERT(0) ;
        return LogHR(MQSec_E_NULL_SD, s_FN, 130);
    }
    else if (!IsValidSecurityDescriptor(pSD4))
    {
        TrERROR(SECURITY, "Can't convert an invalid NT4 Security Descriptor");
        ASSERT(0);
        return MQSec_E_SD_NOT_VALID;
    }

    //
    // Make sure input descriptor is self-relative.
    //
    DWORD dwRevision = 0;
    SECURITY_DESCRIPTOR_CONTROL sdC;
    if (!GetSecurityDescriptorControl(pSD4, &sdC, &dwRevision))
    {
		DWORD gle = GetLastError();
    	TrERROR(SECURITY, "GetSecurityDescriptorControl failed. Error: %!winerr!", gle);
    	ASSERT(("GetSecurityDescriptorControl failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }

    if (!(sdC & SE_SELF_RELATIVE))
    {
        TrERROR(SECURITY, "Can't convert a non self-relative NT4 Security Descriptor");
        return MQSec_E_NOT_SELF_RELATIVE;
    }

    if (eUnDefaultDacl == e_MakeDaclNonDefaulted)
    {
        //
        // Mark the DACL as non-defaulted. that's a hack, not supported
        // by Win32 api.
        //
        ASSERT(pSD4->Control == sdC);
        sdC &= ~SE_DACL_DEFAULTED;
        pSD4->Control = sdC;
    }

    if ((dwObjectType != MQDS_QUEUE)   &&
        (dwObjectType != MQDS_MACHINE) &&
        (dwObjectType != MQDS_MQUSER)  &&
        (dwObjectType != MQDS_SITE)    &&
        (dwObjectType != MQDS_CN)      &&
        (dwObjectType != MQDS_ENTERPRISE))
    {
        //
        // BUGBUG Temporary.
        //
        return LogHR(MQSec_I_SD_CONV_NOT_NEEDED, s_FN, 160);
    }
    
   	SECURITY_DESCRIPTOR sd;

   	if (!InitializeSecurityDescriptor( 
					&sd,
					SECURITY_DESCRIPTOR_REVISION 
					))
    {
        TrERROR(SECURITY, "Can't initialize security descriptor while converting from NT4 to NT5 format. %!winerr!", GetLastError());
        return MQSec_E_INIT_SD;
    }

    //
    // Handle owner.
    //
    PSID pOwner = NULL;
    BOOL bOwnerDefaulted;

    if (!GetSecurityDescriptorOwner( 
				pSD4,
				&pOwner,
				&bOwnerDefaulted 
				))
    {
		DWORD gle = GetLastError();
    	TrERROR(SECURITY, "GetSecurityDescriptorOwner failed. Error: %!winerr!", gle);
    	ASSERT(("GetSecurityDescriptorOwner failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }
    
    if (pOwner != NULL)
    {
        ASSERT(IsValidSid(pOwner));

        //
        // BUGBUG
        // If this is a local user, set the owner to be the anonymous
        // logon user.
        //
        if (!SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted))
        {
			DWORD gle = GetLastError();
    		TrERROR(SECURITY, "GetSecurityDescriptorOwner failed. Error: %!winerr!", gle);
    		ASSERT(("GetSecurityDescriptorOwner failed", gle == ERROR_SUCCESS));
    		return HRESULT_FROM_WIN32(gle);
        }
    }
    else
    {
        //
        // that's legitimate. When fixing 5286, we remove the owner component
        // from the security descriptor, unless caller supply his own
        // descriptor. We let the active directory server to add the owner
        // by itself.
        //
    }

    //
    // Handle group
    //
    PSID pGroup = NULL;
    BOOL bGroupDefaulted;

    if (!GetSecurityDescriptorGroup( 
				pSD4,
				&pGroup,
				&bGroupDefaulted 
				))
    {
		DWORD gle = GetLastError();
    	TrERROR(SECURITY, "GetSecurityDescriptorGroup failed. Error: %!winerr!", gle);
    	ASSERT(("GetSecurityDescriptorGroup failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }

    if (pGroup != NULL)
    {
        ASSERT(IsValidSid(pGroup));

        if (!SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted))
        {
			DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "SetSecurityDescriptorGroup failed. Error: %!winerr!", gle);
	    	ASSERT(("SetSecurityDescriptorGroup failed", gle == ERROR_SUCCESS));
	    	return HRESULT_FROM_WIN32(gle);
        }
    }
    else
    {
        ASSERT((dwObjectType == MQDS_MQUSER) ||
               (dwObjectType == MQDS_QUEUE) ||
               (dwObjectType == MQDS_SITE) ||
               (dwObjectType == MQDS_MACHINE));
    }

    //
    // Handle SACL
    //
    BOOL  bPresent;
    BOOL  bDefaulted;
    DWORD dwAclLen;
    PACL  pAcl4;
    P<ACL> pDacl5 = NULL;
    P<ACL> pSacl5 = NULL;
    BOOL fSaclAlreadyNt5 = FALSE;

    if (!GetSecurityDescriptorSacl( 
				pSD4,
				&bPresent,
				&pAcl4,
				&bDefaulted 
				))
    {
		DWORD gle = GetLastError();
    	TrERROR(SECURITY, "GetSecurityDescriptorSacl failed. Error: %!winerr!", gle);
    	ASSERT(("GetSecurityDescriptorSacl failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }

    hr = MQSec_OK;
    if (bPresent)
    {
        if (pAcl4)
        {
	        DWORD dwNumberOfACEs = (DWORD) pAcl4->AceCount;
        	if (dwNumberOfACEs == 0)
            {
                //
                // this may happen in mmc, when you "protect" the
                // sacl and remove inherited ACE. If sacl remain without
                // aces, then we get here. So actually, we don't have
                // any sacl.
                //
                bPresent = FALSE;
            }
            else
            {
                hr = _ConvertSaclToNT5Format( 
							dwObjectType,
							pAcl4,
							&dwAclLen,
							&pSacl5,
							&fSaclAlreadyNt5 
							);

                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 180);
                }
                ASSERT(IsValidAcl(pSacl5));
            }
        }
        else
        {
            //
            // See secd5to4.cpp for explanation.
            //
            bPresent = FALSE;
        }
    }

    if (!SetSecurityDescriptorSacl( 
				&sd,
				bPresent,
				pSacl5,
				bDefaulted
				))
    {
		DWORD gle = GetLastError();
    	TrERROR(SECURITY, "SetSecurityDescriptorSacl failed. Error: %!winerr!", gle);
    	ASSERT(("SetSecurityDescriptorSacl failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }

    //
    // Handle inheritance. If descriptor was in Nt4 format, then enable
    // inheritance by default.
    //
    if (fSaclAlreadyNt5 || (sdC & SE_SACL_PROTECTED))
    {
        //
        // Propagate the control word from input descriptor.
        // The mmc always return sacl with nt4 version, so check the
        // protected flag too. this flag is specific to win2k.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask =  SE_SACL_AUTO_INHERIT_REQ |
                                              SE_SACL_AUTO_INHERITED   |
                                              SE_SACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = sdC & scMask;

        if (!SetSecurityDescriptorControl(&sd, scMask, scSet))
        {
			DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "SetSecurityDescriptorControl failed. Error: %!winerr!", gle);
	    	return HRESULT_FROM_WIN32(gle);
        }
    }
    else
    {
        //
        // sacl was nt4. Enable inheritance.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask = SE_SACL_AUTO_INHERIT_REQ | SE_SACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = SE_SACL_AUTO_INHERIT_REQ;

        if (!SetSecurityDescriptorControl(&sd, scMask, scSet))
		{
			DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "SetSecurityDescriptorControl failed. Error: %!winerr!", gle);
	    	return HRESULT_FROM_WIN32(gle);
        }    
    }

    //
    // Handle DACL
    //
    //
    if (!GetSecurityDescriptorDacl( 
				pSD4,
				&bPresent,
				&pAcl4,
				&bDefaulted 
				))
    {
		DWORD gle = GetLastError();
    	TrERROR(SECURITY, "GetSecurityDescriptorDacl failed. Error: %!winerr!", gle);
    	ASSERT(("GetSecurityDescriptorDacl failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }

    hr = MQSec_OK;
    BOOL fDaclAlreadyNt5 = fSaclAlreadyNt5;

    if (bPresent)
    {
        hr = _ConvertDaclToNT5Format( 
				dwObjectType,
				pComputerSid,
				pAcl4,
				&dwAclLen,
				&pDacl5,
				&fDaclAlreadyNt5 
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 190);
        }
    }

    if (!SetSecurityDescriptorDacl(
				&sd,
				bPresent,
				pDacl5,
				bDefaulted
				))
    {
    	DWORD gle = GetLastError();
    	TrERROR(SECURITY, "SetSecurityDescriptorDacl failed. Error: %!winerr!", gle);
    	ASSERT(("SetSecurityDescriptorDacl failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }

    //
    // Handle inheritance. If descriptor was in Nt4 format, then enable
    // inheritance by default.
    //
    if (fDaclAlreadyNt5)
    {
        //
        // Propagate the control word from input descriptor.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask =  SE_DACL_AUTO_INHERIT_REQ |
                                              SE_DACL_AUTO_INHERITED   |
                                              SE_DACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = sdC & scMask;

        if (!SetSecurityDescriptorControl(&sd, scMask, scSet))
        {
			DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "SetSecurityDescriptorControl failed. Error: %!winerr!", gle);
	    	return HRESULT_FROM_WIN32(gle);
        }
    }
    else
    {
        //
        // dacl was nt4. Enable inheritance.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask = SE_DACL_AUTO_INHERIT_REQ | SE_DACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = SE_DACL_AUTO_INHERIT_REQ;

        if (!SetSecurityDescriptorControl(&sd, scMask, scSet))
        {
			DWORD gle = GetLastError();
	    	TrERROR(SECURITY, "SetSecurityDescriptorControl failed. Error: %!winerr!", gle);
	    	return HRESULT_FROM_WIN32(gle);
        }
    }

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwLen = 0;
    MakeSelfRelativeSD(&sd, NULL, &dwLen);
    DWORD gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER)
    {
    	TrERROR(SECURITY, "MakeSelfRelativeSD failed. Error: %!winerr!", gle);
    	return HRESULT_FROM_WIN32(gle);
    }
    
	AP<SECURITY_DESCRIPTOR> TempSd = (SECURITY_DESCRIPTOR*) new char[dwLen];
    if (!MakeSelfRelativeSD(&sd, TempSd, &dwLen))
    {
		gle = GetLastError();
    	TrERROR(SECURITY, "MakeSelfRelativeSD failed. Error: %!winerr!", gle);
    	ASSERT(("MakeSelfRelativeSD failed", gle == ERROR_SUCCESS));
    	return HRESULT_FROM_WIN32(gle);
    }
    *ppSD5 = TempSd.detach();

    *pdwSD5Len = dwLen;

    return MQSec_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\stdh_acs.cpp ===
//++
//
// Copyright (c) 1997-1999 Microsoft Coroporation
//
// Module Name  : stdh_acs.h
//
// Abstract     : Security related definitions
//
// History:  Doron Juster (DoronJ), Created
//
//--

#include <stdh_sec.h>
#include "acssctrl.h"

#include "stdh_acs.tmh"

GUID  g_guidCreateQueue =
  { 0x9a0dc343, 0xc100, 0x11d1,
                   { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 }} ;

//
// Map between NT5 DS extended rights and MSMQ1.0 specific rights.
// An extended right is a GUID which represent one MSMQ1.0 specific right.
//

struct RIGHTSMAP  sMachineRightsMap5to4[] = {

  { 0x4b6e08c0, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_DEADLETTER_MESSAGE,
    MQSEC_DELETE_DEADLETTER_MESSAGE },

  { 0x4b6e08c1, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_PEEK_DEADLETTER_MESSAGE,
    MQSEC_PEEK_DEADLETTER_MESSAGE },

  { 0x4b6e08c2, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE,
    MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE },

  { 0x4b6e08c3, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE,
    MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE }

                                 } ;

struct RIGHTSMAP  sQueueRightsMap5to4[] = {

  { 0x06bd3200, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_MESSAGE,
    MQSEC_DELETE_MESSAGE },

  { 0x06bd3201, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_PEEK_MESSAGE,
    MQSEC_PEEK_MESSAGE },

  { 0x06bd3202, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_WRITE_MESSAGE,
    MQSEC_WRITE_MESSAGE },

  { 0x06bd3203, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_JOURNAL_MESSAGE,
    MQSEC_DELETE_JOURNAL_MESSAGE }

                                      } ;

struct RIGHTSMAP  sCnRightsMap5to4[] = {

  { 0xb4e60130, 0xdf3f, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_CN_OPEN_CONNECTOR,
    MQSEC_CN_OPEN_CONNECTOR }

    } ;

struct RIGHTSMAP  *g_psExtendRightsMap5to4[] = {
                                     NULL,
                                     sQueueRightsMap5to4,   // queue
                                     sMachineRightsMap5to4, // machine
                                     sCnRightsMap5to4,      // site
                                     NULL,                  // delete obj
                                     sCnRightsMap5to4,      // cn
                                     NULL,                  // enterprise
                                     NULL,                  // user
                                     NULL } ;               // site link

DWORD  g_pdwExtendRightsSize5to4[] = {
                                     0,
           sizeof(sQueueRightsMap5to4) /  sizeof(sQueueRightsMap5to4[0]),
           sizeof(sMachineRightsMap5to4) / sizeof(sMachineRightsMap5to4[0]),
           sizeof(sCnRightsMap5to4) / sizeof(sCnRightsMap5to4[0]),   // site
                                     0,                  // delete obj
          sizeof(sCnRightsMap5to4) / sizeof(sCnRightsMap5to4[0]),   // cn
                                     0,                  // enterprise
                                     0,                  // user
                                     0 } ;               // site link

//
// Map between NT5 DS specific rights and MSMQ1.0 specific rights.
// Index in this table is the NT5 DS specific right. See defintions of
// DS specific rights in permit.h
//

static DWORD  s_adwQueueRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_QUEUE_PROPERTIES,
                                      MQSEC_SET_QUEUE_PROPERTIES,
                                      0,
                                      0,
                                      QUEUE_EXTENDED_RIGHTS } ;

static DWORD  s_adwMachineRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      MQSEC_CREATE_QUEUE,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_MACHINE_PROPERTIES,
                                      MQSEC_SET_MACHINE_PROPERTIES,
                                      0,
                                      0,
                                      MACHINE_EXTENDED_RIGHTS } ;

static DWORD  s_adwEntRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_ENTERPRISE_PROPERTIES,
                                      MQSEC_SET_ENTERPRISE_PROPERTIES,
                                      0,
                                      0,
                                      0 } ;

//
// Bug 5819 - added SITE_EXTENDED_RIGHTS to site
// YoelA - 10/31/01
// 
static DWORD  s_adwSiteRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      MQSEC_CREATE_MACHINE,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_SITE_PROPERTIES,
                                      MQSEC_SET_SITE_PROPERTIES,
                                      0,
                                      0,
                                      0 } ;

static DWORD  s_adwCnRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_CN_PROPERTIES,
                                      MQSEC_SET_CN_PROPERTIES,
                                      0,
                                      0,
                                      CN_EXTENDED_RIGHTS } ;

DWORD  *g_padwRightsMap5to4[ ] = {
                              NULL,
                              s_adwQueueRightsMap5to4,   // queue
                              s_adwMachineRightsMap5to4, // machine
                              s_adwSiteRightsMap5to4,    // site
                              NULL,                      // delete obj
                              s_adwCnRightsMap5to4,      // cn
                              s_adwEntRightsMap5to4,     // enterprise
                              NULL,                      // user
                              NULL } ;                   // site link

//
// hold the "full control" bits for every object type in MSMQ1.0
//

DWORD  g_dwFullControlNT4[ ] = {
                              0,
                              MQSEC_QUEUE_GENERIC_ALL,       // queue
                              MQSEC_MACHINE_GENERIC_ALL,     // machine
                              MQSEC_SITE_GENERIC_ALL,        // site
                              0,                             // delete obj
                              MQSEC_CN_GENERIC_ALL,          // cn
                              MQSEC_ENTERPRISE_GENERIC_ALL,  // enterprise
                              0,                             // user
                              0 } ;                          // site link

//
// Map between NT4 MSMQ1.0 specific rights and NT5 DS specific rughts.
// Index in this table is the MSMQ1.0 specific right. See defintions of
// MSMQ specific rights in mqsec.h
//

static DWORD  s_adwQueueRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

static DWORD  s_adwMachineRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      RIGHT_DS_CREATE_CHILD,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY | RIGHT_DS_LIST_CONTENTS,
                                      0,
                                      0 } ;

static DWORD  s_adwEntRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

static DWORD  s_adwSiteRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      RIGHT_DS_CREATE_CHILD,
                                      RIGHT_DS_CREATE_CHILD,
                                      RIGHT_DS_CREATE_CHILD,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

static DWORD  s_adwCnRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

DWORD  *g_padwRightsMap4to5[ ] = {
                              NULL,
                              s_adwQueueRightsMap4to5,   // queue
                              s_adwMachineRightsMap4to5, // machine
                              s_adwSiteRightsMap4to5,    // site
                              NULL,                      // delete obj
                              s_adwCnRightsMap4to5,      // cn
                              s_adwEntRightsMap4to5,     // enterprise
                              NULL,                      // user
                              NULL } ;                   // site link
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\secdscrp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: secdscrp.cpp

Abstract:
    Code to handle operations on security descriptor.
    First version taken from mqutil\secutils.cpp

Author:
    Doron Juster (DoronJ)  01-Jul-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include <mqdsdef.h>
#include "..\inc\permit.h"
#include <mqsec.h>
#include <tr.h>

#include "secdscrp.tmh"

static WCHAR *s_FN=L"acssctrl/secdscrp";

//
// Generic mappings of the various objects.
//
static GENERIC_MAPPING g_QueueGenericMapping;
static GENERIC_MAPPING g_MachineGenericMapping;
static GENERIC_MAPPING g_SiteGenericMapping;
static GENERIC_MAPPING g_CNGenericMapping;
static GENERIC_MAPPING g_EnterpriseGenericMapping;

//
// The computer generic mapping is used to check if user can create the
// msmqConfiguration object. this is part of setup and "join domain", and
// it solve bug 6294 and avoid the need for the "add-guid" permission.
//
static GENERIC_MAPPING g_ComputerGenericMapping;

//+----------------------------------------------------------------
//
// Function:   GetObjectGenericMapping()
//
// Description:
//      Get a pointer to the generic mapping of a certain object type.
//
// Parameter:
//      dwObjectType - The type of the object.
//
// Return Value:
//      A pointer to a GENERIC_MAPPING structure.
//
//+----------------------------------------------------------------

PGENERIC_MAPPING
GetObjectGenericMapping(
	DWORD dwObjectType
	)
{
    switch(dwObjectType)
    {
		case MQDS_QUEUE:
			return(&g_QueueGenericMapping);

		case MQDS_MACHINE:
		case MQDS_MSMQ10_MACHINE:
			return(&g_MachineGenericMapping);

		case MQDS_SITE:
			return(&g_SiteGenericMapping);

		case MQDS_CN:
			return(&g_CNGenericMapping);

		case MQDS_ENTERPRISE:
			return(&g_EnterpriseGenericMapping);

		case MQDS_COMPUTER:
			return(&g_ComputerGenericMapping);
    }

    ASSERT(FALSE);
    return(NULL);
}

//+--------------------------------------
//
//  void InitializeGenericMapping()
//
//+--------------------------------------

void InitializeGenericMapping()
{
    g_QueueGenericMapping.GenericRead = MQSEC_QUEUE_GENERIC_READ;
    g_QueueGenericMapping.GenericWrite = MQSEC_QUEUE_GENERIC_WRITE;
    g_QueueGenericMapping.GenericExecute = MQSEC_QUEUE_GENERIC_EXECUTE;
    g_QueueGenericMapping.GenericAll = MQSEC_QUEUE_GENERIC_ALL;

    g_MachineGenericMapping.GenericRead = MQSEC_MACHINE_GENERIC_READ;
    g_MachineGenericMapping.GenericWrite = MQSEC_MACHINE_GENERIC_WRITE;
    g_MachineGenericMapping.GenericExecute = MQSEC_MACHINE_GENERIC_EXECUTE;
    g_MachineGenericMapping.GenericAll = MQSEC_MACHINE_GENERIC_ALL;

    g_SiteGenericMapping.GenericRead = MQSEC_SITE_GENERIC_READ;
    g_SiteGenericMapping.GenericWrite = MQSEC_SITE_GENERIC_WRITE;
    g_SiteGenericMapping.GenericExecute = MQSEC_SITE_GENERIC_EXECUTE;
    g_SiteGenericMapping.GenericAll = MQSEC_SITE_GENERIC_ALL;

    g_CNGenericMapping.GenericRead = MQSEC_CN_GENERIC_READ;
    g_CNGenericMapping.GenericWrite = MQSEC_CN_GENERIC_WRITE;
    g_CNGenericMapping.GenericExecute = MQSEC_CN_GENERIC_EXECUTE;
    g_CNGenericMapping.GenericAll = MQSEC_CN_GENERIC_ALL;

    g_EnterpriseGenericMapping.GenericRead = MQSEC_ENTERPRISE_GENERIC_READ;
    g_EnterpriseGenericMapping.GenericWrite = MQSEC_ENTERPRISE_GENERIC_WRITE;
    g_EnterpriseGenericMapping.GenericExecute = MQSEC_ENTERPRISE_GENERIC_EXECUTE;
    g_EnterpriseGenericMapping.GenericAll = MQSEC_ENTERPRISE_GENERIC_ALL;

    g_ComputerGenericMapping.GenericRead = GENERIC_READ_MAPPING;
    g_ComputerGenericMapping.GenericWrite = GENERIC_WRITE_MAPPING;
    g_ComputerGenericMapping.GenericExecute = GENERIC_EXECUTE_MAPPING;
    g_ComputerGenericMapping.GenericAll = GENERIC_ALL_MAPPING;

}

//+-------------------------------------------------------------
//
//  HRESULT  MQSec_MakeSelfRelative()
//
//  Convert a security descriptor into self relative format.
//
//+-------------------------------------------------------------

HRESULT
APIENTRY
MQSec_MakeSelfRelative(
    IN  PSECURITY_DESCRIPTOR   pIn,
    OUT PSECURITY_DESCRIPTOR  *ppOut,
    OUT DWORD                 *pdwSize
	)
{
    DWORD dwLen = 0;
    BOOL fSucc = MakeSelfRelativeSD(
		            pIn,
		            NULL,
		            &dwLen
		            );

    DWORD dwErr = GetLastError();
    if (!fSucc && (dwErr == ERROR_INSUFFICIENT_BUFFER))
    {
        *ppOut = (PSECURITY_DESCRIPTOR) new char[dwLen];
        if(!MakeSelfRelativeSD(pIn, *ppOut, &dwLen))
        {
			DWORD gle = GetLastError();
            TrERROR(SECURITY, "Failed to convert security descriptor to self-relative format. %!winerr!", gle);
			ASSERT(("MakeSelfRelativeSD failed", 0));
            return MQSec_E_CANT_SELF_RELATIVE;
        }
    }
    else
    {
        TrERROR(SECURITY, "Can't get the SD length required to convert SD to self-relative. %!winerr!", dwErr);
        return MQSec_E_MAKESELF_GETLEN;
    }

    if (pdwSize)
    {
        *pdwSize = dwLen;
    }
    return MQ_OK;
}

//+----------------------------------------------------------------------
//
// Function: MQSec_GetDefaultSecDescriptor()
//
// Description: Create a default security descriptor.
//
// Parameters:
//      dwObjectType - The type of the object (MSDS_QUEUE, ...).
//      ppSecurityDescriptor - A pointer to a buffer that receives the
//          pointer to the created security descriptor.
//      fImpersonate - Should be set to TRUE, when the function should be
//          called on behalf of an RPC call.
//      pInSecurityDescriptor - An optional parameter. Any specified part
//          of this parameter is put in the resulted security descriptor.
//      seInfoToRemove - Specify the components that the caller does not
//          want to be included in the output security descriptor.
//        Note: at present only owner, group and DACL are handled.
//
// Comments:
//      At present we create a descriptor with NT4 format. The MSMQ service
//      convert it to NT5 format before inserting in the NT5 DS.
//
//      If fImpersonate is set to true, the security descriptor will be
//      created acording to the user that originated the call via RPC
//
//      It is the responsibility of the calling code to free the allocated
//      memory for the security descriptor using delete.
//
//      CAUTION: If you change implementation here to use mqutil's registry
//      routines, make sure all clients of this routine are not broken,
//      especially in mqclus.dll (where registry access should be
//      synchronized).   (ShaiK, 20-Apr-1999)
//
//+----------------------------------------------------------------------

HRESULT
APIENTRY
MQSec_GetDefaultSecDescriptor(
	IN  DWORD                 dwObjectType,
	OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
	IN  BOOL                  fImpersonate,
	IN  PSECURITY_DESCRIPTOR  pInSecurityDescriptor,
	IN  SECURITY_INFORMATION  seInfoToRemove,
	IN  enum  enumDaclType    eDaclType,
	IN  PSID  pMachineSid /* = NULL */
	)
{
	TrTRACE(SECURITY, "ObjectType = %d, fImpersonate = %d, InfoToRemove = 0x%x, DaclType = %d", dwObjectType, fImpersonate, seInfoToRemove, eDaclType);

    CAutoCloseHandle hUserToken;
    DWORD gle1 = GetAccessToken(&hUserToken, fImpersonate);
    if (gle1 != ERROR_SUCCESS)
    {
		TrERROR(SECURITY, "GetAccessToken failed, gle = %!winerr!", gle1);
		return HRESULT_FROM_WIN32(gle1);
    }

    SECURITY_DESCRIPTOR sd;
    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "InitializeSecurityDescriptor failed, gle = %!winerr!", gle);
		ASSERT(("InitializeSecurityDescriptor failed", 0));
		return HRESULT_FROM_WIN32(gle);
    }

    PSID pOwner = NULL;
    PSID pGroup = NULL;
    BOOL bDaclPresent = FALSE;
    BOOL bOwnerDefaulted = FALSE;
    BOOL bGroupDefaulted = FALSE;
    if (pInSecurityDescriptor != NULL)
    {
        if (!IsValidSecurityDescriptor(pInSecurityDescriptor))
        {
			TrERROR(SECURITY, "IsValidSecurityDescriptor failed") ;
			ASSERT(("IsValidSecurityDescriptor failed", 0));
			return MQ_ERROR ;
        }

        DWORD dwRevision;
        SECURITY_DESCRIPTOR_CONTROL sdcSrc;

        if(!GetSecurityDescriptorControl(
					pInSecurityDescriptor,
					&sdcSrc,
					&dwRevision
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorControl failed, gle = %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorControl failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }

        //
        // Retrieve the values from the passed security descriptor.
        //

        if(!GetSecurityDescriptorOwner(
					pInSecurityDescriptor,
					&pOwner,
					&bOwnerDefaulted
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorOwner failed, gle = %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorOwner failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }

		TrTRACE(SECURITY, "OwnerSid = %!sid!, OwnerDefaulted = %d", pOwner, bOwnerDefaulted);

        if(!GetSecurityDescriptorGroup(
					pInSecurityDescriptor,
					&pGroup,
					&bGroupDefaulted
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorGroup failed, gle = %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorGroup failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }

		TrTRACE(SECURITY, "GroupSid = %!sid!, GroupDefaulted = %d", pGroup, bGroupDefaulted);

	    BOOL bDefaulted;
        PACL pDacl;
        if(!GetSecurityDescriptorDacl(
					pInSecurityDescriptor,
					&bDaclPresent,
					&pDacl,
					&bDefaulted
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorDacl failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }

        if (bDaclPresent)
        {
            //
            // In case a DACL exist, put it now in the result descriptor.
            //
            if(!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, bDefaulted))
	        {
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "SetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
				ASSERT(("SetSecurityDescriptorDacl failed", 0));
				return HRESULT_FROM_WIN32(gle);
	        }

            if (eDaclType == e_UseDefDaclAndCopyControl)
            {
                SECURITY_DESCRIPTOR_CONTROL scMask =
                                              SE_DACL_AUTO_INHERIT_REQ |
                                              SE_DACL_AUTO_INHERITED   |
                                              SE_DACL_PROTECTED;

                SECURITY_DESCRIPTOR_CONTROL sdc = sdcSrc & scMask;

                if(!SetSecurityDescriptorControl(
						&sd,
						scMask,
						sdc
						))
		        {
					DWORD gle = GetLastError();
					TrERROR(SECURITY, "SetSecurityDescriptorControl failed, gle = %!winerr!", gle);
					ASSERT(("SetSecurityDescriptorControl failed", 0));
					return HRESULT_FROM_WIN32(gle);
		        }
            }
        }

        //
        // Pass the SACL as it is to the result descriptor.
        //
        PACL pSacl;
        BOOL bPresent = FALSE;
        if(!GetSecurityDescriptorSacl(
					pInSecurityDescriptor,
					&bPresent,
					&pSacl,
					&bDefaulted
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorSacl failed, gle = %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorSacl failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }

        if(!SetSecurityDescriptorSacl(&sd, bPresent, pSacl, bDefaulted))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "SetSecurityDescriptorSacl failed, gle = %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorSacl failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }

        if (bPresent && (eDaclType == e_UseDefDaclAndCopyControl))
        {
            SECURITY_DESCRIPTOR_CONTROL scMask =
                                          SE_SACL_AUTO_INHERIT_REQ |
                                          SE_SACL_AUTO_INHERITED   |
                                          SE_SACL_PROTECTED;

            SECURITY_DESCRIPTOR_CONTROL sdc = sdcSrc & scMask;

            if(!SetSecurityDescriptorControl(
					&sd,
					scMask,
					sdc
					))
	        {
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "SetSecurityDescriptorControl failed, gle = %!winerr!", gle);
				ASSERT(("SetSecurityDescriptorControl failed", 0));
				return HRESULT_FROM_WIN32(gle);
	        }
        }
    }

    DWORD dwLen;
    AP<char> ptu;
    AP<char> ptg;
    AP<char> DACL_buff;

    if (pOwner == NULL)
    {
		//
        // Set the owner SID from the access token as the descriptor's owner SID.
		//
        GetTokenInformation(hUserToken, TokenUser, NULL, 0, &dwLen);
        DWORD gle = GetLastError();
        if (gle == ERROR_INSUFFICIENT_BUFFER)
        {
            ptu = new char[dwLen];
            if(!GetTokenInformation(hUserToken, TokenUser, ptu, dwLen, &dwLen))
            {
				gle = GetLastError();
				TrERROR(SECURITY, "GetTokenInformation(TokenUser) failed, gle = %!winerr!", gle);
				ASSERT(("GetTokenInformation(TokenUser) failed", 0));
				return HRESULT_FROM_WIN32(gle);
            }

            pOwner = ((TOKEN_USER*)(char*)ptu)->User.Sid;
			TrTRACE(SECURITY, "OwnerSid = %!sid!", pOwner);
        }
        else
        {
            TrERROR(SECURITY, "GetTokenInformation(TokenUser) failed,  gle = %!winerr!", gle);
			return HRESULT_FROM_WIN32(gle);
        }
        bOwnerDefaulted = TRUE;
    }

    BOOL fIncludeGroup = TRUE;
    if ((seInfoToRemove & GROUP_SECURITY_INFORMATION) ==
                                               GROUP_SECURITY_INFORMATION)
    {
        fIncludeGroup = FALSE;
    }

    if ((pGroup == NULL) && fIncludeGroup)
    {
        // Set the primary group SID from the access token as the descriptor's
        // primary group SID.
        GetTokenInformation(hUserToken, TokenPrimaryGroup, NULL, 0, &dwLen);
        DWORD gle = GetLastError();
        if (gle == ERROR_INSUFFICIENT_BUFFER)
        {
            ptg = new char[dwLen];
            if(!GetTokenInformation(hUserToken, TokenPrimaryGroup, ptg, dwLen, &dwLen))
            {
				gle = GetLastError();
				TrERROR(SECURITY, "GetTokenInformation(TokenPrimaryGroup) failed, gle = %!winerr!", gle);
				ASSERT(("GetTokenInformation(TokenPrimaryGroup) failed", 0));
				return HRESULT_FROM_WIN32(gle);
            }
            	
            pGroup = ((TOKEN_PRIMARY_GROUP*)(char*)ptg)->PrimaryGroup;
			TrTRACE(SECURITY, "GroupSid = %!sid!", pGroup);
        }
        else
        {
            TrERROR(SECURITY, "GetTokenInformation(TokenPrimaryGroup) failed,  gle = %!winerr!", gle);
			return HRESULT_FROM_WIN32(gle);
        }
        bGroupDefaulted = TRUE;
    }

    //
    // If this is a local user, set the owner to Anonymous.
	// ISSUE-2001/08/9-ilanh - We can consider not overwrite pOwner for local user.
	// This might be useful in workgroup or for all private queues.
	// you will get the local user that created the queue as owner and not Anonymous as owner.
	// currently every queue you create in workgroup you will get Anonymous as Owner.
    //
    BOOL fLocalUser = FALSE;

    HRESULT hr = MQSec_GetUserType(pOwner, &fLocalUser, NULL);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    else if (fLocalUser)
    {
        pOwner = MQSec_GetAnonymousSid();
        bOwnerDefaulted = TRUE;
		TrTRACE(SECURITY, "OwnerSid is local user");
    }

    ASSERT((pOwner != NULL) && (IsValidSid(pOwner)));

    if ((seInfoToRemove & OWNER_SECURITY_INFORMATION) ==
                                               OWNER_SECURITY_INFORMATION)
    {
        //
        // Do not include owner in output default security descriptor.
        //
    }
    else
    {
        if(!SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "SetSecurityDescriptorOwner failed, gle = %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorOwner failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }
		TrTRACE(SECURITY, "SetSecurityDescriptorOwner, OwnerSid = %!sid!", pOwner);
    }

    if (fIncludeGroup)
    {
        ASSERT((pGroup != NULL) && IsValidSid(pGroup));
        if(!SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "SetSecurityDescriptorGroup failed, gle = %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorGroup failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }
		TrTRACE(SECURITY, "SetSecurityDescriptorGroup, GroupSid = %!sid!", pGroup);
    }

    BOOL fIncludeDacl = TRUE ;

    if ((dwObjectType == MQDS_SITELINK) ||
        (dwObjectType == MQDS_COMPUTER))
    {
        //
        // For these objects types, we need only the owner. So don't waste
        // time to compute a DACL.
        //
        ASSERT(0);
        fIncludeDacl = FALSE;
    }
    else if ((seInfoToRemove & DACL_SECURITY_INFORMATION) ==
                                               DACL_SECURITY_INFORMATION)
    {
        //
        // don't include DACL.
        //
        fIncludeDacl = FALSE;
    }

    if (!bDaclPresent && fIncludeDacl)
    {
        PACL pDacl = NULL;

        //
        // If owner is the "Unkonwn user", or the Guest account, then grant
        // everyone full control on the object. "Guest" is not a "real"
        // owner, just a place-holder for any unauthenticated user.
        // If guest account is disabled, then the unknown user is
        // impersonated as the anonymous token.
        // We're creating here a NT4 format DACL, so full control to
        // everyone is just a NULL DACL.
        //
        BOOL fGrantEveryoneFull = FALSE;

        if (eDaclType == e_GrantFullControlToEveryone)
        {
            fGrantEveryoneFull = TRUE;
			TrTRACE(SECURITY, "GrantFullControlToEveryone");
        }
        else if (MQSec_IsGuestSid( pOwner ))
        {
            fGrantEveryoneFull = TRUE;
			TrTRACE(SECURITY, "GuestSid: GrantFullControlToEveryone");
        }
        else if (fLocalUser)
        {
            fGrantEveryoneFull = TRUE;
			TrTRACE(SECURITY, "Local user, GrantFullControlToEveryone");
        }

        DWORD dwAclRevision = ACL_REVISION;
        DWORD dwWorldAccess = 0;
        DWORD dwOwnerAccess = 0;
        DWORD dwAnonymousAccess = 0;
        DWORD dwMachineAccess = 0;

        switch (dwObjectType)
        {
			case MQDS_QUEUE:
				if(fGrantEveryoneFull)
				{
					dwWorldAccess = MQSEC_QUEUE_GENERIC_ALL;
				}
				else
				{
					dwWorldAccess = MQSEC_QUEUE_GENERIC_WRITE;
					dwOwnerAccess = GetObjectGenericMapping(dwObjectType)->GenericAll;
					if(pMachineSid != NULL)
					{
						//
						// If the caller supply the Machine Sid,
						// Grant the computer sid read permissions
						//
						dwMachineAccess = MQSEC_QUEUE_GENERIC_READ;
					}
				}
				dwAnonymousAccess = MQSEC_WRITE_MESSAGE;

				break;

			case MQDS_SITE:
				if(fGrantEveryoneFull)
				{
					dwWorldAccess = MQSEC_SITE_GENERIC_ALL;
				}
				else
				{
					dwWorldAccess = MQSEC_SITE_GENERIC_READ;
					dwOwnerAccess = GetObjectGenericMapping(dwObjectType)->GenericAll;
				}
				break;

			case MQDS_CN:
				//
				// This function is called from the replication service
				// to create a defualt descriptor for CNs. That's done
				// when replicating CNs to NT4 world.
				//
				if(fGrantEveryoneFull)
				{
					dwWorldAccess = MQSEC_CN_GENERIC_ALL;
				}
				else
				{
					dwWorldAccess = MQSEC_CN_GENERIC_READ;
					dwOwnerAccess = GetObjectGenericMapping(dwObjectType)->GenericAll;
				}
				break;

			case MQDS_MQUSER:
				//
				// these are DS rights, not msmq.
				//
				if(fGrantEveryoneFull)
				{
					ASSERT(("MQDS_MQUSER should be called by domain user", 0));
					dwWorldAccess = GENERIC_ALL_MAPPING;
				}
				else
				{
					dwWorldAccess = GENERIC_READ_MAPPING;
					dwOwnerAccess = GENERIC_READ_MAPPING   |
									 RIGHT_DS_SELF_WRITE    |
									 RIGHT_DS_WRITE_PROPERTY;
				}
				dwAclRevision = ACL_REVISION_DS;
				break;

			case MQDS_MACHINE:
				ASSERT(fGrantEveryoneFull);
				dwWorldAccess = MQSEC_MACHINE_GENERIC_ALL;
				break;

			default:
				ASSERT(("Unexpected	Object Type", 0));
				break;
        }

        ASSERT(dwWorldAccess != 0);
        ASSERT(fGrantEveryoneFull || (dwOwnerAccess != 0));

		//
		// Create and set the default DACL.
		// Allocate and initialize the DACL
		//

		DWORD dwAclSize = sizeof(ACL)                                +
						  (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
						  GetLengthSid(g_pWorldSid);
		
		if (dwOwnerAccess != 0)
		{
			dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
						 GetLengthSid(pOwner);
		}

		if (dwAnonymousAccess != 0)
		{
			ASSERT(dwObjectType == MQDS_QUEUE);

			dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
						 GetLengthSid(MQSec_GetAnonymousSid());
		}

		if (dwMachineAccess != 0)
		{
			ASSERT(dwObjectType == MQDS_QUEUE);
			ASSERT((pMachineSid != NULL) && IsValidSid(pMachineSid));

			dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
						 GetLengthSid(pMachineSid);
		}

        DACL_buff = new char[dwAclSize];
        pDacl = (PACL)(char*)DACL_buff;

        if(!InitializeAcl(pDacl, dwAclSize, dwAclRevision))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "InitializeAcl failed, gle = %!winerr!", gle);
			ASSERT(("InitializeAcl failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }
        	

        if(!AddAccessAllowedAce(
						pDacl,
						dwAclRevision,
						dwWorldAccess,
						g_pWorldSid
						))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "AddAccessAllowedAce failed, gle = %!winerr!", gle);
			ASSERT(("AddAccessAllowedAce failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }

		TrTRACE(SECURITY, "Everyone ACE: Sid = %!sid!, AccessMask = 0x%x", g_pWorldSid, dwWorldAccess);

		if (dwAnonymousAccess != 0)
		{
			PSID pAnonymousSid = MQSec_GetAnonymousSid();
			if(!AddAccessAllowedAce(
						pDacl,
						dwAclRevision,
						dwAnonymousAccess,
						pAnonymousSid
						))
	        {
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "AddAccessAllowedAce failed, gle = %!winerr!", gle);
				ASSERT(("AddAccessAllowedAce failed", 0));
				return HRESULT_FROM_WIN32(gle);
	        }

			TrTRACE(SECURITY, "Anonymous ACE: Sid = %!sid!, AccessMask = 0x%x", pAnonymousSid, dwAnonymousAccess);
		}

		if (dwMachineAccess != 0)
		{
			ASSERT((pMachineSid != NULL) && IsValidSid(pMachineSid));
			if(!AddAccessAllowedAce(
						pDacl,
						dwAclRevision,
						dwMachineAccess,
						pMachineSid
						))
	        {
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "AddAccessAllowedAce failed, gle = %!winerr!", gle);
				ASSERT(("AddAccessAllowedAce failed", 0));
				return HRESULT_FROM_WIN32(gle);
	        }

			TrTRACE(SECURITY, "Machine$ ACE: Sid = %!sid!, AccessMask = 0x%x", pMachineSid, dwMachineAccess);
		}

		if (dwOwnerAccess != 0)
		{
			//
			// Add owner permissions.
			//
			if(!AddAccessAllowedAce(
						pDacl,
						dwAclRevision,
						dwOwnerAccess,
						pOwner
						))
	        {
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "AddAccessAllowedAce failed, gle = %!winerr!", gle);
				ASSERT(("AddAccessAllowedAce failed", 0));
				return HRESULT_FROM_WIN32(gle);
	        }

			TrTRACE(SECURITY, "Owner ACE: Sid = %!sid!, AccessMask = 0x%x", pOwner, dwOwnerAccess);
		}

		//
		// dacl should not be defaulted !
        // Otherwise, calling IDirectoryObject->CreateDSObject() will ignore
        // the dacl we provide and will insert some default.
		//
        if(!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "SetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorDacl failed", 0));
			return HRESULT_FROM_WIN32(gle);
        }
    }

    //
    // Convert the descriptor to a self relative format.
    //
    dwLen = 0;
    hr = MQSec_MakeSelfRelative(
			(PSECURITY_DESCRIPTOR) &sd,
			ppSecurityDescriptor,
			&dwLen
			);

    return LogHR(hr, s_FN, 80);
}

/***************************************************************************

Function:

    MQSec_CopySecurityDescriptor

Parameters:

    pDstSecurityDescriptor - Destination security descriptor.

    pSrcSecurityDescriptor - Source security descriptor.

    RequestedInformation - Indicates what parts of the source security
        descriptor should be copied to the destination security descriptor.

    eCopyControlBits - indicate whether or not control bits are copied too.

Description:
    The destination security descriptor should be an absolute security
    descriptor. The component in the destination security descriptor are
    being overwriten.

***************************************************************************/

BOOL
APIENTRY
MQSec_CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR  pDstSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR  pSrcSecurityDescriptor,
    IN SECURITY_INFORMATION  RequestedInformation,
    IN enum  enumCopyControl eCopyControlBits
	)
{
    PACL  pAcl;
    PSID  pSid;
    DWORD dwRevision;

    if (pSrcSecurityDescriptor == NULL)
    {
        //
        // Bug 8567.
        // I have no idea why source Security descriptor is NULL, but
        // better return error than AV...
        //
		TrERROR(SECURITY, "MQSec_CopySecurityDescriptor() got NULL source SD") ;
        return FALSE;
    }

#ifdef _DEBUG
    SECURITY_DESCRIPTOR_CONTROL sdc;

    //
    // Verify that the destination security descriptor answers to all
    // requirements.
    //
    BOOL bRet = GetSecurityDescriptorControl(pDstSecurityDescriptor, &sdc, &dwRevision);
    ASSERT(bRet);
    ASSERT(!(sdc & SE_SELF_RELATIVE));
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
#endif

    SECURITY_DESCRIPTOR_CONTROL sdcSrc;
    if(!GetSecurityDescriptorControl(
				pSrcSecurityDescriptor,
				&sdcSrc,
				&dwRevision
				))
	{
			DWORD gle = GetLastError();
			ASSERT(("GetSecurityDescriptorControl failed", 0));
			TrERROR(SECURITY, "GetSecurityDescriptorControl failed, gle = %!winerr!", gle);
			return FALSE;
	}

	//
    // Copy the owner SID
	//
    if (RequestedInformation & OWNER_SECURITY_INFORMATION)
    {
	    BOOL  bDefaulted = FALSE;
        if(!GetSecurityDescriptorOwner(
					pSrcSecurityDescriptor,
					&pSid,
					&bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("GetSecurityDescriptorOwner failed", 0));
			TrERROR(SECURITY, "GetSecurityDescriptorOwner failed, gle = %!winerr!", gle);
			return FALSE;
		}

        if(!SetSecurityDescriptorOwner(
					pDstSecurityDescriptor,
					pSid,
					bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("SetSecurityDescriptorOwner failed", 0));
			TrERROR(SECURITY, "SetSecurityDescriptorOwner failed, gle = %!winerr!", gle);
			return FALSE;
		}
    }

	//
    // Copy the primary group SID.
	//
    if (RequestedInformation & GROUP_SECURITY_INFORMATION)
    {
	    BOOL  bDefaulted = FALSE;
        if(!GetSecurityDescriptorGroup(
					pSrcSecurityDescriptor,
					&pSid,
					&bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("GetSecurityDescriptorGroup failed", 0));
			TrERROR(SECURITY, "GetSecurityDescriptorGroup failed, gle = %!winerr!", gle);
			return FALSE;
		}

        if(!SetSecurityDescriptorGroup(
					pDstSecurityDescriptor,
					pSid,
					bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("SetSecurityDescriptorGroup failed", 0));
			TrERROR(SECURITY, "SetSecurityDescriptorGroup failed, gle = %!winerr!", gle);
			return FALSE;
		}
    }

	//
    // Copy the DACL.
	//
    if (RequestedInformation & DACL_SECURITY_INFORMATION)
    {
	    BOOL  bDefaulted = FALSE;
	    BOOL  bPresent = FALSE;
        if(!GetSecurityDescriptorDacl(
					pSrcSecurityDescriptor,
					&bPresent,
					&pAcl,
					&bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("GetSecurityDescriptorDacl failed", 0));
			TrERROR(SECURITY, "GetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
			return FALSE;
		}

        if(!SetSecurityDescriptorDacl(
					pDstSecurityDescriptor,
					bPresent,
					pAcl,
					bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("SetSecurityDescriptorDacl failed", 0));
			TrERROR(SECURITY, "SetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
			return FALSE;
		}

        if (eCopyControlBits == e_DoCopyControlBits)
        {
            SECURITY_DESCRIPTOR_CONTROL scMask =
                                              SE_DACL_AUTO_INHERIT_REQ |
                                              SE_DACL_AUTO_INHERITED   |
                                              SE_DACL_PROTECTED;

            SECURITY_DESCRIPTOR_CONTROL sdcDst = sdcSrc & scMask;

            if(!SetSecurityDescriptorControl(
					pDstSecurityDescriptor,
					scMask,
					sdcDst
					))
			{
				DWORD gle = GetLastError();
				ASSERT(("SetSecurityDescriptorControl failed", 0));
				TrERROR(SECURITY, "SetSecurityDescriptorControl failed, gle = %!winerr!", gle);
				return FALSE;
			}
        }
    }

	//
    // Copy the SACL.
	//
    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
	    BOOL  bDefaulted = FALSE;
	    BOOL  bPresent = FALSE;
        if(!GetSecurityDescriptorSacl(
					pSrcSecurityDescriptor,
					&bPresent,
					&pAcl,
					&bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("GetSecurityDescriptorSacl failed", 0));
			TrERROR(SECURITY, "GetSecurityDescriptorSacl failed, gle = %!winerr!", gle);
			return FALSE;
		}

        if(!SetSecurityDescriptorSacl(
					pDstSecurityDescriptor,
					bPresent,
					pAcl,
					bDefaulted
					))
		{
			DWORD gle = GetLastError();
			ASSERT(("SetSecurityDescriptorSacl failed", 0));
			TrERROR(SECURITY, "SetSecurityDescriptorSacl failed, gle = %!winerr!", gle);
			return FALSE;
		}

        if (eCopyControlBits == e_DoCopyControlBits)
        {
            SECURITY_DESCRIPTOR_CONTROL scMask =
                                              SE_SACL_AUTO_INHERIT_REQ |
                                              SE_SACL_AUTO_INHERITED   |
                                              SE_SACL_PROTECTED;

            SECURITY_DESCRIPTOR_CONTROL sdcDst = sdcSrc & scMask;

            if(!SetSecurityDescriptorControl(
				pDstSecurityDescriptor,
				scMask,
				sdcDst
				))
			{
				DWORD gle = GetLastError();
				ASSERT(("SetSecurityDescriptorControl failed", 0));
				TrERROR(SECURITY, "SetSecurityDescriptorControl failed, gle = %!winerr!", gle);
				return FALSE;
			}
        }
    }

    return(TRUE);
}


bool
APIENTRY
MQSec_MakeAbsoluteSD(
    PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
	CAbsSecurityDsecripror* pAbsSecDescriptor
	)
/*++
Routine Description:
	Convert Security descriptor to Absolute format

Arguments:
	pObjSecurityDescriptor - self relative security descriptor
	pAbsSecDescriptor - structure of AP<> for absolute security descriptor.

Returned Value:
	true - success, false - failure

--*/
{

#ifdef _DEBUG
    //
    // Verify that the input security descriptor answers to all requirements.
    //
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;
    BOOL fSuccess1 = GetSecurityDescriptorControl(pObjSecurityDescriptor, &sdc, &dwRevision);

    ASSERT(fSuccess1);
    ASSERT(sdc & SE_SELF_RELATIVE);
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
#endif

    //
    // Convert present object descriptor to absolute format. This is
    // necessary for the "set" api which manipulate a security descriptor
    //
    DWORD dwObjAbsSDSize = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;
    DWORD dwOwnerSize = 0;
    DWORD dwPrimaryGroupSize = 0;

    BOOL fSuccess = MakeAbsoluteSD(
						pObjSecurityDescriptor,
						NULL,
						&dwObjAbsSDSize,
						NULL,
						&dwDaclSize,
						NULL,
						&dwSaclSize,
						NULL,
						&dwOwnerSize,
						NULL,
						&dwPrimaryGroupSize
						);

    ASSERT(!fSuccess && (GetLastError() == ERROR_INSUFFICIENT_BUFFER));
    ASSERT(dwObjAbsSDSize != 0);

    //
    // Allocate the buffers for the absolute security descriptor.
    //
    pAbsSecDescriptor->m_pObjAbsSecDescriptor = new char[dwObjAbsSDSize];
    pAbsSecDescriptor->m_pOwner = new char[dwOwnerSize];
    pAbsSecDescriptor->m_pPrimaryGroup = new char[dwPrimaryGroupSize];
    if (dwDaclSize)
    {
        pAbsSecDescriptor->m_pDacl = new char[dwDaclSize];
    }
    if (dwSaclSize)
    {
        pAbsSecDescriptor->m_pSacl = new char[dwSaclSize];
    }

    //
    // Create the absolute descriptor.
    //
    fSuccess = MakeAbsoluteSD(
                    pObjSecurityDescriptor,
                    reinterpret_cast<PSECURITY_DESCRIPTOR>(pAbsSecDescriptor->m_pObjAbsSecDescriptor.get()),
                    &dwObjAbsSDSize,
                    reinterpret_cast<PACL>(pAbsSecDescriptor->m_pDacl.get()),
                    &dwDaclSize,
                    reinterpret_cast<PACL>(pAbsSecDescriptor->m_pSacl.get()),
                    &dwSaclSize,
                    reinterpret_cast<PSID>(pAbsSecDescriptor->m_pOwner.get()),
                    &dwOwnerSize,
                    reinterpret_cast<PSID>(pAbsSecDescriptor->m_pPrimaryGroup.get()),
                    &dwPrimaryGroupSize
					);

    if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "MakeAbsoluteSD() failed, gle = 0x%x", gle);
	    ASSERT(("MakeAbsoluteSD failed", 0));
		return false;
	}
	return true;
}


bool
APIENTRY
MQSec_SetSecurityDescriptorDacl(
    IN  PACL pNewDacl,
    IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
    OUT AP<BYTE>&  pSecurityDescriptor
	)
/*++
Routine Description:
	Set new DACL in pObjSecurityDescriptor.

Arguments:
    pNewDacl - the new DACL
	pObjSecurityDescriptor - object security descriptor.
    pSecurityDescriptor - output result. This is combination of the new DACL
        with unchanged ones from "pObj" in self-relative format.

Returned Value:
	true - success, false - failure

--*/
{
    //
    // Create the absolute descriptor.
    //
	CAbsSecurityDsecripror AbsSecDsecripror;
	if(!MQSec_MakeAbsoluteSD(
			pObjSecurityDescriptor,
			&AbsSecDsecripror
			))
	{
		TrERROR(SECURITY, "MQSec_MakeAbsoluteSD() failed");
		return false;
	}

    SECURITY_DESCRIPTOR sd;
    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "InitializeSecurityDescriptor() failed, gle = 0x%x", gle);
	    ASSERT(("InitializeSecurityDescriptor failed", 0));
		return false;
	}

    if(!SetSecurityDescriptorDacl(&sd, TRUE, pNewDacl, FALSE))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "SetSecurityDescriptorDacl() failed, gle = 0x%x", gle);
	    ASSERT(("SetSecurityDescriptorDacl failed", 0));
		return false;
	}

    //
    // Now copy new components to old descriptor, replacing old components.
    //
    if(!MQSec_CopySecurityDescriptor(
				reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),	// dst
				&sd,							// src
				DACL_SECURITY_INFORMATION,
				e_DoNotCopyControlBits
				))
	{
		TrERROR(SECURITY, "MQSec_CopySecurityDescriptor() failed");
	    ASSERT(("MQSec_CopySecurityDescriptor failed", 0));
		return false;
	}

    //
    // Return a self relative descriptor.
    //
    DWORD dwLen = 0;
    HRESULT hr = MQSec_MakeSelfRelative(
						reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
						reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pSecurityDescriptor),
						&dwLen
						);
	if(FAILED(hr))
	{
		TrERROR(SECURITY, "MQSec_MakeSelfRelative() failed, hr = 0x%x", hr);
	    ASSERT(("MQSec_MakeSelfRelative failed", 0));
		return false;
	}

	return true;
}

//+------------------------------------------------------------------------
//
//  HRESULT APIENTRY  MQSec_MergeSecurityDescriptors()
//
//  Change the security descriptor of an object.
//  Caller must free the returned descriptor, using "delete".
//
//  Parameters:
//      dwObjectType - object type (Queue, Machine, etc...)
//      SecurityInformation - bits field that indicates which security
//          components are included in the input descriptor.
//      pInSecurityDescriptor - Input descriptor. The relevant components
//          from this one are copied to the output descriptor.
//      pObjSecurityDescriptor - Old object descriptor. Its relevant
//          components (those indicated by "SecurityInformation" are
//          replaced with those from "pInSecurityDescriptor". The other
//          components are copied as-is to the output.
//      ppSecurityDescriptor - output result. This is combination of new
//          components from "pIn" with unchanged ones from "pObj".
//          in self-relative format.
//
//  Notes: Input descriptor can be null, or components can be null and
//      marked for insetion (by turning on the relevant bits in
//       "SecurityInformation"). In those cases we use default values.
//
//+------------------------------------------------------------------------

HRESULT
APIENTRY
MQSec_MergeSecurityDescriptors(
                        IN  DWORD                  dwObjectType,
                        IN  SECURITY_INFORMATION   SecurityInformation,
                        IN  PSECURITY_DESCRIPTOR   pInSecurityDescriptor,
                        IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
                        OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor )
{
    //
    // Convert present object descriptor to absolute format. This is
    // necessary for the "set" api which manipulate a security descriptor
    //
	CAbsSecurityDsecripror AbsSecDsecripror;
	if(!MQSec_MakeAbsoluteSD(
			pObjSecurityDescriptor,
			&AbsSecDsecripror
			))
	{
		ASSERT(("MQSec_MakeAbsoluteSD failed", 0));
		TrERROR(SECURITY, "MQSec_MakeAbsoluteSD failed");
		return MQSec_E_UNKNOWN;
	}

    //
    // Now take default components, for those which are not supplied by
    // input descriptor.
    //
    AP<char> pDefaultSecurityDescriptor;
    SECURITY_DESCRIPTOR *pInputSD =
                             (SECURITY_DESCRIPTOR *) pInSecurityDescriptor;

    HRESULT hr = MQSec_OK;
    if (dwObjectType == MQDS_QUEUE)
    {
        //
        // Security descriptor of queue can be provided by caller of
        // MQSetQueueSecurity(). to be compatible with msmq1.0, and
        // with spec, we create the default.
        // For all other types of objects, we expect mmc (or other admin
        // tools) to provide relevant components of the security descriptor,
        // without blank fields that need defaults.
        //
        hr =  MQSec_GetDefaultSecDescriptor(
					dwObjectType,
					(PSECURITY_DESCRIPTOR*) &pDefaultSecurityDescriptor,
					TRUE, // fImpersonate
					pInSecurityDescriptor,
					0,  // seInfoToRemove
					e_UseDefDaclAndCopyControl
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1100) ;
        }

        char *pTmp= pDefaultSecurityDescriptor;
        pInputSD = (SECURITY_DESCRIPTOR *) pTmp;
    }

    //
    // Now copy new components to old descriptor, replacing old components.
    //
    if(!MQSec_CopySecurityDescriptor(
					reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()), //dst
					pInputSD,               // src
					SecurityInformation,
					e_DoCopyControlBits
					))
	{
		ASSERT(("MQSec_CopySecurityDescriptor failed", 0));
		TrERROR(SECURITY, "MQSec_CopySecurityDescriptor failed");
		return MQSec_E_UNKNOWN;
	}

    //
    // Return a self relative descriptor.
    //
    DWORD dwLen = 0 ;
    hr = MQSec_MakeSelfRelative(
				reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
				ppSecurityDescriptor,
				&dwLen
				);

    return LogHR(hr, s_FN, 90);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\acssctrl\secd5to4.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: secd5to4.cpp

Abstract:
    Conversion of NT5 security descriptor to NT4 format.

Author:
    Doron Juster (DoronJ)  24-May-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include <mqnames.h>
#include "mqexception.h"

#include "secd5to4.tmh"

static WCHAR *s_FN=L"acssctrl/secd5to4";

//+----------------------------
//
//  void GetpSidAndObj()
//
//+----------------------------

void  
GetpSidAndObj( 
	IN  ACCESS_ALLOWED_ACE*   pAce,
	OUT PSID                 *ppSid,
	OUT BOOL                 *pfObj,
	OUT GUID                **ppguidObj /* = NULL */
	)
/*++
Routine Description:
	Get ACE information: Sid, Obj ACE, Guid Obj ACE.

Arguments:
	pAce - ACE pointer to inquire.
	ppSid - ACE sid.
	pfObj - flag to indicate if this is a OBJECT_ACE_TYPE.
	ppguidObj - Guid of the object ACE.

Returned Value:
	None

--*/
{
	ASSERT(ppSid != NULL);
	ASSERT(pfObj != NULL);
	
	ACCESS_ALLOWED_OBJECT_ACE* pObjAce = (ACCESS_ALLOWED_OBJECT_ACE*) pAce;

    BOOL fObj = ((pAce->Header.AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ||
                 (pAce->Header.AceType == ACCESS_DENIED_OBJECT_ACE_TYPE)  ||
                 (pAce->Header.AceType == SYSTEM_AUDIT_OBJECT_ACE_TYPE));

    *ppSid = NULL;
    *pfObj = fObj;

    if (!fObj)
    {
        *ppSid = (PSID) &(pAce->SidStart);
        return;
    }

    //
	// Object type ACE
	// Get the sid location
	// If both guids present (ACE_INHERITED_OBJECT_TYPE_PRESENT, ACE_OBJECT_TYPE_PRESENT)
	// The sid location is at SidStart.
	// if only one guid is present, sid location is at InheritedObjectType
	// If none of the guids present, sid location is at ObjectType
	//
    if (pObjAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
    {
        //
        // "inherited" guid is present.
        //
        if (pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            //
            // Both guids are present.
            // ACE Structure contain spaces for both guids.
            //
            *ppSid = (PSID) &(pObjAce->SidStart);
        }
        else
        {
        	//
        	// This is not a ACE with extended rights. Use this flag in order that its mask will be taken into account.
        	//
        	*pfObj = FALSE;
            //
            // Only one guid presented. structure is shorter.
            //
            *ppSid = (PSID) &(pObjAce->InheritedObjectType);
        }
    }
    else if (pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT)
    {
        //
        // In this case, the structure is shorter, and sid start
        // at the "Inherited" member. April98 MSDN is wrong about
        // this structure.
        //
        *ppSid = (PSID) &(pObjAce->InheritedObjectType);
    }
    else
    {
        //
        // Structure even shorter. no guid is present. 
    	// This is not a ACE with extended rights. Use this flag in order that its mask will be taken into account.
    	//
        //
        *pfObj = FALSE;
        ASSERT(pObjAce->Flags == 0);
        *ppSid = (PSID) &(pObjAce->ObjectType);
    }
    
    if ((pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT) && ppguidObj)
    {
        *ppguidObj = &(pObjAce->ObjectType);
    }
    
}

//+---------------------------------------
//
//  DWORD _MapNt5RightsToNt4Ace()
//
//+---------------------------------------

static 
DWORD 
_MapNt5RightsToNt4Ace( 
	IN DWORD               dwObjectType,
	IN BOOL                fObj,
	IN ACCESS_ALLOWED_ACE* pAce,
	IN DWORD               dwPrevMask 
	)
{
    if (dwPrevMask == g_dwFullControlNT4[dwObjectType])
    {
        //
        // already full control. Ignore.
        //
        return dwPrevMask;
    }

    DWORD dwMask = dwPrevMask;

    if (fObj)
    {
        struct RIGHTSMAP  *psMap = g_psExtendRightsMap5to4[dwObjectType];
        DWORD dwSize =  g_pdwExtendRightsSize5to4[dwObjectType];

        if (psMap)
        {
            BOOL fFound = FALSE;
            ACCESS_ALLOWED_OBJECT_ACE* pObjAce = (ACCESS_ALLOWED_OBJECT_ACE*) pAce;
            GUID *pGuid = &(pObjAce->ObjectType);

            if ((pObjAce->Mask & MSMQ_EXTENDED_RIGHT_MASK) == MSMQ_EXTENDED_RIGHT_MASK)
            {
                //
                // This is an extended right object ace. It may be relevant.
                //
                ASSERT(pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT);

                for (DWORD j = 0; j < dwSize; j++)
                {
                    if (memcmp( 
							pGuid,
							&(psMap[j].guidRight),
							sizeof(GUID)
							) == 0)
                    {
                        dwMask |= psMap[j].dwPermission5to4;
                        fFound = TRUE;
                        break;
                    }
                }
            }

            if (!fFound                          &&
                 (dwObjectType == MQDS_MACHINE)  &&
                 (memcmp(pGuid, &g_guidCreateQueue, sizeof(GUID)) == 0))
            {
                //
                // Handle the special case where the DACL doesn't have the
                // "CreateAllChild" bit turned on, but rather it has
                // "CreatemSMQQueue" guid present.
                //
                if (pObjAce->Mask & RIGHT_DS_CREATE_CHILD)
                {
                    dwMask |= MQSEC_CREATE_QUEUE;
                }
            }
        }
        else
        {
            //
            // Only queue and machine objects can have extended rights.
            //
            ASSERT((dwObjectType != MQDS_QUEUE) && (dwObjectType != MQDS_MACHINE));
        }
    }
    else
    {
        //
        // Map the DS specific rights to MSMQ specific rights
        //
        DWORD dwDSRights = pAce->Mask;
        ASSERT(dwDSRights != 0);

        if (dwDSRights == GENERIC_ALL_MAPPING)
        {
            //
            // Full control.
            // Don't look for other allow aces for this sid.
            //
            return  g_dwFullControlNT4[dwObjectType];
        }

        DWORD  *pdwMap = g_padwRightsMap5to4[dwObjectType];
        ASSERT(pdwMap);

        for (DWORD j = 0; j < NUMOF_ADS_SPECIFIC_RIGHTS; j++)
        {
            DWORD dwRight =  dwDSRights & 0x01;
            if (dwRight)
            {
                dwMask |= pdwMap[j];
            }
            dwDSRights >>= 1;
        }

        //
        // Copy the standard rights.
        //
        dwDSRights = pAce->Mask;
        DWORD dwStandard = dwDSRights & STANDARD_RIGHTS_ALL;
        dwMask |= dwStandard;

        if (dwObjectType == MQDS_SITE)
        {
            //
            // the single NT5 DS right CreateChild is mapped to three
            // MSMQ1.0 rights: createFRS, createBSC and createMachine.
            // The translation table contain only the createMachine right.
            // Add all the others.
            //
            if (dwMask & MQSEC_CREATE_MACHINE)
            {
                dwMask |= (MQSEC_CREATE_FRS | MQSEC_CREATE_BSC | MQSEC_CREATE_MACHINE);
            }
        }
    }

    return dwMask;
}

BOOL  
IsNewSid( 
	PSID pSid,
	SID** ppSids,
	DWORD* pdwNumofSids 
	)
{
    for (DWORD j = 0; j < *pdwNumofSids; j++)
    {
        PSID pSidOld = ppSids[j];

        if (EqualSid(pSid, pSidOld))
        {
			//
			// ACE sid already exist in the Sids list.
			//
            return FALSE;
        }
    }

    //
    // New sid, add it to the Sids list
    //
    DWORD dwSize = GetLengthSid(pSid);
    ASSERT(dwSize) ;

	AP<SID> NewSid = (SID*) new BYTE[dwSize];
    if (!CopySid(dwSize, NewSid, pSid))
    {
		//
		// We failed to copy the sid - just don't add it. 
		//
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "CopySid failed. Error: %!winerr!", gle);
		ASSERT(("CopySid failed", gle == ERROR_SUCCESS));
		return TRUE;
    }

    DWORD dwIndex = *pdwNumofSids;
    ppSids[dwIndex] = NewSid.detach();
    *pdwNumofSids = dwIndex + 1;

    return TRUE;
}


//+----------------------------
//
//  BOOL  _IsNewNt5Sid()
//
//+----------------------------

static 
BOOL  
_IsNewNt5Sid( 
	ACCESS_ALLOWED_ACE*   pAce,
	SID                 **ppSids,
	DWORD                *pdwNumofSids 
	)
{
    BOOL fObj;
    PSID pSid = NULL;

    GetpSidAndObj( 
		pAce,
		&pSid,
		&fObj 
		);

    ASSERT(pSid && IsValidSid(pSid));

	return IsNewSid(pSid, ppSids, pdwNumofSids);
}

//+-------------------------------
//
//  void _SetNt4AuditMasks()
//
//+-------------------------------

inline 
static 
void 
_SetNt4AuditMasks( 
	IN  SYSTEM_AUDIT_ACE *pAce,
	IN  DWORD             dwObjectType,
	IN  BOOL              fObj,
	OUT ACCESS_MASK      *pdwFail,
	OUT ACCESS_MASK      *pdwSuccess 
	)
{
    BYTE bFlags = pAce->Header.AceFlags;

    if (bFlags & FAILED_ACCESS_ACE_FLAG)
    {
        *pdwFail = _MapNt5RightsToNt4Ace(  
						dwObjectType,
						fObj,
						(ACCESS_ALLOWED_ACE*) pAce,
						*pdwFail 
						);
    }

    if (bFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
    {
        *pdwSuccess = _MapNt5RightsToNt4Ace(  
							dwObjectType,
							fObj,
							(ACCESS_ALLOWED_ACE*) pAce,
							*pdwSuccess 
							);
    }
}

//+---------------------------------------------
//
//  static HRESULT _ConvertSaclToNT4Format()
//
//+---------------------------------------------

static 
HRESULT 
_ConvertSaclToNT4Format( 
	IN  DWORD   dwObjectType,
	IN  PACL    pAcl5,
	OUT DWORD  *pdwAcl4Len,
	OUT PACL   *ppAcl4 
	)
{
    ASSERT(IsValidAcl(pAcl5));

    DWORD dwAclSize = (DWORD) pAcl5->AclSize;
	DWORD dwNumberOfACEs = (DWORD) pAcl5->AceCount;
	if (dwNumberOfACEs == 0)
    {
        //
        // SACL without ACEs. nothing to convert.
        //
        *pdwAcl4Len = 0;
        *ppAcl4 = NULL;
        return MQSec_OK;
    }

    *pdwAcl4Len = dwAclSize;
    AP<ACL> TempAcl = (PACL) new BYTE[*pdwAcl4Len];
    *ppAcl4 = TempAcl;
    if (!InitializeAcl(*ppAcl4, *pdwAcl4Len, ACL_REVISION))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "InitializeAcl failed. Error: %!winerr!", gle);
		ASSERT(("InitializeAcl failed", gle == ERROR_SUCCESS));
		return HRESULT_FROM_WIN32(gle);
    }

    //
    // First, group aces by SID, then by audit type (fail or success).
    //
    // We build an array of SIDs that we handled up to now. We combine
    // aces of same sid into one ace. This operation does not change the
    // semantic of the acl, just make it more efficient.
    //
    SID  **ppSids5 = (SID**) new PSID[dwNumberOfACEs];
    aPtrs<SID> apSids(ppSids5, dwNumberOfACEs);
    DWORD dwNumSids = 0;

    DWORD i = 0;

    do
    {
	    SYSTEM_AUDIT_ACE *pAce;
        if (!GetAce(pAcl5, i, (LPVOID* )&(pAce)))
        {
            TrERROR(SECURITY, "Failed to get ACE (index=%lu) while converting SACL from NT5 form. %!winerr!", i, GetLastError());
            return MQSec_E_SDCONVERT_GETACE ;
        }

        if (!_IsNewNt5Sid( 
				(ACCESS_ALLOWED_ACE*) pAce,
				ppSids5,
				&dwNumSids 
				))
        {
            i++;
            continue;
        }

        //
        // First ace in the group. Now look for contigous aces with same sid.
        //
        BOOL fObj;
        PSID pSid = NULL;

        GetpSidAndObj( 
			(ACCESS_ALLOWED_ACE*) pAce,
			&pSid,
			&fObj 
			);

        ASSERT(pSid && IsValidSid(pSid));

        ACCESS_MASK  dwMaskFail = 0;
        ACCESS_MASK  dwMaskSuccess = 0;
        _SetNt4AuditMasks( 
			pAce,
			dwObjectType,
			fObj,
			&dwMaskFail,
			&dwMaskSuccess 
			);

        i++;
        DWORD j = i;

        while (j < dwNumberOfACEs)
        {
            if (!GetAce(pAcl5, j, (LPVOID* )&(pAce)))
            {
                TrERROR(SECURITY, "Failed to get ACE (index=%lu) while looking for next ACE in NT4 format. %!winerr!", i, GetLastError());
                return MQSec_E_SDCONVERT_GETACE ;
            }

            PSID pPresentSid = NULL;

            GetpSidAndObj( 
				(ACCESS_ALLOWED_ACE*) pAce,
				&pPresentSid,
				&fObj 
				);

            ASSERT(pPresentSid && IsValidSid(pPresentSid));

            if (EqualSid(pSid, pPresentSid))
            {
                _SetNt4AuditMasks( 
					pAce,
					dwObjectType,
					fObj,
					&dwMaskFail,
					&dwMaskSuccess 
					);
            }
            j++;
        }

        //
        // Now we have a group of aces of same SID, and we have the masks.
        //
        if (dwMaskSuccess != 0)
        {
            if (dwMaskSuccess != 0)
            {
                if (!AddAuditAccessAce( 
						*ppAcl4,
						ACL_REVISION,
						dwMaskSuccess,
						pSid,
						TRUE,     // success
						(dwMaskFail == dwMaskSuccess) 
						))
            	{
            		DWORD gle = GetLastError();
            		TrERROR(SECURITY, "AddAuditAccessAce failed. Error: %!winerr!", gle);
            		ASSERT(("AddAuditAccessAce failed", gle == ERROR_SUCCESS));
            		return HRESULT_FROM_WIN32(gle);
            	}

            }
        }

        if ((dwMaskFail != 0) && (dwMaskFail != dwMaskSuccess))
        {
            if (!AddAuditAccessAce( 
					*ppAcl4,
					ACL_REVISION,
					dwMaskFail,
					pSid,
					FALSE,     // success
					TRUE		// failure
					))
            {
            		DWORD gle = GetLastError();
            		TrERROR(SECURITY, "AddAuditAccessAce failed. Error: %!winerr!", gle);
            		ASSERT(("AddAuditAccessAce failed", gle == ERROR_SUCCESS));
            		return HRESULT_FROM_WIN32(gle);
            }
        }
    }
    while (i < dwNumberOfACEs);

	TempAcl.detach();
	
    return MQSec_OK;
}

//+---------------------------------------
//
//  HRESULT _ConvertGroupOfNt5DaclAces()
//
//  convert a group of ACEs, all of them having same type.
//
//+---------------------------------------

static 
HRESULT 
_ConvertGroupOfNt5DaclAces( 
	DWORD  dwObjectType,
	PACL   pInAcl5,
	DWORD  iFirst,
	DWORD  iLast,
	BOOL   fAllow,
	PACL   pOutAcl4 
	)
{
	DWORD   dwNumberOfACEs = iLast - iFirst + 1;
    DWORD   i = iFirst;

    //
    // We build an array of SIDs that we handled up to now. We combine
    // aces of same sid into one ace. This operation does not change the
    // semantic of the acl, just make it more efficient.
    //
    SID  **ppSids5 = (SID**) new PSID[dwNumberOfACEs];
    aPtrs<SID> apSids(ppSids5, dwNumberOfACEs);
    DWORD    dwNumSids = 0;

    do
    {
	    ACCESS_ALLOWED_ACE *pAce;
        if (!GetAce(pInAcl5, i, (LPVOID* )&(pAce)))
        {
            TrERROR(SECURITY, "Failed to get ACE (index=%lu) while combining same SID NT5 ACEs. %!winerr!", i, GetLastError());
            return MQSec_E_SDCONVERT_GETACE ;
        }

        if (!_IsNewNt5Sid( 
				pAce,
				ppSids5,
				&dwNumSids 
				))
        {
            i++;
            continue;
        }

        //
        // this ace start a group of aces for a given sid.
        // on MSMQ1.0 we don't support inheritance of ace, so just OR the
        // masks of all  aces of this sid and create a NT5 ace.
        //
        PSID pSid = NULL;
        BOOL fObj = FALSE;
        GetpSidAndObj( 
			pAce,
			&pSid,
			&fObj 
			);

        ASSERT(pSid && IsValidSid(pSid));

        DWORD dwMSMQRights = _MapNt5RightsToNt4Ace( 
									dwObjectType,
									fObj,
									pAce,
									0 
									);
        i++;
        DWORD j = i;

        while (j <= iLast)
        {
            if (!GetAce(pInAcl5, j, (LPVOID* )&(pAce)))
            {
                TrERROR(SECURITY, "Failed to get ACE (index=%lu) while looking for next NT5 ACE in a group. %!winerr!", i, GetLastError());
                return MQSec_E_SDCONVERT_GETACE ;
            }

            PSID pPresentSid = NULL;
            GetpSidAndObj( 
				pAce,
				&pPresentSid,
				&fObj 
				);

            ASSERT(pPresentSid && IsValidSid(pPresentSid));

            if (EqualSid(pSid, pPresentSid))
            {
                dwMSMQRights = _MapNt5RightsToNt4Ace( 
									dwObjectType,
									fObj,
									pAce,
									dwMSMQRights 
									);
            }
            j++;
        }

        BOOL f = FALSE;
        if (dwMSMQRights == 0)
        {
            //
            // Ignore. this is probably the result of access bits or
            // extended rights which are not supported on MSMQ1.0
            // don't add ACE with null access mask. It's meaningless
            // in MSMQ1.0
            //
            f = TRUE;
        }
        else if (fAllow)
        {
            if (!AddAccessAllowedAce( 
					pOutAcl4,
					ACL_REVISION,
					dwMSMQRights,
					pSid 
					))
            {
        		DWORD gle = GetLastError();
        		TrERROR(SECURITY, "AddAuditAccessAce failed. Error: %!winerr!", gle);
        		ASSERT(("AddAuditAccessAce failed", gle == ERROR_SUCCESS));
        		return HRESULT_FROM_WIN32(gle);	
            }
        }
        else
        {
            if (!AddAccessDeniedAceEx( 
					pOutAcl4,
					ACL_REVISION,
					0,
					dwMSMQRights,
					pSid 
					))
			{
        		DWORD gle = GetLastError();
        		TrERROR(SECURITY, "AddAuditAccessAce failed. Error: %!winerr!", gle);
        		ASSERT(("AddAccessDeniedAceEx failed", gle == ERROR_SUCCESS));
        		return HRESULT_FROM_WIN32(gle);	
            }
        }
    }
    while (i <= iLast);

    return MQSec_OK;
}

//+---------------------------------------------
//
//  static HRESULT _ConvertDaclToNT4Format()
//
//+---------------------------------------------

static 
HRESULT 
_ConvertDaclToNT4Format( 
	IN  DWORD   dwObjectType,
	IN  PACL    pAcl5,
	OUT DWORD  *pdwAcl4Len,
	OUT PACL   *ppAcl4 
	)
{
    ASSERT(IsValidAcl(pAcl5));
    HRESULT hr = MQSec_OK;

    DWORD dwAclSize = (DWORD) pAcl5->AclSize;
	DWORD dwNumberOfACEs = (DWORD) pAcl5->AceCount;

    //
    // See if we're running in the context of the replication service.
    // If so, then add an ALLOW_ACE for the enterprise object and let
    // everyone register certificate. This is a workaround for bug 5054,
    // to allow users in NT4 sites to register certifiates after PEc
    // migrated to Win2k. Otherwise, the NT4 MQIS servers will reject such
    // request and won't forward write-requests to the PEC.
    // Reason for the bug- we don't have a "register certificate" bit in the
    // security descriptor of the msmqService object, so there is nothing
    // we can translate to NT4 format. Anyway, mixed-mode msmq must relax
    // security, so this is just another aspect of this relaxation. There is
    // no security hole here, as MQIS servers do perform all necessary
    // validations of the certificate before issuing the write request.
    // Even in NT4, the "create user" bit was quite meaningless.
    //
    static BOOL s_fInReplService = FALSE;
    static BOOL s_fCheckReplService = TRUE;

    if (s_fCheckReplService)
    {
        HMODULE  hMq = GetModuleHandle(MQ1REPL_DLL_NAME);
        if (hMq)
        {
            s_fInReplService = TRUE;
        }
        s_fCheckReplService = FALSE;
    }

    if (s_fInReplService && (dwObjectType == MQDS_ENTERPRISE))
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(MQSec_GetWorldSid()));
    }

    //
    // The size of NT4 format can't be larger than the size of NT5.
    // In worst case, when all ACEs are added to NT4 ACL, NT5
    // OBJECT_ACEs are converted to NT4 ACEs which are smaller.
    // So allocating same size is safe, although may waste some memory.
    // The alternative is to scan the NT5 acl before starting conversion
    // and calculating the required size.
    //
    *pdwAcl4Len = dwAclSize;
    AP<ACL> TempAcl = (PACL) new BYTE[*pdwAcl4Len];
    *ppAcl4 = TempAcl;
    if (!InitializeAcl(*ppAcl4, *pdwAcl4Len, ACL_REVISION))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "InitializeAcl failed. Error: %!winerr!", gle);
		ASSERT(("InitializeAcl failed", gle == ERROR_SUCCESS));
		return HRESULT_FROM_WIN32(gle);	
   	}

    //
    // We're not assuming that the input acl is canonical. So we'll handle
    // groups of identical aces (i.e., aces of same type) at a time. Each
    // group will be converted to canonical NT5 format. So if input is
    // canonical, output will be canonical too.
    //
    DWORD i = 0;

    do
    {
        //
        // first ace in the group.
        //
	    ACCESS_ALLOWED_ACE *pAce;
        if (!GetAce(pAcl5, i, (LPVOID* )&(pAce)))
        {
            TrERROR(SECURITY, "Failed to get ACE (index=%lu) while looking for first NT5 ACE to convert. %!winerr!", i, GetLastError());
            return MQSec_E_SDCONVERT_GETACE ;
        }

        //
        // First verify it's an effective ACE. We don't take into account
        // INHRIT_ONLY aces. See ACE_HEADER documentation in MSDN.
        //
        if (pAce->Header.AceFlags & INHERIT_ONLY_ACE)
        {
            i++;
            continue;
        }

        DWORD iFirst = i;
        DWORD iLast = i;
        BOOL fAllow =
                ((pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                 (pAce->Header.AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE));
        i++;

        //
        // now look for other aces with same type.
        //
        while (i < dwNumberOfACEs)
        {
            if (!GetAce(pAcl5, i, (LPVOID* )&(pAce)))
            {
                TrERROR(SECURITY, "Failed to get ACE (index=%lu) while looking for other NT5 ACEs with same type. %!winerr!", i, GetLastError());
                return MQSec_E_SDCONVERT_GETACE ;
            }

            if (pAce->Header.AceFlags & INHERIT_ONLY_ACE)
            {
                //
                // This ACE is not an effective one for this object.
                // End of present group.
                //
                break;
            }

            BOOL fPresentAllow =
                ((pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                 (pAce->Header.AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE));

            if (fAllow == fPresentAllow)
            {
                iLast = i;
                i++;
            }
            else
            {
                break;
            }
        }

        //
        // Handle all aces from iFirst to iLast.
        //
        hr = _ConvertGroupOfNt5DaclAces( 
					dwObjectType,
					pAcl5,
					iFirst,
					iLast,
					fAllow,
					*ppAcl4 
					);
    }
    while (i < dwNumberOfACEs);

    if (s_fInReplService && (dwObjectType == MQDS_ENTERPRISE))
    {
        if (!AddAccessAllowedAce( 
				*ppAcl4,
				ACL_REVISION,
				MQSEC_CREATE_USER,
				MQSec_GetWorldSid() 
				))
        	{
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "AddAccessAllowedAce failed. Error: %!winerr!", gle);
				ASSERT(("AddAccessAllowedAce failed", gle == ERROR_SUCCESS));
				return HRESULT_FROM_WIN32(gle);	
        	}

    }
    
	TempAcl.detach();
	
    return MQSec_OK;
}

//+-----------------------------------------------------------------
//
//  BOOL _AlreadyNT4Format()
//
//  check if security descriptor is already in NT4 format. We're
//  checking the dacl revision. if it's ACL_REVISION then it's NT4.
//  NT5 DS must use the ACL_REVISION_DS.
//
//+-----------------------------------------------------------------

static BOOL _AlreadyNT4Format(IN  SECURITY_DESCRIPTOR  *pSD5)
{
    BOOL  bPresent = FALSE;
    BOOL  bDefaulted;
    PACL  pAcl5;

    if(!GetSecurityDescriptorDacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorDacl() failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
	}

    if (!bPresent)
    {
        //
        // dacl not present. Try the sacl.
        //
        if(!GetSecurityDescriptorSacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					))
		{
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorSacl() failed, gle = 0x%x", gle);
			throw bad_win32_error(gle);
		}

    }

    if (bPresent && (pAcl5 != NULL))
    {
        //
        // If the input is indeed in nt4 format, then it's legal to
        // have a "present" DACL that is NULL. So if acl is not null, we'll
        // check the version, but if it's null, then it's already in
        // nt4 format.
        //
	    return (pAcl5->AclRevision == ACL_REVISION);
    }

    //
    // If both dacl and sacl are not present, or are present as NULL, then
    // consider the SD as being in NT4 format and don't do anything with it.
    //
    return TRUE;
}

//+-----------------------------------------------------------------
//
//  HRESULT MQSec_ConvertSDToNT4Format()
//
//  Description: Convert a security descriptor from NT5 format to NT4
//      compatiblae format.
//
//+-----------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_ConvertSDToNT4Format(
	IN  DWORD                 dwObjectType,
	IN  SECURITY_DESCRIPTOR  *pSD5,
	OUT DWORD                *pdwSD4Len,
	OUT SECURITY_DESCRIPTOR **ppSD4,
	IN  SECURITY_INFORMATION  sInfo 
	)
{
    if (!pSD5 || !ppSD4)
    {
        ASSERT(0);
        return LogHR(MQSec_E_NULL_SD, s_FN, 80);
    }

    HRESULT hr = MQSec_OK;
    *ppSD4 = NULL;

    if (!IsValidSecurityDescriptor(pSD5))
    {
    	DWORD gle = GetLastError();
        TrERROR(SECURITY, "Can't convert an invalid NT5 Security Descriptor. Error: %!winerr!", gle);
        ASSERT(0);
        return MQSec_E_SD_NOT_VALID;
    }

    //
    // Make sure input descriptor is self-relative.
    //
    DWORD dwRevision = 0;
    SECURITY_DESCRIPTOR_CONTROL sdC;

	if (!GetSecurityDescriptorControl(pSD5, &sdC, &dwRevision))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorControl failed. Error: %!winerr!", gle);
		ASSERT(("GetSecurityDescriptorControl failed", gle == ERROR_SUCCESS));
		return HRESULT_FROM_WIN32(gle);
	}

    try
	{
		
	
		if (!(sdC & SE_SELF_RELATIVE))
		{
			TrERROR(SECURITY, "Can't convert a non self-relative NT5 Security Descriptor");
			return MQSec_E_NOT_SELF_RELATIVE;
		}
		else if (_AlreadyNT4Format(pSD5))
		{
			return LogHR(MQSec_I_SD_CONV_NOT_NEEDED, s_FN, 110);
		}
	}
	catch(bad_win32_error& exp)
	{
		TrERROR(SECURITY, "catch bad_win32_error exception, error = 0x%x", exp.error());
		return LogHR(HRESULT_FROM_WIN32(exp.error()), s_FN, 115);
	}


    if ((dwObjectType != MQDS_QUEUE)   &&
        (dwObjectType != MQDS_MACHINE) &&
        (dwObjectType != MQDS_CN)      &&
        (dwObjectType != MQDS_SITE)    &&
        (dwObjectType != MQDS_ENTERPRISE))
    {
        //
        // BUGBUG Temporary.
        //
        return LogHR(MQSec_I_SD_CONV_NOT_NEEDED, s_FN, 120);
    }

    SECURITY_DESCRIPTOR sd;

    if (!InitializeSecurityDescriptor( 
					&sd,
					SECURITY_DESCRIPTOR_REVISION 
					))
    {
        TrERROR(SECURITY, "Can't initialize security descriptor while converting from NT5 to NT4 format. %!winerr!", GetLastError());
        return MQSec_E_INIT_SD;
    }

    //
    // Handle owner.
    //
    PSID pOwner = NULL;
    if (sInfo & OWNER_SECURITY_INFORMATION)
    {
        BOOL bOwnerDefaulted = FALSE;

        if (!GetSecurityDescriptorOwner( 
					pSD5,
					&pOwner,
					&bOwnerDefaulted 
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorOwner failed. Error: %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorOwner failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }
        
        ASSERT(pOwner != NULL);
        ASSERT(IsValidSid(pOwner));

        //
        // BUGBUG
        // If this is a local user, set the owner to be the anonymous
        // logon user.
        //
        if (!SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "SetSecurityDescriptorOwner failed. Error: %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorOwner failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }
    }

    //
    // Handle group
    //
    PSID pGroup = NULL;
    if (sInfo & GROUP_SECURITY_INFORMATION)
    {
        BOOL bGroupDefaulted = FALSE;

        if (!GetSecurityDescriptorGroup( 
					pSD5,
					&pGroup,
					&bGroupDefaulted 
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorGroup failed. Error: %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorGroup failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }

        ASSERT(pGroup != NULL);
        ASSERT(IsValidSid(pGroup));

        if (!SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted))
        {
			DWORD gle = GetLastError(); 
			TrERROR(SECURITY, "SetSecurityDescriptorGroup failed. Error: %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorGroup failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }
        
    }

    //
    // Handle SACL
    //
    BOOL   bPresent = FALSE;
    BOOL   bDefaulted = FALSE;
    PACL   pAcl5;
    DWORD  dwAclLen;
    P<ACL> pSacl4 = NULL;

    if (sInfo & SACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorSacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorSacl failed. Error: %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorSacl failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }

        hr = MQSec_OK;
        if (bPresent)
        {
            if (pAcl5)
            {
                //
                // It's legal to have NULL Sacl. No need to convert it.
                //
                hr = _ConvertSaclToNT4Format( 
							dwObjectType,
							pAcl5,
							&dwAclLen,
							&pSacl4 
							);

                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 140);
                }
                if (pSacl4)
                {
                    ASSERT(IsValidAcl(pSacl4));
                }
                else
                {
                    //
                    // that's OK. sometimes there is a SACL wihtout any
                    // ACEs. let's convert it to no-SACL.
                    //
                    ASSERT(dwAclLen == 0);
                    bPresent = FALSE;
                }
            }
            else
            {
                //
                // that's kind of bug in NT. Flag is set but sacl is null.
                // trying to set this SecurityDescriptor with this value will
                // fail, with error 0x13 from ldap.
                // Reset the present flag.
                //
                bPresent = FALSE;
            }
        }
        if (!SetSecurityDescriptorSacl( 
					&sd,
					bPresent,
					pSacl4,
					bDefaulted
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "SetSecurityDescriptorSacl failed. Error: %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorSacl failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }
    }

    //
    // Handle DACL
    //
    //
    // BUGBUG. Workaround for beta2. Send to NT4 a SD with NUL DACL,
    // which mean full control to everyone.
    //
    P<ACL> pDacl4 = NULL;
    if (sInfo & DACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorDacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetSecurityDescriptorDacl failed. Error: %!winerr!", gle);
			ASSERT(("GetSecurityDescriptorDacl failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }

        hr = MQSec_OK;
        if (bPresent)
        {
            hr = _ConvertDaclToNT4Format( 
						dwObjectType,
						pAcl5,
						&dwAclLen,
						&pDacl4 
						);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 150);
            }
            ASSERT(IsValidAcl(pDacl4));
        }
        if (!SetSecurityDescriptorDacl( 
					&sd,
					bPresent,
					pDacl4,
					bDefaulted
					))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "SetSecurityDescriptorDacl failed. Error: %!winerr!", gle);
			ASSERT(("SetSecurityDescriptorDacl failed", gle == ERROR_SUCCESS));
			return HRESULT_FROM_WIN32(gle);
        }
    }

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwLen = 0;
    MakeSelfRelativeSD(&sd, NULL, &dwLen);
    DWORD gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER)
    {
		TrERROR(SECURITY, "MakeSelfRelativeSD failed. Error: %!winerr!", gle);
		return HRESULT_FROM_WIN32(gle);
    }
    
	AP<SECURITY_DESCRIPTOR> TempSD = (SECURITY_DESCRIPTOR *) new char[dwLen];
    if (!MakeSelfRelativeSD(&sd, TempSD, &dwLen))
    {
		gle = GetLastError();
		TrERROR(SECURITY, "MakeSelfRelativeSD failed. Error: %!winerr!", gle);
		ASSERT(("MakeSelfRelativeSD failed", gle == ERROR_SUCCESS));
		return HRESULT_FROM_WIN32(gle);
    }

    *pdwSD4Len = dwLen;

    *ppSD4 = TempSD.detach();

    return MQSec_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\certget.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certget.cpp

Abstract:
    Implement the "get" methods, for retrieving data from a certificate.

Author:
    Doron Juster (DoronJ)  14-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "certget.tmh"

static WCHAR *s_FN=L"certifct/certget";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetIssuer()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetIssuer( OUT LPWSTR *ppszLocality,
                                      OUT LPWSTR *ppszOrg,
                                      OUT LPWSTR *ppszOrgUnit,
                                      OUT LPWSTR *ppszCommon ) const
{
    P<CERT_NAME_INFO> pNameInfo = NULL ;
    HRESULT hr = GetIssuerInfo( &pNameInfo ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10) ;
    }

    hr = GetNames( pNameInfo,
                   ppszLocality,
                   ppszOrg,
                   ppszOrgUnit,
                   ppszCommon ) ;

    return LogHR(hr, s_FN, 20) ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetIssuerInfo()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetIssuerInfo(
                             OUT CERT_NAME_INFO **ppNameInfo ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 30) ;
    }
    ASSERT(!m_fCreatedInternally) ;

    BYTE   *pBuf = NULL ;
    DWORD   dwBufSize = 0 ;
    HRESULT hr = _DecodeName( m_pCertContext->pCertInfo->Issuer.pbData,
                              m_pCertContext->pCertInfo->Issuer.cbData,
                              &pBuf,
                              &dwBufSize ) ;
    if (FAILED(hr))
    {
        delete pBuf ;
        return LogHR(hr, s_FN, 40) ;
    }
    ASSERT(pBuf && dwBufSize) ;

    *ppNameInfo = (CERT_NAME_INFO*) pBuf ;

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetSubject()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetSubject( OUT LPWSTR *ppszLocality,
                                       OUT LPWSTR *ppszOrg,
                                       OUT LPWSTR *ppszOrgUnit,
                                       OUT LPWSTR *ppszCommon ) const
{
    P<CERT_NAME_INFO> pNameInfo = NULL ;
    HRESULT hr = GetSubjectInfo( &pNameInfo ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50) ;
    }

    hr = GetNames( pNameInfo,
                   ppszLocality,
                   ppszOrg,
                   ppszOrgUnit,
                   ppszCommon ) ;

    return LogHR(hr, s_FN, 60) ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetSubjectInfo()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetSubjectInfo(
                                 OUT CERT_NAME_INFO **ppNameInfo ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 70) ;
    }
    ASSERT(!m_fCreatedInternally) ;

    BYTE   *pBuf = NULL ;
    DWORD   dwBufSize = 0 ;
    HRESULT hr = _DecodeName( m_pCertContext->pCertInfo->Subject.pbData,
                              m_pCertContext->pCertInfo->Subject.cbData,
                              &pBuf,
                              &dwBufSize ) ;
    if (FAILED(hr))
    {
        delete pBuf ;
        return LogHR(hr, s_FN, 80) ;
    }
    ASSERT(pBuf && dwBufSize) ;

    *ppNameInfo = (CERT_NAME_INFO*) pBuf ;

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetNames()
//
//  Description: Get a name component[s] from a CERT_NAME_INFO buffer.
//
//+-----------------------------------------------------------------------

#define  GET_A_NAME(ppBuf, point)           \
    if (ppBuf && !(*ppBuf))                 \
    {                                       \
        hr = _GetAName( prgRDN, ppBuf ) ;   \
        if (FAILED(hr))                     \
        {                                   \
            return LogHR(hr, s_FN, point) ; \
        }                                   \
    }

HRESULT CMQSigCertificate::GetNames( IN  CERT_NAME_INFO *pNameInfo,
                                     OUT LPWSTR          *ppszLocality,
                                     OUT LPWSTR          *ppszOrg,
                                     OUT LPWSTR          *ppszOrgUnit,
                                     OUT LPWSTR          *ppszCommon,
                                     OUT LPWSTR      *ppEmailAddress ) const
{
    HRESULT hr = MQ_OK ;
    DWORD dwc =  pNameInfo->cRDN ;
    CERT_RDN *prgRDN = pNameInfo->rgRDN ;
    P<WCHAR>  pEmailName = NULL ;
    LPWSTR   *ppEmailName = &pEmailName ;

    for ( ; dwc > 0 ; )
    {

        CERT_RDN_ATTR  *prgRDNAttr = prgRDN->rgRDNAttr ;

        if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_ORGANIZATION_NAME) == 0)
        {
            GET_A_NAME(ppszOrg, 90) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId,
                          szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
        {
            GET_A_NAME(ppszOrgUnit, 100) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_LOCALITY_NAME) == 0)
        {
            GET_A_NAME(ppszLocality, 110) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_COMMON_NAME) == 0)
        {
            GET_A_NAME(ppszCommon, 120) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_RSA_emailAddr) == 0)
        {
            GET_A_NAME(ppEmailName, 130) ;
        }

        prgRDN++ ;
        dwc-- ;
    }

    if (ppszCommon && *ppszCommon && !ppEmailAddress && pEmailName)
    {
        //
        // Append the email address to the common name.
        //
        DWORD dwSize = lstrlen(pEmailName) + lstrlen(*ppszCommon) + 12 ;
        WCHAR *pBuf = new WCHAR[ dwSize ] ;
        lstrcpy(pBuf, *ppszCommon) ;
        lstrcat(pBuf, L", Email=") ;
        lstrcat(pBuf, pEmailName) ;

        delete *ppszCommon ;
        *ppszCommon = pBuf ;
    }

    if (ppEmailAddress)
    {
        *ppEmailAddress = pEmailName.detach();
    }

    return LogHR(hr, s_FN, 100) ;
}

#undef  GET_A_NAME

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetValidity()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetValidity( OUT FILETIME *pftNotBefore,
                                        OUT FILETIME *pftNotAfter ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 150) ;
    }
    ASSERT(!m_fCreatedInternally) ;

    if (pftNotBefore)
    {
        *pftNotBefore = m_pCertContext->pCertInfo->NotBefore ;
    }

    if (pftNotAfter)
    {
        *pftNotAfter = m_pCertContext->pCertInfo->NotAfter ;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetValidity()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetPublicKey( IN  HCRYPTPROV hProv,
                                         OUT HCRYPTKEY  *phKey ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 160) ;
    }
    if (!hProv || !phKey)
    {
        return  LogHR(MQSec_E_INVALID_PARAMETER, s_FN, 170) ;
    }

    CERT_PUBLIC_KEY_INFO *pPubKey =
                     &(m_pCertContext->pCertInfo->SubjectPublicKeyInfo) ;

    BOOL fImp =  CryptImportPublicKeyInfo( hProv,
                                           MY_ENCODING_TYPE,
                                           pPubKey,
                                           phKey ) ;
    if (!fImp)
    {
        return LogHR(MQSec_E_CAN_NOT_GET_KEY, s_FN, 180) ;
    }

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\certifct.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: certifct.h

Abstract:

    main header for certificates handling code.

Author:

    Doron Juster  (DoronJ)  25-May-1998

--*/

//+-------------------------------------------
//
//  Internal functions.
//
//+-------------------------------------------

BOOL _CryptAcquireVerContext( HCRYPTPROV *phProv ) ;

HRESULT _CloneCertFromStore ( OUT CMQSigCertificate **ppCert,
                              HCERTSTORE              hStore,
                              IN  LONG                iCertIndex ) ;

//+-------------------------------------------

#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

#define ASSERT_CERT_INFO                \
    ASSERT(m_pCertInfo) ;               \
    if (!m_pCertInfo)                   \
    {                                   \
        return MQSec_E_INVALID_CALL ;   \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\certpriv.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certpriv.cpp

Abstract:
    Implement the private methods of class  CMQSigCertificate

Author:
    Doron Juster (DoronJ)  11-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "certpriv.tmh"

static WCHAR *s_FN=L"certifct/certpriv";

HRESULT  SetKeyContainerSecurity( HCRYPTPROV hProv ) ;

//+-----------------------------------------------------------------------
//
//   HRESULT CMQSigCertificate::_Create()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::_Create(IN PCCERT_CONTEXT  pCertContext)
{
    if (!pCertContext)
    {
        //
        // Object for creating new certificate
        //
        m_fCreatedInternally = TRUE;
        m_pCertInfo = new CERT_INFO;
        memset(m_pCertInfo, 0, sizeof(CERT_INFO));

        //
        // Initialize version and serial number
        //
        m_pCertInfo->dwVersion = CERT_V3;

        m_dwSerNum =  0xaaa55a55;
        m_pCertInfo->SerialNumber.pbData = (BYTE*) &m_dwSerNum;
        m_pCertInfo->SerialNumber.cbData = sizeof(m_dwSerNum);

        //
        // Initialize the signing algorithm. At present we use a predefine
        // one. Caller can't change it.
        //
        memset(&m_SignAlgID, 0, sizeof(m_SignAlgID));
        m_pCertInfo->SignatureAlgorithm.pszObjId = szOID_RSA_MD5;
        m_pCertInfo->SignatureAlgorithm.Parameters = m_SignAlgID;
    }
    else
    {
        //
        // Object for extracting data from existing certificate
        //
        m_pCertContext = pCertContext;

        m_pEncodedCertBuf = m_pCertContext->pbCertEncoded;
        m_dwCertBufSize   = m_pCertContext->cbCertEncoded;

        m_pCertInfoRO = m_pCertContext->pCertInfo;

        ASSERT(m_dwCertBufSize);
        ASSERT(m_pEncodedCertBuf);
    }

    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_InitCryptProviderRead()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::_InitCryptProviderRead()
{
    if (m_hProvRead)
    {
        return MQ_OK;
    }

    if (!_CryptAcquireVerContext( &m_hProvRead ))
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 190);
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_InitCryptProviderCreate()
//
//  Init the crypto provider, and create public/private key pair if
//  necessray. These are the keys for internal certificate.
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::_InitCryptProviderCreate( 
		IN BOOL fCreate,
		IN BOOL fMachine 
		)
{
    if (m_hProvCreate)
    {
        return MQSec_OK;
    }

    HRESULT hr = MQSec_OK;
    DWORD   dwMachineFlag = 0;
    BOOL    fContainerCreated = FALSE;

    LPWSTR lpswContainerName = MSMQ_INTCRT_KEY_CONTAINER_W;
    if (fMachine)
    {
        lpswContainerName = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_W;
        dwMachineFlag = CRYPT_MACHINE_KEYSET;
    }

    if (fCreate)
    {
        //
        // Delete present keys container, so it will be created later.
        // Don't check for returned error. not relevant. Following code
        // will do the error checking.
        //
        CryptAcquireContext( 
			&m_hProvCreate,
			lpswContainerName,
			MS_DEF_PROV,
			PROV_RSA_FULL,
			(CRYPT_DELETEKEYSET | dwMachineFlag) 
			);
    }

    if (!CryptAcquireContext(
				&m_hProvCreate,
				lpswContainerName,
				MS_DEF_PROV,
				PROV_RSA_FULL,
				dwMachineFlag 
				))
    {
        switch(GetLastError())
        {
        case NTE_KEYSET_ENTRY_BAD:
            //
            // Delete the bat key container.
            //
            if (!CryptAcquireContext(
						&m_hProvCreate,
						lpswContainerName,
						MS_DEF_PROV,
						PROV_RSA_FULL,
						(CRYPT_DELETEKEYSET | dwMachineFlag) 
						))
            {
                TrERROR(SECURITY, "Failed to aquire crypto context when deleting bad keyset entry (container=%ls). %!winerr!", lpswContainerName, GetLastError());
                return MQSec_E_DEL_BAD_KEY_CONTNR;
            }
            //
            // Fall through
            //
        case NTE_BAD_KEYSET:
            //
            // Create the key container.
            //
            if (!CryptAcquireContext(
						&m_hProvCreate,
						lpswContainerName,
						MS_DEF_PROV,
						PROV_RSA_FULL,
						(CRYPT_NEWKEYSET | dwMachineFlag) 
						))
            {
                TrERROR(SECURITY, "Failed to aquire crypto context when creating new keyset entry (container=%ls). %!winerr!", lpswContainerName, GetLastError());
                return MQSec_E_CREATE_KEYSET;
            }
            fContainerCreated = TRUE ;
            break;

        default:
            return LogHR(MQ_ERROR, s_FN, 40) ;
        }
    }

    if (fContainerCreated && fMachine)
    {
        //
        // Secure the keys container.
        // Same as done for encryption key.
        //
        hr = SetKeyContainerSecurity( m_hProvCreate ) ;
        ASSERT(SUCCEEDED(hr)) ;
    }

    return LogHR(hr, s_FN, 50) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\certutil.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certutil.cpp

Abstract:
    General Utility functions.

Author:
    Doron Juster (DoronJ)  17-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "cs.h"

#include "certutil.tmh"

static WCHAR *s_FN=L"certifct/certutil";

//+-------------------------------------------------------------------
//
//   BOOL _CryptAcquireVerContext( HCRYPTPROV *phProv )
//
//+-------------------------------------------------------------------

static CCriticalSection s_csAcquireContext;
static CHCryptProv s_hVerProv;

BOOL _CryptAcquireVerContext(HCRYPTPROV *phProv)
{

    if (s_hVerProv)
    {
        *phProv = s_hVerProv;
        return TRUE;
    }

    *phProv = NULL;

    CS Lock(s_csAcquireContext);

    if (!s_hVerProv)
    {
        if (!CryptAcquireContext( 
				&s_hVerProv,
				NULL,
				MS_DEF_PROV,
				PROV_RSA_FULL,
				CRYPT_VERIFYCONTEXT
				))
        {
			DWORD gle = GetLastError();
            TrERROR(SECURITY, "CryptAcquireContext Failed, gle = %!winerr!", gle);
            return FALSE;
        }
	}

    *phProv = s_hVerProv;
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  HRESULT _CloneCertFromStore ()
//
//+-------------------------------------------------------------------

HRESULT _CloneCertFromStore ( OUT CMQSigCertificate **ppCert,
                              HCERTSTORE              hStore,
                              IN  LONG                iCertIndex )
{
    LONG iCert = 0 ;
    PCCERT_CONTEXT pCertContext;
    PCCERT_CONTEXT pPrevCertContext;

    pCertContext = CertEnumCertificatesInStore(hStore, NULL);
    while (pCertContext)
    {
        if (iCert == iCertIndex)
        {
            R<CMQSigCertificate> pCert = NULL ;
            HRESULT hr = MQSigCreateCertificate(
                                     &pCert.ref(),
                                     NULL,
                                     pCertContext->pbCertEncoded,
                                     pCertContext->cbCertEncoded ) ;

            CertFreeCertificateContext(pCertContext) ;

            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 20) ;
            }

            *ppCert = pCert.detach();
            return MQSec_OK ;
        }
        //
        // Get next certificate
        //
        pPrevCertContext = pCertContext,
        pCertContext = CertEnumCertificatesInStore( hStore,
                                                    pPrevCertContext ) ;
        iCert++ ;
    }

    return  LogHR(MQSec_E_CERT_NOT_FOUND, s_FN, 30) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\certvlid.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certvlid.cpp

Abstract:
    Implement the "valid" methods, for verifying the validity of the
    certificate.

Author:
    Doron Juster (DoronJ)  16-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "certvlid.tmh"

static WCHAR *s_FN=L"certifct/certvlid";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetIssuer()
//
//  Description: Verify the time validity of the certificate, relative
//      to "pTime". If pTime is NULL the verify relative to current time.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::IsTimeValid(IN FILETIME *pTime) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 10) ;
    }

    LONG iVer = CertVerifyTimeValidity( pTime,
                                        m_pCertContext->pCertInfo ) ;
    if (iVer < 0)
    {
        return  LogHR(MQSec_E_CERT_NOT_VALID_YET, s_FN, 20) ;
    }
    else if (iVer > 0)
    {
        return  LogHR(MQSec_E_CERT_EXPIRED, s_FN, 30) ;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::IsCertificateValid()
//
//  Description: Verify that this certificate is valid, i.e., it's signed
//       by "pIssuerCert" and both certificates (this one and the issuer
//       one) are valid regarding times.
//       if "pTime" is null then validity is relative to current time.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::IsCertificateValid(
                             IN CMQSigCertificate *pIssuerCert,
                             IN DWORD              dwFlagsIn,
                             IN FILETIME          *pTime,
                             IN BOOL               fIgnoreNotBefore ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 40) ;
    }

    HRESULT hr ;

    if (pTime)
    {
        hr = IsTimeValid(pTime) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 50) ;
        }
        hr = pIssuerCert->IsTimeValid(pTime) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60) ;
        }
    }

    PCCERT_CONTEXT pIssuerContext = pIssuerCert->m_pCertContext ;
    if (!pIssuerContext)
    {
        return LogHR(MQSec_E_INVALID_PARAMETER, s_FN, 70) ;
    }

    DWORD dwFlags = dwFlagsIn ;
    BOOL fValid = CertVerifySubjectCertificateContext( m_pCertContext,
                                                       pIssuerContext,
                                                       &dwFlags ) ;
    if (!fValid)
    {
        TrERROR(SECURITY, "Failed to verify certificate. Flags=0x%x %!winerr!", dwFlagsIn, GetLastError());
        return MQSec_E_CANT_VALIDATE;
    }
    else if (dwFlags == 0)
    {
        return MQ_OK ;
    }
    else if (dwFlags & CERT_STORE_SIGNATURE_FLAG)
    {
        return  LogHR(MQSec_E_CERT_NOT_SIGNED, s_FN, 85) ;
    }
    else if (dwFlags & CERT_STORE_TIME_VALIDITY_FLAG)
    {
        if (fIgnoreNotBefore)
        {
            //
            // Now check only times. If NotBefore is violated, then ignore
            // and return Ok. The common case for this scenario is internal
            // certificate. If clock of client is advanced relative to
            // server, then trying to renew an internal certificate will
            // fail on NotBefore. We ignore this.
            //
            hr = IsTimeValid() ;
            if (SUCCEEDED(hr) || (hr == MQSec_E_CERT_NOT_VALID_YET))
            {
                return MQ_OK ;
            }
        }
        return  LogHR(MQSec_E_CERT_TIME_NOTVALID, s_FN, 90) ;
    }
    else if (dwFlags & CERT_STORE_NO_CRL_FLAG)
    {
        //
        // Issuer doesn't have a CRL in store. That's OK.
        //
        return MQ_OK ;
    }
    else if (dwFlags & CERT_STORE_REVOCATION_FLAG)
    {
        return LogHR(MQSec_E_CERT_REVOCED, s_FN, 100) ;
    }

    ASSERT(0) ;
    return LogHR(MQSec_E_UNKNOWN, s_FN, 110) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\certput.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certput.cpp

Abstract:
    Implement the "put" methods of class  CMQSigCertificate.
    Used for creating a certificate.

Author:
    Doron Juster (DoronJ)  11-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include <uniansi.h>

#include "certput.tmh"

static WCHAR *s_FN=L"certifct/certput";


//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutIssuerA( )
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutIssuer( LPWSTR lpszLocality,
									  LPWSTR lpszOrg,
									  LPWSTR lpszOrgUnit,
									  LPWSTR lpszDomain,
									  LPWSTR lpszUser,
									  LPWSTR lpszMachine )
{
    ASSERT_CERT_INFO ;
    ASSERT(m_pCertInfo->Issuer.cbData == 0) ;

    DWORD  cbIssuerNameEncoded = 0 ;
    BYTE   *pbIssuerNameEncoded = NULL;

    HRESULT hr = _EncodeName( lpszLocality,
                              lpszOrg,
                              lpszOrgUnit,
                              lpszDomain,
                              lpszUser,
                              lpszMachine,
                              &pbIssuerNameEncoded,
                              &cbIssuerNameEncoded) ;
    if (SUCCEEDED(hr))
    {
        m_pCertInfo->Issuer.cbData = cbIssuerNameEncoded;
        m_pCertInfo->Issuer.pbData = pbIssuerNameEncoded;
    }

    return LogHR(hr, s_FN, 10) ;
}


//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutSubjectA()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutSubject( LPWSTR lpszLocality,
                                       LPWSTR lpszOrg,
                                       LPWSTR lpszOrgUnit,
                                       LPWSTR lpszDomain,
                                       LPWSTR lpszUser,
                                       LPWSTR lpszMachine )
{
    ASSERT_CERT_INFO ;
    ASSERT(m_pCertInfo->Subject.cbData == 0) ;

    DWORD  cbSubjectNameEncoded = 0 ;
    BYTE   *pbSubjectNameEncoded = NULL;

    HRESULT hr = _EncodeName( lpszLocality,
                              lpszOrg,
                              lpszOrgUnit,
                              lpszDomain,
                              lpszUser,
                              lpszMachine,
                              &pbSubjectNameEncoded,
                              &cbSubjectNameEncoded) ;
    if (SUCCEEDED(hr))
    {
        m_pCertInfo->Subject.cbData = cbSubjectNameEncoded;
        m_pCertInfo->Subject.pbData = pbSubjectNameEncoded;
    }

    return LogHR(hr, s_FN, 30) ;
}


//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutValidity( WORD wYears )
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutValidity( WORD wYears )
{
    ASSERT_CERT_INFO ;

    SYSTEMTIME  sysTime ;
    GetSystemTime(&sysTime) ;

    FILETIME  ftNotBefore ;
    BOOL fTime = SystemTimeToFileTime( &sysTime,
                                       &ftNotBefore ) ;
    if (!fTime)
    {
        return LogHR(MQSec_E_UNKNOWN, s_FN, 50) ;
    }
    m_pCertInfo->NotBefore = ftNotBefore ;

    sysTime.wYear = sysTime.wYear + wYears;

    //
    //  If current date is 29 Feb, change to 28 Feb
    //  To overcome leap year problem
    //
    if ( sysTime.wMonth == 2 &&
         sysTime.wDay == 29 )
    {
        sysTime.wDay = 28;
    }

    FILETIME  ftNotAfter ;
    fTime = SystemTimeToFileTime( &sysTime,
                                  &ftNotAfter ) ;
    if (!fTime)
    {
        return LogHR(MQSec_E_UNKNOWN, s_FN, 55) ;
    }
    m_pCertInfo->NotAfter = ftNotAfter ;

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutPublicKey()
//
//  Input:
//      fMachine- if TRUE, created the private key in the context of the
//                machine, not under the context of a user.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutPublicKey( IN  BOOL  fRenew,
                                         IN  BOOL  fMachine,
                                         OUT BOOL *pfCreate )
{
    ASSERT_CERT_INFO ;
    BOOL  fRet ;

    if (pfCreate)
    {
        *pfCreate = FALSE ;
    }

    HRESULT hr = _InitCryptProviderCreate( fRenew,
                                           fMachine ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60) ;
    }

    BOOL fGenKey = fRenew ;
    CHCryptKey hKey;

    if (!fGenKey)
    {
        //
        // First, try to get existing keys.
        //
        if (!CryptGetUserKey(m_hProvCreate, AT_SIGNATURE, &hKey))
        {
            if (GetLastError() != NTE_NO_KEY)
            {
                LogNTStatus(GetLastError(), s_FN, 70) ;
                return MQSec_E_PUTKEY_GET_USER;
            }
            fGenKey = TRUE ;
        }
    }

    if (fGenKey)
    {
        fRet = CryptGenKey( m_hProvCreate,
                            AT_SIGNATURE,
                            CRYPT_EXPORTABLE,
                            &hKey ) ;
        if (!fRet)
        {
            TrERROR(SECURITY, "Failed to generate crypto key. %!winerr!", GetLastError());
            return MQSec_E_PUTKEY_GEN_USER;
        }

        if (pfCreate)
        {
            *pfCreate = TRUE ;
        }
    }

    //
    // Call CryptExportPublicKeyInfo to get the size of the returned
    // information.
    //
    DWORD    cbPublicKeyInfo = 0 ;

    BOOL fReturn = CryptExportPublicKeyInfo(
                      m_hProvCreate,         // Provider handle
                      AT_SIGNATURE,          // Key spec
                      MY_ENCODING_TYPE,      // Encoding type
                      NULL,                  // pbPublicKeyInfo
                      &cbPublicKeyInfo);     // Size of PublicKeyInfo

    if (!fReturn || (cbPublicKeyInfo < sizeof(CERT_PUBLIC_KEY_INFO)))
    {
        TrERROR(SECURITY, "Failed to get required length to export public key. %!winerr!", GetLastError());
        return MQSec_E_EXPORT_PUB_FIRST;
    }

    CERT_PUBLIC_KEY_INFO *pBuf =
                (CERT_PUBLIC_KEY_INFO *) new BYTE[ cbPublicKeyInfo ] ;
    if (m_pPublicKeyInfo)
    {
        delete m_pPublicKeyInfo.detach() ;
    }
    m_pPublicKeyInfo = pBuf ; // auto delete pointer.

    //
    // Call CryptExportPublicKeyInfo to get pbPublicKeyInfo.
    //
    fReturn = CryptExportPublicKeyInfo(
                      m_hProvCreate,         // Provider handle
                      AT_SIGNATURE,          // Key spec
                      MY_ENCODING_TYPE,      // Encoding type
                      pBuf,                  // pbPublicKeyInfo
                      &cbPublicKeyInfo);     // Size of PublicKeyInfo
    if (!fReturn)
    {
        TrERROR(SECURITY, "Failed to export signature public key. %!winerr!", GetLastError());
        return MQSec_E_EXPORT_PUB_SECOND;
    }

    m_pCertInfo->SubjectPublicKeyInfo = *pBuf ;

    TrTRACE(SECURITY, "Successfully exported signature public key. size=%u", cbPublicKeyInfo);
    return MQSec_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\cmqcert.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    cmqcert.cpp

Abstract:
    Implement the methods of class  CMQSigCertificate

Author:
    Doron Juster (DoronJ)  04-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "cmqcert.tmh"

static WCHAR *s_FN=L"certifct/cmqcert";

extern DWORD  g_cOpenCert;

//+---------------------------------------------------------
//
//  constructor and destructor
//
//+---------------------------------------------------------

CMQSigCertificate::CMQSigCertificate() :
            m_fCreatedInternally(FALSE),
            m_fDeleted(FALSE),
            m_fKeepContext(FALSE),
            m_pEncodedCertBuf(NULL),
            m_pCertContext(NULL),
            m_hProvCreate(NULL),
            m_hProvRead(NULL),
            m_pPublicKeyInfo(NULL),
            m_pCertInfoRO(NULL),
            m_dwCertBufSize(0)
{
    m_pCertInfo = NULL;
}

CMQSigCertificate::~CMQSigCertificate()
{
    if (m_fCreatedInternally)
    {
        ASSERT(!m_pCertContext);
        if (m_pEncodedCertBuf)
        {
            ASSERT(m_dwCertBufSize > 0);
            delete m_pEncodedCertBuf;
            m_pEncodedCertBuf = NULL;
        }
    }
    else if (m_pCertContext)
    {
        ASSERT(m_pEncodedCertBuf);
        CertFreeCertificateContext(m_pCertContext);
    }
    else
    {
        ASSERT(m_fDeleted || m_fKeepContext);
    }
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::EncodeCert()
//
//   This method sign and encode the certificate. The result is a buffer,
//   allocated here and returned in "ppCertBuf", which holds the encoded
//   certificate.
//   Both input pointers are optional. The encoded buffer is always kept
//   in the object and can be retieved later by calling "GetCertBlob".
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::EncodeCert( 
	IN BOOL     fMachine,
	OUT BYTE  **ppCertBuf,
	OUT DWORD  *pdwSize 
	)
{
    ASSERT_CERT_INFO;

    HRESULT hr = _InitCryptProviderCreate(FALSE, fMachine);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    CRYPT_OBJID_BLOB Parameters;
    memset(&Parameters, 0, sizeof(Parameters));

    CRYPT_ALGORITHM_IDENTIFIER SigAlg;
    SigAlg.pszObjId = szOID_RSA_MD5RSA;
    SigAlg.Parameters = Parameters;

    //
    // Call CryptSignAndEncodeCertificate to get the size of the
    // returned blob.
    //
    ASSERT(m_hProvCreate);
    BOOL fReturn = CryptSignAndEncodeCertificate(
						m_hProvCreate,                   // Crypto provider
						AT_SIGNATURE,                    // Key spec.
						MY_ENCODING_TYPE,                // Encoding type
						X509_CERT_TO_BE_SIGNED,          // Struct type
						m_pCertInfo,                     // Struct info
						&SigAlg,                         // Signature algorithm
						NULL,                            // Not used
						NULL,                            // pbSignedEncodedCertReq
						&m_dwCertBufSize				 // Size of cert blob
						); 
    if (!fReturn)
    {
        TrERROR(SECURITY, "Failed to get the size for signed and encoded certificate. %!winerr!", GetLastError());
        return MQSec_E_ENCODE_CERT_FIRST;
    }

    m_pEncodedCertBuf = (BYTE*) new BYTE[m_dwCertBufSize];

    //
    // Call CryptSignAndEncodeCertificate to get the
    // returned blob.
    //
    fReturn = CryptSignAndEncodeCertificate(
					m_hProvCreate,                  // Crypto provider
					AT_SIGNATURE,                   // Key spec.
					MY_ENCODING_TYPE,               // Encoding type
					X509_CERT_TO_BE_SIGNED,         // Struct type
					m_pCertInfo,                    // Struct info
					&SigAlg,                        // Signature algorithm
					NULL,                           // Not used
					m_pEncodedCertBuf,              // buffer
					&m_dwCertBufSize				// Size of cert blob
					);            
    if (!fReturn)
    {
        TrERROR(SECURITY, "Failed to signed and encoded certificate. %!winerr!", GetLastError());
        return MQSec_E_ENCODE_CERT_SECOND;
    }

    if (ppCertBuf)
    {
        *ppCertBuf = m_pEncodedCertBuf;
    }
    if (pdwSize)
    {
        *pdwSize = m_dwCertBufSize;
    }

    m_pCertInfoRO = m_pCertInfo;

    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::AddToStore( HCERTSTORE hStore )
//
//  Description:  Add the certificate to a store
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::AddToStore(IN HCERTSTORE hStore) const
{
    if (!m_pEncodedCertBuf)
    {
        return LogHR(MQSec_E_INVALID_CALL, s_FN, 40);
    }

    BOOL fAdd =  CertAddEncodedCertificateToStore( 
						hStore,
						MY_ENCODING_TYPE,
						m_pEncodedCertBuf,
						m_dwCertBufSize,
						CERT_STORE_ADD_NEW,
						NULL 
						);
    if (!fAdd)
    {
        TrERROR(SECURITY, "Failed add encoded crtificate to the store. %!winerr!", GetLastError());
        return MQSec_E_CAN_NOT_ADD;
    }

    return MQSec_OK;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::DeleteFromStore()
//
//  Description:  Delete the certificate from its store. This method
//      makes the certificate context (m_pCertContext) invalid.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::DeleteFromStore()
{
    if (!m_pCertContext)
    {
        return LogHR(MQSec_E_INVALID_CALL, s_FN, 60);
    }

    BOOL fDel =  CertDeleteCertificateFromStore(m_pCertContext);

    m_pCertContext = NULL;
    m_fDeleted = TRUE;

    if (!fDel)
    {
        DWORD dwErr = GetLastError();
        LogNTStatus(dwErr, s_FN, 65);
        if (dwErr == E_ACCESSDENIED)
        {
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 70);
        }
        else
        {
            return LogHR(MQSec_E_CAN_NOT_DELETE, s_FN, 80);
        }
    }

    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetCertDigest(OUT GUID  *pguidDigest)
//
//  Description:  Compute the digest of the certificate.
//      Use only the "to be signed" portion of the certificate. This is
//      necessary for keeping compatibility with MSMQ 1.0, which used
//      digsig.dll. digsig hashes only the "to be signed" part.
//
//      The encoded certificate, held by "m_pEncodedCertBuf" is already
//      signed so it can not be used for computing the digest. this is
//      why CERT_INFO (m_pCertInfoRO) is encoded again, with flag
//      X509_CERT_TO_BE_SIGNED. The result of this encoding is used to
//      compute the digest.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetCertDigest(OUT GUID  *pguidDigest)
{
    HRESULT hr = MQSec_OK;

    if (!m_pCertInfoRO)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 90);
    }

    DWORD dwSize = 0;
    BOOL fEncode = CryptEncodeObject(
						MY_ENCODING_TYPE,			// Encoding type
						X509_CERT_TO_BE_SIGNED,		// Struct type
						m_pCertInfoRO,				// Address of struct.
						NULL,						// pbEncoded
						&dwSize						// pbEncoded size
						);               
    if ((dwSize == 0) || !fEncode)
    {
        TrERROR(SECURITY, "Failed to get the size for encoding certificate. %!winerr!", GetLastError());
        return MQSec_E_ENCODE_HASH_FIRST;
    }

    P<BYTE> pBuf = new BYTE[dwSize];
    fEncode = CryptEncodeObject(
					MY_ENCODING_TYPE,			// Encoding type
					X509_CERT_TO_BE_SIGNED,		// Struct type
					m_pCertInfoRO,				// Address of struct.
					pBuf,						// pbEncoded
					&dwSize						// pbEncoded size
					);
    if (!fEncode)
    {
        TrERROR(SECURITY, "Failed to encode certificate. %!winerr!", GetLastError());
        return MQSec_E_ENCODE_HASH_SECOND;
    }

    hr = _InitCryptProviderRead();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }
    ASSERT(m_hProvRead);

    CHCryptHash hHash;
    BOOL fCreate =  CryptCreateHash( 
						m_hProvRead,
						CALG_MD5,
						0,
						0,
						&hHash 
						);
    if (!fCreate)
    {
        TrERROR(SECURITY, "Failed to create MD5 hash. %!winerr!", GetLastError());
        return MQSec_E_CANT_CREATE_HASH;
    }

    BOOL fHash = CryptHashData( 
						hHash,
						pBuf,
						dwSize,
						0 
						);
    if (!fHash)
    {
        TrERROR(SECURITY, "Failed to hash data. %!winerr!", GetLastError());
        return MQSec_E_CAN_NOT_HASH;
    }

    dwSize = sizeof(GUID);
    BOOL fGet = CryptGetHashParam( 
					hHash,
					HP_HASHVAL,
					(BYTE*) pguidDigest,
					&dwSize,
					0 
					);
    if (!fGet)
    {
        TrERROR(SECURITY, "Failed to get hash value from hash object. %!winerr!", GetLastError());
        return MQSec_E_CAN_NOT_GET_HASH;
    }

    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//   HRESULT CMQSigCertificate::Release()
//
//  Description:  delete this object. cleanup is done in the destructor.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::Release(BOOL fKeepContext)
{
    if (fKeepContext)
    {
        m_fKeepContext = TRUE;
        m_pCertContext = NULL;
    }
    g_cOpenCert--;
	TrTRACE(SECURITY, "Releasing Cert, g_cOpenCert = %d", g_cOpenCert);
    delete this;
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\cmqstore.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    cmqstore.cpp

Abstract:
    Implement the methods of class  CMQSigCertStore

Author:
    Doron Juster (DoronJ)  15-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "cmqstore.tmh"

static WCHAR *s_FN=L"certifct/cmqstore";

extern DWORD  g_cOpenCertStore;

//+---------------------------------------------------------
//
//  constructor and destructor
//
//+---------------------------------------------------------

CMQSigCertStore::CMQSigCertStore() :
            m_hStore(NULL),
            m_hProv(NULL),
            m_hKeyStoreReg(NULL)
{
}

CMQSigCertStore::~CMQSigCertStore()
{
    if (m_hStore)
    {
        CertCloseStore(m_hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }
    if (m_hKeyStoreReg)
    {
        RegCloseKey(m_hKeyStoreReg);
    }
}

//+---------------------------------------------------------
//
//  HRESULT CMQSigCertStore::Release()
//
//+---------------------------------------------------------

HRESULT CMQSigCertStore::Release()
{
    g_cOpenCertStore--;
	TrTRACE(SECURITY, "Releasing CertStore, g_cOpenCertStore = %d", g_cOpenCertStore);
    delete this;
    return MQ_OK;
}

//+--------------------------------------------------------------------
//
//  HRESULT CMQSigCertStore::_Open()
//
//  Input:
//      fMachine- TRUE if opening the store of LocalSystem services.
//
//+--------------------------------------------------------------------

HRESULT 
CMQSigCertStore::_Open( 
	IN  LPSTR      lpszRegRoot,
	IN  struct MQSigOpenCertParams *pParams 
	)
{
    LONG lRegError;

    REGSAM  rAccess = KEY_READ;
    if (pParams->bWriteAccess)
    {
        rAccess |= KEY_WRITE;
    }

    HKEY hRootRegKey = HKEY_CURRENT_USER;
    if (pParams->hCurrentUser)
    {
        ASSERT(!(pParams->bMachineStore));

        hRootRegKey = pParams->hCurrentUser;
    }
    else if (pParams->bMachineStore)
    {
        hRootRegKey = HKEY_LOCAL_MACHINE;
    }

    lRegError = RegOpenKeyExA(
					hRootRegKey,
					lpszRegRoot,
					0,
					rAccess,
					&m_hKeyStoreReg
					);
    if (lRegError != ERROR_SUCCESS)
    {
        if (pParams->bCreate)
        {
            //
            // Try to create the key.
            //
            DWORD dwDisposition ;
            lRegError = RegCreateKeyExA( 
								hRootRegKey,
								lpszRegRoot,
								0L,
								"",
								REG_OPTION_NON_VOLATILE,
								KEY_READ | KEY_WRITE,
								NULL,
								&m_hKeyStoreReg,
								&dwDisposition
								);
            if (lRegError != ERROR_SUCCESS)
            {
                TrERROR(SECURITY, "Failed to create user certificate store in registry (%hs). %!winerr!", lpszRegRoot, lRegError);
                return MQ_ERROR_CANNOT_CREATE_CERT_STORE;
            }
        }
        else
        {
            TrERROR(SECURITY, "Failed to open user certificate store in registry (%hs). %!winerr!", lpszRegRoot, lRegError);
            return MQ_ERROR_CANNOT_OPEN_CERT_STORE;
        }
    }

    ASSERT(m_hKeyStoreReg);

    HRESULT hr = _InitCryptProvider();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    DWORD dwStoreFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    if (!pParams->bWriteAccess)
    {
        //
        // Read only access to the certificate store.
        //
        dwStoreFlags |= CERT_STORE_READONLY_FLAG;
    }
    m_hStore = CertOpenStore(
					CERT_STORE_PROV_REG,
					X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
					m_hProv,
					dwStoreFlags,
					m_hKeyStoreReg
					);
    if (!m_hStore)
    {
        LogNTStatus(GetLastError(), s_FN, 40);
        return MQSec_E_CANT_OPEN_STORE;
    }
    return MQSec_OK;
}

//+---------------------------------------------------------
//
//  HRESULT CMQSigCertStore::_InitCryptProvider()
//
//+---------------------------------------------------------

HRESULT CMQSigCertStore::_InitCryptProvider()
{
    if (!_CryptAcquireVerContext(&m_hProv))
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 50);
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\encdname.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    encdname.cpp

Abstract:
    Implement the methods for encoding names

Author:
    Doron Juster (DoronJ)  08-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "uniansi.h"

#include "encdname.tmh"

static WCHAR *s_FN=L"certifct/encdname";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_EncodeName()
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::_EncodeName( 
	LPWSTR  lpszLocality,
	LPWSTR  lpszOrg,
	LPWSTR  lpszOrgUnit,
	LPWSTR  lpszDomain,
	LPWSTR  lpszUser,
	LPWSTR  lpszMachine,
	BYTE   **ppBuf,
	DWORD  *pdwBufSize 
	)
{
    int  cAttr = 0;

    P<CERT_RDN_ATTR> rgNameAttr = (CERT_RDN_ATTR*) new CERT_RDN_ATTR[4];

    rgNameAttr[cAttr].pszObjId = szOID_LOCALITY_NAME;
    rgNameAttr[cAttr].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr].Value.cbData = lstrlen(lpszLocality)*sizeof(WCHAR);
    rgNameAttr[cAttr].Value.pbData = (BYTE*) lpszLocality;

    cAttr++ ;
    rgNameAttr[cAttr].pszObjId = szOID_ORGANIZATION_NAME;
    rgNameAttr[cAttr].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr].Value.cbData = lstrlen(lpszOrg)*sizeof(WCHAR);
    rgNameAttr[cAttr].Value.pbData = (BYTE*) lpszOrg;

    cAttr++ ;
    rgNameAttr[cAttr].pszObjId = szOID_ORGANIZATIONAL_UNIT_NAME;
    rgNameAttr[cAttr].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr].Value.cbData = lstrlen(lpszOrgUnit)*sizeof(WCHAR);
    rgNameAttr[cAttr].Value.pbData = (BYTE*) lpszOrgUnit;

    WCHAR szCNBuf[MAX_PATH * 4];
    wsprintf(szCNBuf, L"%s\\%s, %s", lpszDomain, lpszUser, lpszMachine);

    cAttr++ ;
    rgNameAttr[cAttr ].pszObjId = szOID_COMMON_NAME;
    rgNameAttr[cAttr ].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr ].Value.cbData = lstrlen(szCNBuf)*sizeof(WCHAR);
    rgNameAttr[cAttr ].Value.pbData = (BYTE*) szCNBuf;

    cAttr++;
    ASSERT(cAttr == 4);
    HRESULT hr2 = _EncodeNameRDN( 
						rgNameAttr,
						cAttr,
						ppBuf,
						pdwBufSize 
						);

    return LogHR(hr2, s_FN, 10);
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_EncodeNameRDN()
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::_EncodeNameRDN( 
	CERT_RDN_ATTR *rgNameAttr,
	DWORD         cbRDNs,
	BYTE          **ppBuf,
	DWORD         *pdwBufSize 
	)
{
    //---------------------------------------------------------------
    // Declare and initialize a CERT_RDN array.
    //---------------------------------------------------------------
    P<CERT_RDN> pCertRdn = (CERT_RDN*) new CERT_RDN[cbRDNs];
    for (DWORD j = 0; j < cbRDNs; j++)
    {
        pCertRdn[j].cRDNAttr = 1;
        pCertRdn[j].rgRDNAttr = &rgNameAttr[j];
    }

    //---------------------------------------------------------------
    // Declare and initialize a CERT_NAME_INFO structure.
    //---------------------------------------------------------------
    CERT_NAME_INFO Name = {cbRDNs, pCertRdn};

    //---------------------------------------------------------------
    // Step 5.  Call CryptEncodeObject to get an encoded BYTE string.
    //---------------------------------------------------------------
    *pdwBufSize = 0;

    CryptEncodeObject(
		MY_ENCODING_TYPE,     // Encoding type
		X509_NAME,            // Struct type
		&Name,                // Address of CERT_NAME_INFO struct.
		NULL,                 // pbEncoded
		pdwBufSize			  // pbEncoded size
		);       

    if (0 == *pdwBufSize)
    {
        TrERROR(SECURITY, "Failed to get the size required for object encoding. %!winerr!", GetLastError());
        return MQSec_E_ENC_RDNNAME_FIRST;
    }

    *ppBuf = (BYTE*) new BYTE[*pdwBufSize];
    if (*ppBuf == NULL)
    {
        return LogHR(MQSec_E_NO_MEMORY, s_FN, 30);
    }

    if(!CryptEncodeObject(
            MY_ENCODING_TYPE,    // Encoding type
            X509_NAME,           // Struct type
            &Name,               // Address of CERT_NAME_INFO struct.
            *ppBuf,              // Buffer for encoded name.
            pdwBufSize			 // pbEncoded size
			))        
    {
        TrERROR(SECURITY, "Failed to encode object. %!winerr!", GetLastError());
        return MQSec_E_ENC_RDNNAME_SECOND;
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypt\encrypt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: encrypt.h

Abstract:

Author:
    Doron Juster (DoronJ)  19-Nov-1998
    Ilan Herbst  (ilanh)   10-June-2000

Revision History:

--*/

#ifndef _ENCRYPT_H_
#define _ENCRYPT_H_


HRESULT  
GetProviderProperties( 
	IN  enum   enumProvider  eProvider,
	OUT WCHAR **ppwszContainerName,
	OUT WCHAR **ppwszProviderName,
	OUT DWORD  *pdwProviderType 
	);


HRESULT  
SetKeyContainerSecurity( 
	HCRYPTPROV hProv 
	);


HRESULT 
PackPublicKey(
	IN      BYTE				*pKeyBlob,
	IN      ULONG				ulKeySize,
	IN      LPCWSTR				wszProviderName,
	IN      ULONG				ulProviderType,
	IN OUT  P<MQDSPUBLICKEYS>&  pPublicKeysPack 
	);

#endif // _ENCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\msgauthn.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
    msgauthn.cpp

Abstract:
    Code for message authentication.

Author:
    Doron Juster (DoronJ)  06-Sep-1999

Revision History:

--*/

#include <stdh_sec.h>

#include "msgauthn.tmh"

static WCHAR *s_FN=L"certifct/msgauthn";

//+-----------------------------------------------
//
//  HRESULT MQSigHashMessageProperties()
//
//  Hash an array of message properties.
//
//+-----------------------------------------------

HRESULT APIENTRY  MQSigHashMessageProperties(
                                 IN HCRYPTHASH           hHash,
                                 IN struct _MsgHashData *pHashData )
{
    for ( ULONG j = 0 ; j < pHashData->cEntries ; j++ )
    {
        if (!CryptHashData( hHash,
                            (pHashData->aEntries[j]).pData,
                            (pHashData->aEntries[j]).dwSize,
                            0 ))
        {
            DWORD dwErr = GetLastError() ;
            TrERROR(SECURITY, "In MQSigHashMessageProperties(), CryptHashData(%lut) failed, err- %lxh", j, dwErr);

            return LogHR(dwErr, s_FN, 100) ;
        }
    }

    return MQSec_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\decdname.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    decdname.cpp

Abstract:
    Implement the methods for decoding names

Author:
    Doron Juster (DoronJ)  08-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "uniansi.h"

#include "decdname.tmh"

static WCHAR *s_FN=L"certifct/decdname";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_DecodeName()
//
//  Description: Decode a CERT_NAME_BLOB into a CERT_NAME_INFO.
//
//  Paramters:  BYTE  *pEncodedName - Buffer holding a CERT_NAME_BLOB.
//              DWORD dwEncodedSize - size of blob in  CERT_NAME_BLOB
//
//              BYTE  **pBuf - Pointer to result CERT_NAME_INFO.
//                  Memory for this buffer is allocated in this method.
//              DWORD *pdwBufSize - Pointer to recieve size of buffer
//                  for CERT_NAME_INFO.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::_DecodeName( IN  BYTE  *pEncodedName,
                                        IN  DWORD dwEncodedSize,
                                        OUT BYTE  **pBuf,
                                        OUT DWORD *pdwBufSize ) const
{
    BOOL fDecode = CryptDecodeObject( MY_ENCODING_TYPE,
                                      X509_NAME,
                                      pEncodedName,
                                      dwEncodedSize,
                                      0,
                                      NULL,
                                      pdwBufSize ) ;
    if (!fDecode || (*pdwBufSize == 0))
    {
        LogNTStatus(GetLastError(), s_FN, 10) ;
        return MQSec_E_DCD_RDNNAME_FIRST;
    }

    *pBuf = new BYTE[ *pdwBufSize ] ;
    if (*pBuf == NULL)
    {
        return  LogHR(MQSec_E_NO_MEMORY, s_FN, 20) ;
    }

    fDecode = CryptDecodeObject( MY_ENCODING_TYPE,
                                 X509_NAME,
                                 pEncodedName,
                                 dwEncodedSize,
                                 0,
                                 *pBuf,
                                 pdwBufSize ) ;
    if (!fDecode)
    {
        delete *pBuf ;
        *pdwBufSize = 0 ;

        LogNTStatus(GetLastError(), s_FN, 30) ;
        return MQSec_E_DCD_RDNNAME_SECOND;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_GetAName()
//
//  Description: Get a name component from a CERT_RDN buffer.
//               Buffer for the name is allocated here.
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::_GetAName( 
	IN  CERT_RDN  *prgRDN,
	OUT LPWSTR     *ppszName 
	) const
{
    ASSERT(!(*ppszName));

    if (prgRDN->cRDNAttr != 1)
    {
        return  LogHR(MQSec_E_UNSUPPORT_RDNNAME, s_FN, 40);
    }

    CERT_RDN_ATTR  *prgRDNAttr = prgRDN->rgRDNAttr;
    CERT_RDN_VALUE_BLOB  Value = prgRDNAttr->Value;

    AP<WCHAR> pTmpName;
    if ((lstrcmpiA( prgRDNAttr->pszObjId, szOID_RSA_emailAddr ) == 0) &&
        (prgRDNAttr->dwValueType == CERT_RDN_IA5_STRING))
    {
        //
        // Special case for email address. it's ansi.
        //
		AP<char> pTmpAnsiName;
		DWORD dwSize = Value.cbData + 2;

		pTmpAnsiName = new char[dwSize];
		memset(pTmpAnsiName, 0, dwSize);
        memcpy(pTmpAnsiName, (char*) Value.pbData, Value.cbData) ;

		pTmpName = new WCHAR[dwSize];
		MultiByteToWideChar(CP_ACP, 0, pTmpAnsiName, -1, pTmpName, dwSize);
    }
	else
	{
		//
		// Get required buffer length
		//
		DWORD dwSize = CertRDNValueToStr(
							prgRDNAttr->dwValueType, 
							&Value, 
							NULL, 
							0
							);

		pTmpName = new WCHAR[dwSize];

		CertRDNValueToStr(
				prgRDNAttr->dwValueType, 
				&Value, 
				pTmpName.get(), 
				dwSize
				);
	}

    TrTRACE(SECURITY, "CMQSigCertificate::_GetAName, Name = %ls, ValueType = %d", pTmpName.get(), prgRDNAttr->dwValueType);
    *ppszName = pTmpName.detach();

    return LogHR(MQ_OK, s_FN, 60);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypt\packpkey.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: packpkey.cpp

Abstract:
    Pack public key into a DS blob.

Author:
    Doron Juster (DoronJ)  19-Nov-1998
	Ilan Herbst   (ilanh)  08-Jun-2000, MQSec_PackPublicKey

Revision History:

--*/

#include <stdh_sec.h>
#include <strsafe.h>

#include "packpkey.tmh"

static WCHAR *s_FN=L"encrypt/packpkey";

//+-------------------------------
//
//  HRESULT  _PackAKey()
//
//+-------------------------------

static 
HRESULT
_PackAKey( 
	IN  BYTE           *pKeyBlob,
	IN  ULONG           ulKeySize,
	IN  LPCWSTR         wszProviderName,
	IN  ULONG           ulProviderType,
	OUT MQDSPUBLICKEY **ppPublicKeyPack 
	)
{
	ULONG ProvSizeW = 1 + wcslen(wszProviderName);
    ULONG ulProvSize = sizeof(WCHAR) * ProvSizeW;
    ULONG ulSize = ulProvSize + ulKeySize + SIZEOF_MQDSPUBLICKEY;

    *ppPublicKeyPack = (MQDSPUBLICKEY *) new BYTE[ulSize];
    MQDSPUBLICKEY *pPublicKeyPack = *ppPublicKeyPack;

    pPublicKeyPack->ulKeyLen = ulKeySize;
    pPublicKeyPack->ulProviderLen = ulProvSize;
    pPublicKeyPack->ulProviderType = ulProviderType;

    BYTE *pBuf = (BYTE*) (pPublicKeyPack->aBuf);
    HRESULT hr = StringCchCopy((WCHAR*) pBuf, ProvSizeW, wszProviderName);
	if(FAILED(hr))
	{
		TrERROR(SECURITY, "StringCchCopy Failed, %!hresult!", hr);		
	    return hr;
	}

    pBuf += ulProvSize;
    memcpy(pBuf, pKeyBlob, ulKeySize);
	return MQSec_OK;
}


//+------------------------------------------------------------------------
//
//  HRESULT PackPublicKey()
//
//    pPublicKeyPack- pointer to a strucutre that already contains several
//      keys. A new structure is allocated, the previous one is copied
//      and new key is packed at the end of  the new structure.
//
//+------------------------------------------------------------------------

HRESULT 
PackPublicKey(
	IN      BYTE				*pKeyBlob,
	IN      ULONG				ulKeySize,
	IN      LPCWSTR				wszProviderName,
	IN      ULONG				ulProviderType,
	IN OUT  P<MQDSPUBLICKEYS>&  pPublicKeysPack 
	)
/*++

Routine Description:
	Export the input key into a keyblob and Pack it in the end of the PublicKeysPack structure

Arguments:
	pKeyBlob - pointer to key blob to be add to the keys pack
	ulKeySize - key blob size
	wszProviderName - provider name
	ulProviderType - provider type (base, enhanced)
	pPublicKeysPack - in\out Pointer to Public keys pack, the Key blob will be add 
					  at the end of pPublicKeysPack

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    if ((pKeyBlob == NULL) || (ulKeySize == 0))
    {
        //
        // Nothing to pack.
        //
        return MQSec_OK;
    }

	//
	// Prepare MQDSPUBLICKEY - structure for one key which include 
	// provider name wstring and wstring length, provider type, keyblob and length 
	//
    P<MQDSPUBLICKEY> pPublicKey = NULL;
    HRESULT hr = _PackAKey( 
					pKeyBlob,
					ulKeySize,
					wszProviderName,
					ulProviderType,
					&pPublicKey 
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    //
    // Compute size of new structure.
    //
    ULONG ulSize = 0;
    ULONG ulPrevSize = 0;
    ULONG ulPrevCount = 0;

    if (pPublicKeysPack)
    {
        //
        // Add key to existing structure.
        //
        ASSERT(pPublicKeysPack->ulLen);
        ulPrevSize = pPublicKeysPack->ulLen;
        ulPrevCount = pPublicKeysPack->cNumofKeys;
        ulSize = ulPrevSize;
    }
    else
    {
        //
        // Create new structure.
        //
        ulSize = SIZEOF_MQDSPUBLICKEYS;
        ulPrevSize = ulSize;
    }

	//
	// New keyblob pack size
	//
    ULONG ulKeyPackSize =   pPublicKey->ulKeyLen      +
                            pPublicKey->ulProviderLen +
                            SIZEOF_MQDSPUBLICKEY;
    ulSize += ulKeyPackSize;

    AP<BYTE> pTmp = (BYTE *) new BYTE[ulSize];
    BYTE *pNewPack = pTmp;

    if (pPublicKeysPack)
    {
		//
		// Copy previous key packs
		//
        memcpy(pNewPack, pPublicKeysPack, pPublicKeysPack->ulLen);
        pNewPack +=  pPublicKeysPack->ulLen;
    }
    else
    {
        pNewPack += SIZEOF_MQDSPUBLICKEYS;
    }

	//
	// Adding the new key pack
	//
    memcpy(pNewPack, pPublicKey, ulKeyPackSize);

	pPublicKeysPack.free();
    pPublicKeysPack = (MQDSPUBLICKEYS *) pTmp.detach();

    pPublicKeysPack->ulLen = ulPrevSize + ulKeyPackSize;
    pPublicKeysPack->cNumofKeys = ulPrevCount + 1;

    return MQSec_OK;
}


//+------------------------------------------------------------------------
//
//  HRESULT MQSec_PackPublicKey()
//
//    pPublicKeyPack- pointer to a strucutre that already contains several
//      keys. A new structure is allocated, the previous one is copied
//      and new key is packed at the end of  the new structure.
//
//+------------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_PackPublicKey(
	IN      BYTE            *pKeyBlob,
	IN      ULONG            ulKeySize,
	IN      LPCWSTR          wszProviderName,
	IN      ULONG            ulProviderType,
	IN OUT  MQDSPUBLICKEYS **ppPublicKeysPack 
	)
/*++

Routine Description:
	Export the input key into a keyblob and Pack it in the end of the PublicKeysPack structure

Arguments:
	pKeyBlob - pointer to key blob to be add to the keys pack
	ulKeySize - key blob size
	wszProviderName - provider name
	ulProviderType - provider type (base, enhanced)
	ppPublicKeysPack - in\out Pointer to Public keys pack, the Key blob will be add 
					   at the end of pPublicKeysPack

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
	ASSERT(ppPublicKeysPack);
	P<MQDSPUBLICKEYS>  pPublicKeysPack = *ppPublicKeysPack;

    HRESULT hr = PackPublicKey( 
					pKeyBlob,
					ulKeySize,
					wszProviderName,
					ulProviderType,
					pPublicKeysPack 
					);

	*ppPublicKeysPack = pPublicKeysPack.detach();

	return hr;
}


//+-----------------------------------------------------------------------
//
//  HRESULT MQSec_UnpackPublicKey()
//
//  Unpack the public key that match the provider requested by caller.
//  The function does NOT allocate the buffer for the public key. It's
//  just set a pointer into the input MQDSPUBLICKEYS structure.
//
//+-----------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_UnpackPublicKey(
	IN  MQDSPUBLICKEYS  *pPublicKeysPack,
	IN  LPCWSTR          wszProviderName,
	IN  ULONG            ulProviderType,
	OUT BYTE           **ppKeyBlob,
	OUT ULONG           *pulKeySize 
	)
{
    ULONG cCount = pPublicKeysPack->cNumofKeys;
    BYTE *pBuf = (BYTE*) pPublicKeysPack->aPublicKeys;

    //
    // The structure is not aligned on 4 byte boundaries, raising
    // alignment fault.
    //
    MQDSPUBLICKEY UNALIGNED *pPublicKey = (MQDSPUBLICKEY *) pBuf;

    for ( ULONG j = 0 ; j < cCount ; j++ )
    {
        BYTE* pKey = (BYTE*) pPublicKey->aBuf;
        LPWSTR wszKeyProv = (WCHAR*) pKey;

        if (lstrcmpi(wszProviderName, wszKeyProv) == 0)
        {
            if (pPublicKey->ulProviderType == ulProviderType)
            {
                pKey += pPublicKey->ulProviderLen;
                *pulKeySize = pPublicKey->ulKeyLen;
                *ppKeyBlob = pKey ;

                return MQSec_OK;
            }
        }

        pBuf =  pKey                      +
                pPublicKey->ulProviderLen +
                pPublicKey->ulKeyLen;

        pPublicKey = (MQDSPUBLICKEY *) pBuf;
    }

    return LogHR(MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST, s_FN, 20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\certifct\mqcert.cpp ===
/*++

Copyright (c) 1997-98 Microsoft Corporation

Module Name:
    mqcert.cpp

Abstract:
    This dll replaces digsig.dll which is obsolete now and will not be
    available on NT5. The main functionality in mqcert.dll is to create
    an internal certificate or read the parameters from an existing
    certificate.

Author:
    Doron Juster (DoronJ)  04-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "autorel.h"

#include "mqcert.tmh"

static WCHAR *s_FN=L"certifct/mqcert";

DWORD  g_cOpenCert = 0; // count number of opened certificates.
DWORD  g_cOpenCertStore = 0; // count number of opened certificates.

//+-----------------------------------------------------------------------
//
//  MQSigCreateCertificate()
//
//  Descruption: Create a certificate object.
//
//   *  if "pCertContext" and pCertBlob are NULL then a new (and empty)
//      certificate is created. the caller then use the certificate object
//      (returned in "ppCert") to fill the certificate and encode it.
//   *  if "pCertContext" is not NULL then a certificate object is created
//      which encapsulate the existing certificate (represented by the
//      certificate context). The object can then be used to retrieve
//      certificate parameters.
//        Note: when object is released, the certificate context is released
//              too.
//   *  if "pCertBlob" is not NULL then a certificate context is build from
//      the encoded blob and the code handle it as above (when pCertContext
//      is not NULL).
//
//+-----------------------------------------------------------------------

HRESULT 
APIENTRY
MQSigCreateCertificate( 
	OUT CMQSigCertificate **ppCert,
	IN  PCCERT_CONTEXT      pCertContext,
	IN  PBYTE               pCertBlob,
	IN  DWORD               dwCertSize 
	)
{
    if (!ppCert)
    {
        return  LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 40);
    }
    *ppCert = NULL;

    if (pCertContext && pCertBlob)
    {
        //
        // Only one of them can be non-null.
        //
        return  LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 50);
    }

    if (pCertBlob)
    {
        //
        // Create the Context
        //
        pCertContext = CertCreateCertificateContext( 
							MY_ENCODING_TYPE,
							pCertBlob,
							dwCertSize 
							);
        if (!pCertContext)
        {
			//
			// Better error can be MQ_ERROR_INVALID_CERTIFICATE_BLOB. ilanh 10-Aug-2000
			//
            TrERROR(SECURITY, "Failed to create certificate context from encoded certificate. %!winerr!", GetLastError());
            return MQ_ERROR_INVALID_CERTIFICATE;
        }
    }

    P<CMQSigCertificate> pTmpCert = new CMQSigCertificate;
    g_cOpenCert++;
	TrTRACE(SECURITY, "Adding Cert, g_cOpenCert = %d", g_cOpenCert);

    HRESULT hr = pTmpCert->_Create(pCertContext);

    if (SUCCEEDED(hr))
    {
        *ppCert = pTmpCert.detach();
    }

    return  LogHR(hr, s_FN, 70);
}

//+-----------------------------------------------------------------------
//
//   MQSigOpenUserCertStore()
//
//  Input:
//      fMachine- TRUE if opening the store of LocalSystem services.
//
//+-----------------------------------------------------------------------

HRESULT 
APIENTRY
MQSigOpenUserCertStore( 
	OUT CMQSigCertStore **ppStore,
	IN  LPSTR             lpszRegRoot,
	IN  struct MQSigOpenCertParams *pParams 
	)
{
    *ppStore = NULL;

    if ((pParams->bCreate && !pParams->bWriteAccess) || !lpszRegRoot)
    {
        return  LogHR(MQSec_E_INVALID_PARAMETER, s_FN, 80);
    }

    R<CMQSigCertStore> pTmpStore = new  CMQSigCertStore;
    g_cOpenCertStore++;
	TrTRACE(SECURITY, "Open CertStore, g_cOpenCertStore = %d", g_cOpenCertStore);

    HRESULT hr = pTmpStore->_Open( 
					lpszRegRoot,
					pParams 
					);
    if (SUCCEEDED(hr))
    {
        *ppStore = pTmpStore.detach();
    }

    return LogHR(hr, s_FN, 90);
}

//+-----------------------------------------------------------------------
//
//   MQSigCloneCertFromReg()
//
//  description: This function clones a certificate which is in a store.
//      It's used only for registry bases, non-system, certificates stores.
//      The output CMQSigCertificate object can be used without having
//      to keep the store opened.
//      Note: when enumerating certificate contexts in a store, if you
//          want to use one of the certificates you must keep the store
//          open, otherwise the certificate memory is no longer valid.
//          This function overcome this limitation by allocating new
//          memory for the certificate it return.
//      Note: We don't use CertDuplicateCertificateContext because that api
//          does not allocate new memory. It just increment reference count
//          so the store must be kept open.
//
//+-----------------------------------------------------------------------

HRESULT 
APIENTRY
MQSigCloneCertFromReg( 
	OUT CMQSigCertificate **ppCert,
	const IN  LPSTR  lpszRegRoot,
	const IN  LONG   iCertIndex 
				 )
{
    *ppCert = NULL;

    struct MQSigOpenCertParams sStoreParams;
    memset(&sStoreParams, 0, sizeof(sStoreParams));
    R<CMQSigCertStore> pStore = NULL;

    HRESULT hr = MQSigOpenUserCertStore(
					&pStore.ref(),
					lpszRegRoot,
					&sStoreParams 
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }
    HCERTSTORE hStore = pStore->GetHandle();

    hr = _CloneCertFromStore ( 
				ppCert,
				hStore,
				iCertIndex 
				);
    return LogHR(hr, s_FN, 110);
}

//+-----------------------------------------------------------------------
//
//   MQSigCloneCertFromSysStore()
//
//  description: This function clones a certificate which is in a system
//      store. See description of "MQSigCloneCertFromReg()" for more
//      comments and notes.
//
//+-----------------------------------------------------------------------

HRESULT 
APIENTRY
MQSigCloneCertFromSysStore( 
	OUT CMQSigCertificate **ppCert,
	IN  LPCWSTR              lpwzProtocol,
	const IN  LONG           iCertIndex 
	)
{
    HRESULT hr = MQSec_OK;

    *ppCert = NULL;

    HCRYPTPROV hProv;
    if (!_CryptAcquireVerContext(&hProv))
    {
        return  LogHR(MQSec_E_CANT_ACQUIRE_CTX, s_FN, 120);
    }

    CHCertStore  hSysStore = CertOpenSystemStore(hProv, lpwzProtocol);
    if (!hSysStore)
    {
    	DWORD gle = GetLastError();
        TrERROR(SECURITY, "Failed to open system certificate store for %ls. %!winerr!", lpwzProtocol, gle);
        return MQSec_E_CANT_OPEN_SYSSTORE;
    }

    hr = _CloneCertFromStore( 
				ppCert,
				hSysStore,
				iCertIndex 
				);
    return LogHR(hr, s_FN, 140);
}

/***********************************************************
*
* CertDllMain
*
************************************************************/

BOOL WINAPI CertDllMain (HMODULE /* hMod */, DWORD fdwReason, LPVOID /* lpvReserved */)
{
   if (fdwReason == DLL_PROCESS_ATTACH)
   {
   }
   else if (fdwReason == DLL_PROCESS_DETACH)
   {
		if(g_cOpenCert)
		{
			TrERROR(SECURITY, "Not all Cert were released, g_cOpenCert = %d", g_cOpenCert);
		}

		if(g_cOpenCertStore)
		{
			TrERROR(SECURITY, "Not all CertStore were released, g_cOpenCertStore = %d", g_cOpenCertStore);
		}
   }
   else if (fdwReason == DLL_THREAD_ATTACH)
   {
   }
   else if (fdwReason == DLL_THREAD_DETACH)
   {
   }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypt\enhprov.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: enhprov.cpp

Abstract:
    Retreive the parameters of the enhanced provider.
    At present, we support only the Microsoft base provider and Microsoft
    enhanced provider for encryption.
    To give some flexibility to customer, the parameters of the enhanced
    provider can be read from registry.

Author:
    Doron Juster (DoronJ)  19-Nov-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "encrypt.H"
#include <_registr.h>
#include <cs.h>
#include <Ev.h>

#include "enhprov.tmh"

static WCHAR *s_FN=L"encrypt/enhprov";

static  CHCryptProv  s_hProvQM_40   = NULL;
static  CHCryptProv  s_hProvQM_128  = NULL;

//+--------------------------------------
//
//  HRESULT  GetProviderProperties()
//
//+--------------------------------------

HRESULT  
GetProviderProperties( 
	IN  enum   enumProvider  eProvider,
	OUT WCHAR **ppwszContainerName,
	OUT WCHAR **ppwszProviderName,
	OUT DWORD  *pdwProviderType 
	)
{
    HRESULT hr = MQSec_GetCryptoProvProperty( 
						eProvider,
						eProvName,
						ppwszProviderName,
						NULL 
						);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    if (ppwszContainerName)
    {
        hr = MQSec_GetCryptoProvProperty( 
					eProvider,
					eContainerName,
					ppwszContainerName,
					NULL 
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 20);
        }
    }

    hr = MQSec_GetCryptoProvProperty( 
				eProvider,
				eProvType,
				NULL,
				pdwProviderType 
				);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    return MQSec_OK;
}

//+-----------------------------------------------
//
//  HRESULT MQSec_AcquireCryptoProvider()
//
//+-----------------------------------------------

static CCriticalSection s_csAcquireProvider;

HRESULT 
APIENTRY  
MQSec_AcquireCryptoProvider(
	IN  enum enumProvider  eProvider,
	OUT HCRYPTPROV        *phProv 
	)
{
    static BOOL     s_fInitialized_40  = FALSE;
    static HRESULT  s_hrBase = MQSec_OK;

    static BOOL     s_fInitialized_128 = FALSE;
    static HRESULT  s_hrEnh = MQSec_OK;

    switch (eProvider)
    {
        case eEnhancedProvider:
            if (s_fInitialized_128)
            {
                *phProv = s_hProvQM_128;
                return LogHR(s_hrEnh, s_FN, 70);
            }
            break;

        case eBaseProvider:
            if (s_fInitialized_40)
            {
                *phProv = s_hProvQM_40;
                return LogHR(s_hrBase, s_FN, 80);
            }
            break;

        default:
            ASSERT(0);
            return  LogHR(MQSec_E_UNKNWON_PROVIDER, s_FN, 90);
    }

    //
    // The critical section guard against the case where two threads try to
    // initialize the crypto provider. If the provider was already
    // initialized, then we don't pay the overhead of the critical section.
    // the "initialized" flags must be set to TRUE after the cached handles
    // get their values at the end of this function.
    //
    CS Lock(s_csAcquireProvider);

    HRESULT  hrDefault = MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;

    if (eProvider == eEnhancedProvider)
    {
        if (s_fInitialized_128)
        {
            *phProv = s_hProvQM_128;
            return LogHR(s_hrEnh, s_FN, 100);
        }
        hrDefault = MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED;
    }
    else
    {
        if (s_fInitialized_40)
        {
            *phProv = s_hProvQM_40;
            return LogHR(s_hrBase, s_FN, 110);
        }
    }

    AP<WCHAR> pwszContainerName;
    AP<WCHAR> pwszProviderName;
    DWORD    dwProviderType;

    *phProv = NULL;
    HRESULT hr = GetProviderProperties( 
						eProvider,
						&pwszContainerName,
						&pwszProviderName,
						&dwProviderType 
						);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }

    //
    // Get Falcon's machine key set context.
    //
    HCRYPTPROV hProv = NULL;
    BOOL bRet = CryptAcquireContext( 
					&hProv,
					pwszContainerName,
					pwszProviderName,
					dwProviderType,
					CRYPT_MACHINE_KEYSET 
					);
    DWORD dwErr = GetLastError();
    ASSERT(bRet || (dwErr != NTE_BAD_FLAGS));

    if (!bRet)
    {
        LogHR(dwErr, s_FN, 220);

        if (eProvider != eBaseProvider)
        {
            TrWARNING(SECURITY, "MQSec_AcquireCryptoProvider: Failed to get MSMQ machine key set context, error = %!winerr!", dwErr);
        }
        else
        {
            TrERROR(SECURITY, "MQSec_AcquireCryptoProvider: Failed to get MSMQ machine key set context, error = %!winerr!", dwErr);
        }

        if (eProvider == eBaseProvider)
        {
        	TrTRACE(SECURITY, "Cryptography cannot be used on this computer. Verify that the Microsoft Base Cryptographic Provider is properly installed and that computer keys for Message Queuing were created. You may need to renew the cryptographic keys.");
        }

        hr = hrDefault;
    }

    LPWSTR  lpwszRegName = NULL;

    if (eProvider == eEnhancedProvider)
    {
        s_hrEnh = hr;
        s_hProvQM_128 = hProv;
        s_fInitialized_128 = TRUE;
        lpwszRegName = MSMQ_ENH_CONTAINER_FIX_REGNAME;
    }
    else
    {
        s_hrBase = hr;
        s_hProvQM_40 = hProv;
        s_fInitialized_40 = TRUE;
        lpwszRegName = MSMQ_BASE_CONTAINER_FIX_REGNAME;
    }

    //
    // Because of a bug in beta3 and rc1 crypto api, control panel can not
    // renew crypto key. To workaround, on first boot, first time the service
    // acquire the crypto provider, it sets again the container security.
    //
    if (hProv && SUCCEEDED(hr))
    {
        DWORD  dwAlreadyFixed = 0;
        DWORD  dwType = REG_DWORD;
        DWORD  dwSize = sizeof(dwAlreadyFixed);

        LONG rc = GetFalconKeyValue( 
						lpwszRegName,
						&dwType,
						&dwAlreadyFixed,
						&dwSize 
						);

        if ((rc != ERROR_SUCCESS) || (dwAlreadyFixed == 0))
        {
            HRESULT hr1 = SetKeyContainerSecurity(hProv);
			if(FAILED(hr1))
			{
				ASSERT(("SetKeyContainerSecurity failed", 0));
	            TrERROR(SECURITY, "Fail to set key container security, %!hresult!", hr1);
			}
			else
			{
				//
				// Mark that container security was fixed.
				//
	            dwAlreadyFixed = 1;
	            dwType = REG_DWORD;
	            dwSize = sizeof(dwAlreadyFixed);

	            rc = SetFalconKeyValue( 
						lpwszRegName,
						&dwType,
						&dwAlreadyFixed,
						&dwSize 
						);
	            ASSERT(rc == ERROR_SUCCESS);
			}
        }
    }

    *phProv = hProv;

    return LogHR(hr, s_FN, 130);
}

//+--------------------------------
//
//  HRESULT _GetProvName()
//
//+--------------------------------

static 
HRESULT 
_GetProvName( 
	IN  enum enumProvider    eProvider,
	OUT LPWSTR              *ppwszStringProp 
	)
{
    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *ppwszStringProp = newwcs(x_MQ_Encryption_Provider_128);
            return MQ_OK;

        case eBaseProvider:
        case eForeignBaseProvider:
            *ppwszStringProp = newwcs(x_MQ_Encryption_Provider_40);
            return MQ_OK;

         default:
            ASSERT(0);
            TrERROR(SECURITY, "Unknown provider %d", eProvider);
            return MQSec_E_UNKNWON_PROVIDER;
    }
}

//+-----------------------------------
//
//  HRESULT _GetProvContainerName()
//
//+-----------------------------------

static 
HRESULT 
_GetProvContainerName(
	IN  enum enumProvider    eProvider,
	OUT LPWSTR              *ppwszStringProp 
	)
{
    //
    // We need to read the value from registry since
    // multiple QMs can live on same machine, each with
    // its own value, stored in its own registry. (ShaiK)
    //

    *ppwszStringProp = new WCHAR[255];
    DWORD   cbSize = 255 * sizeof(WCHAR);
    DWORD   dwType = REG_SZ;
    LONG    rc = ERROR_SUCCESS;
    HRESULT hr = MQSec_OK;

    switch (eProvider)
    {
        case eEnhancedProvider:
            rc = GetFalconKeyValue(
						MSMQ_CRYPTO128_CONTAINER_REG_NAME,
						&dwType,
						*ppwszStringProp,
						&cbSize,
						MSMQ_CRYPTO128_DEFAULT_CONTAINER
						);
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break;

        case eForeignEnhProvider:
            rc = GetFalconKeyValue(
						MSMQ_FORGN_ENH_CONTAINER_REGNAME,
						&dwType,
						*ppwszStringProp,
						&cbSize,
						MSMQ_FORGN_ENH_DEFAULT_CONTAINER
						);
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break;

        case eBaseProvider:
            rc = GetFalconKeyValue(
						MSMQ_CRYPTO40_CONTAINER_REG_NAME,
						&dwType,
						*ppwszStringProp,
						&cbSize,
						MSMQ_CRYPTO40_DEFAULT_CONTAINER
						);
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break;

        case eForeignBaseProvider:
            rc = GetFalconKeyValue(
						MSMQ_FORGN_BASE_CONTAINER_REGNAME,
						&dwType,
						*ppwszStringProp,
						&cbSize,
						MSMQ_FORGN_BASE_DEFAULT_CONTAINER
						);
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break;

        default:
            ASSERT(("should not get here!", 0));
            hr = MQSec_E_UNKNWON_PROVIDER;
            break;
    }

    return LogHR(hr, s_FN, 150);
}

//+--------------------------------
//
//  HRESULT _GetProvType()
//
//+--------------------------------

static 
HRESULT 
_GetProvType( 
	IN  enum enumProvider    eProvider,
	OUT DWORD               *pdwProp 
	)
{
    HRESULT hr = MQSec_OK;

    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *pdwProp = x_MQ_Encryption_Provider_Type_128;
            break;

        case eBaseProvider:
        case eForeignBaseProvider:
            *pdwProp = x_MQ_Encryption_Provider_Type_40;
            break;

        default:
            ASSERT(0);
            hr = MQSec_E_UNKNWON_PROVIDER;
            break;
    }

    return LogHR(hr, s_FN, 160);
}

//+-----------------------------------
//
//  HRESULT _GetProvSessionKeySize()
//
//+-----------------------------------

static 
HRESULT 
_GetProvSessionKeySize( 
	IN  enum enumProvider   eProvider,
	OUT DWORD              *pdwProp 
	)
{
    HRESULT hr = MQSec_OK;

    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *pdwProp = x_MQ_SymmKeySize_128;
            break;

        case eBaseProvider:
        case eForeignBaseProvider:
            *pdwProp = x_MQ_SymmKeySize_40;
            break;

        default:
            ASSERT(0);
            hr = MQSec_E_UNKNWON_PROVIDER;
            break;
    }

    return LogHR(hr, s_FN, 170);
}

//+-----------------------------------
//
//  HRESULT _GetProvBlockSize()
//
//+-----------------------------------

static 
HRESULT 
_GetProvBlockSize( 
	IN  enum enumProvider   eProvider,
	OUT DWORD              *pdwProp 
	)
{
    HRESULT hr = MQSec_OK;

    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *pdwProp = x_MQ_Block_Size_128;
            break;

        case eBaseProvider:
        case eForeignBaseProvider:
            *pdwProp = x_MQ_Block_Size_40;
            break;

        default:
            ASSERT(0);
            hr = MQSec_E_UNKNWON_PROVIDER;
            break;
    }

    return LogHR(hr, s_FN, 180);
}

//+--------------------------------------------
//
//  HRESULT  MQSec_GetCryptoProvProperty()
//
//+--------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetCryptoProvProperty(
	IN  enum enumProvider     eProvider,
	IN  enum enumCryptoProp   eProp,
	OUT LPWSTR         *ppwszStringProp,
	OUT DWORD          *pdwProp 
	)
{
    HRESULT hr = MQSec_OK;

    switch (eProp)
    {
        case eProvName:
            hr = _GetProvName(eProvider, ppwszStringProp);
            break;

        case eProvType:
            hr = _GetProvType(eProvider, pdwProp);
            break;

        case eSessionKeySize:
            hr = _GetProvSessionKeySize(eProvider, pdwProp);
            break;

        case eContainerName:
            hr = _GetProvContainerName(eProvider, ppwszStringProp);
            break;

        case eBlockSize:
            hr = _GetProvBlockSize(eProvider, pdwProp);
            break;

        default:
            ASSERT(0);
            hr = MQSec_E_UNKNWON_CRYPT_PROP;
            break;
    }

    return LogHR(hr, s_FN, 190);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypttest\logsimulate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    LogSimulate.cpp

Abstract:
    simulate Log functions

Author:
    Ilan Herbst (ilanh) 13-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"

#include "logsimulate.tmh"

//+----------------------------
//
//  Logging and debugging
//
//+----------------------------

void 
LogMsgHR(        
	HRESULT /* hr */,        
	LPWSTR /* wszFileName */, 
	USHORT /* point */
	)
/*++

Routine Description:
	Simulate LogMsgHR and do nothing 

--*/
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypttest\encrypttestfunctions.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EncryptTestFunctions.cpp

Abstract:
    Encrypt test functions

	Check the exported MQSec_* functions in encrypt library

Author:
    Ilan Herbst (ilanh) 15-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "EncryptTestPrivate.h"

#include "encrypttestfunctions.tmh"


PSID MQSec_GetAdminSid()
{
    ASSERT(("MQSec_GetAdminSid doesn't suppose to be called", 0));
    return NULL;
}


bool
CompareKeys(
	const BYTE* pKey, 
	ULONG ulKeySize, 
	const BYTE* pRefKey, 
	ULONG ulRefKeySize
	)
/*++

Routine Description:
    Compare 2 buffers values

Arguments:
    pKey - pointer to first buffer
	ulKeySize - first buffer size
	pRefKey - pointer to second buffer
	ulRefKeySize - second buffer size

Returned Value:
    true if the buffers match, false if not

--*/
{
	//
	// Buffers must have same size 
	//
	if(ulRefKeySize != ulKeySize)
		return(false);

	//
	// comparing each byte in the buffers
	//
	for(DWORD i=0; i < ulKeySize; i++, pKey++, pRefKey++)
	{
		if(*pKey != *pRefKey)
			return(false);
	}
	return(true);
}


void
TestMQSec_PackPublicKey(
    BYTE	*pKeyBlob,
	ULONG	ulKeySize,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD   Num
	)
/*++

Routine Description:
    Test MQSec_PackPublicKey function

Arguments:
    pKeyBlob - Pointer to KeyBlob to pack
	ulKeySize - KeyBlob size
	wszProviderName - wstring of Provider Name
	ulProviderType - Provider Type
	Num - Number of iterations to test the MQSec_PackPublicKey

Returned Value:
    None

--*/
{
    printf("Test MQSec_PackPublicKey iterations = %d\n", Num);

	//
	// PackKeys structure - this is IN/OUT parameter for the MQSec_PackPublicKey function
	// the NewKey is packed at the end of this structure
	//
    MQDSPUBLICKEYS *pPublicKeysPack = NULL;

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// Pack Key
		//
		HRESULT hr = MQSec_PackPublicKey( 
						pKeyBlob,
						ulKeySize,
						wszProviderName,
						ulProviderType,
						&pPublicKeysPack 
						);
		if (FAILED(hr))
		{
			printf("MQSec_PackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			break;
		}
	}

	delete pPublicKeysPack;
    printf("Test MQSec_PackPublicKey completed iterations = %d\n", Num);
}


void
TestMQSec_UnPackPublicKey(
	MQDSPUBLICKEYS  *pPublicKeysPack,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD   Num
	)
/*++

Routine Description:
    Test MQSec_UnPackPublicKey function

Arguments:
	pPublicKeysPack - pointer to KeysPack structure (MQDSPUBLICKEYS)
	wszProviderName - wstring of Provider Name
	ulProviderType - Provider Type
	Num - Number of iterations to test the MQSec_UnPackPublicKey

Returned Value:
    None

--*/
{
    printf("Test MQSec_UnPackPublicKey iterations = %d\n", Num);


	for(DWORD i = 0; i < Num; i++)
	{
		ULONG ulKeySize;
		BYTE *pKeyBlob = NULL;

		//
		// UnPack Keys
		//
	    HRESULT hr = MQSec_UnpackPublicKey( 
						pPublicKeysPack,
						wszProviderName,
						ulProviderType,
						&pKeyBlob,
						&ulKeySize 
						);

		if (FAILED(hr))
		{
			printf("MQSec_UnpackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			break;
		}
	}

    printf("Test MQSec_UnPackPublicKey completed iterations = %d\n", Num);
}


void
TestPackUnPack(
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_PackPublicKey and MQSec_UnPackPublicKey functions on known const data.
	this way we are validating that both functions are working correctly as a unit.

Arguments:
	Num - Number of iterations to test

Returned Value:
    None

--*/
{
    printf("Test MQSec_PackPublicKey\\UnpackPublicKey iterations = %d\n", Num);

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// Pack Ex Keys of known const data
		//

		MQDSPUBLICKEYS *pPublicKeysPackExch = NULL;

		//
		// Pack Ex Key for BaseProvider
		//
		HRESULT hr = MQSec_PackPublicKey( 
						(BYTE *)xBaseExKey,
						strlen(xBaseExKey),
						x_MQ_Encryption_Provider_40,
						x_MQ_Encryption_Provider_Type_40,
						&pPublicKeysPackExch 
						);

		if (FAILED(hr))
		{
			printf("MQSec_PackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			delete pPublicKeysPackExch;
			ASSERT(0);
			return;
		}

		//
		// Pack Ex Key for EnhanceProvider
		//
		hr = MQSec_PackPublicKey( 
				(BYTE *)xEnhExKey,
				strlen(xEnhExKey),
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pPublicKeysPackExch 
				);

		P<MQDSPUBLICKEYS> pCleanPublicKeysPackExch = pPublicKeysPackExch;

		if (FAILED(hr))
		{
			printf("MQSec_PackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			return;
		}

		//
		// Init BlobEncrypt
		//
		BLOB BlobEncrypt;
		BlobEncrypt.cbSize = pPublicKeysPackExch->ulLen;
		BlobEncrypt.pBlobData = reinterpret_cast<BYTE *>(pPublicKeysPackExch);

		//
		// Pack Sign Keys of known const data
		//

		MQDSPUBLICKEYS *pPublicKeysPackSign = NULL;

		//
		// Pack Sign Key for BaseProvider
		//
		hr = MQSec_PackPublicKey( 
				(BYTE *)xBaseSignKey,
				strlen(xBaseSignKey),
				x_MQ_Encryption_Provider_40,
				x_MQ_Encryption_Provider_Type_40,
				&pPublicKeysPackSign 
				);

		if (FAILED(hr))
		{
			printf("MQSec_PackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			delete pPublicKeysPackSign;
			ASSERT(0);
			return;
		}

		//
		// Pack Sign Key for EnhancedProvider
		//
		hr = MQSec_PackPublicKey( 
				(BYTE *)xEnhSignKey,
				strlen(xEnhSignKey),
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pPublicKeysPackSign 
				);

		P<MQDSPUBLICKEYS> pCleanPublicKeysPackSign = pPublicKeysPackSign;

		if (FAILED(hr))
		{
			printf("MQSec_PackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			return;
		}

		//
		// Init BlobSign
		//
		BLOB BlobSign;
		BlobSign.cbSize = pPublicKeysPackSign->ulLen;
		BlobSign.pBlobData = reinterpret_cast<BYTE *>(pPublicKeysPackSign);

		//
		// Checking UnPack Ex Keys
		//
		MQDSPUBLICKEYS *pPublicKeysPack = reinterpret_cast<MQDSPUBLICKEYS *>(BlobEncrypt.pBlobData);
		ASSERT(pPublicKeysPack->ulLen == BlobEncrypt.cbSize);

		//
		// Checking UnPack Ex Key for EnhancedProvider
		//
		ULONG ulExchEnhKeySize;
		BYTE *pExchEnhKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pExchEnhKeyBlob,
				&ulExchEnhKeySize 
				);

		if (FAILED(hr))
		{
			printf("MQSec_UnpackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			return;
		}

		bool KeysEqual = CompareKeys(
							pExchEnhKeyBlob, 
							ulExchEnhKeySize, 
							reinterpret_cast<const BYTE *>(xEnhExKey), 
							strlen(xEnhExKey)
							);

		ASSERT(KeysEqual);

		//
		// Checking UnPack Ex Key for BaseProvider
		//
		ULONG ulExchBaseKeySize;
		BYTE *pExchBaseKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_40,
				x_MQ_Encryption_Provider_Type_40,
				&pExchBaseKeyBlob,
				&ulExchBaseKeySize 
				);


		if (FAILED(hr))
		{
			printf("MQSec_UnpackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			return;
		}

		KeysEqual = CompareKeys(
						pExchBaseKeyBlob, 
						ulExchBaseKeySize, 
						reinterpret_cast<const BYTE *>(xBaseExKey), 
						strlen(xBaseExKey)
						);

		ASSERT(KeysEqual);

		//
		// Checking UnPack Sign Keys
		//
		pPublicKeysPack = reinterpret_cast<MQDSPUBLICKEYS *>(BlobSign.pBlobData);
		ASSERT(pPublicKeysPack->ulLen == BlobSign.cbSize);

		//
		// Checking UnPack Sign Key for EnhancedProvider
		//
		ULONG ulSignEnhKeySize;
		BYTE *pSignEnhKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pSignEnhKeyBlob,
				&ulSignEnhKeySize 
				);

		if (FAILED(hr))
		{
			printf("MQSec_UnpackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			return;
		}

		KeysEqual = CompareKeys(
						pSignEnhKeyBlob, 
						ulSignEnhKeySize, 
						reinterpret_cast<const BYTE *>(xEnhSignKey), 
						strlen(xEnhSignKey)
						);

		ASSERT(KeysEqual);

		//
		// Checking UnPack Sign Key for BaseProvider
		//
		ULONG ulSignBaseKeySize;
		BYTE *pSignBaseKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_40,
				x_MQ_Encryption_Provider_Type_40,
				&pSignBaseKeyBlob,
				&ulSignBaseKeySize 
				);

		if (FAILED(hr))
		{
			printf("MQSec_UnpackPublicKey failed hr = %x, iteration = %d\n", hr, i);
			ASSERT(0);
			return;
		}

		KeysEqual = CompareKeys(
						pSignBaseKeyBlob, 
						ulSignBaseKeySize, 
						reinterpret_cast<const BYTE *>(xBaseSignKey), 
						strlen(xBaseSignKey)
						);

		ASSERT(KeysEqual);

	} // for(i...)

    printf("Test MQSec_PackPublicKey\\MQSec_UnpackPublicKey completed iterations = %d\n", Num);
}


void
TestMQSec_GetPubKeysFromDS(
	enum enumProvider	eProvider,
	DWORD propIdKeys,
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_GetPubKeysFromDS function

Arguments:
	eProvider - provider type
	propIdKeys - PROPID to get from the DS
	Num - Number of iterations to test the MQSec_GetPubKeysFromDS

Returned Value:
    None

--*/
{
    printf("Test MQSec_GetPubKeysFromDS eProvider = %d, iterations = %d\n", eProvider, Num);

	for(DWORD i = 0; i < Num; i++)
	{
//		LPCWSTR ComputerName = L"TempComputer";
		
		LPCWSTR ComputerName = L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
							   L"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
							   L"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
							   L"DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
							   L"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
							   L"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
							   L"GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG"
							   L"HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH";
		//
		// MQSec_GetPubKeysFromDS
		//
		P<BYTE> abPbKey = NULL;
		DWORD dwReqLen = 0;

		HRESULT hr = MQSec_GetPubKeysFromDS( 
						NULL,
						ComputerName,  // false computer name, the AdSimulate dont use this name
						eProvider,
						propIdKeys,
						&abPbKey,
						&dwReqLen 
						);

		if (FAILED(hr))
		{
			ASSERT(0);
			printf("MQSec_GetPubKeysFromDS (eProvider = %d) failed, iteration = %d\n", eProvider, i);
			return;
		}
	} // for(i...)

	printf("MQSec_GetPubKeysFromDS completed ok iterations = %d\n", Num);

}


void
TestMQSec_StorePubKeys(
	BOOL fRegenerate,
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_StorePubKeys function

Arguments:
	fRegenerate - flag for regenerating new keys or try to retrieve	existing keys
	Num - Number of iterations to test the MQSec_GetPubKeysFromDS

Returned Value:
    None

--*/
{

    printf("Test MQSec_StorePubKeys fRegenerate = %d, iterations = %d\n", fRegenerate, Num);

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// MQSec_StorePubKeys
		//
		BLOB blobEncrypt;
		blobEncrypt.cbSize    = 0;
		blobEncrypt.pBlobData = NULL;

		BLOB blobSign;
		blobSign.cbSize       = 0;
		blobSign.pBlobData    = NULL;

		HRESULT hr = MQSec_StorePubKeys( 
						fRegenerate,
						eBaseProvider,
						eEnhancedProvider,
						&blobEncrypt,
						&blobSign 
						);

		P<BYTE> pCleaner1 = blobEncrypt.pBlobData;
		P<BYTE> pCleaner2 = blobSign.pBlobData;

		if (FAILED(hr))
		{
			ASSERT(0);
			printf("MQSec_StorePubKeys (fRegenerate = %d) failed %x, iteration = %d\n", 
					fRegenerate, hr, i);
			return;
		}
	} // for(i...)


    printf("MQSec_StorePubKeys completed ok, iterations = %d\n", Num);
}


void
TestMQSec_StorePubKeysInDS(
	BOOL fRegenerate,
	DWORD dwObjectType,
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_StorePubKeysInDS function
    every call to MQSec_StorePubKeysInDS allocate a new data blobs in the DS. 
	since those data are globals in our implementation they need to be freed
	and re assigned	to the P<>

Arguments:
	fRegenerate - flag for regenerating new keys or try to retrieve	existing keys
	dwObjectType - Object Type 
	Num - Number of iterations to test the MQSec_GetPubKeysFromDS

Returned Value:
    None

--*/
{
    printf("Test MQSec_StorePubKeysInDS fRegenerate = %d, iterations = %d\n", fRegenerate, Num);

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// MQSec_StorePubKeysInDS
		//
		HRESULT hr = MQSec_StorePubKeysInDS( 
						fRegenerate,	
						NULL,			// wszObjectName
						dwObjectType
						);


		if (FAILED(hr))
		{
			ASSERT(0);
			printf("MQSec_StorePubKeysInDS (fRegenerate = %d) failed %x, iteration = %d\n", 
					fRegenerate, hr, i);
			return;
		}
	} // for(i...)

		
	printf("MQSec_StorePubKeysInDS completed ok, iterations = %d\n", Num);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypttest\encrypttestprivate.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EncryptTestPrivate.h

Abstract:
    Encrypt test private functions and variables

Author:
    Ilan Herbst (ilanh) 15-Jun-00

Environment:
    Platform-independent

--*/

#ifndef _ENCRYPTTESTPRIVATE_H_
#define _ENCRYPTTESTPRIVATE_H_

#include "mqsec.h"


//
// Common Declaration
//
#ifndef _ENCRYPTTEST_CPP_

//
// Const key values for checking
//
extern const LPCSTR xBaseExKey;
extern const LPCSTR xBaseSignKey;
extern const LPCSTR xEnhExKey;
extern const LPCSTR xEnhSignKey;

#endif // _ENCRYPTTEST_CPP_

//
// EncryptTestFunctions
// 

void
TestMQSec_PackPublicKey(
    BYTE	*pKeyBlob,
	ULONG	ulKeySize,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD Num
	);


void
TestMQSec_UnPackPublicKey(
	MQDSPUBLICKEYS  *pPublicKeysPack,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD Num
	);


void
TestPackUnPack(
	DWORD Num
	);


void
TestMQSec_GetPubKeysFromDS(
	enum enumProvider	eProvider,
	DWORD propIdKeys,
	DWORD Num
	);


void
TestMQSec_StorePubKeys(
	BOOL fRegenerate,
	DWORD Num
	);


void
TestMQSec_StorePubKeysInDS(
	BOOL fRegenerate,
	DWORD dwObjectType,
	DWORD Num
	);


//
// AdSimulate functions
//

void
InitADBlobs(
	void
	);


void
InitPublicKeysPackFromStaticDS(
	P<MQDSPUBLICKEYS>& pPublicKeysPackExch,
	P<MQDSPUBLICKEYS>& pPublicKeysPackSign
	);

#endif // _ENCRYPTTESTPRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypttest\adsimulate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    AdSimulate.cpp

Abstract:
    simulate Ad lib	functions

Author:
    Ilan Herbst (ilanh) 14-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "mqprops.h"
#include "mqaddef.h"
#include "mq.h"
#include "dsproto.h"
#include "EncryptTestPrivate.h"

#include "adsimulate.tmh"

//
// Those blobs simulate DS content
//
static P<MQDSPUBLICKEYS> s_BlobSign = NULL;
static P<MQDSPUBLICKEYS> s_BlobEncrypt = NULL;


void
InitADBlobs(
	void
	)
/*++

Routine Description:
    Init s_BlobEncrypt and s_BlobSign that simulate the AD content

Arguments:
	None

Returned Value:
    None

--*/
{
    printf("Init AD Blobs\n");

	//
	// Pack Ex Keys	of const data
	//
    MQDSPUBLICKEYS *pPublicKeysPackExch = NULL;

    HRESULT hr = MQSec_PackPublicKey( 
					(BYTE *)xBaseExKey,
					strlen(xBaseExKey),
					x_MQ_Encryption_Provider_40,
					x_MQ_Encryption_Provider_Type_40,
					&pPublicKeysPackExch 
					);

    if (FAILED(hr))
    {
        printf("MQSec_PackPublicKey failed hr = %x\n", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackExch = pPublicKeysPackExch;
        ASSERT(0);
		return;
    }

    hr = MQSec_PackPublicKey( 
			(BYTE *)xEnhExKey,
			strlen(xEnhExKey),
			x_MQ_Encryption_Provider_128,
			x_MQ_Encryption_Provider_Type_128,
			&pPublicKeysPackExch 
			);

    if (FAILED(hr))
    {
        printf("MQSec_PackPublicKey failed hr = %x\n", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackExch = pPublicKeysPackExch;
        ASSERT(0);
		return;
    }

	//
	// Init s_BlobEncrypt
	//
	s_BlobEncrypt = pPublicKeysPackExch;

	//
	// Pack Sign Keys of const data
	//
    MQDSPUBLICKEYS *pPublicKeysPackSign = NULL;

    hr = MQSec_PackPublicKey( 
			(BYTE *)xBaseSignKey,
			strlen(xBaseSignKey),
			x_MQ_Encryption_Provider_40,
			x_MQ_Encryption_Provider_Type_40,
			&pPublicKeysPackSign 
			);

    if (FAILED(hr))
    {
        printf("MQSec_PackPublicKey failed hr = %x\n", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackSign = pPublicKeysPackSign;
        ASSERT(0);
		return;
    }

	hr = MQSec_PackPublicKey( 
			(BYTE *)xEnhSignKey,
			strlen(xEnhSignKey),
			x_MQ_Encryption_Provider_128,
			x_MQ_Encryption_Provider_Type_128,
			&pPublicKeysPackSign 
			);

    if (FAILED(hr))
    {
        printf("MQSec_PackPublicKey failed hr = %x\n", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackSign = pPublicKeysPackSign;
        ASSERT(0);
		return;
    }

	//
	// Init s_BlobSign
	//
	s_BlobSign = pPublicKeysPackSign;
}


void
InitPublicKeysPackFromStaticDS(
	P<MQDSPUBLICKEYS>& pPublicKeysPackExch,
	P<MQDSPUBLICKEYS>& pPublicKeysPackSign
	)
/*++

Routine Description:
    Initialize the P<MQDSPUBLICKEYS> to DS blobs values. 

Arguments:
	pPublicKeysPackExch - OUT P<MQDSPUBLICKEYS> which will get the BlobEncrypt value 
	pPublicKeysPackSign - OUT P<MQDSPUBLICKEYS> which will get the BlobSign value 

Returned Value:
    None

--*/
{
	P<unsigned char> pTmp = new unsigned char[s_BlobEncrypt->ulLen];
	memcpy(pTmp, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
	pPublicKeysPackExch = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
	
	pTmp = new unsigned char[s_BlobEncrypt->ulLen];
	memcpy(pTmp, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
	pPublicKeysPackSign = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
}


eDsEnvironment
ADGetEnterprise( 
	void
	)
/*++
Routine Description:
	Get AD enviroment

Arguments:
	None

Returned Value:
	Meanwhile always eAD

--*/
{
	return eAD;
}


HRESULT
ADInit( 
	IN  QMLookForOnlineDS_ROUTINE /* pLookDS */,
	IN  MQGetMQISServer_ROUTINE /* pGetServers */,
	IN  bool  /* fSetupMode */,
	IN  bool  /* fQMDll */,
	IN  bool  /* fIgnoreWorkGroup */,
	IN  bool  /* fDisableDownlevelNotifications */
	)
{
	return MQ_OK;
}


HRESULT
ADGetObjectProperties(
	IN  AD_OBJECT               eObject,
	IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,
	IN  LPCWSTR                 /*pwcsObjectName*/,
	IN  const DWORD             cp,
	IN  const PROPID            aProp[],
	IN OUT PROPVARIANT          apVar[]
	)
/*++
Routine Description:
	Get Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	getting the value of those properties from global parameters that simulate AD content 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pwcsObjectName - wstring of object name
	cp - number of props
	aProp - array of PROPID
	apVar - OUT property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK: 
			case PROPID_QM_SIGN_PKS:
                apVar[i].caub.cElems = s_BlobSign->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobSign->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobSign.get(), s_BlobSign->ulLen);
				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
                apVar[i].caub.cElems = s_BlobEncrypt->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobEncrypt->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
				break;

			default:
				printf("ADGetObjectProperties simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;
		}
	}

	return MQ_OK;
}


HRESULT
ADGetObjectPropertiesGuid(
	IN  AD_OBJECT               eObject,
	IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,
	IN  const GUID*             /*pguidObject*/,
	IN  const DWORD             cp,
	IN  const PROPID            aProp[],
	IN  OUT PROPVARIANT         apVar[]
	)
/*++
Routine Description:
	Get Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	getting the value of those properties from global parameters that simulate AD content 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pguidObject - pointer to object guid
	cp - number of props
	aProp - array of PROPID
	apVar - OUT property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK: 
			case PROPID_QM_SIGN_PKS:
                apVar[i].caub.cElems = s_BlobSign->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobSign->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobSign.get(), s_BlobSign->ulLen);
				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
                apVar[i].caub.cElems = s_BlobEncrypt->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobEncrypt->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
				break;

			default:
				printf("ADGetObjectPropertiesGuid simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;

		}
	}

	return MQ_OK;
}


HRESULT
ADSetObjectProperties(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,	
    IN  LPCWSTR                 /*pwcsObjectName*/,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  const PROPVARIANT       apVar[]
    )
/*++
Routine Description:
	Set Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	set global parameters that simulate AD content according to the property value 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pwcsObjectName - wstring of object name
	cp - number of props
	aProp - array of PROPID
	apVar - property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		P<BYTE> pTmp = NULL;
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK:	
			case PROPID_QM_SIGN_PKS:
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobSign.free();
				s_BlobSign = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());

				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
				// delete (internal) AP<> glob  
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobEncrypt.free();
				s_BlobEncrypt = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
				break;

			default:
				printf("ADSetObjectProperties simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;

		}
	}

	return MQ_OK;
}


HRESULT
ADSetObjectPropertiesGuid(
	IN  AD_OBJECT               eObject,
	IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,	
	IN  const GUID*             /*pguidObject*/,
	IN  const DWORD             cp,
	IN  const PROPID            aProp[],
	IN  const PROPVARIANT       apVar[]
	)
/*++
Routine Description:
	Set Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	set global parameters that simulate AD content according to the property value 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pguidObject - pointer to object guid
	cp - number of props
	aProp - array of PROPID
	apVar - property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		P<BYTE> pTmp = NULL;
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK:	
			case PROPID_QM_SIGN_PKS:
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobSign.free();
				s_BlobSign = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobEncrypt.free();
				s_BlobEncrypt = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
				break;

			default:
				printf("ADSetObjectPropertiesGuid simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;

		}
	}
	
	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypttest\encrypttest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EncryptTest.cpp

Abstract:
    Encrypt library test

	Check the exported MQSec_* functions in encrypt library

	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /p     test MQSec_PackPublicKey function \n"
	"    /pu    test MQSec_PackPublicKey\\UnPackPublicKey on const data\n"
	"    /u     test MQSec_UnPackPublicKey function \n"
	"    /g     test MQSec_GetPubKeysFromDS function \n"
	"    /s     test MQSec_StorePubKeys function \n"
	"    /sd    test MQSec_StorePubKeysInDS function \n\n"
	"    By default all those test will run once \n"
	"    Examples of default use:\n\n"
	"        EncryptTest \n\n"
	"    specifying a number after the switch will cause \n"
	"    the test functions to run the specified number of times \n"
	"    Examples of use:\n\n"
	"        EncryptTest /p5 /pu7 /g50 /s20 /sd20 /u10 \n\n";

Author:
    Ilan Herbst (ilanh) 13-Jun-00

Environment:
    Platform-independent

--*/

#define _ENCRYPTTEST_CPP_

#include "stdh.h"
#include "EncryptTestPrivate.h"
#include "mqprops.h"

#include "encrypttest.tmh"

//
// Const key values for checking
//
const LPCSTR xBaseExKey = "1000";
const LPCSTR xBaseSignKey = "2000";
const LPCSTR xEnhExKey = "1000000";
const LPCSTR xEnhSignKey = "2000000";

//
// Usage
//
const char xOptionSymbol1 = '-';
const char xOptionSymbol2 = '/';

const char xUsageText[] =
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /p     test MQSec_PackPublicKey function \n"
	"    /pu    test MQSec_PackPublicKey\\UnPackPublicKey on const data\n"
	"    /u     test MQSec_UnPackPublicKey function \n"
	"    /g     test MQSec_GetPubKeysFromDS function \n"
	"    /s     test MQSec_StorePubKeys function \n"
	"    /sd    test MQSec_StorePubKeysInDS function \n\n"
	"    By default all those test will run once \n"
	"    Examples of default use:\n\n"
	"        EncryptTest \n\n"
	"    specifying a number after the switch will cause \n"
	"    the test functions to run the specified number of times \n"
	"    Examples of use:\n\n"
	"        EncryptTest /p5 /pu7 /g50 /s20 /sd20 /u10 \n\n";

inline
void 
DumpUsageText( 
	void 
	)
{
	printf( "%s\n" , xUsageText );
}


//
// Usage data
//
struct CActivation
{
	CActivation(void):
		m_PackCnt(1), 
		m_UnPackCnt(1),
		m_PackUnPackCnt(1),
		m_GetPubKeysCnt(1),
		m_StorePubKeysCnt(1),
		m_StorePubKeysInDSCnt(1),
		m_fErrorneous(false)
	{
	}

	DWORD	m_PackCnt;
	DWORD	m_UnPackCnt;
	DWORD	m_PackUnPackCnt;
	DWORD	m_GetPubKeysCnt;
	DWORD	m_StorePubKeysCnt;
	DWORD   m_StorePubKeysInDSCnt;
	bool    m_fErrorneous;
};


CActivation g_Activation;



void SetActivation( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments.

Arguments:
    main's command line arguments.

Returned Value:

proper command line syntax:
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /p     test MQSec_PackPublicKey function \n"
	"    /pu    test MQSec_PackPublicKey\\UnPackPublicKey on const data\n"
	"    /u     test MQSec_UnPackPublicKey function \n"
	"    /g     test MQSec_GetPubKeysFromDS function \n"
	"    /s     test MQSec_StorePubKeys function \n"
	"    /sd    test MQSec_StorePubKeysInDS function \n\n"
	"    By default all those test will run once \n"
	"    Examples of default use:\n\n"
	"        EncryptTest \n\n"
	"    specifying a number after the switch will cause \n"
	"    the test functions to run the specified number of times \n"
	"    Examples of use:\n\n"
	"        EncryptTest /p5 /pu7 /g50 /s20 /sd20 /u10 \n\n";
--*/
{
	
	if(argc == 1)
	{
		return;
	}

	for(int index = 1; index < argc; index++)
	{
		if((argv[index][0] != xOptionSymbol1) && (argv[index][0] != xOptionSymbol2))	
		{
			g_Activation.m_fErrorneous = true;
			continue;
		}

		//
		// consider argument as option and switch upon its second (sometimes also third) character.
		//
		switch(argv[index][1])
		{
		case 'P':
		case 'p':
			if((argv[index][2] == 'u') || (argv[index][2] == 'U'))
			{
				g_Activation.m_PackUnPackCnt = _ttoi(argv[index] + 3);
				break;
			}
			g_Activation.m_PackCnt = _ttoi(argv[index] + 2);
			break;

		case 'U':
		case 'u':	
			g_Activation.m_UnPackCnt = _ttoi(argv[index] + 2);
			break;

		case 'G':
		case 'g':	
			g_Activation.m_GetPubKeysCnt = _ttoi(argv[index] + 2);
			break;

		case 'S':
		case 's':	
			if((argv[index][2] == 'd') || (argv[index][2] == 'D'))
			{
				g_Activation.m_StorePubKeysInDSCnt = _ttoi(argv[index] + 3);
				break;
			}
			g_Activation.m_StorePubKeysCnt = _ttoi(argv[index] + 2);
			break;

		case 'H':	
		case 'h':
		case '?':
			g_Activation.m_fErrorneous = true;
			break;

		default:
			g_Activation.m_fErrorneous = true;
			return;
		};
	}

	return;
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Encrypt library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
	SetActivation(argc, argv);

	if(g_Activation.m_fErrorneous)
	{
		DumpUsageText();
		return 3;
	}

    TrInitialize();

	//
	// Test MQSec_PackPublicKey and MQSec_UnPackPublicKey on known const data
	//
	TestPackUnPack(
		g_Activation.m_PackUnPackCnt
		);

	//
	// Test MQSec_PackPublicKey
	//
	TestMQSec_PackPublicKey(
		(BYTE*)xBaseExKey,
		strlen(xBaseExKey),
		x_MQ_Encryption_Provider_40,
		x_MQ_Encryption_Provider_Type_40,
		g_Activation.m_PackCnt
		);


	//
	// Init AD Blobs that simulate the DS content
	//
	InitADBlobs();

	//
	// Initialize KeyPacks
	//

	P<MQDSPUBLICKEYS> pPublicKeysPackExch = NULL;
	P<MQDSPUBLICKEYS> pPublicKeysPackSign = NULL;

	InitPublicKeysPackFromStaticDS(
		pPublicKeysPackExch, 
		pPublicKeysPackSign
		);

	//
	// Test MQSec_UnPackPublicKey
	//
	TestMQSec_UnPackPublicKey(
		pPublicKeysPackExch,
		x_MQ_Encryption_Provider_40,
		x_MQ_Encryption_Provider_Type_40,
		g_Activation.m_UnPackCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, EnhancedProvider, Encrypt Keys 
	//
	TestMQSec_GetPubKeysFromDS(
		eEnhancedProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, BaseProvider, Encrypt Keys  
	//
	TestMQSec_GetPubKeysFromDS(
		eBaseProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

	//
	// Test MQSec_StorePubKeys, no regenerate 
	//
	TestMQSec_StorePubKeys(
		false, 
		g_Activation.m_StorePubKeysCnt
		);

	//
	// Test MQSec_StorePubKeysInDS, no regenerate 
	//
	TestMQSec_StorePubKeysInDS(
		false, 
		MQDS_MACHINE,
		g_Activation.m_StorePubKeysInDSCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, EnhancedProvider, Encrypt Keys  
	//
	TestMQSec_GetPubKeysFromDS(
		eEnhancedProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, BaseProvider, Encrypt Keys  
	//
	TestMQSec_GetPubKeysFromDS(
		eBaseProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

    return 0;

} // _tmain

#undef _ENCRYPTTEST_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypt\pbkeys.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pbkeys.cpp

Abstract:

    Public keys operations.

 1. If the machine key container does not exist, create it, and create
    the key exchange and signature key sets.
 2. If the machine key container exist and the keys should be
    re-generated (fRegenerate == TRUE), re-generate the keys.
 3. Send the key exchange public key to the DS.
 4. Send the signature public key to the DS.

Author:

    Boaz Feldbaum (BoazF)   30-Oct-1996.
    Doron Juster  (DoronJ)  23-Nov-1998, adapt for multiple provider
	Ilan Herbst   (ilanh)   01-Jun-2000, integrate AD lib

--*/

#include <stdh_sec.h>
#include <mqutil.h>
#include <dsproto.h>
#include "encrypt.H"
#include <uniansi.h>
#include "ad.h"

#include "pbkeys.tmh"

static WCHAR *s_FN=L"encrypt/pbkeys";

//
// DsEnv Initialization Control
//
static LONG s_fDsEnvInitialized = FALSE;
static eDsEnvironment s_DsEnv = eUnknown;  


static bool DsEnvIsMqis(void)
/*++

Routine Description:
	check the Ds Enviroment: eAD or eMqis

Arguments:
	None

Returned Value:
	true if the DsEnv is eMqis false if eAD or eUnknown (Workgroup)

--*/
{

	if(!s_fDsEnvInitialized)
	{
		//
		// The s_DsEnv was not initialized, init s_DsEnv
		//
		s_DsEnv = ADGetEnterprise();

		LONG fDsEnvAlreadyInitialized = InterlockedExchange(&s_fDsEnvInitialized, TRUE);

		//
		// The s_DsEnv has *already* been initialized. You should
		// not initialize it more than once. This assertion would be violated
		// if two or more threads initalize it concurently.
		//
		DBG_USED(fDsEnvAlreadyInitialized);
		ASSERT(!fDsEnvAlreadyInitialized);
	}

	if(s_DsEnv == eMqis)
		return true;

	//
	// eAD or eUnknown (WorkGroup)
	// 
	return false;

}


//+-------------------------------------------------------------------
//
//  HRESULT SetKeyContainerSecurity( HCRYPTPROV hProv )
//
// Note: This function is also called when registering an internal
//       certificte for LocalSystem service.
//
//+-------------------------------------------------------------------

HRESULT  SetKeyContainerSecurity( HCRYPTPROV hProv )
{
    //
    // Modify the security of the key container, so that the key container
    // will not be accessible in any way by non-admin users.
    //
    SECURITY_DESCRIPTOR SD;
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);

    //
    // Get the SID of the local administrators group.
    //
	PSID pAdminSid = MQSec_GetAdminSid();

    DWORD dwDaclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
						GetLengthSid(pAdminSid) - sizeof(DWORD);
 
	P<ACL> pDacl = (PACL)(char*) new BYTE[dwDaclSize];

    if(!InitializeAcl(pDacl, dwDaclSize, ACL_REVISION))
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "InitializeAcl failed, gle = %!winerr!", gle);
		return MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR;
    }

    if(!AddAccessAllowedAce(pDacl, ACL_REVISION, KEY_ALL_ACCESS, pAdminSid))
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "AddAccessAllowedAce failed, gle = %!winerr!", gle);
		return MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR;
    }

    if(!SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE))
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "SetSecurityDescriptorDacl failed, gle = %!winerr!", gle);
		return MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR;
    }

    if (!CryptSetProvParam(
			hProv,
			PP_KEYSET_SEC_DESCR,
			(BYTE*)&SD,
			DACL_SECURITY_INFORMATION
			))
    {
        DWORD gle = GetLastError();
        TrERROR(SECURITY, "Can't set the security descriptor of the machine key set. %!winerr!", gle);
        return MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR;
    }

    return(MQ_OK);
}

//+---------------------------------------
//
//   HRESULT _ExportAndPackKey()
//
//+---------------------------------------

static 
HRESULT 
_ExportAndPackKey( 
	IN  HCRYPTKEY   hKey,
	IN  WCHAR      *pwszProviderName,
	IN DWORD        dwProviderType,
	IN OUT P<MQDSPUBLICKEYS>&  pPublicKeysPack 
	)
/*++

Routine Description:
	Export the input key into a keyblob and Pack it in the end of the PublicKeysPack structure

Arguments:
	hKey - input key to be exported and packed
	pwszProviderName - provider name
	dwProviderType - provider type (base, enhanced)
	pPublicKeysPack - in\out Pointer to Public keys pack, the hKey blob will be add 
					   add the end of pPublicKeysPack

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    AP<BYTE> pKeyBlob = NULL;
    DWORD   dwKeyLength;
    DWORD   dwErr;

    BOOL bRet = CryptExportKey( 
					hKey,
					NULL,
					PUBLICKEYBLOB,
					0,
					NULL, // key blob
					&dwKeyLength 
					);
    if (!bRet)
    {
        dwErr = GetLastError();
        LogHR(dwErr, s_FN, 40);

        return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
    }

    pKeyBlob = new BYTE[dwKeyLength];

    bRet = CryptExportKey( 
				hKey,
				NULL,
				PUBLICKEYBLOB,
				0,
				pKeyBlob,
				&dwKeyLength 
				);
    if (!bRet)
    {
        dwErr = GetLastError();
        LogHR(dwErr, s_FN, 50);

        return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
    }

    HRESULT hr = PackPublicKey( 
					pKeyBlob,
					dwKeyLength,
					pwszProviderName,
					dwProviderType,
					pPublicKeysPack 
					);

    return LogHR(hr, s_FN, 60);
}


//+------------------------------------
//
//   HRESULT GetPbKeys()
//
//+------------------------------------

static 
HRESULT 
GetPbKeys(
	IN  BOOL          fRegenerate,
	IN  LPCWSTR		  pwszContainerName,
	IN  LPCWSTR		  pwszProviderName,
	IN  DWORD		  dwProviderType,
	IN  HRESULT       hrDefault,
	OUT HCRYPTPROV   *phProv,
	OUT HCRYPTKEY    *phKeyxKey,
	OUT HCRYPTKEY    *phSignKey
	)
/*++

Routine Description:
	Generate or retrieve Public keys for signing and for session key exchange

Arguments:
	fRegenerate - flag for regenerate new keys or just retrieve the existing keys
	pwszContainerName - container name
	pwszProviderName - provider name
	dwProviderType - provider type (base, enhanced)
	hrDefault - default hr return value
	phProv - pointer to crypto provider handle
	phKeyxKey - pointer to exchange key handle 
	phSignKey - pointer to sign key handle

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    //
    // By default, try to create a new keys container.
    //
    BOOL fSuccess = CryptAcquireContext( 
						phProv,
						pwszContainerName,
						pwszProviderName,
						dwProviderType,
						(CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET) 
						);

	HRESULT hr;

	if (fSuccess)
    {
        //
        // New container created. Set the container security.
        //
        hr = SetKeyContainerSecurity(*phProv);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 70);
        }

        fRegenerate = TRUE;
    }
	else    
    {
        DWORD dwErr = GetLastError();
        
		if (dwErr != NTE_EXISTS)
        {
            LogHR(dwErr, s_FN, 80);
            return hrDefault;
		}
		
		//
		// NTE_EXISTS
        // The key set already exist, so just acquire the CSP context.
        //
        fSuccess = CryptAcquireContext( 
						phProv,
						pwszContainerName,
						pwszProviderName,
						dwProviderType,
						CRYPT_MACHINE_KEYSET 
						);
        if (!fSuccess)
        {
            //
            // Can't open the keys container.
            // We delete previous keys container and create a new one
            // in three cases:
            // 1. The keys got corrupted.
            // 2. We're asked to regenerate the keys themselves. In that
            //    case, old container does not have much value.
            //    This case also happen during setup or upgrade from
            //    nt4/win9x, because of bugs in crypto api that do not
            //    translate correctly the security descriptor of the key
            //    container, when migrating the keys from registry to
            //    file format. See msmq bug 4561, nt bug 359901.
            // 3. Upgrade of cluster. That's probably a CryptoAPI bug,
            //    we just workaround it. msmq bug 4839.
            //
            dwErr = GetLastError();
            LogHR(dwErr, s_FN, 90);

            if (fRegenerate || (dwErr == NTE_KEYSET_ENTRY_BAD))
            {
                //
                // Delete the bad key container.
                //
                fSuccess = CryptAcquireContext( 
								phProv,
								pwszContainerName,
								pwszProviderName,
								dwProviderType,
								(CRYPT_MACHINE_KEYSET | CRYPT_DELETEKEYSET)
								);
                if (!fSuccess)
                {
                    dwErr = GetLastError();
                    LogHR(dwErr, s_FN, 100);

                    return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
                }

                //
                // Re-create the key container.
                //
                fSuccess = CryptAcquireContext( 
								phProv,
								pwszContainerName,
								pwszProviderName,
								dwProviderType,
								(CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET)
								);
                if (!fSuccess)
                {
                    dwErr = GetLastError();
                    LogHR(dwErr, s_FN, 110);

                    return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
                }

                //
                // Set the container security.
                //
                hr = SetKeyContainerSecurity(*phProv);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 120);
                }

                //
                // Now we must generate new key sets.
                //
                fRegenerate = TRUE;
            }
            else
            {
                return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 130);
            }
        }

        if (!fRegenerate)
        {
            //
            // Retrieve the key exchange key set.
            //
			fSuccess = CryptGetUserKey(*phProv, AT_KEYEXCHANGE, phKeyxKey);
            if (!fSuccess)
            {
                dwErr = GetLastError();
                LogHR(dwErr, s_FN, 140);
                return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
            }

            //
            // Retrieve the signing key set.
            //
			fSuccess = CryptGetUserKey(*phProv, AT_SIGNATURE, phSignKey);
            if (!fSuccess)
            {
                dwErr = GetLastError();
                LogHR(dwErr, s_FN, 150);
                return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
            }
        }
    }

    if (fRegenerate)
    {
        //
        // Re-generate the key exchange key set.
        //
        fSuccess = CryptGenKey( 
						*phProv,
						AT_KEYEXCHANGE,
						CRYPT_EXPORTABLE,
						phKeyxKey 
						);
        if (!fSuccess)
        {
            DWORD dwErr = GetLastError();
            LogHR(dwErr, s_FN, 160);
            return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
        }

        //
        // Re-generate the signing key set.
        //
        fSuccess = CryptGenKey( 
						*phProv,
						AT_SIGNATURE,
						CRYPT_EXPORTABLE,
						phSignKey 
						);
        if (!fSuccess)
        {
            DWORD dwErr = GetLastError();
            LogHR(dwErr, s_FN, 170);
            return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
        }
    }
	return MQSec_OK;
}


//+------------------------------------
//
//   HRESULT _PrepareKeyPacks()
//
//+------------------------------------

static 
HRESULT 
_PrepareKeyPacks(
	IN  BOOL                 fRegenerate,
	IN  enum enumProvider    eProvider,
	IN OUT P<MQDSPUBLICKEYS>&  pPublicKeysPackExch,
	IN OUT P<MQDSPUBLICKEYS>&  pPublicKeysPackSign 
	)
/*++

Routine Description:
	Prepare exchange PublicKeys pack and Signature PublicKeys pack.

Arguments:
	fRegenerate - flag for regenerate new keys or just retrieve the existing keys.
	eProvider - Provider type.
    pPublicKeysPackExch - exchange PublicKeys pack.
	pPublicKeysPackSign - signature PublicKeys pack.

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    HRESULT hrDefault = MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
    if (eProvider != eBaseProvider)
    {
        hrDefault = MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED;
    }

    AP<WCHAR>  pwszProviderName = NULL;
    AP<WCHAR>  pwszContainerName = NULL;
    DWORD     dwProviderType;

    HRESULT hr = GetProviderProperties( 
					eProvider,
					&pwszContainerName,
					&pwszProviderName,
					&dwProviderType 
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    CHCryptProv hProv;
    CHCryptKey  hKeyxKey;
    CHCryptKey  hSignKey;

    hr = GetPbKeys(
			fRegenerate,
			pwszContainerName,
			pwszProviderName,
			dwProviderType,
			hrDefault,
			&hProv,
			&hKeyxKey,
			&hSignKey
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }

    //
    // Export key and pack it.
    // On MSMQ1.0, we could have been called for site object (from PSC) and
    // machine object. Only machine object need the key exchange key.
    // On MSMQ2.0, we expect to be called only for machine object.
    //
    hr = _ExportAndPackKey( 
			hKeyxKey,
			pwszProviderName,
			dwProviderType,
			pPublicKeysPackExch 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }

    hr = _ExportAndPackKey( 
			hSignKey,
			pwszProviderName,
			dwProviderType,
			pPublicKeysPackSign 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    return MQSec_OK;
}


//+----------------------------------------------------------------
//
//  HRESULT PbKeysBlobMQIS()
//
//  This code is taken as is from MSMQ1.0 (mqutil\pbkeys.cpp).
//  It's used when server is msmq1.0 on nt4.
//
//+----------------------------------------------------------------

static 
HRESULT 
PbKeysBlobMQIS(
	IN BOOL fRegenerate,
	OUT BLOB * pblobEncrypt,
	OUT BLOB * pblobSign 
	)
{
    BYTE abSignPbK[1024];
    BYTE abKeyxPbK[1024];
    PMQDS_PublicKey pMQDS_SignPbK = (PMQDS_PublicKey)abSignPbK;
    PMQDS_PublicKey pMQDS_KeyxPbK = (PMQDS_PublicKey)abKeyxPbK;

    //
    // We need to read the keys from registry since multiple
    // QMs can live on same machine, each with its own keys,
    // stored in its own registry. (ShaiK)
    //
    WCHAR wzContainer[255] = {L""};
    DWORD cbSize = sizeof(wzContainer);
    DWORD dwType = REG_SZ;

    LONG rc = GetFalconKeyValue(
                  MSMQ_CRYPTO40_CONTAINER_REG_NAME,
                  &dwType,
                  wzContainer,
                  &cbSize,
                  MSMQ_CRYPTO40_DEFAULT_CONTAINER
                  );

	DBG_USED(rc);
    ASSERT(("failed to read from registry", ERROR_SUCCESS == rc));

    //
    // OK, we're almost safe, lets hope the DS will not go off from now until we
    // update the public keys in it...
    //
	CHCryptProv  hProv;
    CHCryptKey hKeyxKey;
    CHCryptKey hSignKey;

    HRESULT hr = GetPbKeys(
					fRegenerate,
					wzContainer,
					MS_DEF_PROV,
					PROV_RSA_FULL,
					MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION,
					&hProv,
					&hKeyxKey,
					&hSignKey
					);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 320);
    }
	
    //
    // Always machine when calling this function
	// Set the key exchange public key blob, only for a machine object.
    //

	//
    // Get the key exchange public key blob
    //
    pMQDS_KeyxPbK->dwPublikKeyBlobSize = sizeof(abKeyxPbK) - sizeof(DWORD);
    if (!CryptExportKey(
            hKeyxKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            pMQDS_KeyxPbK->abPublicKeyBlob,
            &pMQDS_KeyxPbK->dwPublikKeyBlobSize
			))
    {
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 330);
    }

    //
    // Set the signature public key blob.
    //
    pMQDS_SignPbK->dwPublikKeyBlobSize = sizeof(abSignPbK) - sizeof(DWORD);
    if (!CryptExportKey(
            hSignKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            pMQDS_SignPbK->abPublicKeyBlob,
            &pMQDS_SignPbK->dwPublikKeyBlobSize
			))
    {
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 350);
    }

	AP<BYTE> pTempEncryptBlob = new BYTE[pMQDS_KeyxPbK->dwPublikKeyBlobSize];
    memcpy(pTempEncryptBlob, pMQDS_KeyxPbK->abPublicKeyBlob, pMQDS_KeyxPbK->dwPublikKeyBlobSize);

	AP<BYTE> pTempSignBlob = new BYTE[pMQDS_SignPbK->dwPublikKeyBlobSize];
    memcpy(pTempSignBlob, pMQDS_SignPbK->abPublicKeyBlob, pMQDS_SignPbK->dwPublikKeyBlobSize);

    pblobEncrypt->cbSize = pMQDS_KeyxPbK->dwPublikKeyBlobSize;
    pblobEncrypt->pBlobData = pTempEncryptBlob.detach();

    pblobSign->cbSize = pMQDS_SignPbK->dwPublikKeyBlobSize;
    pblobSign->pBlobData = pTempSignBlob.detach();

    return MQSec_OK;
}


//+----------------------------------------------------------------------
//
//  HRESULT  MQSec_StorePubKeys()
//
//  This function always store four keys in local machine:
//  Key-Exchange and signing for Base provider and similar two keys
//  for enhanced provider.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY 
MQSec_StorePubKeys( 
	IN BOOL fRegenerate,
	IN enum enumProvider eBaseCrypProv,
	IN enum enumProvider eEnhCrypProv,
	OUT BLOB * pblobEncrypt,
	OUT BLOB * pblobSign 
	)
{
    P<MQDSPUBLICKEYS>  pPublicKeysPackExch = NULL;
    P<MQDSPUBLICKEYS>  pPublicKeysPackSign = NULL;

    HRESULT hr = _PrepareKeyPacks( 
					fRegenerate,
					eBaseCrypProv,
					pPublicKeysPackExch,
					pPublicKeysPackSign 
					);

    if (FAILED(hr))
    {
        TrERROR(SECURITY, "Fail to prepare keys for base provider, %!hresult!", hr);
        return hr;
    }

    hr = _PrepareKeyPacks( 
			fRegenerate,
			eEnhCrypProv,
			pPublicKeysPackExch,
			pPublicKeysPackSign 
			);

    if (FAILED(hr))
    {
        TrERROR(SECURITY, "Fail to prepare keys for enhanced provider, %!hresult!", hr);
        return hr;
    }

	//
	// Encrypt Blob
	//
    MQDSPUBLICKEYS * pBuf   = pPublicKeysPackExch;
    pblobEncrypt->cbSize    = pPublicKeysPackExch->ulLen;
    pblobEncrypt->pBlobData = (BYTE*) pBuf;

	//
	// Sign Blob
	//
    pBuf                    = pPublicKeysPackSign;
    pblobSign->cbSize       = pPublicKeysPackSign->ulLen;
    pblobSign->pBlobData    = (BYTE*) pBuf;

    pPublicKeysPackExch.detach();
    pPublicKeysPackSign.detach();

    return MQSec_OK;

} // MQSec_StorePubKeys

//+----------------------------------------------------------------------
//
//  HRESULT  MQSec_StorePubKeysInDS()
//
//  This function always store four keys in the DS:
//  Key-Exchange and signing for Base provider and similar two keys
//  for enhanced provider.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY 
MQSec_StorePubKeysInDS( 
	IN BOOL      fRegenerate,
	IN LPCWSTR   wszObjectName,
	IN DWORD     dwObjectType,
	IN BOOL		 fFromSetup		 /* false */
	)
{
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwMachineNameSize = sizeof(szMachineName) /sizeof(TCHAR);

    enum enumProvider eBaseCrypProv = eBaseProvider ;
    enum enumProvider eEnhCrypProv = eEnhancedProvider ;

    if (dwObjectType == MQDS_FOREIGN_MACHINE)
    {
        if (wszObjectName == NULL)
        {
            //
            // Name of foreign machine must be provided.
            //
            return LogHR(MQ_ERROR_ILLEGAL_OPERATION, s_FN, 380) ;
        }

        eBaseCrypProv = eForeignBaseProvider ;
        eEnhCrypProv = eForeignEnhProvider ;
        dwObjectType = MQDS_MACHINE ;
    }
    else if (dwObjectType != MQDS_MACHINE)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 390);
    }

	HRESULT hr;
    if (!wszObjectName)
    {
        hr = GetComputerNameInternal(szMachineName, &dwMachineNameSize) ;
        if (FAILED(hr))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 400);
        }
        wszObjectName = szMachineName;
    }
    //
    //  Explicit ADInit call to override the default of downlevel 
    //  notification support.
    //
    //  NOTE - overriding the default is ok because this API is used to 
    //         update either this computer or foreign computers (to which MSMQ
    //         doesn't send notifications).
    //
    hr = ADInit(
            NULL,   // pLookDS
            NULL,   // pGetServers
            false,  // fSetupMode
            false,  // fQMDll
			false,  // fIgnoreWorkGroup
            true   // fDisableDownlevelNotifications
            );
    if (FAILED(hr))
    {
        return LogHR(MQ_ERROR, s_FN, 401);
    }

    //
    // First verify that the DS is reachable and that we have access rights
    // to do what we want to do. We don't want to change the keys before we
    // verify this.
    //

    //
    // Read the signature public key from the DS. This way we verify that the
    // DS is available, at least for the moment, and that we have read
    // permissions access rights on the object.
    //
    PROPID propId = PROPID_QM_SIGN_PK;
    PROPVARIANT varKey ;
    varKey.vt = VT_NULL ;

	//
	// if we run from setup we dont want to check if we have read/write access to DS 
	// because writing to DS will send notification to load empty keys
	//
	
	if (!fFromSetup)
	{
		hr = ADGetObjectProperties(
					eMACHINE,
					NULL,      // pwcsDomainController
					false,	   // fServerName
					wszObjectName,
					1,
					&propId,
					&varKey
					);
		
		if (FAILED(hr))
		{
			return LogHR(hr, s_FN, 410);
		}

		//
		// Write the signature public key in the DS. This way we verify that the
		// DS is still available and that we have write permissions on the object.
		//
		hr = ADSetObjectProperties(
					eMACHINE,
					NULL,		// pwcsDomainController
					false,		// fServerName
					wszObjectName,
					1,
					&propId,
					&varKey
					);
		
		if (FAILED(hr))
		{
			return LogHR(hr, s_FN, 420);
		}
	}

    //
    // OK, we're almost safe, lets hope the DS will not go off from now until
    // we update the public keys in it...
    //
    BLOB blobEncrypt;
    blobEncrypt.cbSize    = 0;
    blobEncrypt.pBlobData = NULL;

    BLOB blobSign;
    blobSign.cbSize       = 0;
    blobSign.pBlobData    = NULL;

	if(DsEnvIsMqis())
	{
		hr = PbKeysBlobMQIS( 
				fRegenerate,
				&blobEncrypt,
				&blobSign 
				);

	}
	else // eAD
	{
		hr = MQSec_StorePubKeys( 
				fRegenerate,
				eBaseCrypProv,
				eEnhCrypProv,
				&blobEncrypt,
				&blobSign 
				);
	}

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 430);
    }

    AP<BYTE> pCleaner1     = blobEncrypt.pBlobData;
    AP<BYTE> pCleaner2     = blobSign.pBlobData;

    //
    // Write the public keys in the DS.
    //
	propId = PROPID_QM_ENCRYPT_PK;
    varKey.vt = VT_BLOB;
    varKey.blob = blobEncrypt;

    hr = ADSetObjectProperties(
				eMACHINE,
				NULL,		// pwcsDomainController
				false,		// fServerName
				wszObjectName,
				1,
				&propId,
				&varKey
				);
	
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    propId = PROPID_QM_SIGN_PK;
    varKey.vt = VT_BLOB ;
    varKey.blob = blobSign;

    hr = ADSetObjectProperties(
				eMACHINE,
				NULL,		// pwcsDomainController
				false,		// fServerName
				wszObjectName,
				1,
				&propId,
				&varKey
				);
	
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 450);
    }

    return MQSec_OK ;
}

//+-------------------------------------------------------------------------
//
//  HRESULT  MQSec_GetPubKeysFromDS()
//
//  if caller supply machine guid, then "pfDSGetObjectPropsGuidEx" must be
//  pointer to "DSGetObjectPropsGuidEx". Otherwise, if caller supply machine
//  name, it must be pointer to "DSGetObjectPropsGuidEx".
//
//+-------------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetPubKeysFromDS(
	IN  const GUID  *pMachineGuid,
	IN  LPCWSTR      lpwszMachineName,
	IN  enum enumProvider     eProvider,
	IN  DWORD        propIdKeys,
	OUT BYTE       **ppPubKeyBlob,
	OUT DWORD       *pdwKeyLength 
	)
{

	//
	// Since all AD* will return PROPID_QM_ENCRYPT_PK unpack
	// assert so if we are called with this prop, change the code
	//
	ASSERT(propIdKeys != PROPID_QM_ENCRYPT_PK);

    if ((eProvider != eBaseProvider) && (DsEnvIsMqis()))
    {
        //
        // msmq1.0 server support only base providers.
        //
        return LogHR(MQ_ERROR_PUBLIC_KEY_NOT_FOUND, s_FN, 460);
    }

    if ((eProvider == eBaseProvider) && (propIdKeys == PROPID_QM_ENCRYPT_PKS) && (DsEnvIsMqis()))
    {
        //
        // msmq1.0 server support only PROPID_QM_ENCRYPT_PK
        //
		propIdKeys = PROPID_QM_ENCRYPT_PK;
    }
    
	P<WCHAR>  pwszProviderName = NULL;
    DWORD     dwProviderType;

    HRESULT hr =  GetProviderProperties( 
						eProvider,
						NULL,
						&pwszProviderName,
						&dwProviderType 
						);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }
    ASSERT(pwszProviderName);

    PROPID propId = (PROPID)  propIdKeys;
    PROPVARIANT  varKey;
    varKey.vt = VT_NULL;

    //
    // The Ex queries used below are supported only on Windows AD. If
    // a Windows client is served only by NT4 MQIS servers, then the
    // query will fail with error MQ_ERROR_NO_DS. We don't want the mqdscli
    // code to search for all DS servers, looking for a Windows AD.
    // That's the reason for the FALSE parameter. That means that 128 bit
    // encryption is fully supported only in native mode, i.e., when all
    // DS servers are Windows Active Directory.
    // Better solutions are to enabled per-thread server lookup (as is
    // enabled in run-time) or lazy query of encryption key. both are
    // expensive in terms of coding and testing.
    // Note that the FALSE flag is effective only if the server is alive and
    // is indeed a NT4 one. If DS servers are not availalbe, then mqdscli
    // wil look for available servers.
    //

    if (pMachineGuid)
    {
        ASSERT(!lpwszMachineName);

        hr = ADGetObjectPropertiesGuid(
				eMACHINE,
				NULL,      // pwcsDomainController
				false,	   // fServerName
				pMachineGuid,
				1,
				&propId,
				&varKey
				);
	
	}
    else if (lpwszMachineName)
    {
        hr = ADGetObjectProperties(
				eMACHINE,
				NULL,      // pwcsDomainController
				false,	   // fServerName
				lpwszMachineName,
				1,
				&propId,
				&varKey
				);
	}
    else
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 480);
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 510);
    }

    if (varKey.blob.pBlobData == NULL)
    {
        return LogHR(MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST, s_FN, 520);
    }

    ASSERT(varKey.vt == VT_BLOB);

	if(DsEnvIsMqis())
	{
		//
		// msmq1.0 treatment
		//
		*ppPubKeyBlob = varKey.blob.pBlobData;
		*pdwKeyLength = varKey.blob.cbSize;
	    return MQSec_OK;
	}

	//
	// msmq2.0 treatment eAD
	// 
	ASSERT(s_DsEnv == eAD);

    P<MQDSPUBLICKEYS> pPublicKeysPack =
                           (MQDSPUBLICKEYS*) varKey.blob.pBlobData;
    ASSERT(pPublicKeysPack->ulLen == varKey.blob.cbSize);
    if ((long) (pPublicKeysPack->ulLen) > (long) (varKey.blob.cbSize))
    {
        //
        // Either blob is corrupted or we read a beta2 format (same as
        // MQIS, key blob without package).
        //
        return  LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 530);
    }

    ULONG ulKeySize;
    BYTE *pKeyBlob = NULL;

    hr = MQSec_UnpackPublicKey( 
			pPublicKeysPack,
			pwszProviderName,
			dwProviderType,
			&pKeyBlob,
			&ulKeySize 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 540);
    }
    ASSERT(pKeyBlob);

    *pdwKeyLength = ulKeySize;
    *ppPubKeyBlob = new BYTE[*pdwKeyLength];
    memcpy(*ppPubKeyBlob, pKeyBlob, *pdwKeyLength);

    return MQSec_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypttest\mqutilsimulate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MqutilSimulate.cpp

Abstract:
    simulate mqutil functions

Author:
    Ilan Herbst (ilanh) 14-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "mq.h"

#include "mqutilsimulate.tmh"

#define MQUTIL_EXPORT __declspec(dllexport)

//
// constants
//
#define EVENTLOGID          DWORD
#define DBGLVL              UINT

///////////////////////////////////////////////////////////////////////////
//
// class COutputReport
//
// Description : a class for outputing debug messages and event-log messages
//
///////////////////////////////////////////////////////////////////////////

class COutputReport
{
public:

    COutputReport(void)
	{
	}

#ifdef _DEBUG
    void 
	DebugMsg(
		DWORD dwMdl, 
		DBGLVL uiLvl, 
		WCHAR * Format,
		...
		);
#endif

	//
    // event-log functions (valid in release and debug version)
	//
	void ReportMsg( 
		EVENTLOGID id,
		DWORD   cMemSize  = 0,
		LPVOID  pMemDump  = NULL,
		WORD    cParams   = 0,
		LPCTSTR *pParams  = NULL,
		WORD    wCategory = 0 
		);
};


//
// Declare an Object of the report-class.
//
// Only one object is declared per process. In no other module should there be another declaration of an
// object of this class.
//
__declspec(dllexport) COutputReport Report;


HRESULT
MQUTIL_EXPORT
APIENTRY
GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize
    )
/*++

Routine Description:
	Get Computer name in lower case

Arguments: 
	pwcsMachineName - OUT wstring for computer name
	pcbSize - IN/OUT buffer size

Return Value:
    MQ_OK if normal operation, MQ_ERROR if error 

--*/
{
    if (GetComputerName(pwcsMachineName, pcbSize))
    {
        CharLower(pwcsMachineName);
        return MQ_OK;
    }

    return MQ_ERROR;

}


LONG
MQUTIL_EXPORT
APIENTRY
GetFalconKeyValue(
    LPCTSTR /*pszValueName*/,
    PDWORD  pdwType,
    PVOID   pData,
    PDWORD  pdwSize,
    LPCTSTR pszDefValue
    )
/*++

Routine Description:
	Get FalconKey Value. this function simulate mqutil function and always 
	assign the given default value.

Arguments:
	pszValueName - Value Name string
	pdwType - value type
	pData - OUT the value data
	pdwSize - pData buffer size
	pszDefValue - default value

Return Value:
    MQ_OK if normal operation, MQ_ERROR if error 

--*/
{
    if(pszDefValue)
    {
		if (pdwType && (*pdwType == REG_SZ))
		{
			//
			// Don't use the default if caller buffer was too small for
			// value in registry.
			//
			if ((DWORD) wcslen(pszDefValue) < *pdwSize)
			{
				wcscpy((WCHAR*) pData, pszDefValue);
			}
		}
		if (*pdwType == REG_DWORD)
		{
			*((DWORD *)pData) = *((DWORD *) pszDefValue);
		}
    }
	else 
	{
		//
		// No Default Value
		//
        printf("Mqutil simulation GetFalconKeyValue dont supported, need DefValue\n");
		ASSERT(0);
		return MQ_ERROR;
	}

    return MQ_OK;
}


LONG
MQUTIL_EXPORT
APIENTRY
SetFalconKeyValue(
    LPCTSTR /*pszValueName*/,
    PDWORD  /*pdwType*/,
    const VOID * pData,
    PDWORD  pdwSize
    )
/*++

Routine Description:
	Set FalconKey Value. this function simulate mqutil function and do nothing 

Arguments:
	pszValueName - Value Name string
	pdwType - value type
	pData - OUT the value data
	pdwSize - pData buffer size

Return Value:
    ERROR_SUCCESS 

--*/
{
    ASSERT(pData != NULL);
    ASSERT(pdwSize != NULL);

	DBG_USED(pData);
	DBG_USED(pdwSize);

    printf("Mqutil simulation dont support SetFalconKeyValue\n");
	ASSERT(0);

    return(ERROR_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
// COutputReport::ReportMsg
//
// ReportMsg function writes to the Event-log of the Windows-NT system.
// The message is passed only if the the level setisfies the current
// debugging level. The paramaters are :
//
// id - identity of the message that is to be displayed in the event-log
//      (ids are listed in the string-table)
// cMemSize - number of memory bytes to be displayed in the event-log (could be 0)
// pMemDump - address of memory to be displayed
// cParams - number of strings to add to this message (could be 0)
// pParams - a list of cParams strings (could be NULL only if cParams is 0)
//

void COutputReport::ReportMsg( EVENTLOGID /*id*/,
                               DWORD      /*cMemSize*/,
                               LPVOID     /*pMemDump*/,
                               WORD       /*cParams*/,
                               LPCTSTR  * /*pParams*/,
                               WORD       /*wCategory*/ )
/*++

Routine Description:
	Simulate COutputReport::ReportMsg and do nothing 

--*/
{
}

#ifdef _DEBUG
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// COutputReport::DebugMsg - UNICODE version
//
// The function receives a formated string representing the debug message along with a flag that represents
// the level of the passed message. If the level setisfies the current debugging level then the message is
// translated into a buffer and passed to the locations matching the current debug locations.
//

void COutputReport::DebugMsg(DWORD /*dwMdl*/, DBGLVL /*uiLvl*/, WCHAR * /*Format*/, ...)
/*++

Routine Description:
	Simulate COutputReport::DebugMsg and do nothing 

--*/
{
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\encrypttest\stdh.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file used for precompilation.

Author:

    Ilan Herbst  (ilanh)  13-Jun-2000

Environment:

    Platform-independent

Revision History:

--*/


#ifndef _ENCRYPTTEST_STDH_H_
#define _ENCRYPTTEST_STDH_H_

#include <libpch.h>


#endif // _ENCRYPTTEST_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\mqseclog.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: mqseclog.cpp

Abstract:

    Log errors and other messages of the security code.

Author:

    Doron Juster  (DoronJ)  24-May-1998

--*/

#include <stdh.h>

#include "mqseclog.tmh"

static WCHAR *s_FN=L"secutils/mqseclog";

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), NT STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), RPC STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), BOOL: 0x%x", wszFileName, usPoint, b);
}

void LogMsgDWORD(DWORD dw, LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), DWORD: 0x%x", wszFileName, usPoint, dw);
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
	TrERROR(LOG, "%ls(%u), Illegal point", wszFileName, usPoint);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\mqsemain.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    mqsemain.cpp

Abstract:
    Entry point of mqsec.dll

Author:
    Doron Juster (DoronJ)  24-May-1998

Revision History:

--*/

#include <stdh.h>
#include <Cm.h>
#include <Tr.h>
#include <Ev.h>
#include <_registr.h>

#include "mqsemain.tmh"

BOOL WINAPI AccessControlDllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved) ;
BOOL WINAPI CertDllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved) ;
BOOL WINAPI MQsspiDllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved) ;

static WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH + 1];
LPCWSTR g_wszMachineName = wszMachineName;

bool g_fDebugRpc = false;

static bool InitGlobalVars()
{
    DWORD dwMachineNameSize = sizeof(wszMachineName)/sizeof(WCHAR);

    HRESULT hr = GetComputerNameInternal(
					const_cast<LPWSTR>(g_wszMachineName),
					&dwMachineNameSize
					);
    if(FAILED(hr))
    {
    	TrERROR(GENERAL, "GetComputerNameInternal failed. hr = 0x%x", hr);
    	return false;
    }
    return true;
}


static void InitDebugRpcFlag(void)
{
    DWORD DebugRpcFlag = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    LONG rc = GetFalconKeyValue( 
					MSMQ_DEBUG_RPC_REGNAME,
					&dwType,
					&DebugRpcFlag,
					&dwSize 
					);

	ASSERT((rc == ERROR_SUCCESS) || (DebugRpcFlag == 0)); 
	DBG_USED(rc);

    g_fDebugRpc = (DebugRpcFlag != 0);
    TrTRACE(RPC, "fDebugRpc = %d", g_fDebugRpc);
}


static void SetAssertBenign(void)
{
#ifdef _DEBUG
    DWORD AssertBenignValue = 0;
	DWORD Type = REG_DWORD;
    DWORD Size = sizeof(DWORD);
  
    
    GetFalconKeyValue(
        			  ASSERT_BENIGN_REGNAME,
        			  &Type,
        			  &AssertBenignValue,
        			  &Size
        			  );
    
    g_fAssertBenign = (AssertBenignValue != 0);
#endif
}


/*====================================================

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)

 Initialization and cleanup when DLL is loaded, attached and detached.

=====================================================*/


BOOL WINAPI DllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved)
{
    g_hInstance = hMod;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

		
		
        if(!InitGlobalVars())
        {
        	return FALSE;
        }
        InitDebugRpcFlag();
        SetAssertBenign();
    }

	


	//
	// Call mqsec static lib DllMain
	//

    BOOL f = AccessControlDllMain(hMod, fdwReason, lpvReserved);
    if (!f)
    {
        return f;
    }

    f = CertDllMain(hMod, fdwReason, lpvReserved);
    if (!f)
    {
        return f;
    }

    f = MQsspiDllMain(hMod, fdwReason, lpvReserved);
    if (!f)
    {
        return f;
    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        // Free DTC data - if it was loaded
        //
        XactFreeDTC();

        WPP_CLEANUP();
    }
    else if (fdwReason == DLL_THREAD_ATTACH)
    {
    }
    else if (fdwReason == DLL_THREAD_DETACH)
    {
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\inc\permit.h ===
/****************************************************************************
*                            permit.h                                       *
*                                                                           *
*  This file contains all the definition used by the directory service to   *
* implement security, as well the prototypes for the apis exposed.          *
*									    *
* Copyright Microsoft Corp, 1992,1994					    *
****************************************************************************/
#include "accctrl.h"
//
// Define the rights used in the DS
//

#define	RIGHT_DS_CREATE_CHILD	  ACTRL_DS_CREATE_CHILD
#define RIGHT_DS_DELETE_CHILD     ACTRL_DS_DELETE_CHILD
#define RIGHT_DS_DELETE_SELF      DELETE
#define RIGHT_DS_LIST_CONTENTS    ACTRL_DS_LIST
#define RIGHT_DS_SELF_WRITE       ACTRL_DS_SELF
#define RIGHT_DS_READ_PROPERTY    ACTRL_DS_READ_PROP
#define RIGHT_DS_WRITE_PROPERTY   ACTRL_DS_WRITE_PROP
#define RIGHT_DS_DELETE_TREE      ACTRL_DS_DELETE_TREE
#define RIGHT_DS_LIST_OBJECT      ACTRL_DS_LIST_OBJECT
#define RIGHT_DS_CONTROL_ACCESS   ACTRL_DS_CONTROL_ACCESS
//
// Define the generic rights
//

// generic read
#define GENERIC_READ_MAPPING     ((STANDARD_RIGHTS_READ)     | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_LIST_OBJECT))

// generic execute
#define GENERIC_EXECUTE_MAPPING  ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (RIGHT_DS_LIST_CONTENTS))
// generic right
#define GENERIC_WRITE_MAPPING    ((STANDARD_RIGHTS_WRITE)    | \
                                  (RIGHT_DS_SELF_WRITE)      | \
				  (RIGHT_DS_WRITE_PROPERTY))
// generic all

#define GENERIC_ALL_MAPPING      ((STANDARD_RIGHTS_REQUIRED) | \
                                  (RIGHT_DS_CREATE_CHILD)    | \
                                  (RIGHT_DS_DELETE_CHILD)    | \
                                  (RIGHT_DS_DELETE_TREE)     | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_WRITE_PROPERTY)  | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_LIST_OBJECT)     | \
                                  (RIGHT_DS_CONTROL_ACCESS)  | \
                                  (RIGHT_DS_SELF_WRITE))

//
// Standard DS generic access rights mapping
//

#define DS_GENERIC_MAPPING {GENERIC_READ_MAPPING,    \
			    GENERIC_WRITE_MAPPING,   \
			    GENERIC_EXECUTE_MAPPING, \
			    GENERIC_ALL_MAPPING}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\cancel.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    cancel.cpp

Abstract:

Author:

--*/

#include "stdh.h"
#include "cancel.h"
#include <mqexception.h>

#include "cancel.tmh"

MQUTIL_EXPORT CCancelRpc	g_CancelRpc;

DWORD
WINAPI
CCancelRpc::CancelThread(
    LPVOID pParam
    )
/*++

Routine Description:

    Thread routine to cancel pending RPC calls

Arguments:

    None

Return Value:

    None

--*/
{
    CCancelRpc* p = static_cast<CCancelRpc*>(pParam);
    p->ProcessEvents();

    ASSERT(("this line should not be reached!", 0));
    return 0;
}



CCancelRpc::CCancelRpc() :
	m_hModule(NULL),
	m_RefCount(0),
	m_ThreadIntializationStatus(MQ_OK),
	m_dwRpcCancelTimeout(FALCON_DEFAULT_RPC_CANCEL_TIMEOUT * 60 * 1000)
{
}


CCancelRpc::~CCancelRpc()
{
}



HMODULE GetLibraryReference()
{
	WCHAR szModuleName[_MAX_PATH];
	szModuleName[_MAX_PATH - 1] = L'\0';

    DWORD res = GetModuleFileName(g_hInstance, szModuleName, STRLEN(szModuleName));
	if(res == 0)
	{
		DWORD gle = GetLastError();
		TrERROR(RPC, "Failed to get module file name, error %d", gle);
		throw bad_win32_error(gle);
	}

    HMODULE handle = LoadLibrary(szModuleName);
	if(handle == NULL)
	{
		DWORD gle = GetLastError();
		TrERROR(RPC, "Failed to load library, error %d", gle);
		throw bad_win32_error(gle);
	}

	return handle;
}



void
CCancelRpc::Init(
    void
    )
{
	CS lock(m_cs);

	++m_RefCount;
	if(m_RefCount > 1)
		return;

	try
	{
		if(m_hCancelThread != (HANDLE) NULL)
		{
			//
			// There is a scenario when the MQRT dll is shut down and it signals the cancel thread to
			// terminate but before it does the MQRT is loaded again and we may end up trying to
			// create a new cancel thread before the old one exits, so we wait here.
			//
			DWORD res = WaitForSingleObject(m_hCancelThread, INFINITE);
			if(res != WAIT_OBJECT_0)
			{
				DWORD gle = GetLastError();
				TrERROR(RPC, "Failed wait for cancel thread to exit, error %d", gle);
				throw bad_win32_error(gle);
			}

			HANDLE hThread = m_hCancelThread;
			m_hCancelThread = NULL;
			CloseHandle(hThread);
		}

		//
		// This auto-reset event controls whether the Cancel-rpc thread wakes up
		//
		if(m_hRpcPendingEvent == NULL)
		{
			m_hRpcPendingEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			if(m_hRpcPendingEvent == NULL)
			{
				DWORD gle = GetLastError();
				TrERROR(RPC, "Failed to create rpc pending event, error %!winerr!", gle);
				throw bad_win32_error(gle);
			}
		}

		//
		//  When signaled this event tells the worker threads when to
		//  terminate
		//
		if(m_hTerminateThreadEvent == NULL)
		{
			m_hTerminateThreadEvent = CreateEvent( NULL, FALSE, FALSE, NULL);
			if(m_hTerminateThreadEvent == NULL)
			{
				DWORD gle = GetLastError();
				TrERROR(RPC, "Failed to create terminate thread event, error %!winerr!", gle);
				throw bad_win32_error(gle);
			}
		}

		//
		// We must reset this event since it might have been set by a previous call to this function that
		// timedout the wait on m_hThreadIntializationComplete
		//
		if(!ResetEvent(m_hTerminateThreadEvent))
		{
				DWORD gle = GetLastError();
				TrERROR(RPC, "Failed to reset terminate thread event, error %!winerr!", gle);
				throw bad_win32_error(gle);
		}

		//
		//  Signaled by the cancel thread to indicate initialization completed.
		//
		if(m_hThreadIntializationComplete == NULL)
		{
			m_hThreadIntializationComplete = CreateEvent( NULL, FALSE, FALSE, NULL);
			if(m_hThreadIntializationComplete == NULL)
			{
				DWORD gle = GetLastError();
				TrERROR(RPC, "Failed to create initialization completed event, error %!winerr!", gle);
				throw bad_win32_error(gle);
			}
		}

		//
		//  Read rpc cancel registry timeout
		//
		DWORD dwCancelTimeout =  FALCON_DEFAULT_RPC_CANCEL_TIMEOUT;
		DWORD  dwSize = sizeof(DWORD) ;
		DWORD  dwType = REG_DWORD ;
															
		m_dwRpcCancelTimeout = dwCancelTimeout;									

		GetFalconKeyValue(
			FALCON_RPC_CANCEL_TIMEOUT_REGNAME,
			&dwType,
			&m_dwRpcCancelTimeout,
			&dwSize,
			(LPCWSTR)&dwCancelTimeout
			);
		
		if (m_dwRpcCancelTimeout == 0)
        {
            //
            // This value must not be 0, even if user add a registry value
            // with 0. With a 0 value, rpc calls will  be cancelled
            // immediately and sporadically before being copmleted.
            // see also bug 8865.
            //
            ASSERT(("RpcCancelTimeout must not be 0", (m_dwRpcCancelTimeout != 0))) ;
		    m_dwRpcCancelTimeout = FALCON_DEFAULT_RPC_CANCEL_TIMEOUT;
        }

		m_dwRpcCancelTimeout *= ( 60 * 1000);    // in millisec

		ASSERT(m_hModule == NULL);
		m_hModule = GetLibraryReference();

		//
		//  Create Cancel-rpc thread
		//
		DWORD   dwCancelThreadId;
		m_hCancelThread = CreateThread(
								   NULL,
								   0,       // stack size
								   CancelThread,
								   this,
								   0,       // creation flag
								   &dwCancelThreadId
								   );

		if(m_hCancelThread == NULL)
		{
			DWORD gle = GetLastError();

			FreeLibrary(m_hModule);
			m_hModule = NULL;

			TrERROR(RPC, "Failed to create cancel thread, error %d", gle);

			throw bad_win32_error(gle);
		}

		//
		// Wait for Cancel thread to complete its initialization
		//
		DWORD result = WaitForSingleObject(m_hThreadIntializationComplete, 10000);
		
		if(result == WAIT_TIMEOUT)
		{	
			//
			// The thread did not initialize in time. This is either because of low resources or 
			// because we reached here because the first MSMQ API function was called from DLLMain() of a dll.
			// This prevents the thread from initializing until we leave the DllMain() function, but we prefer to abort in this case.
			// So we tell the thread to shut it self down when it does finish initialization.
			//
			TrERROR(RPC, "Cancel thread failed to initialize in a timely fashion.");
			SetEvent(m_hTerminateThreadEvent);

			throw exception();
		}

		if(result != WAIT_OBJECT_0 || FAILED(m_ThreadIntializationStatus))
		{	
			TrERROR(RPC, "Cancel thread failed to initialize, error %d", m_ThreadIntializationStatus);
			throw bad_hresult(m_ThreadIntializationStatus);
		}

		return;
	}
	catch(const exception&)
	{
		--m_RefCount;
		throw;
	}
}//CCancelRpc::Init


DWORD CCancelRpc::RpcCancelTimeout()
{
	ASSERT(m_dwRpcCancelTimeout != 0);
	return m_dwRpcCancelTimeout;
}


void CCancelRpc::ShutDownCancelThread()
{
	CS lock(m_cs);

	--m_RefCount;
	ASSERT(m_RefCount >= 0);
	if(m_RefCount > 0)
		return;

    SetEvent(m_hTerminateThreadEvent);
}



void
CCancelRpc::ProcessEvents(
    void
    )
{
	//
    //  for MQAD operations with ADSI, we need MSMQ thread that
    //  calls CoInitialize and is up and runing as long as
    //  RT & QM are up
    //
    //  To avoid the overhead of additional thread, we are using
    //  cancel thread for this purpose
    //
    m_ThreadIntializationStatus = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
    SetEvent(m_hThreadIntializationComplete);

	if(FAILED(m_ThreadIntializationStatus))
	{
		TrERROR(RPC, "Failed to initialize COM in cancel thread, error %d", m_ThreadIntializationStatus);

		HMODULE handle = m_hModule;
		m_hModule = NULL;
		FreeLibraryAndExitThread(handle,0);
        ASSERT(("this line should not be reached!", 0));
	}


    DWORD dwRpcCancelTimeoutInSec = m_dwRpcCancelTimeout /1000;

    HANDLE hEvents[2];
    hEvents[0] = m_hTerminateThreadEvent;
    hEvents[1] = m_hRpcPendingEvent;
    DWORD dwTimeout = INFINITE;

    for (;;)
    {
        DWORD res = WaitForMultipleObjects(
                        2,
                        hEvents,
                        FALSE,  // wait for any event
                        dwTimeout
                        );
        if ( res == WAIT_OBJECT_0)
        {
            //
            // dec reference to CoInitialize
            //
            CoUninitialize();
			ASSERT(m_hModule != NULL);
			HMODULE handle = m_hModule;
			m_hModule = NULL;
            FreeLibraryAndExitThread(handle,0);
            ASSERT(("this line should not be reached!", 0));
        }
        if ( res == WAIT_OBJECT_0+1)
        {
            dwTimeout = m_dwRpcCancelTimeout;
            continue;
        }

        ASSERT(("event[s] abandoned", WAIT_TIMEOUT == res));

        //
        // Timeout. Check for pending RPC.
        //
        if (m_mapOutgoingRpcRequestThreads.IsEmpty())
        {
            //
            // No pending RPC, back to wait state
            //
            dwTimeout = INFINITE;
            continue;
        }

        //
        //  Check to see if there are outgoing calles issued
        //  more than m_dwRpcCancelTimeout ago
        //
        CancelRequests( time( NULL) - dwRpcCancelTimeoutInSec);
    }

}//CCancelRpc::ProcessEvents

void
CCancelRpc::Add(
                IN HANDLE hThread,
                IN time_t	timeCallIssued
                )
{
	CS lock(m_cs);

    BOOL bWasEmpty = m_mapOutgoingRpcRequestThreads.IsEmpty();

	m_mapOutgoingRpcRequestThreads[hThread] = timeCallIssued;

    if (bWasEmpty)
    {
        VERIFY(PulseEvent(m_hRpcPendingEvent));
    }
}


void
CCancelRpc::Remove(
    IN HANDLE hThread
    )
{
	CS lock(m_cs);

	m_mapOutgoingRpcRequestThreads.RemoveKey( hThread);

}


void
CCancelRpc::CancelRequests(
    IN time_t timeIssuedBefore
    )
{
	CS lock(m_cs);
	time_t	timeRequest;
	HANDLE	hThread;

    POSITION pos;
    pos = m_mapOutgoingRpcRequestThreads.GetStartPosition();
    while(pos != NULL)
    {
		m_mapOutgoingRpcRequestThreads.GetNextAssoc(pos,
											hThread, timeRequest);
		if ( timeRequest < timeIssuedBefore)
		{
			//
			//	The request is outgoing more than the desired time,
			//	cancel it
			//
			RPC_STATUS status;
			status = RpcCancelThread( hThread);
			ASSERT( status == RPC_S_OK);

			//
			// Get it out of the map
            // (calling Remove() again for this thread is no-op)
            //
            Remove(hThread);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\mqutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqutil.cpp

Abstract:

    General utility functions for the general utility dll. This dll contains
    various functions that both the DS and the QM need.

Author:

    Boaz Feldbaum (BoazF) 7-Apr-1996.

--*/

#include "stdh.h"
#include "cancel.h"
#include "mqprops.h"

#include "mqutil.tmh"


HINSTANCE g_hInstance;
HINSTANCE g_DtcHlib         = NULL; // handle of the loaded DTC proxy library (defined in rtmain.cpp)
IUnknown *g_pDTCIUnknown    = NULL; // pointer to the DTC IUnknown
ULONG     g_cbTmWhereabouts = 0;    // length of DTC whereabouts
BYTE     *g_pbTmWhereabouts = NULL; // DTC whereabouts

MQUTIL_EXPORT CHCryptProv g_hProvVer ;

extern CCancelRpc g_CancelRpc;

static BOOL s_fSecInitialized = FALSE ;

void MQUInitGlobalScurityVars()
{
    if (s_fSecInitialized)
    {
       return ;
    }
    s_fSecInitialized = TRUE ;

    BOOL bRet ;
    //
    // Get the verification context of the default cryptographic provider.
    // This is not needed for RT, which call with (fFullInit = FALSE)
    //
    bRet = CryptAcquireContext(
                &g_hProvVer,
                NULL,
                MS_DEF_PROV,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT
                );
    if (!bRet)
    {
		DWORD gle = GetLastError();
        TrERROR(SECURITY, "CryptAcquireContext Failed, gle = %!winerr!", gle);
    }

}

//---------------------------------------------------------
//
//  ShutDownDebugWindow()
//
//  Description:
//
//       This routine notifies working threads to shutdown.
//       Each working thread increments the load count of this library,
//       and on exit it calls FreeLibraryAndExistThread().
//
//       This routine cannot be called from this DLL PROCESS_DETACH,
//       Because PROCESS_DETACH is called only after all the threads
//       are terminated ( which doesn't allow them to perform shutdown).
//       Therefore MQRT calls ShutDownDebugWindow(),  and this allows
//       the working threads to perform shutdown.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

VOID APIENTRY ShutDownDebugWindow(VOID)
{
    //
    //  Signale all threads to exit
    //
	g_CancelRpc.ShutDownCancelThread();
}



HRESULT 
MQUTIL_EXPORT
APIENTRY
GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize
    )
{
    if (GetComputerName(pwcsMachineName, pcbSize))
    {
        CharLower(pwcsMachineName);
        return MQ_OK;
    }
	TrERROR(GENERAL, "Failed to get computer name, error %!winerr!", GetLastError());

    return MQ_ERROR;
} //GetComputerNameInternal

HRESULT 
MQUTIL_EXPORT
APIENTRY
GetComputerDnsNameInternal( 
    WCHAR * pwcsMachineDnsName,
    DWORD * pcbSize
    )
{
    if (GetComputerNameEx(ComputerNameDnsFullyQualified,
						  pwcsMachineDnsName,
						  pcbSize))
    {
        CharLower(pwcsMachineDnsName);
        return MQ_OK;
    }
	TrERROR(GENERAL, "Failed to get computer DNS name, error %!winerr!", GetLastError());

    return MQ_ERROR;
} 


HRESULT GetThisServerIpPort( WCHAR * pwcsIpEp, DWORD dwSize)
{
    dwSize = dwSize * sizeof(WCHAR);
    DWORD  dwType = REG_SZ ;
    LONG res = GetFalconKeyValue( FALCON_DS_RPC_IP_PORT_REGNAME,
        &dwType,
        pwcsIpEp,
        &dwSize,
        FALCON_DEFAULT_DS_RPC_IP_PORT ) ;
    ASSERT(res == ERROR_SUCCESS) ;
	DBG_USED(res);

    return(MQ_OK);
}

/*====================================================

  MSMQGetOperatingSystem

=====================================================*/
extern "C" DWORD MQUTIL_EXPORT_IN_DEF_FILE APIENTRY MSMQGetOperatingSystem()
{
    HKEY  hKey ;
    DWORD dwOS = MSMQ_OS_NONE;
    WCHAR szNTType[32];

    LONG rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 L"System\\CurrentControlSet\\Control\\ProductOptions",
                           0L,
                           KEY_READ,
                           &hKey);
    if (rc == ERROR_SUCCESS)
    {
        DWORD dwNumBytes = sizeof(szNTType);
        rc = RegQueryValueEx(hKey, TEXT("ProductType"), NULL,
                                  NULL, (BYTE *)szNTType, &dwNumBytes);

        if (rc == ERROR_SUCCESS)
        {

            //
            // Determine whether Windows NT Server is running
            //
            if (_wcsicmp(szNTType, TEXT("SERVERNT")) != 0 &&
                _wcsicmp(szNTType, TEXT("LANMANNT")) != 0 &&
                _wcsicmp(szNTType, TEXT("LANSECNT")) != 0)
            {
                //
                // Windows NT Workstation
                //
                ASSERT (_wcsicmp(L"WinNT", szNTType) == 0);
                dwOS =  MSMQ_OS_NTW ;
            }
            else
            {
                //
                // Windows NT Server
                //
                dwOS = MSMQ_OS_NTS;
                //
                // Check if Enterprise Edition
                //
                BYTE  ch ;
                DWORD dwSize = sizeof(BYTE) ;
                DWORD dwType = REG_MULTI_SZ ;
                rc = RegQueryValueEx(hKey,
                                     L"ProductSuite",
                                     NULL,
                                     &dwType,
                                     (BYTE*)&ch,
                                     &dwSize) ;
                if (rc == ERROR_MORE_DATA)
                {
                    P<WCHAR> pBuf = new WCHAR[ dwSize + 2 ] ;
                    rc = RegQueryValueEx(hKey,
                                         L"ProductSuite",
                                         NULL,
                                         &dwType,
                                         (BYTE*) &pBuf[0],
                                         &dwSize) ;
                    if (rc == ERROR_SUCCESS)
                    {
                        //
                        // Look for the string "Enterprise".
                        // The REG_MULTI_SZ set of strings terminate with two
                        // nulls. This condition is checked in the "while".
                        //
                        WCHAR *pVal = pBuf ;
                        while(*pVal)
                        {
                            if (_wcsicmp(L"Enterprise", pVal) == 0)
                            {
                                dwOS = MSMQ_OS_NTE ;
                                break;
                            }
                            pVal = pVal + wcslen(pVal) + 1 ;
                        }
                    }
                }
            }
        }
        RegCloseKey(hKey);
    }

    return dwOS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\mqrpc.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
        mqrpc.c

Abstract:
        handle RPC common functions.

Autor:
        Doron Juster  (DoronJ)     13-may-1996

--*/

#include "stdh.h"
#include "_mqrpc.h"
#include "mqmacro.h"
#include <autorel2.h>
#include <mqsec.h>

#include "mqrpc.tmh"

static WCHAR *s_FN=L"mqsec/mqrpc";


extern bool g_fDebugRpc;


ULONG APIENTRY MQSec_RpcAuthnLevel()
/*++
Routine Description:
	Return RPC_C_AUTHN_LEVEL_PKT_* to use.
	default is the highest level - RPC_C_AUTHN_LEVEL_PKT_PRIVACY.
	If g_fDebugRpc is defined we go down to RPC_C_AUTHN_LEVEL_PKT_INTEGRITY.
	This is usually done for debugging purposes - if you want to see the network traffic unencrypted on the wire.

Arguments:
	None

Returned Value:
	RPC_C_AUTHN_LEVEL_PKT_ to use.

--*/
{
	if(g_fDebugRpc)
		return RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;

	return RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
}

//---------------------------------------------------------
//
//  static RPC_STATUS  _mqrpcBind()
//
//  Description:
//
//      Create a RPC binding handle.
//
//  Return Value:
//
//---------------------------------------------------------

static
RPC_STATUS
_mqrpcBind(
	TCHAR * pszNetworkAddress,
	TCHAR * pProtocol,
	LPWSTR    lpwzRpcPort,
	handle_t  *phBind
	)
{
    TCHAR * pszStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose(
    						NULL,
							pProtocol,
							pszNetworkAddress,
							lpwzRpcPort,
							NULL,
							&pszStringBinding
							);

    if (status != RPC_S_OK)
    {
		TrERROR(RPC, "RpcStringBindingCompose Failed: NetworkAddress = %ls, RpcPort = %ls, Protocol = %ls, status = %!status!", pszNetworkAddress, lpwzRpcPort, pProtocol, status);
		return status;
    }

    TrTRACE(RPC, "RpcStringBindingCompose for remote QM: (%ls)", pszStringBinding);

    status = RpcBindingFromStringBinding(pszStringBinding, phBind);
    TrTRACE(RPC, "RpcBindingFromStringBinding returned 0x%x", status);

    //
    // We don't need the string anymore.
    //
    RPC_STATUS  rc = RpcStringFree(&pszStringBinding);
    ASSERT(rc == RPC_S_OK);
	DBG_USED(rc);

    return status;
}

//+--------------------------------------------
//
//   RPC_STATUS _AddAuthentication()
//
//+--------------------------------------------

static
RPC_STATUS
_AddAuthentication(
	handle_t hBind,
	ULONG    ulAuthnSvcIn,
	ULONG    ulAuthnLevel
	)
{
    RPC_SECURITY_QOS   SecQOS;

    SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    //
    // #3117, for NT5 Beta2
    // Jul/16/1998 RaananH, added kerberos support
    // Jul-1999, DoronJ, add negotiation for remote read.
    //
    BOOL    fNeedDelegation = TRUE;
    ULONG   ulAuthnSvcEffective = ulAuthnSvcIn;
    LPWSTR  pwszPrincipalName = NULL;
    RPC_STATUS  status = RPC_S_OK;

	if (ulAuthnSvcIn != RPC_C_AUTHN_WINNT)
    {
        //
        // We want Kerberos. Let's see if we can obtain the
        // principal name of rpc server.
        //
        status = RpcMgmtInqServerPrincName(
					hBind,
					RPC_C_AUTHN_GSS_KERBEROS,
					&pwszPrincipalName
					);

        if (status == RPC_S_OK)
        {
            TrTRACE(RPC, "RpcMgmtInqServerPrincName() succeeded, %ls", pwszPrincipalName);
            if (ulAuthnSvcIn == MSMQ_AUTHN_NEGOTIATE)
            {
                //
                // remote read.
                // no need for delegation.
                //
                ulAuthnSvcEffective = RPC_C_AUTHN_GSS_KERBEROS;
                fNeedDelegation = FALSE;
            }
            else
            {
                ASSERT(ulAuthnSvcIn == RPC_C_AUTHN_GSS_KERBEROS);
            }
        }
        else
        {
            TrWARNING(RPC, "RpcMgmtInqServerPrincName() failed, status- %lut", status);
            if (ulAuthnSvcIn == MSMQ_AUTHN_NEGOTIATE)
            {
                //
                // server side does not support Kerberos.
                // Let's use ntlm.
                //
                ulAuthnSvcEffective = RPC_C_AUTHN_WINNT;
                status = RPC_S_OK;
            }
        }
    }

    if (status != RPC_S_OK)
    {
        //
        // Need Kerberos but failed with principal name.
        //
        ASSERT(ulAuthnSvcIn == RPC_C_AUTHN_GSS_KERBEROS);
        TrERROR(RPC, "Failed to set kerberos, status = %!status!", status);
        return status;
    }

    if (ulAuthnSvcEffective == RPC_C_AUTHN_GSS_KERBEROS)
    {
        if (fNeedDelegation)
        {
            SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;
            SecQOS.Capabilities |= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
	        TrTRACE(RPC, "Adding delegation");
        }

        //
        // ASSERT that for Kerberos we're using the highest level.
        //
        ASSERT(ulAuthnLevel == MQSec_RpcAuthnLevel());

        status = RpcBindingSetAuthInfoEx(
					hBind,
					pwszPrincipalName,
					ulAuthnLevel,
					RPC_C_AUTHN_GSS_KERBEROS,
					NULL,
					RPC_C_AUTHZ_NONE,
					&SecQOS
					);

        RpcStringFree(&pwszPrincipalName);

        if ((status != RPC_S_OK) && (ulAuthnSvcIn == MSMQ_AUTHN_NEGOTIATE))
        {
            //
            // I do not support Kerberos. for example- local user account
            // on win2k machine in win2k domain. Or nt4 user on similar
            // machine.  Let's use ntlm.
            //
	        TrWARNING(RPC, "RpcBindingSetAuthInfoEx(svc = %d, lvl = %d) failed, kerberos is not supported, will use NTLM, status = %!status!", ulAuthnSvcEffective, ulAuthnLevel, status);
            ulAuthnSvcEffective = RPC_C_AUTHN_WINNT;
            status = RPC_S_OK;
        }
    }

    if (ulAuthnSvcEffective == RPC_C_AUTHN_WINNT)
    {
        status = RpcBindingSetAuthInfoEx(
					hBind,
					0,
					ulAuthnLevel,
					RPC_C_AUTHN_WINNT,
					NULL,
					RPC_C_AUTHZ_NONE,
					&SecQOS
					);
    }

    if (status == RPC_S_OK)
    {
        TrTRACE(RPC, "RpcBindingSetAuthInfoEx(svc - %d, lvl - %d) succeeded", ulAuthnSvcEffective, ulAuthnLevel);
    }
    else
    {
        TrWARNING(RPC, "RpcBindingSetAuthInfoEx(svc - %d, lvl - %d) failed, status = %!status!", ulAuthnSvcEffective, ulAuthnLevel, status);
    }

    return status;
}

//---------------------------------------------------------
//
//  mqrpcBindQMService(...)
//
//  Description:
//
//      Create a RPC binding handle for interfacing with a remote
//      server machine.
//
//  Arguments:
//         OUT BOOL*  pProtocolNotSupported - on return, it's TRUE
//             if present protocol is not supported on LOCAL machine.
//
//         OUT BOOL*  pfWin95 - TRUE if remote machine is Win95.
//
//  Return Value:
//
//---------------------------------------------------------

HRESULT
MQUTIL_EXPORT
mqrpcBindQMService(
	IN  LPWSTR lpwzMachineName,
	IN  LPWSTR lpwzRpcPort,
	IN  OUT ULONG* peAuthnLevel,
	OUT handle_t* lphBind,
	IN  PORTTYPE PortType,
	IN  GetPort_ROUTINE pfnGetPort,
	IN  ULONG ulAuthnSvcIn
	)
{
    ASSERT(pfnGetPort);

    HRESULT hrInit = MQ_OK;
    TCHAR * pProtocol = RPC_TCPIP_NAME;
    BOOL    fWin95 = FALSE;

    *lphBind = NULL;

    handle_t hBind;
    RPC_STATUS status =  _mqrpcBind(
                                 lpwzMachineName,
                                 pProtocol,
                                 lpwzRpcPort,
                                 &hBind
                                 );

    if ((status == RPC_S_OK) && pfnGetPort)
    {
        //
        // Get the fix port from server side and crearte a rpc binding
        // handle for that port. If we're using fix ports only (debug
        // mode), then this call just check if other side exist.
        //

        DWORD dwPort = 0;

        //
        // the following is a rpc call cross network, so try/except guard
        // against net problem or unavailable server.
        //
        RpcTryExcept
        {
            dwPort = (*pfnGetPort) (hBind, PortType) ;
        }
		RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            //
            // Can't get server port, set authentication leve to NONE, to
            // disable next call with lower authentication level.
            //
			DWORD gle = RpcExceptionCode();
	        PRODUCE_RPC_ERROR_TRACING;
	        TrERROR(RPC, "Failed to Get server port, gle = %!winerr!", gle);

            *peAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;

			//
			// Don't overide EPT_S_NOT_REGISTERED error 
			// EPT_S_NOT_REGISTERED indicates that the interface is not register on the server.
			//
			status = gle;
			if(gle != EPT_S_NOT_REGISTERED)
			{
	            status =  RPC_S_SERVER_UNAVAILABLE;
			}
        }
		RpcEndExcept

        if (status == RPC_S_OK)
        {
            //
            // check machine type
            //
            fWin95 = !! (dwPort & PORTTYPE_WIN95);
            dwPort = dwPort & (~PORTTYPE_WIN95);
        }

        if (lpwzRpcPort == NULL)
        {
            //
            // We're using dynamic endpoints.  Free the dynamic binding handle
            // and create another one for the fix server port.
            //
            mqrpcUnbindQMService(&hBind, NULL);
            if (status == RPC_S_OK)
            {
                WCHAR wszPort[32];
                _itow(dwPort, wszPort, 10);
                status =  _mqrpcBind(
                              lpwzMachineName,
                              pProtocol,
                              wszPort,
                              &hBind
                              );
            }
            else
            {
                ASSERT(dwPort == 0);
            }
        }
        else if (status != RPC_S_OK)
        {
            //
            // We're using fix endpoints but other side is not reachable.
            // Release the binding handle.
            //
            mqrpcUnbindQMService(&hBind, NULL);
        }
    }

    if (status == RPC_S_OK)
    {
        //
        // Set authentication into the binding handle.
        //

        if (fWin95)
        {
            //
            // Win95 support only min level. change it.
            //
            *peAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
        }

        ULONG ulAuthnLevel = *peAuthnLevel;

        if (*peAuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
            status = _AddAuthentication(
						hBind,
						ulAuthnSvcIn,
						ulAuthnLevel
						);

            if (status != RPC_S_OK)
            {
                //
                // Release the binding handle.
                //
                mqrpcUnbindQMService(&hBind, NULL);

		        TrERROR(RPC, "Failed to add Authentication, ulAuthnSvcIn = %d, ulAuthnLevel = %d, status = %!status!", ulAuthnSvcIn, ulAuthnLevel, status);
                hrInit = MQ_ERROR;
            }
        }
    }

    if (status == RPC_S_OK)
    {
        *lphBind = hBind;
    }
    else if (status == RPC_S_PROTSEQ_NOT_SUPPORTED)
    {
        //
        // Protocol is not supported, set authentication leve to NONE, to
        // disable next call with lower authentication level.
        //
        *peAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
        hrInit = MQ_ERROR;
    }
    else if (status ==  RPC_S_SERVER_UNAVAILABLE)
    {
        hrInit = MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE;
    }
    else if (status == EPT_S_NOT_REGISTERED)
    {
        hrInit = HRESULT_FROM_WIN32(status);
    }
    else
    {
        hrInit = MQ_ERROR;
    }

    return hrInit;
}

//---------------------------------------------------------
//
//  mqrpcUnbindQMService(...)
//
//  Description:
//
//      Free RPC resources
//
//  Return Value:
//
//---------------------------------------------------------

HRESULT
MQUTIL_EXPORT
mqrpcUnbindQMService(
	IN handle_t*    lphBind,
	IN TBYTE      **lpwBindString
	)
{
    RPC_STATUS rc = 0;

    if (lpwBindString)
    {
       rc = RpcStringFree(lpwBindString);
       ASSERT(rc == 0);
    }

    if (lphBind && *lphBind)
    {
       rc = RpcBindingFree(lphBind);
       ASSERT(rc == 0);
    }

    return (HRESULT) rc;
}

//---------------------------------------------------------
//
//  mqrpcIsLocalCall( IN handle_t hBind )
//
//  Description:
//
//      On server side of RPC, check if RPC call is local
//      (i.e., using the lrpc protocol).
//      this is necessary both for licensing and for the
//      replication service. The replication service must
//      bypass several security restriction imposed by mqdssrv.
//      So mqdssrv let this bypass only if called localy.
//      Note- in MSMQ1.0, all replications were handled by the QM itself,
//      so there was no such problem. In MSMQ2.0, when running in mixed
//      mode, there is an independent service which handle MSMQ1.0
//      replication and it need "special" security handing.
//
//  Return Value: TRUE  if local call.
//                FALSE otherwise. FALSE is return even if there is a
//                      problem to determine whether the call is local
//                      or not.
//
//---------------------------------------------------------

BOOL
MQUTIL_EXPORT
mqrpcIsLocalCall(IN handle_t hBind)
{	
	UINT LocalFlag;
	RPC_STATUS Status = I_RpcBindingIsClientLocal(
							hBind,
							&LocalFlag
							);
	
	if((Status != RPC_S_OK) || !LocalFlag)
	{
		TrERROR(RPC, "Failed to verify local RPC, Status = %!winerr!", Status);
		return FALSE;
	}

	return TRUE;
}

BOOL
MQUTIL_EXPORT
mqrpcIsTcpipTransport(IN handle_t hBind)
{	
	UINT iTransport;
    RPC_STATUS Status = I_RpcBindingInqTransportType( 
    						hBind,
    						&iTransport);
    
    if ((Status != RPC_S_OK) || (iTransport != TRANSPORT_TYPE_CN))
    {
		TrERROR(RPC, "Failed to verify tcp-ip protocol, Status = %!winerr!", Status);
		return FALSE;
    }
	
	return TRUE;
}


unsigned long
MQUTIL_EXPORT
mqrpcGetLocalCallPID(IN handle_t hBind)
{	
	unsigned long PID;
	RPC_STATUS Status = I_RpcBindingInqLocalClientPID(
							hBind,
							&PID
							);
	
	if(Status != RPC_S_OK)
	{
		TrERROR(RPC, "Failed to verify local RPC PID, Status = %!winerr!", Status);
		return 0;
	}

	return PID;
}


VOID
MQUTIL_EXPORT
APIENTRY
ComposeRPCEndPointName(
	LPCWSTR pwszEndPoint,
	LPCWSTR pwszComputerName,
	LPWSTR * ppwzBuffer
	)
/*++

Routine Description:

    This routine generates the QM Local RPC endpoint name with the first two parameters,
    i.e. "(pwszEndPoint)$(pwszComputerName)".
    If pwszComputerName is NULL, the local machine Netbios name is used.

    This feature is to accommodate the need to communicate with the MSMQ QM in the virtual server
    in additional to the MSMQ QM locally.

Arguments:
    pwszEndPoint     - End point name
    pwszComputerName - Machine NetBios Name
    ppwszBuffer      - address of the pointer to the buffer which contains the null-terminated string
                       representation of an endpoint

Returned Value:
    None


--*/
{
    ASSERT(("must get a pointer", NULL != ppwzBuffer));

    LPWSTR pwszName = const_cast<LPWSTR>(g_wszMachineName);

    //
    // Use the pwszComputerName if not NULL
    //
    if(pwszComputerName)
    {
        pwszName = const_cast<LPWSTR>(pwszComputerName);
    }

    DWORD cbSize = sizeof(WCHAR) * (wcslen(pwszName) + wcslen(pwszEndPoint) + 5);
    *ppwzBuffer = new WCHAR[cbSize];

    wcscpy(*ppwzBuffer, pwszEndPoint);
    wcscat(*ppwzBuffer, L"$");
    wcscat(*ppwzBuffer, pwszName);


} //ComposeRPCEndPointName

//=------------------------------------------------------------------
//
// Windows bug 607793, add mutual authentication.
// Keep account name that run the msmq service.
//
AP<WCHAR> g_pwzLocalMsmqAccount = NULL ;
const LPWSTR x_lpwszSystemAccountName = L"NT Authority\\System" ;

//+----------------------------------------
//
//  void  _GetMsmqAccountName()
//
//+----------------------------------------

static void  _GetMsmqAccountNameInternal()
{
    CServiceHandle hServiceCtrlMgr( OpenSCManager(NULL, NULL, GENERIC_READ) ) ;
    if (hServiceCtrlMgr == NULL)
    {
		TrERROR(RPC, "failed to open SCM, err- %!winerr!", GetLastError()) ;
        return ;
    }

    CServiceHandle hService( OpenService( hServiceCtrlMgr,
                                          L"MSMQ",
                                          SERVICE_QUERY_CONFIG ) ) ;
    if (hService == NULL)
    {
		TrERROR(RPC, "failed to open Service, err- %!winerr!", GetLastError()) ;
        return ;
    }

    DWORD dwConfigLen = 0 ;
    BOOL bRet = QueryServiceConfig( hService, NULL, 0, &dwConfigLen) ;

    DWORD dwErr = GetLastError() ;
    if (bRet || (dwErr != ERROR_INSUFFICIENT_BUFFER))
    {
		TrERROR(RPC, "failed to QueryService, err- %!winerr!", dwErr) ;
        return ;
    }

    P<QUERY_SERVICE_CONFIG> pQueryData =
                 (QUERY_SERVICE_CONFIG *) new BYTE[ dwConfigLen ] ;

    bRet = QueryServiceConfig( hService,
                               pQueryData,
                               dwConfigLen,
                              &dwConfigLen ) ;
    if (!bRet)
    {
	    TrERROR(RPC,"failed to QueryService (2nd call), err- %!winerr!", GetLastError()) ;
    }

    LPWSTR lpName = pQueryData->lpServiceStartName ;
    if ((lpName == NULL) || (_wcsicmp(lpName, L"LocalSystem") == 0))
    {
        //
        // LocalSystem account.
        // This case is handled by the caller.
        //
    }
    else
    {
        g_pwzLocalMsmqAccount = new WCHAR[ wcslen(lpName) + 1 ] ;
        wcscpy(g_pwzLocalMsmqAccount, lpName) ;
    }
}

static void  _GetMsmqAccountName()
{
    static bool s_bMsmqAccountSet = false ;
    static CCriticalSection s_csAccount ;
    CS Lock(s_csAccount) ;

    if (s_bMsmqAccountSet)
    {
        return ;
    }

    _GetMsmqAccountNameInternal() ;

    if (g_pwzLocalMsmqAccount != NULL)
    {
        // done.
        //
	    TrTRACE(RPC, "msmq account name is- %ls", g_pwzLocalMsmqAccount) ;

        s_bMsmqAccountSet = true ;
        return ;
    }

    //
    // msmq service is running as LocalSystem account (or mqrt failed
    // to get the account name (whatever the reason) and then it
    // default to local system).
    // Convert system sid into account name.
    //
    PSID pSystemSid = MQSec_GetLocalSystemSid() ;

    DWORD cbName = 0 ;
    DWORD cbDomain = 0 ;
    SID_NAME_USE snUse ;
    AP<WCHAR> pwszName = NULL ;
    AP<WCHAR> pwszDomain = NULL ;
    BOOL bLookup = FALSE ;

    bLookup = LookupAccountSid( NULL,
                                pSystemSid,
                                NULL,
                               &cbName,
                                NULL,
                               &cbDomain,
                               &snUse ) ;
    if (!bLookup && (cbName != 0) && (cbDomain != 0))
    {
        pwszName = new WCHAR[ cbName ] ;
        pwszDomain = new WCHAR[ cbDomain ] ;

        DWORD cbNameTmp = cbName ;
        DWORD cbDomainTmp = cbDomain ;

        bLookup = LookupAccountSid( NULL,
                                    pSystemSid,
                                    pwszName,
                                   &cbNameTmp,
                                    pwszDomain,
                                   &cbDomainTmp,
                                   &snUse ) ;
    }

    if (bLookup)
    {
        //
        // both cbName and cbDomain include the null temrination.
        //
        g_pwzLocalMsmqAccount = new WCHAR[ cbName + cbDomain ] ;
        wcsncpy(g_pwzLocalMsmqAccount, pwszDomain, (cbDomain-1)) ;
        g_pwzLocalMsmqAccount[ cbDomain - 1 ] = 0 ;
        wcsncat(g_pwzLocalMsmqAccount, L"\\", 1) ;
        wcsncat(g_pwzLocalMsmqAccount, pwszName, cbName) ;
        g_pwzLocalMsmqAccount[ cbName + cbDomain - 1 ] = 0 ;
    }
    else
    {
        //
        // Everything failed...
        // As a last default, Let's use the English name of local
        // system account. If this default is not good, then rpc call
        // itself to local server will fail because mutual authentication
        // will fail, so there is no security risk here.
        //
    	TrERROR(RPC, "failed to LookupAccountSid, err- %!winerr!", GetLastError()) ;

        g_pwzLocalMsmqAccount = new
                     WCHAR[ wcslen(x_lpwszSystemAccountName) + 1 ] ;
        wcscpy(g_pwzLocalMsmqAccount, x_lpwszSystemAccountName) ;
    }

	TrTRACE(RPC, "msmq account name is- %ls", g_pwzLocalMsmqAccount) ;

    s_bMsmqAccountSet = true ;
}

//+----------------------------------------------------
//
// MQSec_SetLocalRpcMutualAuth( handle_t *phBind)
//
//  Windows bug 608356, add mutual authentication.
//  Add mutual authentication to local rpc handle.
//
//+----------------------------------------------------

RPC_STATUS APIENTRY
 MQSec_SetLocalRpcMutualAuth( handle_t *phBind )
{
    //
    // Windows bug 608356, add mutual authentication.
    //
    RPC_SECURITY_QOS   SecQOS;

    SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    _GetMsmqAccountName() ;
    ASSERT(g_pwzLocalMsmqAccount != NULL) ;

    RPC_STATUS rc = RpcBindingSetAuthInfoEx( *phBind,
                                   g_pwzLocalMsmqAccount,
                                   RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                   RPC_C_AUTHN_WINNT,
                                   NULL,
                                   RPC_C_AUTHZ_NONE,
                                  &SecQOS ) ;

    if (rc != RPC_S_OK)
    {
        ASSERT_BENIGN(rc == RPC_S_OK);
		TrERROR(RPC, "failed to SetAuth err- %!winerr!", rc) ;
    }

    return rc ;
}

void
MQUTIL_EXPORT
APIENTRY 
ProduceRPCErrorTracing(
	WCHAR *wszFileName, 
	DWORD dwLineNumber)
/*++
Routine Description:
	Produces tracing of the RPC error info 
	This function is called when an RPC exception occurs.

Arguments:
	None.
	
Returned Value:
	None

--*/
{
    RPC_STATUS Status;
    RPC_ERROR_ENUM_HANDLE EnumHandle;

	if (!WPP_LEVEL_COMPID_ENABLED(rsError, RPC))
	{
		return;
	}


	//
	// Enumarate the rpc error entries
	//
    Status = RpcErrorStartEnumeration(&EnumHandle);
    if (Status == RPC_S_ENTRY_NOT_FOUND)
    {
    	return;
    }    
    if (Status != RPC_S_OK)
    {
		TrERROR(RPC, "Call to RpcErrorStartEnumeration failed with status:%!status!",Status);
		return;
    }

	TrERROR(RPC, "DUMPING RPC EXCEPTION ERROR INFORMATION. (Called from File:%ls  Line:%d)", wszFileName, dwLineNumber);


	//
	// Loop and print out each error entry
	//
    RPC_EXTENDED_ERROR_INFO ErrorInfo;
    SYSTEMTIME *SystemTimeToUse;

    for (int index=1; Status == RPC_S_OK; index++)
    {
        ErrorInfo.Version = RPC_EEINFO_VERSION;
        ErrorInfo.Flags = 0;
        ErrorInfo.NumberOfParameters = 4;

        Status = RpcErrorGetNextRecord(&EnumHandle, FALSE, &ErrorInfo);
        if (Status == RPC_S_ENTRY_NOT_FOUND)
        {
        	break;
        }

        if (Status != RPC_S_OK)
        {
			TrERROR(RPC, "Call to RpcErrorGetNextRecord failed with status:%!status!",Status);
    	    break;
        }

		TrERROR(RPC, "RPC ERROR INFO RECORD:%d",index);
        if (ErrorInfo.ComputerName)
        {
			TrERROR(RPC, "RPC ERROR ComputerName is %ls",ErrorInfo.ComputerName);
        }

		TrERROR(RPC, "RPC ERROR ProcessID is %d",ErrorInfo.ProcessID);

        SystemTimeToUse = &ErrorInfo.u.SystemTime;
		TrERROR(RPC, "RPC ERROR System Time is: %d/%d/%d %d:%d:%d:%d", 
                    SystemTimeToUse->wMonth,
                    SystemTimeToUse->wDay,
                    SystemTimeToUse->wYear,
                    SystemTimeToUse->wHour,
                    SystemTimeToUse->wMinute,
                    SystemTimeToUse->wSecond,
                    SystemTimeToUse->wMilliseconds);

		TrERROR(RPC, "RPC ERROR Generating component is %d", ErrorInfo.GeneratingComponent);
		TrERROR(RPC, "RPC ERROR Status is %!status!", ErrorInfo.Status);
		TrERROR(RPC, "RPC ERROR Detection location is %d",(int)ErrorInfo.DetectionLocation);
		TrERROR(RPC, "RPC ERROR Flags is %d", ErrorInfo.Flags);
		TrERROR(RPC, "RPC ERROR ErrorInfo NumberOfParameters is %d", ErrorInfo.NumberOfParameters);
        for (int i = 0; i < ErrorInfo.NumberOfParameters; i ++)
        {
	        switch(ErrorInfo.Parameters[i].ParameterType)
            {
	            case eeptAnsiString:
					TrERROR(RPC, "RPC ERROR ErrorInfo Param %d: Ansi string: %s", i , ErrorInfo.Parameters[i].u.AnsiString);
    	            break;

                case eeptUnicodeString:
					TrERROR(RPC, "RPC ERROR ErrorInfo Param %d: Unicode string: %ls", i ,ErrorInfo.Parameters[i].u.UnicodeString);
                    break;

                case eeptLongVal:
					TrERROR(RPC, "RPC ERROR ErrorInfo Param %d: Long val: %d", i, ErrorInfo.Parameters[i].u.LVal);
                    break;

                case eeptShortVal:
					TrERROR(RPC, "RPC ERROR ErrorInfo Param %d: Short val: %d", i, (int)ErrorInfo.Parameters[i].u.SVal);
                    break;

                case eeptPointerVal:
					TrERROR(RPC, "RPC ERROR ErrorInfo Param %d: Pointer val: 0x%i64x", i, ErrorInfo.Parameters[i].u.PVal);
                    break;

                case eeptNone:
					TrERROR(RPC, "RPC ERROR ErrorInfo Param %d: Truncated", i);
                    break;

                default:
					TrERROR(RPC, "RPC ERROR ErrorInfo Param %d: Invalid type: %d", i, ErrorInfo.Parameters[i].ParameterType);
            }
        }
    }

    RpcErrorEndEnumeration(&EnumHandle);

	TrERROR(RPC, "END DUMPING RPC ERROR INFORMATION");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\bupdate.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    update.cpp

Abstract:

    DS Update Class Implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "stdh.h"
#include "mqprops.h"
#include "bupdate.h"
#include "mqcast.h"

#include "bupdate.tmh"

/*====================================================

UnalignedWcslen()

Arguments:

Return Value:

=====================================================*/
size_t  MQUTIL_EXPORT UnalignedWcslen (
        const wchar_t UNALIGNED * wcs
        )
{
        const wchar_t UNALIGNED *eos = wcs;

        while( *eos++ )
        {
            NULL;
        }

        return( (size_t)(eos - (const wchar_t UNALIGNED *)wcs - 1) );
}



/*====================================================

RoutineName
    CDSBaseUpdate::~CDSBaseUpdate()

Arguments:

Return Value:

Threads:RPC, Scheduler(send), Receive

=====================================================*/
CDSBaseUpdate::~CDSBaseUpdate()
{
    if ( m_fNeedRelease)
    {
        delete []m_pwcsPathName;
        if (m_aVar != NULL)
        {
            for (DWORD i=0; i<m_cp; i++)
            {
                DeleteProperty(m_aVar[i]);
            }
        }
    }
    delete m_pGuid;
    delete []m_aProp;
    delete []m_aVar;
}
/*====================================================

RoutineName
    CDSBaseUpdate::Init()

Arguments:

Return Value:

Threads:RPC
    Creates an update due to RPC from a client
    (CreateObject, DeleteObject, SetProps)
    or Scheduler wakes BuildSyncReplMsg() :
         Creates an updates because of Sync request received from network
=====================================================*/
HRESULT  CDSBaseUpdate::Init(
            IN  const GUID *    pguidMasterId,
            IN  const CSeqNum & sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
            IN  BOOL            fOriginatedByThisMaster,
            IN  unsigned char   bCommand,
            IN  DWORD           dwNeedCopy,
            IN  LPWSTR          pwcsPathName,
            IN  DWORD           cp,
            IN  PROPID*         aProp,
            IN  PROPVARIANT*    aVar)
{
    DWORD len;
    HRESULT status;

    //
    // limited by one byte
    //
    if (cp > 256 || aProp == NULL || aVar == NULL)
    {
        return(MQ_ERROR);   //bugbug find a better error code
    }

    m_bCommand  = bCommand;
    m_guidMasterId = *pguidMasterId;
    m_snPrev = snThisMasterIntersitePrevSeqNum;
    m_sn = sn;
	m_snPurge = snPurge;
    m_fOriginatedByThisMaster = fOriginatedByThisMaster;
    m_pwcsPathName = 0;
    m_aProp = 0;
    m_aVar = 0;

    m_cp = (unsigned char) cp;

    m_pGuid = 0;
    m_fUseGuid = FALSE;

    AP<PROPID> aProps = new PROPID[m_cp];
    memcpy(aProps,aProp,m_cp * sizeof(DWORD));

    AP<PROPVARIANT> aVars = new PROPVARIANT[m_cp];

    if (dwNeedCopy == UPDATE_COPY)
    {
        AP<WCHAR> aPathName = 0;
        //
        // Need to keep a copy of the information within the update instance
        // the call is due to API call (RPC from client)
        //
        if (pwcsPathName != NULL)
        {
            len = (wcslen(pwcsPathName) + 1);
            aPathName = new WCHAR[len];
            memcpy(aPathName,pwcsPathName,sizeof(WCHAR) * len);
        }

        for(DWORD i=0; i<m_cp; i++)
        {
            status = CopyProperty(aVar[i],&aVars[i]);
            if (FAILED(status))
            {
                return(status);
            }
        }
        m_fNeedRelease = TRUE;
        m_pwcsPathName = aPathName.detach();
    }
    else
    {
        //
        // There is NO need to keep a copy of values out of the PROPVARIANTs,
        // just to keep pointers to the data.
        //  the call is a result of Sync request received from network (Scheduler)
        // ( the data will be available until the object is destructed)
        //
        m_pwcsPathName = pwcsPathName;
        memcpy(aVars,aVar,m_cp * sizeof(PROPVARIANT));
        if ( dwNeedCopy ==  UPDATE_NO_COPY_NO_DELETE)
        {
            m_fNeedRelease = FALSE;
        }
        else
        {
            m_fNeedRelease = TRUE;
        }
    }

    m_aProp = aProps.detach();
    m_aVar = aVars.detach();
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::Init() - Initalizes object to use a guid as the key DB operations


Arguments:

Return Value:


=====================================================*/
HRESULT  CDSBaseUpdate::Init(
            IN  const GUID *    pguidMasterId,
            IN  const CSeqNum & sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
            IN  BOOL            fOriginatedByThisMaster,
            IN  unsigned char   bCommand,
            IN  DWORD           dwNeedCopy,
            IN  const GUID*     pguidIdentifier,
            IN  DWORD           cp,
            IN  PROPID*         aProp,
            IN  PROPVARIANT*    aVar)

{
    HRESULT hr = Init(pguidMasterId, sn, snThisMasterIntersitePrevSeqNum, snPurge, fOriginatedByThisMaster,
        bCommand,dwNeedCopy,(LPWSTR)NULL,cp,aProp,aVar);
    if (FAILED(hr))
    {
        return(hr);
    }

    m_fUseGuid = TRUE;

    m_pGuid = new GUID;
    //
    // When creating objects without pathname ( such as sitelink or user),
    //  both pathname and pguidId are NULL
    //
    if ( pguidIdentifier)
    {

        memcpy (m_pGuid,pguidIdentifier,sizeof(GUID));
    }
    else
    {
        if (!( (bCommand == DS_UPDATE_CREATE) &&
            ( (GetObjectType() == MQDS_USER) || (GetObjectType() == MQDS_SITELINK))))
        {
            ASSERT(0);
            return(MQ_ERROR);
        }
    }

    return MQ_OK;
}
/*====================================================

RoutineName
    CDSBaseUpdate::Init()

Arguments:
            IN  unsigned char *     pBuffer : stream of received bytes
            OUT DWORD *             pdwSize : # bytes in stream

Return Value:

Threads:Receive

(Create an update instance as a result of a received
stream of bytes)

=====================================================*/
HRESULT  CDSBaseUpdate::Init(
            IN  const unsigned char*    pBuffer,
            OUT DWORD *                 pdwSize,
            IN  BOOL                    fReplicationService )
{

    const unsigned char * ptr = pBuffer;
    DWORD size;
    HRESULT status;


    AP<WCHAR>   aPathName=0;
    P<GUID>     pGuid=0;
    m_fNeedRelease = TRUE;

    m_bCommand = *ptr++;

    m_fUseGuid = ((*ptr) == 1);
    ptr++;

    if (!m_fUseGuid)
    {
        size = sizeof(TCHAR) *
                 numeric_cast<DWORD>(UnalignedWcslen((const unsigned short *) (ptr)) + 1) ;
        aPathName =  new TCHAR[size];

        memcpy(aPathName,ptr,size);
        ptr += size;
    }
    else
    {
        pGuid = new GUID;

        memcpy (pGuid,ptr,sizeof(GUID));

        ptr += sizeof (GUID);
    };


    memcpy(&m_guidMasterId,ptr,sizeof(GUID));
    ptr+= sizeof(GUID);

    ptr+= m_snPrev.SetValue( ptr);

    ptr+= m_sn.SetValue( ptr);

    ptr+= m_snPurge.SetValue( ptr);

    //
    // The update is always built. No matter if its duplicated or out of sync
    //


    m_cp = *ptr++;
    DWORD dwCp = m_cp ;
    if (fReplicationService)
    {
        //
        // The replication service need two more properties, to include
        // the object guid (the one which come from the NT4/MQIS world) and
        // the masterID.
        // (note: We create objects in NT5 DS with our own guids, the ones
        //  which come from NT4 replication).
        // So here we allocate one more entry in the propvariant array and
        // it will be filled with the guid by the replication service code.
        // Note- this is not good C++ code. The replication service touch
        // internal data structure of this object. Better style would be
        // to have a member method like "SetGuid". However, it's more
        // efficient and avoid many changes in other pieces of code.
        //
#ifdef _DEBUG
        m_cpInc = TRUE ;
#endif
        dwCp += 2 ;
    }

    AP<PROPID> aProps = new PROPID[ dwCp ];

    memcpy(aProps,ptr,m_cp * sizeof(DWORD));
    ptr += m_cp * sizeof(DWORD);

    AP<PROPVARIANT> aVars = new PROPVARIANT[ dwCp ];

    for(DWORD i=0; i<m_cp; i++)
    {
        status = InitProperty(ptr,&size,aProps[i],aVars[i]);
        if (IS_ERROR(status))
        {
            return(status);
        }
        ptr += size;
    }

    *pdwSize = DWORD_PTR_TO_DWORD(ptr-pBuffer);

    m_pwcsPathName = aPathName.detach();
    m_aProp = aProps.detach();
    m_aVar = aVars.detach();
    m_pGuid = pGuid.detach();
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::Serialize()

Arguments:
            OUT unsigned char * pBuffer : stream of bytes to be filled
            OUT DWORD * pdwSize : stream size in bytes
            IN OUT DWORD *pdwThisSourcePrevSeqNum : in case we are the source,
                                                    update our PrevSeqNum

Return Value:

Threads:Scheduler

(create a stream of bytes out of an update instance
 in order to send it)

=====================================================*/
HRESULT CDSBaseUpdate::Serialize(
            OUT unsigned char * pBuffer,
            OUT DWORD * pdwSize,
            IN  BOOL    fInterSite)
{
    unsigned char * ptr = pBuffer;
    DWORD size;
    HRESULT status;


    *ptr++ = m_bCommand;

    *ptr++ = (unsigned char)((m_fUseGuid) ? 1 : 0);

    if (!m_fUseGuid)
    {
        size = sizeof(TCHAR) * (lstrlen(m_pwcsPathName) + 1);
        memcpy(ptr,m_pwcsPathName,size);
        ptr += size;
    }
    else
    {
        memcpy(ptr,m_pGuid,sizeof(GUID));
        ptr+=sizeof(GUID);
    };

    memcpy(ptr,&m_guidMasterId,sizeof(GUID));
    ptr+=sizeof(GUID);

    CSeqNum   snPrev;
    if (m_fOriginatedByThisMaster)
    {
        //
        // I am the originator, update created due to DS API
        //
        if ( fInterSite)
        {
            snPrev =  m_snPrev;
        }
        else
        {
            snPrev =  m_sn;
            snPrev.Decrement();
        }
    }
    else
    {
        //
        // I received it from another place, or as result of build sync reply,
        // keep previous seq num
        //
        snPrev = m_snPrev;
    }
    ptr += snPrev.Serialize( ptr);

    ptr += m_sn.Serialize( ptr);

    ptr += m_snPurge.Serialize( ptr);

    *ptr++ = m_cp;
    memcpy(ptr,m_aProp,m_cp * sizeof(DWORD));
    ptr += m_cp * sizeof(DWORD);



    for(DWORD i=0; i<m_cp; i++)
    {
        status = SerializeProperty(m_aVar[i],ptr,&size);
        if (IS_ERROR (status))
        {
            return(status);
        }
        ptr += size;
    }

    *pdwSize = DWORD_PTR_TO_DWORD(ptr-pBuffer);

    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::GetSerializeSize()

Arguments:

Return Value:

Threads:Scheduler

  Calculates size in bytes of stream needed to send
  this update

=====================================================*/
HRESULT CDSBaseUpdate::GetSerializeSize(
            OUT DWORD * pdwSize)
{
    DWORD size,TotalSize;
    HRESULT status;

    TotalSize =
            sizeof(m_bCommand)+sizeof(m_guidMasterId)+sizeof(m_cp)+ 1 + // 1 is for m_fUseGuid
            +m_snPrev.GetSerializeSize()+m_sn.GetSerializeSize()+m_snPurge.GetSerializeSize()+
            m_cp * sizeof(DWORD);


    if (!m_fUseGuid)
    {
        TotalSize+=sizeof(TCHAR) * (lstrlen(m_pwcsPathName) + 1);   // m_wcsPathName
    }
    else
    {
        TotalSize+=sizeof(GUID);
    };

    for(DWORD i=0; i<m_cp; i++)
    {
        status = SerializeProperty(m_aVar[i],NULL,&size);
        if (IS_ERROR (status))
        {
            return(status);
        }
        TotalSize += size;
    }

    *pdwSize = TotalSize;

    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::SerializeProperty()

Arguments:

Return Value:

Threads:Scheduler

(create a stream of bytes out of a property of
 an update instance)

=====================================================*/
HRESULT CDSBaseUpdate::SerializeProperty(
            IN  PROPVARIANT&    Var,
            OUT unsigned char * pBuffer,
            OUT DWORD *         pdwSize)

{
    DWORD i,size;
    unsigned char * ptr;

    switch (Var.vt)
    {
        case VT_UI1:

            if (pBuffer != NULL)
            {
                *pBuffer = Var.bVal;
            }
            *pdwSize = 1;
            break;

        case VT_I2:
        case VT_UI2:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.iVal,sizeof(WORD));
            }
            *pdwSize = sizeof(WORD);
            break;

        case VT_UI4:
		case VT_I4:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.lVal,sizeof(DWORD));
            }
            *pdwSize = sizeof(DWORD);
            break;

        case VT_CLSID:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,Var.puuid,sizeof(GUID));
            }
            *pdwSize = sizeof(GUID);
            break;

        case VT_LPWSTR:

            *pdwSize = (wcslen(Var.pwszVal) + 1) * sizeof(WCHAR);
            if (pBuffer != NULL)
            {
                memcpy(pBuffer,Var.pwszVal,*pdwSize);
            }
            break;

        case VT_BLOB:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.blob.cbSize,sizeof(DWORD));
                memcpy(pBuffer+sizeof(DWORD),Var.blob.pBlobData,Var.blob.cbSize);
            }
            *pdwSize = Var.blob.cbSize + sizeof(DWORD);
            break;

        case VT_UI4|VT_VECTOR:
            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.caul.cElems ,sizeof(DWORD));
                if (Var.caul.cElems != 0)
                {
                    memcpy(pBuffer+sizeof(DWORD),Var.caul.pElems,Var.caul.cElems * sizeof(DWORD));
                }
            }
            *pdwSize = Var.caul.cElems * sizeof(DWORD) + sizeof(DWORD);
            break;

        case VT_CLSID|VT_VECTOR:
            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.cauuid.cElems ,sizeof(DWORD));
                if (Var.cauuid.cElems != 0)
                {
                    memcpy(pBuffer+sizeof(DWORD),Var.cauuid.pElems,Var.cauuid.cElems * sizeof(GUID));
                }
            }
            *pdwSize = Var.cauuid.cElems * sizeof(GUID) + sizeof(DWORD);
            break;

        case VT_LPWSTR|VT_VECTOR:
            ptr = pBuffer;
            if (pBuffer != NULL)
            {
                memcpy(ptr,&Var.calpwstr.cElems,sizeof(DWORD));
            }
            ptr+=sizeof(DWORD);
            for (i= 0; i < Var.calpwstr.cElems; i++)
            {
                size = (wcslen(Var.calpwstr.pElems[i]) + 1) * sizeof(WCHAR);
                if (pBuffer != NULL)
                {
                    memcpy(ptr,Var.calpwstr.pElems[i],size);
                }
                ptr += size;
            }
            *pdwSize = DWORD_PTR_TO_DWORD(ptr-pBuffer);
            break;

        default:
            return(MQ_ERROR);   // bugbug find better error code
    }
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::InitProperty()

Arguments:

Return Value:

Threads:Receive

(Create a property of an update instance
 as a result of a received stream of bytes)
=====================================================*/
HRESULT CDSBaseUpdate::InitProperty(
            IN  const unsigned char *   pBuffer,
            OUT DWORD *                 pdwSize,
            IN  PROPID                  PropId,
            OUT PROPVARIANT&            Var)

{
    DWORD len;

    memset(&Var,0,sizeof(PROPVARIANT));

    switch (PropId)
    {
        //VT_UI1
        case PROPID_Q_SCOPE:
        case PROPID_D_SCOPE:
        case PROPID_D_OBJTYPE:
        case PROPID_CN_PROTOCOLID:
        case PROPID_E_NAMESTYLE:
        case PROPID_Q_JOURNAL:
        case PROPID_Q_AUTHENTICATE:
        case PROPID_Q_TRANSACTION:
        case PROPID_QM_FOREIGN:
        case PROPID_QM_SERVICE_ROUTING:
        case PROPID_QM_SERVICE_DSSERVER:
        case PROPID_QM_SERVICE_DEPCLIENTS:

            Var.bVal = *pBuffer;
            Var.vt = VT_UI1;
            *pdwSize = 1;
            break;

        //VT_I2
        case PROPID_Q_BASEPRIORITY:

            Var.vt = VT_I2;
            memcpy(&Var.iVal,pBuffer,sizeof(SHORT));
            *pdwSize = sizeof(SHORT);
            break;

        //VT_UI2
        case PROPID_S_INTERVAL1:
        case PROPID_S_INTERVAL2:
        case PROPID_E_S_INTERVAL1:
        case PROPID_E_S_INTERVAL2:
        case PROPID_E_VERSION:

            Var.vt = VT_UI2;
            memcpy(&Var.iVal,pBuffer,sizeof(WORD));
            *pdwSize = sizeof(WORD);
            break;

        //VT_I4
        case PROPID_Q_CREATE_TIME:
        case PROPID_Q_MODIFY_TIME:
        case PROPID_QM_CREATE_TIME:
        case PROPID_QM_MODIFY_TIME:

            Var.vt = VT_I4;
            memcpy(&Var.lVal,pBuffer,sizeof(long));
            *pdwSize = sizeof(long);
            break;

        //VT_UI4
        case PROPID_Q_QUOTA:
        case PROPID_Q_HASHKEY:
        case PROPID_Q_JOURNAL_QUOTA:
        case PROPID_Q_PRIV_LEVEL:
        case PROPID_Q_LABEL_HASHKEY:
        case PROPID_QM_SERVICE:
        case PROPID_QM_HASHKEY:
        case PROPID_QM_QUOTA:
        case PROPID_QM_JOURNAL_QUOTA:
        case PROPID_QM_OS:
        case PROPID_E_CSP_TYPE:
        case PROPID_E_ENCRYPT_ALG:
        case PROPID_E_SIGN_ALG:
        case PROPID_E_HASH_ALG:
        case PROPID_E_CIPHER_MODE:
        case PROPID_E_LONG_LIVE:
        case PROPID_L_COST:

            Var.vt = VT_UI4;
            memcpy(&Var.ulVal,pBuffer,sizeof(DWORD));
            *pdwSize = sizeof(DWORD);
            break;


        //VT_CLSID
        case PROPID_Q_INSTANCE:
        case PROPID_Q_TYPE:
        case PROPID_Q_QMID:
        case PROPID_Q_MASTERID:
        case PROPID_QM_SITE_ID:
        case PROPID_QM_MACHINE_ID:
        case PROPID_QM_MASTERID:
        case PROPID_S_SITEID:
        case PROPID_S_MASTERID:
        case PROPID_D_MASTERID:
        case PROPID_D_IDENTIFIER:
        case PROPID_CN_GUID:
        case PROPID_CN_MASTERID:
        case PROPID_E_MASTERID:
        case PROPID_E_ID:
        case PROPID_U_ID:
        case PROPID_U_DIGEST:
        case PROPID_U_MASTERID:
        case PROPID_L_MASTERID:
        case PROPID_L_ID:
        case PROPID_L_NEIGHBOR1:
        case PROPID_L_NEIGHBOR2:

            Var.vt = VT_CLSID;
            Var.puuid = new CLSID;

            memcpy(Var.puuid,pBuffer,sizeof(GUID));
            *pdwSize = sizeof(GUID);
            break;

        //VT_LPWSTR
        case PROPID_Q_LABEL:
        case PROPID_QM_PATHNAME:
        case PROPID_QM_MACHINE_TYPE:
        case PROPID_S_PATHNAME:
        case PROPID_S_PSC:
        case PROPID_Q_PATHNAME:
        case PROPID_CN_NAME:
        case PROPID_E_NAME:
        case PROPID_E_CSP_NAME:
        case PROPID_E_PECNAME:

            Var.vt = VT_LPWSTR;
            len = numeric_cast<DWORD>(UnalignedWcslen((const unsigned short *)pBuffer) + 1);
            Var.pwszVal = new WCHAR[ len];
            *pdwSize = len * sizeof(WCHAR);
            memcpy(Var.pwszVal,pBuffer,*pdwSize);
            break;

        //VT_BLOB
        case PROPID_QM_ADDRESS:
        case PROPID_Q_SECURITY:
        case PROPID_E_SECURITY:
        case PROPID_QM_SECURITY:
        case PROPID_S_SECURITY:
		case PROPID_S_PSC_SIGNPK:
        case PROPID_CN_SECURITY:
        case PROPID_QM_SIGN_PK:
        case PROPID_QM_ENCRYPT_PK:
        case PROPID_E_CRL:
        case PROPID_U_SIGN_CERT:
        case PROPID_U_SID:
        case PROPID_Q_SEQNUM:
        case PROPID_QM_SEQNUM:
        case PROPID_S_SEQNUM:
        case PROPID_D_SEQNUM:
        case PROPID_CN_SEQNUM:
        case PROPID_E_SEQNUM:
        case PROPID_U_SEQNUM:
        case PROPID_L_SEQNUM:

            Var.vt = VT_BLOB;
            memcpy(&Var.blob.cbSize,pBuffer,sizeof(DWORD));
            if (Var.blob.cbSize != 0)
            {
                Var.blob.pBlobData = new BYTE __RPC_FAR[Var.blob.cbSize];
                memcpy(Var.blob.pBlobData,pBuffer+sizeof(DWORD),Var.blob.cbSize);
            }
            else
            {
                Var.blob.pBlobData = NULL;
            }
            *pdwSize = Var.blob.cbSize + sizeof(DWORD);
            break;

        //VT_CLSID|VT_VECTOR
        case PROPID_QM_CNS:
        case PROPID_QM_OUTFRS:
        case PROPID_QM_INFRS:
        case PROPID_S_GATES:

            Var.vt = VT_CLSID | VT_VECTOR;
            memcpy(&Var.cauuid.cElems ,pBuffer,sizeof(DWORD));
            if (Var.cauuid.cElems != 0)
            {
                Var.cauuid.pElems = new GUID[Var.cauuid.cElems];
                memcpy(Var.cauuid.pElems,pBuffer+sizeof(DWORD),Var.cauuid.cElems * sizeof(GUID));
            }
            else
            {
                Var.cauuid.pElems = NULL;
            }
            *pdwSize = Var.cauuid.cElems * sizeof(GUID) + sizeof(DWORD);
            break;

        default:
            return(MQ_ERROR);   // bugbug find better error code
    }
    return(MQ_OK);

}

/*====================================================

RoutineName
    CDSBaseUpdate::CopyProperty()

Arguments:

Return Value:

Threads:RPC

=====================================================*/
HRESULT CDSBaseUpdate::CopyProperty(
            IN  PROPVARIANT&    SrcVar,
            IN  PROPVARIANT*    pDstVar)

{
    DWORD len;

    memset(pDstVar,0,sizeof(PROPVARIANT));
    pDstVar->vt = SrcVar.vt;

    switch (SrcVar.vt)
    {
        case VT_UI1:

            pDstVar->bVal = SrcVar.bVal;
            break;

        case VT_I2:
        case VT_UI2:

            pDstVar->iVal = SrcVar.iVal;
            break;

        case VT_UI4:
		case VT_I4:

            pDstVar->ulVal = SrcVar.ulVal;
            break;

        case VT_CLSID:

            pDstVar->puuid = new GUID;
            memcpy(pDstVar->puuid,SrcVar.puuid,sizeof(GUID));
            break;

        case VT_LPWSTR:

            len = (wcslen(SrcVar.pwszVal)+1);
            pDstVar->pwszVal = new WCHAR[len];
            memcpy(pDstVar->pwszVal,SrcVar.pwszVal,len*sizeof(WCHAR));
            break;

        case VT_BLOB:
            pDstVar->blob.cbSize = SrcVar.blob.cbSize;
            if (SrcVar.blob.cbSize != 0)
            {
                pDstVar->blob.pBlobData = new BYTE __RPC_FAR[SrcVar.blob.cbSize];

                memcpy(pDstVar->blob.pBlobData,SrcVar.blob.pBlobData,SrcVar.blob.cbSize);
            }
            else
            {
                pDstVar->blob.pBlobData = NULL;
            }
            break;

        case VT_UI4|VT_VECTOR:

            pDstVar->caul.cElems = SrcVar.caul.cElems;
            if (SrcVar.caul.cElems != 0)
            {
                pDstVar->caul.pElems = new DWORD[SrcVar.caul.cElems];
                memcpy(pDstVar->caul.pElems,SrcVar.caul.pElems,SrcVar.caul.cElems * sizeof(DWORD));
            }
            else
            {
                pDstVar->caul.pElems = NULL;
            }
            break;

        case VT_CLSID|VT_VECTOR:

            pDstVar->cauuid.cElems = SrcVar.cauuid.cElems;
            if (SrcVar.cauuid.cElems != 0)
            {
                pDstVar->cauuid.pElems = new GUID[SrcVar.cauuid.cElems];
                memcpy(pDstVar->cauuid.pElems,SrcVar.cauuid.pElems,SrcVar.cauuid.cElems * sizeof(GUID));
            }
            else
            {
                pDstVar->cauuid.pElems = NULL;
            }
            break;


        default:
            return(MQ_ERROR);   // bugbug find better error code
    }
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::DeleteProperty()

Arguments:

Return Value:

Threads:RPC, Scheduler(send), Receive

=====================================================*/
void    CDSBaseUpdate::DeleteProperty(
            IN  PROPVARIANT&    Var)

{
    switch (Var.vt)
    {
        DWORD i;

        case VT_CLSID:

                delete Var.puuid;
                break;

        case VT_LPWSTR:

                delete []Var.pwszVal;
                break;

        case VT_BLOB:
                delete []Var.blob.pBlobData;
                break;

        case (VT_UI4|VT_VECTOR):

                delete []Var.caul.pElems;
                break;

        case (VT_CLSID|VT_VECTOR):

                delete []Var.cauuid.pElems;
                break;

        case (VT_LPWSTR|VT_VECTOR):

            for (i= 0; i < Var.calpwstr.cElems; i++)
            {
                delete[] Var.calpwstr.pElems[i];
            }
            delete []Var.calpwstr.pElems;

            break;

        default:
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\stdh.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: stdh.h

Abstract: Generic header file for utility code

Author: Doron Juster  (DoronJ)  24-May-1998

--*/

#ifndef __SEC_STDH_UT_H
#define __SEC_STDH_UT_H

#include <_stdh.h>
#include <mqutil.h>
extern HINSTANCE g_hInstance;
extern void XactFreeDTC(void);
extern LPCWSTR g_wszMachineName;

#endif // __SEC_STDH_UT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\report.cpp ===
/////////////////////////////////////////////////////////////////////
//
//               File : report.cpp
//
//   NOTE: DllMain is at the end of the module
//////////////////////////////////////////////////////////////////////


#include "stdh.h"
#include <_registr.h>

#include "report.tmh"


//
// Declare an Object of the report-class.
//
// Only one object is declared per process. In no other module should there be another declaration of an
// object of this class.
//
DLL_EXPORT COutputReport Report;


//
// implementation of class COutputReport
//

///////////////////////////////////////////////////////////////
//
// Constructor - COutputReport::COutputReport
//
///////////////////////////////////////////////////////////////

COutputReport::COutputReport(void)
{
    m_dwCurErrorHistoryIndex = 0;              // Initial history cell to use
    strcpy(m_HistorySignature, "MSMQERR");      // Signature for lookup in dump
        
}

//+---------------------------------------------------------
//
//  void COutputReport::KeepErrorHistory()
//
// Keeps error data in the array for future investigations
//
//+---------------------------------------------------------

void
COutputReport::KeepErrorHistory(
	LPCWSTR pFileName,
	USHORT usPoint, 
	LONG status
	)
{
    CS lock(m_LogCS) ;
    DWORD i = m_dwCurErrorHistoryIndex % ERROR_HISTORY_SIZE;

    m_ErrorHistory[i].m_tid = GetCurrentThreadId(); 
    m_ErrorHistory[i].m_status = status;
    m_ErrorHistory[i].m_usPoint = usPoint;
    m_ErrorHistory[i].m_pFileName = pFileName;
            
    ++m_dwCurErrorHistoryIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\register.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
        register.c

Abstract:
        handle registery

Autor:
        Uri Habusha

--*/


//
// NOTE: registry routines in mqutil do not provide
// thread or other synchronization. If you change
// implementation here, carefully verify that
// registry routines in mqutil's clients are not
// broken, especially the wrapper routines in
// mqclus.dll  (ShaiK, 19-Apr-1999)
//


#include "stdh.h"
#include <autorel.h>
#include <uniansi.h>
#include <_mqreg.h>
#include <_registr.h>
#include <strsafe.h>

#include "register.tmh"

template<>
void AFXAPI DestructElements(HKEY *phKey, int nCount)
{
    for (; nCount--; phKey++)
    {
        RegCloseKey(*phKey);
    }
}

TCHAR g_tRegKeyName[ 256 ] = {0} ;
CAutoCloseRegHandle g_hKeyFalcon = NULL ;
static CMap<LPCWSTR, LPCWSTR, HKEY, HKEY&> s_MapName2Handle;
static CCriticalSection s_csMapName2Handle(CCriticalSection::xAllocateSpinCount);


/*====================================================

CompareElements  of LPCTSTR

Arguments:

Return Value:

=====================================================*/
template<>
BOOL AFXAPI CompareElements(const LPCTSTR* MapName1, const LPCTSTR* MapName2)
{

    return (_tcscmp(*MapName1, *MapName2) == 0);

}

/*====================================================

DestructElements of LPCTSTR

Arguments:

Return Value:

=====================================================*/
template<>
void AFXAPI DestructElements(LPCTSTR* ppNextHop, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete [] (WCHAR*) *ppNextHop++;

}

/*====================================================

hash key  of LPCTSTR

Arguments:

Return Value:


=====================================================*/
template<>
UINT AFXAPI HashKey(LPCTSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

//-------------------------------------------------------
//
//  GetFalconSectionName
//
//-------------------------------------------------------
LPCWSTR
MQUTIL_EXPORT
APIENTRY
GetFalconSectionName(
    VOID
    )
{
    ASSERT(g_tRegKeyName[0] != L'\0');
    return g_tRegKeyName;
}



//
// Registry section of MSMQ is based on the service name.
// This allows multiple QMs to live on same machine, each
// with its own registry section. (ShaiK)
//


//
// The size of 300 is from the size of the member m_wzFalconRegSection
// in the CQmResource
//
static WCHAR s_wzServiceName[300] = {QM_DEFAULT_SERVICE_NAME};

DWORD
MQUTIL_EXPORT
APIENTRY
GetFalconServiceName(
    LPWSTR pwzServiceNameBuff,
    DWORD dwServiceNameBuffLen
    )
{
    ASSERT(("must point to a valid buffer", NULL != pwzServiceNameBuff));

    DWORD dwLen = wcslen(s_wzServiceName);

    ASSERT(("out buffer too small!", dwLen < dwServiceNameBuffLen));
    if (dwLen < dwServiceNameBuffLen)
    {
        HRESULT hr = StringCchCopy(pwzServiceNameBuff, dwServiceNameBuffLen, s_wzServiceName);
        ASSERT(SUCCEEDED(hr));
        DBG_USED(hr);
    }

    return(dwLen);

} //GetFalconServiceName


VOID
MQUTIL_EXPORT
APIENTRY
SetFalconServiceName(
    LPCWSTR pwzServiceName
    )
{
    ASSERT(("must get a valid service name", NULL != pwzServiceName));

    HRESULT hr = StringCchCopy(s_wzServiceName, TABLE_SIZE(s_wzServiceName), pwzServiceName);
    ASSERT(("service name too big", SUCCEEDED(hr)));
    DBG_USED(hr);

    //
    // Null the global registry handle so that it'd be reopened in the
    // registry section suitable for this service  (multiple QMs).
    // Note: if synchronization needed caller should provide it. (ShaiK)
    //
    if (g_hKeyFalcon)
    {
        RegCloseKey(g_hKeyFalcon) ;
    }
    g_hKeyFalcon = NULL;
    
    {
        CS lock(s_csMapName2Handle);
        s_MapName2Handle.RemoveAll();
    }


} //SetFalconServiceName


//-------------------------------------------------------
//
//  LONG OpenFalconKey(void)
//
//-------------------------------------------------------
LONG OpenFalconKey(void)
{
    LONG rc;
    WCHAR szServiceName[300] = QM_DEFAULT_SERVICE_NAME;

    HRESULT hr = StringCchCopy(g_tRegKeyName, TABLE_SIZE(g_tRegKeyName), FALCON_REG_KEY);
    ASSERT(SUCCEEDED(hr));

    GetFalconServiceName(szServiceName, TABLE_SIZE(szServiceName));
    if (0 != CompareStringsNoCase(szServiceName, QM_DEFAULT_SERVICE_NAME))
    {
        //
        // Multiple QMs environment. I am a clustered QM !
        //
		hr = StringCchCopy(g_tRegKeyName, TABLE_SIZE(g_tRegKeyName), FALCON_CLUSTERED_QMS_REG_KEY);
	    ASSERT(SUCCEEDED(hr));
		hr = StringCchCat(g_tRegKeyName, TABLE_SIZE(g_tRegKeyName), szServiceName);
	    ASSERT(SUCCEEDED(hr));
		hr = StringCchCat(g_tRegKeyName, TABLE_SIZE(g_tRegKeyName), FALCON_REG_KEY_PARAM);
	    ASSERT(SUCCEEDED(hr));
    }

    rc = RegOpenKeyEx (FALCON_REG_POS,
                       g_tRegKeyName,
                       0L,
                       KEY_READ | KEY_WRITE,
                       &g_hKeyFalcon);

    if (rc != ERROR_SUCCESS)
    {
        rc = RegOpenKeyEx (FALCON_REG_POS,
                           g_tRegKeyName,
                           0L,
                           KEY_READ,
                           &g_hKeyFalcon);
    }

	//
	// temporary remove the assert because if causes trap in 
	// sysocmgr launch
	// Will put it back in when we make mqutil as resource 
	// only dll
	// 
	//
    // ASSERT(rc == ERROR_SUCCESS);

    return rc;
}

/*=============================================================

  FUNCTION:  GetValueKey

  the function returns an handle to open key and the value name.
  If the use value name contains a sub key, it create/open it and returns
  an handle to the subkey; otherwise an handel to Falcon key is returned.

  PARAMETERS:
     pszValueName - Input, user value name. can contain a sub key

     pszValue - pointer to null terminated string contains the value name.

     hKey - pointer to key handle

================================================================*/

LONG GetValueKey(IN LPCTSTR pszValueName,
                 OUT LPCTSTR* lplpszValue,
                 OUT HKEY* phKey)
{
    *lplpszValue = pszValueName;
    LONG rc = ERROR_SUCCESS;

    //
    // Open Falcon key, if it hasn't opened yet.
    //
    if (g_hKeyFalcon == NULL)
    {
        rc = OpenFalconKey();
        if ( rc != ERROR_SUCCESS)
        {
            return rc;
        }
    }

    *phKey = g_hKeyFalcon;

    // look for a sub key
    LPCWSTR lpcsTemp = wcschr(pszValueName,L'\\');
    if (lpcsTemp != NULL)
    {
        // Sub key is exist
        DWORD dwDisposition;

        // update the return val
        *lplpszValue = lpcsTemp +1;

        AP<WCHAR> KeyName = new WCHAR[(lpcsTemp - pszValueName) + 1];
        wcsncpy(KeyName, pszValueName, (lpcsTemp - pszValueName));
        KeyName[(lpcsTemp - pszValueName)] = L'\0';

        // Check if the key already opened
        BOOL rc1;
        {
            CS lock(s_csMapName2Handle);
            rc1 = s_MapName2Handle.Lookup(KeyName, *phKey);
        }
        if (!rc1)
        {
            rc = RegCreateKeyEx (g_hKeyFalcon,
                               KeyName,
                               0L,
                               L"",
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               phKey,
                               &dwDisposition);

            if (rc != ERROR_SUCCESS)
            {
                rc = RegCreateKeyEx (g_hKeyFalcon,
                                   KeyName,
                                   0L,
                                   L"",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_READ,
                                   NULL,
                                   phKey,
                                   &dwDisposition);
            }

            if (rc == ERROR_SUCCESS)
            {
                // save the handle in hash
                {
                    CS lock(s_csMapName2Handle);
                    s_MapName2Handle[KeyName] = *phKey;
                }
                KeyName.detach();
            }
            else
            {
		DWORD gle = GetLastError();
		TrERROR(GENERAL,"GetValueKey - RegCreateKeyEx failed %!winerr!",gle);
            }
        }
    }

    return rc;

}

//-------------------------------------------------------
//
//  GetFalconKey
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
GetFalconKey(LPCWSTR  pszKeyName,
             HKEY *phKey)
{
	DWORD dwLen = wcslen(pszKeyName) + 2;
    AP<WCHAR> szValueKey = new WCHAR[dwLen];
    LPCWSTR szValue;

	HRESULT hr = StringCchCopy(szValueKey, dwLen, pszKeyName);
    ASSERT(SUCCEEDED(hr));
	hr = StringCchCat(szValueKey, dwLen, TEXT("\\"));
    ASSERT(SUCCEEDED(hr));

    return GetValueKey(szValueKey, &szValue, phKey);
}

//-------------------------------------------------------
//
//  GetFalconKeyValue
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
APIENTRY
GetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    PVOID   pData,
    PDWORD  pdwSize,
    LPCTSTR pszDefValue
    )
{
    //
    // NOTE: registry routines in mqutil do not provide
    // thread or other synchronization. If you change
    // implementation here, carefully verify that
    // registry routines in mqutil's clients are not
    // broken, especially the wrapper routines in
    // mqclus.dll  (ShaiK, 19-Apr-1999)
    //

    LONG rc;
    HKEY hKey;
    LPCWSTR lpcsValName;

    ASSERT(pdwSize != NULL);

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if (rc != ERROR_SUCCESS)
    {
        return rc;
    }

    DWORD dwTempType;

    rc = RegQueryValueEx( hKey,
                      lpcsValName,
                      0L,
                      &dwTempType,
                      static_cast<BYTE*>(pData),
                      pdwSize ) ;

	if ((rc == ERROR_SUCCESS) && (pdwType != NULL) && (*pdwType != dwTempType))
	{
		ASSERT(("RegQueryValueEx returned mismatch Registry Value Type",0));
		rc = ERROR_INVALID_PARAMETER;
	}

	//
	// Check if strings is NULL terminated
	//
    if ((rc == ERROR_SUCCESS) &&
    	//
    	// & it is one of the string types
    	//
    	((REG_SZ == dwTempType) ||
    	 (REG_MULTI_SZ  == dwTempType) ||
    	 (REG_EXPAND_SZ == dwTempType)) &&
		//
		// & a buffer was supplied
		//
		(pData != NULL) &&
    	//
    	// & it is not NULL terminated
    	//
		(((WCHAR*)pData)[((*pdwSize)/sizeof(WCHAR))-1] != NULL))
	{
		ASSERT(("RegQueryValueEx returned string which is not NULL terminated",0));
		rc = ERROR_BAD_LENGTH;
	}

    if (rc == ERROR_SUCCESS)
    {
        return rc;
    }

	if (pszDefValue != NULL)
	{
		ASSERT (pData != NULL);
		if ((rc != ERROR_MORE_DATA) && pdwType && (*pdwType == REG_SZ))
		{
		  // Don't use the default if caller buffer was too small for
		  // value in registry.
		  if ((DWORD) wcslen(pszDefValue) < *pdwSize)
		  {
				HRESULT hr = StringCchCopy((WCHAR*) pData, *pdwSize, pszDefValue);
				ASSERT(SUCCEEDED(hr));
		        DBG_USED(hr);
				return ERROR_SUCCESS ;
		  }
		}
		if (*pdwType == REG_DWORD)
		{
				*((DWORD *)pData) = *((DWORD *) pszDefValue) ;
				return ERROR_SUCCESS ;
		}
	}

    return rc;
}



//-------------------------------------------------------
//
//  SetFalconKeyValue
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
APIENTRY
SetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    const VOID * pData,
    PDWORD  pdwSize
    )
{
    ASSERT(pData != NULL);
    ASSERT(pdwSize != NULL);

    DWORD dwType = *pdwType;
    DWORD cbData = *pdwSize;
    HRESULT rc;

    HKEY hKey;
    LPCWSTR lpcsValName;

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    rc =  RegSetValueEx( hKey,
                         lpcsValName,
                         0,
                         dwType,
                         reinterpret_cast<const BYTE*>(pData),
                         cbData);
    return(rc);
}

//-------------------------------------------------------
//
//  DeleteFalconKeyValue
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
DeleteFalconKeyValue(
    LPCTSTR pszValueName )
{

    HKEY hKey;
    LPCWSTR lpcsValName;
    LONG rc;

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    rc = RegDeleteValue( hKey,lpcsValName ) ;
    return rc ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\secutils.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    secutils.cpp

Abstract:

    Various security related functions.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/


#include "stdh.h"
#include <_registr.h>
#include <mqsec.h>
#include <mqprops.h>
#include <mqformat.h>
#include <mqcacert.h>

#include "secutils.tmh"

/*====================================================

HashProperties

Arguments:

Return Value:


=====================================================*/
MQUTIL_EXPORT
HRESULT
HashProperties(
    HCRYPTHASH  hHash,
    DWORD       cp,
    PROPID      *aPropId,
    PROPVARIANT *aPropVar)
{
    DWORD        i;
    DWORD        dwErr ;
    PROPID      *pPropId = 0;
    PROPVARIANT *pPropVar = 0;
    BYTE        *pData = 0;
    DWORD        dwDataSize = 0;

    if (!CryptHashData(hHash, (BYTE*)&cp, sizeof(DWORD), 0))
    {
        dwErr = GetLastError() ;
        TrERROR(SECURITY, "HashProperties(), fail at CryptHashData(), err- %lut", dwErr);

        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    for (i = 0, pPropId = aPropId, pPropVar = aPropVar;
         i < cp;
         i++, pPropId++, pPropVar++)
    {
        if (aPropId)
        {
            if (!CryptHashData(hHash, (BYTE*)pPropId, sizeof(PROPID), 0))
            {
                dwErr = GetLastError() ;
                TrERROR(SECURITY, "HashProperties(), fail at 2nd CryptHashData(), err- %lut", dwErr);

                return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
            }
        }

        switch(pPropVar->vt)
        {
        case VT_UI1:
            pData = (BYTE*)&pPropVar->bVal;
            dwDataSize = sizeof(pPropVar->bVal);
            break;

        case VT_UI2:
        case VT_I2:
            pData = (BYTE*)&pPropVar->iVal;
            dwDataSize = sizeof(pPropVar->iVal);
            break;

        case VT_UI4:
        case VT_I4:
            pData = (BYTE*)&pPropVar->lVal;
            dwDataSize = sizeof(pPropVar->lVal);
            break;

        case VT_CLSID:
            pData = (BYTE*)pPropVar->puuid;
            dwDataSize = sizeof(GUID);
            break;

        case VT_LPWSTR:
            pData = (BYTE*)pPropVar->pwszVal;
            dwDataSize = wcslen(pPropVar->pwszVal);
            break;

        case VT_BLOB:
            pData = (BYTE*)pPropVar->blob.pBlobData;
            dwDataSize = pPropVar->blob.cbSize;
            break;

        case VT_VECTOR | VT_UI1:
            pData = (BYTE*)pPropVar->caub.pElems;
            dwDataSize = pPropVar->caub.cElems;
            break;

        case (VT_VECTOR | VT_CLSID):
            pData = (BYTE*)pPropVar->cauuid.pElems;
            dwDataSize = sizeof(GUID) * pPropVar->cauuid.cElems;
            break;

        case (VT_VECTOR | VT_VARIANT):
            pData = (BYTE*)pPropVar->capropvar.pElems;
            dwDataSize = sizeof(MQPROPVARIANT) * pPropVar->capropvar.cElems;
            break;

        default:
            ASSERT(0);
            return MQ_ERROR;
        }

        if (!CryptHashData(hHash, pData, dwDataSize, 0))
        {
            dwErr = GetLastError() ;
            TrERROR(SECURITY, "HashProperties(), fail at last CryptHashData(), err- %lut", dwErr);

            return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
        }
    }

    return MQ_OK;
}




//
// Function -
//      QueueFormatToFormatName
//
// Parameters -
//      pQueueformat - A pointer to a QUEUE_FORMAT structure.
//      pszShortFormatName - A pointer to a statically allocated buffer. Make
//          this buffer large enough to accomodate most results.
//      ppszLongFormatName - A pointer to a buffer that will hold a pointer to a
//          dynamically allocate buffer, in case pszShortFormatName is not large
//          enough.
//      pulFormatNameLen - Points to a buffer that contains on entry the size
//          of the buffer pointed by pszShortFormatName. On exit he buffer
//          contains the length of the resulted format name.
//      ppszFormatName - A pointer to a buffer that will hold the resulted
//          format name string.
//
// Description -
//      The function converts the queue represented in pQueueformat to it's
//      string representation.
//
static
HRESULT
QueueFormatToFormatName(
    const QUEUE_FORMAT *pQueueformat,
    LPWSTR pszShortFormatName,
    LPWSTR *ppszLongFormatName,
    ULONG *pulFormatNameLen,
    LPWSTR *ppszFormatName)
{
    HRESULT hr;

    //
    // Try to use the short buffer.
    //
    hr = MQpQueueFormatToFormatName(
            pQueueformat,
            pszShortFormatName,
            *pulFormatNameLen,
            pulFormatNameLen,
            false
            );
    if (FAILED(hr))
    {
        if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
        {
            //
            // The short buffer is not large enough. Allocate a lrger buffer
            // and call once more to MQpQueueFormatToFormatName.
            //
            *ppszLongFormatName = new WCHAR[*pulFormatNameLen];
            hr = MQpQueueFormatToFormatName(
                    pQueueformat,
                    *ppszLongFormatName,
                    *pulFormatNameLen,
                    pulFormatNameLen,
                    false
                    );
            if (FAILED(hr))
            {
                return(hr);
            }
            *ppszFormatName = *ppszLongFormatName;
        }
        else
        {
            return(hr);
        }
    }
    else
    {
        *ppszFormatName = pszShortFormatName;
    }

    return(MQ_OK);
}

//
// A buffer that contains only zeroes. This is the default value for the
// correleation ID. The buffer is used when the passed pointer to the message
// correlation ID is NULL.
//
static const BYTE g_abDefCorrelationId[PROPID_M_CORRELATIONID_SIZE] = {0};

//
// Function -
//      HashMessageProperties
//
// Parameters -
//     hHash - A handle to a hash object.
//     pbCorrelationId - A pointer to a buffer that contains the correlation ID
//          of the mesasge. If this pointer is set to NULL, the default value
//          in g_abDefCorrelationId is used for calculating the has value.
//     dwCorrelationIdSize - The size of the correleation ID.
//     dwAppSpecific - A application specific property.
//     pbBody - A pointer to the message body.
//     dwBodySize - The size of the message body in bytes.
//     pwcLabel - A pointer to the message label (title).
//     dwLabelSize - The size of the message label in bytes.
//     pRespQueueFormat - The responce queue.
//     pAdminQueueFormat - The admin queue.
//
// Description -
//      The function calculates the hash value for the message properties.
//
MQUTIL_EXPORT
HRESULT
HashMessageProperties(
    HCRYPTHASH hHash,
    const BYTE *pbCorrelationId,
    DWORD dwCorrelationIdSize,
    DWORD dwAppSpecific,
    const BYTE *pbBody,
    DWORD dwBodySize,
    const WCHAR *pwcLabel,
    DWORD dwLabelSize,
    const QUEUE_FORMAT *pRespQueueFormat,
    const QUEUE_FORMAT *pAdminQueueFormat)
{
    HRESULT hr;
    WCHAR szShortRespFormatName[128];
    ULONG ulRespFormatNameLen = sizeof(szShortRespFormatName)/sizeof(WCHAR);
    AP<WCHAR> pszLongRespFormatName;
    LPWSTR pszRespFormatName = NULL;

    //
    // Get the string representation for the responce queue.
    //
    if (pRespQueueFormat)
    {
        hr = QueueFormatToFormatName(
                pRespQueueFormat,
                szShortRespFormatName,
                &pszLongRespFormatName,
                &ulRespFormatNameLen,
                &pszRespFormatName);
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    WCHAR szShortAdminFormatName[128];
    ULONG ulAdminFormatNameLen = sizeof(szShortAdminFormatName)/sizeof(WCHAR);
    AP<WCHAR> pszLongAdminFormatName;
    LPWSTR pszAdminFormatName = NULL;

    //
    // Get the string representation for the admin queue.
    //
    if (pAdminQueueFormat)
    {
        hr = QueueFormatToFormatName(
                pAdminQueueFormat,
                szShortAdminFormatName,
                &pszLongAdminFormatName,
                &ulAdminFormatNameLen,
                &pszAdminFormatName);
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    //
    // If no correlation ID was specified, use the default value for the
    // correlation ID.
    //
    if (!pbCorrelationId)
    {
        ASSERT(dwCorrelationIdSize == PROPID_M_CORRELATIONID_SIZE);
        pbCorrelationId = g_abDefCorrelationId;
    }

    //
    // Prepare data - size pairs for calculating the hash value.
    //
    struct { const BYTE *pData; DWORD dwSize; }
        DataAndSize[] =
            {{pbCorrelationId, dwCorrelationIdSize},
             {(const BYTE *)&dwAppSpecific, sizeof(DWORD)},
             {pbBody, dwBodySize},
             {(const BYTE *)pwcLabel, dwLabelSize},
             {(const BYTE *)pszRespFormatName, (DWORD)(pszRespFormatName ? ulRespFormatNameLen * sizeof(WCHAR) : 0)},
             {(const BYTE *)pszAdminFormatName, (DWORD)(pszAdminFormatName ? ulAdminFormatNameLen * sizeof(WCHAR) : 0)}};

    //
    // Accumulate the hash value for each data-size pair.
    //
    for (int i = 0; i < sizeof(DataAndSize)/sizeof(DataAndSize[0]); i++)
    {
        if (DataAndSize[i].pData && DataAndSize[i].dwSize)
        {
            if (!CryptHashData(hHash,
                               DataAndSize[i].pData,
                               DataAndSize[i].dwSize,
                               0))
            {
				DWORD gle = GetLastError();
				TrERROR(GENERAL, "CryptHashData() failed at %d iteration, gle = 0x%x", i, gle); 
				return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
            }
        }
    }

    return(MQ_OK);
}


#define CARegKey TEXT("CertificationAuthorities")
#define CACertRegValueName TEXT("CACert")
#define CANameRegValueName TEXT("Name")
#define CAEnabledRegValueName TEXT("Enabled")


//
// Function -
//      GetNewCaConfig
//
// Parameters -
//      hRootStore - A handle to MSMQ ROOT certificate store.
//      pCaConfig - A pointer to an array the receives the configuration.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function enumerate the certificates in MSMQ ROOT certificate store
//      and fills pCaConfig with the configuration data. The array suppose to
//      contain enough entries. This is because the calling code looks how many
//      certificats are in the store and allocates an array in just the right
//      size.
//
HRESULT
GetNewCaConfig(
    HCERTSTORE hRootStore,
    MQ_CA_CONFIG *pCaConfig)
{
    DWORD nCert = 0;

    //
    // Enumerate the certificates in the store.
    //
	PCCERT_CONTEXT pCert = CertEnumCertificatesInStore(hRootStore, NULL);
    while(pCert != NULL) 
    {
        BYTE abShortBuffer[256];
        AP<BYTE> pbLongBuff;
        PVOID pvBuff = abShortBuffer;
        DWORD dwSize = sizeof(abShortBuffer);

        //
        // Get the friendly name of the certificate.
        //

        if (!CertGetCertificateContextProperty(
                pCert,
                CERT_FRIENDLY_NAME_PROP_ID,
                pvBuff,
                &dwSize))
        {
            if (GetLastError() != ERROR_MORE_DATA)
            {
                ASSERT(0);
                return(MQ_ERROR);
            }

            //
            // 128 bytes are not enough, allocate a large enough buffer and
            // try again.
            //
            pvBuff = pbLongBuff = new BYTE[dwSize];

            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    pvBuff,
                    &dwSize))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }

        //
        // Allocate a buffer in the right size and copy the string to the
        // configuration data.
        //
        pCaConfig[nCert].szCaRegName = (LPWSTR) new BYTE[dwSize];
        memcpy(pCaConfig[nCert].szCaRegName, pvBuff, dwSize);
        delete[] pbLongBuff.detach(); // Free and detach.

        //
        // Get the SHA1 hash for the certificate. We'll search the certificate
        // in the certificate store according to this hash value.
        //

        pvBuff = abShortBuffer;
        dwSize = sizeof(abShortBuffer);

        if (!CertGetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                pvBuff,
                &dwSize))
        {
            if (GetLastError() != ERROR_MORE_DATA)
            {
                ASSERT(0);
                return(MQ_ERROR);
            }

            //
            // 128 bytes are not enough, allocate a large enough buffer and
            // try again.
            //
            pvBuff = pbLongBuff = new BYTE[dwSize];

            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_SHA1_HASH_PROP_ID,
                    pvBuff,
                    &dwSize))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }

        //
        // Allocate a buffer in the right size and copy the hash value to
        // the configuration data.
        //
        pCaConfig[nCert].pbSha1Hash = new BYTE[dwSize];
        pCaConfig[nCert].dwSha1HashSize = dwSize;
        memcpy(pCaConfig[nCert].pbSha1Hash, pvBuff, dwSize);
        delete[] pbLongBuff.detach(); // Free and detach.

        //
        // Get the subject name of the certificate.
        //

        pvBuff = abShortBuffer;
        dwSize = sizeof(abShortBuffer);

        if (!CertGetCertificateContextProperty(
                pCert,
                MQ_CA_CERT_SUBJECT_PROP_ID,
                pvBuff,
                &dwSize))
        {
            if (GetLastError() != ERROR_MORE_DATA)
            {
                ASSERT(0);
                return(MQ_ERROR);
            }

            //
            // 128 bytes are not enough, allocate a large enough buffer and
            // try again.
            //
            pvBuff = pbLongBuff = new BYTE[dwSize];

            if (!CertGetCertificateContextProperty(
                    pCert,
                    MQ_CA_CERT_SUBJECT_PROP_ID,
                    pvBuff,
                    &dwSize))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }

        //
        // Allocate a buffer in the right size and copy the subject name to
        // the configuration data.
        //
        pCaConfig[nCert].szCaSubjectName = (LPWSTR)new BYTE[dwSize];
        memcpy(pCaConfig[nCert].szCaSubjectName, pvBuff, dwSize);
        delete[] pbLongBuff.detach(); // Free and detach.

        //
        // Get the enabled flag of the certificate.
        //
        dwSize = sizeof(BOOL);

        if (!CertGetCertificateContextProperty(
                pCert,
                MQ_CA_CERT_ENABLED_PROP_ID,
                (PVOID)&pCaConfig[nCert].fEnabled,
                &dwSize))
        {
            ASSERT(0);
            return(MQ_ERROR);
        }

        //
        // Set the deleted flag to FALSE;
        //
        pCaConfig[nCert].fDeleted = FALSE;

        nCert++;
		pCert = CertEnumCertificatesInStore(hRootStore, pCert);
    }

    return(MQ_OK);
}


//
// Function -
//      SetNewCaConfig
//
// Parameters -
//      nCerts - The number of entries in pMqCaConfig.
//      pMqCaConfig - The configuration data.
//      hRegStore - A handle to ...\MSMQ\Parameters\CertificationAuthorities
//          registry.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function updates the MSMQ ROOT certificate store according to the
//      configuration data that is in pMqCaConfig.
//
HRESULT
SetNewCaConfig(
    DWORD nCerts,
    MQ_CA_CONFIG *pMqCaConfig,
    HKEY hRegStore)
{
    //
    // Get a handle to the MSMQ ROOT certificate store.
    //
    CHCertStore hRootStore;

    hRootStore = CertOpenStore(CERT_STORE_PROV_REG,
                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               NULL,
                               0,
                               hRegStore);
    if (!hRootStore)
    {
        return(MQ_ERROR);
    }

    //
    // Go over all the entries in pMqCaConfig and update the store.
    //

    DWORD i;

    for (i = 0; i < nCerts; i++)
    {
        //
        // Find the certificate in MSMQ store.
        //
        CPCCertContext pCert;
        CRYPT_HASH_BLOB HashBlob = {pMqCaConfig[i].dwSha1HashSize, pMqCaConfig[i].pbSha1Hash};

        pCert = CertFindCertificateInStore(
                    hRootStore,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_SHA1_HASH,
                    &HashBlob,
                    NULL);
        ASSERT(pCert);
        if (!pCert)
        {
            return(MQ_ERROR);
        }

        if (pMqCaConfig[i].fDeleted)
        {
            //
            // delete the certificate from the store.
            //
            if (!CertDeleteCertificateFromStore(pCert))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
            else
            {
                //
                // If CertDeleteCertiticateFromStore succeeded,
                // we don't need to call CertFreeCertificateContext( ) anymore when exit
                // therefore, we need to set it to NULL here.
                //
                pCert = NULL;
            }
        }
        else
        {
            //
            // Set the enabled flag in the temporary in-memory certificate store.
            //
            CRYPT_DATA_BLOB DataBlob = {sizeof(BOOL), (PBYTE)&pMqCaConfig[i].fEnabled};

            if (!CertSetCertificateContextProperty(
                    pCert,
                    MQ_CA_CERT_ENABLED_PROP_ID,
                    0,
                    &DataBlob))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }
    }

    return(MQ_OK);
}

//
// Function -
//      MQSetCaConfig
//
// Parameters -
//      nCerts - The number of MQ_CA_CONFIG entries in MqCaConfig.
//      MqCaConfig - A pointer to a MQ_CA_CONFIG array.
//
// Description -
//      Store the information specified in MqCaConfig into Falcon CA
//      registry.
//
MQUTIL_EXPORT
HRESULT
MQSetCaConfig(
    DWORD nCerts,
    MQ_CA_CONFIG *MqCaConfig)
{
    LONG lError;
    HKEY hCerts;

    //
    // Get a handle to Falcon registry. Don't close this handle
    // because it is cached in MQUTIL.DLL. If you close this handle,
    // the next time you'll need it, you'll get a closed handle.
    //
    lError = GetFalconKey(CARegKey, &hCerts);
    if (lError != ERROR_SUCCESS)
    {
        return MQ_ERROR;
    }

    if (MqCaConfig[0].pbSha1Hash)
    {
        //
        // IE4 is installed, do it in the new way.
        //
        return SetNewCaConfig(nCerts, MqCaConfig, hCerts);
    }

    //
    // Update the registry.
    //
    for (DWORD iCert = 0;
         iCert < nCerts;
         iCert++)
    {
        CAutoCloseRegHandle hCa;

        lError = RegOpenKeyEx(hCerts,
                              MqCaConfig[iCert].szCaRegName,
                              0,
                              KEY_SET_VALUE,
                              &hCa);
        if (lError != ERROR_SUCCESS)
        {
            return MQ_ERROR;
        }

        lError = RegSetValueEx(hCa,
                               CAEnabledRegValueName,
                               0,
                               REG_DWORD,
                               (PBYTE)&MqCaConfig[iCert].fEnabled,
                               sizeof(DWORD));
        if (lError != ERROR_SUCCESS)
        {
            return MQ_ERROR;
        }
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"

#define   INITGUID	
#include "initguid.h"

#include "TXDTC.H"

#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\shrutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    shrutil.cpp

Abstract:

    Utilities that are used both by QM and RT DLL

Author:

    Lior Moshaiov (LiorM)


--*/
#include "stdh.h"
#include "shrutil.h"
#include "TXDTC.H"
#include "txcoord.h"
#include "xolehlp.h"
#include "mqutil.h"
#include <clusapi.h>
#include <mqnames.h>
#include "autohandle.h"

#include "shrutil.tmh"

extern HINSTANCE g_DtcHlib;         // handle of the loaded DTC proxy library (defined in mqutil.cpp)
extern IUnknown *g_pDTCIUnknown;    // pointer to the DTC IUnknown
extern ULONG     g_cbTmWhereabouts; // length of DTC whereabouts
extern BYTE     *g_pbTmWhereabouts; // DTC whereabouts

#define MSDTC_SERVICE_NAME     TEXT("MSDTC")          // Name of the DTC service
#define MSDTC_PROXY_DLL_NAME   TEXT("xolehlp.dll")    // Name of the DTC helper proxy DLL

static CCriticalSection s_DTC_CS;
static CCriticalSection s_WhereaboutsCS;

#define MAX_DTC_WAIT   150   // waiting for DTC start - seconds
#define STEP_DTC_WAIT  10    // check each .. seconds

//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which
//case the MS DTC on the same host is contacted and the interface provided
//for it.
typedef HRESULT (STDAPIVCALLTYPE * LPFNDtcGetTransactionManager) (
                                             LPSTR  pszHost,
                                             LPSTR  pszTmName,
                                    /* in */ REFIID rid,
                                    /* in */ DWORD  i_grfOptions,
                                    /* in */ void FAR * i_pvConfigParams,
                                    /*out */ void** ppvObject ) ;

/*====================================================
VerifyCurDTC
    Internal: verifies that the current cached DTC pointers are alive
=====================================================*/
static BOOL VerifyCurDTC(IUnknown* pDTCIUnknown)
{
    HRESULT hr;

    if (pDTCIUnknown != NULL)
    {
        R<IResourceManagerFactory>       pIRmFactory    = NULL;
        R<ITransactionImport>            pTxImport      = NULL;
        R<ITransactionImportWhereabouts> pITxWhere      = NULL;

        // Check if old DTC pointer is alive yet
        try
        {

            hr = pDTCIUnknown->QueryInterface (IID_ITransactionImportWhereabouts,
                                                (void **)(&pITxWhere));
            if (SUCCEEDED(hr))
            {
                hr  = pDTCIUnknown->QueryInterface(IID_IResourceManagerFactory,
                                                     (LPVOID *) &pIRmFactory);
                if (SUCCEEDED(hr))
                {
                    hr  =  pDTCIUnknown->QueryInterface(IID_ITransactionImport,
                                                          (void **)&pTxImport);
                    if (SUCCEEDED(hr))
                    {
                        return TRUE;
                    }
                }
            }
        }
        catch(...)
        {
            // DTC may have been stopped or killed
        }
    }
    return FALSE;
}


/*====================================================
XactGetWhereabouts
    Gets the whereabouts of the MS DTC
Arguments:
    ULONG  *pcbWhereabouts
    BYTE  **ppbWherabouts
Returns:
    HR
=====================================================*/
HRESULT
XactGetWhereabouts(
    ULONG     *pcbTmWhereabouts,
    BYTE      *ppbTmWhereabouts
    )
{
	HRESULT hr;

	CS lock(s_WhereaboutsCS);

	if ((g_cbTmWhereabouts != 0) && (g_pbTmWhereabouts != NULL))
	{
		if (g_cbTmWhereabouts > *pcbTmWhereabouts)
		{
		   *pcbTmWhereabouts = g_cbTmWhereabouts;
		   return MQ_ERROR_USER_BUFFER_TOO_SMALL;
		}

		CopyMemory(ppbTmWhereabouts, g_pbTmWhereabouts, g_cbTmWhereabouts);
		*pcbTmWhereabouts   = g_cbTmWhereabouts;
		return S_OK;
	}

	// Get the DTC
	R<IUnknown>	punkDtc;
    hr = XactGetDTC((IUnknown **)(&punkDtc));
    if (FAILED(hr))
    {
        TrERROR(XACT_GENERAL, "XactGetDTC failed: %x ", hr);
		return MQ_ERROR_DTC_CONNECT;
    }

	// Get the DTC  ITransactionImportWhereabouts interface
	R<ITransactionImportWhereabouts> pITxWhere;
	hr = punkDtc->QueryInterface (IID_ITransactionImportWhereabouts,
										 (void **)(&pITxWhere));
	if (FAILED(hr))
	{
		TrERROR(XACT_GENERAL, "QueryInterface failed: %x ", hr);
		return MQ_ERROR_DTC_CONNECT;
	}

	// Get the size of the whereabouts blob for the TM
	ULONG nTempTmWhereaboutsSize;
	hr = pITxWhere->GetWhereaboutsSize (&nTempTmWhereaboutsSize);
	if (FAILED(hr))
	{
		TrERROR(XACT_GENERAL, "GetWhereaboutsSize failed: %x ", hr);
		return MQ_ERROR_DTC_CONNECT;
	}

	// Allocate space for the TM whereabouts blob
	BYTE* pbTempWhereaboutsBuf;
	try
	{
		pbTempWhereaboutsBuf = new BYTE[nTempTmWhereaboutsSize];
	}
	catch(const bad_alloc&)
	{
		TrERROR(XACT_GENERAL, "new g_cbTmWhereaboute failed: %x ", hr);
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	// Get the TM whereabouts blob
	ULONG  cbUsed;
	hr = pITxWhere->GetWhereabouts(nTempTmWhereaboutsSize, pbTempWhereaboutsBuf, &cbUsed);
	if (FAILED(hr))
	{
		TrERROR(XACT_GENERAL, "GetWhereabouts failed: %x ", hr);
		return MQ_ERROR_DTC_CONNECT;
	}
	
	g_pbTmWhereabouts = pbTempWhereaboutsBuf;
	g_cbTmWhereabouts = nTempTmWhereaboutsSize;

	if (g_cbTmWhereabouts > *pcbTmWhereabouts)
	{
		*pcbTmWhereabouts = g_cbTmWhereabouts;
	   return MQ_ERROR_USER_BUFFER_TOO_SMALL;
	}

	*pcbTmWhereabouts = g_cbTmWhereabouts;
	CopyMemory(ppbTmWhereabouts, g_pbTmWhereabouts, g_cbTmWhereabouts);
	return S_OK;

}


/*====================================================
XactGetDTC
    Gets the IUnknown pointer
Arguments:
    OUT    IUnknown *ppunkDtc
Returns:
    HR
=====================================================*/
HRESULT
XactGetDTC(IUnknown **ppunkDtc)
{
    // Prepare pessimistic output parameters
    *ppunkDtc         = NULL;


	R<IUnknown> pTempDTC;
	{
		CS lock(s_DTC_CS);
		pTempDTC = SafeAddRef(g_pDTCIUnknown);
	}

    if (VerifyCurDTC(pTempDTC.get()))
    {
		// Detach the pointer and return everything to the caller.
		*ppunkDtc  = pTempDTC.detach();
		return MQ_OK;
	}

	//
	// DTC not exist or not working, Delete old DTC 1st
	//

    XactFreeDTC();

    //
    // Get new DTC pointer
    //

    // On NT, xolehlp is not linked statically to mqutil, so we load it here

	HINSTANCE hTempLib = g_DtcHlib;

	CLibHandle LibToFree;
	if (hTempLib == NULL)
    {
        hTempLib = LoadLibrary(MSDTC_PROXY_DLL_NAME);
		if (NULL == hTempLib)
		{
			TrERROR(XACT_GENERAL, "Failed to load xolehlp.dll. Error: %!winerr!", GetLastError());
			return MQ_ERROR_DTC_CONNECT;
		}
		if (InterlockedCompareExchangePointer((PVOID *)(&g_DtcHlib), hTempLib, NULL) != NULL)
		{
			*&LibToFree = hTempLib;
		}
    }

    // Get DTC API pointer
    LPFNDtcGetTransactionManager pfDtcGetTransactionManager =
          (LPFNDtcGetTransactionManager) GetProcAddress(hTempLib, "DtcGetTransactionManagerExA");

    if (!pfDtcGetTransactionManager)
    {
        TrERROR(XACT_GENERAL, "pfDtcGetTransactionManager=%p ", 0);
        return MQ_ERROR_DTC_CONNECT;
    }

    // Get DTC IUnknown pointer
    HRESULT hr;
	IUnknown* pDTC = NULL;
    hr = (*pfDtcGetTransactionManager)(
                             NULL,
                             NULL,
                             IID_IUnknown,
                             OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS,
                             0,
                             (void**)(&pDTC)
							 );

    if (FAILED(hr) || pDTC == NULL)
    {
        TrERROR(XACT_GENERAL, "pfDtcGetTransactionManager failed: %x ", hr);
        return MQ_ERROR_DTC_CONNECT;
    }

    // Keep DTC IUnknown pointer for the future usage
	CS lock (s_DTC_CS);
	g_pDTCIUnknown = pDTC;

	g_pDTCIUnknown->AddRef();
	*ppunkDtc = g_pDTCIUnknown;

	return S_FALSE;
}

/*====================================================
XactFreeDTC
    Called on library download; frees DTC pointers
=====================================================*/
void XactFreeDTC(void)
{
    // Release previous pointers and data
    try
    {
		{
			CS lock(s_WhereaboutsCS);
			if (g_pbTmWhereabouts)
			{
				delete []g_pbTmWhereabouts;
				g_pbTmWhereabouts = NULL;
				g_cbTmWhereabouts = 0;
			}
		}

		{
			CS lock(s_DTC_CS);
			if (g_pDTCIUnknown)
			{
				g_pDTCIUnknown->Release();
			    g_pDTCIUnknown    = NULL;
			}
		}

        if (g_DtcHlib)
        {
            // Normally we should free DTC proxy library here,
            // but because of some nasty DTC bug xolehlp.dll does not work after reload.
            // So we are simply not freeing it, thus leaving in memory for all process lifetime.

            //FreeLibrary(g_DtcHlib);
		    //g_DtcHlib         = NULL;
        }
    }
    catch(...)
    {
        // Could occur if DTC failed or was released already.
    }
}


bool
MQUTIL_EXPORT
APIENTRY
IsLocalSystemCluster(
    VOID
    )
/*++

Routine Description:

    Check if local machine is a cluster node.

    The only way to know that is try calling cluster APIs.
    That means that on cluster systems, this code should run
    when cluster service is up and running. (ShaiK, 26-Apr-1999)

Arguments:

    None

Return Value:

    true - The local machine is a cluster node.

    false - The local machine is not a cluster node.

--*/
{
    CAutoFreeLibrary hLib = LoadLibrary(L"clusapi.dll");

    if (hLib == NULL)
    {
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }

    typedef DWORD (WINAPI *GetState_fn) (LPCWSTR, DWORD*);
    GetState_fn pfGetState = (GetState_fn)GetProcAddress(hLib, "GetNodeClusterState");

    if (pfGetState == NULL)
    {   
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }

    DWORD dwState = 0;
    if (ERROR_SUCCESS != pfGetState(NULL, &dwState))
    {
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }

    if ((dwState == ClusterStateNotInstalled) || (dwState == ClusterStateNotConfigured))
    {
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }


    TrTRACE(GENERAL, "Local machine is a Cluster node !!");
    return true;

} //IsLocalSystemCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\secutils\restrict.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	Restrict.c

Abstract:
	C++ wrappers for restrictions.

--*/

#include "stdh.h"

#include "_rstrct.h"

#include "restrict.tmh"

//--------------------------------------------------------------------------
//
// Methods for CColumns
//
//--------------------------------------------------------------------------
CColumns::CColumns( unsigned size )
        : m_size( size ),
          m_cCol( 0 ),
          m_aCol( 0 )
{
    if ( m_size > 0 )
    {
        m_aCol = new PROPID[m_size];
        //memset( m_aCol, 1, m_size * sizeof( PROPID ) );
    }
}

CColumns::CColumns( CColumns const & src )
        : m_size( src.m_cCol ),
          m_cCol( 0 )
{
    if ( m_size > 0 )
    {
        m_aCol = new PROPID[m_size];

        //memset( m_aCol, 1, m_size * sizeof( PROPID ) );

        while( m_cCol < src.m_cCol )
        {
            Add( src.Get( m_cCol ) );
        }
    }
}


CColumns::~CColumns()
{
    delete[] m_aCol ;
}

void CColumns::Add( PROPID const & Property)
{
    if( m_cCol == m_size )
    {
        unsigned cNew = (m_size > 0) ? (m_size * 2) : 1;
        PROPID* aNew = new PROPID[cNew];

        memcpy( aNew, m_aCol, m_cCol * sizeof( PROPID ) );
        //memset( aNew + m_cCol, 1, (cNew - m_cCol) * sizeof( PROPID ) );

        delete  m_aCol;

        m_aCol = aNew;
        m_size = cNew;
    }

    m_aCol[m_cCol] = Property;
    ++m_cCol;
}

void CColumns::Remove( unsigned pos )
{
    if ( pos < m_cCol )
    {
        m_cCol--;
        RtlMoveMemory( m_aCol + pos,
                 m_aCol + pos + 1,
                 (m_cCol - pos) * sizeof( PROPID ) );
    }
}
//--------------------------------------------------------------------------
//
// Methods for CSort
//
//--------------------------------------------------------------------------
CSort::CSort( unsigned size )
        : m_size( size ),
          m_csk( 0 ),
          m_ask( 0 )
{
    if ( m_size > 0 )
    {
        m_ask = new CSortKey[m_size];
    }
}

CSort::CSort( CSort const & src )
       : m_size( src.m_csk ),
         m_csk( 0 ),
         m_ask( 0 )
{

    if ( m_size > 0 )
    {
        m_ask = new CSortKey [ m_size];
        while( m_csk < src.m_csk )
        {
            Add( src.Get( m_csk ) );
        }
    }
}


CSort::~CSort()
{
    delete []( m_ask );
}


void CSort::Add( CSortKey const & sk )
{
    if( m_csk == m_size )
    {
        unsigned cNew = (m_size > 0) ? (m_size * 2) : 1;
        CSortKey * aNew = new CSortKey[ cNew ];
		for (unsigned i = 0; i < m_csk; i++)
		{
			aNew[i] = m_ask[i];
		}

        delete []( m_ask );

        m_ask = aNew;
        m_size = cNew;

    }

    m_ask[m_csk] = sk;
    ++m_csk;
}


void CSort::Add( PROPID const & property, ULONG dwOrder)
{
    CSortKey sk( property, dwOrder );
    Add(sk);
}

void CSort::Remove( unsigned pos )
{
    if ( pos < m_csk )
    {
        m_csk--;
		for ( unsigned i = pos; i < m_csk - pos; i++)
		{
			m_ask[i] = m_ask[i+1];
		}
    }
}
//--------------------------------------------------------------------------
//
// Methods for CRestriction
//
//--------------------------------------------------------------------------

CRestriction::CRestriction( unsigned cInitAllocated )
		  :m_cNode( 0 ),
          m_paNode( 0 ),
          m_cNodeAllocated( cInitAllocated )
{
    if ( m_cNodeAllocated > 0 )
    {
        m_paNode = new CPropertyRestriction [ m_cNodeAllocated];
    }
}


CRestriction::CRestriction( const CRestriction& Rst )
	 :m_cNode( Rst.Count() ),
      m_cNodeAllocated( Rst.Count() ),
      m_paNode( 0 )
{
    if ( m_cNodeAllocated > 0 )
    {
        m_paNode = new CPropertyRestriction [ m_cNodeAllocated ];

        for (unsigned i=0; i<m_cNode; i++ )
        {
            m_paNode[i] = Rst.GetChild( i );
        }
    }
}

CRestriction & CRestriction::operator=( CRestriction const & Rst )
{
	delete [] m_paNode;
	m_paNode = 0;

	m_cNodeAllocated = m_cNode = Rst.Count();

	if ( m_cNodeAllocated > 0 )
    {
        m_paNode = new CPropertyRestriction [ m_cNodeAllocated ];

        for ( unsigned i=0; i<m_cNode; i++ )
        {
            m_paNode[i] = Rst.GetChild( i );
        }
    }
	
	return (*this);
}




CRestriction::~CRestriction()
{
	delete [] m_paNode;
}


void CRestriction::AddChild(CPropertyRestriction const & presChild)
{
    if ( m_cNode == m_cNodeAllocated )
    {
        Grow();
    }

    m_paNode[m_cNode] = presChild;
    m_cNode++;
}

/*
CPropertyRestriction const & CRestriction::RemoveChild( unsigned pos )
{
    //
    //  BUGBUG: bad bad code; will return ref to a removed child
    //

    if ( pos < m_cNode )
    {
        CPropertyRestriction  const & prstRemoved = m_paNode[pos];

        for ( pos++; pos < m_cNode; pos++ )
        {
            m_paNode[pos-1] = m_paNode[pos];
        }

        m_cNode--;

        return( prstRemoved );
    }
    else
    {
        return( *(CPropertyRestriction *)0 );
    }
}
*/

void CRestriction::Grow()
{
    int count = (m_cNodeAllocated != 0) ? m_cNodeAllocated * 2 : 2;

    CPropertyRestriction* paNew = new CPropertyRestriction [ count ];

	for ( unsigned i = 0 ; i < m_cNode; i++ )
    {
        paNew[i ] = m_paNode[i];
    }

    delete []( m_paNode );

    m_paNode = paNew;
    m_cNodeAllocated = count;
}

void CRestriction::AddRestriction( ULONG ulValue, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( ulValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( LONG lValue, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( lValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( SHORT sValue, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( sValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( UCHAR ucValue, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( ucValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction(const CMQVariant & prval, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( prval);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( CACLSID * caclsValus, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( caclsValus);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( LPTSTR pwszVal, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( pwszVal);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( CALPWSTR * calpwstr, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( calpwstr);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( GUID * pguidValue, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( pguidValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( BLOB & blobValue, PROPID property, ULONG relop)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( blobValue);
    
	AddChild(PropertyRestriction);
}


//--------------------------------------------------------------------------
//
// Methods for CPropertyRestriction
//
//--------------------------------------------------------------------------
CPropertyRestriction::CPropertyRestriction()
{
}

CPropertyRestriction::CPropertyRestriction( ULONG relop,
                                            PROPID const & Property,
                                            CMQVariant const & prval )
		: m_relop( relop ),
          m_Property( Property ),
          m_prval( prval )
{

}

CPropertyRestriction & CPropertyRestriction::operator=( CPropertyRestriction const & src )
{
	m_relop = src.m_relop;
	m_Property = src.m_Property;
	m_prval = src.m_prval;
	return (*this);
}


CPropertyRestriction::~CPropertyRestriction()
{
}


void CPropertyRestriction::SetValue( TCHAR * pwcsValue )
{
    m_prval = pwcsValue;
}

void CPropertyRestriction::SetValue( BLOB & bValue )
{
    m_prval = bValue;
}

void CPropertyRestriction::SetValue ( CACLSID * caclsValue)
{
	m_prval = caclsValue;
}

void CPropertyRestriction::SetValue ( CALPWSTR  * calpwstrValue)
{
	m_prval = calpwstrValue;
}

void CPropertyRestriction::SetValue( GUID * pguidValue )
{
    m_prval = pguidValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\srvauthn\stdh_sa.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    stdh_sa.h

Abstract:

    Standard header file to the srvauthn static library.

Author:

    Doron Juster  (DoronJ)  June-98

--*/


HRESULT InitServerCredHandle(PCCERT_CONTEXT pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\srvauthn\srvauthn.cpp ===
/*++

Copyright (c) 1997-99  Microsoft Corporation

Module Name:  srvauthn.cpp

Abstract:
   1. Initialization of server authentication (secured comm) on MSMQ servers.
   2. Code to setup and read registry on clients.

Author:

    Doron Juster (DoronJ)   Jun-98

--*/

#include <stdh_sec.h>
#include <mqkeyhlp.h>
#include <_registr.h>
#include "stdh_sa.h"

#include "srvauthn.tmh"

static WCHAR *s_FN=L"srvauthn/srvauthn";

DWORD   g_dwSALastError = 0;

//+--------------------------------------------------------------------
//
//  HRESULT  MQsspi_InitServerAuthntication()
//
//  1. Read digest of server certificate from registry. This was save
//     in registry by control panel.
//  2. Look for server certificate in machine store. Take the one that
//     match the digest read from registry.
//  3. Initialize the schannel provider.
//
//+--------------------------------------------------------------------

HRESULT  MQsspi_InitServerAuthntication()
{
    HRESULT hr = MQSec_OK;

    //
    // Read cert store and digest from registry.
    //
    LPTSTR tszRegName = SRVAUTHN_STORE_NAME_REGNAME;
    TCHAR  tszStore[48];
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = sizeof(tszStore);
    LONG rc = GetFalconKeyValue( 
					tszRegName,
					&dwType,
					(PVOID) tszStore,
					&dwSize 
					);

    if (rc != ERROR_SUCCESS)
    {
        TrERROR(SECURITY, "Failed to read MSMQ registry key %ls. %!winerr!", tszRegName, rc);
        return MQSec_E_READ_REG;
    }

    GUID  CertDigest;
    tszRegName = SRVAUTHN_CERT_DIGEST_REGNAME;
    dwType = REG_BINARY;
    dwSize = sizeof(CertDigest);
    rc = GetFalconKeyValue( 
			tszRegName,
			&dwType,
			(PVOID) &CertDigest,
			&dwSize 
			);
    if (rc != ERROR_SUCCESS)
    {
        TrERROR(SECURITY, "Failed to read MSMQ registry key %ls. %!winerr!", tszRegName, rc);
        return MQSec_E_READ_REG;
    }

    //
    // Enumerate the certificates. Take the one with the matching digest.
    //
    BOOL fCertFound = FALSE;

    CHCertStore hStore = CertOpenStore( 
							CERT_STORE_PROV_SYSTEM,
							0,
							0,
							CERT_SYSTEM_STORE_LOCAL_MACHINE,
							tszStore 
							);
    if (!hStore)
    {
        g_dwSALastError = GetLastError();
        LogNTStatus(g_dwSALastError, s_FN, 30);
        return MQSec_E_CANT_OPEN_STORE;
    }

    PCCERT_CONTEXT pContext = CertEnumCertificatesInStore( 
									hStore,
									NULL 
									);
    while (pContext)
    {
        CMQSigCertificate *pCert;
        hr = MQSigCreateCertificate( 
				&pCert,
				pContext 
				);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            GUID tmpDigest;
            hr = pCert->GetCertDigest(&tmpDigest);

            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                if (memcmp(&tmpDigest, &CertDigest, sizeof(GUID)) == 0)
                {
                    //
                    // that's our certificate.
                    //
                    hr = InitServerCredHandle(pContext);
                    if (SUCCEEDED(hr))
                    {
                        TrTRACE(SECURITY, "Successfully initialized server authentication credentials. (store=%ls)", tszStore);
                    }
                    pCert->Release();
                    pContext = NULL; // freed by previous Release().
                    fCertFound = TRUE;
                    break;
                }
            }
        }

        pCert->Release(TRUE); // TRUE for keeping the context.
                               // it's freed by CertEnum...
        PCCERT_CONTEXT pPrecContext = pContext;
        pContext = CertEnumCertificatesInStore( 
						hStore,
						pPrecContext 
						);
    }
    ASSERT(!pContext);

    if (!fCertFound)
    {
        hr = MQSec_E_CERT_NOT_FOUND;
    }
    return LogHR(hr, s_FN, 40);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsvc\svcmain.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcMain.cpp

Abstract:
    MSMQ Service process

Author:
    Erez Haba (erezh) 20-Feb-2001

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <qm.h>


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    MSMQ Service dispatcher

Arguments:
    arc, arv passed on.

Returned Value:
    Zero

--*/
{
    return QMMain(argc, argv);
} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqutil\res\migtools\mqmigres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrat.rc
//
#define IDS_CANT_LOAD_ODBCCP            12001
#define IDS_CANT_GETADRS_ODBCCP         12002
#define IDS_FAIL_CREATE_DSN             12003
#define IDS_CAPTION                     12013
#define IDS_INVALID_MACHINE_NAME        12014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12015
#define _APS_NEXT_COMMAND_VALUE         12015
#define _APS_NEXT_CONTROL_VALUE         12015
#define _APS_NEXT_SYMED_VALUE           12015
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqutil\res\migtools\migdllres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MqMig.rc
//
#define IDD_MQMIG_FINISH                13001
#define IDS_STR_NOT_DC                  13001
#define IDS_STR_CANT_START              13003
#define IDS_STR_ERROR_TITLE             13004
#define IDS_STR_MUST_FILE               13005
#define IDS_STR_SERVICE_FAIL_TITLE      13006
#define IDS_STR_CANT_OPEN_MGR           13007
#define IDS_STR_CANT_OPEN_MSMQ          13008
#define IDS_STR_CANT_CNFG_MSMQ          13009
#define IDS_STR_SERVICE_WARNING_TITLE   13012
#define IDS_STR_CANT_START_MSMQ         13013
#define IDS_STR_CANT_DEL_WELCOME        13015
#define IDS_STR_DEL_WELCOME_TITLE       13016
#define IDS_STR_WARNING_TITLE           13016
#define IDD_MQMIG_WELCOME               13017
#define IDD_MQMIG_SERVER                13018
#define IDD_MQMIG_LOGIN                 13019
#define IDD_MQMIG_WAIT                  13020
#define IDD_MQMIG_PREMIG                13021
#define IDI_ICON1                       13022
#define IDI_MIGWARNING                  13023
#define IDD_INIT_WAIT                   13024
#define IDD_MQMIG_HELP                  13025
#define IDB_WIZARD_WATERMARK            13026
#define IDD_MQMIG_SERVICE               13027
#define IDB_WIZARD_HEADER               13028
#define IDS_STR_REPLACE_FILE            13030
#define IDS_STR_CANT_CHECK              13031
#define IDS_OLD_VER_SERVERS             13032
#define IDS_STR_TO_CONTINUE             13033
#define IDS_MIGRATION_FAILED            13034
#define IDS_MIGRATION_SUCCEEDED         13035
#define IDS_SQL_NOT_STARTED             13036
#define IDS_STR_CANT_OPEN_SQLSERVER     13037
#define IDS_STR_FAILED_OPEN_MGR         13038
#define IDS_STR_CANT_GET_SQLSERVER_STATUS 13039
#define IDS_STR_CANT_START_SQL_SERVER   13040
#define IDS_STR_CREATE_PATH             13041
#define IDS_STR_PRE_CREATE_PATH         13042
#define IDS_STR_PATH_CREATE_ERROR       13043
#define IDS_WAIT_ANALYZE                13044
#define IDS_WAIT_MIGRATE                13045
#define IDS_QUEUES                      13046
#define IDS_MACHINES                    13047
#define IDS_MQMIG_SITES                 13048
#define IDS_USERS                       13049
#define IDS_ENTERPRISE_ALREADY_EXIST    13050
#define IDS_ANALYSIS_SUCCEEDED          13051
#define IDS_ANALYSIS_FAILED             13052
#define IDS_NOTEPAD                     13053
#define IDS_ANALYSIS_FAILED_NO_LOG      13054
#define IDS_MIGRATION_FAILED_NO_LOG     13055
#define IDS_CANT_OPEN_MSMQ_SRVICE       13056
#define IDS_CANT_GET_MSMQ_CONFIG        13057
#define IDS_MSMQ_NOT_DISABLED           13058
#define IDS_MIGTOOL_CAPTION             13059
#define IDS_LOGGING_TITLE               13060
#define IDS_LOGGING_SUBTITLE            13061
#define IDS_ANALYZE_TITLE               13062
#define IDS_ANALYZE_SUBTITLE            13063
#define IDS_WAIT_TITLE                  13064
#define IDS_WAIT_SUBTITLE               13065
#define IDS_PREIMPORT_TITLE             13066
#define IDS_PREIMPORT_SUBTITLE          13067
#define IDS_WAIT2_TITLE                 13068
#define IDS_WAIT2_SUBTITLE              13069
#define IDS_WELCOME_TITLE_TEXT          13070
#define IDS_MQMIG_USAGE                 13071
#define IDS_STR_CANT_STOP_MSMQ          13072
#define IDS_STR_CANT_DISABLE_MSMQ       13073
#define IDS_CANT_UPDATE_REGISTRY        13077
#define IDS_CANT_CONNECT_DATABASE       13078
#define IDS_CANT_GET_SITEID             13079
#define IDS_CANT_UPDATE_DS              13080
#define IDS_HTML_HELP_PATH              13081
#define IDS_HELP_TITLE                  13082
#define IDS_HELP_SUBTITLE               13083
#define IDS_STR_WRONG_PATH              13085
#define IDS_DRIVE_NOT_VALID             13086
#define IDS_ELAPSED_TIME_TEXT           13087
#define IDS_CANT_GET_IDS                13088
#define IDS_CANT_GET_REGISTRY           13089
#define IDS_CANT_UPDATE_MQIS            13090
#define IDS_UPDATE_SUCCEEDED            13091
#define IDS_UPDATE_PARTIALLY            13092
#define IDS_INITUPDATE                  13093
#define IDS_NO_SERVER_TO_UPDATE         13096
#define IDS_INSUFFICIENT_PERMISSION     13097
#define IDS_STR_RESTORE_OBJECTS         13102
#define IDS_STR_WRONG_DLL_VERSION       13103
#define IDS_STR_CANT_DETERMINE_FILE_VERSION 13104
#define IDC_TEXT1                       13105
#define IDC_CHECK_READ                  13106
#define IDC_RADIO_ERR                   13107
#define IDC_RADIO_WARN                  13108
#define IDC_RADIO_TRACE                 13109
#define IDC_RADIO_INFO                  13110
#define IDC_RADIO_DISABLE               13111
#define IDC_MQMIG_BROWSE                13112
#define IDC_EDIT_LOGFILE                13113
#define IDC_PROGRESS_SITE               13114
#define IDC_PROGRESS_MACHINE            13115
#define IDC_PROGRESS_QUEUE              13116
#define IDC_STATIC_SITE                 13117
#define IDC_STATIC_MACHINE              13118
#define IDC_STATIC_QUEUE                13119
#define IDC_PROGRESS_USER               13120
#define IDC_STATIC_USER                 13121
#define IDC_FINISH_TEXT                 13122
#define IDC_PLEASE_WAIT                 13123
#define IDC_VIEW_LOG_FILE               13124
#define IDC_WELCOME_TEXT                13125
#define IDC_MQMIG_CHECK1                13126
#define IDC_ELAPSED_TIME                13127
#define IDC_INITTEXT                    13128
#define IDC_DONE                        13129
#define IDS_WAIT_MIGRATE_CLIENTS        13130
#define IDS_WAIT_MIGRATE_SERVERS        13131
#define IDS_MIGRATION_NEXT_TO_UPDATE_SERVERS 13132
#define IDS_MIGRATION_NEXT_TO_UPDATE_CLIENTS 13133
#define IDC_SKIP                        13134
#define IDS_UPDATE_CLIENTS_SUCCEEDED    13135
#define IDS_UPDATE_SERVERS_SUCCEEDED    13136
#define IDS_MIGRATION_PROCESS_COMPLETE  13137
#define IDS_UPDATE_CLIENTS_FAILED       13138
#define IDS_UPDATE_SERVERS_FAILED       13139
#define IDC_CHECK1                      13140
#define IDS_MIGRATION_COPMPLETED_SUCCESSFULLY 13141

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        13142
#define _APS_NEXT_COMMAND_VALUE         13142
#define _APS_NEXT_CONTROL_VALUE         13142
#define _APS_NEXT_SYMED_VALUE           13142
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqutil\main.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqutil.cpp

Abstract:

    General utility functions for the general utility dll. This dll contains
    various functions that both the DS and the QM need.

Author:

    Boaz Feldbaum (BoazF) 7-Apr-1996.

--*/

#include "windows.h"


HINSTANCE g_hInstance;

/* -------------------------------------------------------

Function:     HMODULE MQGetResourceHandle()

Decription:   mqutil.dll is a resource only dll. In order to 
	      get loaded, we need a function such as this to do
              that.  This function allows any component to obtain 
              the handle to the resource only dll, i.e. mqutil.dll.
			  It is better to use this function and not to load the
			  dll explicitly, because if the dll is not present an 
			  error will be given by the system when the application 
			  starts. This solves the problem of giving an error message
			  when mqutil.dll is not loaded.

Arguments: None

Return Value: HMODULE -  Handle to the resource only dll.

------------------------------------------------------- */
HMODULE MQGetResourceHandle()
{
	return (HMODULE)g_hInstance;
}


/*====================================================

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)

 Initialization and cleanup when DLL is loaded, attached and detached.

=====================================================*/

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID /* lpvReserved */)
{
    switch(dwReason)
    {

    case DLL_PROCESS_ATTACH :
	    g_hInstance = hMod;
        break;

    case DLL_PROCESS_DETACH :

        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\mqsec\srvauthn\sspi.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sspi.cpp

Abstract:

    Functions that implements the server authentication using SSPI over PCT.

Author:

    Boaz Feldbaum (BoazF) 30-Apr-1997.

--*/

#include <stdh_sec.h>
#include "stdh_sa.h"
#include <mqcrypt.h>
#include <autoptr.h>
#include <mqkeyhlp.h>
#include <cs.h>

static WCHAR *s_FN=L"srvauthn/sspi.cpp";

extern "C"
{
#include <sspi.h>
//#include <sslsp.h>
}

#include "schnlsp.h"

#include "sspi.tmh"

//#define SSL3SP_NAME_A    "Microsoft SSL 3.0"
//#define SP_NAME_A SSL3SP_NAME_A
//#define SP_NAME_A PCTSP_NAME_A

//
// PCT and SSL (the above packages names) are broken and unsupported on
// NT5. Use the "unified" package.
//    "Microsoft Unified Security Protocol Provider"
//
#define SP_NAME_W   UNISP_NAME_W

PSecPkgInfo g_PackageInfo;

//
// Function -
//      InitSecInterface
//
// Parameters -
//      None.
//
// Return value -
//      MQ_OK if successful, else error code.
//
// Description -
//      The function initializes the security interface and retrieves the
//      security package information into a global SecPkgInfo structure.
//

extern "C"
{
typedef SECURITY_STATUS (SEC_ENTRY *SEALMESSAGE_FN)(PCtxtHandle, DWORD, PSecBufferDesc, ULONG);
}

HINSTANCE g_hSchannelDll = NULL;
SEALMESSAGE_FN g_pfnSealMessage;

#define SealMessage(a, b, c, d) g_pfnSealMessage(a, b, c ,d)


HRESULT
InitSecInterface(void)
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        g_hSchannelDll = LoadLibrary(L"SCHANNEL.DLL");
        if (g_hSchannelDll == NULL)
        {
            return LogHR(MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 10);
        }

        g_pfnSealMessage = (SEALMESSAGE_FN)GetProcAddress(g_hSchannelDll, "SealMessage");
        if (!g_pfnSealMessage)
        {
            return LogHR(MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 20);
        }

        SECURITY_STATUS SecStatus;

        InitSecurityInterface();

        //
        // Retrieve the packge information (SSPI).
        //
        SecStatus = QuerySecurityPackageInfo(SP_NAME_W, &g_PackageInfo);
        if (SecStatus != SEC_E_OK)
        {
            LogHR(SecStatus, s_FN, 50);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }

        fInitialized = TRUE;
    }

    return MQ_OK;
}


CredHandle g_hServerCred;
BOOL g_fInitServerCredHandle = FALSE;
static CCriticalSection s_csServerCredHandle;

//
// Function -
//      InitServerCredHandle
//
// Parameters -
//      cbPrivateKey - The size of the server's private key in bytes.
//      pPrivateKey - A pointer to the server's private key buffer.
//      cbCertificate - The size of the server's certificate buffer in bytes.
//      pCertificate - A pointer to the server's certificate buffer
//      szPassword - A pointer to the password with which the server's private
//          key is encrypted.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function creates the server's ceredentials handle out from the
//      certificate and the private key.
//
HRESULT
InitServerCredHandle( 
	PCCERT_CONTEXT pContext 
	)
{
    if (g_fInitServerCredHandle)
    {
        return MQ_OK;
    }

    CS Lock(s_csServerCredHandle);

    if (!g_fInitServerCredHandle)
    {
        //
        // Initialize the security interface.
        //
        SECURITY_STATUS SecStatus = InitSecInterface();
        if (SecStatus != SEC_E_OK)
        {
            LogHR(SecStatus, s_FN, 140);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }

        //
        // Fill the credential structure.
        //
        SCHANNEL_CRED   SchannelCred;

        memset(&SchannelCred, 0, sizeof(SchannelCred));

        SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;

        SchannelCred.cCreds = 1;
        SchannelCred.paCred = &pContext;

        SchannelCred.grbitEnabledProtocols = SP_PROT_PCT1;

        //
        // Retrieve the ceredentials handle (SSPI).
        //
        SecStatus = AcquireCredentialsHandle( 
						NULL,
						SP_NAME_W,
						SECPKG_CRED_INBOUND,
						NULL,
						&SchannelCred,
						NULL,
						NULL,
						&g_hServerCred,
						NULL
						);

        if (SecStatus == SEC_E_OK)
        {
            g_fInitServerCredHandle = TRUE;
        }
        else
        {
            TrERROR(SECURITY, "Failed to acquire a handle for user cridentials. %!winerr!", SecStatus);
        }
    }

    return LogHR(g_fInitServerCredHandle ? MQ_OK : MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 150);
}

//
// Function -
//      ServerAcceptSecCtx
//
// Parameters -
//      fFirst - Indicates whether or not this is the first time the context
//          is to be accepted.
//      pvhServerContext - A pointer to a the server's context handle.
//      pbServerBuffer - A pointer to the server buffer. This buffer is filled
//          by in function. The contents of the buffer should be passed to the
//          client.
//      pdwServerBufferSize - A pointer to a buffer the receives the number of
//          bytes that were written to the server buffer.
//      pbClientBuffer - A buffer that was received from the client.
//      dwClientBufferSize - the size of the buffer that was received from the
//          client.
//
// Return value -
//      SEC_I_CONTINUE_NEEDED if more negotiation with the server is needed.
//      MQ_OK if the negotiation is done. Else an error code.
//
// Description -
//      The function calls SSPI to process the buffer that was received from
//      the client and to get new data to be passed once again to the client.
//
HRESULT
ServerAcceptSecCtx(
    BOOL fFirst,
    LPVOID *pvhServerContext,
    LPBYTE pbServerBuffer,
    DWORD *pdwServerBufferSize,
    LPBYTE pbClientBuffer,
    DWORD dwClientBufferSize)
{
    if (!g_fInitServerCredHandle)
    {
        return LogHR(MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 170);
    }

    SECURITY_STATUS SecStatus;

    SecBufferDesc InputBufferDescriptor;
    SecBuffer InputSecurityToken;
    SecBufferDesc OutputBufferDescriptor;
    SecBuffer OutputSecurityToken;
    ULONG ContextAttributes;
    PCtxtHandle phServerContext = (PCtxtHandle)*pvhServerContext;

    //
    // Build the input buffer descriptor.
    //

    InputBufferDescriptor.cBuffers = 1;
    InputBufferDescriptor.pBuffers = &InputSecurityToken;
    InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    InputSecurityToken.BufferType = SECBUFFER_TOKEN;
    InputSecurityToken.cbBuffer = dwClientBufferSize;
    InputSecurityToken.pvBuffer = pbClientBuffer;

    //
    // Build the output buffer descriptor. We need to allocate a buffer
    // to hold this buffer.
    //

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = &OutputSecurityToken;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    OutputSecurityToken.BufferType = SECBUFFER_TOKEN;
    OutputSecurityToken.cbBuffer = g_PackageInfo->cbMaxToken;
    OutputSecurityToken.pvBuffer = pbServerBuffer;

    if (fFirst)
    {
        //
        // Upon the first call, allocate the context handle.
        //
        phServerContext = new CtxtHandle;
    }

    //
    // Call SSPI to process the client's buffer and retrieve new data to be
    // passed to the client, if neccessary.
    //
    SecStatus = AcceptSecurityContext(
          &g_hServerCred,
          fFirst ? NULL : phServerContext,
          &InputBufferDescriptor,
          0,                        // No context requirements
          SECURITY_NATIVE_DREP,
          phServerContext,          // Receives new context handle
          &OutputBufferDescriptor,  // Receives output security token
          &ContextAttributes,       // Receives context attributes
          NULL                      // Don't receive context expiration time
          );
    LogHR(SecStatus, s_FN, 175);

    HRESULT hr =  ((SecStatus == SEC_E_OK) ||
                   (SecStatus == SEC_I_CONTINUE_NEEDED)) ?
                        SecStatus : MQDS_E_CANT_INIT_SERVER_AUTH;
    if (SUCCEEDED(hr))
    {
        //
        // Pass on the results.
        //
        *pdwServerBufferSize = OutputSecurityToken.cbBuffer;
        if (fFirst)
        {
            *pvhServerContext = phServerContext;
        }
    }

    return LogHR(hr, s_FN, 180);
}

//
// Function -
//      GetSizes
//
// Parameters -
//      pcbMaxToken - A pointer to a buffer that receives the maximun required
//          size for the token buffer. This is an optional parameter.
//      pvhContext - A pointer to a context handle. This is an optional
//          parameter.
//      pcbHeader - A pointer to a buffer that receives the stream header size
//          for the context. This is an optional parameter.
//      cpcbTrailer - A pointer to a buffer that receives the stream trailer
//          size for the context. This is an optional parameter.
//      pcbMaximumMessage - A pointer to a buffer that receives the maximum
//          message size that can be handled in this context. This is an
//          optional parameter.
//      pcBuffers - A pointer t oa buffer that receives the number of buffers
//          that should be passed to SealMessage/UnsealMessage. This is an
//          optional parameter.
//      pcbBlockSize - A pointer to a buffer that receives the block size used
//          in this context. This is an optional parameter.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function retrieves the various required sizes. The maximum token
//      size is per the security package. So no need for a context handle in
//      order to retrieve the maximum token size. For all the other values, it
//      is required to pass a context handle.
//      The function is implemented assuming that first it is called to
//      retrieve only the maximum token size and after that, in a second call,
//      it is called for retreiving the other (context related) values.
//
HRESULT
GetSizes(
    DWORD *pcbMaxToken,
    LPVOID pvhContext,
    DWORD *pcbHeader,
    DWORD *pcbTrailer,
    DWORD *pcbMaximumMessage,
    DWORD *pcBuffers,
    DWORD *pcbBlockSize)
{
    SECURITY_STATUS SecStatus;

    if (!pvhContext)
    {
        //
        // Initialize the security interface.
        //
        SecStatus = InitSecInterface();
        if (SecStatus != SEC_E_OK)
        {
            LogHR(SecStatus, s_FN, 190);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }
    }
    else
    {
        //
        // Get the context related values.
        //
        SecPkgContext_StreamSizes ContextStreamSizes;

        SecStatus = QueryContextAttributes(
            (PCtxtHandle)pvhContext,
            SECPKG_ATTR_STREAM_SIZES,
            &ContextStreamSizes
            );

        if (SecStatus == SEC_E_OK)
        {
            //
            // Pass on the results, as required.
            //
            if (pcbHeader)
            {
                *pcbHeader = ContextStreamSizes.cbHeader;
            }

            if (pcbTrailer)
            {
                *pcbTrailer = ContextStreamSizes.cbTrailer;
            }

            if (pcbMaximumMessage)
            {
                *pcbMaximumMessage = ContextStreamSizes.cbMaximumMessage;
            }

            if (pcBuffers)
            {
                *pcBuffers = ContextStreamSizes.cBuffers;
            }

            if (pcbBlockSize)
            {
                *pcbBlockSize = ContextStreamSizes.cbBlockSize;
            }

        }
    }

    //
    // Pass on the resulted maximum token size, as required.
    //
    if (pcbMaxToken)
    {
        *pcbMaxToken = g_PackageInfo->cbMaxToken;
    }

    return LogHR((HRESULT)SecStatus, s_FN, 200);
}


//
// Function -
//      FreeContextHandle
//
// Parameters -
//      pvhContextHandle - A pointer to a context handle.
//
// Return value -
//      None.
//
// Description -
//      The function deletes the context and frees the memory for the context
//      handle.
//
void
FreeContextHandle(
    LPVOID pvhContextHandle)
{
    PCtxtHandle pCtxtHandle = (PCtxtHandle) pvhContextHandle;

    //
    // delete the context.
    //
    DeleteSecurityContext(pCtxtHandle);

    //
    // Free the momery for the context handle.
    //
    delete pCtxtHandle;
}

//
// Function -
//      MQSealBuffer
//
// Parameters -
//      pvhContext - A pointer to a context handle.
//      pbBuffer - A buffer to be sealed.
//      cbSize -  The size of the buffer to be sealed.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function seals the buffer. That is, it signes and decryptes the
//      buffer. The buffer should be constructed as follows:
//
//          |<----------------- cbSize ------------------>|
//          +--------+--------------------------+---------+
//          | Header | Actual data to be sealed | Trailer |
//          +--------+--------------------------+---------+
//
//      The header and trailer are parts of the buffer that are filled by SSPI
//      when sealing the buffer. The sizes of the header and the trailer can
//      be retrieved by calling GetSizes() (above).
//
HRESULT
MQSealBuffer(
    LPVOID pvhContext,
    PBYTE pbBuffer,
    DWORD cbSize)
{
    SECURITY_STATUS SecStatus;

    //
    // Get the header and trailer sizes, and the required number of buffers.
    //
    SecPkgContext_StreamSizes ContextStreamSizes;

    SecStatus = QueryContextAttributes(
        (PCtxtHandle)pvhContext,
        SECPKG_ATTR_STREAM_SIZES,
        &ContextStreamSizes
        );

    if (SecStatus != SEC_E_OK)
    {
        return LogHR((HRESULT)SecStatus, s_FN, 220);
    }

    ASSERT(cbSize > ContextStreamSizes.cbHeader + ContextStreamSizes.cbTrailer);

    //
    // build the stream buffer descriptor
    //
    SecBufferDesc SecBufferDescriptor;
    AP<SecBuffer> aSecBuffers = new SecBuffer[ContextStreamSizes.cBuffers];

    SecBufferDescriptor.cBuffers = ContextStreamSizes.cBuffers;
    SecBufferDescriptor.pBuffers = aSecBuffers;
    SecBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    //
    // Build the header buffer.
    //
    aSecBuffers[0].BufferType = SECBUFFER_STREAM_HEADER;
    aSecBuffers[0].cbBuffer = ContextStreamSizes.cbHeader;
    aSecBuffers[0].pvBuffer = pbBuffer;

    //
    // Build the data buffer.
    //
    aSecBuffers[1].BufferType = SECBUFFER_DATA;
    aSecBuffers[1].cbBuffer = cbSize - ContextStreamSizes.cbHeader - ContextStreamSizes.cbTrailer;
    aSecBuffers[1].pvBuffer = (PBYTE)aSecBuffers[0].pvBuffer + aSecBuffers[0].cbBuffer;

    //
    // Build the trailer buffer.
    //
    aSecBuffers[2].BufferType = SECBUFFER_STREAM_TRAILER;
    aSecBuffers[2].cbBuffer = ContextStreamSizes.cbTrailer;
    aSecBuffers[2].pvBuffer = (PBYTE)aSecBuffers[1].pvBuffer + aSecBuffers[1].cbBuffer;

    //
    // Build the rest of the buffer as empty buffers.
    //
    for (DWORD i = 3; i < ContextStreamSizes.cBuffers; i++)
    {
        aSecBuffers[i].BufferType = SECBUFFER_EMPTY;
    }

    //
    // Call SSPI to seal the buffer.
    //
    SecStatus = SealMessage((PCtxtHandle)pvhContext, 0, &SecBufferDescriptor, 0);

    return LogHR((HRESULT)SecStatus, s_FN, 230);
}


//+---------------------------------
//
//  BOOL WINAPI MQsspiDllMain ()
//
//+---------------------------------

BOOL WINAPI
MQsspiDllMain(HMODULE /* hMod */, DWORD ulReason, LPVOID /* lpvReserved */)
{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        //
        // BUGBUG - We can't delete the security context here because schannel may
        //          do it's cleanup before us and the certificates in the context will
        //          already be deleted. So deleting the securiy context will try to
        //          delete a certificate. This may cause bad thing to happen. So
        //          currently we risk in leaking some memory. Same goes to the credentials
        //          handles.
        //
/*
*        if (g_fInitServerCredHandle)
*        {
*            FreeCredentialsHandle(&g_hServerCred);
*        }
*/
        if (g_hSchannelDll)
        {
            FreeLibrary(g_hSchannelDll);
        }
        break;

    case DLL_THREAD_DETACH:
        break ;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\admin.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admin.cpp

Abstract:

	Admin Class implementation.

Author:

	David Reznick (t-davrez)


--*/

#include "stdh.h"
#include "qmres.h"
#include "cqmgr.h"
#include "admcomnd.h"
#include "admutils.h"
#include "admin.h"
#include "cqpriv.h"
#include <strsafe.h>

#include "admin.tmh"

extern HMODULE   g_hResourceMod;

static WCHAR *s_FN=L"admin";

CCriticalSection g_csReadWriteRequests;

//
// Constructor
//
CAdmin::CAdmin() : m_fReportQueueExists(FALSE),
                   m_fPropagateFlag(DEFAULT_PROPAGATE_FLAG)
{
}


/*====================================================
															
RoutineName
	CAdmin::Init()

Arguments:

Return Value:

=====================================================*/
HRESULT CAdmin::Init()
{
    DWORD dwSize, dwType;
    GUID ReportQueueGuid;
    QUEUE_FORMAT QueueFormat;

    VOID WINAPI ReceiveAdminCommands(const CMessageProperty*, const QUEUE_FORMAT*);

    TrTRACE(GENERAL, "Entering CAdmin::Init");
		
    HRESULT hR = GetAdminQueueFormat( &QueueFormat);
    if (FAILED(hR))
    {
        TrERROR(GENERAL, "ERROR : CAdmin::Init -> couldn't get Admin-Queue from registry!!!");
        return LogHR(hR, s_FN, 10);
    }

    //
    // Get the report-queue guid from registry (if one exists)
    //
    dwSize = sizeof(GUID);
    dwType = REG_BINARY;

    LONG iReg = GetFalconKeyValue( REG_REPORTQUEUE,
                                   &dwType,
                                   &ReportQueueGuid,
                                   &dwSize);

    if (iReg == ERROR_SUCCESS)
    {
        m_ReportQueueFormat.PublicID(ReportQueueGuid);
        m_fReportQueueExists = TRUE;
        //
        // Get the propagate flag from the registry (if one exists)
        //
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        iReg = GetFalconKeyValue( REG_PROPAGATEFLAG,
                                  &dwType,
                                  &m_fPropagateFlag,
                                  &dwSize) ;
    }

    //
    // Set the QM's state (Report Or Normal)
    //
    CQueueMgr::SetReportQM(m_fPropagateFlag != 0);

    HRESULT hr2 = QmpOpenAppsReceiveQueue( &QueueFormat, ReceiveAdminCommands );
    return LogHR(hr2, s_FN, 20);
}

/*====================================================
															
RoutineName
	CAdmin::GetReportQueue

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::GetReportQueue(QUEUE_FORMAT* pReportQueue)
{
    static BOOL fAfterInit = TRUE;
    TrTRACE(GENERAL, "Entering CAdmin::GetReportQueue");

    CS lock(g_csReadWriteRequests);

    if (m_fReportQueueExists)
    {
        if (fAfterInit)
        {
            fAfterInit = FALSE;
            //
            // Check if the queue exist any more
            //
            QueueProps QueueProp;
            HRESULT hr = QmpGetQueueProperties( &m_ReportQueueFormat, &QueueProp, false, false);

            if (FAILED(hr))
            {
                if (hr != MQ_ERROR_NO_DS)
                {
                    TrTRACE(GENERAL, "CAdmin::GetReportQueue : The report queue is not exist");

                    LogHR(hr, s_FN, 30);

                    m_ReportQueueFormat.UnknownID(0);
                    m_fReportQueueExists = FALSE;
                    hr = DeleteFalconKeyValue(REG_REPORTQUEUE);

                    //
                    // Reset the propagation flag and delete it from registry.
                    //
                    m_fPropagateFlag = DEFAULT_PROPAGATE_FLAG ;
                    CQueueMgr::SetReportQM(m_fPropagateFlag != 0);
                    DeleteFalconKeyValue( REG_PROPAGATEFLAG ) ;
                    return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 35);
                }
                else
                {
                    fAfterInit = TRUE;
                }
            }
            else
            {
                delete QueueProp.pQMGuid;
                delete [] QueueProp.lpwsQueuePathName;
            }
        }

        *pReportQueue = m_ReportQueueFormat;
        return MQ_OK;
    }
    else
    {
        TrTRACE(GENERAL, "CAdmin::GetReportQueue : The report queue is not defined");
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 40);
    }
}

/*====================================================
															
RoutineName
	CAdmin::SetReportQueue

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SetReportQueue(GUID* pReportQueueGuid)
{
    LONG    hr;
    DWORD dwSize = sizeof(GUID);
    DWORD dwType = REG_BINARY;
    HRESULT rc = MQ_OK;

    TrTRACE(GENERAL, "Entering CAdmin::SetReportQueue");

    CS lock(g_csReadWriteRequests);

    if (*pReportQueueGuid == GUID_NULL)
    {
        m_ReportQueueFormat.UnknownID(0);
        m_fReportQueueExists = FALSE;
        hr = DeleteFalconKeyValue(REG_REPORTQUEUE);

        //
        // Reset the propagation flag and delete it from registry.
        //
        m_fPropagateFlag = DEFAULT_PROPAGATE_FLAG ;
        CQueueMgr::SetReportQM(m_fPropagateFlag != 0);
        DeleteFalconKeyValue( REG_PROPAGATEFLAG ) ;
    }
    else
    {
        //
        // write report queue's name if registry
        //

        hr = SetFalconKeyValue(REG_REPORTQUEUE,
                               &dwType,
                               pReportQueueGuid,
                               &dwSize);

        if (hr == ERROR_SUCCESS)
        {
            m_ReportQueueFormat.PublicID(*pReportQueueGuid);
            m_fReportQueueExists = TRUE;
        }
        else
        {
            rc = MQ_ERROR;
        }
    }

    return LogHR(rc, s_FN, 50);
}


/*====================================================
															
RoutineName
	CAdmin::SetReportPropagateFlag

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SetReportPropagateFlag(BOOL fReportPropFlag)
{
    LONG rc;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    TrTRACE(GENERAL, "Entering CAdmin::SetReportPropagateFlag");

    rc = SetFalconKeyValue(REG_PROPAGATEFLAG,
                           &dwType,
                           &fReportPropFlag,
                           &dwSize);

    if (rc == ERROR_SUCCESS)
    {
        m_fPropagateFlag = fReportPropFlag;

        //
        // Set the QM's state (Report Or Normal)
        //
        CQueueMgr::SetReportQM(m_fPropagateFlag !=0);
        return(MQ_OK);
    }
    else
    {
        LogNTStatus(rc, s_FN, 60);
        return MQ_ERROR;
    }
}

/*====================================================
															
RoutineName
	CAdmin::SendReport

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SendReport(IN QUEUE_FORMAT* pReportQueue,
                           IN OBJECTID*     pMessageID,
                           IN QUEUE_FORMAT* pTargetQueue,
                           IN LPCWSTR       pwcsNextHop,
                           IN ULONG         ulHopCount)
{
    CString strMsgTitle, strMsgBody, strMsgID, strTargetQueueFormat;

    //
    // translate Message-ID and Target-Queue to string format
    //
    if ( FAILED(GetMsgIdName(pMessageID, strMsgID)) ||
         FAILED(GetFormattedName(pTargetQueue,strTargetQueueFormat)))
    {
        TrERROR(GENERAL, "SendReport : couldn't prepare message");
        return LogHR(MQ_ERROR, s_FN, 70);
    }

    //
    // Build the Title with a time stamp
    //
    PrepareReportTitle(strMsgTitle, pMessageID, pwcsNextHop, ulHopCount);

    //
    // Build report message body
    //
    strMsgBody += L"<MESSAGE ID>";
    strMsgBody += strMsgID + L"</MESSAGE ID>\n";
    strMsgBody += L"<TARGET QUEUE>";
    strMsgBody += strTargetQueueFormat + L"</TARGET QUEUE>\n";

    if (pwcsNextHop)
    {
        strMsgBody += L"<NEXT HOP>";
        strMsgBody += pwcsNextHop;
        strMsgBody += L"</NEXT HOP>\n";
    }

    //
    // Send report message with report title
    //
    HRESULT hr2 = SendQMAdminMessage(
                           pReportQueue,
                           (LPTSTR)(LPCTSTR)strMsgTitle,
                           (strMsgTitle.GetLength() + 1),
                           (UCHAR*)(LPTSTR)(LPCTSTR)strMsgBody,
                           (strMsgBody.GetLength() + 1) * sizeof(WCHAR),
                           REPORT_MSGS_TIMEOUT);
    return LogHR(hr2, s_FN, 80);

}

/*====================================================
															
RoutineName
	CAdmin::SendReportConflict

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SendReportConflict(IN QUEUE_FORMAT* pReportQueue,
                                   IN QUEUE_FORMAT* pOriginalReportQueue,
                                   IN OBJECTID*     pMessageID,
                                   IN QUEUE_FORMAT* pTargetQueue,
                                   IN LPCWSTR       pwcsNextHop)
{
	WCHAR szReportTitle[100];

	LoadString(g_hResourceMod, IDS_REPORT_TITLE, szReportTitle, TABLE_SIZE(szReportTitle));
	

    CString strMsgTitle, strMsgBody, strMsgID, strTargetQueueFormat,
            strOriginalQueueFormat;

    //
    // translate Message-ID and Target-Queue to string format
    //
    if ( FAILED(GetMsgIdName(pMessageID, strMsgID)) ||
         FAILED(GetFormattedName(pTargetQueue,strTargetQueueFormat)) ||
         FAILED(GetFormattedName(pOriginalReportQueue,strOriginalQueueFormat)))
    {
        TrERROR(GENERAL, "SendReportConflict : couldn't prepare message");
        return LogHR(MQ_ERROR, s_FN, 90);
    }

    //
    // Build the Title with a time stamp
    //
    strMsgTitle = szReportTitle;

    //
    // Build report message body
    //
    strMsgBody += L"<ORIGINAL QUEUE>";
    strMsgBody += strOriginalQueueFormat + L"</ORIGINAL QUEUE>\n";
    strMsgBody += L"<MESSAGE ID>";
    strMsgBody += strMsgID + L"</MESSAGE ID>\n";
    strMsgBody += L"<TARGET QUEUE>";
    strMsgBody += strTargetQueueFormat + L"</TARGET QUEUE>\n";

    if (pwcsNextHop)
    {
        strMsgBody += L"<NEXT HOP>";
        strMsgBody += pwcsNextHop;
        strMsgBody += L"</NEXT HOP>\n";
    }

    //
    // Send report message with report title
    //
    HRESULT hr2 = SendQMAdminMessage(
                           pReportQueue,
                           (LPTSTR)(LPCTSTR)strMsgTitle,
                           (strMsgTitle.GetLength() + 1),
                           (UCHAR*)(LPTSTR)(LPCTSTR)strMsgBody,
                           (strMsgBody.GetLength() + 1) * sizeof(WCHAR),
                           REPORT_MSGS_TIMEOUT);
    return LogHR(hr2, s_FN, 100);

}


/********************************************************************
/      Private Routines of CAdmin Class
/********************************************************************/




/*====================================================
															
RoutineName
	CAdmin::GetAdminQueueFormat()

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::GetAdminQueueFormat( QUEUE_FORMAT * pQueueFormat)
{
    extern LPTSTR  g_szMachineName;

    HRESULT rc;

   	DWORD LenMachine = wcslen(g_szMachineName);
	DWORD Length =
			LenMachine +                    // "machineName"
            1 +                             // '\'
			wcslen(ADMIN_QUEUE_NAME) +1;	// "private$\ADMIN_QUEUE$"

	P<WCHAR> lpwFormatName = new WCHAR[Length];

	rc = StringCchCopy(lpwFormatName, Length, g_szMachineName);
	if (FAILED(rc))
	{
		TrERROR(NETWORKING, "Failed to copy string, %ls, !%hresult%", lpwFormatName, rc);
		return rc;
	}

	lpwFormatName[LenMachine] = L'\\';

	rc = StringCchCopy(lpwFormatName + (LenMachine + 1), Length - (LenMachine + 1), ADMIN_QUEUE_NAME);
	if (FAILED(rc))
	{
		TrERROR(NETWORKING, "Failed to copy string, %ls, %!hresult!", lpwFormatName, rc);
		return rc;
	}

    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(lpwFormatName, pQueueFormat);

    if (FAILED(rc))
    {
        //
        // The ADMIN_QUEUE doesn't exist
        //
        LogHR(rc, s_FN, 110);
        return MQ_ERROR;
    }

    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT));
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\admcomnd.cpp ===
#include "stdh.h"
#include "qmres.h"
#include "admcomnd.h"
#include "admutils.h"
#include "admin.h"
#include "cqpriv.h"
#include "mqformat.h"
#include "license.h"
#include <xstr.h>
#include <strsafe.h>

#include "admcomnd.tmh"

extern CAdmin Admin;

extern HMODULE   g_hResourceMod;

static WCHAR *s_FN=L"admcomnd";

inline IsValidResponseQueue(const QUEUE_FORMAT* pq)
{
	return (pq->GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);
}


/*====================================================

RoutineName
    HandleGetReportQueueMessage

Arguments:

Return Value:

=======================================================*/
static
void
HandleGetReportQueueMessage(
	LPCWSTR pBuf,
	DWORD TotalSize,
	const QUEUE_FORMAT* pResponseQFormat
	)
{
	if (QueueMgr.GetEnableReportMessages()== 0)
    {
        //
        // If we are not allowed to send report messages.
        //
        return;
    }    

    if (TotalSize != 0)
    {
        TrERROR(GENERAL, "Rejecting bad 'Get Report Queue' admin command. Too many parameters, should be zero. %.*ls", xwcs_t(pBuf, TotalSize));
        ASSERT_BENIGN(TotalSize == 0);
        return;
    }

	if (!IsValidResponseQueue(pResponseQFormat))
	{
        TrERROR(GENERAL, "Rejecting bad 'Get Report Queue' admin command. Invalid response queue");
        ASSERT_BENIGN(("Invalid admin command response queue type", 0));
		return;
	}
	
    HRESULT hr;
    QMResponse Response;
    Response.dwResponseSize = 0;
    QUEUE_FORMAT ReportQueueFormat;
    hr = Admin.GetReportQueue(&ReportQueueFormat);

    switch(hr)
    {
        case MQ_ERROR_QUEUE_NOT_FOUND :
            Response.uStatus = ADMIN_STAT_NOVALUE;
            break;

        case MQ_OK :
            Response.uStatus = ADMIN_STAT_OK;
            Response.dwResponseSize = sizeof(GUID);
            memcpy(Response.uResponseBody, &ReportQueueFormat.PublicID(),
                   Response.dwResponseSize);
            break;

        default:
            Response.uStatus = ADMIN_STAT_ERROR;
    }

    hr = SendQMAdminResponseMessage(pResponseQFormat,
                                    ADMIN_RESPONSE_TITLE,
                                    STRLEN(ADMIN_RESPONSE_TITLE)+1,
                                    Response,
                                    ADMIN_COMMANDS_TIMEOUT);

    LogHR(hr, s_FN, 10);
}

/*====================================================

RoutineName
    HandleSetReportQueueMessage

Arguments:

Return Value:

=====================================================*/
static
void
HandleSetReportQueueMessage(
    LPCWSTR pBuf,
    DWORD TotalSize
    )
{
	if (QueueMgr.GetEnableReportMessages()== 0)
    {
        //
        // If we are not allowed to send report messages.
        //
        return;
    }    

	if((TotalSize != 1 + STRING_UUID_SIZE) || (*pBuf != L'='))
	{
		TrERROR(GENERAL, "Rejecting bad 'Set Report Queue' admin command. %.*ls", xwcs_t(pBuf, TotalSize));
		ASSERT_BENIGN(TotalSize == 1 + STRING_UUID_SIZE);
		ASSERT_BENIGN(*pBuf == L'=');
		return;
	}
	
    GUID ReportQueueGuid;
    WCHAR wcsGuid[STRING_UUID_SIZE+1];

    wcsncpy(wcsGuid,pBuf+1,STRING_UUID_SIZE);
    wcsGuid[STRING_UUID_SIZE] = L'\0';

    if (IIDFromString((LPWSTR)wcsGuid, &ReportQueueGuid) == S_OK)
    {
        Admin.SetReportQueue(&ReportQueueGuid);
    }
}


/*====================================================

RoutineName
    HandleGetPropagateFlagMessage

Arguments:

Return Value:

=====================================================*/
static
void
HandleGetPropagateFlagMessage(
	LPCWSTR pBuf,
	DWORD TotalSize,
	const QUEUE_FORMAT* pResponseQFormat
	)
{
	if (QueueMgr.GetEnableReportMessages()== 0)
    {
        //
        // If we are not allowed to send report messages.
        //
        return;
    }    

    if (TotalSize != 0)
    {
        TrERROR(GENERAL, "Rejecting bad 'Get Propagate Flag' admin command. Too many parameters, should be zero. %.*ls", xwcs_t(pBuf, TotalSize));
        ASSERT_BENIGN(TotalSize == 0);
        return;
    }

	if (!IsValidResponseQueue(pResponseQFormat))
	{
        TrERROR(GENERAL, "Rejecting bad 'Get Propagate Flag' admin command. Invalid response queue");
        ASSERT_BENIGN(("Invalid admin command response queue type", 0));
		return;
	}

    QMResponse Response;
    BOOL fPropagateFlag;

    HRESULT hr = Admin.GetReportPropagateFlag(fPropagateFlag);

    switch(hr)
    {
        case MQ_OK :
            Response.uStatus = ADMIN_STAT_OK;
            Response.dwResponseSize = 1;
            Response.uResponseBody[0] = (fPropagateFlag) ? PROPAGATE_FLAG_TRUE :
                                                           PROPAGATE_FLAG_FALSE;
            break;

        default:
            Response.uStatus = ADMIN_STAT_ERROR;
    }

    hr = SendQMAdminResponseMessage(pResponseQFormat,
                        ADMIN_RESPONSE_TITLE,
                        STRLEN(ADMIN_RESPONSE_TITLE) +1,
                        Response,
                        ADMIN_COMMANDS_TIMEOUT);

    LogHR(hr, s_FN, 30);
}

/*====================================================

RoutineName
    HandleSetPropagateFlagMessage

Arguments:

Return Value:

=====================================================*/
static
void
HandleSetPropagateFlagMessage(
    LPCWSTR pBuf,
    DWORD TotalSize
    )
{
	if (QueueMgr.GetEnableReportMessages()== 0)
    {
        //
        // If we are not allowed to send report messages.
        //
        return;
    }    

    const UINT iFalseLen = STRLEN(PROPAGATE_STRING_FALSE);
    const UINT iTrueLen  = STRLEN(PROPAGATE_STRING_TRUE);

    //
    // Argument format : "=FALSE" or "=TRUE"
    //
    if ( (TotalSize == 1 + iFalseLen) && (*pBuf == L'=') &&
         (wcsncmp(pBuf + 1, PROPAGATE_STRING_FALSE, iFalseLen) == 0) )
    {
    	Admin.SetReportPropagateFlag(FALSE);
    	return;
    }
    
    if ( (TotalSize == 1 + iTrueLen) && (*pBuf == L'=') &&
              (!wcsncmp(pBuf + 1, PROPAGATE_STRING_TRUE, iTrueLen)) )
    {
        Admin.SetReportPropagateFlag(TRUE);
        return;
    }
    
    TrERROR(GENERAL, "Rejecting bad 'Set Propagate Flag' admin command. Bad parameter. '%.*ls'", xwcs_t(pBuf, TotalSize));
}


/*====================================================

RoutineName
    HandleSendTestMessage

Arguments:

Return Value:

=====================================================*/
static
void
HandleSendTestMessage(
    LPCWSTR pBuf,
    DWORD TotalSize
    )
{
	if (QueueMgr.GetEnableReportMessages()== 0)
    {
        //
        // If we are not allowed to send report messages.
        //
        return;
    }    

	if((TotalSize != 1 + STRING_UUID_SIZE) || (*pBuf != L'='))
	{
		TrERROR(GENERAL, "Rejecting bad 'Send Test Message' admin command. %.*ls", xwcs_t(pBuf, TotalSize));
		ASSERT_BENIGN(TotalSize == 1 + STRING_UUID_SIZE);
		ASSERT_BENIGN(*pBuf == L'=');
		return;
	}

	WCHAR wcsGuid[STRING_UUID_SIZE+1];
	TCHAR szTitle[100];

	LoadString(g_hResourceMod, IDS_TEST_TITLE, szTitle, TABLE_SIZE(szTitle));

	CString strTestMsgTitle = szTitle;

	wcsncpy(wcsGuid,pBuf+1,STRING_UUID_SIZE);
	wcsGuid[STRING_UUID_SIZE] = L'\0';

	GUID guidPublic;
	if (IIDFromString(wcsGuid, &guidPublic) == S_OK)
	{
	    QUEUE_FORMAT DestQueueFormat(guidPublic);

	    PrepareTestMsgTitle(strTestMsgTitle);

	    //
	    // Send a test message with a title and no body.
	    //
	     SendQMAdminMessage(
	                &DestQueueFormat,
	                (LPTSTR)(LPCTSTR)strTestMsgTitle,
	                (strTestMsgTitle.GetLength() + 1),
	                NULL,
	                0,
	                ADMIN_COMMANDS_TIMEOUT,
	                TRUE,
	                TRUE);
	}
}

//
// GET_FIRST/NEXT_PRIVATE_QUEUE
//
#ifdef _WIN64
//
// WIN64, the LQS operations are done using a DWORD mapping of the HLQS enum handle. The 32 bit mapped
// value is specified in the MSMQ message from MMC, and not the real 64 bit HLQS handle
//
#define GET_FIRST_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetFirstPrivateQueuePositionByDword(pos, strPathName, dwQueueId)
#define GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetNextPrivateQueueByDword(pos, strPathName, dwQueueId)
#else //!_WIN64
//
// WIN32, the LQS operations are done using the HLQS enum handle that is specified as 32 bit value
// in the MSMQ messages from MMC
//
#define GET_FIRST_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetFirstPrivateQueuePosition(pos, strPathName, dwQueueId)
#define GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetNextPrivateQueue(pos, strPathName, dwQueueId);
#endif //_WIN64

/*====================================================

RoutineName
    HandleGetPrivateQueues

Arguments:

Return Value:

=======================================================*/
static
void
HandleGetPrivateQueues(
	LPCWSTR pBuf,
	DWORD TotalSize,
	const QUEUE_FORMAT* pResponseQFormat
	)
{
    if ((TotalSize == 0) || (*pBuf != L'='))
    {
        TrERROR(GENERAL, "Rejecting bad 'Get Private Queues' admin command. missing parameters");
        ASSERT_BENIGN(*pBuf == L'=');
        ASSERT_BENIGN(TotalSize > 0);
        return;
    }

	if (!IsValidResponseQueue(pResponseQFormat))
	{
        TrERROR(GENERAL, "Rejecting bad 'Get Private Queues' admin command. Invalid response queue");
        ASSERT_BENIGN(("Invalid admin command response queue type", 0));
		return;
	}

    HRESULT  hr;
    QMGetPrivateQResponse Response;

    Response.hr = ERROR_SUCCESS;
    Response.pos = NULL;
    Response.dwResponseSize = 0;
    Response.dwNoOfQueues = 0;

    //
    // Inside context for private queues handling.
    //
    {
        DWORD dwReadFrom = 0;
        _sntscanf(pBuf + 1, TotalSize - 1, L"%ul", &dwReadFrom);

        LPCTSTR  strPathName;
        DWORD    dwQueueId;
        DWORD    dwResponseSize = 0;
        QMGetPrivateQResponse_POS32 pos; //always 32 bit on both win32 and win64

        //
        // lock to ensure private queues are not added or deleted while filling the
        // buffer.
        //
        CS lock(g_QPrivate.m_cs);
        //
        // Skip the previous read queues
        //
        //
        // Write the pathnames into the buffer.
        //
        if (dwReadFrom)
        {
            //
            // Get Next Private queue based on the LQS enum handle that is specified in the MMC message
            // On win64 the value specified is a DWORD mapping of the LQS enum handle - to maintain
            // 32 bit wire compatibility to existing MMC's that run on win32
            //
            pos = (QMGetPrivateQResponse_POS32) dwReadFrom;
            hr = GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
        }
        else
        {
            //
            // Get First Private queue.
            // Also sets pos to the LQS enum handle (or to a mapped DWORD of it on win64)
            //
            hr = GET_FIRST_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
        }

        while (SUCCEEDED(hr))
        {
			if(dwQueueId <= MAX_SYS_PRIVATE_QUEUE_ID)
			{
				//
				// Filter out system queues out of the list
				//
				hr = GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
				continue;
			} 
            
            DWORD dwNewQueueLen;

            dwNewQueueLen = (wcslen(strPathName) + 1) * sizeof(WCHAR) + sizeof(DWORD);
            //
            // Check if there is still enough space (take ten characters extra for lengths, etc)
            //
            if (dwNewQueueLen >(MAX_GET_PRIVATE_RESPONSE_SIZE - dwResponseSize))
            {
                Response.hr = ERROR_MORE_DATA;
                break;
            }

            //
            // Write down the Queue Id
            //
            *(DWORD UNALIGNED *)(Response.uResponseBody+dwResponseSize) = dwQueueId;

            //
            // Write down the name - including the terminating NULL.
            //
			size_t size = (sizeof(Response.uResponseBody) - dwResponseSize - sizeof(DWORD)) / sizeof(WCHAR);
            hr = StringCchCopy((TCHAR *)(Response.uResponseBody + dwResponseSize + sizeof(DWORD)), size, strPathName);
			ASSERT(SUCCEEDED(hr));
            dwResponseSize += dwNewQueueLen;
            //
            // Update the number of the returned private queue
            //
            Response.dwNoOfQueues++;
            //
            // Get Next Private queue
            //
            hr = GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
        }

        Response.pos = pos;
        Response.dwResponseSize += dwResponseSize;
    }

    hr = SendQMAdminMessage(pResponseQFormat,
                            ADMIN_RESPONSE_TITLE,
                            STRLEN(ADMIN_RESPONSE_TITLE)+1,
                            (PUCHAR)(&Response),
                            sizeof(QMGetPrivateQResponse),
                            ADMIN_COMMANDS_TIMEOUT);
    LogHR(hr, s_FN, 96);
}

/*====================================================

RoutineName
    HandlePing

Arguments:

Return Value:

=====================================================*/
static
void
HandlePing(
	LPCWSTR pBuf,
	DWORD TotalSize,
	const QUEUE_FORMAT* pResponseQFormat
	)
{
	if (!IsValidResponseQueue(pResponseQFormat))
	{
        TrERROR(GENERAL, "Rejecting bad 'Ping' admin command. Invalid response queue");
        ASSERT_BENIGN(("Invalid admin command response queue type", 0));
		return;
	}

    //
    // Ping returns the exact arguments it gets
    //
    QMResponse Response;
    Response.uStatus = ADMIN_STAT_OK;
    Response.dwResponseSize = (DWORD)min((TotalSize + 1)*sizeof(WCHAR), sizeof(Response.uResponseBody));
    memcpy(Response.uResponseBody, pBuf, Response.dwResponseSize);
    HRESULT hr;
    hr = SendQMAdminResponseMessage(pResponseQFormat,
                        ADMIN_PING_RESPONSE_TITLE,
                        STRLEN(ADMIN_PING_RESPONSE_TITLE)+1,
                        Response,
                        ADMIN_COMMANDS_TIMEOUT);

    LogHR(hr, s_FN, 100);
}


/*====================================================

RoutineName
    HandleGetDependentClients

Arguments:

Return Value:

=======================================================*/
//
// This global is used only in this function.
//
extern CQMLicense  g_QMLicense ;

static
void
HandleGetDependentClients(
	LPCWSTR pBuf,
	DWORD TotalSize,
	const QUEUE_FORMAT* pResponseQFormat
	)
{
    if (TotalSize != 0)
    {
        TrERROR(GENERAL, "Rejecting bad 'Get Dependent Clients' admin command. Too many parameters, should be zero. %.*ls", xwcs_t(pBuf, TotalSize));
        ASSERT_BENIGN(TotalSize == 0);
        return;
    }
    
	if (!IsValidResponseQueue(pResponseQFormat))
	{
        TrERROR(GENERAL, "Rejecting bad 'Get Dependent Clients' admin command. Invalid response queue");
        ASSERT_BENIGN(("Invalid admin command response queue type", 0));
		return;
	}

    HRESULT hr;
    AP<ClientNames> pNames;
    
    g_QMLicense.GetClientNames(&pNames);
    AP<UCHAR> pchResp  = new UCHAR[sizeof(QMResponse) -
                                 MAX_ADMIN_RESPONSE_SIZE +
                                 pNames->cbBufLen] ;
    QMResponse *pResponse = (QMResponse *)pchResp.get(); 

    pResponse->uStatus = ADMIN_STAT_OK;
    pResponse->dwResponseSize = pNames->cbBufLen;

    memcpy(pResponse->uResponseBody, pNames, pNames->cbBufLen);
    hr = SendQMAdminResponseMessage(pResponseQFormat,
                        ADMIN_DEPCLI_RESPONSE_TITLE, 
                        STRLEN(ADMIN_DEPCLI_RESPONSE_TITLE) + 1,
                        *pResponse,
                        ADMIN_COMMANDS_TIMEOUT);
    LogHR(hr, s_FN, 110);
}

/*====================================================

RoutineName
   ParseAdminCommands

Arguments:

Return Value:

=====================================================*/
void
ParseAdminCommands(
    LPCWSTR pBuf,
    DWORD TotalSize,
    const QUEUE_FORMAT* pResponseQFormat
    )
{
    //
    // NOTE : The Admin commands are string-based and not indexed. The motivation
    //        is to have meaningful messages (that can be read by explorer). The
    //        efficiency is less important due to the low-frequency of admin
    //        messages.
    //

    ASSERT(pBuf != NULL);

    //
    // Verify that the command is null terminated
    //
    if((TotalSize == 0) || pBuf[TotalSize - 1] != L'\0')
    {
    	TrERROR(GENERAL, "Rejecting bad admin command. '%.*ls' (size is zero or not null terminated)", xwcs_t(pBuf, TotalSize));
    	return;
    }

	//
	// Trim size for null terminator
	//
	--TotalSize;
	
	int len = STRLEN(ADMIN_SET_REPORTQUEUE);
    if (wcsncmp(pBuf, ADMIN_SET_REPORTQUEUE, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandleSetReportQueueMessage(pBuf, TotalSize);
        return;
    }

	len = STRLEN(ADMIN_GET_REPORTQUEUE);
    if (wcsncmp(pBuf, ADMIN_GET_REPORTQUEUE, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandleGetReportQueueMessage(pBuf, TotalSize, pResponseQFormat);
        return;
    }

	len = STRLEN(ADMIN_SET_PROPAGATEFLAG);
    if (wcsncmp(pBuf, ADMIN_SET_PROPAGATEFLAG, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandleSetPropagateFlagMessage(pBuf, TotalSize);
        return;
    }
    
    len = STRLEN(ADMIN_GET_PROPAGATEFLAG);
    if (wcsncmp(pBuf, ADMIN_GET_PROPAGATEFLAG, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandleGetPropagateFlagMessage(pBuf, TotalSize, pResponseQFormat);
        return;
    }
    
    len = STRLEN(ADMIN_SEND_TESTMSG);
    if (wcsncmp(pBuf, ADMIN_SEND_TESTMSG, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandleSendTestMessage(pBuf, TotalSize);
        return;
    }

	len = STRLEN(ADMIN_GET_PRIVATE_QUEUES);
    if (wcsncmp(pBuf, ADMIN_GET_PRIVATE_QUEUES, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandleGetPrivateQueues(pBuf, TotalSize, pResponseQFormat);
        return;
    }
    
	len = STRLEN(ADMIN_PING);
    if (wcsncmp(pBuf, ADMIN_PING, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandlePing(pBuf, TotalSize, pResponseQFormat);
        return;
    }

	len = STRLEN(ADMIN_GET_DEPENDENTCLIENTS);
    if (wcsncmp(pBuf, ADMIN_GET_DEPENDENTCLIENTS, len) == 0)
    {
        pBuf += len;
        TotalSize -= len;
        HandleGetDependentClients(pBuf, TotalSize, pResponseQFormat);
    }
    
    TrERROR(GENERAL, "Rejecting unknown dmin command. '%.*ls'", xwcs_t(pBuf, TotalSize));
}

/*====================================================

RoutineName
    ReceiveAdminCommands()

Arguments:

Return Value:


=====================================================*/
VOID
WINAPI
ReceiveAdminCommands(
    const CMessageProperty* pmp,
    const QUEUE_FORMAT* pqf
    )
{
    DWORD dwTitleLen = wcslen(ADMIN_COMMANDS_TITLE);

    if ( (pmp->pTitle == NULL) || (pmp->dwTitleSize != (dwTitleLen+1)) ||
         (wcsncmp((LPCTSTR)pmp->pTitle, ADMIN_COMMANDS_TITLE, dwTitleLen)) )
    {
        TrERROR(GENERAL, "Error -  in ReceiveAdminCommands : No title in message");
        return;
    }

    if ( pmp->wClass == MQMSG_CLASS_NORMAL )
    {
        ParseAdminCommands((LPWSTR)pmp->pBody, pmp->dwBodySize / sizeof(WCHAR), pqf);
    }
    else
    {
        TrERROR(DS, "ReceiveAdminCommands: wrong message class");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\admin.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admin.h

Abstract:

	Admin Class definition
		
Author:

	David Reznick (t-davrez)


--*/


#define ADMIN_QUEUE_NAME	(L"private$\\admin_queue$")
#define REG_REPORTQUEUE     (L"ReportQueueGuid")
#define REG_PROPAGATEFLAG   (L"PropagateFlag")

#define DEFAULT_PROPAGATE_FLAG 0

class CAdmin
{
    public:

        CAdmin();

        HRESULT Init();

        HRESULT GetReportQueue(OUT QUEUE_FORMAT* pReportQueue);
        HRESULT SetReportQueue(IN  GUID* pReportQueueGuid);

        HRESULT GetReportPropagateFlag(OUT BOOL& fReportPropFlag);
        HRESULT SetReportPropagateFlag(IN  BOOL fReportPropFlag);
        
        HRESULT SendReport(IN QUEUE_FORMAT* pReportQueue,
                           IN OBJECTID*     pMessageID,
                           IN QUEUE_FORMAT* pTargetQueue,
                           IN LPCWSTR       pwcsNextHop,
                           IN ULONG         ulHopCount);

        HRESULT SendReportConflict(IN QUEUE_FORMAT* pReportQueue,
                                   IN QUEUE_FORMAT* pOriginalReportQueue,
                                   IN OBJECTID*     pMessageID,
                                   IN QUEUE_FORMAT* pTargetQueue,
                                   IN LPCWSTR       pwcsNextHop);

    private:

        //functions
        HRESULT GetAdminQueueFormat( QUEUE_FORMAT * pQueueFormat);

        //members
        BOOL m_fReportQueueExists;
        QUEUE_FORMAT m_ReportQueueFormat;

        BOOL m_fPropagateFlag;
};



//
//  inline members
//

inline HRESULT CAdmin::GetReportPropagateFlag(OUT BOOL& fReportPropFlag)
{
    fReportPropFlag = m_fPropagateFlag;
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\admutils.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admutils.h

Abstract:

	headers for QM-Admin utilities (for report-queue handling)

Author:

	David Reznick (t-davrez)  04-13-96


--*/

#define STRING_LONG_SIZE 20
#define STRING_UUID_SIZE 38  // Wide-Characters (includiing - "{}")


HRESULT SendQMAdminResponseMessage(const QUEUE_FORMAT* pResponseQueue,
                                   TCHAR* pTitle,
                                   DWORD  dwTitleSize,
                                   QMResponse &Response,
                                   DWORD  dwTimeout,
                                   BOOL   fTrace = FALSE);

HRESULT SendQMAdminMessage(const QUEUE_FORMAT* pResponseQueue,
                           TCHAR* pTitle,
                           DWORD  dwTitleSize,
                           UCHAR* puBody,
                           DWORD  dwBodySize,
                           DWORD  dwTimeout,
                           BOOL   fTrace = FALSE,
                           BOOL   fNormalClass = FALSE);

HRESULT GetFormattedName(QUEUE_FORMAT* pTargetQueue,
                         CString&      strTargetQueueFormat);

HRESULT GetMsgIdName(OBJECTID* pObjectID,
                     CString&  strTargetQueueFormat);

void PrepareReportTitle(CString& strMsgTitle, OBJECTID* pMessageID, 
                        LPCWSTR pwcsNextHop, ULONG ulHopCount);
void PrepareTestMsgTitle(CString& strTitle);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\adnotify_s_.c ===
#pragma warning(push, 3)
#include <adnotify_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\admutils.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admutils.cpp

Abstract:

	QM-Admin utilities (for report-queue handling)

Author:

	David Reznick (t-davrez)  04-13-96


--*/

#include "stdh.h"
#include "qmp.h"
#include "admcomnd.h"
#include "admutils.h"
#include "qmres.h"
#include "mqformat.h"

#include "admutils.tmh"

extern LPTSTR  g_szMachineName;
extern HINSTANCE g_hInstance;	
extern HMODULE   g_hResourceMod;			

static WCHAR *s_FN=L"admutils";

/*====================================================

RoutineName
    GuidToString

Arguments:

Return Value:

=====================================================*/

BOOL GuidToString(const GUID& srcGuid, CString& strGuid)
{
    WCHAR wcsTemp[STRING_UUID_SIZE+1];
    INT iLen = StringFromGUID2(srcGuid, wcsTemp, TABLE_SIZE(wcsTemp));

    if (iLen == (STRING_UUID_SIZE + 1))
    {
        //
        // take the enclosing brackets "{}" off
        //
        wcsTemp[STRING_UUID_SIZE-1] = L'\0';
        strGuid = &wcsTemp[1];
        return TRUE;
    }

    return LogBOOL(FALSE, s_FN, 1010); 
}

/*====================================================

RoutineName
    SendQMAdminMessage

Arguments:

Return Value:

=====================================================*/

HRESULT SendQMAdminMessage(const QUEUE_FORMAT* pResponseQueue,
                           TCHAR* pTitle,
                           DWORD  dwTitleSize,
                           UCHAR* puBody,
                           DWORD  dwBodySize,
                           DWORD  dwTimeout,
                           BOOL   fTrace,
                           BOOL   fNormalClass)
{
    CMessageProperty MsgProp;

    if (fNormalClass)
    {
        MsgProp.wClass=MQMSG_CLASS_NORMAL;
    }
    else
    {
        MsgProp.wClass=MQMSG_CLASS_REPORT;
    }
    MsgProp.dwTimeToQueue = dwTimeout;
    MsgProp.dwTimeToLive = INFINITE;
    MsgProp.pMessageID=NULL;
    MsgProp.pCorrelationID=NULL;
    MsgProp.bPriority=MQ_MIN_PRIORITY;
    MsgProp.bDelivery=MQMSG_DELIVERY_EXPRESS;
    MsgProp.bAcknowledge=MQMSG_ACKNOWLEDGMENT_NONE;
    MsgProp.bAuditing=DEFAULT_Q_JOURNAL;
    MsgProp.dwApplicationTag=DEFAULT_M_APPSPECIFIC;
    MsgProp.dwTitleSize=dwTitleSize;
    MsgProp.pTitle=pTitle;
    MsgProp.dwBodySize=dwBodySize;
    MsgProp.dwAllocBodySize=dwBodySize;
    MsgProp.pBody=puBody;

    if (fTrace)
    {
        MsgProp.bTrace = MQMSG_SEND_ROUTE_TO_REPORT_QUEUE;
    }
    else
    {
        MsgProp.bTrace = MQMSG_TRACE_NONE;
    }

    HRESULT hr2 = QmpSendPacket(
                    &MsgProp,
                    pResponseQueue,
                    NULL,
                    NULL
                    );
	return LogHR(hr2, s_FN, 10);
}

/*====================================================

RoutineName
    SendQMAdminResponseMessage

Arguments:

Return Value:

=====================================================*/

HRESULT SendQMAdminResponseMessage(const QUEUE_FORMAT* pResponseQueue,
                                   TCHAR* pTitle,
                                   DWORD  dwTitleSize,
                                   QMResponse &Response,
                                   DWORD  dwTimeout,
                                   BOOL   fTrace)
{
    HRESULT hr2 = SendQMAdminMessage(pResponseQueue,
                               pTitle,
                               dwTitleSize,
                               &Response.uStatus,
                               Response.dwResponseSize+1,
                               dwTimeout,
                               fTrace);
	return LogHR(hr2, s_FN, 20);
}



/*====================================================

RoutineName
    GetFormattedName

Arguments:

Return Value:
  returns the formatted name representation of the
  queue format
=====================================================*/

HRESULT GetFormattedName(QUEUE_FORMAT* pTargetQueue,
                         CString&      strTargetQueueFormat)

{
    CString strGuid;
    HRESULT hr = MQ_ERROR;
    WCHAR   wsFormatName[80];
    ULONG   ulFormatNameLength;

    hr = MQpQueueFormatToFormatName(pTargetQueue,wsFormatName,80, &ulFormatNameLength, false);
    strTargetQueueFormat = wsFormatName;


    return LogHR(hr, s_FN, 30);
}

/*====================================================

RoutineName
    GetMsgIdName

Arguments:

Return Value:
  returns the formatted string representation of the
  message id
=====================================================*/

HRESULT GetMsgIdName(OBJECTID* pObjectID,
                     CString&      strTargetQueueFormat)

{
    WCHAR wcsID[STRING_LONG_SIZE];

    if (!GuidToString(pObjectID->Lineage,strTargetQueueFormat))
    {
        return LogHR(MQ_ERROR, s_FN, 40);
    }

    _ltow(pObjectID->Uniquifier,wcsID,10);

    strTargetQueueFormat += '\\';
    strTargetQueueFormat += wcsID;

    return MQ_OK;
}

/*====================================================

RoutineName
    MessageIDToReportTitle

    This function converts the message id and hop count to a string in the following
    format:
    gggg:dddd:hh

  where: g is the first 4 hexadecimal digits of the GUID
         d is the internal message identifier
         h is the hop count

Arguments:

Return Value:

=====================================================*/

void MessageIDToReportTitle(CString& strIdTitle, OBJECTID* pMessageID,
                            ULONG ulHopCount)
{
    //
    // The first four digits of the printed GUID are Data1
    // four MSB.
    //
    USHORT usHashedId = (USHORT)(pMessageID->Lineage.Data1 >> 16);
    strIdTitle.Format(TEXT("%04X:%04d%3d"),
                      usHashedId, (USHORT)pMessageID->Uniquifier, ulHopCount);
}

/*====================================================

RoutineName
    PrepareReportTitle

    This function builds the title of the message send to
    the report queue. The message consists of the sender's
    name and a time stamp

Arguments:

Return Value:

=====================================================*/

void PrepareReportTitle(CString& strMsgTitle, OBJECTID* pMessageID,
                        LPCWSTR pwcsNextHop, ULONG ulHopCount)
{
    CString strTimeDate, strDescript, strIdTitle;
	TCHAR szSend[100], szReceived[100];
	TCHAR szTime[100], szDate[100];

	LoadString(g_hResourceMod, IDS_SENT1, szSend, TABLE_SIZE(szSend));
	LoadString(g_hResourceMod, IDS_RECEIVE, szReceived, TABLE_SIZE(szReceived));


	//
	// Get time and date
	//
	_wstrdate(szDate);
	_wstrtime(szTime);

    strTimeDate.Format(TEXT("%s , %s"),szDate, szTime);

    //
    // NOTE :   The Next-Hop machine is represented by its address. We need a
    //          way to translate the string address to computer
    //          name. Currently the address is put into the message body
    //
    if (pwcsNextHop)
    {
        //
        // Report message is being sent as the message exists the QM
        //
        strDescript.Format(szSend,g_szMachineName,pwcsNextHop);
    }
    else
    {
        //
        // Report message is being sent on receival of message
        //
        strDescript.Format(szReceived, g_szMachineName);
    }

    //
    // Prepate the message ID title
    //
    MessageIDToReportTitle(strIdTitle, pMessageID, ulHopCount);

    strMsgTitle.Format(TEXT("%s %s%s"), strIdTitle,strDescript,strTimeDate);
}

void PrepareTestMsgTitle(CString& strTitle)
{
    CString strDescript;
	TCHAR szSend[100];
	TCHAR szDate[100], szTime[100];

	LoadString(g_hResourceMod, IDS_SENT2, szSend, TABLE_SIZE(szSend));

	//
	// Get time and date
	//
	_wstrdate(szDate);
	_wstrtime(szTime);

    strDescript.Format(szSend, g_szMachineName,	szDate, szTime);

    strTitle += strDescript;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cache.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    cache.h

    Template for managing cached values.  Each value in the cache should be
    inherited from the CCacheValue class. The calling code should call the
    method of the cached value, so that the entry may be deleted.

    Each value in the cache can have maximum life time in the cache - set
    using m_ExpirationTime member variable. If the number of values in
    the cache becomes twice as much as the hash size, half of the older
    values are removed from the cache.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#ifndef _CACHE_H_
#define _CACHE_H_

#define CACHE_EXPIRATION_GANULARITY (CTimeDuration::OneSecond().Ticks() * 60)

//
// Each value on the cache must be inherited from the CCacheValue class.
//
class CCacheValue
{
public:
    LONG AddRef();
    LONG Release();

public:
    CTimeInstant m_CreationTime;
    LONG  m_lRefCount;

protected:
    CCacheValue();
    virtual ~CCacheValue() = 0;
};

inline CCacheValue::CCacheValue() :
    m_CreationTime(ExGetCurrentTime()),
    m_lRefCount(1)
{
}

inline LONG CCacheValue::AddRef()
{
    LONG lRefCount = InterlockedIncrement(&m_lRefCount);

    return lRefCount;
}

inline LONG CCacheValue::Release()
{
    LONG lRefCount = InterlockedDecrement(&m_lRefCount);

    if (lRefCount == 0)
    {
        delete this;
    }

    return lRefCount;
}

inline CCacheValue::~CCacheValue()
{
    ASSERT(m_lRefCount == 0);
}

//
// Cache template.
//
template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CCache : public CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
{
public:
    CCache();
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

private:
    void ExpireHalfCacheEntries();
    void ExpirePeriodicCacheEnteries(CTimer* pTimer);

    VALUE& operator[](ARG_KEY key) 
        { 
            return CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](key);
        }

private:
    static void WINAPI TimeToExpireCacheEntries(CTimer* pTimer);

public:
    CTimeDuration m_CacheLifetime;
    CCriticalSection m_cs;

private:
    BOOL m_fExpireCacheScheduled;
    CTimer m_ExpireCacheTimer;


};

template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::CCache() :
    m_CacheLifetime(CTimeDuration::MaxValue()),
    m_fExpireCacheScheduled(FALSE),
    m_ExpireCacheTimer(TimeToExpireCacheEntries)
{
}

//
// This function is defined in symmkey.cpp. It finds the median
// value for the time values on the array t.
//
extern ULONGLONG FindMedianTime(ULONGLONG* t, int p, int r, int i);


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::ExpirePeriodicCacheEnteries(CTimer* pTimer)
/*++

  Routine Description:
    The routine removes all the keys that are in the cache for more than a certain
    amount of time.
    The routine calls from the timer.

  Arguments:
    pointer to timer object, that can be used for rescheduling

  Returned Value:
    None
 --*/
{
    ASSERT(pTimer == &m_ExpireCacheTimer);
    ASSERT(m_fExpireCacheScheduled == TRUE);

    CS lock(m_cs);

    //
    // Expire all the keys that are in the cache for more than
    // a certain amount of time.
    //

    m_fExpireCacheScheduled = FALSE;

    CTimeInstant CurrentTime = ExGetCurrentTime();
    CTimeInstant ExpirationTime = CurrentTime - m_CacheLifetime + CACHE_EXPIRATION_GANULARITY;

    //
    // Scan the cache and expire entries.
    //
    POSITION pos = GetStartPosition();
    CTimeInstant MinCreationTime = CTimeInstant::MaxValue();

    while (pos)
    {
        KEY key;
        VALUE value;

        GetNextAssoc(pos, key, value);

        if (value)
        {
            if (value->m_CreationTime < ExpirationTime)
            {
                RemoveKey(key);
            }
            else
            {
                MinCreationTime = min(MinCreationTime, value->m_CreationTime);
            }
        }
    }

    if (MinCreationTime != CTimeInstant::MaxValue())
    {
        //
        // Reschedule the expiration routine for next time.
        //
        CTimeDuration NextTimeout = m_CacheLifetime - (CurrentTime - MinCreationTime) + CACHE_EXPIRATION_GANULARITY;
            
        ExSetTimer(pTimer, NextTimeout); 
        m_fExpireCacheScheduled = TRUE;
    }
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::ExpireHalfCacheEntries(void)
/*++

  Routine Description:
    The routine removes older half of the keys in the cache.

  Arguments:
    pointer to timer object, that can be used for rescheduling

  Returned Value:
    None
 --*/
{
    CS lock(m_cs);

    //
    // Expire older half of the keys in the cache.
    //

    //
    // Get the time values into an array.
    //
    int iHashCount = GetCount();
    AP<ULONGLONG> t = new ULONGLONG[iHashCount];

    POSITION pos = GetStartPosition();
    int i = 0;

    while (pos)
    {
        KEY key;
        VALUE value;

        GetNextAssoc(pos, key, value);
        if (value)
        {
            t[i++] = value->m_CreationTime.Ticks();
        }
    }

    //
    // Find the time median.
    //
    CTimeInstant MedExpiration = FindMedianTime(t, 0, i - 1, iHashCount / 2);

    //
    // Limit the expiration to half of the entries. This is required if
    // many entries have the same time.
    //
    int nLimit = i / 2;


    //
    // Scan the cache and expire entries.
    //
    pos = GetStartPosition();
    int n = 0;

    while (pos)
    {
        KEY key;
        VALUE value;

        GetNextAssoc(pos, key, value);

        if (value)
        {
            if (value->m_CreationTime < MedExpiration)
            {
                RemoveKey(key);
                if (++n > nLimit)
                {
                    break;
                }
            }
        }
    }
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    //
    // Lookup the value in the cache.
    //
    BOOL fRet = CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(key, rValue);

    if (fRet)
    {
        //
        // Added one to the reference count og the value.
        //
        rValue->AddRef();
    }

    return fRet;
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
/*++

Note:
    The Critical Section should be held by the caller

--*/
{
    newValue->AddRef();

    //
    // See if the hash table is to be exploded and release old entries
    // as needed.
    //
    if (GetCount() >= (int)GetHashTableSize() << 1)
    {
        ExpireHalfCacheEntries();
    }

    //
    // Add the value to the cache.
    //
    CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(key, newValue);

    if(m_fExpireCacheScheduled)
        return;

    if(m_CacheLifetime == CTimeDuration::MaxValue())
        return;

    ASSERT(GetCount() == 1);

    ExSetTimer(&m_ExpireCacheTimer,  m_CacheLifetime + CACHE_EXPIRATION_GANULARITY);
    m_fExpireCacheScheduled = TRUE;
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::TimeToExpireCacheEntries(CTimer* pTimer)
{
    CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>* pCache = 
        CONTAINING_RECORD(pTimer, CCache, m_ExpireCacheTimer);
    pCache->ExpirePeriodicCacheEnteries(pTimer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\appnotify.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    appNotify.cpp

Abstract:
    Application notification

Author:
    Uri Habusha (urih)

--*/


#include "stdh.h"
#include "Tm.h"
#include "Mtm.h"
#include <qmres.h>

#include "cqmgr.h"
#include "httpaccept.h"

#include <strsafe.h>
#include "qmacapi.h"

#include "appnotify.tmh"

extern HANDLE g_hAc;
extern HMODULE g_hResourceMod;

static WCHAR *s_FN=L"appnotify";

VOID
AppNotifyTransportClosed(
    LPCWSTR queueUrl
    )
{
    TmTransportClosed(queueUrl);
}


VOID
AppNotifyMulticastTransportClosed(
    MULTICAST_ID id
    )
{
    MtmTransportClosed(id);
}


const GUID&
McGetMachineID(
    void
    )
{
    return *CQueueMgr::GetQMGuid();
}


void
AppAllocatePacket(
    const QUEUE_FORMAT& destQueue,
    UCHAR delivery,
    DWORD pktSize,
    CACPacketPtrs& pktPtrs
    )
{
    ACPoolType acPoolType = (delivery == MQMSG_DELIVERY_RECOVERABLE) ? ptPersistent : ptReliable;
	bool fCheckMachineQuota = !QmpIsDestinationSystemQueue(destQueue);

    HRESULT hr = QmAcAllocatePacket(
            g_hAc,
            acPoolType,
            pktSize,
            pktPtrs,
            fCheckMachineQuota
            );

    if (SUCCEEDED(hr))
        return;

    TrERROR(GENERAL, "No more resources in AC driver. Error %xh", hr);

    LogHR(hr, s_FN, 10);
	
    throw exception();
}


void
AppFreePacket(
    CACPacketPtrs& pktPtrs
    )
{
	QmAcFreePacket(
				   pktPtrs.pDriverPacket, 
    			   0, 
    			   eDeferOnFailure);
}


void
AppAcceptMulticastPacket(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT& destQueue
    )
{
    HttpAccept(httpHeader, bodySize, body, &destQueue);
}



static 
BOOL
GetInstanceName(
	LPWSTR instanceName,
	DWORD size,
	...
	)
{
	WCHAR formatIntanceName[256];
	int rc;
	
	rc = LoadString(
			g_hResourceMod, 
			IDS_INCOMING_PGM_INSTANCE_NAME,
			formatIntanceName, 
			TABLE_SIZE(formatIntanceName)
			);
	
	if (rc == 0)
	{
		return FALSE;
	}

    va_list va;
    va_start(va, size);   

	DWORD NumOfTcharsCopied = FormatMessage(
				FORMAT_MESSAGE_FROM_STRING,
				formatIntanceName,
				0,
				0,
				instanceName,
				size,
				&va
				);

	va_end(va);

	if (NumOfTcharsCopied == 0)
	{
		DWORD gle = GetLastError();
	    TrERROR(GENERAL, "Could not create Instance name size=%d, Format=%ls, gle=%!winerr!", size, formatIntanceName, gle);
	    return FALSE;
	}
	else if (NumOfTcharsCopied == size)
	{
	    TrERROR(GENERAL, "Instance name size too small: size=%d, Format=%ls", size, formatIntanceName);
		return FALSE;		
	}

	return TRUE;
}


R<ISessionPerfmon>
AppGetIncomingPgmSessionPerfmonCounters(
	LPCWSTR strMulticastId,
	LPCWSTR remoteAddr
	)
{
	WCHAR instanceName[MAX_PATH];

	if (!GetInstanceName(instanceName, TABLE_SIZE(instanceName), strMulticastId,	remoteAddr))
	{
		//
		// Assign the multicast ID in case of failure to get the instance name
		//
		StringCchPrintf(instanceName, TABLE_SIZE(instanceName), L"%s", strMulticastId);
	}


	R<CInPgmSessionPerfmon> p = new CInPgmSessionPerfmon;
	p->CreateInstance(instanceName);
	
	return p;
}


void
AppConnectMulticast(
	void
	)
{
	if (QmpInitMulticastListen())
		return;

	throw exception();
}


void
AppRequeueMustSucceed(
	CQmPacket *pQMPacket
	)
{
	QmpRequeueMustSucceed(pQMPacket);
}


DWORD
AppGetBindInterfaceIp(
	void
	)
{
	return GetBindingIPAddress();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cgroup.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cgroup.h

Abstract:
    Handle AC group

Author:
    Uri Habusha (urih)

--*/

#ifndef __CQGroup__
#define __CQGroup__

#include <msi.h>
#include <rwlock.h>
#include "ex.h"

class CTransportBase;
class CQueue;
extern CCriticalSection    g_csGroupMgr;


class CQGroup : public IMessagePool
{
   public:
      CQGroup();
      ~CQGroup();

      VOID InitGroup(CTransportBase* pSession, BOOL fPeekByPriority) throw(std::bad_alloc);

      void Close(void);
	
      R<CQueue> PeekHead();

      HANDLE  GetGroupHandle() const;

      void EstablishConnectionCompleted(void);

      BOOL IsEmpty(void) const;

   public:
      static void MoveQueueToGroup(CQueue* pQueue, CQGroup* pcgNewGroup);
      

   public:
        // 
        // Interface function
        //
        void Requeue(CQmPacket* pPacket);
        void EndProcessing(CQmPacket* pPacket,USHORT mqclass);
        void LockMemoryAndDeleteStorage(CQmPacket * pPacket);


        void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs);
        void CancelRequest(void);
		virtual void OnRetryableDeliveryError();
		virtual void OnRedirected(LPCWSTR RedirectedUrl);
				
   private:
		HRESULT AddToGroup(CQueue* pQueue);
   		R<CQueue> RemoveFromGroup(CQueue* pQueue);
		void CleanRedirectedQueue();
		void CloseGroupAndMoveQueueToWaitingGroup(void);
		void MoveQueuesToWaitingGroup(void);
		void AddWaitingQueue(void);
		void CloseGroupAndMoveQueuesToNonActiveGroup(void);
		static void WINAPI CloseTimerRoutineOnLowResources(CTimer* pTimer);

   private:
	  mutable CReadWriteLock m_CloseGroup;  
      HANDLE              m_hGroup;
      CTransportBase*        m_pSession;
      CList<CQueue *, CQueue *&> m_listQueue;
	  bool m_fIsDeliveryOk;
	  bool m_fRedirected;

	  //
	  // Variables used when closing group
	  // These variables were added to support cases of low resources
	  //
	  std::vector< R<CQueue> > m_pWaitingQueuesVec;
	  	
	  //
	  // Timer used to retry close operation on low resource situations
	  //
	  CTimer m_LowResourcesTimer;

};

/*====================================================

Function:      CQGroup::GetGroupHandle

Description:   The routine returns the Group Handle

Arguments:     None

Return Value:  Group Handle

Thread Context:

=====================================================*/

inline HANDLE
CQGroup::GetGroupHandle() const
{
        return(m_hGroup);
}

inline
BOOL 
CQGroup::IsEmpty(
    void
    ) const
{
    return m_listQueue.IsEmpty();
}


#endif __CQGroup__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cdeferredexecutionlist.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    CDeferredExecutionList.h

Abstract:
    CDeferredExecutionList
    A safe (critical section protected), intrusive (see list.h) list that
    contains work items to be executed by a WorkerRoutine.

	An example of using this class is for packets that need to be freed and
	their ACFreePacket call failed

	CDeferredItemsPool
	A class the implements a pool for reserving deferred execution list itmes.
	This class is needed since sometimes when we want to defer an action, we
	need to allocate memory in order to add that item to the deferred execution list.
	Since the allocation may fail, we need to use a pool of preallocated items.
	

Author:
    Nir Ben-Zvi (nirb) 3-Jan-2002

Revision History:

--*/

/*++

  DESCRIPTION:
	A CDeferredExecutionList is used to queue items for deferred execution of a
	certain action.
	The template parameters include the List template parameters:
	1. Type of item
	2. Offset of the LIST_ENTRY in the item

	The construction parameters include:
	1. The DeferredExecutionRoutine to be called for the deferred execution
	2. The timeout for the timer invoked

	Once an item is inserted to the list, A timer is set. When the timer routine
	is invoked, it calls the ExecuteDefferedItems public routine which loops
	over the list and calls the DeferredExecutionRoutine for each item after
	removing it from the list.

	The DeferredExecutionRoutine executes the deferred action. If it fails it
	throws an exception.

--*/

#pragma once

#ifndef _CDEFERREDEXECUTIONLIST_H
#define _CDEFERREDEXECUTIONLIST_H

#include "list.h"
#include "cs.h"
#include "ex.h"

static const DWORD xDeferredExecutionTimeout = 1000;

//---------------------------------------------------------
//
//  class CDeferredExecutionList
//
//---------------------------------------------------------
template<class T, int Offset = FIELD_OFFSET(T, m_link)>
class CDeferredExecutionList {
public:

	typedef void (WINAPI *EXECUTION_FUNC)(T *pItem);
	
public:
    CDeferredExecutionList(
    			EXECUTION_FUNC pFunction,
    			DWORD dwTimeout = xDeferredExecutionTimeout
    			);
   	void ExecuteDefferedItems();

   	BOOL IsExecutionDone();

    void insert(T* pItem);

private:
	
	//
	// Disable copy ctor and assignment operator
	//
	CDeferredExecutionList(const CDeferredExecutionList&);
	CDeferredExecutionList& operator=(const CDeferredExecutionList&);

private:

	static void WINAPI DeferredExecutionTimerRoutine(CTimer* pTimer);

    void InsertInFront(T* pItem);

private:
	List<T, Offset> m_Items;
	CTimer m_Timer;
	DWORD m_dwTimeout;
	CCriticalSection m_cs;
	EXECUTION_FUNC m_pDeferredExecutionFunction;

	DWORD m_nExecutingThreads;
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------
template<class T, int Offset>
inline CDeferredExecutionList<T, Offset>::CDeferredExecutionList(
	EXECUTION_FUNC pFunction,
	DWORD dwTimeout = xDeferredExecutionTimeout
	) :
	m_Timer(DeferredExecutionTimerRoutine),
	m_dwTimeout(dwTimeout),
	m_cs(CCriticalSection::xAllocateSpinCount),
	m_pDeferredExecutionFunction(pFunction),
	m_nExecutingThreads(0)
{
    ASSERT(("A Deferred Execution Routine must be supplied", pFunction != NULL));
}


template<class T, int Offset>
inline void CDeferredExecutionList<T, Offset>::ExecuteDefferedItems(void)
/*++

Routine Description:
	Loop over the list and call the deferred execution routine

	Since this can be run by multiple threads, we also keep a counter
	indicating the number of concurrent items executing.
	This counter is used by the IsExecutionDone routine.

	We may leave this routine without executing all the items in one of two cases:
	1. One of the deferred execution items failed to execute
	2. Other threads are executing items and they did not finish yet
	

Arguments:
    None

Returned Value:
    None.

--*/
{
	{
		CS lock(m_cs);
		++m_nExecutingThreads;
	}
		
	for (;;)
	{
		T* pItem;

		//
		// Get the next item
		//
		{
			CS lock(m_cs);
			if(m_Items.empty())
			{
				--m_nExecutingThreads;
				return;
			}
				
			pItem = &m_Items.front();
			m_Items.pop_front();
		}

		//
		// Invoke the deferred execution function
		//
		try
		{
			m_pDeferredExecutionFunction(pItem);		
		}
		catch(const exception &)
		{
			//
			// The item was not executed, insert it back to front of the list (invokes the timer) and leave
			//
			CS lock(m_cs);
			InsertInFront(pItem);
			--m_nExecutingThreads;
			return;
		}
	}
}


template<class T, int Offset>
void
WINAPI
CDeferredExecutionList<T, Offset>::DeferredExecutionTimerRoutine(
    CTimer* pTimer
    )
/*++

Routine Description:
	A static function which is used as a timer routine for the
	CDeferredExecutionList class

Arguments:
    pTimer - A pointer to the timer object contained within a CDeferredExecutionList class.

Returned Value:
    None.

--*/
{
	//
	// Get the pointer to the CDeferredExecutionList  class
	//
    CDeferredExecutionList<T, Offset> *pList =
    	CONTAINING_RECORD(pTimer, CDeferredExecutionList, m_Timer);

	//
	// Retry the close operation
	//
	pList->ExecuteDefferedItems();
}


template<class T, int Offset>
inline BOOL CDeferredExecutionList<T, Offset>::IsExecutionDone(void)
{
	//
	// The execution is done when there are no more items in the list
	// and all the calls to the execution routine ended
	//
	CS lock(m_cs);
	if (m_Items.empty() && 0 == m_nExecutingThreads)
		return TRUE;

	return FALSE;
}


template<class T, int Offset>
inline void CDeferredExecutionList<T, Offset>::insert(T* item)
{
	//
	// Insert the item safetly and invoke a timer.
	//	
	CS lock(m_cs);
	m_Items.push_back(*item);
	if (!m_Timer.InUse())
	{
		ExSetTimer(&m_Timer, CTimeDuration::FromMilliSeconds(m_dwTimeout));
	}
}



template<class T, int Offset>
inline void CDeferredExecutionList<T, Offset>::InsertInFront(T* item)
{
	//
	// Insert the item safetly into the beginning of the list and invoke a timer.
	//	
	CS lock(m_cs);
	m_Items.push_front(*item);
	if (!m_Timer.InUse())
	{
		ExSetTimer(&m_Timer, CTimeDuration::FromMilliSeconds(m_dwTimeout));
	}
}


//---------------------------------------------------------
//
//  class CDeferredItemsPool
//
//---------------------------------------------------------
class CDeferredItemsPool {

public:
    struct CDeferredItem
    {
    	LIST_ENTRY m_link;

		union
		{
    		const void 		*ptr1;
    		CPacket     	*packet1;
    		CACGet2Remote   *pg2r;
    		void *const 	*pptr1;	
		} u1;
		
		union
		{
	    	DWORD 		dword1;
	    	USHORT		ushort1;
		} u2;


		union
		{
    		CPacket     	*packet2;
	    	LPOVERLAPPED overlapped1;
		} u3;

    	DWORD 		dword2;
    	HANDLE 		handle1;

#ifdef _DEBUG
    	DWORD m_Caller;  		// The calling function
    	DWORD m_CallerToCaller; // The caller to the calling function
    	DWORD m_CallerToCallerToCaller; // The caller to the calling function
#endif    	
    };

public:
    CDeferredItemsPool();
    ~CDeferredItemsPool();

    void ReserveItems(DWORD dwNumOfItemsToReserve);
    void UnreserveItems(DWORD dwNumOfItemsToUnreserve);

	CDeferredItem *GetItem();
	void ReturnItem(CDeferredItem *pItem);

private:
	
	//
	// Disable copy ctor and assignment operator
	//
	CDeferredItemsPool(const CDeferredItemsPool&);
	CDeferredItemsPool& operator=(const CDeferredItemsPool&);

private:
	CCriticalSection m_cs;

	List<CDeferredItem> m_Items;
	DWORD m_dwNumOfItemsInList;  // For debugging purposes
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------
inline CDeferredItemsPool::CDeferredItemsPool():
		m_dwNumOfItemsInList(0)
{
}


inline CDeferredItemsPool::~CDeferredItemsPool()
/*++

Routine Description:
	Free all the list items.

Arguments:
    None

Returned Value:
    None.

--*/
{
/*	
    //
	// No need to get the critical section in a destructor
	//

	
	//
	// Loop and free the items in the list
	//
	while (!m_Items.empty())
	{
		P<CDeferredItem> pItem = &m_Items.front();
		m_Items.pop_front();
		m_dwNumOfItemsInList--;
	}
*/
}


inline void CDeferredItemsPool::ReserveItems(DWORD dwNumOfItemsToReserve)
/*++

Routine Description:
	Add the reservation request to the number of items already reserved
	If there are not enough items in the pool, allocate additional items.

Arguments:
    dwNumOfItemsToReseve - The additional number of items to reserve

Returned Value:
    None.
    This function may throw a bad_alloc if the reservation fails.

--*/
{
	CS lock(m_cs);


	//
	// Adjust number of items in the list
	//
	DWORD dwItemsReserved = 0;
	try
	{
		for (dwItemsReserved = 0;
		     dwItemsReserved < dwNumOfItemsToReserve;
		     ++dwItemsReserved)
		{
			CDeferredItem *pItem = new CDeferredItem;
			m_Items.push_front(*pItem);
			m_dwNumOfItemsInList++;


#ifdef _DEBUG
#if  defined(_M_AMD64) || defined(_M_IA64)
			pItem->m_Caller = NULL;
			pItem->m_CallerToCaller = NULL;
			pItem->m_CallerToCallerToCaller = NULL;
#else
			try
			{
				union
				{
					DWORD *ptr1;
					DWORD **ptr2;
				} u;
				
				__asm
				{
					mov u.ptr1, ebp
				};
				pItem->m_Caller = *(u.ptr1+1);
				u.ptr1 = *u.ptr2;
				pItem->m_CallerToCaller = *(u.ptr1+1);
				u.ptr1 = *u.ptr2;
				pItem->m_CallerToCallerToCaller = *(u.ptr1+1);
			}
			catch (...)
			{
			}
#endif
#endif  // Debug			
		}
	}
	catch (const bad_alloc&)
	{
		//
		// Revert the allocations done
		//
		UnreserveItems(dwItemsReserved);
		
		throw;
	}
}


inline void CDeferredItemsPool::UnreserveItems(DWORD dwNumOfItemsToUnreserve)
/*++

Routine Description:
	Decrease the number of reserved items
	Adjust the number of items in the pool to the number of items reserved

Arguments:
    dwNumOfItemsToUnreserve - The number of items to decrease in the reservation

Returned Value:
    None.

--*/
{
	CS lock(m_cs);

	//
	// Adjust number of items in the list
	//
	for (DWORD dwItemsUnreserved = 0;
		 dwItemsUnreserved < dwNumOfItemsToUnreserve;
		 ++dwItemsUnreserved)
	{
		ASSERT(("We are expecting to find items to unreserve in the list", !m_Items.empty()));
		
		P<CDeferredItem> pItem = &m_Items.front();
		m_Items.pop_front();
		m_dwNumOfItemsInList--;
	}
}


inline CDeferredItemsPool::CDeferredItem *CDeferredItemsPool::GetItem()
/*++

Routine Description:
	Get an item from the pool.
	This also decreases the number of items to be reserved.
	The item will be released by a call to ReturnItem()
	
Arguments:
    None.

Returned Value:
    A pointer to the item

--*/
{
	CS lock(m_cs);
	ASSERT(("Excpecting at list one item in the pool", !m_Items.empty()));

	CDeferredItem* pItem = &m_Items.front();
	m_Items.pop_front();
	m_dwNumOfItemsInList--;

	return pItem;
}


inline void CDeferredItemsPool::ReturnItem(CDeferredItemsPool::CDeferredItem *pItem)
/*++

Routine Description:
	Return an item to the pool. The item was aquired by a call to GetItem
	The current implementation simply deletes the item.
	
Arguments:
    pItem - A pointer to the item.

Returned Value:
    None

--*/
{
	delete pItem;
}

#endif // _CDEFERREDEXECUTIONLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cgroup.cpp ===
//++
//
// Copyright (c) 1996 Microsoft Coroporation
//
// Module Name : cgroup.cpp
//
// Abstract    : Handle  AC group
//
// Module Autor: Uri Habusha
//
//--

#include "stdh.h"
#include "cgroup.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "qmutil.h"
#include "sessmgr.h"
#include <ac.h>
#include <mqexception.h>
#include "qmacapi.h"

#include "cgroup.tmh"

extern HANDLE g_hAc;
extern CQGroup * g_pgroupNonactive;
extern CQGroup * g_pgroupWaiting;
extern CSessionMgr SessionMgr;
CCriticalSection    g_csGroupMgr(CCriticalSection::xAllocateSpinCount);


static WCHAR *s_FN=L"cgroup";

const DWORD xLowResourceWaitingTimeout = 1000;


/*======================================================

Function:        CGroup::CGroup

Description:     Constructor.

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/
CQGroup::CQGroup():
    m_hGroup(NULL),
    m_pSession(NULL),
	m_fIsDeliveryOk(true),
	m_fRedirected(false),
	m_LowResourcesTimer(CloseTimerRoutineOnLowResources)
{
}


/*======================================================
Function:        CQGroup::OnRetryableDeliveryError

Description:     Called by mt.lib on retryable delivery error. This call will cause
                 the group to be moved to the wating list on destruction.

Arguments:       None

Return Value:    None
========================================================*/
void CQGroup::OnRetryableDeliveryError()
{
	m_fIsDeliveryOk = false;
}





/*======================================================

Function:        CQGroup::~CQGroup()

Description:     Deconstructor.
                 Using when closing a group due a closing of a session. As a result all the queue
                 in the group moving to non-active group and waiting for re-establishing of a
                 session.

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/

CQGroup::~CQGroup()
{
	ASSERT(("The group should be closed when calling the destructor",m_listQueue.IsEmpty()));
}


/*======================================================

Function:        CGroup::InitGroup

Description:     Constructor. Create a group in AC

Arguments:       pSession - Pointer to transport

Return Value:    None. Throws an exception.

Thread Context:

History Change:

========================================================*/
VOID 
CQGroup::InitGroup(
    CTransportBase * pSession,
    BOOL             fPeekByPriority
    ) 
    throw(bad_alloc)
{
   HRESULT rc = ACCreateGroup(&m_hGroup, fPeekByPriority);
   if (FAILED(rc))
   {
       m_hGroup = NULL;
       TrERROR(GENERAL, "Failed to create a group, ntstatus 0x%x", rc);
       LogHR(rc, s_FN, 30);
       throw bad_alloc();
   }

   //
   // Associate the group to completion port
   //
   ExAttachHandle(m_hGroup);
   
   if (pSession != NULL)
   {
       m_pSession = pSession;
   }
   
   TrTRACE(GENERAL, "Succeeded to create a group (handle %p) for new session", m_hGroup);
}


void CQGroup::Close(void)
/*++

Routine Description:
	This function is used when closing a group due a closing of a session. As a result all the queue
	in the group moving to non-active group and waiting for re-establishing of a
	session.

	If an exception is raised, we regard it as a low resources situation, increase our reference count
	and schedule a timer to retry the operation. This reference count will be decreased when
	the function invoked by the timer ends.


Arguments:
    None

Returned Value:
    None.

--*/
{
	try
	{
		if(!m_fRedirected)
		{
			CleanRedirectedQueue();
		}
		

		if (m_fIsDeliveryOk)
		{
			CloseGroupAndMoveQueuesToNonActiveGroup();
		}
		else
		{
			CloseGroupAndMoveQueueToWaitingGroup();
		}
	}
	catch(const exception&)
	{
		//
		// We are supposed to be in a low resources exception
		// Increase the reference count and schedule a timer to be called at a more relaxed (hopefully) time
		//
		CS lock(g_csGroupMgr);
		TrERROR(GENERAL, "An exception is treated as low resources. Scheduling a timer of %d ms to retry",xLowResourceWaitingTimeout);
		if (!m_LowResourcesTimer.InUse())
		{
			AddRef();  
			ExSetTimer(&m_LowResourcesTimer, CTimeDuration::FromMilliSeconds(xLowResourceWaitingTimeout));
		}
    }
}


void 
WINAPI
CQGroup::CloseTimerRoutineOnLowResources(
    CTimer* pTimer
    )
/*++

Routine Description:
	invoked when we failed to close the group.
	In that situation, we set a timer in order to retry the close
	operation

	NOTE that this is a static function.

Arguments:
    pTimer - A pointer to the timer object contained within a CQGroup class.

Returned Value:
    None.

--*/
{
	//
	// Get the pointer to the CQGroup timer class
	// NOTE that this auto release pointer releases the reference added when we activated the timer
	//      in CQGroup::Close
	//
    R<CQGroup> pGroup = CONTAINING_RECORD(pTimer, CQGroup, m_LowResourcesTimer);

	//
	// Retry the close operation
	//
	pGroup->Close();
}


void CQGroup::CleanRedirectedQueue()
{
	CS lock(g_csGroupMgr);

    POSITION  posInList = m_listQueue.GetHeadPosition();

	while(posInList != NULL)
    {
		CQueue* pQueue = m_listQueue.GetNext(posInList);
		pQueue->RedirectedTo(NULL);
	}
}

void CQGroup::CloseGroupAndMoveQueuesToNonActiveGroup(void)
{
	CS lock(g_csGroupMgr);

	POSITION  posInList = m_listQueue.GetHeadPosition();

	ASSERT(("If we got here we could not have been at CloseGroupAndMoveQueueToWaitingGroup",0 == m_pWaitingQueuesVec.capacity()));

	while(posInList != NULL)
	{
		//
		// Move the queue from the group to nonactive group
		//
		CQueue* pQueue = m_listQueue.GetNext(posInList);

		pQueue->SetSessionPtr(NULL);
		pQueue->ClearRoutingRetry();

		MoveQueueToGroup(pQueue, g_pgroupNonactive);
	}

	ASSERT(m_listQueue.IsEmpty());

	CancelRequest();
	m_pSession = NULL;
}


void CQGroup::OnRedirected(LPCWSTR RedirectedUrl)
{
	CS lock(g_csGroupMgr);

	POSITION  posInList = m_listQueue.GetHeadPosition();
	while(posInList != NULL)
	{
		CQueue* pQueue = m_listQueue.GetNext(posInList);
		pQueue->RedirectedTo(RedirectedUrl);	
	}
	m_fRedirected = true;
}


void CQGroup::CloseGroupAndMoveQueueToWaitingGroup(void)
/*++

Routine Description:
	This function moves all the queues in the group to the waiting group and also sets the
	timers for each queue in the group.

	NOTE that the routine keeps state to handle cases of low resources exceptions occuring while
	the routine is run. The state is kept in the m_listQueue and the following three class variables:
	m_pWaitingQueuesVec

Arguments:
    None

Returned Value:
    None.

--*/
{
	//
	// Allocate space to keep the queues that are passed to the waiting group. 
	// When we are done moving them to the waiting group, we should set a timer for each one
	// This is done seperately to avoid a deadlock since the critical section aquisition sequence is than other
	// places that aquire the same critical sections (g_csGroupMgr, m_csMapWaiting)
	// 
	if (0 == m_pWaitingQueuesVec.capacity())
	{
		DWORD size = m_listQueue.GetCount();
		m_pWaitingQueuesVec.reserve(size);
	}

	//
	// Move the queues to the waiting group
	//
	MoveQueuesToWaitingGroup();

	//
	// Move the queue to sessionMgr waiting queue list
	//
	AddWaitingQueue();
}

void CQGroup::MoveQueuesToWaitingGroup(void)
/*++

Routine Description:
	This function moves the queues to the waiting group 

	NOTE that the routine keeps state to handle cases of low resources exceptions occuring while
	the routine is run. The state is kept in the m_listQueue and the following three class variables:
	m_pWaitingQueuesVec
	
Arguments:
    None

Returned Value:
    None.

--*/
{
	CS lock(g_csGroupMgr);

	POSITION  posInList = m_listQueue.GetHeadPosition();

	while(posInList != NULL)
	{
		R<CQueue> pQueue = SafeAddRef(m_listQueue.GetNext(posInList));
		ASSERT(pQueue->GetGroup() != NULL);

		MoveQueueToGroup(pQueue.get(), g_pgroupWaiting);				

		//
		// Save the queue for the next step of scheduling a timer for each queue
		//
		ASSERT(("Queues were added to the group while closing it",m_pWaitingQueuesVec.size() != m_pWaitingQueuesVec.capacity()));
		m_pWaitingQueuesVec.push_back(pQueue);
		pQueue->IncRoutingRetry();
	}

	ASSERT(m_listQueue.IsEmpty());

	CancelRequest();
	m_pSession = NULL;
}


void CQGroup::AddWaitingQueue(void)
/*++

Routine Description:
	This function moves the queues previously added to the waiting group.
	into the sessionMgr waiting queue list. (The actions are not done together to avoid
	a potential dead lock)

	NOTE that the routine keeps state to handle cases of low resources exceptions occuring while
	the routine is run. The state is kept  the following three class variables:
	m_pWaitingQueuesVec

Arguments:
    None

Returned Value:
    None.

--*/
{
	while (m_pWaitingQueuesVec.size() > 0)
	{
		ASSERT(m_pWaitingQueuesVec.front().get() != NULL);

		SessionMgr.AddWaitingQueue(m_pWaitingQueuesVec.front().get());

		m_pWaitingQueuesVec.erase(m_pWaitingQueuesVec.begin());
	}
}


/*======================================================

Function:        CGroup::AddToGroup

Description:     Add Queue to a group

Arguments:       This function is called when a new queue is opened, a session is created
                 or session is closed. It is used to move queue from one group to another.

Return Value:    qHandle - Handle of the added queue

Thread Context:  None

History Change:

========================================================*/

HRESULT CQGroup::AddToGroup(CQueue *pQueue)
{
	//
	// Don't need to catch the CS. This function is internal and all the caller 
	// already catch the CS.
	//

	ASSERT(("queue handle can't be invalid", (pQueue->GetQueueHandle() != INVALID_HANDLE_VALUE)));
	ASSERT(("group handle can't be invalid", (m_hGroup != NULL)));

    //
    // Add the Handle to group list
    //
	R<CQueue> qr = SafeAddRef(pQueue);

	try
	{
		m_listQueue.AddHead(pQueue);
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to add queue %ls to the group list because of insufficient resources.", pQueue->GetQueueName());
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	//
	// Add the queue to AC group
	//
	HRESULT rc = ACMoveQueueToGroup(pQueue->GetQueueHandle(), m_hGroup);
	if (SUCCEEDED(rc))
	{
		//
		// Set The group
		//
		pQueue->SetGroup(this);

		//
		// Set The Group Session
		//
		pQueue->SetSessionPtr(m_pSession);

		TrTRACE(GENERAL, "Add Queue: %p to group %p", pQueue->GetQueueHandle(), m_hGroup);

		qr.detach();
		return rc;
	}

	TrERROR(GENERAL, "MQAC Failed to move queue %ls to group. Error 0x%x. Wait a second and try again", pQueue->GetQueueName(), rc);

    //
    // Failure can be insufficient resources or invalid device request when QM shuts down
    //
	LogHR(rc, s_FN, 991);
	ASSERT(rc == STATUS_INSUFFICIENT_RESOURCES || rc == STATUS_INVALID_DEVICE_REQUEST);

	m_listQueue.RemoveHead();

	return rc;
}


/*======================================================

Function:       CGroup::RemoveFromGroup

Description:    Remove queue from a group
                This function is called when a queue is closed and it
                is used to remove the queue from the current group.

Arguments:      qHandle - an Handle of the removed queue

Return Value:   The removed queue or null if not found

Thread Context:

History Change:

========================================================*/

R<CQueue> CQGroup::RemoveFromGroup(CQueue* pQueue)
{
   POSITION posInList = m_listQueue.Find(pQueue, NULL);
   if (posInList == NULL)
        return 0;
   
   m_listQueue.RemoveAt(posInList);

   return pQueue;
}


void CQGroup::MoveQueueToGroup(CQueue* pQueue, CQGroup* pcgNewGroup)
{
	CS lock(g_csGroupMgr);

	CQGroup* pcgOwner = pQueue->GetGroup();
	if (pcgOwner == pcgNewGroup)
	{
		return;
	}

	if (pcgNewGroup)
	{
		HRESULT rc = pcgNewGroup->AddToGroup(pQueue);
		if (FAILED(rc))
		{
			TrERROR(GENERAL, "Failed to add queue to group: %ls to group: %p  Return code:0x%x", pQueue->GetQueueName(), pcgNewGroup, rc);
			throw bad_hresult(rc);
		}
	}
	else
	{
		HRESULT rc = ACMoveQueueToGroup(pQueue->GetQueueHandle(), NULL);
		if (FAILED(rc))
		{
			TrERROR(GENERAL, "Failed in ACMoveQueueToGroup  queue: %ls to group: %p  Return code:0x%x", pQueue->GetQueueName(), pcgNewGroup, rc);
			throw bad_hresult(rc);
		}


		//
		// Set The group
		//
		pQueue->SetGroup(NULL);

		//
		// Set The Group Session
		//
		pQueue->SetSessionPtr(NULL);
	}
	
	if (pcgOwner != NULL)
	{
		R<CQueue> Queue = pcgOwner->RemoveFromGroup(pQueue);
		ASSERT(Queue.get() != NULL);
	}
}


/*====================================================

Function:      CQGroup::RemoveHeadFromGroup

Description:

Arguments:     None

Return Value:  pointer to cqueue object

Thread Context:

=====================================================*/

R<CQueue>  CQGroup::PeekHead()
{
   CS  lock(g_csGroupMgr);
   if ( m_listQueue.IsEmpty())
   {
   		return NULL;
   }

   return SafeAddRef(m_listQueue.GetHead());
}

/*======================================================

Function:        CQGroup::EstablishConnectionCompleted()

Description:     This function is used when the session is establish. It marks the queues
                 in the group as active. 

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/
void
CQGroup::EstablishConnectionCompleted(void)
{
    CS          lock(g_csGroupMgr);

    POSITION    posInList;
    CQueue*     pQueue;

    //
    // Check if there are any queue in the group
    //
    if (! m_listQueue.IsEmpty()) 
    {
        posInList = m_listQueue.GetHeadPosition();
        while (posInList != NULL)
        {
            //
            // the session becomes active. Clear the retry field in queue object
            //
            pQueue = m_listQueue.GetNext(posInList);

#ifdef _DEBUG
            if (pQueue->GetRoutingRetry() > 1)
            {
                //
                // print report message if we recover from a reported problem
                //
		        TrTRACE(GENERAL, "The message was successfully routed to queue %ls", pQueue->GetQueueName());
            }
#endif
            pQueue->ClearRoutingRetry();
        }
    }

    TrTRACE(GENERAL, "Mark all the queues in  group %p as active", m_hGroup);
 }


void
CQGroup::Requeue(
    CQmPacket* pPacket
    )
{
	QmpRequeueAndDelete(pPacket);
}


void 
CQGroup::EndProcessing(
    CQmPacket* pPacket,
	USHORT mqclass
    )
{
    QmAcFreePacket( 
    			   pPacket->GetPointerToDriverPacket(), 
    			   mqclass, 
    			   eDeferOnFailure);
}


void 
CQGroup::LockMemoryAndDeleteStorage(
    CQmPacket* pPacket
    )
{
    //
    // Construct CACPacketPtrs
    //
    CACPacketPtrs pp;
    pp.pPacket = NULL;
    pp.pDriverPacket = pPacket->GetPointerToDriverPacket();
    ASSERT(pp.pDriverPacket != NULL);

    //
    // Lock the packet mapping to QM address space (by add ref it)
    //
    HRESULT hr = QmAcGetPacketByCookie(g_hAc, &pp);
    if (FAILED(hr))
    {
		throw bad_hresult(hr);
    }

    //
    // Delete the packet from disk. It is still mapped to QM process address space.
    //
    QmAcFreePacket2(g_hAc, pPacket->GetPointerToDriverPacket(), 0, eDeferOnFailure);
}


void 
CQGroup::GetFirstEntry(
    EXOVERLAPPED* pov, 
    CACPacketPtrs& acPacketPtrs
    )
{
	CSR readlock(m_CloseGroup);

    acPacketPtrs.pPacket = NULL;
    acPacketPtrs.pDriverPacket = NULL;

	//
	// If group was closed just before
	//
	if(m_hGroup == NULL)
	{
		throw exception();
	}

    //
    // Create new GetPacket request from the queue
    //
    HRESULT rc = QmAcGetPacket(
                    GetGroupHandle(), 
                    acPacketPtrs, 
                    pov
                    );

    if (FAILED(rc) )
    {
        TrERROR(GENERAL, "Failed to  generate get request from group. Error %x", rc);
        LogHR(rc, s_FN, 40);
        throw exception();
    }
		
}

void CQGroup::CancelRequest(void)
{
	CSW writelock(m_CloseGroup);

    HANDLE hGroup = InterlockedExchangePointer(&m_hGroup, NULL);
    
    if (hGroup == NULL)
        return;


    HRESULT rc = ACCloseHandle(hGroup);
	if (FAILED(rc))
	{
		TrERROR(GENERAL, "Failed to close handle to group  Return code:0x%x", rc);
		throw bad_hresult(rc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cqmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqmgr.cpp

Abstract:

    Definition of the QM outbound queue manager

Author:

    Uri Habusha (urih)

--*/

#include "stdh.h"
#include <mqwin64a.h>
#include <mqformat.h>
#include <Msm.h>
#include <Mtm.h>
#include "cqmgr.h"
#include "qmthrd.h"
#include "cgroup.h"
#include "cqpriv.h"
#include "session.h"
#include "sessmgr.h"
#include <ac.h>
#include <mqsec.h>
#include "regqueue.h"
#include "qmutil.h"
#include "qmsecutl.h"
#include "fntoken.h"
#include "qal.h"
#include "xactout.h"
#include <fn.h>
#include <cry.h>
#include <xds.h>
#include <adsiutil.h>
#include <autohandle.h>
#include "qmds.h"
#include "ad.h"
#include <ntdsapi.h>
#include "qmacapi.h"

#include <strsafe.h>

#include "cqmgr.tmh"

extern HANDLE g_hAc;
extern HANDLE g_hMachine;
extern CQGroup * g_pgroupNonactive;
extern CQGroup * g_pgroupNotValidated;
extern CQGroup* g_pgroupDisconnected;
extern CQGroup* g_pgroupLocked;
extern LPTSTR g_szMachineName;
extern AP<WCHAR> g_szComputerDnsName;
extern CSessionMgr SessionMgr;
extern BOOL g_fWorkGroupInstallation;

static WCHAR *s_FN=L"cqmgr";



//
// Class for generating random stream data (base64 encoded) used by the sender
// for exacly once delivery in srmp protocol
//
class CSenderStreamFactory
{
public:
	const CSenderStream* Create()
	{
		UCHAR SenderStream[CSenderStream::x_MaxDataSize];
		CryGenRandom(
			SenderStream,
			sizeof(SenderStream)
			);

		DWORD base64Size;
		AP<char> pBase64 = Octet2Base64(
								SenderStream,
								sizeof(SenderStream),
								&base64Size
								);

		m_SenderStream = CSenderStream(
								(UCHAR*)pBase64.get(),
								base64Size
								);

		return &m_SenderStream;
	}

private:
	CSenderStream m_SenderStream;
};


LONGLONG g_NextSeqID;
inline void InitNextSeqID()
{
    //
    // Read previous SeqID from the registry
    // N.B. if GetFalconKeyValue fails, it does not change RegSeqID value
    //
    //
    DWORD Type = REG_DWORD;
    DWORD Size = sizeof(DWORD);

    DWORD RegSeqID = 0;
    GetFalconKeyValue(
        MSMQ_SEQ_ID_REGNAME,
        &Type,
        &RegSeqID,
        &Size
        );

    //
    // Increment by 1, so we will not use the same SeqID more than once in
    // successive boots.
    //
    ++RegSeqID;

    //
    // Select the max SeqID, Time or Registry. This overcomes date/time changes
    // on this computer.
    //
    DWORD TimeSeqID = MqSysTime();
    DWORD SeqID = max(RegSeqID, TimeSeqID);

    //
    // Write-back selected SeqID
    //
    SetFalconKeyValue(
        MSMQ_SEQ_ID_REGNAME,
        &Type,
        &SeqID,
        &Size
        );

    ((LARGE_INTEGER*)&g_NextSeqID)->HighPart = SeqID;

    TrWARNING(GENERAL, "QM sets starting SeqID: %x", RegSeqID);
}


inline LONGLONG GetNextSeqID()
{
    return ++g_NextSeqID;
}


inline BOOL IsPublicQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_PUBLIC);
}

inline BOOL IsPrivateQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE);
}

inline BOOL IsDirectQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
}

inline BOOL IsMachineQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_MACHINE);
}

inline BOOL IsConnectorQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_CONNECTOR);
}

inline BOOL IsNormalQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_NONE);
}

inline BOOL IsJournalQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_JOURNAL);
}

inline BOOL IsDeadXactQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_DEADXACT);
}

inline BOOL IsDeadLetterQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_DEADLETTER);
}

inline BOOL IsMulticastQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_MULTICAST);
}

inline DWORD MQAccessToFileAccess(DWORD dwAccess)
{
    DWORD dwFileAccess = 0;

    if (dwAccess & (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS))
    {
        dwFileAccess |= FILE_READ_ACCESS;
    }

    if (dwAccess & MQ_SEND_ACCESS)
    {
        dwFileAccess |= FILE_WRITE_ACCESS;
    }

    return dwFileAccess;
}


static CMap<GUID, const GUID&, bool, bool> ForeignMachineMap;

static bool IsForeignMachine(const GUID* pGuid)
{
	ASSERT(!QmpIsLocalMachine(pGuid));
	
	bool fForeign;
    if (ForeignMachineMap.Lookup(*pGuid, fForeign))
    	return fForeign;

    if(!CQueueMgr::CanAccessDS())
    	return false;

    PROPID aProp[1];
    PROPVARIANT aVar[1];

    aProp[0] = PROPID_QM_FOREIGN;
    aVar[0].vt = VT_NULL;

    HRESULT rc;
    rc = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,   // pwcsDomainController
					false,	// fServerName
                    pGuid,
                    TABLE_SIZE(aProp),
                    aProp,
                    aVar
					);
    if (FAILED(rc))
    	return false;

    fForeign = (aVar[0].bVal != MSMQ_MACHINE);
    ForeignMachineMap[*pGuid] = fForeign;
	return fForeign;
}


static
VOID
QMpUpdateMulticastBinding(
    const QUEUE_FORMAT * pQueueFormat,
    DWORD       cp,
    PROPID      aProp[],
    PROPVARIANT aVar[]
    )
{
    //
    // In Lockdown mode Do not make multicast listeners.
    //

    if(QueueMgr.GetLockdown())
    {
            TrTRACE(GENERAL, "Do not make multicast bindings in Lockdown mode");
            return;
    }
	
    //
    // Transactional queues ignore the multicast property.
    //
    // We either have the transactional queue property in the aProp argument,
    // or the queue is not transactional (in the case of create private queue), or
    // both the transactional and multicast properties are not in the aProp arguments
    // (in the case of handling DS notification from downlevel platforms).
    //
    for (DWORD ix = 0; ix < cp; ++ix)
    {
        if (aProp[ix] == PROPID_Q_TRANSACTION && aVar[ix].bVal)
        {
            TrTRACE(GENERAL, "Do not update multicast binding for transactional queue");
            return;
        }
    }

    for (DWORD ix = 0; ix < cp; ++ix)
    {
        if (aProp[ix] == PROPID_Q_MULTICAST_ADDRESS)
        {
            if (aVar[ix].vt == VT_EMPTY)
            {
                MsmUnbind(*pQueueFormat);
                return;
            }

            ASSERT(("VT must be VT_LPWSTR", aVar[ix].vt == VT_LPWSTR));
            ASSERT(("NULL not allowed", aVar[ix].pwszVal != NULL));
            ASSERT(("Empty string not allowed", L'\0' != *aVar[ix].pwszVal));

            MULTICAST_ID MulticastId;
            FnParseMulticastString(aVar[ix].pwszVal, &MulticastId);

            try
            {
                MsmBind(*pQueueFormat, MulticastId);
            }
            catch (const bad_win32_error& e)
            {
				LogIllegalPoint(s_FN, 2000);
			    EvReportWithError(MULTICAST_BIND_ERROR, e.error(), 1, aVar[ix].pwszVal);
            }

            return;
        }
    }
} // QMpUpdateMulticastBinding


/*======================================================

Function:      GetMachineProperty

Description:   query the database, and gets the MACHINE path name

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/
HRESULT GetMachineProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                           OUT PQueueProps    pQueueProp)
{
    ASSERT(IsMachineQueue(pQueueFormat));

    PROPID      aProp[3];
    PROPVARIANT aVar[3];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);
    HRESULT     rc = MQ_ERROR_NO_DS;

    aProp[0] = PROPID_QM_PATHNAME;
    aProp[1] = PROPID_QM_QUOTA;
    aProp[2] = PROPID_QM_JOURNAL_QUOTA;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI4;
    aVar[2].vt = VT_UI4;

    //
    // SP4, bug# 2962. postpone the MQIS initialization until it realy required
    //
    MQDSClientInitializationCheck();

    if (CQueueMgr::CanAccessDS())
    {
        rc = ADGetObjectPropertiesGuid(
                        eMACHINE,
                        NULL,   // pwcsDomainController
						false,	// fServerName
                        &pQueueFormat->MachineID(),
                        cProps,
                        aProp,
                        aVar
						);
    }

    pQueueProp->fJournalQueue = FALSE;
    pQueueProp->pQMGuid = new GUID;
    *pQueueProp->pQMGuid = pQueueFormat->MachineID();
    pQueueProp->fTransactedQueue = FALSE;
    pQueueProp->fIsLocalQueue = QmpIsLocalMachine(pQueueProp->pQMGuid);
    pQueueProp->fForeign = FALSE;

    if (SUCCEEDED(rc))
    {
        pQueueProp->lpwsQueuePathName = aVar[0].pwszVal;
        pQueueProp->dwQuota = aVar[1].ulVal;
        pQueueProp->dwJournalQuota = aVar[2].ulVal;
        pQueueProp->fUnknownQueueType = FALSE;
        if(!pQueueProp->fIsLocalQueue)
        {
		    pQueueProp->fForeign = IsForeignMachine(pQueueProp->pQMGuid);
        }
    }
    else
    {
        //
        // If we cannot connect to the DS, or we are working in a Workgroup environment,
        // and we deal with the local computer - try the registry.
        //
        if ((rc == MQ_ERROR_NO_DS || rc == MQ_ERROR_UNSUPPORTED_OPERATION) && (pQueueProp->fIsLocalQueue))
        {
            //
            // Retreive the machine properties from registery
            //
            pQueueProp->lpwsQueuePathName = newwcs(g_szMachineName);
            GetMachineQuotaCache(&(pQueueProp->dwQuota), &(pQueueProp->dwJournalQuota));
            rc = MQ_OK;
        }
        else
        {
            pQueueProp->lpwsQueuePathName = NULL;
            pQueueProp->dwQuota = 0;
            pQueueProp->dwJournalQuota = 0;
        }
    }

    return LogHR(rc, s_FN, 10);
}

/*======================================================

Function:      GetDSQueueProperty

Description:   query the database, and gets the DS Queue path name,
               Quata, QMID and Jornal

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/

HRESULT GetDSQueueProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                           OUT PQueueProps         pQueueProp)
{
    ASSERT(IsPublicQueue(pQueueFormat));
    HRESULT rc = MQ_ERROR_NO_DS ;
    BOOL fGotDSInfo = FALSE;

    PROPID aProp[12];
    PROPVARIANT aVar[12];
    ULONG  cProps = sizeof(aProp) / sizeof(PROPID);

    aProp[0] = PROPID_Q_PATHNAME;
    aProp[1] = PROPID_Q_JOURNAL;
    aProp[2] = PROPID_Q_QUOTA;
    aProp[3] = PROPID_Q_QMID;
    aProp[4] = PROPID_Q_JOURNAL_QUOTA;
    aProp[5] = PROPID_Q_BASEPRIORITY;
    aProp[6] = PROPID_Q_TRANSACTION;
    aProp[7] = PROPID_Q_AUTHENTICATE;
    aProp[8] = PROPID_Q_PRIV_LEVEL;
    aProp[9] = PROPID_Q_INSTANCE;
    //
    // Note the following property is supported by MSMQ 3.0 and higher in AD schema of
    // Whistler version and higher. In other cases our AD provider will return VT_EMPTY and MQ_OK.
    //
    aProp[10] = PROPID_Q_MULTICAST_ADDRESS;
    //
    // Note the following property is supported by MSMQ 2.0 and higher in AD schema of
    // Win2K version and higher. In other cases our AD provider will return MQ_ERROR.
    //
    aProp[11] = PROPID_Q_PATHNAME_DNS;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI1;
    aVar[2].vt = VT_UI4;
    aVar[3].vt = VT_NULL;
    aVar[4].vt = VT_UI4;
    aVar[5].vt = VT_I2;
    aVar[6].vt = VT_UI1;
    aVar[7].vt = VT_UI1;
    aVar[8].vt = VT_UI4;
    aVar[9].vt = VT_CLSID;
    aVar[10].vt = VT_NULL;
    aVar[11].vt = VT_NULL;

    GUID gQueueID;
    aVar[9].puuid = &gQueueID;

    //
    // SP4, bug# 2962. postpone the MQIS initialization until it realy required
    //
    MQDSClientInitializationCheck();

    if (CQueueMgr::CanAccessDS())
    {
        rc = ADGetObjectPropertiesGuid(
					eQUEUE,
					NULL,     // pwcsDomainController
					false,	  // fServerName
					&pQueueFormat->PublicID(),
					cProps,
					aProp,
					aVar
					);
        //
        //  MSMQ 1.0 DS server do not support PROPID_Q_PATHNAME_DNS
        //  and return MQ_ERROR in case of unsupported property.
        //  If such error is returned, assume MSMQ 1.0 DS and try again
        //  this time without PROPID_Q_PATHNAME_DNS.
        //
        if ( rc == MQ_ERROR)
        {
            aVar[11].vt = VT_EMPTY;
            ASSERT(aProp[cProps - 1] == PROPID_Q_PATHNAME_DNS);

            rc = ADGetObjectPropertiesGuid(
							eQUEUE,
							NULL,     // pwcsDomainController
							false,	  // fServerName
							&pQueueFormat->PublicID(),
							cProps - 1,
							aProp,
							aVar
							);
        }

        if (SUCCEEDED(rc))
        {
            //
            // We look for the enhanced key first, and ignore error.
            // If we are not able to get the base key, however, this is a real
            // problem. If it is because of NO_DS, the oper should fail (DS failed
            // between get props and GetSendQMKeyxPbKey). Otherwise, we will open
            // the queue and non-encrypted messages will work. We will try again on send
            // encrypted messages. (YoelA - 13-Jan-2000).
            // propagated to Whistler by DoronJ, apr-2000.
            //
            HRESULT rcEnhanced = GetSendQMKeyxPbKey( aVar[3].puuid,
                                                     eEnhancedProvider ) ;
            LogHR(rcEnhanced, s_FN, 2221);

            HRESULT rcBase = GetSendQMKeyxPbKey( aVar[3].puuid,
                                                 eBaseProvider );
            LogHR(rcBase, s_FN, 2220);

            if (SUCCEEDED(rcBase))
            {
                fGotDSInfo = TRUE;
            }
            else if (rcBase == MQ_ERROR_NO_DS)
            {
                rc = rcBase ;
            }
        }
    }

    if (rc == MQ_ERROR_NO_DS)
    {
        //
        // Cleanup aVar members that were dynamically allocated and get their cached values
        //

        if (aVar[0].vt == VT_LPWSTR)
        {
            delete [] aVar[0].pwszVal;
        }
        aVar[0].vt = VT_NULL;

        if (aVar[3].vt == VT_CLSID)
        {
            delete aVar[3].puuid;
        }
        aVar[3].vt = VT_NULL;

        if (aVar[10].vt == VT_LPWSTR)
        {
            delete [] aVar[10].pwszVal;
        }
        aVar[10].vt = VT_NULL;

        if (aVar[11].vt == VT_LPWSTR)
        {
            delete [] aVar[11].pwszVal;
        }
        aVar[11].vt = VT_NULL;

        rc = GetCachedQueueProperties(
                cProps,
                aProp,
                aVar,
                &pQueueFormat->PublicID()
                );
    }

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 20);
    }

    pQueueProp->lpwsQueuePathName = aVar[0].pwszVal;
    if ( aVar[11].vt != VT_EMPTY)
    {
        pQueueProp->lpwsQueueDnsName = aVar[11].pwszVal;
    }
    pQueueProp->fJournalQueue     = aVar[1].bVal;
    pQueueProp->dwQuota           = aVar[2].ulVal;
    pQueueProp->pQMGuid           = aVar[3].puuid;
    pQueueProp->dwJournalQuota    = aVar[4].ulVal;
    pQueueProp->siBasePriority    = aVar[5].iVal;
    pQueueProp->fIsLocalQueue     = QmpIsLocalMachine(pQueueProp->pQMGuid);
    pQueueProp->fTransactedQueue  = aVar[6].bVal;
    pQueueProp->fAuthenticate     = aVar[7].bVal;
    pQueueProp->dwPrivLevel       = aVar[8].ulVal;
    pQueueProp->fForeign = FALSE;
    if(!pQueueProp->fIsLocalQueue)
    {
	    pQueueProp->fForeign = IsForeignMachine(pQueueProp->pQMGuid);
    }
    pQueueProp->fUnknownQueueType = FALSE;


    if (pQueueProp->fIsLocalQueue && fGotDSInfo)
    {
        //
        // In case we got the proerties from the DS and this is a local queue, update the
        // public queue cache.
        //
        SetCachedQueueProp(&pQueueFormat->PublicID(),
                           cProps,
                           aProp,
                           aVar,
                           TRUE,
                           TRUE,
                           time(NULL));

        QMpUpdateMulticastBinding(pQueueFormat, cProps, aProp, aVar);
    }

    return MQ_OK;
}

/*======================================================

Function:      GetPrivateQueueProperty

Description:   query the database, and gets the private Queue path name,
               Quata, QMID and Jornal

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/
HRESULT GetPrivateQueueProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                                OUT PQueueProps         pQueueProp)
{
    ASSERT(IsPrivateQueue(pQueueFormat));

    PROPID      aProp[9];
    PROPVARIANT aVar[9];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);
    HRESULT     rc = MQ_OK;

    aProp[0] = PROPID_Q_PATHNAME;
    aProp[1] = PROPID_Q_JOURNAL;
    aProp[2] = PROPID_Q_QUOTA;
    aProp[3] = PROPID_Q_JOURNAL_QUOTA;
    aProp[4] = PROPID_Q_BASEPRIORITY;
    aProp[5] = PROPID_Q_TRANSACTION;
    aProp[6] = PPROPID_Q_SYSTEMQUEUE ;
    aProp[7] = PROPID_Q_AUTHENTICATE;
    aProp[8] = PROPID_Q_PRIV_LEVEL;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI1;
    aVar[2].vt = VT_UI4;
    aVar[3].vt = VT_UI4;
    aVar[4].vt = VT_I2;
    aVar[5].vt = VT_UI1;
    aVar[6].vt = VT_UI1;
    aVar[7].vt = VT_UI1;
    aVar[8].vt = VT_UI4;

    if (QmpIsLocalMachine(&pQueueFormat->PrivateID().Lineage))
    {
        //
        // Local Private Queue
        //
        rc = g_QPrivate.QMGetPrivateQueuePropertiesInternal(
                            pQueueFormat->PrivateID().Uniquifier,
                            cProps,
                            aProp,
                            aVar
                            );

        if (SUCCEEDED(rc))
        {
            pQueueProp->lpwsQueuePathName   = aVar[0].pwszVal;
            pQueueProp->fJournalQueue       = aVar[1].bVal;
            pQueueProp->dwQuota             = aVar[2].ulVal;
            pQueueProp->dwJournalQuota      = aVar[3].ulVal;
            pQueueProp->siBasePriority      = aVar[4].iVal;
            pQueueProp->fIsLocalQueue       = TRUE;
            pQueueProp->fTransactedQueue    = aVar[5].bVal;
            pQueueProp->fSystemQueue        = aVar[6].bVal;
            pQueueProp->fAuthenticate       = aVar[7].bVal;
            pQueueProp->dwPrivLevel         = aVar[8].ulVal;
            pQueueProp->fUnknownQueueType   = FALSE;
	    	pQueueProp->fForeign 	    = FALSE;
        }
    }
    else
    {
        {
            //
            // Create queue name "machine guid\queue id"
            //

            GUID_STRING strUuid;
            MQpGuidToString(&pQueueFormat->PrivateID().Lineage, strUuid);

			DWORD size = GUID_STR_LENGTH + 10;
            pQueueProp->lpwsQueuePathName = new WCHAR[size];
            rc = StringCchPrintf(
            			pQueueProp->lpwsQueuePathName,
            			size,
            			L"%s" FN_PRIVATE_SEPERATOR FN_PRIVATE_ID_FORMAT,
                        strUuid,
                        pQueueFormat->PrivateID().Uniquifier
                        );
			ASSERT(SUCCEEDED(rc));
        }
        pQueueProp->fIsLocalQueue = FALSE;
        pQueueProp->fJournalQueue = FALSE;
        pQueueProp->dwQuota = 0;
        pQueueProp->dwJournalQuota = 0;
        pQueueProp->siBasePriority = 0;
        pQueueProp->fTransactedQueue = FALSE;
        pQueueProp->fSystemQueue = FALSE ;
        pQueueProp->fAuthenticate = FALSE;
        pQueueProp->dwPrivLevel = MQ_PRIV_LEVEL_OPTIONAL;
        pQueueProp->fUnknownQueueType = TRUE;
		pQueueProp->fForeign = IsForeignMachine(&pQueueFormat->PrivateID().Lineage);

        //
        // If we send to a system queue then we want max priority.
        // All system queues on all machines have the same ID number
        // so check local machine to see if the ID is one of a system
        // queue and retrieve its base priority.
        //
        if (g_QPrivate.IsPrivateSysQueue(pQueueFormat->PrivateID().Uniquifier))
        {
            aProp[0] = PROPID_Q_BASEPRIORITY;
            aVar[0].vt = VT_I2;
            rc = g_QPrivate.GetPrivateSysQueueProperties(1, aProp, aVar);
            ASSERT(rc == MQ_OK) ;
            if (rc == MQ_OK)
            {
               pQueueProp->siBasePriority = aVar[0].iVal;
               pQueueProp->fSystemQueue = TRUE ;
            }
        }

        rc = MQ_OK ;
    }
    pQueueProp->pQMGuid = new GUID;
    *pQueueProp->pQMGuid = pQueueFormat->PrivateID().Lineage;

    if (SUCCEEDED(rc) && !pQueueProp->fIsLocalQueue)
    {
       //
       // Private queue on remote machine.
       //

       //
       // SP4, bug# 2962. postpone the MQIS initialization until it realy required
       //
       MQDSClientInitializationCheck();

       if (CQueueMgr::CanAccessDS())
       {
            //
            // We look for the enhanced key first, and ignore error.
            // If we are not able to get the base key, however, this is a real
            // problem. If it is because of NO_DS, the oper should fail (DS failed
            // between get props and GetSendQMKeyxPbKey). Otherwise, we will open
            // the queue and non-encrypted messages will work. We will try again on send
            // encrypted messages. (YoelA - 13-Jan-2000).
            // propagated to Whistler by DoronJ, apr-2000
            //
            HRESULT rcEnhanced = GetSendQMKeyxPbKey( pQueueProp->pQMGuid,
                                                     eEnhancedProvider ) ;
            LogHR(rcEnhanced, s_FN, 2231);

            HRESULT rcBase = GetSendQMKeyxPbKey( pQueueProp->pQMGuid,
                                                 eBaseProvider );
            LogHR(rcBase, s_FN, 2230);

            if (rcBase == MQ_ERROR_NO_DS)
            {
                rc = rcBase ;
            }
            else
            {
                rc = MQ_OK;
            }
       }
       else
       {
            //
            // Return this error to prevent premature routing.
            //
            rc = MQ_ERROR_NO_DS ;
       }
    }

    return LogHR(rc, s_FN, 30);
}

/*======================================================

Function:      GetConnectorQueueProperty

Description:

Arguments:

Return Value:

History Change:

========================================================*/
HRESULT
GetConnectorQueueProperty(
    const QUEUE_FORMAT* pQueueFormat,
    PQueueProps         pQueueProp
    )
{
    ASSERT(IsConnectorQueue(pQueueFormat));

    //
    // This code added as part of QFE 2738 that fixed connector
	// rcovery problem (urih, 3-Feb-98)
	//
    BOOL fXactOnly = (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_XACTONLY) ? TRUE : FALSE;
    {
        //
        // Create queue name "CONNECTOR=CN id"
        //
        GUID_STRING strUuid;
        MQpGuidToString(&pQueueFormat->ConnectorID(), strUuid);

        DWORD dwFormatNameSize = FN_CONNECTOR_TOKEN_LEN + 1 +  // L"CONNECTOR="
                                 GUID_STR_LENGTH +             // Connector Guid
                                 FN_DEADXACT_SUFFIX_LEN +      // L";XACTONLY"
                                 1;                            // L"\0'

        pQueueProp->lpwsQueuePathName = new WCHAR[dwFormatNameSize];

        HRESULT hr = StringCchPrintf(
			        		pQueueProp->lpwsQueuePathName,
			        		dwFormatNameSize,
			        		L"%s=%s",
			        		FN_CONNECTOR_TOKEN,
			        		strUuid
			        		);
		ASSERT(SUCCEEDED(hr));
		
        if (fXactOnly)
        {
            hr = StringCchCat(pQueueProp->lpwsQueuePathName, dwFormatNameSize, FN_DEADXACT_SUFFIX);
			ASSERT(SUCCEEDED(hr));
        }
    }
    pQueueProp->fJournalQueue     = FALSE;
    pQueueProp->dwQuota           = DEFAULT_Q_QUOTA;
    pQueueProp->pQMGuid           = NULL;
    pQueueProp->dwJournalQuota    = 0;
    pQueueProp->siBasePriority    = DEFAULT_Q_BASEPRIORITY;
    pQueueProp->fIsLocalQueue     = FALSE;
    pQueueProp->fTransactedQueue  = fXactOnly;
    pQueueProp->fConnectorQueue   = TRUE;
    pQueueProp->fForeign          = FALSE;
    pQueueProp->fUnknownQueueType = FALSE;


    if (!CQueueMgr::CanAccessDS())
    {
        return LogHR(MQ_ERROR_NO_DS, s_FN, 40);
    }
    //
    // Check if the machine belongs to such site
    //
    HRESULT hr;
    PROPID      aProp[1];
    PROPVARIANT aVar[1];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

    aProp[0] = PROPID_QM_SITE_IDS;
    aVar[0].vt = VT_NULL;
	
    hr = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,       // pwcsDomainController
					false,	    // fServerName
                    QueueMgr.GetQMGuid(),
                    cProps,
                    aProp,
                    aVar
					);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }


    BOOL fFound = FALSE;

    for(DWORD i = 0; i < aVar[0].cauuid.cElems; i++)
    {
        if (aVar[0].cauuid.pElems[i] == pQueueFormat->ConnectorID())
        {
            //
            //  verify that the site is indeed foreign
            //
            //  BUGBUG - to improve and call local routing cache
            //  instead of accessing the DS
            //      ronith june-00
            //
            PROPID propSite[]= {PROPID_S_FOREIGN};
            MQPROPVARIANT varSite[TABLE_SIZE(propSite)] = {{VT_NULL,0,0,0,0}};
            HRESULT hr1 = ADGetObjectPropertiesGuid(
                            eSITE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &aVar[0].cauuid.pElems[i],
                            TABLE_SIZE(propSite),
                            propSite,
                            varSite
							);
            if (FAILED(hr1))
            {
                break;
            }
            if (varSite[0].bVal == 1)
            {
                fFound = TRUE;
                break;
            }
        }
    }

    delete [] aVar[0].cauuid.pElems;

    if (fFound)
    {
        return MQ_OK;
    }
    else
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 60);
    }
}



/*======================================================

Function:      GetDirectQueueProperty

Description:   query the database, and gets the Direct Queue path name,
               Quata, QMID and Jornal

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/

HRESULT GetDirectQueueProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                               OUT PQueueProps         pQueueProp,
                               bool                    fInReceive,
                               bool                    fInSend
                               )
{
    ASSERT(IsDirectQueue(pQueueFormat));
    HRESULT     rc = MQ_OK;

    PROPID      aProp[10];
    PROPVARIANT aVar[10];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

    aProp[0] = PROPID_Q_PATHNAME;
    aProp[1] = PROPID_Q_JOURNAL;
    aProp[2] = PROPID_Q_QUOTA;
    aProp[3] = PROPID_Q_JOURNAL_QUOTA;
    aProp[4] = PROPID_Q_BASEPRIORITY;
    aProp[5] = PROPID_Q_TRANSACTION;
    aProp[6] = PROPID_Q_AUTHENTICATE;
    aProp[7] = PROPID_Q_PRIV_LEVEL;
    aProp[8] = PPROPID_Q_SYSTEMQUEUE;
    //
    // Note the following property is supported by MSMQ 3.0 and higher in AD schema of
    // Whistler version and higher. In other cases our AD provider will return VT_EMPTY and MQ_OK.
    //
    aProp[9] = PROPID_Q_MULTICAST_ADDRESS;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI1;
    aVar[2].vt = VT_UI4;
    aVar[3].vt = VT_UI4;
    aVar[4].vt = VT_I2;
    aVar[5].vt = VT_UI1;
    aVar[6].vt = VT_UI1;
    aVar[7].vt = VT_UI4;
    aVar[8].vt = VT_UI1;
    aVar[9].vt = VT_NULL;

    pQueueProp->fSystemQueue = FALSE ;
    pQueueProp->fForeign = FALSE;

    BOOL fLocal = IsLocalDirectQueue(pQueueFormat, fInReceive, fInSend) ;

    if (fLocal)
    {
		AP<WCHAR> lpwsQueuePathName;
		bool fPrivate;

		try
		{
			FnDirectIDToLocalPathName(
				pQueueFormat->DirectID(),
				g_szMachineName,
				lpwsQueuePathName
				);

			fPrivate = FnIsPrivatePathName(lpwsQueuePathName.get());
		}
		catch(const exception&)
		{
			return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 65);
		}


        //
        // Local Queue. Access the DB to reterive the queue properties
        //
        if (fPrivate)
        {
            //
            // Local private queue
            //
            ASSERT(aProp[ cProps - 2 ] == PPROPID_Q_SYSTEMQUEUE);
            ASSERT(aVar[ cProps - 2 ].vt == VT_UI1);

            rc = g_QPrivate.QMGetPrivateQueuePropertiesInternal(
                                                      lpwsQueuePathName.get(),
                                                      cProps,
                                                      aProp,
                                                      aVar );
            if (SUCCEEDED(rc))
            {
               pQueueProp->fSystemQueue = aVar[ cProps - 2 ].bVal;
            }
        }
        else
        {
            //
            // local DS queue
            //
            aProp[ cProps - 2 ] = PROPID_Q_INSTANCE;
            aVar[ cProps - 2 ].vt = VT_NULL;

            rc = MQ_ERROR_NO_DS;

            //
            // SP4, bug# 2962. postpone the MQIS initialization until it realy required
            //
            MQDSClientInitializationCheck();

            if (CQueueMgr::CanAccessDS())
            {
                rc = ADGetObjectProperties(
						eQUEUE,
						NULL,     // pwcsDomainController
						false,	  // fServerName
						lpwsQueuePathName.get(),
						cProps,
						aProp,
						aVar
						);

                if (SUCCEEDED(rc))
                {
                    //
                    // Update the public queue cache.
                    //
                    SetCachedQueueProp(aVar[cProps-2].puuid,
                                       cProps,
                                       aProp,
                                       aVar,
                                       TRUE,
                                       TRUE,
                                       time(NULL));

                    //
                    // Try to update queue properties in the queue manager.
                    // Build the queue format as public or private queue type, since bind/unbind
                    // to multicast group is done only for private or public queues (not direct).
                    //
                    QUEUE_FORMAT PublicQueueFormat(*aVar[cProps-2].puuid);
                    QMpUpdateMulticastBinding(&PublicQueueFormat, cProps, aProp, aVar);
                }
            }
            if (rc == MQ_ERROR_NO_DS)
            {
                rc = GetCachedQueueProperties( cProps,
                                               aProp,
                                               aVar,
                                               NULL,
                                               lpwsQueuePathName.get() ) ;
            }
            if (SUCCEEDED(rc))
            {
                pQueueProp->guidDirectQueueInstance = *(aVar[cProps-2].puuid);
                delete aVar[cProps-2].puuid;
            }
        }

        if (SUCCEEDED(rc))
        {
            pQueueProp->lpwsQueuePathName = aVar[0].pwszVal;
			
			bool fPrivate3;
			try
			{
				fPrivate3 = FnIsPrivatePathName(pQueueProp->lpwsQueuePathName);
			}
			catch(const exception&)
			{
				return MQ_ERROR_ILLEGAL_FORMATNAME;
			}

			//
			// Fill the private queue id.
			//
        	if (fPrivate3)
            {
	            rc = g_QPrivate.QMPrivateQueuePathToQueueId(
	            					pQueueProp->lpwsQueuePathName,
	            					&(pQueueProp->dwPrivateQueueId));
                TrTRACE(GENERAL, "Extracted private queue id: %d", pQueueProp->dwPrivateQueueId);
	        }

            pQueueProp->fJournalQueue = aVar[1].bVal;
            pQueueProp->dwQuota = aVar[2].ulVal;
            pQueueProp->dwJournalQuota = aVar[3].ulVal;
            pQueueProp->siBasePriority = aVar[4].iVal;
            pQueueProp->pQMGuid = new GUID;
            *pQueueProp->pQMGuid = *(CQueueMgr::GetQMGuid());
            pQueueProp->fIsLocalQueue = TRUE;
            pQueueProp->fTransactedQueue = aVar[5].bVal;
            pQueueProp->fAuthenticate = aVar[6].bVal;
            pQueueProp->dwPrivLevel = aVar[7].ulVal;
            pQueueProp->fUnknownQueueType = FALSE;

        }
    }

    if (!fLocal || (rc == MQ_ERROR_NO_DS))
    {
        //
        // Retreive the queue name from Queue Format direct name.
        // Store the name with the protocol type.
        //
        pQueueProp->lpwsQueuePathName = newwcs(pQueueFormat->DirectID());
        CharLower(pQueueProp->lpwsQueuePathName);

        pQueueProp->fIsLocalQueue = FALSE;
        pQueueProp->pQMGuid = new GUID;
        memset(pQueueProp->pQMGuid, 0, sizeof(GUID));
        pQueueProp->fJournalQueue = FALSE;
        pQueueProp->dwQuota = 0;
        pQueueProp->dwJournalQuota = 0;
        pQueueProp->siBasePriority = 0;
        pQueueProp->fTransactedQueue = FALSE;
        pQueueProp->fUnknownQueueType = TRUE;
	}

	//
	// If we send to a system queue then we want max priority.
	// All system queues on all machines have the same name
	// so check local machine to see if the name is one of a system
	// queue and retrieve its base priority.
	//
    if (!fLocal)
	{
		AP<WCHAR> lpwsQueuePathName;
		bool fPrivate2;

		try
		{
			FnDirectIDToLocalPathName(
				pQueueFormat->DirectID(),
				g_szMachineName,
				lpwsQueuePathName
				);

			fPrivate2 = FnIsPrivatePathName(lpwsQueuePathName.get());
		}
		catch(const exception&)
		{
			//
			// Give up boosting. Could not parse remote direct formatname
			//
			return MQ_OK;
		}

		if(!fPrivate2 || !g_QPrivate.IsPrivateSysQueue(lpwsQueuePathName.get()))
		{
			return MQ_OK;
		}

		//
		// Boost priority. Queue is a remote system queue.
		//

		aProp[0] = PROPID_Q_BASEPRIORITY;
		aVar[0].vt = VT_I2;
		HRESULT rc1 = g_QPrivate.GetPrivateSysQueueProperties(1,
													aProp,
													aVar ) ;
		ASSERT(rc1 == MQ_OK) ;
		if (rc1 == MQ_OK)
		{
			pQueueProp->siBasePriority = aVar[0].iVal;
			pQueueProp->fSystemQueue = TRUE ;
		}
	}

    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to get direct queue property. %!hresult!", rc);   
    } 

    return rc;
} // GetDirectQueueProperty


HRESULT
GetMulticastQueueProperty(
    const QUEUE_FORMAT* pQueueFormat,
    PQueueProps         pQueueProp
    )
{
    //
    // Must be multicast queue here
    //
    ASSERT(IsMulticastQueue(pQueueFormat));

    //
    // Set system and foreign properties
    //
    pQueueProp->fSystemQueue = FALSE ;
    pQueueProp->fForeign = FALSE;

    //
    // Set queue name
    //
    WCHAR QueueName[MAX_PATH];
    MQpMulticastIdToString(pQueueFormat->MulticastID(), QueueName, TABLE_SIZE(QueueName));
    CharLower(QueueName);
    pQueueProp->lpwsQueuePathName = newwcs(QueueName);

    //
    // Multicast queue is not local
    //
    pQueueProp->fIsLocalQueue = FALSE;

    //
    // Multicast queue has no meaningful guid
    //
    pQueueProp->pQMGuid = new GUID;
    memset(pQueueProp->pQMGuid,0,sizeof(GUID));

    //
    // Set journal and quota
    //
    pQueueProp->fJournalQueue = FALSE;
    pQueueProp->dwQuota = 0;
    pQueueProp->dwJournalQuota = 0;

    //
    // Multicast queue is not transactional
    //
    pQueueProp->siBasePriority = 0;
    pQueueProp->fTransactedQueue = FALSE;
    pQueueProp->fUnknownQueueType = FALSE;

    return MQ_OK;

} // GetMulticastQueueProperty


/*======================================================

Function:      QmpGetQueueProperties

Description:   query the database, and gets the QUEUE path name and
               destination machine

Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/
HRESULT
QmpGetQueueProperties(
    const QUEUE_FORMAT * pQueueFormat,
    PQueueProps          pQueueProp,
    bool                 fInReceive,
    bool                 fInSend
    )
{
    HRESULT rc = MQ_OK;

    FillMemory(pQueueProp, sizeof(QueueProps), 0);

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_MACHINE:
            rc = GetMachineProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            rc = GetDSQueueProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            rc = GetPrivateQueueProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            rc = GetDirectQueueProperty(pQueueFormat, pQueueProp, fInReceive, fInSend);
            break;

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            rc = GetConnectorQueueProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
            rc = GetMulticastQueueProperty(pQueueFormat, pQueueProp);
            break;

        default:
            ASSERT(0);
            rc = MQ_ERROR;
    }

    if (rc == MQ_ERROR_NO_DS)
    {
        pQueueProp->fUnknownQueueType = TRUE;
    }

    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to get queue properties. %!hresult!", rc);   
    }
    return rc;
} // QmpGetQueueProperties


/*======================================================

Function:      CQueueMgr::CQueueMgr

Description:   Constructor

Arguments:     None

Return Value:  None

Thread Context:

History Change:

========================================================*/

CQueueMgr::CQueueMgr() :
    m_fQueueCleanupScheduled(FALSE),
    m_QueueCleanupTimer(QueuesCleanup),
    m_cs(CCriticalSection::xAllocateSpinCount)
{
}

/*======================================================

Function:      CQueueMgr::~CQueueMgr

Description:   Deconstructor

Arguments:     None

Return Value:  None

Thread Context:

History Change:

========================================================*/


CQueueMgr::~CQueueMgr()
{
    m_MapQueueId2Q.RemoveAll();
}

/*======================================================

Function:       CQueueMgr::InitQueueMgr

Description:    Create the QM threads and AC services request

                The routine is called after the QM initialization passes successfully.
                The routine creates ACGetServiceRequest and create QM threads

Arguments:      None

Return Value:   TRUE if the AC services and QM threads create successfully. FALSE otherwise

Thread Context:

History Change:

========================================================*/

BOOL CQueueMgr::InitQueueMgr()
{
    HRESULT hr;

    //
    // Initialize private queue data structures
    //
    hr = g_QPrivate.PrivateQueueInit();

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 1020);
        return FALSE;
    }

    ASSERT(g_hAc != NULL);           //be sure the intilization pass o.k

    //
    // Create ACGetServiceRequest
    //
    HRESULT rc;
    QMOV_ACGetRequest* pAcRequestOv = new QMOV_ACGetRequest;
    rc = QmAcGetServiceRequest(
                        g_hAc,
                        &(pAcRequestOv->request),
                        &pAcRequestOv->qmov
                        );
    if(FAILED(rc))
    {
        delete pAcRequestOv;
        TrERROR(GENERAL, "Failed to get driver first service request. Error: %!status!", rc);
        return FALSE;
    }

    //
    // Set Queue clean-up timeout
    //
    DWORD dwDefaultVal;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    if (!IsRoutingServer())  //[adsrv]
    {
        //
        // In Client the default Release session timeout is 5 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_CLIENT_CLEANUP;
    }
    else
    {
        //
        // In FRS the default Release session timeout is 2 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_SERVER_CLEANUP;
    }

    DWORD dwCleanupTimeout;
    rc = GetFalconKeyValue(
            MSMQ_CLEANUP_INTERVAL_REGNAME,
            &dwType,
            &dwCleanupTimeout,
            &dwSize,
            (LPCTSTR)&dwDefaultVal
            );

    m_CleanupTimeout = CTimeDuration::FromMilliSeconds(dwCleanupTimeout);

    InitNextSeqID();

    dwType = REG_DWORD ;
    dwSize = sizeof(DWORD) ;
    dwDefaultVal = DEFAULT_MSMQ_IGNORE_OS_VALIDATION ;
    DWORD dwIgnore = DEFAULT_MSMQ_IGNORE_OS_VALIDATION ;

    rc = GetFalconKeyValue(
            MSMQ_IGNORE_OS_VALIDATION_REGNAME,
            &dwType,
            &dwIgnore,
            &dwSize,
            (LPCTSTR)&dwDefaultVal
            );
    m_bIgnoreOsValidation = (dwIgnore != 0) ;

    return(TRUE);
}



/*======================================================

Function:       IsRemoteReadAccess

Description:    Check that access is for get operation (receive/peek)
                the queue itself (no admin operation)

========================================================*/
#define MQ_GET_ACCESS  (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS)

inline
BOOL
IsRemoteReadAccess(
    DWORD dwAccess
    )
{
    return ((dwAccess & MQ_GET_ACCESS) && !(dwAccess & MQ_ADMIN_ACCESS));
}


/*======================================================

Function:       IsValidOpenOperation

Description:    Check that open operation is valid

Arguments:      pQueueFormat - pointer to QUEUE_FORMAT of open queue
                dqAccess - Access type

Return Value:   HRESULT

Thread Context:

History Change:

========================================================*/
HRESULT
IsValidOpenOperation(
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess
    )
{
    //
    // This code is not called when opening distribution queues
    //
    ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DL);

	//
	// Cannot open queue for receiving with http format name
	// unless this is an outgoing queue.
	//
	bool fReceiveAccess = ((dwAccess & MQ_RECEIVE_ACCESS) == MQ_RECEIVE_ACCESS);
	bool fPeekAccess = ((dwAccess & MQ_PEEK_ACCESS) == MQ_PEEK_ACCESS);
	bool fAdminAccess = ((dwAccess & MQ_ADMIN_ACCESS) == MQ_ADMIN_ACCESS);
	bool fHttpFormatName = ((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT)&&
							(FnIsHttpDirectID(pQueueFormat->DirectID())) );
							
    if ((fReceiveAccess || fPeekAccess) &&
    	(!fAdminAccess) &&
    	fHttpFormatName )
    {
    	TrERROR(GENERAL,"Cannot open queue: %ls for receiving with http format name", pQueueFormat->DirectID());
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;      
    }

    //
    // Check that journal queues and system queues are opened for read only
    //
    if ((!IsNormalQueueType(pQueueFormat)) && !(dwAccess & MQ_GET_ACCESS))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 100);
    }
    //
    // Check that Connector queues are opened for read only
    //
    if (IsConnectorQueue(pQueueFormat) && !(dwAccess & MQ_GET_ACCESS))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 110);
    }

    //
    // Check that Multicast queues are not opened for read, unless this is Admin access.
    //
    if (IsMulticastQueue(pQueueFormat) && (dwAccess & MQ_GET_ACCESS) != 0 && (dwAccess & MQ_ADMIN_ACCESS) == 0)
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 114);
    }

    return MQ_OK;
}


/*======================================================

Function:  HRESULT CQueueMgr::CreateQueueObject()

Description:

Arguments:
     DWORD  dwAccess - Queue Access mode. This value is 0 for "internal"
                       opens, i.e., queue openings because of recivery
                       or reception of packets.

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::CreateQueueObject(
    IN  const QUEUE_FORMAT* pQueueFormat,
    OUT CQueue**            ppQueue,
    IN  DWORD               dwAccess,
    OUT LPWSTR*             lplpwsRemoteQueueName,
    OUT BOOL*               pfRemoteReturn,
    IN  BOOL                fRemoteServer,
    IN  const GUID*         pgConnectorQM,
    IN  bool                fInReceive,
    IN  bool                fInSend,
	const CSenderStream* pSenderStream
    )
{
    HRESULT    rc;
    BOOL       fNoDS = FALSE;

    QueueProps qp;

    *ppQueue = NULL;

    if (pfRemoteReturn)
    {
        ASSERT(dwAccess != 0);
        *pfRemoteReturn = FALSE;
    }

    //
    // Get Queue Properties. Name and QMId
    //
    rc = QmpGetQueueProperties(pQueueFormat, &qp, fInReceive, fInSend);
    if (FAILED(rc))
    {
        if (rc == MQ_ERROR_NO_DS)
        {
            fNoDS = TRUE;
            if (pgConnectorQM)
            {
                ASSERT(qp.fUnknownQueueType);
                qp.fUnknownQueueType = FALSE;
                qp.fTransactedQueue = TRUE;
                qp.fForeign = TRUE;
            }
            else
            {
                if ((dwAccess == 0) || (dwAccess & MQ_SEND_ACCESS))
                {
                    ASSERT(qp.fUnknownQueueType);
                }
                else
                {
                    TrERROR(GENERAL, "::CreateQueueObject failed, mqstatus %x", rc);
                    return LogHR(rc, s_FN, 120);
                }
            }
        }
        else
        {
            TrERROR(GENERAL, "::CreateQueueObject failed, mqstatus %x", rc);
            return rc;
        }
    }

    if (pfRemoteReturn   && lplpwsRemoteQueueName &&
       !qp.fIsLocalQueue && !qp.fConnectorQueue)
    {
        //
        // Open for Remote read (first call on client side).
        // Return path name so RT can find remote server name and call
        // it for remote open.
        //
        if(IsRemoteReadAccess(dwAccess))
        {
            ASSERT(!fRemoteServer);
            ASSERT(!(dwAccess & MQ_SEND_ACCESS));
			ASSERT(lplpwsRemoteQueueName != NULL);
            HRESULT rc = MQ_OK;

            if ((pQueueFormat->GetType()) == QUEUE_FORMAT_TYPE_PRIVATE)
            {
                if (qp.lpwsQueuePathName)
                {
                    delete qp.lpwsQueuePathName;
                    qp.lpwsQueuePathName = NULL;
                    ASSERT( qp.lpwsQueueDnsName == NULL);
                }
                //
                // Remote read from privat queue.
                // Get remote machine name from DS.
                //
                PROPID      aProp[2];
                PROPVARIANT aVar[2];
                rc = MQ_ERROR_NO_DS;

                aProp[0] = PROPID_QM_PATHNAME;
                aVar[0].vt = VT_NULL;
                aProp[1] = PROPID_QM_PATHNAME_DNS;  // should be last
                aVar[1].vt = VT_NULL;

                if (CQueueMgr::CanAccessDS())
                {
                    rc = ADGetObjectPropertiesGuid(
								eMACHINE,
								NULL,    // pwcsDomainController
								false,	 // fServerName
								qp.pQMGuid,
								2,
								aProp,
								aVar
								);
                    //
                    //  MSMQ 1.0 DS server do not support PROPID_QM_PATHNAME_DNS
                    //  and return MQ_ERROR in case of unsupported property.
                    //  If such error is returned, assume MSMQ 1.0 DS and try again
                    //  this time without PROPID_QM_PATHNAME_DNS.
                    //
                    if ( rc == MQ_ERROR)
                    {
                        aVar[1].vt = VT_EMPTY;
                        ASSERT( aProp[1] ==  PROPID_QM_PATHNAME_DNS);

                        rc = ADGetObjectPropertiesGuid(
									eMACHINE,
									NULL,    // pwcsDomainController
									false,	 // fServerName
									qp.pQMGuid,
									1,   // assuming DNS property is last
									aProp,
									aVar
									);
                    }
                    if (SUCCEEDED(rc))
                    {
                        qp.lpwsQueuePathName = aVar[0].pwszVal;
                        if ( aVar[1].vt != VT_EMPTY)
                        {
                            qp.lpwsQueueDnsName = aVar[1].pwszVal;
                        }
                    }
                }
            }

            if (SUCCEEDED(rc))
            {
                ASSERT(qp.lpwsQueuePathName);
                if ( qp.lpwsQueueDnsName != NULL)
                {
                    *lplpwsRemoteQueueName = qp.lpwsQueueDnsName.detach();
					delete[]  qp.lpwsQueuePathName;
					qp.lpwsQueuePathName = NULL;
                }
                else
                {
                    *lplpwsRemoteQueueName = qp.lpwsQueuePathName;
                }

				TrTRACE(RPC, "Open RemoteRead client First call, RemoteQueueName = %ls", *lplpwsRemoteQueueName);
                *pfRemoteReturn = TRUE;
            }

            //
            // Clean up queue properties. (usually this is done in
            // CQueue destructor, but here we don't create a CQueue
            // object).
            //
            if (qp.pQMGuid)
            {
                delete qp.pQMGuid;
            }
            if (FAILED(rc))
            {
                if (qp.lpwsQueuePathName)
                {
                    delete qp.lpwsQueuePathName;
                }
                *lplpwsRemoteQueueName = NULL;
                *pfRemoteReturn = FALSE;
            }

            return LogHR(rc, s_FN, 140);
        }
        else if ((dwAccess & MQ_ADMIN_ACCESS) == MQ_ADMIN_ACCESS)
        {
            //
            // Bug 8765.
            // Trying to open a remote journal queue with ADMIN access.
            // this is not supported. If you want to purge a remote
            // journal queue, then open it just with MQ_RECEIVE_ACCESS and
            // then call MQPurgeQueue.
            // Same fix for remote deadletter/xactdead queues.
            //
            BOOL fBadQueue = IsJournalQueueType(pQueueFormat)  ||
                             IsDeadXactQueueType(pQueueFormat) ||
                             IsDeadLetterQueueType(pQueueFormat);
            if (fBadQueue)
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 390);
            }
        }
    }
    else if (fRemoteServer && !qp.fIsLocalQueue && !qp.fConnectorQueue)
    {
        ASSERT(!lplpwsRemoteQueueName);
        if (dwAccess & MQ_GET_ACCESS)
        {
            //
            // We're on server side of remote read but queue is not local.
            // This weird situation can happen (at least) in the following
            // cases:
            // 1. The machine is dual boot. Each configuration has its own
            //    QM but both configurations have same address.
            //    So request to remote read machine A reach
            //    machine B, which physically are the same.
            // 2. Remote machine is in another site. when it process this
            //    request it's offline and the queue is not registered in
            //    its local registry.
            //
            if (qp.pQMGuid)
            {
                delete qp.pQMGuid;
            }
            if (qp.lpwsQueuePathName)
            {
                delete qp.lpwsQueuePathName;
            }
            return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 150);
        }
        else
        {
            //
            // Why did we reach here ??? BUGBUGBUGBUG
            //
            ASSERT(0);
        }
    }

	R<CQueue> pQueue = new CQueue(
								pQueueFormat,
								INVALID_HANDLE_VALUE,
								&qp,
								fNoDS
								);

	//
    // Set the Connector QM ID
    //
    rc = pQueue->SetConnectorQM(pgConnectorQM);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 160);
    }

	CS lock(m_cs);
	
	try
	{
		//
	    // Check if the queue is not already in hash.
	    //
		CQueue* pQueueTemp = NULL;
	    BOOL fLookup = LookUpQueue(pQueueFormat, &pQueueTemp, fInReceive, fInSend);
	    if (fLookup)
	    {
			*ppQueue = pQueueTemp;
			return MQ_OK;
	    }
	
	    //
	    // As a machine queue handle, sets the AC handle
	    //
	    if ((dwAccess != 0) && IsMachineQueue(pQueueFormat))
	    {
	        BOOL fSuccess;
	        HANDLE hDup;
	        fSuccess = MQpDuplicateHandle(
	                    GetCurrentProcess(),
	                    g_hMachine,
	                    GetCurrentProcess(),
	                    &hDup,
	                    0,      // desired access
	                    FALSE,  // inheritance
	                    DUPLICATE_SAME_ACCESS
	                    );

	        if(!fSuccess)
	        {
	            //
	            // Duplicate must succeed since we use the same process. The only reason
	            // for failure is insufficient resources
	            //
	            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 170);
	        }

	        pQueue->SetQueueHandle(hDup);
	    }
	    else
	    {
	        //
	        // Create AC queue and set the Queue Handle
	        //
	        rc = CreateACQueue(pQueue.get(), pQueueFormat,pSenderStream);

	        if(FAILED(rc))
	        {
	            TrERROR(DS, "ACCreateQueue failed, mqstatus %x;", rc);
	            return rc;
	        }

	        //
	        // If the Queue isn't Local, Add queue to non active group
	        //
	        if (!qp.fIsLocalQueue && !IsRemoteReadAccess(dwAccess))
	        {
	            if (fNoDS)
	            {
					CQGroup::MoveQueueToGroup(pQueue.get(), g_pgroupNotValidated);
	            }
	            else  if (!qp.fConnectorQueue)
	            {
					CQGroup::MoveQueueToGroup(pQueue.get(), g_pgroupNonactive);
	            }
	        }
	    }

		//
	    // Add queue to QM internal DB
	    //
	    AddQueueToHashAndList(pQueue.get());
		*ppQueue = pQueue.detach();
	    return MQ_OK;
	}
	catch(const bad_hresult& e)
	{
		RemoveQueue(pQueue.get());

    	rc = e.error();
		return LogHR(rc, s_FN, 181);
    }
	catch(const exception&)
	{
		RemoveQueue(pQueue.get());
		return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 182);
	}


}


/*======================================================

Function:  HRESULT CQueueMgr::OpenQueue()

Description:

Arguments:
        BOOL fRemoteServer- TRUE on server side of remote-read.

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::OpenQueue(
    const QUEUE_FORMAT * pQueueFormat,
    DWORD              dwCallingProcessID,
    DWORD              dwAccess,
    DWORD              dwShareMode,
    CQueue * *         ppQueue,
    LPWSTR *           lplpwsRemoteQueueName,
    PHANDLE            phQueue,
	BOOL*              pfRemoteReturn,
    BOOL               fRemoteServer /* = FALSE */
    )
{
    CQueue*   pQueue = NULL;

	if(pfRemoteReturn)
	{
		*pfRemoteReturn = FALSE;
	}
	
	QUEUE_FORMAT_TRANSLATOR  RealDestinationQueue(pQueueFormat, CONVERT_SLASHES | MAP_QUEUE);
    BOOL      fJournalQueue = IsJournalQueueType(RealDestinationQueue.get());

    HRESULT rc = IsValidOpenOperation(RealDestinationQueue.get(), dwAccess);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 190);
    }

    if(IsDirectQueue(RealDestinationQueue.get()))
    {
        BOOL fLocal = IsLocalDirectQueue(RealDestinationQueue.get(), false, false) ;

        if (fLocal && RealDestinationQueue.get()->IsSystemQueue())
        {
            //
            // This is a local machine queue
            //
            QUEUE_SUFFIX_TYPE qst = RealDestinationQueue.get()->Suffix();
            RealDestinationQueue.get()->MachineID(*GetQMGuid());
            RealDestinationQueue.get()->Suffix(qst);
        }
    }

    //
    // Check if the queue already exist
    //
    BOOL fQueueExist = LookUpQueue(RealDestinationQueue.get(), &pQueue, false, false);
    R<CQueue> Ref = pQueue;

    if (fQueueExist)
    {
        if (pQueue->QueueNotValid())
        {
            //
            // This case happens when a queue was originally opened when
            // MQIS server was offline. Later, when MQIS becomes available,
            // it was determined that the open operation was not valid.
            //
            return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 210);
        }

        if (!pQueue->IsLocalQueue() && !pQueue->IsConnectorQueue())
        {
            if(IsRemoteReadAccess(dwAccess))
            {
                //
                // Remote reader. (first call on client side). Turn the Exist
                // flag to FALSE so CreateQueueObject is create to retrieve
                // full path of remote queue.
                //
                Ref.free();
                fQueueExist = FALSE;
            }
        }
    }

    //
    // If first time the queue is opened than create queue object
    //
    if (!fQueueExist)
    {
        ASSERT(Ref.get() == 0);

		BOOL fRemoteReturn;
        rc = CreateQueueObject(
				RealDestinationQueue.get(),
				&pQueue,
				dwAccess,
				lplpwsRemoteQueueName,
				&fRemoteReturn,
				fRemoteServer,
				0,
				false,
                false,
                NULL
				);
        if(FAILED(rc))
        {
        	TrERROR(GENERAL, "Failed to create a queue object. %!hresult!", rc);   
        }

        if (fRemoteReturn || FAILED(rc))
        {
			if(fRemoteReturn)
			{
				ASSERT(pfRemoteReturn != NULL);
				*pfRemoteReturn = fRemoteReturn;
			}
    	
            ASSERT(pQueue == 0);
            return rc;
        }

        Ref = pQueue;

		TrTRACE(GENERAL, "Created queue object for queue: %ls", pQueue->GetQueueName());
    }

	//
    // we should not reach here under these conditions.
    // We should be in ::OpenRRQueue() instead.
    //
	ASSERT(!IsRemoteReadAccess(dwAccess) || pQueue->IsLocalQueue() || pQueue->IsConnectorQueue());
	
	HANDLE hQueue = pQueue->GetQueueHandle();
	ASSERT(hQueue);
	
    //
    // If dwCallingProcessID is NULL no handle duplication is required
    //
    if (dwCallingProcessID == NULL)
    {
		if (ppQueue)
		{
     		*ppQueue = Ref.detach();
		}

        if (phQueue != NULL)
        {
            *phQueue = hQueue;
        }
        return MQ_OK;
    }

    //
    // Verify that the user has permissions to open
    // the queue in the desired access.
    //
    rc = VerifyOpenPermission(
            pQueue,
            RealDestinationQueue.get(),
            dwAccess,
            fJournalQueue,
            pQueue->IsLocalQueue()
            );

    //
    // If the queue is marked as Unknown queue type it means it opens without
    // DS. In such a case we don't have security descriptor and we can't check
    // access permision
    //
    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 230);
    }

    HANDLE hAcQueue;
    rc = ACCreateHandle(&hAcQueue);
    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 240);
    }

    if(fJournalQueue)
    {
        rc = ACAssociateJournal(
                hQueue,
                hAcQueue,
                dwAccess,
                dwShareMode
                );
    }
    else if(IsDeadXactQueueType(RealDestinationQueue.get()))
    {
        rc = ACAssociateDeadxact(
                hQueue,
                hAcQueue,
                dwAccess,
                dwShareMode
                );
    }
    else
    {
        bool fProtocolSrmp = (FnIsDirectHttpFormatName(RealDestinationQueue.get()) ||
                              IsMulticastQueue(RealDestinationQueue.get()));
        rc = ACAssociateQueue(
                hQueue,
                hAcQueue,
                dwAccess,
                dwShareMode,
                fProtocolSrmp
                );
    }

    if(FAILED(rc))
    {
        ACCloseHandle(hAcQueue);
        return LogHR(rc, s_FN, 250);
    }

    CHandle hCallingProcess = OpenProcess(
                                PROCESS_DUP_HANDLE,
                                FALSE,
                                dwCallingProcessID
                                );

    if(hCallingProcess == 0)
    {
        ACCloseHandle(hAcQueue);
        TrERROR(GENERAL, "Cannot open calling process in OpenQueue, error %d", GetLastError());
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 260);
    }

    HANDLE hDupQueue;
    BOOL fSuccess;
    fSuccess = MQpDuplicateHandle(
                GetCurrentProcess(),
                hAcQueue,
                hCallingProcess,
                &hDupQueue,
                MQAccessToFileAccess(dwAccess),
                TRUE,
                DUPLICATE_CLOSE_SOURCE
                );

    if(!fSuccess)
    {
        //
        // The handle hAcQueue is closed regardless of error code
        //

        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 270);
    }

    ASSERT(phQueue != NULL);
    *phQueue = hDupQueue;
	if (ppQueue)
	{
		*ppQueue = Ref.detach();
	}
	
    return MQ_OK;

} // CQueueMgr::OpenQueue


/*======================================================

Function:    ValidateOpenedQueues()

Description: Validate a queue which was opened while working offline,
             without a MQIS server.
             We only check that the queue exist in the database and
             retrieve its properties.
             We can't validate permissions because we may now run in
             a security context which is different than the one when
             sending the message. (assume userA was logged on while
             offline, sent a message, then logged on as userB and
             connect the network).
             Security will be checked on the receiving side, as it is
             done with recovered packets after boot.

========================================================*/
static LONG s_fActiveValidateOpenedQueue = FALSE;

void CQueueMgr::ValidateOpenedQueues()
{
	if (InterlockedExchange(&s_fActiveValidateOpenedQueue,  TRUE))
	{
		//
		// There is another thread that already validates the opened queue
		//
		return;
	}

	try
	{
		for(;;)
		{
			HRESULT rc;
			R<CQueue> pQueue;

			{
				CS lock(m_cs);
				pQueue = g_pgroupNotValidated->PeekHead();
			}

			if (pQueue.get() == NULL)
			{
				  InterlockedExchange(&s_fActiveValidateOpenedQueue,  FALSE);					
				  return;
			}

	  		ASSERT(("Multicast queue should not be in NotValidate group", (pQueue->GetQueueType() != QUEUE_TYPE_MULTICAST)));

	  		TrTRACE(GENERAL, "Validating Queue '%ls', Type = %d", pQueue->GetQueueName(), pQueue->GetQueueType());

			if (pQueue->GetRoutingRetry() != 0)
			{
				//
				// If routing retry isn't 0, we reach here due NO_DS error during the
				// create connection. It means that the Queue properties is already
				// verified and we used the not validated group as a temporary group until
				// the DS becomes online and routing information can be retreived from
				// the DS.
				//
			  	pQueue->ClearRoutingRetry();
			  	CQGroup::MoveQueueToGroup(pQueue.get(), g_pgroupNonactive);
				continue;
			}

			//
			// Get Queue Properties. Name and QMId
			//
			QueueProps qp;
			QUEUE_FORMAT qf = pQueue->GetQueueFormat();
			rc = QmpGetQueueProperties(&qf, &qp, false, false);

			if (FAILED(rc))
			{
				//
				// DS offline again. Return the queue to the list and
				// untill DS be online again
				//
				if (rc == MQ_ERROR_NO_DS)
				{
				  InterlockedExchange(&s_fActiveValidateOpenedQueue,  FALSE);					
				  return;
				}

				TrERROR(GENERAL, "Failed to retreive queue properties for queue '%ls', hr = %!hresult!", pQueue->GetQueueName(), rc);
				pQueue->SetQueueNotValid();
				continue;
			}

			if (qp.fIsLocalQueue)
			{
				//
				// When offline, local queues are supposed to be open by using
				// cache in registry. We'll reach this point if registry is not
				// up-to-date (notification get lost). We previously (when offline)
				// opened the queue as non-local and now that we have DS we found
				// it's local. At present we don't handle such change in state
				// and we just mark the queue as not valid.
				//
				TrERROR(GENERAL, "Mark local queue '%ls' as not valid", pQueue->GetQueueName());
				pQueue->SetQueueNotValid() ;
				delete qp.pQMGuid;
				continue;
			}

			if (pQueue->IsConnectorQueue())
			{
			 	CQGroup::MoveQueueToGroup(pQueue.get(), NULL);
			 	continue;
			}

			ASSERT(qp.lpwsQueuePathName ||
			   (pQueue->GetQueueType() != QUEUE_TYPE_PUBLIC)) ;

			if (pQueue->GetQueueName() == NULL)
			{
				pQueue->SetQueueName((TCHAR*)qp.lpwsQueuePathName) ;
				pQueue->PerfUpdateName();
				if (pQueue->GetQueueName() != NULL)
				{
		   			CS lock(m_cs);
					m_MapName2Q[pQueue->GetQueueName()] = pQueue.get();
				}
			}
			else
			{
				ASSERT(wcscmp(qp.lpwsQueuePathName, pQueue->GetQueueName()) == 0);
			}

			pQueue->InitQueueProperties(&qp) ;
			//
			// Update the connector QM.
			//
			rc = pQueue->SetConnectorQM();
			if (FAILED(rc))
			{
				InterlockedExchange(&s_fActiveValidateOpenedQueue,  FALSE);					
			 	return;
			}

			rc = ACSetQueueProperties(
			        pQueue->GetQueueHandle(),
			        pQueue->IsJournalQueue(),
			        pQueue->ShouldMessagesBeSigned(),
			        pQueue->GetPrivLevel(),
			        pQueue->GetQueueQuota(),         // Quota
			        pQueue->GetJournalQueueQuota(),
			        pQueue->GetBaseQueuePriority(),
			        pQueue->IsTransactionalQueue(),
			        pQueue->GetConnectorQM(),
			        pQueue->IsUnkownQueueType()
			        );

			LogHR(rc, s_FN, 112);
			ASSERT(SUCCEEDED(rc));

			CQGroup::MoveQueueToGroup(pQueue.get(), g_pgroupNonactive);
		}
	}
	catch(const exception&)
	{
		InterlockedExchange(&s_fActiveValidateOpenedQueue, FALSE);	
		throw;
	}
}

/*======================================================
Function:    OpenAppsReceiveQueue

Description: The function opens a receive queue for QM internal application
             (i.e DS, Admin). The queue should be a local queue and it
             should be created before opening or beeing recorder in
             Registery As a private queue.

Arguments:   pguidInstance - Pointer to a guid. It the queue is private
                             queue it should be a dummy guid, in which
                             the guid is zero except the low 2 bytes that
                             contains the private queue ID.

             lpReceiveRoutine - Pointer to call back routine. This routine
                             will be called when a message arrive to the
                             queue. The routine is a synchronize routine.

Return Value: phQueue - Queue Handle. The function returns to the caller
                        the open queue handle. This will be used by the
                        caller to close the queue.

History Change:

========================================================*/
HRESULT
CQueueMgr::OpenAppsReceiveQueue(
    const QUEUE_FORMAT* pQueueFormat,
    LPRECEIVE_COMPLETION_ROUTINE  lpReceiveRoutine
    )
{
    HANDLE  hQueue;
    CQueue* pQueue = 0;
    HRESULT rc = OpenQueue(
					pQueueFormat,
					0,					// Calling process ID
					MQ_RECEIVE_ACCESS,
					MQ_DENY_RECEIVE_SHARE,
					&pQueue,
					NULL,				// Remote queue name
					&hQueue,
					NULL				// pfRemoteReturn
					);

    if(FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to open internal private queue for receive. Error: 0x%x", rc);
    	return rc;
    }

    //
    // Wait to incoming packets
    //
    QMOV_ACGetInternalMsg* lpQmOv =  new QMOV_ACGetInternalMsg(hQueue, lpReceiveRoutine);

    rc = QmAcGetPacket(
    		hQueue,
			lpQmOv->packetPtrs,
			&lpQmOv->qmov
			);

    if (FAILED(rc))
    {
        delete lpQmOv;
        TrERROR(GENERAL, "Get Packet from a Internal Queue failed, Error: %x", rc);
        return rc;
    }

    TrTRACE(GENERAL, "Succeeded to Create get packet request from internal queue");
	return MQ_OK;
}

/*======================================================

Function:       CQueueMgr::GetQueueObject

Description:    The routine returnes the Queue object that match the specifued guid.

                generally the Queue object is featched from QueueMgr internal data
                structure. However if the queue is not local queue and the machine is
                FRS, the routine locate a temporary queue on the machine and returnes
                a pointer to its object.

Arguments:      pguidQueue - pointer to guid of the queue

Return Value:   pointer to queue object.

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::GetQueueObject(
    const QUEUE_FORMAT* pQueueFormat,
    CQueue **           ppQueue,
    const GUID*         pgConnectorQM,
    bool                fInReceive,
    bool                fInSend,
	const CSenderStream* pSenderStream
    )
{
    *ppQueue = NULL;

    try
    {
        if (LookUpQueue(pQueueFormat, ppQueue, fInReceive, fInSend))
        {
            ASSERT(("Illegal queue object", (*ppQueue)->GetQueueHandle() != INVALID_HANDLE_VALUE));
            return MQ_OK;
        }

        HRESULT rc = CreateQueueObject(
                                 pQueueFormat,
                                 ppQueue,
                                 0,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 pgConnectorQM,
                                 fInReceive,
                                 fInSend,
				                 pSenderStream
                                 );

        return LogHR(rc, s_FN, 300);
    }
    catch(const bad_alloc&)
    {
        LogIllegalPoint(s_FN, 2002);
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 310);
    }
    catch(const bad_format_name&)
	{
		return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 311);
	}
}


/*====================================================

  RoutineName: CreateACQueue

  Arguments:   pQueeu - pointer to queue object

  Return Value:

=====================================================*/
HRESULT
CQueueMgr::CreateACQueue(IN CQueue*                 pQueue,
                         IN const QUEUE_FORMAT*     pQueueFormat,
						 IN const CSenderStream* pSenderStream
						 )
{
    HRESULT rc;
    HANDLE  hQueue;
    P<QUEUE_FORMAT> pLocalDirectQueueFormat;
    AP<WCHAR> pDirectId;

    //
    //  We reset the format name journal flag, so MQHandleToFormatName
    //  will be correct if the journal queue is opened first.
    //
    QUEUE_SUFFIX_TYPE qst = pQueueFormat->Suffix();
    QUEUE_FORMAT* pqf = const_cast<QUEUE_FORMAT*>(pQueueFormat);

    //
    // Local direct queue gets a canonical format name: PUBLIC= or PRIVATE= in Domain environment,
    // DIRECT=OS:<MachineName> in Workgroup (DS-Less) environment (where <MachineName> in DNS
    // format if available).
    //
    if (pQueue->IsLocalQueue() && pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        if (g_fWorkGroupInstallation)
        {
            AP<WCHAR> pLocalPathName;
            if (g_szComputerDnsName == NULL)
            {
                FnDirectIDToLocalPathName(pQueueFormat->DirectID(), g_szMachineName, pLocalPathName);
            }
            else
            {
                FnDirectIDToLocalPathName(pQueueFormat->DirectID(), g_szComputerDnsName, pLocalPathName);
            }

            DWORD size = FN_DIRECT_OS_TOKEN_LEN + wcslen(pLocalPathName) + 1;
            pDirectId = new WCHAR[size];
			rc = StringCchPrintf(pDirectId, size, L"%s%s", FN_DIRECT_OS_TOKEN, pLocalPathName);
			ASSERT(SUCCEEDED(rc));
			
            pLocalDirectQueueFormat = new QUEUE_FORMAT(pDirectId);
        }
        else
        {
            switch (pQueue->GetQueueType())
            {
                case QUEUE_FORMAT_TYPE_PUBLIC:
                    pLocalDirectQueueFormat = new QUEUE_FORMAT(*pQueue->GetQueueGuid());
                    break;

                case QUEUE_FORMAT_TYPE_PRIVATE:
                    pLocalDirectQueueFormat = new QUEUE_FORMAT(*pQueue->GetQueueGuid(),
                                                               pQueue->GetPrivateQueueId());
                    break;

                default:
                    ASSERT(0);
                    return LogHR(MQ_ERROR, s_FN, 320);
            }
        }
        pqf = pLocalDirectQueueFormat;
    }


    if(IsJournalQueueType(pqf))
    {
        pqf->Suffix(QUEUE_SUFFIX_TYPE_NONE);
    }

	
		
    const GUID* pDestGUID = pQueue->GetMachineQMGuid();

	CSenderStreamFactory SenderStreamFactory;
	if(pSenderStream == NULL)
	{
		pSenderStream = SenderStreamFactory.Create();
	}
	else

	if(!pSenderStream->IsValid())
	{
		//
		// This is from packet that was recovered and does not include the sender stream.
		// we should not set new stream on the queue.
		//
		pSenderStream = NULL;
	}

    rc = ACCreateQueue(
            pQueue->IsLocalQueue(),
            (pDestGUID) ? pDestGUID : &GUID_NULL,
            pqf,
            pQueue->GetQueueCounters(),
            GetNextSeqID(),
            0,
			pSenderStream,
			&hQueue
            );


    //
    //  reset the journal flag state to the original state
    //
    pqf->Suffix(qst);

    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 330);
    }

    rc = ACSetQueueProperties(
                hQueue,
                pQueue->IsJournalQueue(),
                pQueue->ShouldMessagesBeSigned(),
                pQueue->GetPrivLevel(),
                pQueue->GetQueueQuota(),          // Quota
                pQueue->GetJournalQueueQuota(),
                pQueue->GetBaseQueuePriority(),
                pQueue->IsTransactionalQueue(),
                pQueue->GetConnectorQM(),
                pQueue->IsUnkownQueueType()
                );

    if(FAILED(rc))
    {
    	ACCloseHandle(hQueue);
        return LogHR(rc, s_FN, 340);
    }

    pQueue->SetQueueHandle(hQueue);
	ExAttachHandle(hQueue);
    return LogHR(rc, s_FN, 350);
}


/*====================================================

  RoutineName:

  Arguments:

  Return Value:

=====================================================*/

extern DWORD g_dwDefaultTimeToQueue ;

HRESULT
CQueueMgr::SendPacket(
    CMessageProperty *   pmp,
    const QUEUE_FORMAT   DestinationMqf[],
    ULONG                nDestinationMqf,
    const QUEUE_FORMAT * pAdminQueueFormat,
    const QUEUE_FORMAT * pResponseQueueFormat
    )
{
    CQueue *          pQueue = NULL;
    HRESULT           rc;

    //
    // Build AC Send Parameters Buffer
    //

    CACSendParameters SendParams;

    if (pAdminQueueFormat != NULL)
    {
        SendParams.nAdminMqf = 1;
        SendParams.AdminMqf =  const_cast<QUEUE_FORMAT*>(pAdminQueueFormat);
    }

    if (pResponseQueueFormat != NULL)
    {
        SendParams.nResponseMqf = 1;
        SendParams.ResponseMqf =  const_cast<QUEUE_FORMAT*>(pResponseQueueFormat);
    }

    //
    //  Set properties values
    //
    SendParams.MsgProps.pClass           = &pmp->wClass;
    if (pmp->pMessageID != NULL)
    {
        SendParams.MsgProps.ppMessageID  = const_cast<OBJECTID**>(&pmp->pMessageID);
    }
    if (pmp->pCorrelationID != NULL)
    {
        SendParams.MsgProps.ppCorrelationID  = const_cast<PUCHAR*>(&pmp->pCorrelationID);
    }
    SendParams.MsgProps.pPriority        = &pmp->bPriority;
    SendParams.MsgProps.pDelivery        = &pmp->bDelivery;
    SendParams.MsgProps.pAcknowledge     = &pmp->bAcknowledge;
    SendParams.MsgProps.pAuditing        = &pmp->bAuditing;
    SendParams.MsgProps.pTrace           = &pmp->bTrace;
    SendParams.MsgProps.pApplicationTag  = &pmp->dwApplicationTag;
    SendParams.MsgProps.ppBody           = const_cast<PUCHAR*>(&pmp->pBody);
    SendParams.MsgProps.ulBodyBufferSizeInBytes = pmp->dwBodySize;
    SendParams.MsgProps.pulBodyType      = &pmp->dwBodyType;
    SendParams.MsgProps.ulAllocBodyBufferInBytes = pmp->dwAllocBodySize;
    SendParams.MsgProps.pBodySize        = 0;
    SendParams.MsgProps.ppTitle          = const_cast<PWCHAR*>(&pmp->pTitle);
    SendParams.MsgProps.ulTitleBufferSizeInWCHARs = pmp->dwTitleSize;

    SendParams.MsgProps.ulAbsoluteTimeToQueue = pmp->dwTimeToQueue ;
    SendParams.MsgProps.ulRelativeTimeToLive = pmp->dwTimeToLive ;

    if ((SendParams.MsgProps.ulAbsoluteTimeToQueue == INFINITE) ||
        (SendParams.MsgProps.ulAbsoluteTimeToQueue == LONG_LIVED))
    {
        SendParams.MsgProps.ulAbsoluteTimeToQueue = g_dwDefaultTimeToQueue ;
    }

    if (SendParams.MsgProps.ulRelativeTimeToLive != INFINITE)
    {
       if (SendParams.MsgProps.ulAbsoluteTimeToQueue > SendParams.MsgProps.ulRelativeTimeToLive)
       {
          //
          // TimeToQueue should be less than TimeToLive
          //
          ASSERT(0) ;
          SendParams.MsgProps.ulAbsoluteTimeToQueue = SendParams.MsgProps.ulRelativeTimeToLive ;
          SendParams.MsgProps.ulRelativeTimeToLive = 0 ;
       }
       else
       {
          SendParams.MsgProps.ulRelativeTimeToLive -= SendParams.MsgProps.ulAbsoluteTimeToQueue ;
       }
    }

    //
    // Convert TimeToQueue, which was relative until now,
    // to absolute
    //
    ULONG utime = MqSysTime() ;
    if (utime > (SendParams.MsgProps.ulAbsoluteTimeToQueue + utime))
    {
       //
       // overflow. timeout too long.
       //
       ASSERT(INFINITE == 0xffffffff) ;
       ASSERT(LONG_LIVED == 0xfffffffe) ;

       SendParams.MsgProps.ulAbsoluteTimeToQueue = LONG_LIVED - 1 ;
    }
    else
    {
       SendParams.MsgProps.ulAbsoluteTimeToQueue += utime ;
    }

    SendParams.MsgProps.pulSenderIDType  = &pmp->ulSenderIDType;
    SendParams.MsgProps.ppSenderID       = const_cast<PUCHAR*>(&pmp->pSenderID);
    SendParams.MsgProps.uSenderIDLen     = pmp->uSenderIDLen;
    SendParams.MsgProps.ppSenderCert     = const_cast<PUCHAR*>(&pmp->pSenderCert);
    SendParams.MsgProps.ulSenderCertLen  = pmp->ulSenderCertLen;
    SendParams.MsgProps.pulPrivLevel     = &pmp->ulPrivLevel;
    SendParams.MsgProps.pulHashAlg       = &pmp->ulHashAlg;
    SendParams.MsgProps.pulEncryptAlg    = &pmp->ulEncryptAlg;
    SendParams.MsgProps.ppSymmKeys       = const_cast<PUCHAR*>(&pmp->pSymmKeys);
    SendParams.MsgProps.ulSymmKeysSize   = pmp->ulSymmKeysSize;
    SendParams.MsgProps.bEncrypted       = pmp->bEncrypted;
    SendParams.MsgProps.bAuthenticated   = pmp->bAuthenticated;
    SendParams.MsgProps.ppMsgExtension   = const_cast<PUCHAR*>(&pmp->pMsgExtension);
    SendParams.MsgProps.ulMsgExtensionBufferInBytes = pmp->dwMsgExtensionSize;
    SendParams.MsgProps.ppSignature      = const_cast<PUCHAR*>(&pmp->pSignature);
    SendParams.MsgProps.ulSignatureSize  = pmp->ulSignatureSize;
    if (SendParams.MsgProps.ulSignatureSize)
    {
        SendParams.MsgProps.fDefaultProvider = pmp->bDefProv;
        if (!pmp->bDefProv)
        {
            ASSERT(pmp->wszProvName);
            SendParams.MsgProps.ppwcsProvName    = const_cast<WCHAR **>(&pmp->wszProvName);
            SendParams.MsgProps.ulProvNameLen    = wcslen(pmp->wszProvName)+1;
            SendParams.MsgProps.pulProvType      = &pmp->ulProvType;
        }
        else
        {
            SendParams.MsgProps.ppwcsProvName    = NULL;
            SendParams.MsgProps.ulProvNameLen    = 0;
            SendParams.MsgProps.pulProvType      = NULL;
        }
    }

	//
	// Order ack information
	//
	if(pmp->pEodAckStreamId != NULL)
	{
		SendParams.MsgProps.ppEodAckStreamId  = (UCHAR**)&pmp->pEodAckStreamId;
		ASSERT(pmp->EodAckStreamIdSizeInBytes != 0);
		SendParams.MsgProps.EodAckStreamIdSizeInBytes = pmp->EodAckStreamIdSizeInBytes;
		
		SendParams.MsgProps.pEodAckSeqId  =  &pmp->EodAckSeqId;

		ASSERT(pmp->EodAckSeqNum != 0);
		SendParams.MsgProps.pEodAckSeqNum  = &pmp->EodAckSeqNum;
	}


    ASSERT(("Must have at least one destination queue", nDestinationMqf >= 1));
    if (nDestinationMqf == 1   &&
        DestinationMqf[0].GetType() != QUEUE_FORMAT_TYPE_DL)
    {

		//
	    // Translate the queue format name according to local mapping (qal.lib)
	    //
		QUEUE_FORMAT_TRANSLATOR  RealDestinationMqf(&DestinationMqf[0], CONVERT_SLASHES | MAP_QUEUE);
	   	
        //
        // Single destination queue.
        //
        rc = GetQueueObject(RealDestinationMqf.get(), &pQueue, 0, false, false);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 360);
        }
    }
    else
    {
        //
        // Distribution queue.
        //
        try
        {
            rc = GetDistributionQueueObject(nDestinationMqf, DestinationMqf, &pQueue);
            if (FAILED(rc))
            {
                return LogHR(rc, s_FN, 362);
            }
        }
        catch (const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 364);
        }
        catch (const bad_hresult& failure)
        {
            return LogHR(failure.error(), s_FN, 366);
        }
        catch (const exception&)
        {
            ASSERT(("Need to know the real reason for failure here!", 0));
            return LogHR(MQ_ERROR_NO_DS, s_FN, 368);
        }
    }

    R<CQueue> Ref = pQueue;

    //
    // N.B. Using this version of ACSendMessage. there is no notification
    //      when the send is completed (persistent case)
    //      Also check quota for non system queues only.
    //
    rc = ACSendMessage( pQueue->GetQueueHandle(),
                       !pQueue->IsSystemQueue(),
                        SendParams );

	//
	// Log to tracing that a message was sent.
	// Do this only if we are in the proper tracing level
	//
	if (SUCCEEDED(rc) && WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
	{
		DWORD dwMessageDelivery = (NULL != SendParams.MsgProps.pDelivery) ? *(SendParams.MsgProps.pDelivery) : -1;
		DWORD dwMessageClass = (NULL != SendParams.MsgProps.pAcknowledge) ? *(SendParams.MsgProps.pAcknowledge) : -1;
		WCHAR *wszLabel = L"NO LABEL";							
		DWORD dwLabelLen = wcslen(wszLabel);									
		if (NULL != SendParams.MsgProps.ppTitle && NULL != *(SendParams.MsgProps.ppTitle))
		{													
			wszLabel = *(SendParams.MsgProps.ppTitle);			
			dwLabelLen = SendParams.MsgProps.ulTitleBufferSizeInWCHARs;
		}														
																
		TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls    Delivery:0x%x   Class:0x%x   Label:%.*ls",
			L"Sending message from QM",
			pQueue->GetQueueName(),
			dwMessageDelivery,
			dwMessageClass,
			xwcs_t(wszLabel, dwLabelLen));
	}

    return LogHR(rc, s_FN, 370);
}


BOOL
CQueueMgr::LookupQueueInIdMap(
	const QUEUE_ID* pid,
	CQueue** ppQueue
	)
{
	CS lock(m_cs);
    BOOL fSucc = m_MapQueueId2Q.Lookup(pid, *ppQueue);

    if(fSucc)
    {
        //
        // Increment the refernce count. It is the caller responsibility to decrement it.
        //
        (*ppQueue)->AddRef();
    }
    return(fSucc);
}


BOOL
CQueueMgr::LookupQueueInNameMap(
	LPCWSTR queueName,
	CQueue** ppQueue
	)
{
    CS lock(m_cs);
	BOOL fSucc = m_MapName2Q.Lookup(queueName, *ppQueue);
	if (fSucc)
	{
        //
        // Increment the refernce count. It is the caller responsibility to decrement it.
        //
        (*ppQueue)->AddRef();
	}

	return fSucc;
}
/*======================================================

Function:       CQueueMgr::LookUpQueue

Description:    The routine returns the CQueue object that match the Queue Guid

Arguments:      pguidQueue - Queue Guid

Return Value:   pQueue - pointer to CQueue object
                TRUE if a queue was found for the guid, FALSE otherwse.


				NTRAID#NTBUG9-509653-2001/24/12-NirB  	Problem with direct names that contain DNS names (i.e. machine.msmqx.com)
				Consider the following scenario:
				1. Routine is called when DNS names are not yet refreshed and returns FALSE.
				2. A subsequent call to the routine with the same name may return TRUE if the DNS names are refreshed.
				This may lead to a case where we will have two handles for the same queue.
				
Thread Context:

History Change:

========================================================*/
BOOL
CQueueMgr::LookUpQueue(
    IN  const QUEUE_FORMAT* pQueueFormat,
    OUT CQueue **           pQueue,
    IN  bool                fInReceive,
    IN  bool                fInSend
    )
{
    QUEUE_ID QueueObject = {0};

    *pQueue = NULL;                         // set default return value
    switch (pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->PrivateID().Lineage);
            QueueObject.dwPrivateQueueId = pQueueFormat->PrivateID().Uniquifier;
		    return LookupQueueInIdMap(&QueueObject, pQueue);

        case QUEUE_FORMAT_TYPE_PUBLIC:
            //
            // Public Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->PublicID());
		    return LookupQueueInIdMap(&QueueObject, pQueue);

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            //
            // Connector Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->ConnectorID());
            QueueObject.dwPrivateQueueId = (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_XACTONLY) ? 1 : 0;

		    return LookupQueueInIdMap(&QueueObject, pQueue);

        case QUEUE_FORMAT_TYPE_MACHINE:
            //
            // Machine Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->MachineID());
		    return LookupQueueInIdMap(&QueueObject, pQueue);

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // Direct Queue
            //
            if (IsLocalDirectQueue(pQueueFormat, fInReceive, fInSend))
            {
                //
                // System direct queues should have been replaced with machine queues
                // at this stage
                //
                ASSERT(!pQueueFormat->IsSystemQueue());

				AP<WCHAR> PathName;

				FnDirectIDToLocalPathName(
					pQueueFormat->DirectID(),
					g_szMachineName,
					PathName
					);
				
				BOOL fSucc = LookupQueueInNameMap(PathName.get(), pQueue);
				if (fSucc)
				{
					return fSucc;
				}
            }

			//
			// Look for the queue by its DirectID. This is correct for queues that are
			// not local, or for local queues that were not validated because of NO_DS
			//
			{
	            AP<WCHAR> lpwcsQueuePathName = newwcs(pQueueFormat->DirectID());
	            CharLower(lpwcsQueuePathName);

				return LookupQueueInNameMap(lpwcsQueuePathName, pQueue);
			}
			
        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Lookup lowercase string in map
            //
            WCHAR QueueName[MAX_PATH];
            MQpMulticastIdToString(pQueueFormat->MulticastID(), QueueName, TABLE_SIZE(QueueName));
            CharLower(QueueName);

			return LookupQueueInNameMap(QueueName, pQueue);
        }

        default:
            ASSERT(0);
			LogIllegalPoint(s_FN, 374);
            return FALSE;
    }
}

/*======================================================

Function:      CQueueMgr::AddQueueToHash

Description:   Add Queue To Hash Table and to active queue list

Arguments:     pguidQueue - Guid of the Queue
               pQueue     - pointer to CQueue Object

Return Value:  None

Thread Context:

History Change:

========================================================*/

void CQueueMgr::AddQueueToHashAndList(IN CQueue* pQueue)
{

    CS lock(m_cs);

	//
	// auto release reference couting in case of exception
	//
	R<CQueue> Ref(SafeAddRef(pQueue));

	try
	{
	    //
	    // Add the queue to the map.
	    //
	    if (pQueue->GetQueueGuid() != NULL)
	    {
	    	//
	    	// This assert might fail after the one below does.
	    	//
	    	//CQueue* pTmpQueue;
	    	//ASSERT(m_MapQueueId2Q.Lookup(pQueue->GetQueueId(), pTmpQueue) == 0);
	    	//DBG_USED(pTmpQueue);

	        m_MapQueueId2Q[pQueue->GetQueueId()] = pQueue;   
	    }

	    if (pQueue->GetQueueName() != NULL)
	    {
			// NTRAID-686238-2002/08/14-talk
			// This assert failed in the following scenario: Create pubic queue X, Open X, Delete X, Create X, Open X.
			// The problem is that the queue has a new GUID so the insertion to the GUIDs map succeeds, but because both
			// queues have the same name, the new one overrides the old one in the names map.
			// There are several problems with that:
			// 1. When the new queue gets cleaned up, it removes the entry from the map. There may be some operations 
			// that depends on the queue being in the map.
			// 2. In case there is an exception when inserting the queue to the maps we might delete the old queue in the
			// names maps even though it wasn't inserted by us.
			//
	    	//CQueue* pTmpQueue;
	    	//ASSERT(m_MapName2Q.Lookup(pQueue->GetQueueName(), pTmpQueue) == 0);
	    	//DBG_USED(pTmpQueue);

	        m_MapName2Q[pQueue->GetQueueName()] = pQueue;
	    }

	    //
	    // Add queue to Active queue list
	    //
	    AddToActiveQueueList(pQueue);

		//
		// Transfer ownership to the list
		//
		Ref.detach();
	}
	catch(const exception&)
	{
		//
		// Remove the queue from the maps
		//
	    if (pQueue->GetQueueGuid() != NULL)
	    {
	        m_MapQueueId2Q.RemoveKey(pQueue->GetQueueId());
	    }

	    if (pQueue->GetQueueName() != NULL)
	    {
	        m_MapName2Q.RemoveKey(pQueue->GetQueueName());
	    }

    	TrERROR(GENERAL, " Exception when trying to Map Queue %ls",pQueue->GetQueueName());
		LogIllegalPoint(s_FN, 376);
		throw;
	}
}

/*======================================================

Function:      CQueueMgr::RemoveQueueFromHash

Description:   remove a queue from the hash but don't remove
               remove it form the list

Arguments:     pQueue     - pointer to CQueue Object

Return Value:  None

Thread Context:

History Change:

========================================================*/

void CQueueMgr::RemoveQueueFromHash(CQueue* pQueue)
{
    CS lock(m_cs);

    //
    // Remove the queue from Id to Queue object map
    //
    if (pQueue->GetQueueGuid() != NULL)
    {
        m_MapQueueId2Q.RemoveKey(pQueue->GetQueueId());
        pQueue->SetQueueGuid(NULL) ;
    }

    //
    // Remove the queue from name to Queue object map
    //
    LPCTSTR  qName = pQueue->GetQueueName();
    if (qName != NULL)
    {
        m_MapName2Q.RemoveKey(qName);
        pQueue->SetQueueName(NULL);
    }

}


/*======================================================

Function:      CQueueMgr::RemoveQueue

Description:   Close handle and Remove Queue from Hash Tables

Arguments:     pQueue   - pointer to CQueue Object
               fDelete  - of TRUE then delete the object. Otherwise,
                          only invalidate the handle and remove from
                          hash tables.

Return Value:  None

Thread Context:

History Change:

========================================================*/

void CQueueMgr::RemoveQueue(CQueue* pQueue)
{
    ASSERT(pQueue != NULL);

#ifdef _DEBUG
	{
        AP<WCHAR> lpcsQueueName;
        pQueue->GetQueue(&lpcsQueueName);
        TrTRACE(GENERAL, "Remove Queue %ls", lpcsQueueName.get());
	}
#endif

    HANDLE hQueue = pQueue->GetQueueHandle();
    if (hQueue != INVALID_HANDLE_VALUE)
    {
		CQGroup::MoveQueueToGroup(pQueue, NULL);

        //
        // Close the queue Handle
        //
        ACCloseHandle(hQueue);
        pQueue->SetQueueHandle(INVALID_HANDLE_VALUE);
    }

    RemoveQueueFromHash(pQueue);
}


/*======================================================
Function:      CanReleaseQueue

Description: Check if given queue object has no users so it can be released

========================================================*/
static bool CanReleaseQueue(const CBaseQueue& BaseQueue)
{
	//
	// If remote read queue - then we can remove it it has no users except the queue manager
	//
	if (BaseQueue.IsRemoteProxy())
    {
		return (BaseQueue.GetRef() == 1);
    }

	//
	// On non remote queue - The queue can be removed if it has no external users
	// except the queue manager  and the group (if any)
	//
	const CQueue& Queue = static_cast<const CQueue&>(BaseQueue);
	return((Queue.GetRef() == 1) || 	
           (Queue.GetRef() == 2 && Queue.GetGroup()  == g_pgroupNonactive) ||
           (Queue.GetRef() == 2 && Queue.GetGroup()  == g_pgroupNotValidated)
           );
}



/*======================================================

Function:      CQueueMgr::ReleaseQueue

Description:   Scan the queue list and remove from internal DB all the queues
               that are not used. The creterias are:

                 - All the Application Handles are closed
                 - No waiting messgae in the queue.
                 - No waiting message in the associate journal queue

========================================================*/

void CQueueMgr::ReleaseQueue(void)
{
    CList<LONGLONG, LONGLONG&> listSeqId;

    //
    // Cleaning the unused queues
    //
    {
        CS lock(m_cs);

        ASSERT(m_fQueueCleanupScheduled);

		try
		{
	        POSITION pos;

        	pos = m_listQueue.GetHeadPosition();
	        while(pos != NULL)
	        {
	            POSITION prevpos = pos;
	            CBaseQueue*  pBQueue = const_cast<CBaseQueue*>(m_listQueue.GetNext(pos));

			    if(!CanReleaseQueue(*pBQueue))
			    	continue;

                ASSERT(!pBQueue->IsRemoteProxy());

                CQueue* pQueue = (CQueue*) pBQueue ;

                //
                // Remove the queue only if there is no active session
                //
                if(pQueue->IsConnected())
                	continue;

                HANDLE hQueue = pQueue->GetQueueHandle();

                ASSERT(hQueue != g_hAc);
                ASSERT(hQueue != g_hMachine);
                HRESULT hr  = ACCanCloseQueue(hQueue);
                if (FAILED(hr))
                {
                    //
                    // Here MQ_ERROR indicates that the queue object
                    // can not be deleted. That's OK. So do not
                    // log here anything.
                    //
                    continue;
                }

				//
				// Get the queue sequnce id to release unused Exactly-Once-Delivery sequences
				// Do it before removing the queue such in case an exception is thrown
				// while adding the sequence id to the list the queue still active and
				// it will clean next time.
				//
                LONGLONG liSeqId = pQueue->GetQueueSequenceId();
                if (liSeqId != 0)
                {
                    listSeqId.AddTail(liSeqId);
                }

                RemoveQueue(pQueue);
                m_listQueue.RemoveAt(prevpos);

                TrTRACE(GENERAL, "ReleaseQueue %p; name=%ls",pBQueue, pBQueue->GetQueueName());

				pQueue->Release();
	        }
		}
	    catch(const exception&)
	    {
	    	//
	    	// There was exception while cleanup the queues. Don't do anything, but
	    	// rescheduling for cleanup
	    	//
	    }

        //
        // Set a new timer for Queues cleaning
        //
        if (m_listQueue.IsEmpty())
        {
            m_fQueueCleanupScheduled = FALSE;
        }
        else
        {
            ExSetTimer(&m_QueueCleanupTimer, m_CleanupTimeout);
        }
    }

    //
    // Release any Exactly-Once-Delivery sequences if any exist
    //
    if(!listSeqId.IsEmpty())
    {
        CS lockoutHash(g_critOutSeqHash);

        LONGLONG liSeqId;
        POSITION pos;

        pos = listSeqId.GetHeadPosition();
        while(pos != NULL)
        {
            liSeqId = listSeqId.GetNext(pos);

            // Deleting last and all previous sequences for the direction
            g_OutSeqHash.DeleteSeq(liSeqId);
        }
    }
}

/*======================================================

Function:      CQueueMgr::QueueDeleted

Description:   Queue was deleted. The function removed the queue from
               QM internal data structure and from the public queue cache

Arguments:     pguidQueue - Guid of the Queue

Return Value:  None

========================================================*/
void
CQueueMgr::NotifyQueueDeleted(
	const QUEUE_FORMAT& qf
	)
{
	CS lock(m_cs);
	
    //
    // Find the Queue ObjectIn QM internal Data Structure
    //
    CQueue* pQueue;
    if (LookUpQueue(&qf, &pQueue, false, false))
    {
        ASSERT (pQueue->GetQueueHandle() != INVALID_HANDLE_VALUE);
		ASSERT(pQueue->IsLocalQueue() || pQueue->IsUnkownQueueType());
        ASSERT((pQueue->GetQueueType() == QUEUE_TYPE_PUBLIC) ||
        	   (pQueue->GetQueueType() == QUEUE_TYPE_PRIVATE));

        R<CQueue> Ref = pQueue;      // automatic release
        //
        // Mark the queue as invalid
        //
        pQueue->SetQueueNotValid();
    }
}


VOID
CQueueMgr::UpdateQueueProperties(
    IN const QUEUE_FORMAT* pQueueFormat,
    IN DWORD       cpObject,
    IN PROPID      pPropObject[],
    IN PROPVARIANT pVarObject[]
    )
{
    CQueue* pQueue;
    R<CQueue> Ref = NULL;

    ASSERT(pQueueFormat != NULL);
    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PUBLIC) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE));

    QMpUpdateMulticastBinding(pQueueFormat, cpObject, pPropObject, pVarObject);

    //
    // Find the Queue ObjectIn QM internal Data Structure
    //
    if (LookUpQueue(pQueueFormat, &pQueue, false, false))
    {
        Ref = pQueue;

#ifdef _DEBUG
        {
            AP<WCHAR> lpcsQueueName;
            pQueue->GetQueue(&lpcsQueueName);
            TrTRACE(GENERAL, "DS NOTIFICATION: Set Queue properties for queue: %ls", lpcsQueueName);
        }
#endif
		//
		// The queue is a local queue but can also be from an unknown type due to
		// timing issues (For example opening a queue for read when the queue was created from another machine)
		//
        ASSERT(pQueue->IsLocalQueue() || pQueue->IsUnkownQueueType());

        BOOL fPropChange = FALSE;
        //
        // Change the queue properties
        //
        for (DWORD i = 0 ; i < cpObject ; i++ )
        {
            switch( pPropObject[i] )
            {
                case PROPID_Q_JOURNAL:
                    pQueue->SetJournalQueue(pVarObject[i].bVal == MQ_JOURNAL);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_QUOTA:
                    pQueue->SetQueueQuota(pVarObject[i].ulVal);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_BASEPRIORITY:
                    pQueue->SetBaseQueuePriority(pVarObject[i].iVal);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_JOURNAL_QUOTA:
                    pQueue->SetJournalQueueQuota(pVarObject[i].ulVal);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_SECURITY:
					ASSERT (pVarObject[i].blob.cbSize == GetSecurityDescriptorLength((SECURITY_DESCRIPTOR*)pVarObject[i].blob.pBlobData));
                    pQueue->SetSecurityDescriptor((SECURITY_DESCRIPTOR*)pVarObject[i].blob.pBlobData);
                    break;

                case PROPID_Q_AUTHENTICATE:
                    pQueue->SetAuthenticationFlag(pVarObject[i].bVal);
                    break;

                case PROPID_Q_PRIV_LEVEL:
                    pQueue->SetPrivLevel(pVarObject[i].ulVal);
                    break;
            }
        }

        if (fPropChange)
        {
            HRESULT rc;
            rc = ACSetQueueProperties(
                        pQueue->GetQueueHandle(),
                        pQueue->IsJournalQueue(),
                        pQueue->ShouldMessagesBeSigned(),
                        pQueue->GetPrivLevel(),
                        pQueue->GetQueueQuota(),         // Quota
                        pQueue->GetJournalQueueQuota(),
                        pQueue->GetBaseQueuePriority(),
                        pQueue->IsTransactionalQueue(),
                        pQueue->GetConnectorQM(),
                        pQueue->IsUnkownQueueType()
                        );

            ASSERT(SUCCEEDED(rc));
            LogHR(rc, s_FN, 113);
        }
    }
} // CQueueMgr::UpdateQueueProperties


/*======================================================

Function:    ValidateMachineProperties()

========================================================*/

void
CQueueMgr::ValidateMachineProperties(
	void
	)
{
    PROPID aProp[6];
    PROPVARIANT aVar[6];
    HRESULT rc = MQ_ERROR_NO_DS;

    aProp[0] = PROPID_QM_PATHNAME;
    aProp[1] = PROPID_QM_QUOTA;
    aProp[2] = PROPID_QM_JOURNAL_QUOTA;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI4;
    aVar[2].vt = VT_UI4;


    rc = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,   // pwcsDomainController
					false,	// fServerName
                    GetQMGuid(),
                    3,
                    aProp,
                    aVar
					);

    if (FAILED(rc))
    {
    	TrERROR(GENERAL, " Failed to retrieve machine properties. %!hresult!", rc);
    	throw bad_hresult(rc);
    }

	UpdateMachineProperties(3, aProp, aVar);
}

/*======================================================

Function:      CQueueMgr::UpdateMachineProperties

Description:   Machine properties was changed. The function changed the mqchine
               properties and change the machine properties on the cache

Arguments:     pguidQueue - Guid of the Queue

Return Value:  None

========================================================*/
void
CQueueMgr::UpdateMachineProperties(IN DWORD       cpObject,
                                   IN PROPID      pPropObject[],
                                   IN PROPVARIANT pVarObject[])
{
    CS lock(m_cs);
    HRESULT rc;

    //
    // Change the queue properties
    //
    for(DWORD i = 0 ; i < cpObject ; i++ )
    {
        switch( pPropObject[i] )
        {
            case PROPID_QM_QUOTA:
                //
                // change Quota value of machine object
                //
                rc = ACSetMachineProperties(g_hAc, pVarObject[i].ulVal);
                LogHR(rc, s_FN, 115);

                //
                // Change the machine quota on registery
                //
                SetMachineQuotaChace(pVarObject[i].ulVal);
                break;

            case PROPID_QM_JOURNAL_QUOTA:
                //
                //  change the quota of the machine journal
                //
                rc = ACSetQueueProperties(
                        g_hMachine,
                        FALSE,
                        FALSE,
                        MQ_PRIV_LEVEL_OPTIONAL,
                        DEFAULT_Q_QUOTA,        // The deadletter quota, currently no property
                        pVarObject[i].ulVal,
                        0,
                        FALSE,
                        NULL,
                        FALSE
                        );
                LogHR(rc, s_FN, 116);

                //
                // Change the machine Journal quota on registery
                //
                SetMachineJournalQuotaChace(pVarObject[i].ulVal);
                break;

            case PROPID_QM_SECURITY:
                SetMachineSecurityCache((PVOID) pVarObject[i].blob.pBlobData,
                                        pVarObject[i].blob.cbSize );
                break;

            default:
                break;
        }
    }
}


void
CQueueMgr::GetOpenQueuesFormatName(
    LPWSTR** pppFormatName,
    LPDWORD  pdwFormatSize
    )
{
    *pppFormatName = NULL;
    *pdwFormatSize = 0;

    //
    //  Get the critical section to insure that no other
    //  thread add/remove queue
    //

    CS lock(m_cs);

    //
    // Retrieve number of queues
    //
    int iElem;
    iElem = m_listQueue.GetCount();  // The driver opens 3 queues (Machine Queues) always.
                                      // These queues are not appear in the QM hash tabel.
    //
    // Allocate result memory
    //
    DWORD Index = 0;
    AP<LPWSTR> pFormatName = new LPWSTR[iElem];


    try
    {
        //
        // Loop over all open queues
        //
        POSITION pos = m_listQueue.GetHeadPosition();
        while (pos)
        {
            const CQueue* pQueue;
            pQueue = static_cast<const CQueue*>(m_listQueue.GetNext(pos));

            if ((pQueue->GetQueueType() == QUEUE_TYPE_MACHINE) &&
                (pQueue->IsLocalQueue()))
            {
                continue;
            }


            if(pQueue->IsRemoteProxy())
            {
                //
                // Skip Remote Read queue.
                // NOTE: remote read queue does not have the NotValid Flag.
                //
                continue;
            }

            if (pQueue->QueueNotValid())
            {
                //
                // Ignore deleted queue
                //
                continue;
            }

            //
            // Copy the format name
            //
            WCHAR StacktmpBuf[1001];
            AP<WCHAR> pHeapTmpBuf;
            DWORD dwBufSize = 1000;
			WCHAR *pBuf = StacktmpBuf;
            HRESULT hr = ACHandleToFormatName(pQueue->GetQueueHandle(), StacktmpBuf, &dwBufSize);
			LogHR(hr, s_FN, 102);
			if (MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL == hr)
			{
				pHeapTmpBuf = new WCHAR [dwBufSize+1];
	            hr = ACHandleToFormatName(pQueue->GetQueueHandle(), pHeapTmpBuf, &dwBufSize);
				pBuf = pHeapTmpBuf;
			}
			if(FAILED(hr))
			{
				TrTRACE(DS, "ACHandleToFormatName returned error %x \n",hr);

				ASSERT(SUCCEEDED(hr));
				throw bad_alloc();
			}	

            //
            // Allocate memory
            //
			pFormatName[Index] = newwcs(pBuf);
            ++Index;
        }
    }
    catch(const bad_alloc&)
    {
        while(Index)
        {
            delete [] pFormatName[--Index];
        }

        LogIllegalPoint(s_FN, 1040);
        throw;
    }

    *pppFormatName = pFormatName.detach();
    *pdwFormatSize = Index;

}


/*======================================================

Function:      CQueueMgr::SetConnected

Description:   Assign if the DS access is allowed

========================================================*/
void CQueueMgr::SetConnected()
{
    LONG PrevConnectValue = InterlockedExchange(&m_Connected, true);

    if (TRUE == PrevConnectValue)
        return;

	CS lock(m_csMgmt);
	
	try
	{
	    //
	    // Don't catch the QueueMgr semaphore before calling the "SessionMgr.NetworkConnection"
	    // It can cause deadlock
	    //
	    SessionMgr.ConnectNetwork();

		MsmConnect();

		//
		// If trying to connect QM immediately after service startup
		// we need first to enable access to DS, otherwise we can enter
		// twice to ValidateOpenedQueues function. first from this function
		// and second from OnlineInitialization function.
		//
		MQDSClientInitializationCheck();
		
		//
		// Move the queues from On Hold group to NonActive Group. Queues that
		// are marked as onhold will be move back to the "onhold" group latter.
		//
		for(;;)
		{
			R<CQueue> pQueue =  g_pgroupDisconnected->PeekHead();
			if (pQueue.get() == NULL)
			{
				//
				// In rare case, it can happen that although the returned value
				// is NULL the group isn't empty. This happen if while trying to
				// moving the queue to disconnect there is a context switch and
				// the above code is running.
				//
				if (!g_pgroupDisconnected->IsEmpty())
					continue;
				
				break;
			}

 		    CQGroup::MoveQueueToGroup(pQueue.get(), g_pgroupNonactive);
		}
		
		//
		// handle the Queues that were opened when the machine was disconected
		//
		ValidateOpenedQueues();
		
		if (!g_fWorkGroupInstallation)
			ValidateMachineProperties();

	    DWORD dwSize = sizeof(DWORD);
	    DWORD dwType = REG_DWORD;

	    SetFalconKeyValue(
	        FALCON_CONNECTED_NETWORK,
	        &dwType,
	        &m_Connected,
	        &dwSize
	        );

	}
	catch(const exception&)
	{
		InterlockedExchange(&m_Connected, false);
		MsmDisconnect();
		MtmDisconnect();

		throw;
	}
}

/*======================================================

Function:      CQueueMgr::SetConnected

Description:   Assign if the DS access is allowed

========================================================*/
void CQueueMgr::SetDisconnected()
{
    LONG PrevConnectValue = InterlockedExchange(&m_Connected, FALSE);

    if (FALSE == PrevConnectValue)
        return;

	CS lock(m_csMgmt);
	
	try
	{
	    //
	    // Don't catch the QueueMgr semaphore before calling the "SessionMgr.NetworkConnection"
	    // It can cause deadlock
	    //
	    SessionMgr.DisconnectNetwork();
	}
	catch(exception&)
	{
		TrERROR(GENERAL, "Failed to set QM in connected/disconnected mode");
		InterlockedExchange(&m_Connected, PrevConnectValue);
		throw;
	}

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    SetFalconKeyValue(
        FALCON_CONNECTED_NETWORK,
        &dwType,
        &m_Connected,
        &dwSize
        );

    CS lock1(m_cs);

	MsmDisconnect();
	MtmDisconnect();
}


void
CQueueMgr::MoveQueueToOnHoldGroup(
    CQueue* pQueue
    )
{
    CS lock(m_cs);

    //
    // This check is protected with the CS. This insures that
    // if the queue is marked as OnHold queue no one changes
    // its status during the move
    //
    if (IsOnHoldQueue(pQueue))
    {
    	//
    	// Moving queue to disconnected group can fail due to low resources. However, in such a case
    	// the queue still in nonactive group. The code tries to move it again
    	// to disoccnected group later on
    	//
		CQGroup::MoveQueueToGroup(pQueue, g_pgroupDisconnected);
    }
}


void
CQueueMgr::MoveQueueToLockedGroup(
    CQueue* pQueue
    )
{
    CS lock(m_cs);

    //
    // This check is protected with the CS. This insures that
    // if the queue is marked as Locked queue no one changes
    // its status during the move
    //
	CQGroup::MoveQueueToGroup(pQueue, g_pgroupLocked);
}



void
CQueueMgr::MovePausedQueueToNonactiveGroup(
        CQueue* pQueue
        )
{
    CS lock(m_cs);

	if (pQueue->GetGroup() == g_pgroupDisconnected)
	{
		CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);
	}
}

/*======================================================

Function:      CQueueMgr::InitConnected

Description:   Initialize the network and DS connection state

========================================================*/
void
CQueueMgr::InitConnected(
    void
    )
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD DefaultValue = TRUE;

    GetFalconKeyValue(
        FALCON_CONNECTED_NETWORK,
        &dwType,
        &m_Connected,
        &dwSize,
        (LPCTSTR)&DefaultValue
        );
}

// [adsrv]
/*======================================================

Globally-available functions make it easy to find out the
nature of the available services on this very machine

========================================================*/
bool IsRoutingServer(void)
{
    return CQueueMgr::GetMQSRouting();
}


bool IsDepClientsServer(void)
{
    return CQueueMgr::GetMQSDepClients();
}

bool IsNonServer(void)
{
    return (!CQueueMgr::GetMQSRouting());
}

#ifdef _DEBUG
bool CQueueMgr::IsQueueInList(const CBaseQueue* pQueue)
/*++

  Routine Description:
   check if given queue is in the queues list

  Parameters:
    pQueue - pointer to basic Queue class

  Returned value:
    true - the queue is in the list otherwise false

  Note:
    This function is called from Cqueue destrcutor to verify that the queue
	is not in the list after destruction.
 --*/
{
	 POSITION pos = m_listQueue.GetHeadPosition();
     while(pos != NULL)
     {
		if(pQueue == m_listQueue.GetNext(pos))
			return true;
	 }
     return false;
}
#endif



void
CQueueMgr::AddToActiveQueueList(
    const CBaseQueue* pQueue
    )
/*++

  Routine Description:
    The routine add the queue to list of active queues. This list is used
    for cleanup and for admin purpose.
    The routine ignores the system queues, since they are only used internally
    by MSMQ and are never cleaned up.

  Parameters:
    pQueue - pointer to basic Queue class

  Returned value:
    None.

  Note:
    The list contains the regular queues and the remote read queues.
    The QueueManager critcal section must be held.

 --*/
{
    //
    // Ignore system queues on local machine. They are always alive.
    //
    if (pQueue->IsSystemQueue() && pQueue->IsLocalQueue())
        return;


    m_listQueue.AddTail(pQueue);
    if (!m_fQueueCleanupScheduled)
    {
        //
        // Set a new timer for Queues cleaning
        //
        ExSetTimer(&m_QueueCleanupTimer, m_CleanupTimeout);
        m_fQueueCleanupScheduled = TRUE;
    }

}


static
HRESULT
QMpDuplicateDistributionHandle(
    HANDLE   hDistribution,
    DWORD    CallingProcessID,
    HANDLE * phDuplicate
    )
{
    ASSERT(phDuplicate != NULL);

    CAutoCloseHandle hCallingProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, CallingProcessID);
    if(hCallingProcess == 0)
    {
        return MQ_ERROR_PRIVILEGE_NOT_HELD;
    }

    BOOL fSuccess = MQpDuplicateHandle(
                        GetCurrentProcess(),
                        hDistribution,
                        hCallingProcess,
                        phDuplicate,
                        MQAccessToFileAccess(MQ_SEND_ACCESS),
                        TRUE,
                        DUPLICATE_CLOSE_SOURCE
                        );
    if(!fSuccess)
    {
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 1042);
    }

    return MQ_OK;

} // QMpDuplicateDistributionHandle


void
WINAPI
CQueueMgr::QueuesCleanup(
    CTimer* pTimer
    )
/*++
  Routine Description:
    The function is called from scheduler when Queueu Cleanup interval
    timeout is expired. The routine retrive the Queue Manager
    object and calls the ReleaseQueue member function .

  Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the Queue Manager
             object and it use to retrive the transport object.

  Return Value:
    None

--*/
{
    CQueueMgr* pQueueMgr = CONTAINING_RECORD(pTimer, CQueueMgr, m_QueueCleanupTimer);

    TrTRACE(GENERAL, "Call Queue Cleanup");
    pQueueMgr->ReleaseQueue();
}



static HRESULT QMpTranslateError(HRESULT hr)
{
	if(SUCCEEDED(hr))
		return MQ_OK;

	switch(hr)
	{
    case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
	case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
		return MQ_ERROR_NO_DS;
        break;

	case HRESULT_FROM_WIN32(ERROR_DS_DECODING_ERROR):
    case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
		return MQDS_OBJECT_NOT_FOUND;
        break;

    case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        return MQ_ERROR_ACCESS_DENIED;
        break;

	default:
		return MQ_ERROR;
	}
}



VOID
CQueueMgr::ExpandMqf(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    ULONG *            pnLeafMqf,
    QUEUE_FORMAT * *   ppLeafMqf
    ) const
/*++

Routine Description:

    Expand top level elemtns of a multi queue format to leaf elements.
    The elements that need expansion in the MQF are queue format of type DL=.
    Expansion means querying Active Directory for the leaf elements of a DL.

    This routine allocates memory for the leaf MQF. Deallocation is the
    responsibility of the caller.

Arguments:

    nTopLevelMqf - Number of top level elemenets in the array.

    TopLevelMqf  - Array of top level elements of multi queue format.

    pnLeafMqf    - Points to the number of leaf elements in the array, on output.

    ppLeafMqf    - Points to an array of leaf queue formats, on output.

Note:

    This routine may query Active Directory, which is quite lengthy,
    so make sure caller does not hold the member CS lock.

Return Value:

    None. Throws exception.

--*/
{
    ASSERT(nTopLevelMqf != 0);
    ASSERT(ppLeafMqf);
    ASSERT(pnLeafMqf);

    //
    // In DS-less configuration the formatname DL= is not supported.
    //
    if (g_fWorkGroupInstallation)
    {
        for (ULONG ix = 0; ix < nTopLevelMqf; ++ix)
        {
            if (TopLevelMqf[ix].GetType() == QUEUE_FORMAT_TYPE_DL)
            {
                TrERROR(GENERAL, "DL= not supported in DS-less mode");
                throw bad_hresult(MQ_ERROR_UNSUPPORTED_OPERATION);
            }
        }
    }

	try
	{
		FnExpandMqf(nTopLevelMqf, TopLevelMqf, pnLeafMqf, ppLeafMqf);
	}
	catch(const bad_ds_result& e)
	{
		throw bad_hresult(QMpTranslateError(e.error()));
	}
} // CQueueMgr::ExpandMqf


HRESULT
CQueueMgr::GetDistributionQueueObject(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    CQueue * *         ppQueue
    )
/*++

Routine Description:

    Get a queue object that represent a distribution queue.

    Note that this routine does not lock the member CS.

Parameters:

    nTopLevelMqf - Number of top level queue format names. Minimum is 1.

    TopLevelMqf  - The top level queue format names of the distribution.

    ppQueue      - Pointer to pointer to a queue object, on output.

Returned value:

    MQ_OK - The operation completed successfully.
    other status - The operation failed.

    This routine throws exception.

 --*/
{
    ASSERT(nTopLevelMqf != 0);
    ASSERT(ppQueue != NULL);

    AP<QUEUE_FORMAT> LeafMqf;
    ULONG            nLeafMqf;
    ExpandMqf(nTopLevelMqf, TopLevelMqf, &nLeafMqf, &LeafMqf);
    {
        //
        // Enforce cleaner is cleaned up before LeafMqf by scoping
        //
        CMqfDisposer cleaner(nLeafMqf, LeafMqf);

        HRESULT hr;
        AP< R<CQueue> > LeafQueues = new R<CQueue>[nLeafMqf];
        AP<bool> ProtocolSrmp = new bool[nLeafMqf];
        for (ULONG ix = 0; ix < nLeafMqf; ++ix)
        {
		    //
	        // Translate the queue format name according to local mapping (qal.lib)
	        //
			QUEUE_FORMAT_TRANSLATOR RealLeafMqf(&LeafMqf[ix], CONVERT_SLASHES| MAP_QUEUE);

            //
            // GetDistributionQueueObject is called only in the send pass
            //
            hr = GetQueueObject(RealLeafMqf.get(), &LeafQueues[ix].ref(), 0, false, false);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 1044);
            }

            LeafQueues[ix]->AddRef();

            ProtocolSrmp[ix] = (FnIsDirectHttpFormatName(RealLeafMqf.get()) ||
                                IsMulticastQueue(RealLeafMqf.get()));
        }

        QueueProps qp;
        FillMemory(&qp, sizeof(QueueProps), 0);
		QUEUE_FORMAT qf;
        R<CQueue> pDistribution = new CQueue(&qf ,INVALID_HANDLE_VALUE, &qp, TRUE);

        HANDLE hDistribution;
        hr = CreateACDistribution(nTopLevelMqf, TopLevelMqf, nLeafMqf, LeafQueues, ProtocolSrmp, &hDistribution);
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 1046);
        }

        pDistribution->SetQueueHandle(hDistribution);

        *ppQueue = pDistribution.detach();
        return MQ_OK;
    }
} // CQueueMgr::GetDistributionQueueObject


HRESULT
CQueueMgr::OpenMqf(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    DWORD              dwCallingProcessID,
    HANDLE *           phDistribution
    )
/*++

Routine Description:

    Open a distribution queue for send.

    Note that this routine does not lock the member CS.

Parameters:

    nTopLevelMqf - Number of top level queue formats. Minimum is 1.

    TopLevelMqf  - The top level queue formats of the distribution.

    dwCallingProcessID - Process ID of the user process.

    phDistribution     - Points to the handle of the distribution, on output.

Returned value:

    MQ_OK - The operation completed successfully.
    other status - The operation failed.

    This routine throws exception.

 --*/
{
    ASSERT(nTopLevelMqf != 0);
    ASSERT(phDistribution != NULL);

    AP<QUEUE_FORMAT> LeafMqf;
    ULONG            nLeafMqf;
    ExpandMqf(nTopLevelMqf, TopLevelMqf, &nLeafMqf, &LeafMqf);
    {
        //
        // Enforce cleaner is cleaned up before LeafMqf by scoping
        //
        CMqfDisposer cleaner(nLeafMqf, LeafMqf);

        HRESULT hr;
        AP< R<CQueue> > LeafQueues = new R<CQueue>[nLeafMqf];
        AP<bool> ProtocolSrmp = new bool[nLeafMqf];
        for (ULONG ix = 0; ix < nLeafMqf; ++ix)
        {
            hr = OpenQueue(
	            	&LeafMqf[ix],
	            	0, 					// Calling process ID
	            	MQ_SEND_ACCESS,
	            	0, 					// dwShareMode
	            	&LeafQueues[ix].ref(),
	            	NULL, 				// Remote queue name
	            	NULL,				// phQueue
					NULL				// pfRemoteReturn
	            	);

            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 1048);
            }

            hr = VerifyOpenPermission(LeafQueues[ix].get(), &LeafMqf[ix], MQ_SEND_ACCESS, FALSE, LeafQueues[ix]->IsLocalQueue());
            if(FAILED(hr))
            {
                return LogHR(hr, s_FN, 1049);
            }

            ProtocolSrmp[ix] = (FnIsDirectHttpFormatName(&LeafMqf[ix]) ||
                                IsMulticastQueue(&LeafMqf[ix]));
        }

        hr = CreateACDistribution(nTopLevelMqf, TopLevelMqf, nLeafMqf, LeafQueues, ProtocolSrmp, phDistribution);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1051);
        }

        hr = QMpDuplicateDistributionHandle(*phDistribution, dwCallingProcessID, phDistribution);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1052);
        }

        return MQ_OK;
    }
} // CQueueMgr::OpenMqf


HRESULT
CQueueMgr::CreateACDistribution(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    ULONG              nLeafQueues,
    const R<CQueue>    LeafQueues[],
    const bool         ProtocolSrmp[],
    HANDLE *           phDistribution
    )
/*++

Routine Description:

    Create a distribution object in the AC layer.

Parameters:

    nTopLevelMqf - Number of top level queues in the distribution. Minimum is 1.

    TopLevelMqf  - The top level queue formats of the distribution.

    nLeafQueues  - Number of leaf queues in the distribution. May be 0.

    LeafQueues   - The leaf queue objects of the distribution.

    ProtocolSrmp - Indicates for each queue of the distribution whether it is an http queue.

    phDistribution - Points to the handle of the distribution object, on output.

Returned value:

    MQ_OK - The operation completed successfully.
    other status - The operation failed.

    This routine throws bad_alloc exception.

 --*/
{
    //
    // Get the handles of all leaf queues.
    //
    AP<HANDLE> phLeafQueues = new HANDLE[nLeafQueues];
    for (ULONG ix = 0; ix < nLeafQueues; ++ix)
    {
        phLeafQueues[ix] = LeafQueues[ix]->GetQueueHandle();

        ASSERT(phLeafQueues[ix] != NULL);
        ASSERT(phLeafQueues[ix] != INVALID_HANDLE_VALUE);
    }

    //
    // Call AC to create the distribution object
    //
    return ACCreateDistribution(
               nLeafQueues,
               phLeafQueues,
               ProtocolSrmp,
               nTopLevelMqf,
               TopLevelMqf,
               phDistribution
               );
} // CQueueMgr::CreateACDistribution


HRESULT
CQueueMgr::SetQMGuid(
    void
    )
{
    DWORD dwValueType = REG_BINARY ;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue(MSMQ_QMID_REGNAME,
                               &dwValueType,
                               &m_guidQmQueue,
                               &dwValueSize);

    if (rc != ERROR_SUCCESS)
    {
        DWORD dwSysprep = 0;
        dwValueSize = sizeof(DWORD);
        dwValueType = REG_DWORD;

        GetFalconKeyValue(MSMQ_SYSPREP_REGNAME, &dwValueType, &dwSysprep, &dwValueSize);
        if (dwSysprep != 0)
        {
            TrWARNING(DS, "First run after Sysprep - generating a new QM ID !");

            RPC_STATUS status = UuidCreate(&m_guidQmQueue);
			DBG_USED(status);
            ASSERT(("must succeed in generating guid for this QM", status == RPC_S_OK));

            dwValueType = REG_BINARY;
            dwValueSize = sizeof(GUID);
            rc = SetFalconKeyValue(MSMQ_QMID_REGNAME, &dwValueType, &m_guidQmQueue, &dwValueSize);

            if (rc != ERROR_SUCCESS)
            {
                TrERROR(DS, "Failed to set QM Guid in registry, error 0x%x", rc);
				EvReportWithError(EVENT_ERROR_QM_WRITE_REGISTRY, rc, 1, MSMQ_QMID_REGNAME);
                return HRESULT_FROM_WIN32(rc);
            }

            DeleteFalconKeyValue(MSMQ_SYSPREP_REGNAME);
            return MQ_OK;
        }

		TrERROR(DS, "Can't initilize QM Guid. Error %d", rc);
		EvReportWithError(EVENT_ERROR_QM_READ_REGISTRY, rc, 1, MSMQ_QMID_REGNAME);
        return HRESULT_FROM_WIN32(rc);

    }

    ASSERT((dwValueType == REG_BINARY) &&
           (dwValueSize == sizeof(GUID)));

    return(MQ_OK);
}


HRESULT
CQueueMgr::SetQMGuid(
    const GUID * pGuid
    )
{
    m_guidQmQueue = *pGuid;

    return(MQ_OK);
}


HRESULT
CQueueMgr::SetMQSRouting(
    void
    )
{
   DWORD dwDef = 0xfffe ;
   DWORD dwMQSRouting;
   READ_REG_DWORD(dwMQSRouting, MSMQ_MQS_ROUTING_REGNAME, &dwDef ) ;
   if (dwMQSRouting == dwDef)
   {
      TrERROR(DS, "QMInit :: Could not retrieve data for value MQSRouting in registry");
      return MQ_ERROR;
   }

   m_bMQSRouting = (dwMQSRouting != 0);

   TrTRACE(GENERAL, "Setting QM Routing status: %d",m_bMQSRouting);
   return MQ_OK;
}

HRESULT
CQueueMgr::SetMQSTransparentSFD(
    void
    )
{
   DWORD dwDef = 0xfffe ;
   DWORD dwMQSTransparentSFD;
   READ_REG_DWORD(dwMQSTransparentSFD, MSMQ_MQS_TSFD_REGNAME, &dwDef ) ;

   if (dwMQSTransparentSFD == dwDef)
   {
        m_bTransparentSFD = false;
   }
   else
   {
        m_bTransparentSFD = (dwMQSTransparentSFD != 0);
   }


   TrTRACE(GENERAL, "Setting QM TransparentSFD status: %d",m_bTransparentSFD);
   return MQ_OK;
}



HRESULT
CQueueMgr::SetMQSDepClients(
    void
    )
{
   DWORD dwDef = 0xfffe ;
   DWORD dwMQSDepClients;
   READ_REG_DWORD(dwMQSDepClients, MSMQ_MQS_DEPCLINTS_REGNAME, &dwDef ) ;
   if (dwMQSDepClients == dwDef)
   {
      TrERROR(DS, "QMInit::Could not retrieve data for value MQSDepClients in registry");
      return MQ_ERROR;
   }

   m_bMQSDepClients = (dwMQSDepClients != 0);

   TrTRACE(GENERAL, "Setting QM Dependent Clients Servicing state: %d",m_bMQSDepClients);
   return MQ_OK;
}

HRESULT
CQueueMgr::SetEnableReportMessages(
    void
    )
{
   DWORD dwDef = MSMQ_REPORT_MESSAGES_DEFAULT ;
   DWORD dwEnableReportMessages;
   READ_REG_DWORD(dwEnableReportMessages, MSMQ_REPORT_MESSAGES_REGNAME, &dwDef ) ;

   m_bEnableReportMessages = (dwEnableReportMessages != 0);

   TrTRACE(GENERAL, "Setting Enable Report Messages state: %d",m_bEnableReportMessages);
   return MQ_OK;
}


void
CQueueMgr::SetLockdown(
	void
	)
{
	DWORD dwDef = 0;
    	DWORD dwLockdown;
    	READ_REG_DWORD(dwLockdown, MSMQ_LOCKDOWN_REGNAME, &dwDef);
    	if (dwLockdown == dwDef)
    	{
    		m_fLockdown = false;
    		return;
    	}
   	 m_fLockdown = true;
}


void
CQueueMgr::SetPublicQueueCreationFlag(
	void
	)
{
	DWORD dwDef = MSMQ_SERVICE_QUEUE_CREATION_DEFAULT;
	DWORD dwQueueCreation;
	READ_REG_DWORD(dwQueueCreation, MSMQ_SERVICE_QUEUE_CREATION_REGNAME, &dwDef);
	m_fCreatePublicQueueOnBehalfOfRT = (dwQueueCreation != 0);
}


bool CFunc_dscmp::operator()(LPCWSTR str1, LPCWSTR str2) const
{
	int ret = CompareStringW(
					DS_DEFAULT_LOCALE,
					DS_DEFAULT_LOCALE_COMPARE_FLAGS,
					str1,
					-1,
					str2,
					-1
					);
	
	return (ret == CSTR_LESS_THAN);
}


bool
QmpIsDestinationSystemQueue(
	const QUEUE_FORMAT& DestinationQueue
	)
{
	CQueue* pQueue;
	try
	{
		HRESULT hr = QueueMgr.GetQueueObject(&DestinationQueue, &pQueue, 0, TRUE, false);
		if (FAILED(hr))
		{
			TrERROR(NETWORKING, "Failed to get the queue object for destination queue. %!hresult!", hr);
			return false;
		}
	}
	catch(const exception&)
	{
		return false;
	}

	ASSERT(pQueue != NULL);
	R<CQueue> Ref = pQueue;

	//
	// Check if the queue is local system queue
	//
	if(!pQueue->IsLocalQueue() || !pQueue->IsSystemQueue())
		return false;

	//
	// check if the system queue is notification or order queue
	//
	const QUEUE_ID* pQid = pQueue->GetQueueId();
	return ((pQid->dwPrivateQueueId == NOTIFICATION_QUEUE_ID) ||
		    (pQid->dwPrivateQueueId == ORDERING_QUEUE_ID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cqmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqmgr.h

Abstract:

    Declaration of the QM outbound queue manager

Author:

    Uri Habusha (urih)

--*/

#ifndef __CQMGR_H__
#define __CQMGR_H__

#include "session.h"
#include "cgroup.h"
#include "cqueue.h"
#include "qmsecutl.h"
#include "qmutil.h"
#include "ac.h"
#include <stlcmp.h>
#include "qmrtopen.h"

struct CFunc_dscmp : public std::binary_function<LPCWSTR, LPCWSTR, bool>
{
    bool operator() (LPCWSTR str1, LPCWSTR str2) const;
};


template <class T>
class CQueueNameToQueue
{
	typedef std::map<LPCTSTR, T, CFunc_dscmp> QMap;
	
public:
	BOOL Lookup(LPCWSTR Qname, T& pQueue)
	{
		QMap::const_iterator it = m_MapName2Q.find(Qname);
		if(it == m_MapName2Q.end())
			return FALSE;

		*(&pQueue) = it->second;

		return TRUE;
	}


	void RemoveKey(LPCWSTR Qname)
	{
		m_MapName2Q.erase(Qname);		
	}


	T& operator[](LPCWSTR Qname)
	{
		return 	m_MapName2Q[Qname];			
	}

private:
	QMap m_MapName2Q;	
};



class CQueueMgr
{
public:

    CQueueMgr();
    ~CQueueMgr();

    BOOL
    InitQueueMgr(
        void
        );


    HRESULT
    OpenQueue(
        const QUEUE_FORMAT * pQueueFormat,
        DWORD              dwCallingProcessID,
        DWORD              dwAccess,
        DWORD              dwShareMode,
        CQueue * *         ppQueue,
        LPWSTR *           lplpwsRemoteQueueName,
        PHANDLE            phQueue,
		BOOL*              pfRemoteReturn,
        BOOL               fRemote = FALSE
        );

    HRESULT
    OpenMqf(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        DWORD              dwCallingProcessID,
        HANDLE *           phDistribution
        );

    HRESULT
    OpenRRQueue(
        const QUEUE_FORMAT*          pQueueFormat,
        DWORD                        dwCallingProcessID,
        DWORD                        dwAccess,
        DWORD                        dwShareMode,
        ULONG                        srv_hACQueue,
        ULONG                        srv_pQMQueue,
        DWORD                        dwpContext,
		CAutoCloseNewRemoteReadCtxAndBind* pNewRemoteReadContextAndBind,
	    CBindHandle&		         hBind,
        PHANDLE                      phQueue
        );

    void
    ValidateOpenedQueues(
        void
        );

    void
    ValidateMachineProperties(
        void
        );

    HRESULT
    OpenAppsReceiveQueue(
        const QUEUE_FORMAT *         pQueueFormat,
        LPRECEIVE_COMPLETION_ROUTINE lpReceiveRoutine
        );

    HRESULT
    SendPacket(
        CMessageProperty *   pmp,
        const QUEUE_FORMAT   DestinationMqf[],
        ULONG                nDestinationMqf,
        const QUEUE_FORMAT * pAdminQueueFormat,
        const QUEUE_FORMAT * pResponseQueueFormat
        );

    void
    AddQueueToHashAndList(
        CQueue* pQueue
        );

    void
    RemoveQueueFromHash(
        CQueue* pQueue
        );

    void
    RemoveQueue(
        CQueue * pQueue
        );

    void
    ReleaseQueue(
        void
        );

    HRESULT
    GetQueueObject(
        const QUEUE_FORMAT * pqf,
        CQueue * *           ppQueue,
        const GUID *         pgConnectorQM,
        bool                 fInReceive,
        bool                 fInSend,
		const CSenderStream* pSenderStream = NULL
        );


	BOOL
	LookupQueueInIdMap(
		const QUEUE_ID* pid,
		CQueue** ppQueue
		);

	
	BOOL
	LookupQueueInNameMap(
		LPCWSTR queueName,
		CQueue** ppQueue
		);

	
    BOOL
    LookUpQueue(
        const QUEUE_FORMAT * pqf,
        CQueue * *           ptQueue,
        bool                 fInReceive,
        bool                 fInSend
        );

    void
    NotifyQueueDeleted(
        const QUEUE_FORMAT& qf
        );

    VOID
    UpdateQueueProperties(
        const QUEUE_FORMAT * pQueueFormat,
        DWORD                cpObject,
        PROPID               pPropObject[],
        PROPVARIANT          pVarObject[]
        );

    void
    UpdateMachineProperties(
        DWORD       cpObject,
        PROPID      pPropObject[],
        PROPVARIANT pVarObject[]
        );

    BOOL
    IsOnHoldQueue(
        const CQueue* pQueue
        )
    {
        return (!IsConnected() || pQueue->IsOnHold());
    }

    void
    MoveQueueToOnHoldGroup(
        CQueue * pQueue
        );

	void
	MoveQueueToLockedGroup(
		CQueue* pQueue
		);

	void
	MovePausedQueueToNonactiveGroup(
        CQueue * pQueue
        );

#ifdef _DEBUG

	bool
    IsQueueInList(
        const CBaseQueue * pQueue
        );

#endif

    static
    bool
    IsConnected(
        void
        )
    {
        return (m_Connected != 0);
    }

    static
    void
    InitConnected(
        void
        );

    void
    SetConnected(
       void
       );

	void
	SetDisconnected(
		void
		);

	
    static
    bool
    CanAccessDS(
        void
        )
    {
        return  (IsConnected() && IsDSOnline());
    }

    static
    HRESULT
        SetQMGuid(
        void
        );

    static
    HRESULT
    SetQMGuid(
        const GUID * pGuid
        );

    static
    const GUID*
    GetQMGuid(
        void
        )
    {
	    ASSERT( m_guidQmQueue != GUID_NULL);
        return(&m_guidQmQueue);
    }

    static
    bool
    IsDSOnline(
        void
        )
    {
        return m_fDSOnline;
    }

    static
    void
    SetDSOnline(
        bool f
        )
    {
        m_fDSOnline = f;
    }

    static
    void
    SetReportQM(
        bool f
        )
    {
        m_fReportQM = f;
    }

    static
    bool
    IsReportQM(
        void
        )
    {
        return m_fReportQM;
    }

    static
    HRESULT
    SetMQSRouting(
        void
        );

    static
    bool
    GetMQSRouting(
        void
        )
    {
        return m_bMQSRouting;
    }

    static
    HRESULT
    SetMQSTransparentSFD(
        void
        );

    static
    bool
    GetMQSTransparentSFD(
        void
        )
    {
        return m_bTransparentSFD;
    }


    static
    HRESULT
    SetMQSDepClients(
        void
        );

    static
    HRESULT
    SetEnableReportMessages(
        void
        );

    static
    bool
    GetMQSDepClients(
        void
        )
    {
        return m_bMQSDepClients;
    }

    static
    bool
    GetEnableReportMessages(
        void
        )
    {
        return m_bEnableReportMessages;
    }

    static
    void
    WINAPI
    QueuesCleanup(
        CTimer * pTimer
        );

    static
    bool
    IgnoreOsValidation(
        void
        )
    {
        return m_bIgnoreOsValidation ;
    }

    static
    bool
    GetLockdown(
    	void
    	)
    {
    	return m_fLockdown;
    }


    static
    bool
    GetCreatePublicQueueFlag(
    	void
    	)
    {
    	return m_fCreatePublicQueueOnBehalfOfRT;
    }


    static
    void
    SetLockdown(
    	void
    	);


    static
    void
    SetPublicQueueCreationFlag(
    	void
    	);


    //
    // Administration functions
    //

    void
    GetOpenQueuesFormatName(
        LPWSTR** pppFormatName,
        LPDWORD  pdwFormatSize
        );

private:

    HRESULT
    CreateACQueue(
        CQueue *             pQueue,
        const QUEUE_FORMAT * pQueueFormat,
		const CSenderStream* pSenderStream
        );


    //
    //  Create standard queue object. For send and local read.
    //
    HRESULT
    CreateQueueObject(
        const QUEUE_FORMAT * pQueueFormat,
        CQueue * *           ppQueue,
        DWORD                dwAccess,
        LPWSTR *             lplpwsRemoteQueueName,
        BOOL *               pfRemoteReturn,
        BOOL                 fRemoteServer,
        const GUID *         pgConnectorQM,
        bool                 fInReceive,
        bool                 fInSend,
		const CSenderStream* pSenderStream
        );

    void
    AddToActiveQueueList(
        const CBaseQueue * pQueue
        );

    HRESULT
    GetDistributionQueueObject(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        CQueue * *         ppQueue
        );

    VOID
    ExpandMqf(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        ULONG *            pnLeafMqf,
        QUEUE_FORMAT * *   ppLeafMqf
        ) const;

    HRESULT
    CreateACDistribution(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        ULONG              nLeafMqf,
        const R<CQueue>    LeafQueues[],
        const bool         ProtocolSrmp[],
        HANDLE *           phDistribution
        );

private:

    CCriticalSection m_cs;
    CCriticalSection m_csMgmt;

    //
    // Guid of the QM queue
    //
    static GUID m_guidQmQueue;

    //
    // DS initilization status
    //
    static bool m_fDSOnline;
    static bool m_bIgnoreOsValidation ;
    static LONG m_Connected;
    static bool m_fReportQM;
    static bool m_bMQSRouting;
    static bool m_bMQSDepClients;
	static bool m_bEnableReportMessages;
    static bool m_fLockdown;
    static bool m_fCreatePublicQueueOnBehalfOfRT;
    static bool m_bTransparentSFD;

    CTimeDuration m_CleanupTimeout;

    CMap<const QUEUE_ID*, const QUEUE_ID*, CQueue*, CQueue*&> m_MapQueueId2Q ;
	CQueueNameToQueue<CQueue*> m_MapName2Q;

    //
    // Clean Up variables
    //
    BOOL m_fQueueCleanupScheduled;
    CTimer m_QueueCleanupTimer;
    CList <const CBaseQueue *, const CBaseQueue *> m_listQueue;
};


extern CQueueMgr QueueMgr;

//
//  Compare two const strings
//
template<>
extern BOOL AFXAPI  CompareElements(const LPCTSTR* MapName1, const LPCTSTR* MapName2);



HRESULT
QmpGetQueueProperties(
    const QUEUE_FORMAT * pQueueFormat,
    PQueueProps          pQueueProp,
    bool                 fInReceive,
    bool                 fInSend
    );


inline
BOOL
QmpIsLocalMachine(
    const GUID * pGuid
    )
{
    return(pGuid ? (*pGuid == *CQueueMgr::GetQMGuid()) : FALSE);
}


#endif // __CQMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cqpriv.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqpriv.cpp

Abstract:

    This module implements QM Private queue

Author:

    Uri Habusha (urih)

--*/

#include "stdh.h"
#include <Msm.h>
#include <mqexception.h>
#include "cqpriv.h"
#include "cqmgr.h"
#include "_mqdef.h"
#include <mqsec.h>
#include "regqueue.h"
#include "mqutil.h"
#include "lqs.h"

#include <strsafe.h>

#include "cqpriv.tmh"

extern LPWSTR  g_szMachineName;
extern BOOL g_fWorkGroupInstallation;

static WCHAR g_nullLable[2] = L"";

static PROPID g_propidQueue [] = {
                PROPID_Q_LABEL,
                PROPID_Q_TYPE,
                PROPID_Q_PATHNAME,
                PROPID_Q_JOURNAL,
                PROPID_Q_QUOTA,
                PROPID_Q_SECURITY,
                PROPID_Q_JOURNAL_QUOTA,
                PROPID_Q_CREATE_TIME,
                PROPID_Q_BASEPRIORITY,
                PROPID_Q_MODIFY_TIME,
                PROPID_Q_AUTHENTICATE,
                PROPID_Q_PRIV_LEVEL,
                PROPID_Q_TRANSACTION,
                PPROPID_Q_SYSTEMQUEUE,
                PROPID_Q_MULTICAST_ADDRESS
                };

#define NPROPS (sizeof(g_propidQueue)/sizeof(PROPID))

static PROPVARIANT g_propvariantQueue[NPROPS];

static DWORD g_QueueSecurityDescriptorIndex;
static DWORD g_QueueCreateTimeIndex;
static DWORD g_QueueModifyTimeIndex;

CQPrivate g_QPrivate;

static WCHAR *s_FN=L"cqpriv";

//
// PROPERTY_MAP is a class that mapps from the property id to it's index in
// propvariants array.
//
class PROPERTY_MAP
{
public:
    PROPERTY_MAP(PROPID *, DWORD);
    ~PROPERTY_MAP();
    int operator [](PROPID);

private:
    PROPID m_propidMax;
    PROPID m_propidMin;
    int *m_pMap;
};

PROPERTY_MAP::PROPERTY_MAP(PROPID *aProps, DWORD cProps)
{
    DWORD i;

    m_pMap = NULL;

    if (!cProps)
    {
        return;
    }

    //
    // Find the maximum and minimum values of the propery IDs
    //
    for (i = 1, m_propidMax = aProps[0], m_propidMin = aProps[0];
         i < cProps;
         i++)
    {
        if (m_propidMax < aProps[i])
        {
            m_propidMax = aProps[i];
        }

        if (m_propidMin > aProps[i])
        {
            m_propidMin = aProps[i];
        }
    }

    //
    // Allocate memory for the map.
    //
    m_pMap = new int[m_propidMax - m_propidMin + 1];

    //
    // Fill the entier map with -1s. Property IDs that does not exist will
    // result in a -1.
    //
    for (i = 0; i < m_propidMax - m_propidMin + 1; i++)
    {
        m_pMap[i] = -1;
    }

    //
    // Fill the map with the indesis of the property IDs.
    //
    for (i = 0; i < cProps; i++)
    {
        m_pMap[aProps[i] - m_propidMin] = i;
    }
}

PROPERTY_MAP::~PROPERTY_MAP()
{
    delete[] m_pMap;
}

int PROPERTY_MAP::operator[] (PROPID PropId)
{
    if ((PropId > m_propidMax) || (PropId < m_propidMin))
    {
        //
        // Out of range.
        //
        return -1;
    }

    return m_pMap[PropId - m_propidMin];
}


static PROPERTY_MAP g_mapQueuePropertyToIndex(g_propidQueue, NPROPS);

/*====================================================

CQPrivate::IsLocalPrivateQueue

Arguments:

Return Value:


=====================================================*/
inline BOOL IsLocalPrivateQueue(IN const QUEUE_FORMAT* pQueueFormat)
{
    switch (pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // We never call it in the receive pass (YoelA, 6-Aug-2000)
            //
            return IsLocalDirectQueue(pQueueFormat, false, false);

        case QUEUE_FORMAT_TYPE_PRIVATE:
            return QmpIsLocalMachine(&pQueueFormat->PrivateID().Lineage);

    }

    return FALSE;
}


inline
HRESULT
ReplaceDNSNameWithNetBiosName(
    LPCWSTR PathName,
    LPWSTR ReplaceName,
    size_t ReplaceNameSizeInChar
    )
{
    //
    // We want to keep the queue with a single name representation. Replace the
    // DNS name with a NetBios Name
    //
    LPWSTR FirstSlash = wcschr(PathName,L'\\');
	if(FirstSlash == NULL)
	{
		TrERROR(GENERAL, "Bad pathname. Missing backslash in %ls", PathName);
		ASSERT(("Missing backslash in pathname.", 0));
		return MQ_ERROR_INVALID_PARAMETER;
	}

	HRESULT hr = StringCchPrintf(ReplaceName, ReplaceNameSizeInChar, L"%s%s", g_szMachineName, FirstSlash);	
	return hr;
}


/*====================================================

CQPrivate::CQPrivate

Arguments:

Return Value:

=====================================================*/

CQPrivate::CQPrivate()
{
   m_dwMaxSysQueue = 0 ;
}

/*====================================================

CQPrivate::~CQPrivate

Arguments:

Return Value:


=====================================================*/
CQPrivate::~CQPrivate()
{
}

/*====================================================

CQPrivate::QMSetupCreateSystemQueue

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMSetupCreateSystemQueue(
	IN LPCWSTR lpwcsPathName,
	IN DWORD   dwQueueId,
	IN bool fIsTriggersQueue
	)
{

    //
    // Object not initialized yet
    //
    ASSERT(m_dwMaxSysQueue != 0);

    HRESULT rc;

    TrTRACE(GENERAL, " MQSetupCreatePrivateQueue - Queue Path name: %ls", lpwcsPathName);

    //
    // Set default values for all the queue properties
    // that were not provided by the caller
    //
    DWORD cpObject;
    PROPID* pPropObject;
    AP<PROPVARIANT> pVarObject;
    P<VOID> pSecurityDescriptor;
    P<VOID> pSysSecurityDescriptor;
    P<ACL> pDacl;

    //
    // Set the queue's DACL so that the local administrators group
    // will have full control over the queue, except for delete access right.
	// Everyone will have the Generic write (send, get).
	// Anonymous will have only write message (send) access.
    //
    pSysSecurityDescriptor = new SECURITY_DESCRIPTOR;
    InitializeSecurityDescriptor(
			pSysSecurityDescriptor,
			SECURITY_DESCRIPTOR_REVISION
			);

    //
    // SID for the local administrators group.
    //
	PSID pAdminSid = MQSec_GetAdminSid();
	DWORD AdminSidLength = GetLengthSid(pAdminSid) ;
	DWORD Sids = 1;
	
	PSID pAnonymousSid = NULL;
	DWORD AnonymousSidLength = 0;
	PSID pEveryoneSid = NULL;
	DWORD EveryoneSidLength = 0;
	PSID pNetworkServiceSid = NULL;
	DWORD NetworkServiceSidLength = 0;
	
	if (!fIsTriggersQueue)
	{
    	pAnonymousSid = MQSec_GetAnonymousSid();
    	AnonymousSidLength = GetLengthSid(pAnonymousSid);

	    pEveryoneSid = MQSec_GetWorldSid();
	    EveryoneSidLength = GetLengthSid(pEveryoneSid);

	    Sids += 2;
	}
	else
	{
		pNetworkServiceSid = MQSec_GetNetworkServiceSid();
		NetworkServiceSidLength = GetLengthSid(pNetworkServiceSid);

		Sids ++;
	}

	
	//
    // Calculate the required DACL size and allocate it.
    //
    DWORD dwDaclSize = sizeof(ACL) +
                 Sids * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                 AdminSidLength +
				 EveryoneSidLength +
				 AnonymousSidLength +
				 NetworkServiceSidLength;

    pDacl = (PACL)(char*) new BYTE[dwDaclSize];

    //
    // Initialize the DACL and fill it with the two ACEs
    //
    InitializeAcl(pDacl, dwDaclSize, ACL_REVISION);

	BOOL fSuccess = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					MQSEC_QUEUE_GENERIC_ALL & ~MQSEC_DELETE_QUEUE,
					pAdminSid
					);
	ASSERT(fSuccess);

	if (!fIsTriggersQueue)
	{
	    fSuccess = AddAccessAllowedAce(
						pDacl,
						ACL_REVISION,
						MQSEC_QUEUE_GENERIC_WRITE,
						pEveryoneSid
						);

		ASSERT(fSuccess);

		fSuccess = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					MQSEC_WRITE_MESSAGE,
					pAnonymousSid
					);

		ASSERT(fSuccess);
	}
	else
	{
		fSuccess = AddAccessAllowedAce(
						pDacl,
						ACL_REVISION,
						MQSEC_QUEUE_GENERIC_ALL & ~MQSEC_DELETE_QUEUE,
						pNetworkServiceSid
						);

		ASSERT(fSuccess);
	}

    SetSecurityDescriptorDacl(pSysSecurityDescriptor, TRUE, pDacl, FALSE);

    //
    // Create a default security descriptor.
    //
    HRESULT hr = MQSec_GetDefaultSecDescriptor(
						MQDS_QUEUE,
						&pSecurityDescriptor,
						FALSE, // fImpersonate
						pSysSecurityDescriptor,
						0,     // seInfoToRemove
						e_UseDefaultDacl
						);
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Faild to create a default security descriptor because of low resources. %!hresult!", hr);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    rc = SetQueueProperties(
				lpwcsPathName,
				pSecurityDescriptor,
				0,
				NULL,
				NULL,
				&cpObject,
				&pPropObject,
				&pVarObject
				);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 30);
    }
    //
    // Set Path Name + queue name
    //
    LPTSTR lpszQueueName;

    lpszQueueName = _tcschr(lpwcsPathName,TEXT('\\'));
    if (lpszQueueName++ == NULL)
	{
        return LogHR(MQ_ERROR, s_FN, 40);
    }

    pVarObject[g_mapQueuePropertyToIndex[PROPID_Q_PATHNAME]].pwszVal =  (LPTSTR)lpwcsPathName;
    pVarObject[g_mapQueuePropertyToIndex[PROPID_Q_LABEL]].pwszVal = lpszQueueName;
    pVarObject[g_mapQueuePropertyToIndex[PPROPID_Q_SYSTEMQUEUE]].bVal = true;

	//
	// Set system queues to max priority.
	//
	pVarObject[g_mapQueuePropertyToIndex[PROPID_Q_BASEPRIORITY]].lVal =  DEFAULT_SYS_Q_BASEPRIORITY ;

    rc = RegisterPrivateQueueProperties(
			lpwcsPathName,
			dwQueueId,
			TRUE,
			cpObject,
			pPropObject,
			pVarObject
			);

    if (SUCCEEDED(rc))
    {
       //
       // try to open the queue. If file is not valid (e.g., because
       // disk is full) then LQSOpen fail and delete the file.
       //
       CHLQS hLQS;
       rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    }

    return LogHR(rc, s_FN, 45);
}

/*====================================================

CQPrivate::QMCreatePrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMCreatePrivateQueue(LPCWSTR lpwcsPathName,
                                PSECURITY_DESCRIPTOR  pSecurityDescriptor,
                                DWORD       cp,
                                PROPID      aProp[],
                                PROPVARIANT apVar[],
                                BOOL        fCheckAccess
                               )
{
    HRESULT rc;

    TrTRACE(GENERAL, " MQDSCreatePrivateQueue - Queue Path name: %ls", lpwcsPathName);

    //
    // Check that it is local machine
    //
    BOOL fDNSName;
    BOOL fLocalMachine = IsPathnameForLocalMachine(lpwcsPathName, &fDNSName);
    if (!fLocalMachine)
	    return LogHR(MQ_ERROR_ILLEGAL_QUEUE_PATHNAME, s_FN, 50);

    WCHAR QueuePathName[MAX_COMPUTERNAME_LENGTH + MQ_MAX_Q_NAME_LEN + 2];
    if (fDNSName)
    {
        rc = ReplaceDNSNameWithNetBiosName(lpwcsPathName, QueuePathName, TABLE_SIZE(QueuePathName));
		if(FAILED(rc))
			return rc;
        lpwcsPathName = QueuePathName;
    }

    if (fCheckAccess)
    {
        //
        // Verify the the user has access rights to create a private queue.
        //
        rc = CheckPrivateQueueCreateAccess();
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 60);
        }
    }

    //
    // Try to open the queue, if we succeed, it means that the queue
    // already exist.
    //
    CHLQS hLQS;
    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (SUCCEEDED(rc))
    {
    	TrWARNING(GENERAL, "The queue %ls already exists.", lpwcsPathName);
    	return MQ_ERROR_QUEUE_EXISTS;
    }

    //
    // Set default values for all the queue properties
    // that were not provided by the caller
    //
    DWORD cpObject;
    PROPID* pPropObject;
    AP<PROPVARIANT> pVarObject;
    P<VOID> pDefaultSecurityDescriptor ;

    //
    // Fill with default vaules any missing part of the security descriptor.
    //
    HRESULT hr = MQSec_GetDefaultSecDescriptor(
						MQDS_QUEUE,
						&pDefaultSecurityDescriptor,
						TRUE, // fImpersonate
						pSecurityDescriptor,
						0,    // seInfoToRemove
						e_UseDefaultDacl,
						MQSec_GetLocalMachineSid(FALSE, NULL)
						);
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Faild to get default security descriptor because of low resources. %!hresult!", hr);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    pSecurityDescriptor = pDefaultSecurityDescriptor;


    rc = SetQueueProperties(lpwcsPathName,
                            pSecurityDescriptor,
                            cp,
                            aProp,
                            apVar,
                            &cpObject,
                            &pPropObject,
                            &pVarObject
                           );

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 90);
    }

    DWORD dwQueueId;

    rc = GetNextPrivateQueueId(&dwQueueId);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 100);
    }

    rc = RegisterPrivateQueueProperties(lpwcsPathName,
                                        dwQueueId,
                                        TRUE,
                                        cpObject,
                                        pPropObject,
                                        pVarObject);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 110);
    }

    //
    // try to open the queue. If file is not valid (e.g., because
    // disk is full) then LQSOpen fail and delete the file.
    //
    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 111);
    }

    //
    // Notify the queue manager about properties changes.
    // Build the queue format as private queue type, since bind/unbind
    // to multicast group is done only for private or public queues (not direct).
    //
    QUEUE_FORMAT qf(*QueueMgr.GetQMGuid(), dwQueueId);
    QueueMgr.UpdateQueueProperties(&qf, cp, aProp, apVar);

    return rc;
}

/*====================================================

CQPrivate::QMGetPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueuePropertiesInternal(IN  LPCWSTR lpwcsPathName,
                                               IN  DWORD cp,
                                               IN  PROPID aProp[],
                                               IN  PROPVARIANT apVar[]
                                            )
{
    HRESULT rc;
    CHLQS hLQS;

    TrTRACE(GENERAL, " QMGetPrivateQueueProperties - Queue Path name: %ls", lpwcsPathName);

    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to open the private queue %ls. %!hresult!", lpwcsPathName , rc);   
        return rc;
    }

    rc = LQSGetProperties(hLQS, cp, aProp, apVar);
    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to get properties for private queue %ls. %!hresult!", lpwcsPathName , rc);   
    }

    return rc;

}

/*====================================================

CQPrivate::QMGetPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueueProperties(IN  QUEUE_FORMAT* pQueueFormat,
                                       IN  DWORD cp,
                                       IN  PROPID aProp[],
                                       IN  PROPVARIANT apVar[]
                                      )
{
    HRESULT rc;

    ASSERT(pQueueFormat != NULL);

    rc = ValidateProperties(cp, aProp);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 150);
    }

    DWORD QueueId;
    rc = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(rc))
        return LogHR(rc, s_FN, 160);

    //
    // Verify that the user has access rights to get the queue properties.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);
    rc = QSec.AccessCheck(MQSEC_GET_QUEUE_PROPERTIES);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 170);
    }

    HRESULT hr2 = QMGetPrivateQueuePropertiesInternal(QueueId,
                                               cp,
                                               aProp,
                                               apVar
                                              );
    return LogHR(hr2, s_FN, 175);
}

/*====================================================

CQPrivate::QMGetPrivateQueuePropertiesInternal

Arguments:

Return Value:

=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueuePropertiesInternal(IN  DWORD       Uniquifier,
                                               IN  DWORD       cp,
                                               IN  PROPID      aProp[],
                                               IN  PROPVARIANT apVar[]
                                              )
{
    HRESULT rc;

    //
    //  Clear all the pointers of VT_NULL variants
    //
    for ( DWORD i = 0; i < cp ; i++)
    {
        if (apVar[i].vt == VT_NULL)
        {
            memset( &apVar[i].caub, 0, sizeof(CAUB));
        }
    }

    CHLQS hLQS;

    rc = LQSOpen(Uniquifier, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 180);
    }

    HRESULT hr2 = LQSGetProperties(hLQS, cp, aProp, apVar);
    return LogHR(hr2, s_FN, 190);
}

/*====================================================

CQPrivate::QMDeletePrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMDeletePrivateQueue(IN  QUEUE_FORMAT* pQueueFormat)
{
    HRESULT rc;

    ASSERT(pQueueFormat != NULL);

    DWORD QueueId;
    rc = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(rc))
        return LogHR(rc, s_FN, 200);

    //
    // Verify that the user has access rights to delete the queue.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);
    rc = QSec.AccessCheck(MQSEC_DELETE_QUEUE);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 210);
    }

    TrTRACE(GENERAL, "Private Queue: %!guid!\\%d was deleted", &(pQueueFormat->PrivateID().Lineage), pQueueFormat->PrivateID().Uniquifier);

	//
    // Generate context to allow deleting key in a critical section
    //
    {
        //
        // lock before changing the map - to allow safe reading of the map.
        //
        CS lock(m_cs);
		QueueMgr.NotifyQueueDeleted(*pQueueFormat);
    }

    HRESULT hr2 = LQSDelete(QueueId);
    if (FAILED(hr2))
    {
        return LogHR(hr2, s_FN, 220);
    }

    QUEUE_FORMAT qf(*QueueMgr.GetQMGuid(), QueueId);
    MsmUnbind(qf);

    return hr2;
}

/*====================================================

CQPrivate::QMPrivateQueuePathToQueueFormat

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMPrivateQueuePathToQueueFormat(
    LPCWSTR lpwcsPathName,
    QUEUE_FORMAT* pQueueFormat
    )
{
    DWORD dwQueueId;
    HRESULT rc;

    if (g_fWorkGroupInstallation)
    {
        //
        // if the machine is MSMQ workgroup machine, the routine returns
        // direct format name. This is use to enables the application to pass
        // the queue as a response queue, or admin queue
        //
        DWORD size = FN_DIRECT_OS_TOKEN_LEN + 1 + wcslen(lpwcsPathName)+1;
        AP<WCHAR> pQueueFormatName = new WCHAR[size];
        rc = StringCchPrintf(pQueueFormatName, size, L"%s%s", FN_DIRECT_OS_TOKEN, lpwcsPathName);
        ASSERT(SUCCEEDED(rc));

        //
        //  verify validity of local queue
        //
        DWORD dwTmp;
        rc = QMPrivateQueuePathToQueueId(lpwcsPathName, &dwTmp);
        if (FAILED(rc))
        {
	    	TrERROR(GENERAL, "Failed to get id from path name for %ls. %!hresult!", lpwcsPathName, rc);
        	return rc;
        }
        pQueueFormat->DirectID(pQueueFormatName.detach());
        return MQ_OK;
    }

    AP<WCHAR> lpwcsQueueName = newwcs(lpwcsPathName);
    CharLower(lpwcsQueueName);

    rc = QMPrivateQueuePathToQueueId(lpwcsPathName, &dwQueueId);
    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to get id from path name for %ls. %!hresult!", lpwcsPathName, rc);
        return rc;
    }

    pQueueFormat->PrivateID(*CQueueMgr::GetQMGuid(), dwQueueId);

    return(MQ_OK);
}

/*====================================================

QmpPrepareSetPrivateQueueProperties

Arguments:

Return Value:

=====================================================*/
static
HRESULT
QmpPrepareSetPrivateQueueProperties(
    HLQS          hLqs,
    DWORD         cProps,
    PROPID        aProp[],
    PROPVARIANT   aVar[],
    DWORD *       pcProps1,
    PROPID *      paProp1[],
    PROPVARIANT * paVar1[]
    )
{
    //
    // Query LQS if queue is transactional
    //
    PROPID aPropXact[1];
    PROPVARIANT aVarXact[1];
    aPropXact[0] = PROPID_Q_TRANSACTION;
    aVarXact[0].vt = VT_UI1;

    HRESULT rc = LQSGetProperties(hLqs, 1, aPropXact, aVarXact);
    if (FAILED(rc))
    {
        return rc;
    }

    //
    // Allocate new structures
    //
    DWORD cProps1 = cProps + 1;
    AP<PROPID> aProp1;
    AP<PROPVARIANT> aVar1;

    try
    {
        aProp1 = new PROPID[cProps1];
        aVar1  = new PROPVARIANT[cProps1];
    }
    catch (const std::exception&)
    {
    	TrERROR(GENERAL, "Faild to allocate memory for array of PROPID or PROPVARIANT.");
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the transactional property to the allocated structures
    //
    aProp1[0] = aPropXact[0];
    aVar1[0]  = aVarXact[0];

    //
    // Copy the original properties to the allocated structures
    //
    for (DWORD ix = 0; ix < cProps; ++ix)
    {
        aProp1[ix + 1] = aProp[ix];
        aVar1[ix + 1]  = aVar[ix];
    }

    //
    // Assign allocated structures to the out parameters and detach
    //
    (*pcProps1) = cProps1;
    (*paProp1) = aProp1.detach();
    (*paVar1)  = aVar1.detach();

    return MQ_OK;
}

/*====================================================

QMSetPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMSetPrivateQueueProperties(
    IN  QUEUE_FORMAT* pQueueFormat,
    IN  DWORD cp,
    IN  PROPID aProp[],
    IN  PROPVARIANT apVar[]
    )
{
    HRESULT rc;

    ASSERT(pQueueFormat != NULL);

    rc = ValidateProperties(cp, aProp);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 250);
    }

    DWORD QueueId;
    rc = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(rc))
        return LogHR(rc, s_FN, 260);

    //
    // Verify that the user has access rights to set the queue props.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);
    rc = QSec.AccessCheck(MQSEC_SET_QUEUE_PROPERTIES);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 270);
    }

    rc = QMSetPrivateQueuePropertiesInternal( QueueId,
                    	                      cp,
                    	                      aProp,
                    	                      apVar
                                        	) ;
    return LogHR(rc, s_FN, 290);
}

/*====================================================

QMSetPrivateQueuePropertiesInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
CQPrivate::QMSetPrivateQueuePropertiesInternal(
                    	IN  DWORD       Uniquifier,
                    	IN  DWORD       cp,
                    	IN  PROPID      aProp[],
                    	IN  PROPVARIANT apVar[]
                    	)
{
    HRESULT rc;
    CHLQS hLQS;

    rc = LQSOpen(Uniquifier, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 780);
    }

    //
    // UpdateQueueProperties needs to know if queue is transactional,
    // so handle allocations and operations that can fail before calling
    // RegisterPrivateQueueProperties().
    //
    AP<PROPID> aProp1;
    AP<PROPVARIANT> aVar1;
    ULONG cProps1;

    rc = QmpPrepareSetPrivateQueueProperties( hLQS,
                                              cp,
                                              aProp,
                                              apVar,
                                             &cProps1,
                                             &aProp1,
                                             &aVar1 ) ;
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 790);
    }

    rc = LQSSetProperties(hLQS, cp, aProp, apVar);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 800);
    }

    //
    // Build the queue format as private queue type, since bind/unbind
    // to multicast group is done only for private or public queues (not direct).
    //
    QUEUE_FORMAT qf(*QueueMgr.GetQMGuid(), Uniquifier);
    QueueMgr.UpdateQueueProperties(&qf, cProps1, aProp1 ,aVar1);

    return LogHR(rc, s_FN, 300);
}

/*====================================================

CQPrivate::QMGetPrivateQueueSecrity

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueueSecrity(IN  QUEUE_FORMAT* pQueueFormat,
                                    IN SECURITY_INFORMATION RequestedInformation,
                                    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                    IN DWORD nLength,
                                    OUT LPDWORD lpnLengthNeeded
                                   )
{
    ASSERT(pQueueFormat != NULL);

    HRESULT hr;
    DWORD QueueId;
    hr = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(hr))
        return LogHR(hr, s_FN, 310);

    //
    // Verify that the user has access rights to get the queue security.
    //
    CQMSecureablePrivateObject QSec(eQUEUE,
                                    QueueId);

    hr = QSec.GetSD(RequestedInformation,
                    pSecurityDescriptor,
                    nLength,
                    lpnLengthNeeded);
    return LogHR(hr, s_FN, 320);
}

/*====================================================

CQPrivate::QMSetPrivateQueueSecrity

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMSetPrivateQueueSecrity(IN  QUEUE_FORMAT* pQueueFormat,
                                    IN SECURITY_INFORMATION RequestedInformation,
                                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                                   )
{
    HRESULT hr;

    ASSERT(pQueueFormat != NULL);

    DWORD QueueId;
    hr = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(hr))
        return LogHR(hr, s_FN, 330);

    //
    // Verify that the user has access rights to set the queue security.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);

    hr = QSec.SetSD(RequestedInformation, pSecurityDescriptor);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340);
    }

    hr = QSec.Store() ;
    return LogHR(hr, s_FN, 350);
}

/*====================================================

CQPrivate::RegisterPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::RegisterPrivateQueueProperties(IN LPCWSTR lpszQueuePathName,
                                          IN DWORD dwQueueId,
                                          IN BOOLEAN fNewQueue,
                                          IN DWORD cpObject,
                                          IN PROPID pPropObject[],
                                          IN PROPVARIANT pVarObject[]
                                         )
{
    HRESULT rc;
    CHLQS hLQS;

    //
    // Create the queue in the local queue store
    //
    rc = LQSCreate( lpszQueuePathName,
                    dwQueueId,
                    cpObject,
                    pPropObject,
                    pVarObject,
                    &hLQS);

    if (rc == MQ_ERROR_QUEUE_EXISTS)
    {
        //
        // If the queue already exists, only set the queue props.
        //
        rc = LQSSetProperties( hLQS,
                               cpObject,
                               pPropObject,
                               pVarObject);
        if (FAILED(rc) && fNewQueue)
        {
            LQSClose(hLQS);
            hLQS = NULL;
            LQSDelete(dwQueueId);
        }
    }

    return LogHR(rc, s_FN, 360);
}

/*====================================================

CQPrivate::GetNextPrivateQueueId

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::GetNextPrivateQueueId(OUT DWORD *pdwQueueId)
{
    CS lock(m_cs);
    HRESULT rc;
    static CAutoCloseRegHandle hKey = NULL;

    if (!hKey)
    {
        rc = RegOpenKeyEx(FALCON_REG_POS,
                          GetFalconSectionName(),
                          0L,
                          KEY_WRITE | KEY_READ,
                          &hKey);
        if (rc != ERROR_SUCCESS)
        {
            TrERROR(GENERAL, "Fail to Open 'LastPrivateQueueId' Key in Falcon Registry. Error %d", rc);
            LogNTStatus(rc, s_FN, 370);
            return MQ_ERROR;
        }
    }
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);

    {
        rc = RegQueryValueEx(hKey,
                     TEXT("LastPrivateQueueId"),
                     0L,
                     &dwType,
                     (LPBYTE)pdwQueueId,
                     &cbData);
    }

    if (rc != ERROR_SUCCESS)
    {
        //
        // QFE - bug 2736: K2 setup problem with private queues
        //
        // After runing K2 setup on a cluster, the LastPrivateQueueId isn't
        // stored on the registery. When trying to create a private queue
        // the QM failes to retreive the data and returns MQ_ERROR.
        //
        // Fix
        //==========
        // when the QM failed to retrive the LAstPrivateQueueId from
        // registery, it generates this reg value and set it to 0xf.
        //
        *pdwQueueId = 0xf;
        dwType = REG_DWORD;
        rc =  RegSetValueEx(hKey,
                        L"LastPrivateQueueId",
                        0L,
                        REG_DWORD,
                        (const BYTE*)pdwQueueId,
                        sizeof(DWORD));

        ASSERT(rc == ERROR_SUCCESS);
        if (FAILED(rc))
        {
            LogHR(rc, s_FN, 380);
            return MQ_ERROR;
        }
    }

    if (dwType != REG_DWORD)
    {
        TrERROR(GENERAL, "Registry Inconsistant for 'LastPrivateQueueId' value. Type: %d", dwType);
		return MQ_ERROR;
    }

    BOOL fCheckAll = FALSE;
    rc = MQ_OK;
    while (SUCCEEDED(rc))
    {
        //
        // increment the queue Id to next queue
        //
        (*pdwQueueId)++;
        if (*pdwQueueId == 0)
        {
            if (fCheckAll)
            {
                //
                // We can't find any free ID.
                //
                return LogHR(MQ_ERROR, s_FN, 390);
            }
            ASSERT(m_dwMaxSysQueue) ;
            *pdwQueueId =  m_dwMaxSysQueue + 1 ;
            fCheckAll = TRUE;
        }

        CHLQS hLQS;

        rc = LQSOpen(*pdwQueueId, &hLQS, NULL);
    }

    //
    // Store the new value in registery
    //
    rc =  RegSetValueEx(hKey,
                    L"LastPrivateQueueId",
                    0L,
                    REG_DWORD,
                    (const BYTE*)pdwQueueId,
                    sizeof(DWORD));

    return LogHR(rc, s_FN, 400);
}


/*====================================================

CQPrivate::SetQueueProperties

Arguments:

=====================================================*/

HRESULT
CQPrivate::SetQueueProperties(
                IN  LPCWSTR                lpwcsPathName,
                IN  PSECURITY_DESCRIPTOR   pSecurityDescriptorIn,
                IN  DWORD                  cp,
                IN  PROPID                 aProp[],
                IN  PROPVARIANT            apVar[],
                OUT DWORD*                 pcpOut,
                OUT PROPID **              ppOutProp,
                OUT PROPVARIANT **         ppOutPropvariant )
{
    //
    //  allocate a copy of the default provariants
    //
    DWORD dwNumOfObjectProps = TABLE_SIZE(g_propvariantQueue);
    AP<PROPVARIANT> pAllPropvariants = new PROPVARIANT[dwNumOfObjectProps];
    memcpy (pAllPropvariants, g_propvariantQueue, sizeof(PROPVARIANT) * dwNumOfObjectProps);

    //
    //  Overwrite the defaults with the values supplied by the user
    //
    for (DWORD i =0 ; i < cp; i++)
    {
        //
        //  Get this propert index in the default arrays
        //
        int index;
        if((index = g_mapQueuePropertyToIndex[aProp[i]]) != -1)
        {
            //
            //  just copy the propety over the default value
            //
            if (aProp[i] == PROPID_Q_PATHNAME)
            {
                pAllPropvariants[index].vt = VT_LPWSTR;
                pAllPropvariants[index].pwszVal = const_cast<LPWSTR>(lpwcsPathName);
            }
            else
            {
                pAllPropvariants[index] = apVar[i];
            }
        }
    }

    //
    //  Set the security property
    //
    SECURITY_DESCRIPTOR *pPrivateSD = NULL ;


#ifdef _DEBUG
    // First verify that we're sane
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwSDRev;

    ASSERT(pSecurityDescriptorIn);
    ASSERT(GetSecurityDescriptorControl(pSecurityDescriptorIn, &sdc, &dwSDRev));
    ASSERT(dwSDRev == SECURITY_DESCRIPTOR_REVISION);
    ASSERT(sdc & SE_SELF_RELATIVE);
#endif

    //
    // Convert security descriptor to NT4 format. We keep it in LQS file
    // in NT4 format, mostly for support of cluster rolling-upgrade.
    //
    DWORD dwSD4Len = 0 ;
    P<SECURITY_DESCRIPTOR> pSD4 ;
    HRESULT hr = MQSec_ConvertSDToNT4Format(
                                MQDS_QUEUE,
                               (SECURITY_DESCRIPTOR*) pSecurityDescriptorIn,
                               &dwSD4Len,
                               &pSD4 ) ;
    ASSERT(SUCCEEDED(hr)) ;
    LogHR(hr, s_FN, 199);

    if (SUCCEEDED(hr) && (hr != MQSec_I_SD_CONV_NOT_NEEDED))
    {
        pPrivateSD = pSD4 ;
    }
    else
    {
        ASSERT(pSD4 == NULL) ;
        pPrivateSD = (SECURITY_DESCRIPTOR*) pSecurityDescriptorIn ;
    }
    ASSERT(pPrivateSD && IsValidSecurityDescriptor(pPrivateSD)) ;

    pAllPropvariants[g_QueueSecurityDescriptorIndex].blob.pBlobData =
                                            (unsigned char *) pPrivateSD ;
    pAllPropvariants[g_QueueSecurityDescriptorIndex].blob.cbSize =
           ((pPrivateSD) ? GetSecurityDescriptorLength(pPrivateSD) : 0) ;

    //
    //  Set the create and modify time
    //
    pAllPropvariants[g_QueueCreateTimeIndex].lVal = INT_PTR_TO_INT(time( NULL)); //BUGBUG bug year 2038
    pAllPropvariants[g_QueueModifyTimeIndex].lVal =
                             pAllPropvariants[g_QueueCreateTimeIndex].lVal ;

    *pcpOut =  dwNumOfObjectProps;
    *ppOutProp = g_propidQueue;
    *ppOutPropvariant = pAllPropvariants.detach();
    return(MQ_OK);
}

/*====================================================

CQPrivate::InitDefaultQueueProperties

Arguments:

Return Value:


=====================================================*/
void
CQPrivate::InitDefaultQueueProperties(void)
{
    DWORD i;
    BLOB  defaultQueueSecurity = {0, NULL};

    for (i=0; i < NPROPS; i++)
    {
        //
        //  Set default values
        //
        switch( g_propidQueue[i] )
        {
            case PROPID_Q_TYPE:
                g_propvariantQueue[i].vt = VT_CLSID;
                g_propvariantQueue[i].puuid = const_cast<GUID*>(&GUID_NULL);
                break;
            case PROPID_Q_JOURNAL:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = DEFAULT_Q_JOURNAL;
                break;
            case PROPID_Q_QUOTA:
                g_propvariantQueue[i].vt = VT_UI4;
                g_propvariantQueue[i].ulVal = DEFAULT_Q_QUOTA;
                break;
            case PROPID_Q_LABEL:
                g_propvariantQueue[i].vt = VT_LPWSTR;
                g_propvariantQueue[i].pwszVal = g_nullLable;
                break;
            case PROPID_Q_SECURITY:
                g_propvariantQueue[i].vt = VT_BLOB;
                g_propvariantQueue[i].blob = defaultQueueSecurity;
                g_QueueSecurityDescriptorIndex = i;
                break;
            case PROPID_Q_JOURNAL_QUOTA:
                g_propvariantQueue[i].vt = VT_UI4;
                g_propvariantQueue[i].ulVal = DEFAULT_Q_JOURNAL_QUOTA;
                break;
            case PROPID_Q_BASEPRIORITY:
                g_propvariantQueue[i].vt = VT_I2;
                g_propvariantQueue[i].lVal = DEFAULT_Q_BASEPRIORITY;
                break;
            case PROPID_Q_CREATE_TIME:
                g_propvariantQueue[i].vt = VT_I4;
                g_QueueCreateTimeIndex = i;
                break;
            case PROPID_Q_MODIFY_TIME:
                g_propvariantQueue[i].vt = VT_I4;
                g_QueueModifyTimeIndex =i;
                break;
            case PROPID_Q_AUTHENTICATE:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = DEFAULT_Q_AUTHENTICATE;
                break;
            case PROPID_Q_PRIV_LEVEL:
                g_propvariantQueue[i].vt = VT_UI4;
                g_propvariantQueue[i].ulVal = DEFAULT_Q_PRIV_LEVEL;
                break;
            case PROPID_Q_TRANSACTION:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = DEFAULT_Q_TRANSACTION;
                break;
            case PPROPID_Q_SYSTEMQUEUE:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = 0 ;
                break;
            case PROPID_Q_PATHNAME:
                g_propvariantQueue[i].vt = VT_LPWSTR;
                break;
            case PROPID_Q_MULTICAST_ADDRESS:
                g_propvariantQueue[i].vt = VT_EMPTY;
                break;
            default:
                g_propvariantQueue[i].vt = VT_EMPTY;
                break;
        }
    }
}



/*====================================================

CQPrivate::PrivateQueueInit

Arguments:

Return Value:


=====================================================*/

HRESULT
CQPrivate::PrivateQueueInit(void)
{
    if (m_dwMaxSysQueue)
    {
       //
       // Already initialized
       //
       return MQ_OK ;
    }

    InitDefaultQueueProperties();

    //
    // If either of these constant change, then change the size and
    // initialization of arrat m_lpSysQueueNames, below.
    //
    ASSERT(MIN_SYS_PRIVATE_QUEUE_ID == 1) ;
    ASSERT(MAX_SYS_PRIVATE_QUEUE_ID == 6) ;

    DWORD dwDefault = MAX_SYS_PRIVATE_QUEUE_ID ;
    READ_REG_DWORD( m_dwMaxSysQueue,
                    MSMQ_MAX_PRIV_SYSQUEUE_REGNAME,
                    &dwDefault ) ;

    dwDefault =  DEFAULT_SYS_Q_BASEPRIORITY ;
    READ_REG_DWORD( m_dwSysQueuePriority,
                    MSMQ_PRIV_SYSQUEUE_PRIO_REGNAME,
                    &dwDefault ) ;

   	m_lpSysQueueNames[0] = NULL;
   	m_lpSysQueueNames[1] = ADMINISTRATION_QUEUE_NAME ;
    m_lpSysQueueNames[2] = NOTIFICATION_QUEUE_NAME ;
    m_lpSysQueueNames[3] = ORDERING_QUEUE_NAME ;
    m_lpSysQueueNames[4] = NULL;
    m_lpSysQueueNames[5] = TRIGGERS_QUEUE_NAME ;

    return(MQ_OK);
}

static
HRESULT
GetPathName(DWORD dwQueueId, LPCWSTR &lpszPathName)
{
    HRESULT hr;
    CHLQS hLQS;

    hr = LQSOpen(dwQueueId, &hLQS, NULL);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }

    PROPID PropId[1];
    PROPVARIANT PropVar[1];

    PropId[0] = PROPID_Q_PATHNAME;
    PropVar[0].vt = VT_NULL;
    hr = LQSGetProperties(hLQS, 1, PropId, PropVar);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 420);
    }

    lpszPathName = PropVar[0].pwszVal;

    return LogHR(hr, s_FN, 430);
}

/*====================================================

CQPrivate::QMGetFirstPrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetFirstPrivateQueuePosition(
                               IN OUT    PVOID    &pos,
                               OUT       LPCWSTR  &lpszPathName,
                               OUT       DWORD    &dwQueueId)
{
    HRESULT hr;
    CHLQS hLQS;

    pos = NULL;

    hr = LQSGetFirst(&hLQS, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 450);
    }

    pos = hLQS;
    hLQS = NULL;

    return MQ_OK;
}

/*====================================================

CQPrivate::QMGetNextPrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetNextPrivateQueue(
                               IN OUT    PVOID    &hLQSEnum,
                               OUT       LPCWSTR  &lpszPathName,
                               OUT       DWORD    &dwQueueId)
{
    HRESULT hr;

    hr = LQSGetNext(hLQSEnum, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 460);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }

    return LogHR(hr, s_FN, 480);
}

#ifdef _WIN64
/*====================================================

CQPrivate::QMGetFirstPrivateQueueByDword

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetFirstPrivateQueuePositionByDword(OUT DWORD    &dwpos,
                                                         OUT LPCWSTR  &lpszPathName,
                                                         OUT DWORD    &dwQueueId)
{
    HRESULT hr;
    CMappedHLQS dwMappedHLQS;

    dwpos = 0;

    hr = LQSGetFirstWithMappedHLQS(&dwMappedHLQS, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 560);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 570);
    }

    dwpos = dwMappedHLQS;
    dwMappedHLQS = NULL;

    return MQ_OK;
}

/*====================================================

CQPrivate::QMGetNextPrivateQueueByDword

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetNextPrivateQueueByDword(IN OUT DWORD    &dwpos,
                                                OUT    LPCWSTR  &lpszPathName,
                                                OUT    DWORD    &dwQueueId)
{
    HRESULT hr;

    hr = LQSGetNextWithMappedHLQS(dwpos, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 580);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 590);
    }

    return LogHR(hr, s_FN, 600);
}
#endif //_WIN64
/*====================================================

CQPrivate::QMPrivateQueuePathToQueueId

Arguments:

Return Value:

=====================================================*/

HRESULT
CQPrivate::QMPrivateQueuePathToQueueId(IN LPCWSTR lpwcsPathName,
                                       OUT DWORD *pdwQueueId
                                      )
{
    HRESULT rc;
    CHLQS hLQS;

    BOOL fDNSName;
    BOOL fLocalMachine = IsPathnameForLocalMachine(lpwcsPathName, &fDNSName);
    if(!fLocalMachine)
	    return LogHR(MQ_ERROR_ILLEGAL_QUEUE_PATHNAME, s_FN, 490);

    WCHAR QueuePathName[MAX_COMPUTERNAME_LENGTH + MQ_MAX_Q_NAME_LEN + 2];
    if (fDNSName)
    {
        rc = ReplaceDNSNameWithNetBiosName(lpwcsPathName, QueuePathName, TABLE_SIZE(QueuePathName));
		if(FAILED(rc))
			return rc;

        lpwcsPathName = QueuePathName;
    }

    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to open %ls. %!hresult!", lpwcsPathName, rc);
        return rc;
    }

    rc = LQSGetIdentifier(hLQS, pdwQueueId);
    if (FAILED(rc))
    {
    	TrERROR(GENERAL, "Failed to get identifier for %ls. %!hresult!", lpwcsPathName, rc);
    }
    
    return rc;
}

/*====================================================

BOOL CQPrivate::IsPrivateSysQueue()

Arguments:

Return Value:

=====================================================*/

BOOL
CQPrivate::IsPrivateSysQueue(IN  LPCWSTR lpwcsPathName )
{
   WCHAR *pName = wcsrchr(lpwcsPathName, L'\\') ;
   if (!pName)
   {
      return FALSE ;
   }
   pName++ ;  // skip the backslash.

   for ( int j = 0 ; j < MAX_SYS_PRIVATE_QUEUE_ID ; j++ )
   {
		if ((m_lpSysQueueNames[j] != NULL) &&
			  (0 == _wcsicmp(pName, m_lpSysQueueNames[j])))
		{
			 return TRUE ;
		}
   }

   return FALSE ;
}

/*====================================================

CQPrivate::IsPrivateSysQueue()

Arguments:

Return Value:

=====================================================*/

BOOL
CQPrivate::IsPrivateSysQueue(IN  DWORD Uniquifier )
{
   ASSERT(m_dwMaxSysQueue) ;
   BOOL fSystemQueue = (Uniquifier <=  m_dwMaxSysQueue) &&
                       (Uniquifier >=  MIN_SYS_PRIVATE_QUEUE_ID) ;
   return fSystemQueue ;
}

/*====================================================

CQPrivate::GetPrivateSysQueueProperties()

Arguments:

Return Value:

=====================================================*/

HRESULT
CQPrivate::GetPrivateSysQueueProperties(IN  DWORD       cp,
                                        IN  PROPID      aProp[],
                                        IN  PROPVARIANT apVar[] )
{
   for ( DWORD j = 0 ; j < cp ; j++ )
   {
      switch (aProp[j])
      {
         case  PPROPID_Q_SYSTEMQUEUE:
            apVar[j].bVal = TRUE ;
            break ;

         case  PROPID_Q_BASEPRIORITY:
            apVar[j].iVal =  (SHORT) m_dwSysQueuePriority ;
            break ;

         default:
            break ;
      }
   }

   return MQ_OK ;
}

HRESULT
CQPrivate::GetQueueIdForDirectFormatName(
    LPCWSTR QueueFormatname,
    DWORD* pQueueId
    )
//
// Routine Description:
//      The routine gets direct format name and returns the Queue ID of the
//      corresponding queue
//
// Arguments:
//      QueueFormatname - direct queue format name
//      pQueueId - pointer to return Queue Id
//
// Returned Value:
//      MQ_OK if the Queue  exist, MQ_ERROR_QUEUE_NOT_FOUND otherwise
//
{
    //
    // build queue name
    //
    LPCWSTR lpszQueueName = wcschr(QueueFormatname, L'\\');
	if(lpszQueueName == NULL)
	{
		TrERROR(GENERAL, "Missing backslash in format name %ls", QueueFormatname);
		ASSERT(("Bad format name. Missing backslash", 0));
		return MQ_ERROR_INVALID_PARAMETER;
	}

    const DWORD x_MaxLength = MAX_COMPUTERNAME_LENGTH +                 // computer name
                              1 +                                       // '\'
                              PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH +    // "private$\"
                              MQ_MAX_Q_NAME_LEN +                       // Queue name
                              1;                                        // '\0'
    WCHAR QueuePathName[x_MaxLength];
    HRESULT hr = StringCchPrintf(QueuePathName, x_MaxLength, L"%s%s", g_szMachineName, lpszQueueName);
	if (FAILED(hr))
	{
		TrTRACE(GENERAL, "Failed to generate queue path name. %!hresult!", hr);
		return hr;
	}

    hr = QMPrivateQueuePathToQueueId(QueuePathName, pQueueId);
    return LogHR(hr, s_FN, 520);
}




HRESULT
CQPrivate::GetQueueIdForQueueFormatName(
    const QUEUE_FORMAT* pQueueFormat,
    DWORD* pQueueId
    )
//
// Routine Description:
//      The routine gets format name and returns the Queue ID of the
//      corresponding queue
//
// Arguments:
//      QueueFormatname - queue format name
//      pQueueId - pointer to return Queue Id
//
// Returned Value:
//      MQ_OK if the Queue  exist, MQ_ERROR_QUEUE_NOT_FOUND otherwise
//
{
    if (!IsLocalPrivateQueue(pQueueFormat))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 530);
    }

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
            *pQueueId = pQueueFormat->PrivateID().Uniquifier;
            return MQ_OK;

        case QUEUE_FORMAT_TYPE_DIRECT:
            return LogHR(GetQueueIdForDirectFormatName(pQueueFormat->DirectID(), pQueueId), s_FN, 540);

        default:
            ASSERT(0);
    }

    return LogHR(MQ_ERROR, s_FN, 550);
}

/*====================================================

CompareElements  of LPCTSTR

Arguments:

Return Value:


=====================================================*/

template<>
BOOL AFXAPI  CompareElements(const LPCTSTR* MapName1, const LPCTSTR* MapName2)
{
    return (_tcscmp(*MapName1, *MapName2) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\crrqmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    crrqmgr.cpp

Abstract:
    Contain CQueueMgr methods which handle client side of remote-read.

Author:
    Doron Juster  (DoronJ)

--*/


#include "stdh.h"
#include "cqpriv.h"
#include "cqmgr.h"
#include "qmutil.h"
#include "ad.h"
#include <Fn.h>
#include <strsafe.h>

#include "crrqmgr.tmh"

static WCHAR *s_FN=L"crrqmgr";

/*======================================================

Function:  CQueueMgr::CreateRRQueueObject()

Description: Create a CRRQueue object in client side of
             remote reader.

Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/

static
HRESULT
GetRRQueueProperties(
	IN  const QUEUE_FORMAT* pQueueFormat,
	IN P<GUID>& pCleanGuid,
    OUT QueueProps* pqp
	)
{
	ASSERT(pqp != NULL);

    //
    // Get Queue Properties. Name and QMId
    //
    HRESULT rc = QmpGetQueueProperties(pQueueFormat, pqp, false, false);

    if (FAILED(rc))
    {
       TrERROR(GENERAL, "CreateRRQueueObject failed, ntstatus %x", rc);
       return LogHR(rc, s_FN, 10);
    }
    //
    //  Override the Netbios name if there is a DNS name
    //
    if (pqp->lpwsQueueDnsName != NULL)
    {
        delete pqp->lpwsQueuePathName;
        pqp->lpwsQueuePathName = pqp->lpwsQueueDnsName.detach();
    }

    //
    //  Cleanup
    //
    pCleanGuid = pqp->pQMGuid;

    if (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
    {
        if (pqp->lpwsQueuePathName)
        {
            delete pqp->lpwsQueuePathName;
            pqp->lpwsQueuePathName = NULL;
            ASSERT(pqp->lpwsQueueDnsName == NULL);
        }

        if (!CQueueMgr::CanAccessDS())
        {
			TrERROR(GENERAL, "Can't access DS");
			return MQ_ERROR_NO_DS;
        }
        
        //
        // Create a dummy path name. It must start with machine name.
        // Get machine name from DS.
        //
        PROPID      aProp[2];
        PROPVARIANT aVar[2];

        aProp[0] = PROPID_QM_PATHNAME;
        aVar[0].vt = VT_NULL;
        aProp[1] = PROPID_QM_PATHNAME_DNS; // should be last
        aVar[1].vt = VT_NULL;

        rc = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,   // pwcsDomainController
					false,	// fServerName
                    pqp->pQMGuid,
                    2,
                    aProp,
                    aVar
					);

        //
        //  MSMQ 1.0 DS server do not support PROPID_QM_PATHNAME_DNS
        //  and return MQ_ERROR in case of unsupported property.
        //  If such error is returned, assume MSMQ 1.0 DS and try again
        //  this time without PROPID_QM_PATHNAME_DNS.
        //
        if (rc == MQ_ERROR)
        {
            aVar[1].vt = VT_EMPTY;
            ASSERT( aProp[1] == PROPID_QM_PATHNAME_DNS);

            rc = ADGetObjectPropertiesGuid(
						eMACHINE,
						NULL,    // pwcsDomainController
						false,	 // fServerName
						pqp->pQMGuid,
						1,   // assuming DNS property is last
						aProp,
						aVar
						);
        }

        if(FAILED(rc))
        {
			TrERROR(GENERAL, "Fail to resolve private FormatName to machineName, %!HRESULT!", rc);
			return rc;
        }

        GUID_STRING strUuid;
        MQpGuidToString(pqp->pQMGuid, strUuid);

        WCHAR wszTmp[512];

        //
        //    use dns name of remote computer if we have it
        //
        if ( aVar[1].vt != VT_EMPTY)
        {
			rc = StringCchPrintf(
						wszTmp,
						TABLE_SIZE(wszTmp),
						L"%s\\%s\\%lu",
						aVar[1].pwszVal,
						strUuid,
						pQueueFormat->PrivateID().Uniquifier
						);

            delete [] aVar[1].pwszVal;
        }
        else
        {
            rc = StringCchPrintf(
					wszTmp,
					TABLE_SIZE(wszTmp),
					L"%s\\%s\\%lu",
					aVar[0].pwszVal,
					strUuid,
					pQueueFormat->PrivateID().Uniquifier
					);
        }

        delete [] aVar[0].pwszVal;

		if (FAILED(rc))
		{
			TrERROR(GENERAL, "StringCchPrintf failed, %!HRESULT!", rc);
			return rc;
		}

		int size = wcslen(wszTmp) + 1;
        pqp->lpwsQueuePathName = new WCHAR[size];
		rc = StringCchCopy(pqp->lpwsQueuePathName, size, wszTmp);
		if (FAILED(rc))
		{
			TrERROR(GENERAL, "StringCchCopy failed, %!HRESULT!", rc);
			ASSERT(("StringCchCopy failed", 0));
			return rc;
		}
    }

    ASSERT(!pqp->fIsLocalQueue);
    ASSERT(pqp->lpwsQueuePathName);
    return MQ_OK;
}



static
HRESULT
CreateRRQueueObject(
	IN  const QUEUE_FORMAT* pQueueFormat,
	IN OUT CBindHandle&	hBind,
	OUT R<CBaseRRQueue>&  pQueue
	)
{
    QueueProps qp;
	P<GUID> pCleanGuid;
	HRESULT hr = GetRRQueueProperties(pQueueFormat, pCleanGuid, &qp);
	if(FAILED(hr))
		return hr;

	pQueue = new CRRQueue(pQueueFormat, &qp, hBind);

	//
	// Ownership of hBind was transfered to CRRQueue object.
	// hBind will be released in CRRQueue dtor
	//
	hBind.detach();
	return MQ_OK;
}


static
HRESULT
CreateNewRRQueueObject(
	IN  const QUEUE_FORMAT* pQueueFormat,
	IN OUT CAutoCloseNewRemoteReadCtxAndBind* pNewRemoteReadContextAndBind,
	OUT R<CBaseRRQueue>&  pQueue
	)
{
	ASSERT(pNewRemoteReadContextAndBind != NULL);

    QueueProps qp;
	P<GUID> pCleanGuid;
	HRESULT hr = GetRRQueueProperties(pQueueFormat, pCleanGuid, &qp);
	if(FAILED(hr))
		return hr;

	pQueue = new CNewRRQueue(
					pQueueFormat,
					&qp,
					pNewRemoteReadContextAndBind->GetBind(),
					pNewRemoteReadContextAndBind->GetContext()
					);

	//
	// Ownership of hBind and RemoteReadContextHandle was transfered to CNewRRQueue object.
	// they will be released in CNewRRQueue dtor
	//
	pNewRemoteReadContextAndBind->detach();
	return MQ_OK;
}
	

/*======================================================

Function:  HRESULT CQueueMgr::OpenRRQueue()

Description:

Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::OpenRRQueue(
	IN  const QUEUE_FORMAT* pQueueFormat,
	IN  DWORD dwCallingProcessID,
	IN  DWORD dwAccess,
	IN  DWORD dwShareMode,
	IN  ULONG srv_hACQueue,
	IN  ULONG srv_pQMQueue,
	IN  DWORD dwpContext,
	IN OUT CAutoCloseNewRemoteReadCtxAndBind* pNewRemoteReadContextAndBind,
	IN OUT  CBindHandle&	hBind,
	OUT PHANDLE    phQueue
	)
{
    //
    // It's essential that handle is null on entry, for cleanup in RT.
    //
    *phQueue = NULL;

	bool fNewRemoteRead = (pNewRemoteReadContextAndBind != NULL);

	R<CBaseRRQueue> pQueue;
	HRESULT rc;
	if(fNewRemoteRead)
	{
		//
		// hBind should be in pNewRemoteReadContextAndBind
		//
		ASSERT(hBind == NULL);
	   	rc = CreateNewRRQueueObject(pQueueFormat, pNewRemoteReadContextAndBind, pQueue);
	    if (FAILED(rc))
	    {
			TrERROR(GENERAL, "Failed to create CNewRRQueue, %!HRESULT!", rc);
			return rc;
	    }
	}
	else
	{
	   	rc = CreateRRQueueObject(pQueueFormat, hBind, pQueue);
	    if (FAILED(rc))
	    {
			TrERROR(GENERAL, "Failed to create CRRQueue, %!HRESULT!", rc);
			return rc;
	    }
	}
	
    ASSERT(pQueue->GetRef() == 1);

    //
    //  N.B. The queue handle created by ACCreateRemoteProxy is not held by
    //      the QM. **THIS IS NOT A LEAK**. The handle is held by the driver
    //      which call back with this handle to close the RR proxy queue when
    //      the application closes its handle.
    //
    HANDLE hQueue;
    rc = ACCreateRemoteProxy(
            pQueueFormat,
            pQueue.get(),
            &hQueue
            );

    if (FAILED(rc))
    {
        TrERROR(GENERAL, "Make queue failed, ntstatus %x", rc);
        return LogHR(rc, s_FN, 40);
    }

    ASSERT(hQueue != NULL);
    pQueue->SetCli_hACQueue(hQueue);

    //
    // We do not AddRef here the pQueue object.
    // It should be AddRef only after ACAssociateQueue.
    // After ACAssociateQueue the handle is given to the application,
    // and the application will call close queue.
    //

	if(!fNewRemoteRead)
	{
	    //
		// Old Remote Read interface
		// open Session with remote QM and create RPC context for this
		// queue handle.
	    //
	    PCTX_RRSESSION_HANDLE_TYPE pRRContext = 0;
		CRRQueue* pCRRQueue = static_cast<CRRQueue*>(pQueue.get());
	    rc = pCRRQueue->OpenRRSession(
				srv_hACQueue,
				srv_pQMQueue,
				&pRRContext,
				dwpContext
				);
	    if(FAILED(rc))
	    {
	       TrERROR(GENERAL, "Canot Open RR Session %x", rc);
	       return LogHR(rc, s_FN, 30);
	    }

	    ASSERT(pRRContext != 0);
	    pCRRQueue->SetRRContext(pRRContext);
	    pCRRQueue->SetServerQueue(srv_pQMQueue, srv_hACQueue);
	}

    ASSERT(dwCallingProcessID);
    CHandle hCallingProcess = OpenProcess(
                                PROCESS_DUP_HANDLE,
                                FALSE,
                                dwCallingProcessID
                                );
    if(hCallingProcess == 0)
    {
        TrERROR(GENERAL, "Cannot open process in OpenRRQueue, gle = %!winerr!", GetLastError());
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 50);
    }

    CFileHandle hAcQueue;
    rc = ACCreateHandle(&hAcQueue);
    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 60);
    }

    rc = ACAssociateQueue(
            hQueue,
            hAcQueue,
            dwAccess,
            dwShareMode,
            false
            );

    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 70);
    }

    //
    // AddRef - The application got the handle
    // Release is called when we call ACCloseHandle().
	// Since the handle hAcQueue is closed regardless of error code of MQpDuplicateHandle,
	// the normal close operation will be performed through the driver also when MQpDuplicateHandle fail.
	//
	
    pQueue->AddRef();

    HANDLE hDupQueue = NULL;

    BOOL fSuccess;
    fSuccess = MQpDuplicateHandle(
                GetCurrentProcess(),
                hAcQueue.detach(),
                hCallingProcess,
                &hDupQueue,
                FILE_READ_ACCESS,
                TRUE,
                DUPLICATE_CLOSE_SOURCE
                );

    if(!fSuccess)
    {
        //
        // The handle hAcQueue is closed regardless of error code
        //

        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 80);
    }

    *phQueue = hDupQueue;
    return LogHR(rc, s_FN, 90);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\csecobj.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:  csecobj.h

Abstract: "SecureableObject" code, once in mqutil.dll.
    in MSMQ2.0 it's used only here, so I removed it from mqutil.
    This object holds the security descriptor of an object. This object is
    used for validating access rights for various operations on the various
    objects.

Author:

    Doron Juster  (DoronJ)

--*/
#include "mqaddef.h"

class CSecureableObject
{

public:
    CSecureableObject(AD_OBJECT eObject);
    HRESULT Store();
    HRESULT SetSD(SECURITY_INFORMATION, PSECURITY_DESCRIPTOR);
    HRESULT GetSD(SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, LPDWORD);
    HRESULT AccessCheck(DWORD dwDesiredAccess);
    const VOID *GetSDPtr() { return m_SD; };

private:
    DWORD AdObjectToMsmq1Object(void) const;

protected:
    PSECURITY_DESCRIPTOR m_SD;
    AD_OBJECT  m_eObject;

    virtual HRESULT GetObjectSecurity() = 0;
    virtual HRESULT SetObjectSecurity() = 0;
    HRESULT m_hrSD;
    LPWSTR  m_pwcsObjectName;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cqpriv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqprivate.h

Abstract:

    CQPrivate class definition

Author:

    Uri Habusha (urih)

--*/

#ifndef __QM_CQPRIVATE__
#define __QM_CQPRIVATE__

#include "privque.h"
#include "qformat.h"
#include "qmrt.h"

class CQPrivate{
public:
    CQPrivate();                     // Constructore

    ~CQPrivate();                    // deconstructor

    HRESULT PrivateQueueInit(void);

    HRESULT
	QMSetupCreateSystemQueue(
		IN LPCWSTR lpwcsPathName,
		IN DWORD   dwQueueId,
		IN bool fIsTriggersQueue = false
		);


    HRESULT QMCreatePrivateQueue(IN LPCWSTR lpwcsPathName,
                                 IN PSECURITY_DESCRIPTOR  pSecurityDescriptor,
                                 IN DWORD       cp,
                                 IN PROPID      aProp[],
                                 IN PROPVARIANT apVar[],
                                 IN BOOL        fCheckAccess
                                );

    HRESULT QMGetPrivateQueueProperties(IN  QUEUE_FORMAT* pObjectFormat,
                                        IN  DWORD cp,
                                        IN  PROPID aProp[],
                                        IN  PROPVARIANT apVar[]
                                       );

    HRESULT QMGetPrivateQueuePropertiesInternal(IN  LPCWSTR lpwcsPathName,
                                                IN  DWORD cp,
                                                IN  PROPID aProp[],
                                                IN  PROPVARIANT apVar[]
                                               );

    HRESULT QMGetPrivateQueuePropertiesInternal(IN  DWORD Uniquifier,
                                                IN  DWORD cp,
                                                IN  PROPID aProp[],
                                                IN  PROPVARIANT apVar[]
                                               );

    HRESULT QMDeletePrivateQueue(IN  QUEUE_FORMAT* pObjectFormat);

    HRESULT QMPrivateQueuePathToQueueFormat(IN LPCWSTR lpwcsPathName,
                                            OUT QUEUE_FORMAT *pQueueFormat
                                           );

    HRESULT QMPrivateQueuePathToQueueId(IN LPCWSTR lpwcsPathName,
                                        OUT DWORD* dwQueueId
                                        );

    HRESULT QMSetPrivateQueueProperties(IN  QUEUE_FORMAT* pObjectFormat,
                                        IN  DWORD cp,
                                        IN  PROPID aProp[],
                                        IN  PROPVARIANT apVar[]
                                       );

    HRESULT QMSetPrivateQueuePropertiesInternal(
                        		IN  DWORD  Uniquifier,
                                IN  DWORD  cp,
                                IN  PROPID aProp[],
                                IN  PROPVARIANT apVar[]
                               );

    HRESULT QMGetPrivateQueueSecrity(IN  QUEUE_FORMAT* pObjectFormat,
                                     IN SECURITY_INFORMATION RequestedInformation,
                                     OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                     IN DWORD nLength,
                                     OUT LPDWORD lpnLengthNeeded
                                    );

    HRESULT QMSetPrivateQueueSecrity(IN  QUEUE_FORMAT* pObjectFormat,
                                     IN SECURITY_INFORMATION RequestedInformation,
                                     IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                                    );

    HRESULT QMGetFirstPrivateQueuePosition(OUT LPVOID   &pos,
                                           OUT LPCWSTR  &lpszPathName,
                                           OUT DWORD    &dwQueueId
                                          );

    HRESULT QMGetNextPrivateQueue(IN OUT LPVOID   &pos,
                                  OUT    LPCWSTR  &lpszPathName,
                                  OUT    DWORD    &dwQueueId
                                 );

#ifdef _WIN64
    HRESULT QMGetFirstPrivateQueuePositionByDword(OUT DWORD    &dwpos,
                                                  OUT LPCWSTR  &lpszPathName,
                                                  OUT DWORD    &dwQueueId
                                                 );

    HRESULT QMGetNextPrivateQueueByDword(IN OUT DWORD    &dwpos,
                                         OUT    LPCWSTR  &lpszPathName,
                                         OUT    DWORD    &dwQueueId
                                        );
#endif //_WIN64

    BOOL    IsPrivateSysQueue(IN  LPCWSTR lpwcsPathName ) ;

    BOOL    IsPrivateSysQueue(IN  DWORD Uniquifier ) ;

    HRESULT GetPrivateSysQueueProperties(IN  DWORD       cp,
                                         IN  PROPID      aProp[],
                                         IN  PROPVARIANT apVar[] );

    CCriticalSection m_cs;

private:

    void InitDefaultQueueProperties(void);

    HRESULT SetQueueProperties(
                IN LPCWSTR lpwcsPathName,
                IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
                IN  DWORD                  cp,
                IN  PROPID                 aProp[],
                IN  PROPVARIANT            apVar[],
                OUT DWORD*                 pcpOut,
                OUT PROPID **              ppOutProp,
                OUT PROPVARIANT **         ppOutPropvariant);

    HRESULT GetNextPrivateQueueId(OUT DWORD* dwQueueId);

    HRESULT RegisterPrivateQueueProperties(IN LPCWSTR lpszPathName,
                                           IN DWORD dwQueueId,
                                           IN BOOLEAN fNewQueue,
                                           IN DWORD cpObject,
                                           IN PROPID pPropObject[],
                                           IN PROPVARIANT pVarObject[]
                                          );

    HRESULT
    GetQueueIdForDirectFormatName(
        LPCWSTR QueueFormatname,
        DWORD* pQueueId
        );

    HRESULT
    GetQueueIdForQueueFormatName(
        const QUEUE_FORMAT* pObjectFormat,
        DWORD* pQueueId
        );

    static HRESULT ValidateProperties(IN DWORD cp,
                                      IN PROPID aProp[]);


    DWORD  m_dwMaxSysQueue ;
    DWORD  m_dwSysQueuePriority ;
    LPWSTR m_lpSysQueueNames[ MAX_SYS_PRIVATE_QUEUE_ID ] ;
};

/*====================================================

CQPrivate::ValidateProperties

   Validate that all the specified properties are allowed to be queried
   by applications via the DS API.

Arguments:

Return Value:


=====================================================*/
inline HRESULT
CQPrivate::ValidateProperties(IN DWORD cp,
                              IN PROPID aProp[])
{
	DWORD i;
	PROPID *pPropID;

	for (i = 0, pPropID = aProp;
		 (i < cp) && !IS_PRIVATE_PROPID(*pPropID);
		 i++, pPropID++)
	{
		NULL;
	}

    if (i < cp) {
        return MQ_ERROR_ILLEGAL_PROPERTY_VT;
    }

    return(MQ_OK);
}

//
// The singleton private queues manager.
//
extern CQPrivate g_QPrivate;

#endif // __QM_CQPRIVATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\csecobj.cpp ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:  csecobj.h

Abstract: "SecureableObject" code, once in mqutil.dll.
    in MSMQ2.0 it's used only here, so I removed it from mqutil.
    This object holds the security descriptor of an object. This object is
    used for validating access rights for various operations on the various
    objects.

Author:

    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "csecobj.h"
#include <mqsec.h>
#include "ad.h"

#include "csecobj.tmh"

static WCHAR *s_FN=L"csecobj";

// The default constructor of CSecureableObject just sets object type name for
// audits.
CSecureableObject::CSecureableObject(AD_OBJECT eObject)
{
    m_eObject = eObject;
    m_pwcsObjectName = NULL;
    m_SD = NULL;
    m_hrSD = MQ_ERROR;
}

// Copy the security descriptor to a buffer.
HRESULT
CSecureableObject::GetSD(
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnNeededLength)
{
	ASSERT(pSecurityDescriptor != NULL);

    if(FAILED(m_hrSD)) 
	{
        return(m_hrSD);
    }

    DWORD dwDesiredAccess = READ_CONTROL;
    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    HRESULT hr = AccessCheck(dwDesiredAccess);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    SECURITY_DESCRIPTOR sd;
    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "InitializeSecurityDescriptor failed, gle = %!winerr!", gle);
		ASSERT(("InitializeSecurityDescriptor failed", 0));
		return HRESULT_FROM_WIN32(gle);
    }

    // use the  e_DoNotCopyControlBits for compatibility with old code.
    // That was the default behavior of old code.
    //
    if(!MQSec_CopySecurityDescriptor( 
			&sd,
			m_SD,
			RequestedInformation,
			e_DoNotCopyControlBits 
			))
    {
		TrERROR(SECURITY, "Failed to copy security descriptor");
		return MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR;
    }

    *lpnNeededLength = nLength;

    if (!MakeSelfRelativeSD(&sd, pSecurityDescriptor, lpnNeededLength))
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "MakeSelfRelativeSD failed, gle = %!winerr!", gle);
		if(gle == ERROR_INSUFFICIENT_BUFFER)
	        return MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
		
		return HRESULT_FROM_WIN32(gle);
    }

    ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));

    return (MQ_OK);
}

//+-------------------------------------------
//
//  CSecureableObject::SetSD()
//
//  Set (modify) the security descriptor.
//
//+-------------------------------------------

HRESULT
CSecureableObject::SetSD(
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptorIn)
{
    ASSERT(m_eObject == eQUEUE);

#ifdef _DEBUG
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;

    // Verify that the destination security descriptor answers to all
    // requirements.
    BOOL bRet = GetSecurityDescriptorControl(m_SD, &sdc, &dwRevision);
    ASSERT(bRet);
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
    ASSERT(sdc & SE_SELF_RELATIVE);
#endif

    if(FAILED(m_hrSD)) 
	{
        return(m_hrSD);
    }

    DWORD dwDesiredAccess = 0;
    if (RequestedInformation & OWNER_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= WRITE_OWNER;
    }

    if (RequestedInformation & DACL_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= WRITE_DAC;
    }

    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    HRESULT hr = AccessCheck(dwDesiredAccess);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    //
    // Convert to NT4 format.
    //
    SECURITY_DESCRIPTOR *pSecurityDescriptor = NULL;
    P<SECURITY_DESCRIPTOR> pSD4;

    if (pSecurityDescriptorIn)
    {
        DWORD dwSD4Len = 0 ;
        hr = MQSec_ConvertSDToNT4Format(
					MQDS_QUEUE,
					(SECURITY_DESCRIPTOR*) pSecurityDescriptorIn,
					&dwSD4Len,
					&pSD4,
					RequestedInformation
					);
        ASSERT(SUCCEEDED(hr));
        LogHR(hr, s_FN, 198);

        if (SUCCEEDED(hr) && (hr != MQSec_I_SD_CONV_NOT_NEEDED))
        {
            pSecurityDescriptor = pSD4;
        }
        else
        {
            ASSERT(pSD4 == NULL);
            pSecurityDescriptor =
                             (SECURITY_DESCRIPTOR*) pSecurityDescriptorIn ;
        }
        ASSERT(pSecurityDescriptor &&
               IsValidSecurityDescriptor(pSecurityDescriptor));
    }

    AP<char> pDefaultSecurityDescriptor;
    hr = MQSec_GetDefaultSecDescriptor( 
				AdObjectToMsmq1Object(),
				(PSECURITY_DESCRIPTOR*) &pDefaultSecurityDescriptor,
				TRUE,	// fImpersonate
				pSecurityDescriptor,
				0,    // seInfoToRemove
				e_UseDefaultDacl,
				MQSec_GetLocalMachineSid(FALSE, NULL)
				);
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 40);
        return hr;
    }

	//
    // Temporarily convert the security descriptor to an absolute security
    // descriptor.
	//
	CAbsSecurityDsecripror AbsSecDsecripror;
	if(!MQSec_MakeAbsoluteSD(
			m_SD,
			&AbsSecDsecripror
			))
	{
		TrERROR(SECURITY, "Failed to convert to Absolute security descriptor");
		return MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR;
	}

    //
    // Overwrite the information from the passed security descriptor.
    // use the  e_DoNotCopyControlBits for compatibility with old code.
    // That was the default behavior of old code.
    //
    if(!MQSec_CopySecurityDescriptor(
                reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
                (PSECURITY_DESCRIPTOR) pDefaultSecurityDescriptor,
                RequestedInformation,
                e_DoNotCopyControlBits 
				))
	{
		TrERROR(SECURITY, "Failed to copy security descriptor");
		return MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR;
	}

	//
    // Re-convert the security descriptor to a self relative security
    // descriptor.
	//
    DWORD dwSelfRelativeSecurityDescriptorLength = 0;
    MakeSelfRelativeSD(
        AbsSecDsecripror.m_pObjAbsSecDescriptor.get(),
        NULL,
        &dwSelfRelativeSecurityDescriptorLength
		);

	if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "MakeSelfRelativeSD failed, gle = %!winerr!", gle);
	    ASSERT(gle == ERROR_INSUFFICIENT_BUFFER);
		return HRESULT_FROM_WIN32(gle);
	}

	//
    // Allocate the buffer for the new security descriptor.
	//

	AP<char> pSelfRelativeSecurityDescriptor = new char[dwSelfRelativeSecurityDescriptorLength];
    if(!MakeSelfRelativeSD(
            AbsSecDsecripror.m_pObjAbsSecDescriptor.get(),
			pSelfRelativeSecurityDescriptor.get(),
			&dwSelfRelativeSecurityDescriptorLength
			))
    {
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "MakeSelfRelativeSD failed, gle = %!winerr!", gle);
		return HRESULT_FROM_WIN32(gle);
    	
    }

	//
    // Free the previous security descriptor.
	//
    delete[] (char*)m_SD;

	//
    // Set the new security descriptor.
	//
    m_SD = pSelfRelativeSecurityDescriptor.detach();
	
    return (MQ_OK);
}

// Store the security descriptor in the database.
HRESULT
CSecureableObject::Store()
{
    if(FAILED(m_hrSD)) 
	{
        return(m_hrSD);
    }

#ifdef _DEBUG
    BOOL bRet;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;

    // Verify that the destination security descriptor answers to all
    // requirements.
    bRet = GetSecurityDescriptorControl(m_SD, &sdc, &dwRevision);
    ASSERT(bRet);
    ASSERT(sdc & SE_SELF_RELATIVE);
#endif

    HRESULT hr = SetObjectSecurity();

    return LogHR(hr, s_FN, 50);
}

HRESULT
CSecureableObject::AccessCheck(DWORD dwDesiredAccess)
{
    //
    //  Access check should be performed only on queue, machine, ForeignSite(CN).
    //
    if ((m_eObject != eQUEUE) && (m_eObject != eMACHINE) &&
        (m_eObject != eFOREIGNSITE))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 60);
    }

    if(FAILED(m_hrSD)) 
	{
        return(m_hrSD);
    }

    HRESULT hr = MQSec_AccessCheck( 
				    	(SECURITY_DESCRIPTOR*) m_SD,
						AdObjectToMsmq1Object(),
						m_pwcsObjectName,
						dwDesiredAccess,
						(LPVOID) this,
						TRUE,	// fImpersonate
						TRUE 
						);
    return LogHR(hr, s_FN, 70);
}

DWORD
CSecureableObject::AdObjectToMsmq1Object(void) const
{
    switch (m_eObject)
    {
    case eQUEUE:
        return MQDS_QUEUE;
        break;
    case eMACHINE:
        return MQDS_MACHINE;
        break;
    case eCOMPUTER:
        return MQDS_COMPUTER;
        break;
    case eUSER:
        return MQDS_USER;
        break;
    case eSITE:
        return MQDS_SITE;
        break;
    case eFOREIGNSITE:
        return MQDS_CN;
        break;
    case eENTERPRISE:
        return MQDS_ENTERPRISE;
        break;
    default:
        ASSERT(0);
        return 0;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\dumpauthzutl.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    DumpAuthzUtl.cpp

Abstract:

    Dump authz related information utilities.

Author:

    Ilan Herbst (ilanh) 14-Apr-2001

--*/

#include "stdh.h"
#include "Authz.h"
#include "sddl.h"
#include "cm.h"
#include "tr.h"
#include "mqexception.h"
#include "autoreln.h"
#include "mqsec.h"
#include "DumpAuthzUtl.h"

#include "DumpAuthzUtl.tmh"

static WCHAR *s_FN=L"DumpAuthzUtl";

static
bool 
DumpAccessCheckFailure()
/*++

Routine Description:
    Read DumpAccessCheckFailure flag from registry

Arguments:
	None

Return Value:
	true if DumpAccessCheckFailure is set.
--*/
{
	//
	// Reading this registry only at first time.
	//
	static bool s_fInitialized = false;
	static bool s_fDumpAccessCheck = false;

	if(s_fInitialized)
	{
		return s_fDumpAccessCheck;
	}

	const RegEntry xRegEntry(TEXT("security"), TEXT("DumpAccessCheckFailure"), 0);
	DWORD DumpAccessCheckValue;
	CmQueryValue(xRegEntry, &DumpAccessCheckValue);

	s_fDumpAccessCheck = (DumpAccessCheckValue != 0);
	s_fInitialized = true;

	TrTRACE(SECURITY, "DumpAccessCheckFailure value = %d", DumpAccessCheckValue);

	return s_fDumpAccessCheck;
}


#define GET_PSID_FROM_PACE(pAce) (&((PACCESS_ALLOWED_ACE)pAce)->SidStart)
#define GET_ACE_MASK(pAce) (((PACCESS_DENIED_ACE)pAce)->Mask)
#define GET_ACE_TYPE(pAce) (((PACCESS_DENIED_ACE)pAce)->Header.AceType)


void 
IsPermissionGranted(
	PSECURITY_DESCRIPTOR pSD,
	DWORD Permission,
	bool* pfAllGranted, 
	bool* pfEveryoneGranted, 
	bool* pfAnonymousGranted 
	)
/*++

Routine Description:
	Check if we allow all (everyone + anonymous) a permission in
	a security descriptor.
	if there is no deny ace, also return if Everyone or Anonymous are
	explicitly grant the permissions.

Arguments:
	pSD - pointer to the security descriptor 
	Permission - requested permission.
	pfAllGranted - [out] flag that indicate if all grant the permissions.
	pfEveryoneGranted - [out] flag that indicate if Everyone explicitly grant the permissions.
	pfAnonymousGranted - [out] flag that indicate if Anonymous explicitly grant the permissions.

Returned Value:
	true if we allow all the permission, false otherwise
	
--*/
{
	ASSERT((pSD != NULL) && IsValidSecurityDescriptor(pSD));

	*pfAllGranted = false;
	*pfEveryoneGranted = false;
	*pfAnonymousGranted = false;

	//
    // get the DACL of the queue security descriptor.
	//
    BOOL bDaclPresent;
    PACL pDacl;
    BOOL bDaclDefaulted;
    if(!GetSecurityDescriptorDacl(
						pSD, 
						&bDaclPresent, 
						&pDacl, 
						&bDaclDefaulted
						))
	{
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorDacl() failed, %!winerr!", gle);
		LogBOOL(FALSE, s_FN, 20);
		return;
	}

	//
    // If there is no DACL, or it is NULL, access is granted for all.
	//
    if (!bDaclPresent || !pDacl)
    {
		TrTRACE(SECURITY, "no DACL, or NULL DACL, access is granted for all");
		*pfAllGranted = true;
		*pfEveryoneGranted = true;
		*pfAnonymousGranted = true;
		return;
    }

    ACL_SIZE_INFORMATION AclSizeInfo;
    if(!GetAclInformation(
					pDacl, 
					&AclSizeInfo, 
					sizeof(AclSizeInfo), 
					AclSizeInformation
					))
	{
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetAclInformation() failed, %!winerr!", gle);
		LogBOOL(FALSE, s_FN, 40);
		return;
	}

	//
    // If the DACL is empty, deny access from all.
	//
    if (AclSizeInfo.AceCount == 0)
    {
		TrTRACE(SECURITY, "empty DACL, deny access from all");
		LogBOOL(FALSE, s_FN, 50);
		return;
    }

	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;
    for (DWORD i = 0; i < AclSizeInfo.AceCount; i++)
    {
		LPVOID pAce;

        if(!GetAce(pDacl, i, &pAce))
        {
	        DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetAce() failed, %!winerr!", gle);
			return;
        }

        //
		// Ignore unknown ACEs
		//
        if (!(GET_ACE_TYPE(pAce) == ACCESS_ALLOWED_ACE_TYPE) &&
            !(GET_ACE_TYPE(pAce) == ACCESS_DENIED_ACE_TYPE))
        {
            continue;
        }

		//
        // See if we have the permission bit set in the ACE.
		//
        if (GET_ACE_MASK(pAce) & Permission)
        {
			if(GET_ACE_TYPE(pAce) == ACCESS_DENIED_ACE_TYPE)
			{
				//
				// Found a deny on the requested permission
				//
				TrTRACE(SECURITY, "found deny ACE");
				LogBOOL(FALSE, s_FN, 60);
				return;
			}

			ASSERT(GET_ACE_TYPE(pAce) == ACCESS_ALLOWED_ACE_TYPE);
			
            if(EqualSid(MQSec_GetWorldSid(), GET_PSID_FROM_PACE(pAce)))
			{
				fEveryoneGranted = true;
				TrTRACE(SECURITY, "Everyone allowed access");
				continue;
			}

            if(EqualSid(MQSec_GetAnonymousSid(), GET_PSID_FROM_PACE(pAce)))
			{
				TrTRACE(SECURITY, "Anonymous allowed access");
				fAnonymousGranted = true;
			}

		}

	}

	*pfEveryoneGranted = fEveryoneGranted;
	*pfAnonymousGranted = fAnonymousGranted;

	*pfAllGranted = (fEveryoneGranted && fAnonymousGranted);
}


static 
void 
PrintSid(
	PSID pSid
	)
/*++
Routine Description:
	Print text sid and user information.

Arguments:
	pSid - pointer to the sid

Returned Value:
	None

--*/
{

	//
	// string sid
	//
	LPWSTR pStringSid = NULL;
	if(!ConvertSidToStringSid(pSid, &pStringSid))
	{
        DWORD gle = GetLastError();
		TrERROR(SECURITY, "ConvertSidToStringSid failed, %!winerr!", gle);
		return;
	}

    CAutoLocalFreePtr pFreeSid = reinterpret_cast<BYTE*>(pStringSid);

	//
	// map sid to domain\user account
	//
    WCHAR NameBuffer[128];
    WCHAR DomainBuffer[128];
    ULONG NameLength = TABLE_SIZE(NameBuffer);
    ULONG DomainLength = TABLE_SIZE(DomainBuffer);
    SID_NAME_USE SidUse;
    if (!LookupAccountSid( 
			NULL,
			pSid,
			NameBuffer,
			&NameLength,
			DomainBuffer,
			&DomainLength,
			&SidUse
			))
    {
        DWORD gle = GetLastError();
		TrTRACE(SECURITY, "%ls", pStringSid);
		TrERROR(SECURITY, "LookupAccountSid failed, %!winerr!", gle);
		return;
    }

	if(DomainBuffer[0] == '\0')
	{
		TrTRACE(SECURITY, "%ls, %ls", pStringSid, NameBuffer);
		return;
	}

	TrTRACE(SECURITY, "%ls, %ls\\%ls", pStringSid, DomainBuffer, NameBuffer);

}


typedef struct _ACCESS_ALLOWED_OBJECT_ACE_1 {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE_1 ;


static
void
PrintACEs(
	PACL pAcl
	)
/*++
Routine Description:
	Print list of ACEs

Arguments:
	pAcl - pointer to the ACL to be printed

Returned Value:
	None

--*/
{
	TrTRACE(SECURITY, "Revision: %d,  Numof ACEs: %d", pAcl->AclRevision, pAcl->AceCount);

    for (DWORD i = 0; i < pAcl->AceCount; i++)
    {
		ACCESS_ALLOWED_ACE* pAce;
        if(!GetAce(
				pAcl, 
				i, 
				(LPVOID*)&(pAce)
				))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "GetAce() failed, %!winerr!", gle);
			throw bad_win32_error(gle);
        }

        DWORD AceType = pAce->Header.AceType;
		if((AceType > ACCESS_MAX_MS_OBJECT_ACE_TYPE) || 
		   (AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE))
		{
			//
			// Handle only obj ACE and normal ACE.
			//
			TrTRACE(SECURITY, "ACE(%d), Unknown AceType %d", i, AceType);
			throw bad_win32_error(ERROR_INVALID_ACL);
		}

	    bool fObjAce = false;
		if((AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && 
		   (AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE))
		{
			fObjAce = true;
		}

		TrTRACE(SECURITY, "ACE(%d), AceType - %d, Mask- 0x%x", i, AceType, pAce->Mask);

		ACCESS_ALLOWED_OBJECT_ACE* pObjAce = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE*>(pAce);

		PSID pSid = reinterpret_cast<PSID>(&(pAce->SidStart));
        if(fObjAce)
        {
			TrTRACE(SECURITY, "ObjFlags - 0x%x", pObjAce->Flags);

            if (pObjAce->Flags == ACE_OBJECT_TYPE_PRESENT)
            {
	            ACCESS_ALLOWED_OBJECT_ACE_1* pObjAce1 = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE_1*>(pObjAce);
				pSid = reinterpret_cast<PSID>(&(pObjAce1->SidStart));
            }
        }

        if (pObjAce->Flags == ACE_OBJECT_TYPE_PRESENT)
        {
			TrTRACE(SECURITY, "ObjectType - %!guid!", &pObjAce->ObjectType);
        }

//		TrTRACE(SECURITY, "%!sid!", pSid);
		PrintSid(pSid);
    }
}


static
void
ShowOGandSID(
	PSID pSid, 
	BOOL fDefaulted
	)
/*++
Routine Description:
	Print owner\group and sid

Arguments:
	pSid - pointer to sid
	Defaulted - flag that indicate if defaulted

Returned Value:
	None

--*/
{
	if(fDefaulted)
	{
		TrTRACE(SECURITY, "Defaulted");
	}
	else
	{
		TrTRACE(SECURITY, "NotDefaulted");
	}

    if (!pSid)
    {
		TrTRACE(SECURITY, "Not available");
		return;
    }

//	TrTRACE(SECURITY, "%!sid!", pSid);
    PrintSid(pSid);
}


void
PrintAcl(
    BOOL fAclExist,
    BOOL fDefaulted,
    PACL pAcl
	)
/*++
Routine Description:
	Print Acl

Arguments:
	pSid - pointer to sid
	Defaulted - flag that indicate if defaulted

Returned Value:
	None

--*/
{
	if (!fAclExist)
    {
		TrTRACE(SECURITY, "NotPresent");
		return;
    }

	if(fDefaulted)
	{
		TrTRACE(SECURITY, "Defaulted");
	}
	else
	{
		TrTRACE(SECURITY, "NotDefaulted");
	}

	if (pAcl == NULL)
    {
		TrTRACE(SECURITY, "NULL");
		return;
	}

    PrintACEs(pAcl);
}


static
void  
ShowNT5SecurityDescriptor( 
	PSECURITY_DESCRIPTOR pSD
	)
/*++
Routine Description:
	Print Security descriptor

Arguments:
	pSD - pointer to security descriptor

Returned Value:
	None

--*/
{
	ASSERT((pSD != NULL) && IsValidSecurityDescriptor(pSD));
	if((pSD == NULL) || !IsValidSecurityDescriptor(pSD))
	{
		TrERROR(SECURITY, "invalid security descriptor or NULL security descriptor");
		throw bad_win32_error(ERROR_INVALID_SECURITY_DESCR);
	}

    DWORD dwRevision = 0;
    SECURITY_DESCRIPTOR_CONTROL sdC;
    if(!GetSecurityDescriptorControl(pSD, &sdC, &dwRevision))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorControl() failed, %!winerr!", gle);
		throw bad_win32_error(gle);
	}
	
	TrTRACE(SECURITY, "SecurityDescriptor");
	TrTRACE(SECURITY, "Control - 0x%x, Revision - %d", (DWORD) sdC, dwRevision);

	//
	// Owner
	//
    PSID  pSid;
    BOOL  Defaulted = FALSE;
    if (!GetSecurityDescriptorOwner(pSD, &pSid, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorOwner() failed, %!winerr!", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(SECURITY, "Owner information:");
    ShowOGandSID(pSid, Defaulted);

	//
	// Group
	//
    if (!GetSecurityDescriptorGroup(pSD, &pSid, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorGroup() failed, %!winerr!", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(SECURITY, "Group information:");
    ShowOGandSID(pSid, Defaulted);


	//
	// DACL
	//
    BOOL fAclExist;
    PACL pAcl;
    if (!GetSecurityDescriptorDacl(pSD, &fAclExist, &pAcl, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorDacl() failed, %!winerr!", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(SECURITY, "DACL information:");
	PrintAcl(fAclExist, Defaulted, pAcl); 

	//
	// SACL
	//
    if (!GetSecurityDescriptorSacl(pSD, &fAclExist, &pAcl, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "GetSecurityDescriptorSacl() failed, %!winerr!", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(SECURITY, "SACL information:");
	PrintAcl(fAclExist, Defaulted, pAcl); 
}


static
void
GetClientContextInfo(
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
	)
/*++

Routine Description:
	Get Client context info.

Arguments:
	AuthzClientContext - client context

Returned Value:
	None
	
--*/
{
	//
	// UserSid
	//
	DWORD BufferSize = 0;

	AuthzGetInformationFromContext(
		  ClientContext,
		  AuthzContextInfoUserSid,
		  0,
		  &BufferSize,
		  NULL
		  );

	AP<BYTE> pToken = new BYTE[BufferSize];
	if(!AuthzGetInformationFromContext(
			  ClientContext,
			  AuthzContextInfoUserSid,
			  BufferSize,
			  &BufferSize,
			  pToken
			  ))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "AuthzGetContextInformation(AuthzContextInfoUserSid)  failed, %!winerr!", gle);
		throw bad_win32_error(gle);
	}

	TrTRACE(SECURITY, "AuthzContextInfoUserSid");
    PSID pSid = (PSID) (((TOKEN_USER*) pToken.get())->User.Sid);
//	TrTRACE(SECURITY, "%!sid!", pSid);
	PrintSid(pSid);

	//
	// GroupsSids
	//
	AuthzGetInformationFromContext(
		  ClientContext,
		  AuthzContextInfoGroupsSids,
		  0,
		  &BufferSize,
		  NULL
		  );

	AP<BYTE> pTokenGroup = new BYTE[BufferSize];
	if(!AuthzGetInformationFromContext(
			  ClientContext,
			  AuthzContextInfoGroupsSids,
			  BufferSize,
			  &BufferSize,
			  pTokenGroup
			  ))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "AuthzGetContextInformation(AuthzContextInfoGroupsSids)  failed, %!winerr!", gle);
		throw bad_win32_error(gle);
	}

	DWORD GroupCount = (((TOKEN_GROUPS*) pTokenGroup.get())->GroupCount);
	TrTRACE(SECURITY, "AuthzContextInfoGroupsSids, GroupCount = %d", GroupCount);

	for(DWORD i=0; i < GroupCount; i++)
	{
		PSID pSid = (PSID) (((TOKEN_GROUPS*) pTokenGroup.get())->Groups[i].Sid);
		TrTRACE(SECURITY, "Group %d: ", i);
//		TrTRACE(SECURITY, "%!sid!", pSid);
		PrintSid(pSid);
	}
	
	//
	// RestrictedSids
	//
	AuthzGetInformationFromContext(
		  ClientContext,
		  AuthzContextInfoRestrictedSids,
		  0,
		  &BufferSize,
		  NULL
		  );

	AP<BYTE> pRestrictedSids = new BYTE[BufferSize];
	if(!AuthzGetInformationFromContext(
			  ClientContext,
			  AuthzContextInfoRestrictedSids,
			  BufferSize,
			  &BufferSize,
			  pRestrictedSids
			  ))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "AuthzGetContextInformation(AuthzContextInfoRestrictedSids)  failed, %!winerr!", gle);
		throw bad_win32_error(gle);
	}

	GroupCount = (((TOKEN_GROUPS*) pRestrictedSids.get())->GroupCount);
	TrTRACE(SECURITY, "AuthzContextInfoRestrictedSids, GroupCount = %d", GroupCount);

	for(DWORD i=0; i < GroupCount; i++)
	{
		PSID pSid = (PSID) (((TOKEN_GROUPS*) pRestrictedSids.get())->Groups[i].Sid);
		TrTRACE(SECURITY, "Group %d: ", i);
//		TrTRACE(SECURITY, "%!sid!", pSid);
		PrintSid(pSid);
	}
}


bool
IsAllGranted(
	DWORD Permissions,
	PSECURITY_DESCRIPTOR pSD
	)
/*++

Routine Description:
	Checks if all granted permission.

Arguments:
	permissions - requested permissions.
	pSD - security descriptor.

Returned Value:
	true if all grant the permission.
	
--*/
{
	bool fAllGranted = false;
	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;

	IsPermissionGranted(
		pSD, 
		Permissions,
		&fAllGranted, 
		&fEveryoneGranted, 
		&fAnonymousGranted 
		);

	TrTRACE(SECURITY, "IsAllGranted = %d", fAllGranted);
	return fAllGranted;
}


bool
IsEveryoneGranted(
	DWORD Permissions,
	PSECURITY_DESCRIPTOR pSD
	)
/*++

Routine Description:
	Checks if everyone granted permission.

Arguments:
	permissions - requested permissions.
	pSD - security descriptor.

Returned Value:
	true if everyone grant the permission.
	
--*/
{
	bool fAllGranted = false;
	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;

	IsPermissionGranted(
		pSD, 
		Permissions,
		&fAllGranted, 
		&fEveryoneGranted, 
		&fAnonymousGranted 
		);

	TrTRACE(SECURITY, "IsEveryoneGranted = %d", fEveryoneGranted);
	return fEveryoneGranted;
}


void
DumpAccessCheckFailureInfo(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD,
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
	)
/*++

Routine Description:
	DumpAccessCheckFailureInfo if registry DumpAccessCheckFailure
	is set.

Arguments:
	permissions - requested permissions.
	pSD - security descriptor.
	ClientContext - authz client context handle

Returned Value:
	None
	
--*/
{
	if(DumpAccessCheckFailure())
	{
		TrTRACE(SECURITY, "requested permission = 0x%x", permissions);

		try
		{
			GetClientContextInfo(ClientContext);
			ShowNT5SecurityDescriptor(pSD);
		}
		catch(bad_win32_error& exp)
		{
			TrERROR(SECURITY, "catch bad_win32_error exception, error = 0x%x", exp.error());
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cqueue.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cqueue.cpp

Abstract:
    Definition of a CQueue class

Author:
    Uri Habusha (urih)

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "cgroup.h"
#include "cqpriv.h"
#include "qmperf.h"
#include "onhold.h"
#include <mqstl.h>
#include <qal.h>
#include <mp.h>
#include <fn.h>
#include <ac.h>
#include <mqformat.h>

#include "sessmgr.h"
#include "QmRd.h"

#include <Tm.h>
#include <Mtm.h>
#include <Mt.h>
#include <Rd.h>

#include <strsafe.h>

#include "qmacapi.h"

#include "cqueue.tmh"

//
// extern CQMCmd   QMCmd;
//
extern CSessionMgr SessionMgr;
extern CQueueMgr QueueMgr;
extern CQGroup * g_pgroupNonactive;
extern CQGroup * g_pgroupWaiting;
extern CQGroup * g_pgroupNotValidated;
extern CQGroup* g_pgroupDisconnected;
extern CQGroup* g_pgroupLocked;

extern HANDLE g_hAc;

static WCHAR *s_FN=L"cqueue";


/*======================================================

Function:         CBaseQueue::CBaseQueue

Description:      Constructor

========================================================*/

CBaseQueue::CBaseQueue() :
    m_usQueueType(0)
{
}

/*======================================================


Function:         void  CBaseQueue::InitNameAndGuid()

Description:

========================================================*/

void  CBaseQueue::InitNameAndGuid( IN const QUEUE_FORMAT* pQueueFormat,
                                   IN PQueueProps         pQueueProp )
{

    m_qid.pguidQueue = NULL;
    if (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        //
        // Direct Queue
        //
        m_qid.dwPrivateQueueId = 0;
        if (pQueueProp->fIsLocalQueue)
        {
            m_qName = pQueueProp->lpwsQueuePathName;
			if (FnIsPrivatePathName(m_qName))
			{
                m_dwQueueType = QUEUE_TYPE_PRIVATE;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = *(CQueueMgr::GetQMGuid());

				//
                // Get the unique handle initialized at QmpGetQueueProperties
                //
                m_qid.dwPrivateQueueId = pQueueProp->dwPrivateQueueId;
			}
            else
            {
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueProp->guidDirectQueueInstance;
                m_dwQueueType = QUEUE_TYPE_PUBLIC;
            }
        }
        else
        {
            m_qName = (TCHAR*)pQueueProp->lpwsQueuePathName;
            m_dwQueueType = QUEUE_TYPE_UNKNOWN;
        }
    }
    else
    {
        m_qid.dwPrivateQueueId = 0;
        m_qName = (TCHAR*)pQueueProp->lpwsQueuePathName;
        switch (pQueueFormat->GetType())
        {
            case QUEUE_FORMAT_TYPE_PUBLIC:
                m_dwQueueType = QUEUE_TYPE_PUBLIC;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueFormat->PublicID();
                break;

            case QUEUE_FORMAT_TYPE_MACHINE:
                m_dwQueueType = QUEUE_TYPE_MACHINE;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueFormat->MachineID();
                break;

            case QUEUE_FORMAT_TYPE_CONNECTOR:
                m_dwQueueType = QUEUE_TYPE_CONNECTOR;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueFormat->ConnectorID();
                m_qid.dwPrivateQueueId = (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_XACTONLY) ? 1 : 0;
                break;

            case QUEUE_FORMAT_TYPE_PRIVATE:
                m_qid.pguidQueue = new GUID;
                *m_qid.pguidQueue = pQueueFormat->PrivateID().Lineage;
                m_qid.dwPrivateQueueId = pQueueFormat->PrivateID().Uniquifier;

                if (QmpIsLocalMachine(pQueueProp->pQMGuid))
                {
                    m_dwQueueType = QUEUE_TYPE_PRIVATE;
                }
                else
                {
                    m_dwQueueType = QUEUE_TYPE_MACHINE;
                }
                break;

            case QUEUE_FORMAT_TYPE_MULTICAST:
                m_dwQueueType = QUEUE_TYPE_MULTICAST;
                break;

            case QUEUE_FORMAT_TYPE_UNKNOWN:
                //
                // Distribution queues are of type unknown.
                //
                NULL;
                break;

            default:
                ASSERT(0);
        }
    }
}

/*======================================================

Function:  void CQueue::SetSecurityDescriptor()

Description:

========================================================*/
void CQueue::SetSecurityDescriptor(void)
{
    if (!m_fLocalQueue)
    {
		SetSecurityDescriptor(NULL);
		return;
    }

    switch (GetQueueType())
    {
        case QUEUE_TYPE_PUBLIC:
        {
            CQMDSSecureableObject DsSec(
                                    eQUEUE,
                                    GetQueueGuid(),
                                    TRUE,
                                    TRUE,
                                    NULL);

			SetSecurityDescriptor((const PSECURITY_DESCRIPTOR)DsSec.GetSDPtr());
			return;
        }
        case QUEUE_TYPE_PRIVATE:
        {
            CQMSecureablePrivateObject QmSec(eQUEUE, GetPrivateQueueId());
			SetSecurityDescriptor((const PSECURITY_DESCRIPTOR)QmSec.GetSDPtr());
            return;
        }
        case QUEUE_TYPE_MACHINE:
        case QUEUE_TYPE_CONNECTOR:
        case QUEUE_TYPE_MULTICAST:
        case QUEUE_TYPE_UNKNOWN:
        {
            //
            // No caching of security descriptor of the machine.
            // Whenever the security descriptor of the machnie is needed
            // it is taken from the registry. The registry is updated
            // using the notification messages.
            // Whenever the security descriptor of the CN is needed, it is
            // taken from the DS.
            //
			SetSecurityDescriptor(NULL);
            return;
        }
        default:
            ASSERT(0);
    }
}

/*======================================================

Function:  void CQueue::InitQueueProperties()

Description:

========================================================*/

void CQueue::InitQueueProperties(IN PQueueProps   pQueueProp)
{
    m_fLocalQueue     = pQueueProp->fIsLocalQueue;
    m_pguidDstMachine = pQueueProp->pQMGuid;
    m_dwQuota         = pQueueProp->dwQuota;
    m_dwJournalQuota  = pQueueProp->dwJournalQuota;
    m_lBasePriority   = pQueueProp->siBasePriority;
    m_fTransactedQueue= pQueueProp->fTransactedQueue;
    m_fJournalQueue   = pQueueProp->fJournalQueue;
    m_fSystemQueue    = pQueueProp->fSystemQueue;
    m_fConnectorQueue = pQueueProp->fConnectorQueue;
    m_fForeign        = pQueueProp->fForeign;
    m_fAuthenticate   = pQueueProp->fAuthenticate;
    m_fUnknownQueueType = pQueueProp->fUnknownQueueType;
    m_dwPrivLevel     = pQueueProp->dwPrivLevel;

    SetSecurityDescriptor();
}

/*======================================================

Function:         CQueue::CQueue

Description:      Constructor

Arguments:        pQGuid - Queue Guid
                  qHandle - Queue Handle. Local queue recorder in DS is constructed with
                            qHandle = INVALID_FILE_HANDLE. The qHandle will update when a
                            message     is arrived to the queue.


Return Value:     None

Thread Context:

History Change:

========================================================*/

CQueue::CQueue(IN const QUEUE_FORMAT* pQueueFormat,
               IN HANDLE              hQueue,
               IN PQueueProps         pQueueProp,
               IN BOOL                fNotDSValidated)
{
    ASSERT(pQueueFormat != NULL);

    TrTRACE(GENERAL, "CQueue Constructor for queue: %ls, NoDS- %lxh", pQueueProp->lpwsQueuePathName, fNotDSValidated);

    //
    // Data member initilization
    //
    m_fNotValid = FALSE ;
    m_fOnHold = FALSE;

    m_pSession = NULL;
    m_pGroup = NULL;
    m_dwRoutingRetry = 0;
    m_fHopCountFailure = FALSE;
    m_pgConnectorQM = NULL;
    m_hQueue = hQueue;

    InitNameAndGuid(pQueueFormat, pQueueProp ) ;

    InitQueueProperties(pQueueProp) ;

    PerfRegisterQueue();

    m_dwSignature =  QUEUE_SIGNATURE ;
}

/*======================================================

Function:      CQueue::~CQueue

Description:   destructor

Arguments:     None

Return Value:  None

Thread Context:

History Change:

========================================================*/

CQueue::~CQueue()
{
	
	ASSERT(!QueueMgr.IsQueueInList(this));

    m_dwSignature = 0 ;
    delete [] m_qName;
    delete m_qid.pguidQueue;
    delete m_pguidDstMachine;
    delete m_pgConnectorQM;

    PerfRemoveQueue();
}


void CQueue::HandleCreateConnectionFailed(HRESULT rc)
{
    if (GetRoutingRetry() == 1)
    {
        TrERROR(GENERAL, "Cannot route messages to queue %ls. %!hresult!", GetQueueName(),rc);
    }

    if (rc == MQ_ERROR_NO_DS)
    {
		CQGroup::MoveQueueToGroup(this, g_pgroupNotValidated);
		return;
    }

    //
    // Don't decrement the reference count. we do it inorder to avoid remove queue
    // while it in waiting stage. If we want to remove the queue in this stage requires
    // synchronization between the QueueMgr and SessionMgr in order to remove the queue
    // from SessionMgr data structure.
    //
    SessionMgr.AddWaitingQueue(this);
}

/*======================================================

Function:        CQueue::CreateConnection

Description:     Create Connection

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/
void CQueue::CreateConnection(void) throw(bad_alloc)
{
    //
    // Create connection for direct HTTP/HTTPS queue, use different function
    //
    ASSERT(! IsDirectHttpQueue());

    //
    // Increment the reference count, to insure that the queue doesn't remove
    // during the clean-up while the routine try to find a session for it.
    //
    R<CQueue> qref = SafeAddRef(this);

    //
    // No Session - try to establish one
    //
    IncRoutingRetry();

    HRESULT rc = MQ_OK;

    try
    {
        if (m_qid.pguidQueue == NULL)
        {
            rc = SessionMgr.GetSessionForDirectQueue(this, &m_pSession);
        }
        else
        {
            //
            // No Session - try to establish one
            //
            QmRdGetSessionForQueue(this, &m_pSession);
        }
    }
    catch(const bad_hresult& e)
    {
        rc = e.error();
    }
    catch(const exception&)
    {
        //
        // Cannot establish connection; try it latter
        //
        rc = MQ_ERROR_INSUFFICIENT_RESOURCES;
        LogIllegalPoint(s_FN, 60);
    }


    SetHopCountFailure(FALSE);

    if(FAILED(rc))
    {
    	HandleCreateConnectionFailed(rc);
    	return;
    }

    if (m_pSession == NULL) {
        //
        // Establish session failed
        //
        TrWARNING(ROUTING, "Could not find a session for %ls",GetQueueName());
        return;
    }

    //
    // Success to get a session
    //
    ASSERT(m_pSession != NULL);

    //
    // move the queue to active list
    //
    m_pSession->AddQueueToSessionGroup(this);
}

/*====================================================
Function:       CQueue::Connect

Description:    Connect a queue to a session. Using when queue is waiting for a
                session and it was found. A session was allocated to the queue.
                It can begin sending packets.

Arguments:      pSess - pointer to allocated session

Return Value:   None. Throws an exception.

Thread Context:

History Change:

========================================================*/

void CQueue::Connect(IN CTransportBase * pSess) throw(bad_alloc)
{
    CS lock(m_cs);

    ASSERT(("invalid session", pSess != NULL));

    m_pSession = pSess;
    //
    // Move the queue from waiting group to Active group
    //
    m_pSession->AddQueueToSessionGroup(this);

#ifdef _DEBUG
    if (GetRoutingRetry() > 1)
    {
        TrERROR(GENERAL, "The message was successfully routed to queue %ls",GetQueueName());
    }
#endif
    ClearRoutingRetry();
}

/*======================================================

Function:       CQueue::RcvPk

Description:    The function gets a packet and pass it to the AC for the appropriete quque

Arguments:      PktPtrs - pointer to receive packet

Return Value:   MQI_STATUS

Thread Context:

History Change:

========================================================*/

HRESULT CQueue::PutPkt(IN CQmPacket* PktPtrs,
                       IN BOOL      fRequeuePkt,
                       IN CTransportBase*  pSession)
{
    QMOV_ACPut* pAcPutOV;
    HRESULT rc;

    //
    // Queue the packet to the appropriate queue
    //

    //
    // Create an overlapped for AcPutPacket
    //
    rc = CreateAcPutPacketRequest(pSession,
                                  ((fRequeuePkt) ? 0 : PktPtrs->GetStoreAcknowledgeNo()),
                                  &pAcPutOV);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 10);
    }
    //
    // Increment reference count. We don't delete the Session
    // object before the put operation is completed
    //
    pSession->AddRef();

    //
    // put packet in AC
    //
    try
    {
    	QmAcPutPacketWithOverlapped(
            m_hQueue,
            PktPtrs->GetPointerToDriverPacket(),
            &pAcPutOV->qmov,
            eDoNotDeferOnFailure
            );
    }
    catch (const bad_hresult& e)
    {
    	HRESULT hr = e.error();
        TrERROR(GENERAL, "ACPutPacket Failed. Error: %!hresult!", hr );
        LogHR(hr, s_FN, 20);
        return hr;
    }

    TrTRACE(GENERAL, "Pass Packet to QUEUE %ls", GetQueueName());

    return MQ_OK;
}

/*======================================================

Function:       CQueue::PutOrderedPkt

Description:    The function puts the ordered packet to the AC queue
                It also sets Received flag

Arguments:      PktPtrs - pointer to receive packet

Return Value:   MQI_STATUS

Thread Context:

History Change:

========================================================*/

HRESULT CQueue::PutOrderedPkt(IN CQmPacket* PktPtrs,
                              IN BOOL      fRequeuePkt,
                              IN CTransportBase*  pSession)
{
    QMOV_ACPutOrdered* pAcPutOV;
    HRESULT rc;

    //
    // Queue the packet to the appropriate queue, mark it Received and wait
    //

    //
    // Create an overlapped for AcPutPacket
    //
    rc = CreateAcPutOrderedPacketRequest(PktPtrs,
                                         m_hQueue,
                                         pSession,
                                         ((fRequeuePkt) ? 0 : PktPtrs->GetStoreAcknowledgeNo()),
                                         &pAcPutOV);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 30);
    }
    //
    // Increment reference count. We don't delete the Session
    // object before the put operation is completed
    //
    pSession->AddRef();

    //
    // Set received bit of the packet - to make it invisible for readers
    //     and put packet in AC
    //
    rc = ACPutPacket1(m_hQueue, PktPtrs->GetPointerToDriverPacket(), &pAcPutOV->qmov);

    if(FAILED(rc))
    {
        TrERROR(GENERAL, "ACPutPacket Failed. Error: %x", rc);
        // BUGBUG return NAK if needed
        LogHR(rc, s_FN, 40);
        return MQ_ERROR;
    }

    TrTRACE(GENERAL, "Pass Ordered Packet to QUEUE %ls", GetQueueName());

    return MQ_OK;
}

//
//Performance counters update
//


void CQueue::PerfUpdateName() const
{
    if(m_pQueueCounters == 0)
        return;

    AP<WCHAR> pName = GetName();
    PerfApp.SetInstanceName(m_pQueueCounters, pName);
}


/*======================================================

Function:       CQueue::PerfRegisterQueue()

Description:    Registers an instance of a queue object corrosponding to this queue
                for performace monitoring.

Arguments:

Return Value:   None

Comments:       The CPerf::AddInstance function always returns a valid pointer (even if more than
                the maximum allowed instances have been added) so the member should never fail.

========================================================*/

void CQueue::PerfRegisterQueue()
{
    AP<WCHAR> pName = GetName();
    m_pQueueCounters = (QueueCounters *)PerfApp.AddInstance(PERF_QUEUE_OBJECT, pName);
    PerfApp.ValidateObject(PERF_QUEUE_OBJECT);

    if (PerfApp.IsDummyInstance(m_pQueueCounters))
    {
        //
        //  Do not pass dummy instances to the device driver, just pass null,
        //  it'll handle it.
        //
        m_pQueueCounters = NULL;
    }
}

/*======================================================

Function:         CQueue::PerfRemoveQueue()

Description:      Removes the instance correspanding to this queue from
                  performance monitoring

Arguments:

Return Value:     None

Comments:

========================================================*/

void CQueue::PerfRemoveQueue()
{
    PerfApp.RemoveInstance(PERF_QUEUE_OBJECT, m_pQueueCounters);

    m_pQueueCounters = NULL;
}

/*======================================================

Function:         CQueue::SetQueueNotValid()

Description:

Arguments:

Return Value:     None

Comments:

========================================================*/

void CQueue::SetQueueNotValid()
{
    ASSERT(!m_fNotValid);
    ASSERT(GetQueueType() != QUEUE_TYPE_MULTICAST);

	TrERROR(GENERAL, "Setting Queue '%ls' to not valid", GetQueueName());

    //
    //  Purge the queue, removing all messages from it. The queue will be close
    //  when no handles and no messages are in the queue.
    //
    HANDLE hQueue = GetQueueHandle();
    if (hQueue != INVALID_HANDLE_VALUE)
    {
        HRESULT hr;
        hr = ACPurgeQueue(hQueue, TRUE, MQMSG_CLASS_NORMAL);

        if (hr == STATUS_INSUFFICIENT_RESOURCES)
        {
            Sleep(2 * 1000);

            //
            // ISSUE-2000/10/22-shaik: Second chance fail due to low resources causes leaks.
            //
            hr = ACPurgeQueue(hQueue, TRUE, MQMSG_CLASS_NORMAL);
        }

        LogHR(hr, s_FN, 101);

        CQGroup::MoveQueueToGroup(this, NULL);
    }

    m_fNotValid = TRUE ;

    if (IsOnHold())
    {
        ASSERT(!IsLocalQueue());

        //
        // remove the queu from "onHold" registery
        //
        ResumeDeletedQueue(this);
    }

    //
    //  Remove the queue from hash so it will no be found
    //
    QueueMgr.RemoveQueueFromHash(this);
}

/*======================================================

Function:         SetConnectorQM()

Description:      The Function set the Connector QM that should be used
                  to reach the foreign queue. If the queue is not transacted
                  foreign queue the Connector QM is ignored.

                  The function calls twice. first after recovery, the GUID of
                  the Connector QM is fetched from the packet. the second time
                  when creating a queue object for transacted foreign queue.
                  In this case the function determine the Connector QM and set
                  its guid.

Arguments:        pgConnectorQM - pointer to Connector QM GUID. When calling
                  for creating a new queue object the value is null

Return Value:     None

Comments:

========================================================*/
HRESULT
CQueue::SetConnectorQM(const GUID* pgConnectorQM)
{
    HRESULT hr = MQ_OK;

    delete m_pgConnectorQM;
    m_pgConnectorQM = NULL;

    if (IsDSQueue())
    {
        //
        //  Get Connector QM ID
        //
        if (pgConnectorQM)
        {
            ASSERT(m_pgConnectorQM == NULL);
            ASSERT(IsTransactionalQueue() && IsForeign());

            m_pgConnectorQM = new GUID;
            *m_pgConnectorQM = *pgConnectorQM;
        }
        else
        {
            if (IsForeign() && IsTransactionalQueue())
            {
				m_pgConnectorQM = new GUID;
                try
                {
				    RdGetConnector(*m_pguidDstMachine, *m_pgConnectorQM);
                }
                catch(const bad_hresult& e)
                {
                    hr = e.error();
                }
                catch(const exception&)
                {
                    hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {
                if (IsUnkownQueueType())
                {
                    m_pgConnectorQM = new GUID;
                    *m_pgConnectorQM = GUID_NULL;
                }
            }
        }
    }
    else
    {
        ASSERT(pgConnectorQM == NULL);
    }

    #ifdef _DEBUG

        if (m_pgConnectorQM)
        {
            AP<WCHAR> lpcsTemp;
            GetQueue(&lpcsTemp);

            TrTRACE(XACT_GENERAL, "The Connector QM for Queue: %ls is: %!guid!", lpcsTemp, m_pgConnectorQM);
        }

    #endif

    return LogHR(hr, s_FN, 50);
}

/*======================================================

Function:         CQueue::GetRoutingMachine()

Description:      The function return the machine guid that should be used when
                  routing to the QUEUE.

                  If the queue is transacted foreign queue and we are FRS we route
                  according to the Connector QM. otherwise the routing is done
                  according to the destination machine.

Arguments:

Return Value:     None

Comments:

========================================================*/
const GUID*
CQueue::GetRoutingMachine(void) const
{
    ASSERT((GetQueueType() == QUEUE_TYPE_PUBLIC) ||
           (GetQueueType() == QUEUE_TYPE_MACHINE));

    if (GetConnectorQM() && !QmpIsLocalMachine(GetConnectorQM()))
    {
        ASSERT(IsForeign() && IsTransactionalQueue());
        return GetConnectorQM();
    }
    else
    {
        ASSERT(GetMachineQMGuid() != NULL);
        return GetMachineQMGuid();
    }
}

LPWSTR CBaseQueue::GetName() const
{
    if (m_qName != NULL)
    {
    	return newwcs(m_qName);
    }

    if (m_qid.pguidQueue != NULL)
    {
        const QUEUE_FORMAT qf = GetQueueFormat();

        //
        // Use the format name as the name.
        // NOTE: we don't care if the buffer is too small (it will not).
        // In any case it will be filled up to it's end.
        //
        //
        ULONG Size;
 	   	AP<WCHAR> pName = new WCHAR[MAX_PATH];
        MQpQueueFormatToFormatName(&qf, pName, MAX_PATH, &Size, false);
        return pName.detach();
    }

    return 0;
}


#ifdef _DEBUG
void
CBaseQueue::GetQueue(OUT LPWSTR* lplpcsQueue)
{
    *lplpcsQueue = GetName();

    if(*lplpcsQueue == NULL)
    {
        *lplpcsQueue = new WCHAR[MAX_PATH];
        HRESULT hr = StringCchPrintf(*lplpcsQueue, MAX_PATH, L"Unknown or deleted queue at %p", this);
        ASSERT(SUCCEEDED(hr));
    }
}
#endif // _DEBUG

//
// Admin Functions
//
LPCWSTR
CQueue::GetConnectionStatus(
    void
    ) const
{
    CS lock(m_cs);

    if (IsLocalQueue() || IsConnectorQueue())
        return MGMT_QUEUE_STATE_LOCAL;

    if (IsOnHold())
        return MGMT_QUEUE_STATE_ONHOLD;

	//
	// Capture the group before checking the session. Otherwise we can get unstable state.
	// The queue doesn't belong to session group, therefore the session pointer is null. Now
	// before capturing the group, the queue was moved to session group. As a result the queue
	// doesn't belong to build-in group any more and we got an assert.
	//
    const CQGroup* pGroup = GetGroup();

	if (m_pSession != NULL)
    {
        if (m_pSession->IsDisconnected())
        {
            return MGMT_QUEUE_STATE_DISCONNECTING;
        }
        else
        {
            return MGMT_QUEUE_STATE_CONNECTED;
        }
    }

	if (pGroup == NULL)
    {
		//
        // ISSUE-2001/07/11-urih: The queue is in transition mode.
		//                        Need better synchronization between CQGroup and CQueue
        //
		return MGMT_QUEUE_STATE_NONACTIVE;
	}

    if (pGroup == g_pgroupNonactive)
        return MGMT_QUEUE_STATE_NONACTIVE;

    if (pGroup == g_pgroupWaiting)
        return MGMT_QUEUE_STATE_WAITING;

    if (pGroup == g_pgroupNotValidated)
        return MGMT_QUEUE_STATE_NEED_VALIDATE;

    if (pGroup == g_pgroupDisconnected)
        return MGMT_QUEUE_STATE_DISCONNECTED;

	if (pGroup == g_pgroupLocked)
		return MGMT_QUEUE_STATE_LOCKED;
	
    if (IsDirectHttpQueue())
        return GetHTTPConnectionStatus();

    if (GetQueueType() == QUEUE_TYPE_MULTICAST)
        return MGMT_QUEUE_STATE_CONNECTED;

    ASSERT(0);
    return L"";

}


LPCWSTR
CQueue::GetHTTPConnectionStatus(
    void
    ) const
{
    ASSERT(IsDirectHttpQueue());

    R<CTransport> p = TmGetTransport(GetQueueName());
    if (p.get() == NULL)
        return MGMT_QUEUE_STATE_NONACTIVE;

    CTransport::ConnectionState state = p->State();
    switch (state)
    {
    case CTransport::csNotConnected:
        return MGMT_QUEUE_STATE_NONACTIVE;

    case CTransport::csConnected:
        return MGMT_QUEUE_STATE_CONNECTED;

    case CTransport::csShuttingDown:
        return MGMT_QUEUE_STATE_DISCONNECTING;

    case CTransport::csShutdownCompleted:
        return MGMT_QUEUE_STATE_DISCONNECTED;

    default:
        //
        // Illegal Connection state",
        //
        ASSERT(0);
    };

    return L"";
}


LPWSTR
CQueue::GetNextHop(
    void
    ) const
{
    CS lock(m_cs);

    if (!m_pSession)
    {
        if (GetQueueType() == QUEUE_TYPE_MULTICAST)
        {
            ASSERT(GetQueueName != NULL);
            return newwcs(GetQueueName());
        }
        return NULL;
    }

    return GetReadableNextHop(m_pSession->GetSessionAddress());
}


LPCWSTR
CQueue::GetType(
    void
    ) const
{
    switch (GetQueueType())
    {
        case QUEUE_TYPE_PUBLIC:
            ASSERT(IsDSQueue());
            return MGMT_QUEUE_TYPE_PUBLIC;

        case QUEUE_TYPE_PRIVATE:
            ASSERT(IsPrivateQueue());
            return MGMT_QUEUE_TYPE_PRIVATE;

        case QUEUE_TYPE_MACHINE:
            if (IsPrivateQueue())
            {
                ASSERT(!IsLocalQueue());
                return MGMT_QUEUE_TYPE_PRIVATE;
            }

            return MGMT_QUEUE_TYPE_MACHINE;

        case QUEUE_TYPE_CONNECTOR:
            ASSERT(IsConnectorQueue());
            return MGMT_QUEUE_TYPE_CONNECTOR;

        case QUEUE_TYPE_MULTICAST:
            return MGMT_QUEUE_TYPE_MULTICAST;

        case QUEUE_TYPE_UNKNOWN:
        {
			LPCWSTR lpcsTemp;

			if (IsDirectHttpQueue())
			{
				DirectQueueType dqt;
				lpcsTemp = FnParseDirectQueueType(m_qName, &dqt);

				//
				// skip machine name
				//
				lpcsTemp = wcspbrk(lpcsTemp, FN_HTTP_SEPERATORS);
				if ((lpcsTemp == NULL) ||
					(_wcsnicmp(lpcsTemp +1, FN_MSMQ_HTTP_NAMESPACE_TOKEN, FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN)) != 0)
					return MGMT_QUEUE_TYPE_PUBLIC;

				lpcsTemp = wcspbrk(lpcsTemp + 1, FN_HTTP_SEPERATORS);
				if (lpcsTemp == NULL)
					return MGMT_QUEUE_TYPE_PUBLIC;
			}
			else
			{
				//
				// The queue is remote direct queue. Check the queue Type
				// according to format name
				//
				lpcsTemp = wcschr(m_qName, L'\\');
				ASSERT(("Bad queue name.", lpcsTemp	!= NULL));
			}

			if(lpcsTemp == NULL)
			{
				TrERROR(GENERAL, "Bad queue name %ls", m_qName);
				throw bad_hresult(MQ_ERROR_INVALID_PARAMETER);
			}

            if (_wcsnicmp(lpcsTemp+1,FN_PRIVATE_TOKEN, FN_PRIVATE_TOKEN_LEN) == 0)
            {
                return MGMT_QUEUE_TYPE_PRIVATE;
            }

			return MGMT_QUEUE_TYPE_PUBLIC;
        }

        default:
            ASSERT(0);
    }
    return L"";
}

void
CQueue::Resume(
    void
    )
{
	BOOL fOnHold = InterlockedExchange(&m_fOnHold, FALSE);
    if (!fOnHold)
    {
        //
        // The queue isn't in OnHold state. Can't execute resume
        //
        return;
    }

    TrTRACE(GENERAL, "Resume Queue: %ls. Move the Queue to NonActive Group",GetQueueName());

    //
    // return the Queue back to Non-Active group
    //
    try
    {
		QueueMgr.MovePausedQueueToNonactiveGroup(this);
    }
    catch (const exception&)
    {
    	TrERROR(GENERAL, "Failed to resume Queue: %ls. Moving the queue to non-active group was failed",GetQueueName());
		InterlockedExchange(&m_fOnHold, TRUE);
		throw;
    }

    //
    // Decrement the refernce count such the queue object cab be cleaned
    //
    Release();
}


void
CQueue::Pause(
    void
    )
{

	BOOL fOnHold = InterlockedExchange(&m_fOnHold, TRUE);
    if (fOnHold)
    {
        //
        // The queue is already onhold.
        //
        return;
    }

    TrTRACE(GENERAL, "Pause Queue: %ls.",GetQueueName());

    //
    // Increment the reference count. So the Queue object will not cleaned up
    //
    AddRef();

	//
	// For outgoing multicast queue, calls the MTM to close the connection
	//
	if (GetQueueType() == QUEUE_TYPE_MULTICAST)
	{
		MULTICAST_ID id;

		LPCTSTR pQueueName=GetQueueName();
		MQpStringToMulticastId(pQueueName, wcslen(pQueueName), id);

		MtmTransportPause(id);
		return;
	}

	//
	// If the queue is direct http - then we don't have to deal with
	// session object member but to call the tm to stop delivery
	//
	QUEUE_FORMAT qf = GetQueueFormat();
	if(FnIsDirectHttpFormatName(&qf))
	{
		TmPauseTransport(qf.DirectID());
		return;
	}


    CTransportBase* pSession = NULL;
	{
		CS Lock(m_cs);

		//
		// When the queue move to onhold state, MSMQ disconnect the
		// session it belong to. As a result all the queues moved to
		// Nonactive group. When the QM gets the next message for sending
		// from this queue, it moves the Queue to OnHold greop
		//
		if ((IsOnHold()) && (m_pSession != NULL))
		{
			pSession = m_pSession;
			pSession->AddRef();
		}
	}

	if (pSession != NULL)
	{
		pSession->Disconnect();
		pSession->Release();
	}
}

const QUEUE_FORMAT
CBaseQueue::GetQueueFormat(
    void
    ) const
{
    QUEUE_FORMAT qf;

    switch (m_dwQueueType)
    {
        case QUEUE_TYPE_PUBLIC:
            ASSERT(IsDSQueue());
            qf.PublicID(*m_qid.pguidQueue);
            break;

        case QUEUE_TYPE_PRIVATE:
            ASSERT(IsPrivateQueue());
            qf.PrivateID(*m_qid.pguidQueue, m_qid.dwPrivateQueueId);
            break;

        case QUEUE_TYPE_MACHINE:
            if (IsPrivateQueue())
            {
                qf.PrivateID(*m_qid.pguidQueue, m_qid.dwPrivateQueueId);
            }
            else
            {
                qf.MachineID(*m_qid.pguidQueue);
            }
            break;

        case QUEUE_TYPE_CONNECTOR:
            ASSERT(m_fConnectorQueue);
            qf.ConnectorID(*m_qid.pguidQueue);
            if (IsPrivateQueue())
            {
                qf.Suffix(QUEUE_SUFFIX_TYPE_XACTONLY);
            }

            break;

        case QUEUE_TYPE_MULTICAST:
            ASSERT(("CBaseQueue::GetQueueFormat for multicast queue is unexpected!", 0));
            break;

        case QUEUE_TYPE_UNKNOWN:
            qf.DirectID(const_cast<LPWSTR>(GetQueueName()));
            break;

        default:
            ASSERT(0);
    }

    return qf;
}


void
CQueue::Requeue(
    CQmPacket* pPacket
    )
{
    //
    // put packet in AC
    //
    QmAcPutPacket(GetQueueHandle(), pPacket->GetPointerToDriverPacket(),eDoNotDeferOnFailure);
}


void
CQueue::EndProcessing(
    CQmPacket* pPacket,
	USHORT mqclass
    )
{
    QmAcFreePacket( 
    			   pPacket->GetPointerToDriverPacket(), 
    			   mqclass, 
    			   eDeferOnFailure);
}


void
CQueue::LockMemoryAndDeleteStorage(
    CQmPacket* /* pPacket */
    )
{
    ASSERT(("CQueue::LockMemoryAndDeleteStorage should not be called!", 0));
}


void
CQueue::GetFirstEntry(
    EXOVERLAPPED* pov,
    CACPacketPtrs& acPacketPtrs
    )
{
    acPacketPtrs.pPacket = NULL;
    acPacketPtrs.pDriverPacket = NULL;

    //
    // Create new GetPacket request from the queue
    //
    HRESULT rc = QmAcGetPacket(
                    GetQueueHandle(),
                    acPacketPtrs,
                    pov
                    );

    if (FAILED(rc))
    {
        TrERROR(GENERAL, "Failed to  generate get request from queue: %ls. Error %x", GetName(), rc);
        LogHR(rc, s_FN, 100);
        throw exception();
    }
}


void CQueue::CancelRequest(void)
{
    ASSERT(0);
}


bool CQueue::IsDirectHttpQueue(void) const
{
	if(GetQueueName())
		return FnIsHttpDirectID(GetQueueName());

	return false;
}


LPWSTR CQueue::RedirectedTo() const
{
	return newwcs(m_RedirectedToUrl.get());
}



void CQueue::RedirectedTo(LPCWSTR RedirectedToUrl)
{
	m_RedirectedToUrl.free();
	if(RedirectedToUrl != NULL)
	{
		m_RedirectedToUrl = newwcs(RedirectedToUrl);
	}
}



R<CQGroup> CQueue::CreateMessagePool(void)
{
    try
    {
        R<CQGroup> pGroup = new CQGroup();
        pGroup->InitGroup(NULL, TRUE);

		CQGroup::MoveQueueToGroup(this, pGroup.get());
		return pGroup;
    }
    catch(const exception&)
    {
        TrERROR(GENERAL, "Failed to create connection for multicast address: %ls.", GetName());
        LogIllegalPoint(s_FN, 70);
		
		IncRoutingRetry();
		SessionMgr.AddWaitingQueue(this);

        throw;
    }
}


void CQueue::CreateMulticastConnection(const MULTICAST_ID& id)
{
	R<CQGroup> pGroup = CreateMessagePool();
	
	try
	{
		R<COutPgmSessionPerfmon> pPerfmon = new COutPgmSessionPerfmon;

        MtmCreateTransport(pGroup.get(), pPerfmon.get(), id);

		if (QueueMgr.IsOnHoldQueue(this))
		{
			MtmTransportPause(id);
		}

	}
	catch(const exception&)
	{
		pGroup->OnRetryableDeliveryError();
		pGroup->Close();
		throw;
	}
}



void CQueue::CreateHttpConnection(void)
{
	R<CQGroup> pGroup = CreateMessagePool();

    try
    {
		R<COutHttpSessionPerfmon> pPerfmon = new COutHttpSessionPerfmon;
		
		//
		// The queue name might be redirected to another url so we should
		// take the redirected destination as the destination url.	
		//
		AP<WCHAR> pRedirectedName = RedirectedTo();
		LPCWSTR pTragetName = (pRedirectedName != NULL) ? pRedirectedName.get() : GetQueueName();

		AP<WCHAR> url = newwcs(pTragetName);
		FnReplaceBackSlashWithSlash(url);

		TmCreateTransport(pGroup.get(), pPerfmon.get(), url);

		if(QueueMgr.IsOnHoldQueue(this))
		{
			TmPauseTransport(pTragetName);
			return;
		}
    }
    catch(const exception&)
    {
		pGroup->OnRetryableDeliveryError();
		pGroup->Close();
		throw;
    }
}

LONGLONG CQueue::GetQueueSequenceId(void) const
{
	if (GetQueueHandle() == INVALID_HANDLE_VALUE)
		return 0;

    //
    // Find whether Exactly-Once-Delivery sequence exists
    //
    CACGetQueueProperties qp = { 0 };
    HRESULT hr = ACGetQueueProperties(GetQueueHandle(), qp);
    if (SUCCEEDED(hr))
	    return qp.liSeqID;

    return 0;
}


bool
CQueue::TimeToRemoveFromWaitingGroup(
	CTimer* pTimer,
	DWORD dwDeliveryRetryTimeOutScale
    )
{	
    try
    {
    	SessionMgr.MoveQueueFromWaitingToNonActiveGroup(this);
    }
    catch(const exception&)
    {	
    		CS lock(m_cs);
    		
		if(!IsConnected())
		{
			DWORD dwTime = SessionMgr.GetWaitingTimeForQueue(this);
    			ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(dwTime * dwDeliveryRetryTimeOutScale));
			return false;
		}
    }
    return true;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\cqueue.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cqueue.h

Abstract:
    Definition of a Receive/Send queue class

Author:
    Uri habusha (urih)

--*/


#ifndef __CQUEUE_H__
#define __CQUEUE_H__

#include "qmpkt.h"
#include "session.h"
#include "acdef.h"
#include "qmutil.h"
#include "RemoteRead.h"
#include "qm2qm.h"
#include "rrcontext.h"
#include "_mqrpc.h"
#include "msi.h"
#include "qmrtopen.h"

#define  QUEUE_SIGNATURE  0x426f617a

typedef struct _QueueProps
{
    LPWSTR  lpwsQueuePathName;
    GUID*   pQMGuid;
    BOOL    fIsLocalQueue;
    BOOL    fJournalQueue;
    BOOL    fTransactedQueue;
    DWORD   dwQuota;
    DWORD   dwJournalQuota;
    GUID    guidDirectQueueInstance;
    SHORT   siBasePriority;
    BOOL    fSystemQueue;
    BOOL    fConnectorQueue;
    BOOL    fAuthenticate;
    DWORD   dwPrivLevel;
    BOOL    fForeign;
    BOOL    fUnknownQueueType;
    DWORD 	dwPrivateQueueId;   // Local Private Queue Id (if relevant)
    AP<WCHAR> lpwsQueueDnsName;
} QueueProps, * PQueueProps;

class CQGroup;

#define  QUEUE_TYPE_UNKNOWN 0
#define  QUEUE_TYPE_PUBLIC  1
#define  QUEUE_TYPE_PRIVATE 2
#define  QUEUE_TYPE_MACHINE 3
#define  QUEUE_TYPE_CONNECTOR 4
#define  QUEUE_TYPE_MULTICAST 5

struct RR_CLIENT_INFO {
   ULONG hcliQueue;
   ULONG ulTag;
};

template<>
inline UINT AFXAPI HashKey(const RR_CLIENT_INFO& key)
{
    return key.ulTag;
}

inline operator ==(const RR_CLIENT_INFO& a, const RR_CLIENT_INFO& b)
{
    return ((a.hcliQueue == b.hcliQueue) && (a.ulTag == b.ulTag));
}

typedef CMap<RR_CLIENT_INFO, const RR_CLIENT_INFO&, DWORD, DWORD> CRemoteMapping;

//
// CBaseQueue Class
//==================
// Data Memeber:
//
//   m_qName - This field is used in debuging mode. It is used for producing
//             meaningfull debug messages. It is also used for auditing in
//             order to write the queue name in the audited events.
//

class CBaseQueue : public IMessagePool
{
public:
    CBaseQueue() ;

protected:
    virtual ~CBaseQueue() {}

public:
    BOOL IsLocalQueue(void) const ;
    BOOL IsRemoteProxy(void) const ;
    BOOL IsDSQueue(void) const;
    BOOL IsPrivateQueue(void) const;
    BOOL IsSystemQueue() const;

    const GUID *GetQueueGuid(void) const;
    void  SetQueueGuid(GUID *pGuid) ;
    const QUEUE_ID* GetQueueId(void);

    void  InitNameAndGuid( IN const QUEUE_FORMAT* pQueueFormat,
                         IN PQueueProps         pQueueProp) ;

    LPCTSTR GetQueueName(void) const ;
    void    SetQueueName(LPTSTR pName);

    inline DWORD GetSignature() { return m_dwSignature ; }

    const QUEUE_FORMAT GetQueueFormat() const;

#ifdef _DEBUG
    void GetQueue(OUT LPWSTR* lpcsQueue);
#endif

protected:
    LPWSTR GetName() const;

protected:
    union {
        USHORT   m_usQueueType;
        struct {
            USHORT m_fLocalQueue      : 1;
            USHORT m_fRemoteProxy     : 1;
            USHORT m_fSystemQueue     : 1;      // True if private system Queue.
            USHORT m_fConnectorQueue  : 1;
            USHORT m_fForeign         : 1;
            USHORT m_fJournalQueue    : 1;
            USHORT m_fTransactedQueue : 1;
            USHORT m_fAuthenticate    : 1;
            USHORT m_fUnknownQueueType: 1;      // TRUE if opened without DS
        };
    };


    LPTSTR      m_qName ;
    QUEUE_ID    m_qid ;
    DWORD       m_dwQueueType;
    DWORD       m_dwSignature ;
};


//
// CQueueSecurityDescriptor Class
// helper class to handle refrence count for users of Security Descriptor
//===============
// Data Memeber:
//
//   m_pSecurityDescriptor - Security descriptor
//
class CQueueSecurityDescriptor : public CReference
{
public:	
	CQueueSecurityDescriptor(const PSECURITY_DESCRIPTOR pSD)
	{
		if(pSD == NULL)
		{
			return;
		}
		ASSERT(IsValidSecurityDescriptor(pSD));

		DWORD dwSdLen = GetSecurityDescriptorLength(pSD);
		m_pSecurityDescriptor = new char[dwSdLen];					// Allocate the memory.
		memcpy(m_pSecurityDescriptor, pSD, dwSdLen);                // Copy the security descriptor.
	}

	
	PSECURITY_DESCRIPTOR GetSD()
	{
		return static_cast<PSECURITY_DESCRIPTOR>(m_pSecurityDescriptor);
	}


private:
	AP<char> m_pSecurityDescriptor; // The security descriptor

};


//
// CQueue Class
//===============
// Data Memeber:
//
//   m_qHandle - Specifies the queue handle in AC driver. All the reference to the queue
//             in AC is with this handle.
//
//   m_qGroupHandle - specifies the handle of the group to which the queue is belong. This
//             field is only relevant for send queues.
//
//   m_qGuid - Queue guid using to identify the queue.
//
//   m_fSendMore - indicates if more packets can be passed to the session. This field
//             is only relevant for the send queue.
//
//   m_qSock - SOCKET Handle uses for sending packet to a queue. Relevant for send
//             packet only.
//
//   m_listPkt - Unsend packet, when the packet can be resend all the packets are returned to
//             AC driver. The driver is responsible to hold them according to there priority.
//

class CQueue : public CBaseQueue
{
  public:
      CQueue( IN const QUEUE_FORMAT* pQueueFormat,
              IN HANDLE              hQueue,
              IN PQueueProps         pQueueProp,
              IN BOOL                fNotDSValidated = FALSE ) ;

  protected:
      virtual ~CQueue();

  public:
	  LPWSTR RedirectedTo() const;
	  void 	RedirectedTo(LPCWSTR RedirectedToUrl);	
	
      void  InitQueueProperties(IN PQueueProps   pQueueProp) ;

      void   SetQueueHandle(IN HANDLE hQueue);
      HANDLE GetQueueHandle(void) const;

      HRESULT  PutPkt(IN CQmPacket*      PktPtrs,
                      IN BOOL            fRequeuePkt,
                      IN CTransportBase* pSession);

      HRESULT  PutOrderedPkt(IN CQmPacket*       PktPtrs,
                             IN BOOL             fRequeuePkt,
                             IN CTransportBase*  pSession);

      void CQueue::HandleCreateConnectionFailed(HRESULT rc);
	  void CreateConnection(void) throw(std::bad_alloc);

      void Connect(IN CTransportBase * pSess) throw(std::bad_alloc);

      HANDLE GetGroupHandle(void) const;

      void SetSessionPtr(CTransportBase*);
      BOOL IsConnected(void) const;

      void     SetGroup(CQGroup*);
      CQGroup* GetGroup(void) const;

      void SetJournalQueue(BOOL);
      BOOL IsJournalQueue(void) const;

      void  SetQueueQuota(DWORD);
      DWORD GetQueueQuota(void) const;

      void  SetJournalQueueQuota(DWORD);
      DWORD GetJournalQueueQuota(void) const;

      void SetBaseQueuePriority(LONG);
      LONG GetBaseQueuePriority(void) const;

      void SetTransactionalQueue(BOOL);
      BOOL IsTransactionalQueue(void) const;

      BOOL IsConnectorQueue(void) const;
      BOOL IsForeign(void) const;

      void SetAuthenticationFlag(BOOL);
      BOOL ShouldMessagesBeSigned() const;

      void  UnknownQueueType(BOOL);
      BOOL  IsUnkownQueueType() const;

      void SetPrivLevel(DWORD);
      DWORD GetPrivLevel(void) const;

      DWORD GetQueueType(void) const;

      DWORD GetPrivateQueueId(void) const;

      const GUID* GetMachineQMGuid(void) const;

      void  ClearRoutingRetry(void);
      void  IncRoutingRetry(void);
      DWORD GetRoutingRetry(void) const;

      void  SetHopCountFailure(BOOL flag);
      BOOL  IsHopCountFailure(void) const;

      void SetSecurityDescriptor(void);
      void SetSecurityDescriptor(const PSECURITY_DESCRIPTOR pSD);

      R<CQueueSecurityDescriptor> GetSecurityDescriptor(void) const;
      BOOL  QueueNotValid() const;
      void  SetQueueNotValid() ;

      QueueCounters* GetQueueCounters();

      HRESULT SetConnectorQM(const GUID* pgConnectorQM = NULL);
      const GUID* GetConnectorQM(void) const;

      const GUID* GetRoutingMachine(void) const;
      LONGLONG GetQueueSequenceId(void) const;
      void PerfUpdateName(void) const;

      bool IsDirectHttpQueue(void) const;
      void CreateHttpConnection(void);
      void CreateMulticastConnection(const MULTICAST_ID& id);

      bool  TimeToRemoveFromWaitingGroup(CTimer* pTimer, DWORD dwDeliveryRetryTimeOutScale);

      //
      // Admin Functions
      //
      LPCWSTR GetConnectionStatus(void) const;
      LPCWSTR GetHTTPConnectionStatus(void) const;

      LPCWSTR GetType(void) const;
      LPWSTR GetNextHop(void) const;
      BOOL IsOnHold(void) const;

      void Pause(void);
      void Resume(void);

  public:
    //
    // Queue interfaces
    //
    void Requeue(CQmPacket* pPacket);
    void EndProcessing(CQmPacket* pPacket, USHORT mqclass);
    void LockMemoryAndDeleteStorage(CQmPacket * pPacket);

    void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs);
    void CancelRequest(void);

  private:
		R<CQGroup> CreateMessagePool(void);
		AP<WCHAR> m_RedirectedToUrl;
        R<CQueueSecurityDescriptor> m_pSecurityDescriptorObject; // The security descriptor of the queue.
		mutable CCriticalSection m_csSecurityDescriptor;           // CS of security descriptor.

		mutable CCriticalSection    m_cs;

        LONG                m_lBasePriority;
        DWORD               m_dwPrivLevel;       // Required privacy level of messages.
        DWORD               m_dwQuota;
        DWORD               m_dwJournalQuota;
        GUID*               m_pguidDstMachine;   //
        GUID*               m_pgConnectorQM;
        CTransportBase*     m_pSession;          // pointer to session
        CQGroup*            m_pGroup;            // pointer togroup the queue belong

        DWORD               m_dwRoutingRetry;
        BOOL                m_fHopCountFailure;

        HANDLE m_hQueue;   // Queue handle in AC driver
        BOOL m_fNotValid;
        LONG m_fOnHold;

        //
        //Queue performance counters defenitions
        //
        QueueCounters *m_pQueueCounters;

        void PerfRemoveQueue();
        void PerfRegisterQueue();


};


//---------------------------------------------------------
//
//  CBaseRRQueue - RRQueue base class
//
//---------------------------------------------------------

class CBaseRRQueue : public CBaseQueue
{
public:
	CBaseRRQueue(
		IN const QUEUE_FORMAT* pQueueFormat,
		IN PQueueProps pQueueProp,
		IN handle_t	hBind
		);

protected:
	virtual ~CBaseRRQueue();

public:

	void  RemoteRead(CACRequest * pRequest);

	void  RemoteCreateCursor(CACRequest *pRequest);

	void  RemoteCloseCursor(CACRequest* pRequest);

	void  RemoteCancelRead(CACRequest* pRequest);

	void  RemotePurgeQueue();

	virtual CRemoteReadBase* CreateRemoteReadRequest(CACRequest *pRequest) = 0;

	virtual CRemoteCloseQueueBase* CreateCloseRRContextRequest() = 0;

	virtual CRemoteCreateCursorBase* CreateRemoteCreateCursorRequest(CACRequest *pRequest) = 0;

	virtual CRemoteCloseCursorBase* CreateRemoteCloseCursorRequest(CACRequest *pRequest) = 0;

	virtual CRemotePurgeQueueBase* CreateRemotePurgeQueueRequest() = 0;

	virtual CRemoteCancelReadBase* CreateRemoteCancelReadRequest(CACRequest* pRequest) = 0;

    //
    // Queue interfaces
    //
    void Requeue(CQmPacket*)
    {
        ASSERT(0);
    }


    void EndProcessing(CQmPacket*, USHORT)
    {
        ASSERT(0);
    }


    void LockMemoryAndDeleteStorage(CQmPacket*)
    {
        ASSERT(0);
    }


    void GetFirstEntry(EXOVERLAPPED* , CACPacketPtrs&)
    {
        ASSERT(0);
    }


    void CancelRequest(void)
    {
        ASSERT(0);
    }


    virtual PVOID GetRRContext() = 0;


    void SetCli_hACQueue(HANDLE hQueue)
    {
    	*&m_cli_hACQueue = hQueue;
    }


    HANDLE GetCli_hACQueue()
    {
    	return m_cli_hACQueue;
    }

	virtual void IncrementEndReceiveCnt() = 0;

	virtual void DecrementEndReceiveCnt() = 0;

	virtual void InvalidateHandleForReceive() = 0;

	const handle_t GetBind()
	{
		return m_hRemoteBind;
	}
	
	const void DetachBind()
	{
		m_hRemoteBind.detach();
	}

protected:

    virtual void ResetRRContext() = 0;

    virtual void DestroyClientRRContext() = 0;

	const handle_t GetBind2()
	{
		return m_hRemoteBind2;
	}

 	ULONG BindInqRpcAuthnLevel(handle_t hBind);

	HRESULT
	CreateBind(
		LPWSTR MachineName,
		ULONG* peAuthnLevel,
		GetPort_ROUTINE pfnGetPort
		);

	HRESULT
	CreateBind2(
		LPWSTR MachineName,
		ULONG* peAuthnLevel,
		PORTTYPE PortType,
		GetPort_ROUTINE pfnGetPort
		);

	void CloseRRContext();

private:
	CBindHandle m_hRemoteBind;
	CBindHandle m_hRemoteBind2;

	//
	// client side AC handle associated with this queue
	//
	CFileHandle m_cli_hACQueue;
};


//---------------------------------------------------------
//
//  CRRQueue - Old Remote Read interface RRQueue
//
//---------------------------------------------------------

class CRRQueue : public CBaseRRQueue
{
public:
	CRRQueue(
		IN const QUEUE_FORMAT* pQueueFormat,
		IN PQueueProps pQueueProp,
		IN handle_t	hBind
		);

protected:
	virtual ~CRRQueue();

public:

	virtual COldRemoteRead* CreateRemoteReadRequest(CACRequest *pRequest);

	virtual COldRemoteCloseQueue* CreateCloseRRContextRequest();

	virtual COldRemoteCreateCursor* CreateRemoteCreateCursorRequest(CACRequest* pRequest);

	virtual COldRemoteCloseCursor* CreateRemoteCloseCursorRequest(CACRequest* pRequest);

	virtual COldRemotePurgeQueue* CreateRemotePurgeQueueRequest();

	virtual COldRemoteCancelRead* CreateRemoteCancelReadRequest(CACRequest* pRequest);


	HRESULT
	OpenRRSession(
	    ULONG hRemoteQueue,
	    ULONG pRemoteQueue,
	    PCTX_RRSESSION_HANDLE_TYPE *ppRRContext,
	    DWORD  dwpContext
	    );


    void SetServerQueue(ULONG srv_pQMQueue, ULONG srv_hACQueue)
    {
    	m_srv_pQMQueue = srv_pQMQueue;
    	m_srv_hACQueue = srv_hACQueue;
    }


	ULONG GetSrv_pQMQueue()
	{
		return m_srv_pQMQueue;
	}


	ULONG GetSrv_hACQueue()
	{
		return m_srv_hACQueue;
	}


    void SetRRContext(PCTX_RRSESSION_HANDLE_TYPE pRRContext)
    {
    	m_pRRContext = pRRContext;
    }


    virtual PCTX_RRSESSION_HANDLE_TYPE GetRRContext()
    {
    	return m_pRRContext;
    }


    virtual void ResetRRContext()
    {
    	m_pRRContext = NULL;
    }

    virtual void DestroyClientRRContext()
    {
    	RpcSsDestroyClientContext(&m_pRRContext);
    }

	virtual void IncrementEndReceiveCnt();

	virtual void DecrementEndReceiveCnt();

	bool HandleValidForReceive()
	{
		return m_fHandleValidForReceive;
	}

	virtual void InvalidateHandleForReceive()
	{
		//
		// Invalidate the handle for further Receives in case of EndReceive fails.
		// From now on Every Receive request will fail with MQ_ERROR_STALE_HANDLE.
		//
		m_fHandleValidForReceive = false;
	}

	void CancelPendingStartReceiveRequest(CACRequest *pRequest);

	bool QueueStartReceiveRequestIfPendingForEndReceive(COldRemoteRead* pRemoteReadRequest);

private:
	HRESULT BindRemoteQMService();

private:
	ULONG m_srv_hACQueue;
	ULONG m_srv_pQMQueue;

    PCTX_RRSESSION_HANDLE_TYPE m_pRRContext;

	//
	// Version of the remote QM. For remote QM of version that does not
	// support latest remote read interface these fields are zero.
	//
	UCHAR  m_RemoteQmMajorVersion;
	UCHAR  m_RemoteQmMinorVersion;
	USHORT m_RemoteQmBuildNumber;

    //
    // Pending EndReceive related members.
    //
	LONG m_EndReceiveCnt;
    CCriticalSection m_PendingEndReceiveCS;
	std::vector<COldRemoteRead*> m_PendingEndReceive;

	//
	// Flag that indicate if the handle is valid for Receive.
	// When EndReceive fails, we invalidate the handle for further receives.
	// This is better than accumulating messages on the server because EndReceive failures.
	//
	bool m_fHandleValidForReceive;
};


//---------------------------------------------------------
//
//  CNewRRQueue - New Remote Read interface RRQueue
//
//---------------------------------------------------------

class CNewRRQueue : public CBaseRRQueue
{
public:
	CNewRRQueue(
		IN const QUEUE_FORMAT* pQueueFormat,
		IN PQueueProps pQueueProp,
		IN handle_t	hBind,
	    IN RemoteReadContextHandleExclusive pNewRemoteReadContext
		);

protected:
	virtual ~CNewRRQueue();

public:

	virtual CNewRemoteRead* CreateRemoteReadRequest(CACRequest* pRequest);

	virtual CNewRemoteCloseQueue* CreateCloseRRContextRequest();

	virtual CNewRemoteCreateCursor* CreateRemoteCreateCursorRequest(CACRequest* pRequest);

	virtual CNewRemoteCloseCursor* CreateRemoteCloseCursorRequest(CACRequest* pRequest);

	virtual CNewRemotePurgeQueue* CreateRemotePurgeQueueRequest();

	virtual CNewRemoteCancelRead* CreateRemoteCancelReadRequest(CACRequest* pRequest);


    virtual RemoteReadContextHandleShared GetRRContext()
    {
    	return m_pNewRemoteReadContext;
    }


    virtual void ResetRRContext()
    {
    	m_pNewRemoteReadContext = NULL;
    }

    virtual void DestroyClientRRContext()
    {
    	RpcSsDestroyClientContext(&m_pNewRemoteReadContext);
    }

	virtual void IncrementEndReceiveCnt()
	{
		return;
	}

	virtual void DecrementEndReceiveCnt()
	{
		return;
	}

	virtual void InvalidateHandleForReceive()
	{
		return;
	}

private:
	void CreateReadBind();
	
private:
    RemoteReadContextHandleShared m_pNewRemoteReadContext;
};

//
// Inline functions of CBaseQueue
//

/*======================================================

Function:        CBaseQueue::GetQueueName

Description:     Returns the name of the queue

Arguments:       None

Return Value:    Returns the name of the queue

Thread Context:

History Change:

========================================================*/
inline LPCTSTR
CBaseQueue::GetQueueName(void) const
{
    return(m_qName);
}



/*======================================================

Function:        CBaseQueue::IsLocalQueue

Description:     Returns if the queue is local queue (open for receive
                 and not FRS queue) or not.

Arguments:       None

Return Value:    TRUE, if the queue is local queue. FALSE otherwise

Thread Context:

History Change:

========================================================*/

inline BOOL
CBaseQueue::IsLocalQueue(void) const
{
   return(m_fLocalQueue);
}

/*======================================================

Function:        CBaseQueue::IsRemoteProxy

Description:     Returns if the queue is local queue (open for receive
                 and not FRS queue) or not.

Arguments:       None

Return Value:    TRUE, if the queue is local queue. FALSE otherwise

Thread Context:

History Change:

========================================================*/

inline BOOL
CBaseQueue::IsRemoteProxy(void) const
{
   return(m_fRemoteProxy) ;
}

/*======================================================

Function:        CBaseQueue::IsDSQueue

========================================================*/

inline BOOL
CBaseQueue::IsDSQueue(void) const
{
   return (m_qid.pguidQueue && (m_qid.dwPrivateQueueId == 0));
}

/*======================================================

Function:        CBaseQueue::IsPrivateQueue

========================================================*/

inline BOOL
CBaseQueue::IsPrivateQueue(void) const
{
   return (m_qid.pguidQueue && (m_qid.dwPrivateQueueId != 0));
}


inline BOOL CBaseQueue::IsSystemQueue(void) const
{
    return m_fSystemQueue;
}

/*======================================================

Function:        CBaseQueue::GetQueueGuid

Description:     Returns the guid of the queue

Arguments:       None

Return Value:    Returns the guid of the queue

Thread Context:

History Change:

========================================================*/

inline const GUID *
CBaseQueue::GetQueueGuid(void) const
{
        return(m_qid.pguidQueue);
}

/*======================================================

Function:        CBaseQueue::SetQueueGuid

Description:     Set the guid of the queue

Arguments:       None

Thread Context:

History Change:

========================================================*/

inline void
CBaseQueue::SetQueueGuid(GUID *pGuid)
{
   if (m_qid.pguidQueue)
   {
      delete m_qid.pguidQueue ;
   }
   m_qid.pguidQueue = pGuid ;
}

/*======================================================

Function:        CBaseQueue::GetQueueId

Description:     Returns the id of the queue

========================================================*/
inline const QUEUE_ID* CBaseQueue::GetQueueId(void)
{
        return(&m_qid);
}

/*======================================================

Function:        CBaseQueue::NullQueueName

Description:     Returns the name of the queue

Arguments:       None

Return Value:    Returns the name of the queue

Thread Context:

History Change:

========================================================*/

inline void
CBaseQueue::SetQueueName(LPTSTR pName)
{
   delete [] m_qName;

   m_qName = pName ;
}

//*******************************************************************
//
// Inline functions of CQueue
//
//*******************************************************************

 //++
 // Function: CQueue::GetQueueHandle
 //
 // Synopsis: The function returns the queue handle
 //
 //--

inline HANDLE
CQueue::GetQueueHandle(void) const
{
    ASSERT(this);
   return(m_hQueue);
}

 //++
 // Function: CQueue::SetQueueHandle
 //
 // Synopsis: The function set the queue handle
 //
 // Arguments:       hQueue - Handle to a queue
 //
 //--

inline void
CQueue::SetQueueHandle(IN HANDLE hQueue)
{
   m_hQueue = hQueue;
}

/*======================================================

Function:        CQueue::GetGroupHandle

Description:     The function returns the handle of the group that the queue belongs

Arguments:       None

Return Value:    Handle of the group

Thread Context:

History Change:

========================================================*/
inline HANDLE
CQueue::GetGroupHandle(void) const
{
    return(m_pSession->GetGroupHandle());
}

/*======================================================

Function:        CQueue::SetSessionPtr

Description:     The function set the  Session that the queue belongs

========================================================*/
inline void
CQueue::SetSessionPtr(CTransportBase* pSession)
{
    CS lock(m_cs);

    m_pSession = pSession;

    //
    // If the Queue is connected to new session but the queue is mark
    // as onhold queue, disconnect the session. This can happen when the
    // connection process began before the queue move to onhold and
    // completed after
    //
    if ((m_pSession != NULL) && IsOnHold())
    {
        m_pSession->Disconnect();
    }
}

//+-------------------------------------------------------------------------
//
//  inline BOOL CQueue::IsConnected(void) const
//
//  bug 4342.
//  stop reciving transactional messages because of failure to access the
//  DS.  The receiver, sender and DS are on line and sending/receiving
//  messages. At some time the DS goes down, as a result the receiver stop
//  sending order acks and the sender stop sending a newer messages.
//  This bug caused since the "sender order ack" queue is cleaned-up. when
//  the receiver try to send a new order ack, the QM tries to open the queue
//  but failed due "ERROR_NO_DS". The QM moves the queue to "need validate"
//  group and wait until the DS will be  on line.
//  First fix- Release queue object only if there is no an active session.
//
//  This caused regression, because if session never close (there is a lot
//  of traffic between the machines) then queues will never be cleaned up.
//  This is exactly what happen at upgraded PEC. Because of replication and
//  hello traffic, there are many permanent sessions with BSCs and PSCs.
//  Second fix- Apply first fix only to system queues, not to users queues.
//
//+-------------------------------------------------------------------------

inline BOOL CQueue::IsConnected(void) const
{
    BOOL fIsConnected = (m_pSession != NULL) && IsSystemQueue() ;
    return fIsConnected ;
}


/*======================================================

Function:        CQueue::SetGroup

Description:     The function set the  Group that the queue belongs

========================================================*/
inline void
CQueue::SetGroup(CQGroup* pGroup)
{
    m_pGroup = pGroup;
}


/*======================================================

Function:        CQueue::SetGroup

Description:     The function set the  Group that the queue belongs

========================================================*/
inline CQGroup*
CQueue::GetGroup(void) const
{
    return m_pGroup;
}


/*======================================================

Function:        CQueue::GetQueueType

Description:

Arguments:

Return Value:

========================================================*/
inline DWORD
CQueue::GetQueueType(void) const
{
    return m_dwQueueType;
}

/*======================================================

Function:        CQueue::GetPrivateQueueId

Description:

Arguments:

Return Value:

========================================================*/
inline DWORD
CQueue::GetPrivateQueueId(void) const
{
    return m_qid.dwPrivateQueueId;
};

/*======================================================

Function:        CQueue::GetMachineQMGuid

Description:

Arguments:

Return Value:

========================================================*/
inline const GUID*
CQueue::GetMachineQMGuid(void) const
{
    return m_pguidDstMachine;
}

/*======================================================

Function:        CQueue::SetSecurityDescriptor

Description:

========================================================*/
inline void
CQueue::SetSecurityDescriptor(const PSECURITY_DESCRIPTOR pSD)
{
	CQueueSecurityDescriptor* NewSD = new CQueueSecurityDescriptor(pSD);
    CS lock(m_csSecurityDescriptor);
	m_pSecurityDescriptorObject = NewSD;
}


/*======================================================

Function:        CQueue::GetSecurityDescriptor

Description:

Arguments:

Return Value:

========================================================*/
inline R<CQueueSecurityDescriptor>
CQueue::GetSecurityDescriptor(void ) const
{
    CS lock(m_csSecurityDescriptor);
    ASSERT (m_pSecurityDescriptorObject.get() != NULL);
	return m_pSecurityDescriptorObject;
}

inline void
CQueue::SetJournalQueue(BOOL f)
{
    m_fJournalQueue = f ? 1 : 0;
}

inline BOOL
CQueue::IsJournalQueue(void) const
{
    return m_fJournalQueue;
}

inline void
CQueue::SetQueueQuota(DWORD dwQuota)
{
    m_dwQuota = dwQuota;
}

inline BOOL
CQueue::IsTransactionalQueue(void) const
{
    return m_fTransactedQueue;
}

inline void
CQueue::SetTransactionalQueue(BOOL f)
{
    m_fTransactedQueue = f ? 1 : 0;
}

inline void
CQueue::SetAuthenticationFlag(BOOL fAuthntication)
{
    m_fAuthenticate = fAuthntication;
}

inline BOOL
CQueue::ShouldMessagesBeSigned(void) const
{
    return m_fAuthenticate;
}

inline void
CQueue::SetPrivLevel(DWORD dwPrivLevel)
{
    m_dwPrivLevel = dwPrivLevel;
}

inline DWORD
CQueue::GetPrivLevel(void) const
{
    return m_dwPrivLevel;
}

inline BOOL
CQueue::IsConnectorQueue(void) const
{
    return m_fConnectorQueue;
}

inline BOOL
CQueue::IsForeign(void) const
{
    return m_fForeign;
}

inline DWORD
CQueue::GetQueueQuota(void) const
{
    return m_dwQuota;
}

inline void
CQueue::SetJournalQueueQuota(DWORD dwJournalQuota)
{
    m_dwJournalQuota = dwJournalQuota;
}

inline DWORD
CQueue::GetJournalQueueQuota(void) const
{
    return m_dwJournalQuota;
}

inline void
CQueue::SetBaseQueuePriority(LONG lBasePriority)
{
    m_lBasePriority = lBasePriority;
}

inline LONG
CQueue::GetBaseQueuePriority(void) const
{
    return m_lBasePriority;
}

inline void
CQueue::ClearRoutingRetry(void)
{
    m_dwRoutingRetry=0;
}

inline void
CQueue::IncRoutingRetry(void)
{
    m_dwRoutingRetry++;
}

inline DWORD
CQueue::GetRoutingRetry(void) const
{
    return m_dwRoutingRetry;
}

inline void
CQueue::SetHopCountFailure(BOOL flag)
{
    m_fHopCountFailure=flag;
}

inline BOOL
CQueue::IsHopCountFailure(void) const
{
    return(m_fHopCountFailure);
}

inline
QueueCounters*
CQueue::GetQueueCounters()
{
    return(m_pQueueCounters);
}

inline void
CQueue::UnknownQueueType(BOOL f)
{
    m_fUnknownQueueType = f;
}

inline BOOL
CQueue::IsUnkownQueueType() const
{
   return m_fUnknownQueueType; ;
}

inline BOOL
CQueue::QueueNotValid() const
{
   return m_fNotValid ;
}

inline const GUID*
CQueue::GetConnectorQM(void) const
{
    return m_pgConnectorQM;
}

inline
BOOL
CQueue::IsOnHold(
    void
    ) const
{
    return m_fOnHold;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\depclient.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DepClient.cpp

Abstract:

    Server side support for MSMQ 1.0 and 2.0 dependent clients.

Author:

    Shai Kariv  (shaik)  15-May-2000

--*/

#include "stdh.h"

#include "ds.h"
#include "cqueue.h"
#include "cqmgr.h"
#include "_rstrct.h"
#include "qmds.h"
#include "cqpriv.h"
#include "qm2qm.h"
#include "qmrt.h"
#include "_mqini.h"
#include "_mqrpc.h"
#include "qmthrd.h"
#include "license.h"
#include "version.h"
#include <mqsec.h>
#include "rpcsrv.h"
#include "Fn.h"
#include "qmcommnd.h"
#include "qmrtopen.h"
#include "qmrpcsrv.h"

#include <strsafe.h>

#include "DepClient.tmh"

extern CContextMap g_map_QM_dwQMContext;


static WCHAR *s_FN=L"DepClient";



static
VOID
TransferBufferV1ToMsgProps(
    const CACTransferBufferV1 * ptb1,
    CACMessageProperties      * pMsgProps
    )
/*++

Routine Description:

    Maps MSMQ 1.0 transfer buffer to CACMessageProperties structure.

Arguments:

    ptb1      - Pointer to MSMQ 1.0 transfer buffer.

    pMsgProps - Pointer to message properties structure.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    pMsgProps->bAuthenticated   = ptb1->bAuthenticated;
    pMsgProps->bEncrypted       = ptb1->bEncrypted;
    pMsgProps->fDefaultProvider = ptb1->fDefaultProvider;
    pMsgProps->pAcknowledge     = ptb1->pAcknowledge;
    pMsgProps->pApplicationTag  = ptb1->pApplicationTag;
    pMsgProps->pArrivedTime     = ptb1->pArrivedTime;
    pMsgProps->pAuditing        = ptb1->pAuditing;
    pMsgProps->pAuthenticated   = ptb1->pAuthenticated;
    pMsgProps->pBodySize        = ptb1->pBodySize;
    pMsgProps->pClass           = ptb1->pClass;
    pMsgProps->pDelivery        = ptb1->pDelivery;
    pMsgProps->pMsgExtensionSize= ptb1->pMsgExtensionSize;
    pMsgProps->ppBody           = ptb1->ppBody;
    pMsgProps->ppConnectorType  = ptb1->ppConnectorType;
    pMsgProps->ppCorrelationID  = ptb1->ppCorrelationID;
    pMsgProps->ppMessageID      = ptb1->ppMessageID;
    pMsgProps->ppMsgExtension   = ptb1->ppMsgExtension;
    pMsgProps->pPriority        = ptb1->pPriority;
    pMsgProps->ppSenderCert     = ptb1->ppSenderCert;
    pMsgProps->ppSenderID       = ptb1->ppSenderID;
    pMsgProps->ppSignature      = ptb1->ppSignature;
    pMsgProps->pulSignatureSizeProp = ptb1->pulSignatureSizeProp;
    pMsgProps->ulSignatureSize  = ptb1->ulSignatureSize;
    pMsgProps->ppSrcQMID        = ptb1->ppSrcQMID;
    pMsgProps->ppSymmKeys       = ptb1->ppSymmKeys;
    pMsgProps->ppTitle          = ptb1->ppTitle;
    pMsgProps->ppwcsProvName    = ptb1->ppwcsProvName;
    pMsgProps->pSentTime        = ptb1->pSentTime;
    pMsgProps->pTrace           = ptb1->pTrace;
    pMsgProps->pulAuthProvNameLenProp = ptb1->pulAuthProvNameLenProp;
    pMsgProps->pulBodyType      = ptb1->pulBodyType;
    pMsgProps->pulEncryptAlg    = ptb1->pulEncryptAlg;
    pMsgProps->pulHashAlg       = ptb1->pulHashAlg;
    pMsgProps->pulPrivLevel     = ptb1->pulPrivLevel;
    pMsgProps->pulProvType      = ptb1->pulProvType;
    pMsgProps->pulRelativeTimeToLive = ptb1->pulRelativeTimeToLive;
    pMsgProps->pulRelativeTimeToQueue= ptb1->pulRelativeTimeToQueue;
    pMsgProps->pulSenderCertLenProp  = ptb1->pulSenderCertLenProp;
    pMsgProps->pulSenderIDLenProp= ptb1->pulSenderIDLenProp;
    pMsgProps->pulSenderIDType   = ptb1->pulSenderIDType;
    pMsgProps->pulSymmKeysSizeProp  = ptb1->pulSymmKeysSizeProp;
    pMsgProps->pulTitleBufferSizeInWCHARs = ptb1->pulTitleBufferSizeInWCHARs;
    pMsgProps->pulVersion        = ptb1->pulVersion;
    pMsgProps->pUow              = ptb1->pUow;
    pMsgProps->ulAbsoluteTimeToQueue = ptb1->ulAbsoluteTimeToQueue;
    pMsgProps->ulAllocBodyBufferInBytes = ptb1->ulAllocBodyBufferInBytes;
    pMsgProps->ulAuthLevel       = ptb1->ulAuthLevel;
    pMsgProps->ulBodyBufferSizeInBytes = ptb1->ulBodyBufferSizeInBytes;
    pMsgProps->ulMsgExtensionBufferInBytes = ptb1->ulMsgExtensionBufferInBytes;
    pMsgProps->ulProvNameLen     = ptb1->ulProvNameLen;
    pMsgProps->ulRelativeTimeToLive = ptb1->ulRelativeTimeToLive;
    pMsgProps->ulSenderCertLen   = ptb1->ulSenderCertLen;
    pMsgProps->ulSymmKeysSize    = ptb1->ulSymmKeysSize;
    pMsgProps->ulTitleBufferSizeInWCHARs = ptb1->ulTitleBufferSizeInWCHARs;
    pMsgProps->uSenderIDLen      = ptb1->uSenderIDLen;

    //
    // Properties in CACMessageProperties that are not included in
    // transfer buffer V1.0 should be initialized here (e.g. zeroed):
    //
    pMsgProps->pbFirstInXact = 0;
    pMsgProps->pbLastInXact  = 0;
    pMsgProps->ppXactID      = 0;

    pMsgProps->pLookupId     = 0;
    pMsgProps->ppSrmpEnvelope = NULL;
    pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs = NULL;
    pMsgProps->ppCompoundMessage = NULL;
    pMsgProps->pCompoundMessageSizeInBytes = NULL;
    pMsgProps->CompoundMessageSizeInBytes = 0;

    pMsgProps->EodStreamIdSizeInBytes = 0;
    pMsgProps->pEodStreamIdSizeInBytes = NULL;
    pMsgProps->ppEodStreamId = NULL;
    pMsgProps->EodOrderQueueSizeInBytes = 0;
    pMsgProps->pEodOrderQueueSizeInBytes = NULL;
    pMsgProps->ppEodOrderQueue = NULL;

    pMsgProps->pEodAckSeqId = NULL;
    pMsgProps->pEodAckSeqNum = NULL;
    pMsgProps->EodAckStreamIdSizeInBytes = 0;
    pMsgProps->pEodAckStreamIdSizeInBytes = NULL;
    pMsgProps->ppEodAckStreamId = NULL;

} // TransferBufferV1ToMsgProps


static
VOID
TransferBufferV2ToMsgProps(
    const CACTransferBufferV2 * ptb2,
    CACMessageProperties      * pMsgProps
    )
/*++

Routine Description:

    Maps MSMQ 2.0 transfer buffer to CACMessageProperties structure.

Arguments:

    ptb2      - Pointer to MSMQ 2.0 transfer buffer.

    pMsgProps - Pointer to message properties structure.

Returned Value:

    None.

--*/
{
    //
    // First translate message properties that in transfer buffer 1.0
    //
    TransferBufferV1ToMsgProps(&ptb2->old, pMsgProps);

    //
    // Now translate additional properties that in transfer buffer 2.0
    //
    pMsgProps->pbFirstInXact    = ptb2->pbFirstInXact;
    pMsgProps->pbLastInXact     = ptb2->pbLastInXact;
    pMsgProps->ppXactID         = ptb2->ppXactID;

} // TransferBufferV2ToMsgProps


static
VOID
MsgPropsToTransferBufferV1(
    const CACMessageProperties & MsgProps,
    CACTransferBufferV1 *        ptb1
    )
/*++

Routine Description:

    Maps CACMessageProperties structure to MSMQ 1.0 transfer buffer

Arguments:

    MsgProps  - Message properties structure.

    ptb1      - Pointer to MSMQ 1.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    ptb1->bAuthenticated    = MsgProps.bAuthenticated;
    ptb1->bEncrypted        = MsgProps.bEncrypted;
    ptb1->fDefaultProvider  = MsgProps.fDefaultProvider;
    ptb1->pAcknowledge      = MsgProps.pAcknowledge;
    ptb1->pApplicationTag   = MsgProps.pApplicationTag;
    ptb1->pArrivedTime      = MsgProps.pArrivedTime;
    ptb1->pAuditing         = MsgProps.pAuditing;
    ptb1->pAuthenticated    = MsgProps.pAuthenticated;
    ptb1->pBodySize         = MsgProps.pBodySize;
    ptb1->pClass            = MsgProps.pClass;
    ptb1->pDelivery         = MsgProps.pDelivery;
    ptb1->pMsgExtensionSize = MsgProps.pMsgExtensionSize;
    ptb1->ppBody            = MsgProps.ppBody;
    ptb1->ppConnectorType   = MsgProps.ppConnectorType;
    ptb1->ppCorrelationID   = MsgProps.ppCorrelationID;
    ptb1->ppMessageID       = MsgProps.ppMessageID;
    ptb1->ppMsgExtension    = MsgProps.ppMsgExtension;
    ptb1->pPriority         = MsgProps.pPriority;
    ptb1->ppSenderCert      = MsgProps.ppSenderCert;
    ptb1->ppSenderID        = MsgProps.ppSenderID;
    ptb1->ppSignature       = MsgProps.ppSignature;
    ptb1->pulSignatureSizeProp  = MsgProps.pulSignatureSizeProp;
    ptb1->ulSignatureSize       = MsgProps.ulSignatureSize;
    ptb1->ppSrcQMID         = MsgProps.ppSrcQMID;
    ptb1->ppSymmKeys        = MsgProps.ppSymmKeys;
    ptb1->ppTitle           = MsgProps.ppTitle;
    ptb1->ppwcsProvName     = MsgProps.ppwcsProvName;
    ptb1->pSentTime         = MsgProps.pSentTime;
    ptb1->pTrace            = MsgProps.pTrace;
    ptb1->pulAuthProvNameLenProp = MsgProps.pulAuthProvNameLenProp;
    ptb1->pulBodyType       = MsgProps.pulBodyType;
    ptb1->pulEncryptAlg     = MsgProps.pulEncryptAlg;
    ptb1->pulHashAlg        = MsgProps.pulHashAlg;
    ptb1->pulPrivLevel      = MsgProps.pulPrivLevel;
    ptb1->pulProvType       = MsgProps.pulProvType;
    ptb1->pulRelativeTimeToLive = MsgProps.pulRelativeTimeToLive;
    ptb1->pulRelativeTimeToQueue= MsgProps.pulRelativeTimeToQueue;
    ptb1->pulSenderCertLenProp  = MsgProps.pulSenderCertLenProp;
    ptb1->pulSenderIDLenProp    = MsgProps.pulSenderIDLenProp;
    ptb1->pulSenderIDType       = MsgProps.pulSenderIDType;
    ptb1->pulSymmKeysSizeProp   = MsgProps.pulSymmKeysSizeProp;
    ptb1->pulTitleBufferSizeInWCHARs = MsgProps.pulTitleBufferSizeInWCHARs;
    ptb1->pulVersion            = MsgProps.pulVersion;
    ptb1->pUow                  = MsgProps.pUow;
    ptb1->ulAbsoluteTimeToQueue = MsgProps.ulAbsoluteTimeToQueue;
    ptb1->ulAllocBodyBufferInBytes = MsgProps.ulAllocBodyBufferInBytes;
    ptb1->ulAuthLevel           = MsgProps.ulAuthLevel;
    ptb1->ulBodyBufferSizeInBytes  = MsgProps.ulBodyBufferSizeInBytes;
    ptb1->ulMsgExtensionBufferInBytes = MsgProps.ulMsgExtensionBufferInBytes;
    ptb1->ulProvNameLen         = MsgProps.ulProvNameLen;
    ptb1->ulRelativeTimeToLive  = MsgProps.ulRelativeTimeToLive;
    ptb1->ulSenderCertLen       = MsgProps.ulSenderCertLen;
    ptb1->ulSymmKeysSize        = MsgProps.ulSymmKeysSize;
    ptb1->ulTitleBufferSizeInWCHARs = MsgProps.ulTitleBufferSizeInWCHARs;
    ptb1->uSenderIDLen          = MsgProps.uSenderIDLen;

    //
    // Properties that are not included in transfer buffer 1.0 / 2.0
    //
    ASSERT(MsgProps.pLookupId == 0);
    ASSERT(MsgProps.ppSrmpEnvelope == NULL);
    ASSERT(MsgProps.pSrmpEnvelopeBufferSizeInWCHARs == NULL);
    ASSERT(MsgProps.ppCompoundMessage == NULL);
    ASSERT(MsgProps.pCompoundMessageSizeInBytes == NULL);
    ASSERT(MsgProps.CompoundMessageSizeInBytes == 0);
    ASSERT(MsgProps.EodStreamIdSizeInBytes == 0);
    ASSERT(MsgProps.pEodStreamIdSizeInBytes == NULL);
    ASSERT(MsgProps.ppEodStreamId == NULL);
    ASSERT(MsgProps.EodOrderQueueSizeInBytes == 0);
    ASSERT(MsgProps.pEodOrderQueueSizeInBytes == NULL);
    ASSERT(MsgProps.ppEodOrderQueue == NULL);
    ASSERT(MsgProps.pEodAckSeqId == NULL);
    ASSERT(MsgProps.pEodAckSeqNum == NULL);
    ASSERT(MsgProps.EodAckStreamIdSizeInBytes == 0);
    ASSERT(MsgProps.pEodAckStreamIdSizeInBytes == NULL);
    ASSERT(MsgProps.ppEodAckStreamId == NULL);

} // MsgPropsToTransferBufferV1


static
VOID
MsgPropsToTransferBufferV2(
    const CACMessageProperties & MsgProps,
    CACTransferBufferV2 *        ptb2
    )
/*++

Routine Description:

    Maps CACMessageProperties structure to MSMQ 2.0 transfer buffer

Arguments:

    MsgProps  - Message properties structure.

    ptb2      - Pointer to MSMQ 2.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // First translate message properties that in transfer buffer 1.0
    //
    MsgPropsToTransferBufferV1(MsgProps, &ptb2->old);

    //
    // Now translate additional properties that in transfer buffer 2.0
    //
    ptb2->pbFirstInXact         = MsgProps.pbFirstInXact;
    ptb2->pbLastInXact          = MsgProps.pbLastInXact;
    ptb2->ppXactID              = MsgProps.ppXactID;

} // MsgPropsToTransferBufferV2


static
VOID
TransferBufferV1ToSendParams(
    const CACTransferBufferV1 * ptb1,
    CACSendParameters         * pSendParams
    )
/*++

Routine Description:

    Maps MSMQ 1.0 transfer buffer to CACSendParameters structure.

Arguments:

    ptb1        - Pointer to MSMQ 1.0 transfer buffer.

    pSendParams - Pointer to send parameters structure.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    TransferBufferV1ToMsgProps(ptb1, &pSendParams->MsgProps);

    pSendParams->nAdminMqf = 0;
    pSendParams->nResponseMqf = 0;

    if (ptb1->Send.pAdminQueueFormat != NULL)
    {
        pSendParams->AdminMqf = ptb1->Send.pAdminQueueFormat;
        pSendParams->nAdminMqf = 1;
    }

    if (ptb1->Send.pResponseQueueFormat != NULL)
    {
        pSendParams->ResponseMqf = ptb1->Send.pResponseQueueFormat;
        pSendParams->nResponseMqf = 1;
    }

    //
    // Additional send parameters that are not in transfer buffer 1.0
    // should be initialized here (e.g. zeroed):
    //
    pSendParams->SignatureMqfSize = 0;
	pSendParams->ppSignatureMqf = NULL;

	pSendParams->ulXmldsigSize = 0;
	pSendParams->ppXmldsig = NULL;

    pSendParams->ppSoapHeader = NULL;
    pSendParams->ppSoapBody = NULL;

} // TransferBufferV1ToSendParams


static
VOID
TransferBufferV2ToSendParams(
    const CACTransferBufferV2 * ptb2,
    CACSendParameters         * pSendParams
    )
/*++

Routine Description:

    Maps MSMQ 2.0 transfer buffer to CACSendParameters structure.

Arguments:

    ptb2        - Pointer to MSMQ 2.0 transfer buffer.

    pSendParams - Pointer to send parameters structure.

Returned Value:

    None.

--*/
{
    //
    // First translate parameters that in transfer buffer 1.0
    //
    TransferBufferV1ToSendParams(&ptb2->old, pSendParams);

    //
    // Now translate additional send parameters that in transfer buffer 2.0.
    // Actually there are no additional send parameters in transfer buffer 2.0,
    // but rather message properties
    //
    TransferBufferV2ToMsgProps(ptb2, &pSendParams->MsgProps);

    //
    // Additional send parameters that are not in transfer buffer 2.0
    // should be initialized here (e.g. zeroed):
    //
    NULL;

} // TransferBufferV2ToSendParams


static
VOID
TransferBufferV1ToReceiveParams(
    const CACTransferBufferV1 * ptb1,
    CACReceiveParameters      * pReceiveParams
    )
/*++

Routine Description:

    Maps MSMQ 1.0 transfer buffer to CACReceiveParameters structure.

Arguments:

    ptb1           - Pointer to MSMQ 1.0 transfer buffer.

    pReceiveParams - Pointer to receive parameters structure.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    TransferBufferV1ToMsgProps(ptb1, &pReceiveParams->MsgProps);

#ifdef _WIN64
    pReceiveParams->Cursor         = ptb1->Receive.Cursor;
#else
    pReceiveParams->Cursor         = reinterpret_cast<HANDLE>(ptb1->Receive.Cursor);
#endif

    pReceiveParams->RequestTimeout = ptb1->Receive.RequestTimeout;
    pReceiveParams->Action         = ptb1->Receive.Action;
    pReceiveParams->Asynchronous   = ptb1->Receive.Asynchronous;

    pReceiveParams->ppDestFormatName             = ptb1->Receive.ppDestFormatName;
    pReceiveParams->pulDestFormatNameLenProp     = ptb1->Receive.pulDestFormatNameLenProp;

    pReceiveParams->ppAdminFormatName            = ptb1->Receive.ppAdminFormatName;
    pReceiveParams->pulAdminFormatNameLenProp    = ptb1->Receive.pulAdminFormatNameLenProp;

    pReceiveParams->ppResponseFormatName         = ptb1->Receive.ppResponseFormatName;
    pReceiveParams->pulResponseFormatNameLenProp = ptb1->Receive.pulResponseFormatNameLenProp;

    pReceiveParams->ppOrderingFormatName         = ptb1->Receive.ppOrderingFormatName;
    pReceiveParams->pulOrderingFormatNameLenProp = ptb1->Receive.pulOrderingFormatNameLenProp;

    //
    // Additional receive parameters that are not in transfer buffer 1.0
    // should be initialized here (e.g. zeroed):
    //

    pReceiveParams->ppDestMqf    = NULL;
    pReceiveParams->pulDestMqfLenProp = NULL;

    pReceiveParams->ppAdminMqf    = NULL;
    pReceiveParams->pulAdminMqfLenProp = NULL;

    pReceiveParams->ppResponseMqf    = NULL;
    pReceiveParams->pulResponseMqfLenProp = NULL;

	pReceiveParams->SignatureMqfSize = 0;
	pReceiveParams->ppSignatureMqf = NULL;
	pReceiveParams->pSignatureMqfSize = NULL;

    pReceiveParams->LookupId = 0;

} // TransferBufferV1ToReceiveParams


static
VOID
TransferBufferV2ToReceiveParams(
    const CACTransferBufferV2 * ptb2,
    CACReceiveParameters      * pReceiveParams
    )
/*++

Routine Description:

    Maps MSMQ 2.0 transfer buffer to CACReceiveParameters structure.

Arguments:

    ptb2           - Pointer to MSMQ 2.0 transfer buffer.

    pReceiveParams - Pointer to receive parameters structure.

Returned Value:

    None.

--*/
{
    //
    // First translate parameters that in transfer buffer 1.0
    //
    TransferBufferV1ToReceiveParams(&ptb2->old, pReceiveParams);

    //
    // Now translate additional recieve parameters that in transfer buffer 2.0.
    // Actually there are no additional receive parameters in transfer buffer 2.0,
    // but rather message properties
    //
    TransferBufferV2ToMsgProps(ptb2, &pReceiveParams->MsgProps);

} // TransferBufferV2ToReceiveParams


static
VOID
ReceiveParamsToTransferBufferV1(
    const CACReceiveParameters & ReceiveParams,
    CACTransferBufferV1 *        ptb1
    )
/*++

Routine Description:

    Maps CACReceiveParameters structure to MSMQ 1.0 transfer buffer.

Arguments:

    ReceiveParams  - Receive parameters structure.

    ptb1           - Pointer to MSMQ 1.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    MsgPropsToTransferBufferV1(ReceiveParams.MsgProps, ptb1);

#ifdef _WIN64
    ptb1->Receive.Cursor         = ReceiveParams.Cursor;
#else
    ptb1->Receive.Cursor         = (ULONG)ReceiveParams.Cursor;
#endif

    ptb1->Receive.RequestTimeout = ReceiveParams.RequestTimeout;
    ptb1->Receive.Action         = ReceiveParams.Action;
    ptb1->Receive.Asynchronous   = ReceiveParams.Asynchronous;

    ptb1->Receive.ppDestFormatName    = ReceiveParams.ppDestFormatName;
    ptb1->Receive.pulDestFormatNameLenProp = ReceiveParams.pulDestFormatNameLenProp;

    ptb1->Receive.ppAdminFormatName    = ReceiveParams.ppAdminFormatName;
    ptb1->Receive.pulAdminFormatNameLenProp = ReceiveParams.pulAdminFormatNameLenProp;

    ptb1->Receive.ppResponseFormatName    = ReceiveParams.ppResponseFormatName;
    ptb1->Receive.pulResponseFormatNameLenProp = ReceiveParams.pulResponseFormatNameLenProp;

    ptb1->Receive.ppOrderingFormatName    = ReceiveParams.ppOrderingFormatName;
    ptb1->Receive.pulOrderingFormatNameLenProp = ReceiveParams.pulOrderingFormatNameLenProp;

    //
    // Properties that are not included in transfer buffer 1.0 / 2.0
    //
    ASSERT(ReceiveParams.LookupId == 0);
	ASSERT(ReceiveParams.SignatureMqfSize == 0);
	ASSERT(ReceiveParams.pSignatureMqfSize == NULL);
	ASSERT(ReceiveParams.ppSignatureMqf == NULL);

} // ReceiveParamsToTransferBufferV1


static
VOID
ReceiveParamsToTransferBufferV2(
    const CACReceiveParameters & ReceiveParams,
    CACTransferBufferV2 *        ptb2
    )
/*++

Routine Description:

    Maps CACReceiveParameters structure to MSMQ 2.0 transfer buffer.

Arguments:

    ReceiveParams  - Receive parameters structure.

    ptb2           - Pointer to MSMQ 2.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // First translate receive parameters that in transfer buffer 1.0
    //
    ReceiveParamsToTransferBufferV1(ReceiveParams, &ptb2->old);

    //
    // Now translate additional receive parameters that in transfer buffer 2.0.
    // Actually there are no additional receive parameters in transfer buffer 2.0,
    // but rather message properties.
    //
    MsgPropsToTransferBufferV2(ReceiveParams.MsgProps, ptb2);

} // ReceiveParamsToTransferBufferV2


//---------------------------------------------------------
//
//  RT interface to AC, done indirectly by RPC to QM (rather than
//  directly calling the driver).
//  For Win95 (all configurations) and NT dependent clients.
//
//---------------------------------------------------------

//
// This is the context for the RPC. Upon rundown (or normal call to
// CloseQueue), the queue handle is closed and the reference count of the
// license is decremented.
//
struct RPC_QUEUE_CONTEXT : public CBaseContextType
{
	HANDLE   hQueue ;
	GUID     LicGuid ;
	DWORD    dwQMContextMapped;
};


#define  _CONTEXT_TO_HANDLE(pContext) \
                    (((RPC_QUEUE_CONTEXT*)pContext)->hQueue)

#define  _CONTEXT_TO_LICENSE(pContext) \
                    (((RPC_QUEUE_CONTEXT*)pContext)->LicGuid)

#define  _CONTEXT_TO_QM_CONTEXT_MAPPED(pContext) \
                    (((RPC_QUEUE_CONTEXT*)pContext)->dwQMContextMapped)

/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_QMOpenQueueInternal(
    /* [in] */ handle_t                     hBind,
    /* [in] */ QUEUE_FORMAT*                pQueueFormat,
    /* [in] */ DWORD                        dwDesiredAccess,
    /* [in] */ DWORD                        dwShareMode,
    /* [in] */ DWORD                        hRemoteQueue,
    /* [out][in] */ LPWSTR __RPC_FAR       *lplpRemoteQueueName,
    /* [in] */  DWORD __RPC_FAR             *dwpQueue,
    /* [in] */  GUID*                       pLicGuid,
    /* [in] */  LPWSTR                      lpClientName,
    /* [out] */ DWORD __RPC_FAR             *pdwQMContext,
    /* [out] */ RPC_QUEUE_HANDLE __RPC_FAR  *phQueue,
    /* [in]  */ DWORD                       /*dwRemoteProtocol*/,
    /* [in]  */ DWORD                       dwpRemoteContext
    )
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(hBind);

    if(pQueueFormat == NULL ||
       !FnIsValidQueueFormat(pQueueFormat) ||
       pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_CONNECTOR)
    {
         return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 177);
    }

    if((hRemoteQueue != 0) && ((dwpQueue == NULL) || (*dwpQueue == 0)))
    {
		//
		// Validate second remote read dependent client call.
		// When hRemoteQueue is supplied the client should also supply
		// valid dwpQueue value.
		//
		return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 178);
    }

    if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

    if (!g_QMLicense.IsClientRPCAccessAllowed(pLicGuid, lpClientName))
    {
        return LogHR(MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW, s_FN, 180);
    }

	if (!IsValidAccessMode(pQueueFormat, dwDesiredAccess, dwShareMode))
	{
		TrERROR(RPC, "Ilegal access mode bits are turned on.");
		RpcRaiseException(MQ_ERROR_UNSUPPORTED_ACCESS_MODE);
	}

	HRESULT hr;
    HANDLE hQueueHandle = 0;
	if (hRemoteQueue == 0)
    {
	     hr = OpenQueueInternal(
                    pQueueFormat,
                    GetCurrentProcessId(),
                    dwDesiredAccess,
                    dwShareMode,
                    lplpRemoteQueueName,
                    &hQueueHandle,
					true,	// 	fFromDepClient
                    NULL /* ppLocalQueue */
                    );
    }
    else
    {
        //
        // This is client side of remote read.
        // RTDEP calls here after it get handle to queue from remote computer.
		// This path is now supported only for dependent client
        //
		TrTRACE(RPC, "Dependent client second remote read call, hRemoteQueue = %d", hRemoteQueue);
		CBindHandle hBind;
		hr = QueueMgr.OpenRRQueue(
						pQueueFormat,
						GetCurrentProcessId(),
						dwDesiredAccess,
						dwShareMode,
						hRemoteQueue,
						*dwpQueue,
						dwpRemoteContext,
						NULL,	// pNewRemoteReadContextAndBind	
						hBind,	// hRemoteBind == NULL
						&hQueueHandle
						);
    }

    *phQueue = NULL;
    DWORD dwQMContext = NULL;
    if (SUCCEEDED(hr))
    {
		if (hQueueHandle == 0)
		{
			//	
			// First call for remote-read open.
			//
			TrTRACE(RPC, "Dependent client first remote read call, RemoteQueueName = %ls", *lplpRemoteQueueName);
			ASSERT(lplpRemoteQueueName && (*lplpRemoteQueueName != NULL));
		}
		else
		{
			P<RPC_QUEUE_CONTEXT> pContext =
			                   (RPC_QUEUE_CONTEXT *) new RPC_QUEUE_CONTEXT;
			memset(pContext, 0, sizeof(RPC_QUEUE_CONTEXT)) ;

			pContext->m_eType = CBaseContextType::eQueueCtx;
			pContext->hQueue = hQueueHandle;
			if (pLicGuid)
			{
				pContext->LicGuid = *pLicGuid;
			}
			dwQMContext = ADD_TO_CONTEXT_MAP(g_map_QM_dwQMContext, (RPC_QUEUE_CONTEXT*)pContext);

			pContext->dwQMContextMapped = dwQMContext;
			*phQueue = (RPC_QUEUE_HANDLE) pContext.detach();
		}
    }

    if (*phQueue == NULL)
    {
		//
		// Either Open operatoin failed or it is first call for
		// remote-read. Queue actually not opened.
		//
		g_QMLicense.DecrementActiveConnections(pLicGuid);
    }

    *pdwQMContext = dwQMContext;
    return LogHR(hr, s_FN, 190);
}

/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACCloseHandle(
/* [out][in] */ RPC_QUEUE_HANDLE __RPC_FAR *phQueue)
/*++

Routine Description:

    RPC server side of a dependent client call to ACCloseHandle.
    This routine handles dependent client 1.0 and 2.0 .

Arguments:

    phQueue - Pointer to queue handle.

Returned Value:

    Status.

--*/
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

    if(*phQueue == 0)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1941);

	RPC_QUEUE_CONTEXT* pqCtx = (RPC_QUEUE_CONTEXT*)(*phQueue);

	if(pqCtx->m_eType != CBaseContextType::eQueueCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 197);
	}

    HANDLE hQueue = _CONTEXT_TO_HANDLE(*phQueue) ;
    HRESULT rc = ACCloseHandle(hQueue);

    //
    // Decrement the license ref count.
    //
    g_QMLicense.DecrementActiveConnections(&(_CONTEXT_TO_LICENSE(*phQueue))) ;

    DELETE_FROM_CONTEXT_MAP(g_map_QM_dwQMContext, _CONTEXT_TO_QM_CONTEXT_MAPPED(*phQueue));
    //
    //  revoke rpc context handle
    //
    delete *phQueue ;
    *phQueue = 0;

    return LogHR(rc, s_FN, 195);

} // rpc_ACCloseHandle


//
// Dummy Handle for downlevel dependent clients
// that call MQCreateCursor() also for send.
// This Dummy handle value is odd
// it can't be real handle that was returned by ACCreateCursor
//
const DWORD xDummyCursorHandle = 11;


/* [call_as] */
HRESULT
qmcomm2_v1_0_S_rpc_ACCreateCursorEx(
    /* [in] */ RPC_QUEUE_HANDLE                       hQueue,
    /* [in][out] */ CACCreateRemoteCursor __RPC_FAR * pcc)
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
    if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

	if (hQueue == 0)
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1950);
	
    if(pcc == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1951);

	RPC_QUEUE_CONTEXT* pqCtx = (RPC_QUEUE_CONTEXT*)(hQueue);
	
    if(pqCtx->m_eType != CBaseContextType::eQueueCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1952);
	}

    OVERLAPPED ov = {0};
    HRESULT hr = GetThreadEvent(ov.hEvent);
	if(FAILED(hr))
		return LogHR(hr, s_FN, 1955);

    //
    // Call local AC driver
    //
	HACCursor32 hCursor = 0;
    hr = ACCreateCursor(_CONTEXT_TO_HANDLE(hQueue), &hCursor, &ov);

	if(hr == STATUS_ACCESS_DENIED)
	{
		//
		// w2k, NT4 dependent clients use mqoa that will try to create cursor also for send operation
		// in this case ACCreateCursor return STATUS_ACCESS_DENIED
		// For this specific case, Return dummy cursor so those clients will not break.
		//
		TrWARNING(GENERAL, "Downlevel depedent client call MQCreateCursor() for queue open to send");
		hCursor = (HACCursor32)xDummyCursorHandle;
		hr = MQ_OK;
	}

    if(hr == STATUS_PENDING)
    {
        //
        //  Wait for Remote Create Cursor completion
        //
        DWORD dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
		ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
		hr = DWORD_PTR_TO_DWORD(ov.Internal);
		if (dwResult != WAIT_OBJECT_0)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed WaitForSingleObject, gle = %!winerr!", gle);
			hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		TrTRACE(GENERAL, "Opening Remote cursor, hQueue = 0x%p, hCursor = 0x%x", hQueue, (DWORD)hCursor);
    }

    //
    // Convert parameters to remotable structure
    //
#ifdef _WIN64
    pcc->hCursor      = hCursor;
#else
    pcc->hCursor      = reinterpret_cast<ULONG>(hCursor);
#endif

    return LogHR(hr, s_FN, 200);

} // rpc_ACCreateCursorEx


/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACCreateCursor(
    /* [in] */ RPC_QUEUE_HANDLE                     hQueue,
    /* [in][out] */ CACTransferBufferV1 __RPC_FAR * ptb1
    )
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

	if (hQueue == 0)
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 172);

    if(ptb1 == NULL)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 171);
    }

    HRESULT hr2 = qmcomm2_v1_0_S_rpc_ACCreateCursorEx(hQueue, &ptb1->CreateCursor);
    return LogHR(hr2, s_FN, 210);

} // rpc_ACCreateCursor


/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACCloseCursor(
    /* [in] */ RPC_QUEUE_HANDLE hQueue,
    /* [in] */ ULONG    hCursor
    )
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);

	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 173);
    }

 	if (hQueue == 0)
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 174);

	RPC_QUEUE_CONTEXT* pqCtx = (RPC_QUEUE_CONTEXT*)(hQueue);

    if (pqCtx->m_eType != CBaseContextType::eQueueCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 221);
	}

	if(hCursor == xDummyCursorHandle)
	{
		//
		// Closing the Dummy cursor handle.
		// Don't call ACCloseCursor() in this case
		//
		TrWARNING(GENERAL, "Closing Dummy cursor handle");
	    return MQ_OK;
	}

	ASSERT(hCursor != xDummyCursorHandle);

    HRESULT hr2 = ACCloseCursor(_CONTEXT_TO_HANDLE(hQueue), (HACCursor32)hCursor);
    return LogHR(hr2, s_FN, 220);
}


/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACSetCursorProperties(
    /* [in] */ RPC_QUEUE_HANDLE /* hProxy */,
    /* [in] */ ULONG /* hCursor */,
    /* [in] */ ULONG /* hRemoteCursor */
    )
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	//
	// This RPC interface is obsolete.
	// rpc_ACCreateCursor will take care of the remote cursor properties internally in the qm.
    //
    ASSERT_BENIGN(("rpc_ACSetCursorProperties is obsolete RPC interface", 0));
	TrERROR(GENERAL, "rpc_ACSetCursorProperties is obsolete RPC interface");
    return MQ_ERROR_ILLEGAL_OPERATION;
}


/* [call_as] */
HRESULT
qmcomm2_v1_0_S_rpc_ACSendMessageEx(
    /* [in] */ RPC_QUEUE_HANDLE                  hQueue,
    /* [in] */ CACTransferBufferV2 __RPC_FAR *   ptb2,
    /* [in, out, unique] */ OBJECTID __RPC_FAR * pMessageID
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACSendMessageEx.
    This routine handles dependent client 2.0 .

Arguments:

    hQueue     - Queue handle.

    ptb2       - Pointer to transfer buffer of MSMQ 2.0.

    pMessageID - Pointer to message ID.

Returned Value:

    Status.

--*/
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 2300);
    }

  	if (hQueue == 0)
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 2303);

    if(ptb2 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2301);

	RPC_QUEUE_CONTEXT* pqCtx = (RPC_QUEUE_CONTEXT*)(hQueue);

    if(pqCtx->m_eType != CBaseContextType::eQueueCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 2302);
	}

    //
    // Convert MSMQ V2.0 transfer buffer to CACSendParameters structure
    //
    CACSendParameters SendParams;
    TransferBufferV2ToSendParams(ptb2, &SendParams);

	//
	//	Even though, on the client side pMessageID and
	//  *ptb2->old.ppMessageID point to the same buffer,
	//	RPC on the server side allocates different buffers.
	//
    if(pMessageID)
    {
        SendParams.MsgProps.ppMessageID = &pMessageID;
    }

    OVERLAPPED ov = {0};
    HRESULT rc = GetThreadEvent(ov.hEvent);
	if(FAILED(rc))
		return LogHR(rc, s_FN, 235);

    rc = ACSendMessage(_CONTEXT_TO_HANDLE(hQueue), SendParams, &ov);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for send completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 192);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

	if (SUCCEEDED(rc))
	{
		//
		// Log to tracing that a message was sent.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			DWORD dwMessageDelivery = (NULL != SendParams.MsgProps.pDelivery) ? *(SendParams.MsgProps.pDelivery) : -1;
			DWORD dwMessageClass = (NULL != SendParams.MsgProps.pAcknowledge) ? *(SendParams.MsgProps.pAcknowledge) : -1;
			WCHAR *wszLabel = L"NO LABEL";							
			DWORD dwLabelLen = wcslen(wszLabel);									
			if (NULL != SendParams.MsgProps.ppTitle && NULL != *(SendParams.MsgProps.ppTitle))
			{													
				wszLabel = *(SendParams.MsgProps.ppTitle);			
				dwLabelLen = SendParams.MsgProps.ulTitleBufferSizeInWCHARs;
			}														

			WCHAR wszQueueName1[200];
			DWORD dwQueueNameLength = TABLE_SIZE(wszQueueName1) - 1;
			HRESULT hr = qmcomm_v1_0_S_rpc_ACHandleToFormatName(hQueue, TABLE_SIZE(wszQueueName1), wszQueueName1, &dwQueueNameLength);
			WCHAR *wszQName;
			if (SUCCEEDED(hr))
			{
				wszQName = wszQueueName1;
			}
			else
			{
		    	TrERROR(GENERAL, "Failed in qmcomm_v1_0_S_rpc_ACHandleToFormatName: %!hresult!", hr);
				wszQName = L"*** Unknown Queue ***";																	
			}
			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls    Delivery:0x%x   Class:0x%x   Label:%.*ls",
				L"Sending message from DEP(EX) RT",
				wszQName,
				dwMessageDelivery,
				dwMessageClass,
				xwcs_t(wszLabel, dwLabelLen));
		}
	}

    return LogHR(rc, s_FN, 240);

} // rpc_ACSendMessageEx


/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACSendMessage(
    /* [in] */ RPC_QUEUE_HANDLE                       hQueue,
    /* [in] */ struct CACTransferBufferV1 __RPC_FAR * ptb1,
    /* [in, out, unique] */ OBJECTID __RPC_FAR *      pMessageID
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACSendMessage.
    This routine handles dependent client 1.0 .

Arguments:

    hQueue - Queue handle.

    ptb1   - Pointer to transfer buffer of MSMQ 1.0.

    pMessageID - Pointer to message ID.

Returned Value:

    Status.

--*/
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);

	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 2400);
    }

 	if (hQueue == 0)
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 2403);

    if(ptb1 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2401);

	RPC_QUEUE_CONTEXT* pqCtx = (RPC_QUEUE_CONTEXT*)(hQueue);

    if(pqCtx->m_eType != CBaseContextType::eQueueCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 2402);
	}

    //
    // Convert MSMQ V1.0 transfer buffer to CACSendParameters structure
    //
    CACSendParameters SendParams;
    TransferBufferV1ToSendParams(ptb1, &SendParams);

	//
	//	Even though, on the client side pMessageID and
	//  *ptb1->ppMessageID point to the same buffer,
	//	RPC on the server side allocates different buffers.
	//
    if(pMessageID)
    {
        SendParams.MsgProps.ppMessageID = &pMessageID;
    }

    OVERLAPPED ov = {0};
    HRESULT rc = GetThreadEvent(ov.hEvent);
	if(FAILED(rc))
		return LogHR(rc, s_FN, 245);

    rc = ACSendMessage(_CONTEXT_TO_HANDLE(hQueue), SendParams, &ov);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for send completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 400);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

	if (SUCCEEDED(rc))
	{
		//
		// Log to tracing that a message was sent.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			DWORD dwMessageDelivery = (NULL != SendParams.MsgProps.pDelivery) ? *(SendParams.MsgProps.pDelivery) : -1;
			DWORD dwMessageClass = (NULL != SendParams.MsgProps.pAcknowledge) ? *(SendParams.MsgProps.pAcknowledge) : -1;
			WCHAR *wszLabel = L"NO LABEL";							
			DWORD dwLabelLen = wcslen(wszLabel);									
			if (NULL != SendParams.MsgProps.ppTitle && NULL != *(SendParams.MsgProps.ppTitle))
			{													
				wszLabel = *(SendParams.MsgProps.ppTitle);			
				dwLabelLen = SendParams.MsgProps.ulTitleBufferSizeInWCHARs;
			}														
																	
			WCHAR wszQueueName1[200];
			DWORD dwQueueNameLength = TABLE_SIZE(wszQueueName1) - 1;
			HRESULT hr = qmcomm_v1_0_S_rpc_ACHandleToFormatName(hQueue, TABLE_SIZE(wszQueueName1), wszQueueName1, &dwQueueNameLength);
			WCHAR *wszQName;
			if (SUCCEEDED(hr))
			{
				wszQName = wszQueueName1;
			}
			else
			{
		    	TrERROR(GENERAL, "Failed in qmcomm_v1_0_S_rpc_ACHandleToFormatName: %!hresult!", hr);
				wszQName = L"*** Unknown Queue ***";																	
			}
			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls    Delivery:0x%x   Class:0x%x   Label:%.*ls",
				L"Sending message from DEP RT",
				wszQName,
				dwMessageDelivery,
				dwMessageClass,
				xwcs_t(wszLabel, dwLabelLen));
		}
	}

    return LogHR(rc, s_FN, 250);

} // rpc_ACSendMessage


/* [call_as] */
HRESULT
qmcomm2_v1_0_S_rpc_ACReceiveMessageEx(
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ DWORD hQMContext,
    /* [out][in] */ struct CACTransferBufferV2 __RPC_FAR * ptb2
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACReceiveMessageEx.
    This routine handles dependent client 2.0 .

Arguments:

    hBind      - Binding handle.

    hQMContext - Context handle.

    ptb2       - Pointer to transfer buffer of MSMQ 2.0.

Returned Value:

    Status.

--*/
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

    if(hQMContext == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 4001);

    if(ptb2 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 4002);

    //
    // Convert MSMQ V2.0 transfer buffer to CACReceiveParameters structure
    //
    CACReceiveParameters ReceiveParams;
    TransferBufferV2ToReceiveParams(ptb2, &ReceiveParams);

    OVERLAPPED ov = {0};
    HRESULT rc = GetThreadEvent(ov.hEvent);
	if(FAILED(rc))
		return rc;

    HANDLE hQueue;

    try
    {
        hQueue = (HANDLE) _CONTEXT_TO_HANDLE(GET_FROM_CONTEXT_MAP(g_map_QM_dwQMContext, hQMContext));
    }
    catch(const exception&)
    {
    	TrERROR(GENERAL, "Rejecting invalid dependent client context %x", hQMContext);
		return MQ_ERROR_INVALID_PARAMETER;
    }

    rc = ACReceiveMessage(hQueue, ReceiveParams, &ov);

    //
    // Convert CACReceiveParameters to MSMQ V2.0 transfer buffer
    //
    ReceiveParamsToTransferBufferV2(ReceiveParams, ptb2);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for receive completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 193);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

    //
    //  Set correct string length to unmarshal correct
    //
    if(ptb2->old.Receive.ppResponseFormatName &&
       ptb2->old.Receive.pulResponseFormatNameLenProp)
    {
        ptb2->old.Receive.ulResponseFormatNameLen = min(
            *ptb2->old.Receive.pulResponseFormatNameLenProp,
            ptb2->old.Receive.ulResponseFormatNameLen
            );
    }

    if(ptb2->old.Receive.ppAdminFormatName &&
       ptb2->old.Receive.pulAdminFormatNameLenProp)
    {
        ptb2->old.Receive.ulAdminFormatNameLen = min(
            *ptb2->old.Receive.pulAdminFormatNameLenProp,
            ptb2->old.Receive.ulAdminFormatNameLen
            );
    }

    if(ptb2->old.Receive.ppDestFormatName &&
       ptb2->old.Receive.pulDestFormatNameLenProp)
    {
        ptb2->old.Receive.ulDestFormatNameLen = min(
            *ptb2->old.Receive.pulDestFormatNameLenProp,
            ptb2->old.Receive.ulDestFormatNameLen
            );
    }

    if(ptb2->old.Receive.ppOrderingFormatName &&
       ptb2->old.Receive.pulOrderingFormatNameLenProp)
    {
        ptb2->old.Receive.ulOrderingFormatNameLen = min(
            *ptb2->old.Receive.pulOrderingFormatNameLenProp,
            ptb2->old.Receive.ulOrderingFormatNameLen
            );
    }

    if(ptb2->old.ppTitle &&
       ptb2->old.pulTitleBufferSizeInWCHARs)
    {
        ptb2->old.ulTitleBufferSizeInWCHARs = min(
            *ptb2->old.pulTitleBufferSizeInWCHARs,
            ptb2->old.ulTitleBufferSizeInWCHARs
            );
    }

    return LogHR(rc, s_FN, 270);

} // rpc_ACReceiveMessageEx


/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACReceiveMessage(
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ DWORD hQMContext,
    /* [out][in] */ struct CACTransferBufferV1 __RPC_FAR * ptb1
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACReceiveMessage.
    This routine handles dependent client 1.0 .

Arguments:

    hBind      - Binding handle.

    hQMContext - Context handle.

    ptb1       - Pointer to transfer buffer of MSMQ 1.0.

Returned Value:

    Status.

--*/
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

    if(hQMContext == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2701);

    if(ptb1 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2702);

    //
    // Convert MSMQ V1.0 transfer buffer to CACReceiveParameters structure
    //
    CACReceiveParameters ReceiveParams;
    TransferBufferV1ToReceiveParams(ptb1, &ReceiveParams);

    OVERLAPPED ov = {0};
    HRESULT rc = GetThreadEvent(ov.hEvent);
	if(FAILED(rc))
		return LogHR(rc, s_FN, 275);

    HANDLE hQueue;

    try
    {
        hQueue = (HANDLE) _CONTEXT_TO_HANDLE(GET_FROM_CONTEXT_MAP(g_map_QM_dwQMContext, hQMContext));
    }
    catch(const exception&)
    {
		TrERROR(GENERAL, "Rejecting invalid dependent client context %x", hQMContext);
		return MQ_ERROR_INVALID_PARAMETER;
    }

    rc = ACReceiveMessage(hQueue, ReceiveParams, &ov);

    //
    // Convert CACReceiveParameters to MSMQ V1.0 transfer buffer
    //
    ReceiveParamsToTransferBufferV1(ReceiveParams, ptb1);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for receive completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 420);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

    //
    //  Set correct string length to unmarshal correct
    //
    if(ptb1->Receive.ppResponseFormatName)
    {
        ptb1->Receive.ulResponseFormatNameLen = min(
            *ptb1->Receive.pulResponseFormatNameLenProp,
            ptb1->Receive.ulResponseFormatNameLen
            );
    }

    if(ptb1->Receive.ppAdminFormatName)
    {
        ptb1->Receive.ulAdminFormatNameLen = min(
            *ptb1->Receive.pulAdminFormatNameLenProp,
            ptb1->Receive.ulAdminFormatNameLen
            );
    }

    if(ptb1->Receive.ppDestFormatName)
    {
        ptb1->Receive.ulDestFormatNameLen = min(
            *ptb1->Receive.pulDestFormatNameLenProp,
            ptb1->Receive.ulDestFormatNameLen
            );
    }

    if(ptb1->Receive.ppOrderingFormatName)
    {
        ptb1->Receive.ulOrderingFormatNameLen = min(
            *ptb1->Receive.pulOrderingFormatNameLenProp,
            ptb1->Receive.ulOrderingFormatNameLen
            );
    }

    if(ptb1->ppTitle)
    {
        ptb1->ulTitleBufferSizeInWCHARs = min(
            *ptb1->pulTitleBufferSizeInWCHARs,
            ptb1->ulTitleBufferSizeInWCHARs
            );
    }

    return LogHR(rc, s_FN, 280);

} // rpc_ACReceiveMessage


/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACHandleToFormatName(
    /* [in] */ RPC_QUEUE_HANDLE hQueue,
    /* [in] */ DWORD dwFormatNameRPCBufferLen,
    /* [size_is][out] */ LPWSTR lpwcsFormatName,
    /* [out][in] */ LPDWORD pdwLength
    )
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);

	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 294);
    }

 	if (hQueue == 0)
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 295);

    if ((dwFormatNameRPCBufferLen != 0) && (lpwcsFormatName == NULL))
    {
		TrERROR(GENERAL, "Received NULL buffer");
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 293);
    }

	memset(lpwcsFormatName, 0, dwFormatNameRPCBufferLen * sizeof(WCHAR));

	RPC_QUEUE_CONTEXT* pqCtx = (RPC_QUEUE_CONTEXT*)(hQueue);

    if(pqCtx->m_eType != CBaseContextType::eQueueCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 291);
	}

    HRESULT hr2 = ACHandleToFormatName( _CONTEXT_TO_HANDLE(hQueue),
                                 lpwcsFormatName,
                                 pdwLength);
    return LogHR(hr2, s_FN, 290);
}

/* [call_as] */
HRESULT
qmcomm_v1_0_S_rpc_ACPurgeQueue(
    /* [in] */ RPC_QUEUE_HANDLE hQueue
    )
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 305);
    }

 	if (hQueue == 0)
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 302);

 	RPC_QUEUE_CONTEXT* pqCtx = (RPC_QUEUE_CONTEXT*)(hQueue);

    if(pqCtx->m_eType != CBaseContextType::eQueueCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 301);
	}

    HRESULT hr2 = ACPurgeQueue(_CONTEXT_TO_HANDLE(hQueue));
    return LogHR(hr2, s_FN, 300);
}

void __RPC_USER RPC_QUEUE_HANDLE_rundown( RPC_QUEUE_HANDLE hQueue)
{
    TrWARNING(GENERAL, "QUEUE_HANDLE_rundown: handle = 0x%p", _CONTEXT_TO_HANDLE(hQueue));
    qmcomm_v1_0_S_rpc_ACCloseHandle(&hQueue);
}

//+-------------------------------------------------------------------------
//
//  HRESULT QMQueryQMRegistryInternal()
//
// This function is called by dependent clients to update the registry
// on the dependent machine. The dependent need the list of MSMQ DS servers
// because it query them directly, not through the supporting server.
//
//+-------------------------------------------------------------------------

/* [call_as] */
HRESULT
qmcomm_v1_0_S_QMQueryQMRegistryInternal(
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ DWORD    dwQueryType,
    /* [string][out] */ LPWSTR __RPC_FAR *lplpRegValue
    )
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
	if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

    ASSERT(lplpRegValue) ;
    *lplpRegValue = NULL ;

    switch (dwQueryType)
    {
       case  QueryRemoteQM_MQISServers:
       {
         //
         //  Read the list of servers from registry
         //
         WCHAR wszServers[ MAX_REG_DSSERVER_LEN ] ;
         DWORD dwSize = sizeof(wszServers) ;
         DWORD dwType = REG_SZ ;

         LONG res = GetFalconKeyValue( MSMQ_DS_SERVER_REGNAME,
                                       &dwType,
                                       wszServers,
                                       &dwSize ) ;

         ASSERT(res == ERROR_SUCCESS) ;

         if (res == ERROR_SUCCESS)
         {
            ASSERT(dwSize < MAX_REG_DSSERVER_LEN) ;

			*lplpRegValue = newwcs(wszServers);
            return MQ_OK;
         }

         return LogHR(MQ_ERROR, s_FN, 310);
       }

       case  QueryRemoteQM_LongLiveDefault:
       {
            DWORD dwVal ;
            DWORD dwDef = MSMQ_DEFAULT_LONG_LIVE ;
            READ_REG_DWORD(dwVal, MSMQ_LONG_LIVE_REGNAME, &dwDef);

            *lplpRegValue = new WCHAR[ 24 ] ;
            return StringCchPrintf(*lplpRegValue, 24, L"%ld", (long) dwVal);
       }

        case  QueryRemoteQM_EnterpriseGUID:
        {
            GUID guidEnterprise = McGetEnterpriseId();

            GUID_STRING strUuid;
            MQpGuidToString(&guidEnterprise, strUuid);

            *lplpRegValue = newwcs(strUuid);
            return MQ_OK ;
        }

       case QueryRemoteQM_QMVersion:
       {
          //
          // This is used by MSMQ2.0 dependent client to find the version of
          // its supporting server. if the dependent client get MQ_ERROR,
          // then it know the server is MSMQ1.0
          //
          WCHAR wszVersion[ 64 ] ;
          HRESULT hr = StringCchPrintf(wszVersion, TABLE_SIZE(wszVersion), L"%ld,%ld,%ld", rmj, rmm, rup) ;
          if (FAILED(hr))
          {
          	ASSERT(("Insufficient buffer", 0));
          	return hr;
          }
          		
          *lplpRegValue = newwcs(wszVersion);

          return MQ_OK ;
       }

       case  QueryRemoteQM_ServerQmGUID:
       {
            GUID_STRING strUuid;
            MQpGuidToString(QueueMgr.GetQMGuid(), strUuid);

            *lplpRegValue = newwcs(strUuid);

            return MQ_OK ;
       }

       default:
         ASSERT_BENIGN(("Bad dwQueryType value passed to QMQueryQMRegistryInternal RPC interface; safe to ignore.", 0));
         return LogHR(MQ_ERROR, s_FN, 320);
    }
} // QMQueryQMRegistryInternal


/* [call_as] */
HRESULT
qmcomm2_v1_0_S_QMSendMessageInternalEx(
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ QUEUE_FORMAT* /*pQueueFormat*/,
    /* [in] */ struct CACTransferBufferV2* /*ptb2*/,
	/* [in, out, unique] */ OBJECTID* /*pMessageID */
    )
/*++

Routine Description:

    RPC server side of a dependent client call to QMSendMessageInternalEx.
    This routine handles dependent client 2.0 .

Arguments:

    hBind        - Binding handle.

    pQueueFormat - Pointer to queue format.

    ptb2         - Pointer to transfer buffer of MSMQ 2.0.

    pMessageID   - Pointer to the message ID.

Returned Value:

    Status.

--*/
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
    //
    // Dependent client 2.0 calls this routine when AC on supporting server
    // returns STATUS_RETRY in the send path. In MSMQ 3.0 AC does not return
    // STATUS_RETRY anymore and thus we do not expect this routine to be called.
    // (ShaiK, 30-May-2000)
    //
    ASSERT_BENIGN(("QMSendMessageInternalEx is an obsolete RPC interface; safe to ignore", 0));
    LogIllegalPoint(s_FN, 500);
    return MQ_ERROR_ILLEGAL_OPERATION;

} // QMSendMessageInternalEx


/* [call_as] */
HRESULT
qmcomm_v1_0_S_QMSendMessageInternal(
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ QUEUE_FORMAT* /*pQueueFormat*/,
    /* [in] */ struct CACTransferBufferV1* /*ptb1*/
    )
/*++

Routine Description:

    RPC server side of a dependent client call to QMSendMessageInternal.
    This routine handles dependent client 1.0 .

Arguments:

    hBind        - Binding handle.

    pQueueFormat - Pointer to queue format.

    ptb1         - Pointer to transfer buffer of MSMQ 1.0.

Returned Value:

    Status.

--*/
{
	//
	// Set RPC timeout to 5 minutes
	//
	SetRpcServerKeepAlive(NULL);
	
    //
    // Dependent client 2.0 calls this routine when AC on supporting server
    // returns STATUS_RETRY in the send path. In MSMQ 3.0 AC does not return
    // STATUS_RETRY anymore and thus we do not expect this routine to be called.
    // (ShaiK, 30-May-2000)
    //
    ASSERT_BENIGN(("QMSendMessageInternal is an obsolete RPC interface; safe to ignore", 0));
    LogIllegalPoint(s_FN, 510);
    return MQ_ERROR_ILLEGAL_OPERATION;

} // QMSendMessageInternal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\heap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company and Microsoft
 * Corporation make no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *
 */

#ifndef HEAP_H
#define HEAP_H

template <class RandomAccessIterator, class Distance, class T>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && *(first + parent) < value) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }
    *(first + holeIndex) = value;
}

#if 0
template <class RandomAccessIterator, class T, class Distance>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, T*, Distance) {
    __push_heap(first, (Distance)((last - first) - 1), (Distance)(0), T(*(last - 1)));
}
#else //!0
template <class RandomAccessIterator, class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, T*) {
    __push_heap(first, (last - first) - 1, first - first /* 0 cast to Distance */, T(*(last - 1)));
}
#endif //0

template <class RandomAccessIterator>
inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {
#if 0
    __push_heap_aux(first, last, value_type(first), /*dummy, just for ptrdiff*/ last - first);
#else //!0
    __push_heap_aux(first, last, value_type(first));
#endif //0
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value, Compare comp) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && comp(*(first + parent), value)) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }
    *(first + holeIndex) = value;
}

#if 0
template <class RandomAccessIterator, class Compare,  class T,  class Distance>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Compare comp, T*, Distance) {
    __push_heap(first, (Distance)((last - first) - 1), (Distance)(0), T(*(last - 1)), comp);
}
#else //!0
template <class RandomAccessIterator, class Compare,  class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Compare comp, T*) {
    __push_heap(first, (last - first) - 1, first - first /* 0 cast to Distance */, T(*(last - 1)), comp);
}
#endif //0

template <class RandomAccessIterator, class Compare>
inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,
		      Compare comp) {
#if 0
    __push_heap_aux(first, last, comp, value_type(first), /*dummy, just for ptrdiff*/ last - first);
#else //!0
    __push_heap_aux(first, last, comp, value_type(first));
#endif //0
}

template <class RandomAccessIterator, class Distance, class T>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (*(first + secondChild) < *(first + (secondChild - 1)))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value);
}

template <class RandomAccessIterator, class T, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value);
}

template <class RandomAccessIterator, class T>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), distance_type(first));
}

template <class RandomAccessIterator>
inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {
    __pop_heap_aux(first, last, value_type(first));
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value, Compare comp) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (comp(*(first + secondChild), *(first + (secondChild - 1))))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value, comp);
}

template <class RandomAccessIterator, class T, class Compare, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Compare comp,
		       Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value, comp);
}

template <class RandomAccessIterator, class T, class Compare>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*, Compare comp) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), comp,
	       distance_type(first));
}

template <class RandomAccessIterator, class Compare>
inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		     Compare comp) {
    __pop_heap_aux(first, last, value_type(first), comp);
}

template <class RandomAccessIterator, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,
		 Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;

    for (;;) {
	__adjust_heap(first, parent, len, T(*(first + parent)));
	if (parent == 0) return;
	parent--;
    }
}

template <class RandomAccessIterator>
inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {
    __make_heap(first, last, value_type(first), distance_type(first));
}

template <class RandomAccessIterator, class Compare, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last,
		 Compare comp, T*, Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;

    for (;;) {
	__adjust_heap(first, parent, len, T(*(first + parent)), comp);
	if (parent == 0) return;
	parent--;
    }
}

template <class RandomAccessIterator, class Compare>
inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,
		      Compare comp) {
    __make_heap(first, last, comp, value_type(first), distance_type(first));
}

template <class RandomAccessIterator>
void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {
    while (last - first > 1) pop_heap(first, last--);
}

template <class RandomAccessIterator, class Compare>
void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
	       Compare comp) {
    while (last - first > 1) pop_heap(first, last--, comp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\dumpauthzutl.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    DumpAuthzUtl.h

Abstract:

    Dump authz related information utilities.

Author:

    Ilan Herbst (ilanh) 14-Apr-2001

--*/

#ifndef _DUMPAUTHZUTL_H_
#define _DUMPAUTHZUTL_H_


void
PrintAcl(
    BOOL fAclExist,
    BOOL fDefaulted,
    PACL pAcl
	);


void 
IsPermissionGranted(
	PSECURITY_DESCRIPTOR pSD,
	DWORD Permission,
	bool* pfAllGranted, 
	bool* pfEveryoneGranted, 
	bool* pfAnonymousGranted 
	);


bool
IsAllGranted(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD
	);


bool
IsEveryoneGranted(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD
	);


void
DumpAccessCheckFailureInfo(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD,
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
	);


#endif // _DUMPAUTHZUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\httpaccept.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    httpAccept.h

Abstract:
    Accept HTTP request interface

Author:
    Uri Habusha (urih) 14-May-2000

--*/

#pragma once

#ifndef __HTTP_ACCEPT_H__
#define __HTTP_ACCEPT_H__



void 
IntializeHttpRpc(
    void
    );



LPCSTR
HttpAccept(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pDestQueue
    );

#endif // __HTTP_ACCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\httpauthr.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    HttpAuthr.cpp

Abstract:
    functions to verify the xml signature authnticate the sender
	and check the sender access rights (sender authorization)

Author:
    Ilan Herbst (ilanh) 15-May-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "session.h"
#include "qmsecutl.h"
#include <mqsec.h>
#include <mqformat.h>
#include "Xds.h"
#include "tr.h"
#include "mpnames.h"
#include <utf8.h>

#include "HttpAuthr.tmh"

static WCHAR *s_FN=L"HttpAuthr";


static
LPCWSTR
SkipUriPrefix(
	LPCWSTR Uri
	)
/*++
Routine Description:
	Skip the Uri prefix

Arguments:
	Uri - reference Uri

Returned Value:
	Pointer to reference Uri after the prefix.

--*/
{
	LPCWSTR pUriNoPrefix = Uri;
	if(pUriNoPrefix[0] == PREFIX_INTERNAL_REFERENCE_C)
	{
		//
		// This is internal #.....
		//
		pUriNoPrefix++;
		return pUriNoPrefix;
	}

	if(wcsncmp(pUriNoPrefix, xPrefixMimeAttachmentW, xPrefixMimeAttachmentLen) == 0)
	{
		pUriNoPrefix += xPrefixMimeAttachmentLen;
		return pUriNoPrefix;
	}

	ASSERT_BENIGN(("Unknown Uri prefix", 0));
	return pUriNoPrefix;
}


#ifdef _DEBUG
static

void
StringToGuid(
    xwcs_t& str,
    GUID* pGuid
    )
{
    const int format[] = {8,4,4,2,2,2,2,2,2,2,2};
    const int delimiter[] ={1,1,1,0,1,0,0,0,0,0,0};

    ULONG d[11];

    ASSERT((TABLE_SIZE(format) == 11) && (TABLE_SIZE(delimiter) == 11));

    if (str.Length() < GUID_STR_LENGTH)
    {
         ASSERT_BENIGN(("Illegal uuid format", 0));
    }
    LPCWSTR p= str.Buffer();

    for(int i=0; i< 11; i++)
    {
        WCHAR buf[9];
        WCHAR *endptr;
        int size = format[i];
        if(delimiter[i] && p[size] != L'-')
        {
            ASSERT_BENIGN(("Illegal uuid format", 0));
        }
        memcpy(buf,p,size*sizeof(WCHAR));
        buf[size]=L'\0';
        d[i] = wcstoul(buf,&endptr,16);
        if(*endptr != L'\0')
        {
            ASSERT_BENIGN(("Illegal uuid format", 0));
        }
        p=p+size+delimiter[i];
    }
    pGuid->Data1=d[0];
    pGuid->Data2 = static_cast<WORD>(d[1]);
    pGuid->Data3 = static_cast<WORD>(d[2]);
    for(int i = 0; i < 8; i++)
    {
        pGuid->Data4[i] = static_cast<BYTE>(d[i+3]);
    }
}

#endif // _DEBUG


static
void
VerifySignatureXds(
	CQmPacket *PktPtrs,
	HCRYPTPROV hProv,
	HCRYPTKEY hPbKey,
	bool fMarkAuth
	)
/*++
Routine Description:
	Verify signature on xml dsig element.
	this function verify that the signature in the packet fits the message body
	and other references that were signed with the public key of the certificate

Arguments:
	PktPtrs - pointer to the packet
	hProv - handle of the provider
	hPbKey - handle of the sender public key
	fMarkAuth - indicate if the packet will be marked as authenticated after verifying the signature.

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{

    ASSERT(!PktPtrs->IsEncrypted());
	
	ASSERT(!PktPtrs->IsAuthenticated());
	ASSERT(PktPtrs->GetLevelOfAuthentication() == 0);

    //
    // Get the signature from the packet.
    //
    USHORT ulSignatureSize;
    const BYTE* pSignature = PktPtrs->GetSignature(&ulSignatureSize);

	ASSERT(ulSignatureSize > 0);

	ASSERT(hProv != NULL);
	ASSERT(hPbKey != NULL);

	//
	// Convert the signature element to unicode.
	// our xml parser works on unicode
	//
	size_t SignatureWSize;
	AP<WCHAR> pSignatureW = UtlUtf8ToWcs(pSignature, ulSignatureSize,  &SignatureWSize);

	//
	// Parsing signature element
	//
	CAutoXmlNode SignatureTree;
	XmlParseDocument(xwcs_t(pSignatureW, SignatureWSize), &SignatureTree);

	//
	// Get reference vector from the SignatureTree
	//
	CReferenceValidateVectorTypeHelper ReferenceValidateVector = XdsGetReferenceValidateInfoVector(
															         SignatureTree
															         );

	XdsValidateSignature(
		SignatureTree,
		hPbKey,
		hProv
		);
	
	TrTRACE(SECURITY, "Validate Signature on signature element completed ok (still need to validate references)");

	//
	// Normal termination --> Validation ok
	//

	bool fBodyRefValidated = false;
	bool fExtensionRefValidated = false;
	//
	// Fill ReferenceData in the ReferenceValidateVector found in the signature
	//
	for(ReferenceValidateVectorType::iterator ir = ReferenceValidateVector->begin();
		ir != ReferenceValidateVector->end(); ++ir)
	{
		TrTRACE(SECURITY, "Uri '%.*ls'", LOG_XWCS((*ir)->Uri()));
		LPCWSTR pUriId = SkipUriPrefix((*ir)->Uri().Buffer());

		//
		// Get ReferenceData according to Uri or some other mechanism
		// this need to be decided
		//
		xdsvoid_t ReferenceData;

		if(wcsncmp(pUriId, xMimeBodyIdW, xMimeBodyIdLen) == 0)
		{
#ifdef _DEBUG
		    GUID UriSrcQmGuid = GUID_NULL;
            xwcs_t xstr_urid(pUriId + xMimeBodyIdLen, wcslen(pUriId + xMimeBodyIdLen));
			StringToGuid(xstr_urid, &UriSrcQmGuid);
			ASSERT_BENIGN(UriSrcQmGuid == *PktPtrs->GetSrcQMGuid());
#endif // _DEBUG

			//
			// Message Body validation
			//
			ULONG dwBodySize;
			const UCHAR* pBody = PktPtrs->GetPacketBody(&dwBodySize);
			TrTRACE(SECURITY, "VerifySignatureXds: message body reference, BodySize = %d", dwBodySize);

            if( NULL == pBody || 0 == dwBodySize )
            {
                TrTRACE(SECURITY, "VerifySignatureXds: can't verify empty body");
                throw bad_reference();
            }

			ReferenceData = xdsvoid_t(pBody, dwBodySize);
			(*ir)->SetReferenceData(ReferenceData);
			XdsValidateReference(**ir, hProv);

			//
			// Mark that we validated body reference
			//
			fBodyRefValidated = true;

			TrTRACE(SECURITY, "Validate message body reference completed ok");
		}
		else if(wcsncmp(pUriId, xMimeExtensionIdW, xMimeExtensionIdLen) == 0)
		{
#ifdef _DEBUG
		    GUID UriSrcQmGuid = GUID_NULL;
            xwcs_t xstr_urid(pUriId + xMimeExtensionIdLen, wcslen(pUriId + xMimeExtensionIdLen));
			StringToGuid(xstr_urid, &UriSrcQmGuid);
			ASSERT_BENIGN(UriSrcQmGuid == *PktPtrs->GetSrcQMGuid());
#endif // _DEBUG

			//
			// Message Extension validation
			//
			ULONG dwExtensionSize = PktPtrs->GetMsgExtensionSize();
			const UCHAR* pExtension = PktPtrs->GetMsgExtensionPtr();
			TrTRACE(SECURITY, "VerifySignatureXds: message Extension reference, ExtensionSize = %d", dwExtensionSize);

			ReferenceData = xdsvoid_t(pExtension, dwExtensionSize);
			(*ir)->SetReferenceData(ReferenceData);
			XdsValidateReference(**ir, hProv);

			//
			// Mark that we validate extension reference
			//
			fExtensionRefValidated = true;

			TrTRACE(SECURITY, "Validate message Extension reference completed ok");
		}
		else
		{
			//
			// Unknown Reference in SignatureElement
			// We will not reject the signature because unknown references
			// this means that we will only validate body and extension references
			// and ignore other references.
			//
			TrERROR(SECURITY, "unexpected reference in SignatureElement, Uri = %.*ls", LOG_XWCS((*ir)->Uri()));
		}
	}

	TrTRACE(SECURITY, "Verify SignatureXds completed ok");

	//
	// Check if all mandatory references exist
	//
	bool fMandatoryReferencesExist = true;
	if(!fBodyRefValidated && (PktPtrs->GetBodySize() != 0))
	{
		fMandatoryReferencesExist = false;
		TrERROR(SECURITY, "Body exist but we did not validate body reference");
	}

	if(!fExtensionRefValidated && (PktPtrs->GetMsgExtensionSize() != 0))
	{
		fMandatoryReferencesExist = false;
		TrERROR(SECURITY, "Extension exist but we did not validate extension reference");
	}

	//
	// mark the message as authenticated only if needed.
	// Certificate was found in the DS or certificate is not self signed
	// and all Mandatory references exists.
	//
	if(!fMarkAuth || !fMandatoryReferencesExist)
	{
		TrWARNING(SECURITY, "The message will not mark as autheticated");
		return;
	}

	//
	// All is well, mark the message that it is an authenticated message.
	// mark the authentication flag and the level of authentication as XMLDSIG
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIGXML);
}		


USHORT
AuthenticateHttpMsg(
	CQmPacket* pPkt,
	PCERTINFO* ppCertInfo
	)
/*++
Routine Description:
	Authenticate Http message
	The function get the certificate related information including the crypto provider
	and the user sid, verify the xml digital signature.

Arguments:
	pPkt - pointer to the packet
	ppCertInfo - pointer to cert info

Returned Value:
    The acknowledgment class.
    if Authenticate packet is OK, MQMSG_CLASS_NORMAL is returned
	if error MQMSG_CLASS_NACK_BAD_SIGNATURE is returned

--*/
{
	//
	// 1) Get the CSP information for the message certificate.
	// 2) Get the SenderSid from the DS according to the certificate - will be used latter
	//    after verifying the signature to determinate the user access rights.
	//
	// Note: for http messages we are not forcing a retry to get the sid, fNeedSidInfo = false
	// In msmq protocol we force retry to get the sid in case of MQMSG_SENDERID_TYPE_SID
	//

	R<CERTINFO> pCertInfo;
	HRESULT hr = GetCertInfo(
					 pPkt,
					 &pCertInfo.ref(),
					 false // fNeedSidInfo
					 );

	if (FAILED(hr))
	{
		TrERROR(SECURITY, "GetCertInfo() Failed in VerifyHttpRecvMsg()");
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}

	HCRYPTPROV hProv = pCertInfo->hProv;
	HCRYPTKEY hPbKey = pCertInfo->hPbKey;

	try
	{
		//
		// fMarkAuth flag indicate if the packet should be mark as authenticated
		// after validating the signature.
		// The packed should be marked as authenticate if the certificate was found in the DS (pSid != NULL)
		// or the certificate is not self signed
		//
		bool fMarkAuth = ((pCertInfo->pSid != NULL) || (!pCertInfo->fSelfSign));

		VerifySignatureXds(
			pPkt,
			hProv,
			hPbKey,
			fMarkAuth
			);

		*ppCertInfo = pCertInfo.detach();

		return(MQMSG_CLASS_NORMAL);
	}
	catch (const bad_XmldsigElement&)
	{
		TrERROR(SECURITY, "Bad Xmldsig Element");
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
	catch (const bad_signature&)
	{
		//
		// XdsValidateSignature throw excption --> Validation fail
		//
		TrERROR(SECURITY, "Signature Validation Failed - bad_signature excption");

		//
		// Bad signature, send NACK.
		//
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
	catch (const bad_reference&)
	{
		//
		// XdsCoreValidation throw Reference excption --> CoreValidation fail
		//
		TrERROR(SECURITY, "Core Validation Failed, Reference Validation Failed");

		//
		// Bad signature, send NACK.
		//
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
	catch (const bad_CryptoApi& badCryEx)
	{
		TrERROR(SECURITY, "bad Crypto Class Api Excption ErrorCode = %x", badCryEx.error());

		//
		// Bad signature, send NACK.
		//
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
    catch (const bad_base64&)
    {
		TrERROR(SECURITY, "Signature Validation Failed - bad_base64 excption");
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
    catch (const bad_alloc&)
    {
		TrERROR(SECURITY, "Signature Validation Failed - bad_alloc excption");
		LogIllegalPoint(s_FN, 20);
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
}


USHORT
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt,
	PCERTINFO* ppCertInfo
	)
/*++
Routine Description:
	Authenticate http message for local queues

Arguments:
	pPkt - pointer to the packet
	ppCertInfo - pointer to cert info

Returned Value:
    The acknowledgment class.
    if packet authentication is OK, MQMSG_CLASS_NORMAL is returned

--*/
{
	ASSERT(pPkt->IsEncrypted() == 0);

	//
	// Authentication
	//

	//
	// Mark the message as unAuthenticated
	//
	pPkt->SetAuthenticated(FALSE);
	pPkt->SetLevelOfAuthentication(MQMSG_AUTHENTICATION_NOT_REQUESTED);

	*ppCertInfo = NULL;

	if(pPkt->GetSignatureSize() != 0)
	{
		//
		// We have signature but no sender certificate
		//
		if(!pPkt->SenderCertExist())
		{
			TrERROR(SECURITY, "VerifyAuthenticationHttpMsg(): We have Signature but no sender certificate");
			return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
		}
		USHORT usClass = AuthenticateHttpMsg(
							pPkt,
							ppCertInfo
							);

		if(MQCLASS_NACK(usClass))
		{
			TrERROR(SECURITY, "AuthenticateHttpMsg() failed");
			return(usClass);
		}

	}

    return(MQMSG_CLASS_NORMAL);
}


USHORT
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt,
	const CQueue* pQueue,
	PCERTINFO* ppCertInfo
	)
/*++
Routine Description:
	Authenticate http message and get sender sid

Arguments:
	pPkt - pointer to the packet
	pQueue - pointer to the queue
	ppCertInfo - pointer to cert info

Returned Value:
    The acknowledgment class.
    if packet authentication is OK, MQMSG_CLASS_NORMAL is returned

--*/
{
	ASSERT(pQueue->IsLocalQueue());

	//
	// dont support encryption in HTTP messages
	// encryption is done using https - iis level
	//
	ASSERT(pQueue->GetPrivLevel() != MQ_PRIV_LEVEL_BODY);
	ASSERT(pPkt->IsEncrypted() == 0);

	USHORT usClass = VerifyAuthenticationHttpMsg(
						pPkt,
						ppCertInfo
						);

	if(MQCLASS_NACK(usClass))
	{
		TrERROR(SECURITY, "Authentication failed");
		return(usClass);
	}

    if (pQueue->ShouldMessagesBeSigned() && !pPkt->IsAuthenticated())
    {
		//
        // The queue enforces that any message sent to it should be signed.
        // But the message does not contain a signature, send NACK.
		//

		TrERROR(SECURITY, "The queue accept only Authenticated packets, the packet is not authenticated");
        return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
    }

    return(MQMSG_CLASS_NORMAL);
}



USHORT
VerifyAuthorizationHttpMsg(
	const CQueue* pQueue,
	PSID pSenderSid
	)
/*++
Routine Description:
	Check if the sender sid is Authorize to write message to the queue

Arguments:
	pQueue - pointer to the queue
	pSenderSid - pointer to sender sid

Returned Value:
    The acknowledgment class.
    if access granted, MQMSG_CLASS_NORMAL is returned

--*/
{
	ASSERT(pQueue->IsLocalQueue());

	//
    // Verify the the sender has write access permission on the queue.
	//
	HRESULT hr = VerifySendAccessRights(
					 const_cast<CQueue*>(pQueue),
					 pSenderSid,
					 (USHORT)(pSenderSid ? MQMSG_SENDERID_TYPE_SID : MQMSG_SENDERID_TYPE_NONE)
					 );

    if (FAILED(hr))
    {
		//
        // Access was denied, send NACK.
		//
		TrERROR(SECURITY, "VerifyAuthorizationHttpMsg(): VerifySendAccessRights failed");
        return(MQMSG_CLASS_NACK_ACCESS_DENIED);
    }

	TrTRACE(SECURITY, "VerifyAuthorizationHttpMsg(): VerifySendAccessRights ok");
    return(MQMSG_CLASS_NORMAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\httpauthr.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMessageXml.h

Abstract:
    functions to verify authentication and authorization  in the qm

Author:
    Ilan Herbst (ilanh) 21-May-2000

Environment:
    Platform-independent,

--*/

#ifndef _HTTPAUTHR_H_
#define _HTTPAUTHR_H_


USHORT 
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt,
	PCERTINFO* ppCertInfo
	);


USHORT 
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt, 
	const CQueue* pQueue,
	PCERTINFO* ppCertInfo
	);

	
USHORT 
VerifyAuthorizationHttpMsg(
	const CQueue* pQueue,
	PSID pSenderSid
	);

#endif // _HTTPAUTHR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\inrcv.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    inrcv.cpp

Abstract:
	implementation for functions that handlers incomming message.					

Author:
    Gil Shafriri 4-Oct-2000

Environment:
    Platform-independent

--*/
#include "stdh.h"
#include "mqstl.h"
#include "qmpkt.h"
#include "xact.h"
#include "xactin.h"
#include "cqueue.h"
#include "cqmgr.h"
#include "rmdupl.h"
#include "inrcv.h"
#include "rmdupl.h"
#include <mp.h>
#include <mqexception.h>

#include "qmacapi.h"

#include "inrcv.tmh"

extern  CInSeqHash* g_pInSeqHash;
extern HANDLE g_hAc;

static WCHAR *s_FN=L"Inrcv";


class ACPutPacketOvl : public EXOVERLAPPED
{
public:
    ACPutPacketOvl(
        EXOVERLAPPED::COMPLETION_ROUTINE lpComplitionRoutine
        ) :
        EXOVERLAPPED(lpComplitionRoutine, lpComplitionRoutine)
    {
    }

	HANDLE          m_hQueue;
    CACPacketPtrs   m_packetPtrs;   // packet pointers
};



//-------------------------------------------------------------------
//
// CSyncPutPacketOv class
//
//-------------------------------------------------------------------
class CSyncPutPacketOv : public OVERLAPPED
{
public:
    CSyncPutPacketOv()
    {
        memset(static_cast<OVERLAPPED*>(this), 0, sizeof(OVERLAPPED));

        hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (hEvent == NULL)
        {
            TrERROR(SRMP, "Failed to create event for HTTP AC put request. Error %d", GetLastError());
            LogIllegalPoint(s_FN, 10);
            throw exception();
        }

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR) hEvent | (DWORD_PTR)0x1);

    }


    ~CSyncPutPacketOv()
    {
        CloseHandle(hEvent);
    }


    HANDLE GetEventHandle(void) const
    {
        return hEvent;
    }


    HRESULT GetStatus(void) const
    {
        return static_cast<HRESULT>(Internal);
    }
};



static void WaitForIoEnd(CSyncPutPacketOv* pov)
/*++
Routine Description:
   Wait until IO operation ends.

Arguments:
   	pov - overlapp to wait on.

Returned Value:
    None.

Note:
--*/
{
    DWORD rc = WaitForSingleObject(pov->GetEventHandle(), INFINITE);
    if (rc == WAIT_FAILED)
    {
    	DWORD gle = GetLastError();
		TrERROR(GENERAL, "Storing packet Failed. WaitForSingleObject Returned error. Error: %x", gle);
        throw bad_win32_error(gle);
    }

	ASSERT(rc == WAIT_OBJECT_0);
	
    if (FAILED(pov->GetStatus()))
    {
		TrERROR(GENERAL, "Storing packet Failed Asyncronusly. Error: %x", rc);
        LogHR(rc, s_FN, 20);
        throw exception();
    }
}


void static WINAPI HandlePutPacket(EXOVERLAPPED* pov)
/*++
Routine Description:
    Check the result of async put packet routine and throw the exception if any
    problem occured

Arguments:
   	pov - overlapp that pointing to the stored packet and additional information
	needed to be written to the logger (stream information).

Returned Value:
    None.

Note:
--*/
{
	P<ACPutPacketOvl> pACPutPacketOvl = static_cast<ACPutPacketOvl*> (pov);
    HRESULT hr = (HRESULT)pACPutPacketOvl->Internal;

    if (FAILED(hr))
    {
		TrERROR(GENERAL, "Storing packet Failed Asyncronusly. Error: %x", hr);
    }
}


void static WINAPI HandlePutOrderedPacket(EXOVERLAPPED* pov)
/*++
Routine Description:
   Save the packet in the logger. This function is called after the order packet
   saved to disk/

Arguments:
   	pov - overlapp that pointing to the stored packet and additional information
	needed to be written to the logger (stream information).

Returned Value:
    None.

Note:
--*/
{
	P<ACPutPacketOvl> pACPutPacketOvl = static_cast<ACPutPacketOvl*> (pov);

    CQmPacket Pkt(
		pACPutPacketOvl->m_packetPtrs.pPacket,
		pACPutPacketOvl->m_packetPtrs.pDriverPacket
		);

	R<CInSequence> inseq = g_pInSeqHash->LookupSequence(&Pkt);
	ASSERT(inseq.get() != NULL);

	//
	// EVALUATE_OR_INJECT_FAILURE is used to simulate an asynchronous failure.
	//
	HRESULT hr = EVALUATE_OR_INJECT_FAILURE2(pACPutPacketOvl->GetStatus(), 10);
	if(FAILED(hr))
	{
		//
		// We need to delete all packets that started processing after this one,
		// because order of packet in queue is determined on receival.
		//
		inseq->FreePackets(&Pkt);
		return;
	}

	inseq->Register(&Pkt);
}

static
void
SyncPutPacket(
	const CQmPacket& pkt,
    const CQueue* pQueue
    )
/*++
Routine Description:
   Save packet in the driver queue and wait for completion.


Arguments:
	pkt - packet to save.
	pQueue - queue to save the packet into.

Returned Value:
    None.

--*/
{
	CSyncPutPacketOv ov;

    QmAcPutPacketWithOverlapped(
                pQueue->GetQueueHandle(),
                pkt.GetPointerToDriverPacket(),
                &ov,
                eDoNotDeferOnFailure
                );

	WaitForIoEnd(&ov);
}


static
void
AsyncPutPacket(
	const CQmPacket& Pkt,
    const CQueue* pQueue
    )
/*++
Routine Description:
   Save packet in the driver queue and wait for completion.


Arguments:
	pkt - packet to save.
	pQueue - queue to save the packet into.

Returned Value:
    None.

--*/
{
	P<ACPutPacketOvl> pACPutPacketOvl = new ACPutPacketOvl(HandlePutPacket);
										
	pACPutPacketOvl->m_packetPtrs.pPacket = Pkt.GetPointerToPacket();
    pACPutPacketOvl->m_packetPtrs.pDriverPacket = Pkt.GetPointerToDriverPacket();
    pACPutPacketOvl->m_hQueue    = pQueue->GetQueueHandle();

	QmAcPutPacketWithOverlapped(
						pQueue->GetQueueHandle(),
                        Pkt.GetPointerToDriverPacket(),
                        pACPutPacketOvl,
                        eDoNotDeferOnFailure
						);
	pACPutPacketOvl.detach();
}

static
void
AsyncPutOrderPacket(
					const CQmPacket& Pkt,
					const CQueue& Queue
					)
/*++
Routine Description:
   Store order packet in a queue asyncrounsly.

Arguments:
   		Pkt - packet to store
		Queue - queue to stote in the packet.
		

Returned Value:
    None.

Note:
After this   asyncrounsly operation ends the packet is still invisible to application.
Only after it is written to the logger - the logger callback make it visible according to the correct
order.

--*/
{
	ASSERT(Pkt.IsEodIncluded());
	P<ACPutPacketOvl> pACPutPacketOvl = 	new ACPutPacketOvl(HandlePutOrderedPacket);
										
	pACPutPacketOvl->m_packetPtrs.pPacket = Pkt.GetPointerToPacket();
    pACPutPacketOvl->m_packetPtrs.pDriverPacket = Pkt.GetPointerToDriverPacket();
    pACPutPacketOvl->m_hQueue    = Queue.GetQueueHandle();
	

	HRESULT rc = ACPutPacket1(
						Queue.GetQueueHandle(),
                        Pkt.GetPointerToDriverPacket(),
                        pACPutPacketOvl
						);


    if(FAILED(rc))
    {
        TrERROR(GENERAL, "ACPutPacket1 Failed. Error: %x", rc);
        throw bad_hresult(rc);
    }
	pACPutPacketOvl.detach();
}



void
AppPacketNotAccepted(
    CQmPacket& pkt,
    USHORT usClass
    )
{
    QmAcFreePacket(
    			   pkt.GetPointerToDriverPacket(),
    			   usClass,
    			   eDeferOnFailure);
}



bool
AppPutOrderedPacketInQueue(
    CQmPacket& pkt,
    const CQueue* pQueue
    )
{
	ASSERT(pkt.IsEodIncluded());

	R<CInSequence> pInSeq = g_pInSeqHash->LookupCreateSequence(&pkt);
	CS lock(pInSeq->GetCriticalSection());

	//
	// Verify that the packet is in the right order
	//

	if(!pInSeq->VerifyAndPrepare(&pkt, pQueue->GetQueueHandle()))
	{
		TrERROR(SRMP,
	        "Http Packet rejectet because of wrong order : SeqID=%x / %x , SeqN=%d ,Prev=%d",
	        HIGH_DWORD(pkt.GetSeqID()),
	        LOW_DWORD(pkt.GetSeqID()),
	        pkt.GetSeqN(),
	        pkt.GetPrevSeqN()
	        );

		return false;
	}

	AsyncPutOrderPacket(pkt, *pQueue);
	pInSeq->Advance(&pkt);

	return true;
}



void
AppPutPacketInQueue(
    CQmPacket& pkt,
    const CQueue* pQueue,
    bool bMulticast
	)
/*++
Routine Description:
   Save packet in the driver queue.

Arguments:
    pkt - packet to save.
	pQueue - queue to save the packet into.
	

Returned Value:
    None.

--*/
{
    if( bMulticast )
    {
        AsyncPutPacket(pkt,pQueue);
        return;
    }

    //
    // We don't need ordering - save it syncrounosly and make it visible to application.
    //
    SyncPutPacket(pkt, pQueue);
}

bool AppIsDestinationAccepted(const QUEUE_FORMAT* pfn, bool fTranslated)
/*++
Routine Description:
   Determine if the incoming message contain the valid destination queue format

Arguments:

	pfn - QUEUE_FORMAT of incoming message
	

Returned Value:
    None.

--*/
{
    //
    // We always accept the multicast queues
    //
    if( pfn->GetType() == QUEUE_FORMAT_TYPE_MULTICAST )
    {
        return true;
    }

    //
    // Check that destination queue is local or there is a translation exist,
    // in other words - do not allow http routing on non-transparent SFD machines
    //
    R<CQueue> pQueue;
    HRESULT   hr = QueueMgr.GetQueueObject( pfn, &pQueue.ref(), 0, false, false);

    if( FAILED(hr) || pQueue.get() == NULL)
    {
        TrERROR(SRMP, "Packet rejected because queue was not found");
        return false;
    }

    if( !pQueue->IsLocalQueue() && !fTranslated && !QueueMgr.GetMQSTransparentSFD())
    {	
        TrERROR(SRMP, "Packet rejectet because http routing is not supported");
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\ise2qm_s_.c ===
#pragma warning(push, 3)
#include <ise2qm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\initmclistener.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    InitMcListener.cpp

Abstract:
    Initialize Multicast listener

Author:
    Uri Habusha (urih) 26-Sep-2000

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "Mc.h"
#include "Msm.h"
#include "Fn.h"
#include "mqexception.h"
#include "lqs.h"
#include "cqmgr.h"

#include "InitMcListener.tmh"

static WCHAR *s_FN=L"Initmclistener";

static LPWSTR GetMulticastAddress(HLQS hLqs)
{
    PROPID aProp[2];
    PROPVARIANT aVar[2];
    ULONG cProps = 0;

    aProp[0] = PROPID_Q_MULTICAST_ADDRESS;
    aVar[0].vt = VT_NULL;
    ++cProps;

    //
    // Transactional queues ignore the multicast property. We allow setting the multicast
    // property for transactional queues since it's difficult to block it but do not bind.
    //
    aProp[1] = PROPID_Q_TRANSACTION;
    aVar[1].vt = VT_UI1;
    ++cProps;

    HRESULT hr = LQSGetProperties(hLqs, cProps, aProp, aVar);
    LogHR(hr, s_FN, 70);
    if (FAILED(hr))
        throw bad_hresult(hr);

    if (aVar[0].vt == VT_EMPTY)
        return NULL;

    if (aVar[1].bVal)
    {
        TrTRACE(NETWORKING, "Do not bind transactional queue to multicast address");
        return NULL;
    }

    ASSERT((aVar[0].pwszVal != NULL) && (aVar[0].vt == VT_LPWSTR));
    return aVar[0].pwszVal;
}


static void BindMulticast(const QUEUE_FORMAT& qf, LPCWSTR address)
{    
    MULTICAST_ID multicastId;

    try
    {
        FnParseMulticastString(address, &multicastId);
    }
    catch(const bad_format_name&)
    {
        //
        // If the multicast address isn't valid ignore the current address and
        // continue to procees the rest of the queues
        //
        EvReportWithError(MULTICAST_BIND_ERROR, MQ_ERROR_ILLEGAL_FORMATNAME, 1, address);
        LogIllegalPoint(s_FN, 50);
        return;
    }

    try
    {
        MsmBind(qf, multicastId);
    }
    catch (const bad_win32_error& e)
    {
        EvReportWithError(MULTICAST_BIND_ERROR, e.error(), 1, address);
        LogIllegalPoint(s_FN, 55);
    }
}


static bool InitMulticastPublicQueues(void)
    //
    // Enumerate local public queues in LQS.
    //
{
    GUID guid;
    HLQS hLQS;

    HRESULT hr = LQSGetFirst(&hLQS, &guid);

    for(;;)
    {
        //
        // No more queues
        //
        if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
            return true;

        //
        // Open a public queue store according to the queue GUID.
        //
        WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];
        CHLQS hLqsQueue;
        hr = LQSOpen(&guid, &hLqsQueue, szFilePath);
        if (FAILED(hr))
        {
            EvReportWithError(EVENT_ERROR_INIT_MULTICAST, hr, 1, szFilePath);
            LogHR(hr, s_FN, 60);
            return false;
        }

        AP<WCHAR> multicastAddress = GetMulticastAddress(hLqsQueue);

        if (multicastAddress != NULL)
        {
            BindMulticast(QUEUE_FORMAT(guid), multicastAddress);
        }

        hr = LQSGetNext(hLQS, &guid);
    }

    //
    // No need to close the enumeration handle in case LQSGetNext fails
    //
}


static bool InitMulticastPrivateQueues(void)
{
    //
    // Enumerate local public queues in LQS.
    //
    DWORD queueId;
    HLQS hLQS;

    HRESULT hr = LQSGetFirst(&hLQS, &queueId);

    for(;;)
    {
        //
        // No more queues
        //
        if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
            return true;

        //
        // Open a private queue store according to the queue id.
        //
        WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];
        CHLQS hLqsQueue;
        hr = LQSOpen(queueId, &hLqsQueue, szFilePath);
        if (FAILED(hr))
        {
            EvReportWithError(EVENT_ERROR_INIT_MULTICAST, hr, 1, szFilePath);
            return false;
        }

        AP<WCHAR> multicastAddress = GetMulticastAddress(hLqsQueue);

        if (multicastAddress != NULL)
        {
            BindMulticast(QUEUE_FORMAT(McGetMachineID(), queueId), multicastAddress);
        }

        hr = LQSGetNext(hLQS, &queueId);
    }

    //
    // No need to close the enumeration handle in case LQSGetNext fails
    //
}


bool QmpInitMulticastListen(void)
{
	//
	// If the QM is offline. Report to Multicast that it should be offline and return.
	// binding of queues to multicast address is done when the QM becomes active.
	//
	if (!QueueMgr.IsConnected())
	{
		MsmDisconnect();
		return true;
	}

    if (!InitMulticastPublicQueues())
    {
    	LogIllegalPoint(s_FN, 30);
        return false;
    }

    if (!InitMulticastPrivateQueues())
    {
    	LogIllegalPoint(s_FN, 40);
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\inrcv.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    inrcv.h

Abstract:
	header for functions that handlers incomming message.					

Author:
    Gil Shafriri 4-Oct-2000

Environment:
    Platform-independent

--*/
class  CQmPacket;
class  CQueue;

bool AppPutOrderedPacketInQueue(CQmPacket& pkt, const CQueue* pQueue);
void AppPutPacketInQueue( CQmPacket& pkt, const CQueue* pQueue, bool bMulticast);
void AppPacketNotAccepted(CQmPacket& pkt,USHORT usClass);
bool AppIsDestinationAccepted(const QUEUE_FORMAT* pfn, bool fTranslated);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\httpaccept.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    HttpAccept.cpp

Abstract:
    Http Accept implementation

Author:
    Uri Habusha (urih) 14-May-2000

Environment:
    Platform-independent,

--*/

#include <stdh.h>
#include <mqstl.h>
#include <xml.h>
#include <tr.h>
#include <ref.h>
#include <Mp.h>
#include <Fn.h>
#include "qmpkt.h"
#include "cqueue.h"
#include "cqmgr.h"
#include "inrcv.h"
#include "ise2qm.h"
#include "rmdupl.h"
#include "HttpAccept.h"
#include "HttpAuthr.h"
#include "perf.h"
#include "privque.h"
#include <singelton.h>

#include "httpAccept.tmh"
#include "privque.h"
#include "timeutl.h"
#include <singelton.h>

static WCHAR *s_FN=L"HttpAccept";

using namespace std;



const char xHttpOkStatus[] = "200 OK";
const char xHttpBadRequestStatus[] =  "400 Bad Request";
const char xHttpNotImplemented[] = "501 Not Implemented";
const char xHttpInternalErrorStatus[] = "500 Internal Server Error";
const char xHttpEntityTooLarge[]= "413 Request Entity Too Large";
const char xHttpServiceUnavailable[]= "503 Service Unavailable";





//-------------------------------------------------------------------
//
// CPutHttpRequestOv class
//
//-------------------------------------------------------------------
class CPutHttpRequestOv : public OVERLAPPED
{
public:
    CPutHttpRequestOv()
    {
        memset(static_cast<OVERLAPPED*>(this), 0, sizeof(OVERLAPPED));

        hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (hEvent == NULL)
        {
            TrERROR(SRMP, "Failed to create event for HTTP AC put request. Error %d", GetLastError());
            LogIllegalPoint(s_FN, 10);
            throw exception();
        }

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR) hEvent | (DWORD_PTR)0x1);

    }


    ~CPutHttpRequestOv()
    {
        CloseHandle(hEvent);
    }


    HANDLE GetEventHandle(void) const
    {
        return hEvent;
    }


    HRESULT GetStatus(void) const
    {
        return static_cast<HRESULT>(Internal);
    }
};


static
USHORT
VerifyTransactRights(
    const CQmPacket& pkt,
    const CQueue* pQueue
    )
{
    if(pkt.IsOrdered() == pQueue->IsTransactionalQueue())
        return MQMSG_CLASS_NORMAL;

    if (pkt.IsOrdered())
        return MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q;

    return MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG;
}



static
R<CQueue>
GetDestinationQueue(
    const CQmPacket& pkt
    )
{
    //
    // Get Destination queue
    //
    QUEUE_FORMAT destQueue;
    const_cast<CQmPacket&>(pkt).GetDestinationQueue(&destQueue);

	//
	// we convert all '\' to '/' for canonic lookup.
	//
	if(destQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
	{
		FnReplaceBackSlashWithSlash(const_cast<LPWSTR>(destQueue.DirectID()));
	}

    CQueue* pQueue = NULL;
    QueueMgr.GetQueueObject(&destQueue, &pQueue, 0, false, false);

    return pQueue;
}


static
bool
VerifyDuplicate(
	const CQmPacket& pkt,
	bool* pfDupInserted,
	BOOL fLocalDest
	)
{
	
	if(pkt.IsOrdered() && fLocalDest)
	{
		*pfDupInserted = false;
		return true;
	}

	bool fRet =  DpInsertMessage(pkt) == TRUE;
	*pfDupInserted = fRet;
	return fRet;
}



static
void
ProcessReceivedPacket(
    CQmPacket& pkt,
    bool bMulticast
    )
{

    ASSERT(! pkt.IsSessionIncluded());

	//
	// Log to tracing that a message was Received.
	// Do this only if we are in the proper tracing level
	//
	if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
	{
		OBJECTID TraceMessageId;
		pkt.GetMessageId(&TraceMessageId);
		TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls  ID:%!guid!\\%u   Delivery:0x%x   Class:0x%x   Label:%.*ls",
			L"HTTP/MULTICAST Message arrived in QM - Before insertion into queue",
			L"Unresolved yet",
			&TraceMessageId.Lineage,
			TraceMessageId.Uniquifier,
			pkt.GetDeliveryMode(),
			pkt.GetClass(),
			xwcs_t(pkt.GetTitlePtr(), pkt.GetTitleLength()));
	}

    try
    {
        //
        // Increment Hop Count
        //
        pkt.IncHopCount();

        R<CQueue> pQueue = GetDestinationQueue(pkt);
        if(pQueue.get() == NULL)
        {
			TrERROR(SRMP, "Packet rejected because queue was not found");
            AppPacketNotAccepted(pkt, MQMSG_CLASS_NACK_BAD_DST_Q);
            return;
        }

		bool	fDupInserted;
		if(!VerifyDuplicate(pkt , &fDupInserted, pQueue->IsLocalQueue()))
		{
			TrERROR(SRMP, "Http Duplicate Packet rejected");
			AppPacketNotAccepted(pkt, 0);
            return;
		}
		
		//
		// If the packet was inserted to the remove duplicate map - we should clean it on rejection
		//
		CAutoDeletePacketFromDuplicateMap AutoDeletePacketFromDuplicateMap(fDupInserted ? &pkt : NULL);

		//
		// If not local queue  - queue it for delivery if it is frs.
		//
		if(!pQueue->IsLocalQueue())
		{
			AppPutPacketInQueue(pkt, pQueue.get(), bMulticast);
			AutoDeletePacketFromDuplicateMap.detach();
			return;
		}
		
		if ((pQueue->IsSystemQueue()) && (pQueue->GetPrivateQueueId() != ORDERING_QUEUE_ID))
		{
			TrERROR(SRMP, "Packet rejected, Can not send message to internal system queue");
            AppPacketNotAccepted(pkt, MQMSG_CLASS_NACK_BAD_DST_Q);
            return;
		}
	
	    //
        //  Match ordered packets with transactional queue
        //
        USHORT usClass = VerifyTransactRights(pkt, pQueue.get());
        if(MQCLASS_NACK(usClass))
        {
			TrERROR(SRMP, "Http Packet rejected because wrong transaction usage");
            AppPacketNotAccepted(pkt, 0);
            return;
        }

		//
		// Verify that HTTP packet destination dont receive only encrypted messages
		//
		if(pQueue->GetPrivLevel() == MQ_PRIV_LEVEL_BODY)
		{
			TrERROR(SRMP, "HTTP packet rejected because destination queue receives only encrypted messages");
			AppPacketNotAccepted(pkt, MQMSG_CLASS_NACK_ACCESS_DENIED);
			return;
		}

	    //
	    // After Authentication the message we know the SenderSid
	    // and perform the Authorization based on the SenderSid
	    //
		R<CERTINFO> pCertInfo;
	    usClass = VerifyAuthenticationHttpMsg(&pkt, pQueue.get(), &pCertInfo.ref());
        if(MQCLASS_NACK(usClass))
        {
			TrERROR(SRMP, "Http Packet rejected because of bad signature");
            AppPacketNotAccepted(pkt, usClass);
            return;
        }

    	usClass = VerifyAuthorizationHttpMsg(
						pQueue.get(),
						(pCertInfo.get() == NULL) ? NULL : pCertInfo->pSid
						);

        if(MQCLASS_NACK(usClass))
        {
			TrERROR(SRMP, "Http Packet rejected because access was denied");
            AppPacketNotAccepted(pkt, usClass);
            return;
        }

						
		if(pkt.IsOrdered())
		{
        	if(!AppPutOrderedPacketInQueue(pkt, pQueue.get()))
        	{
	            AppPacketNotAccepted(pkt, usClass);
	            return;
        	}

		}
		else
		{
        	AppPutPacketInQueue(pkt, pQueue.get(), bMulticast);
		}
		AutoDeletePacketFromDuplicateMap.detach();

		//
		// Log to tracing that a message was Received.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			OBJECTID TraceMessageId;
			pkt.GetMessageId(&TraceMessageId);
			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls  ID:%!guid!\\%u   Delivery:0x%x   Class:0x%x   Label:%.*ls",
				L"HTTP/MULTICAST Message arrived in QM - After insertion into queue",
				pQueue.get()->GetQueueName(),
				&TraceMessageId.Lineage,
				TraceMessageId.Uniquifier,
				pkt.GetDeliveryMode(),
				pkt.GetClass(),
				xwcs_t(pkt.GetTitlePtr(), pkt.GetTitleLength()));
		}
    }
    catch (const exception&)
    {
		TrERROR(SRMP, "Http Packet rejected because of unknown exception");
        AppPacketNotAccepted(pkt, 0);
        LogIllegalPoint(s_FN, 20);
        throw;
    }

}

static
void CheckReceivedPacketEndpoints( CQmPacket& pkt, const QUEUE_FORMAT* pqf )
{
    //
    // We don't support non-http destination for non-multicast queues.
    //
    if( !pqf )
    {
        QUEUE_FORMAT destQueue, adminQueue;

        //
        // Check the destination queue for http format complience
        //
        pkt.GetDestinationQueue(&destQueue);

        if( !FnIsDirectHttpFormatName(&destQueue) )
        {
            ASSERT(QUEUE_FORMAT_TYPE_UNKNOWN != destQueue.GetType());
            if(WPP_LEVEL_COMPID_ENABLED(rsError, NETWORKING))
            {
                std::wostringstream stm;
                stm << CFnSerializeQueueFormat(destQueue);
                TrERROR(SRMP, "Http Packet rejected because of remote non-http destination: %ls", stm.str().c_str());
            }
            throw bad_srmp();
        }

        //
        // Check the admin queue for http format complience
        //
        pkt.GetAdminQueue(&adminQueue);
        if( QUEUE_FORMAT_TYPE_UNKNOWN != adminQueue.GetType() &&
            !FnIsDirectHttpFormatName(&adminQueue))
        {
            if(WPP_LEVEL_COMPID_ENABLED(rsError, NETWORKING))
            {
                std::wostringstream stm;
                stm << CFnSerializeQueueFormat(adminQueue);
                TrERROR(SRMP, "Http Packet rejected because of remote non-http admin queue: %ls", stm.str().c_str());
            }
            throw bad_srmp();
        }
    }
}


CQmPacket*
MpSafeDeserialize(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf,
	bool fLocalSend
    )
/*++

Routine Description:
	This function will catch stack overflow exceptions and fix stack if they happen.
	it will not catch other C exceptions & C++ exceptions
	
Arguments:
    Like MpDeserialize.

Return Value:
	CQmPacket - Success
	NULL - stack overflow exception happened.
	
--*/
{
    __try
    {
		return MpDeserialize(httpHeader, bodySize, body,  pqf, fLocalSend);
    }
	__except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
	{
     	_resetstkoflw();
        TrERROR(SRMP, "Http Packet rejected because of stack overflow");
        ASSERT_BENIGN(0);
	}
   	return NULL;
}


LPCSTR
HttpAccept(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf
    )
{
    bool bMulticast = ( pqf != NULL );
    //
    // Covert Mulitipart HTTP request to MSMQ packet
    //
    P<CQmPacket> pkt = MpSafeDeserialize(httpHeader, bodySize, body,  pqf, false);
    if (pkt.get() == NULL)
    {
    	return xHttpEntityTooLarge;
    }

    ASSERT(pkt->IsSrmpIncluded());

    //
    // Check the packet for non-http destination and admin queues
    //
    CheckReceivedPacketEndpoints(*pkt,pqf);

    //
    // Validate the receive packet. If wrong return an acknowledge and free
    // the packet. Otherwise store in AC
    //
    ProcessReceivedPacket(*pkt, bMulticast);

    return xHttpOkStatus;
}


void UpdatePerfmonCounters(DWORD bytesReceived)
{
	CSingelton<CInHttpPerfmon>::get().UpdateBytesReceived(bytesReceived);
	CSingelton<CInHttpPerfmon>::get().UpdateMessagesReceived();
}


extern "C"
LPSTR
R_ProcessHTTPRequest(
    handle_t,
    LPCSTR Headers,
    DWORD BufferSize,
    BYTE __RPC_FAR Buffer[]
    )
{	
	if(!QueueMgr.IsConnected())
	{
		TrERROR(SRMP, "Reject HTTP packet since the QM is offline.");
		return newstr(xHttpServiceUnavailable);
	}

	const char xPost[] = "POST";
	bool fFound = UtlIsStartSec(
							Headers,
							Headers+strlen(Headers),
							xPost,
							xPost + STRLEN(xPost),
							UtlCharNocaseCmp<char>()
							);
	if (!fFound)
	{
		ASSERT_BENIGN(("Unexpected HTTP method", 0));
		TrERROR(SRMP, "Reject HTTP packet since the request method isn't POST. HTTP Header: %s", Headers);
		return newstr(xHttpNotImplemented);
	}

	TrTRACE(SRMP, "Got http messages from msmq extension dll ");

    //
	// Update performace counters
	//
	UpdatePerfmonCounters(strlen(Headers) + BufferSize);

	//
	// here we must verify that we have four zeros at the end
	// of the buffer. It was appended by the mqise.dll to make sure
	// that c run time functions like swcanf we will use on the buffer will not crach.
	// At the moment 4 zeros are needed to make sure we will not crach even
	// that the xml data is not alligned on WCHAR boundary
	//
	DWORD ReduceLen =  sizeof(WCHAR)*2;
    for(DWORD i=1; i<= ReduceLen ; ++i)
	{
	    if(Buffer[BufferSize - i] != 0)
        {
            TrERROR(SRMP, "Reject HTTP packet since it does not meet ISE2QM requirements");
            return newstr(xHttpBadRequestStatus);
        }
	}

	//
	//  We must tell the buffer parsers that the real size does not includes
	//	The four zedros at the end
	BufferSize -= ReduceLen;
	
    try
    {
       LPCSTR status = HttpAccept(Headers, BufferSize, Buffer, NULL);
       return newstr(status);
    }
    catch(const bad_document&)
    {
        return newstr(xHttpBadRequestStatus);
    }
    catch(const bad_srmp&)
    {
        return newstr(xHttpBadRequestStatus);
    }
    catch(const bad_request&)
    {
        return newstr(xHttpBadRequestStatus);
    }

	catch(const bad_format_name& )
	{
	    return newstr(xHttpBadRequestStatus);
	}

	catch(const bad_time_format& )
	{
	    return newstr(xHttpBadRequestStatus);
	}

	catch(const bad_time_value& )
	{
	    return newstr(xHttpBadRequestStatus);
	}

	catch(const bad_packet_size&)
	{
		return newstr(xHttpEntityTooLarge);
	}

    catch(const std::bad_alloc&)
    {
        TrERROR(SRMP, "Failed to handle HTTP request due to low resources");
        LogIllegalPoint(s_FN, 30);
        return newstr(xHttpInternalErrorStatus);
    }
	catch(const std::exception&)
    {
        TrERROR(SRMP, "Failed to handle HTTP request due to unknown exception");
        LogIllegalPoint(s_FN, 40);
        return newstr(xHttpInternalErrorStatus);
    }

}

RPC_STATUS RPC_ENTRY ISE2QMSecurityCallback(
	RPC_IF_HANDLE ,
	void* hBind
	)
{	
	TrTRACE(RPC, "ISE2QMSecurityCallback starting");
	
	//
	// Check if local RPC
	//
	if(!mqrpcIsLocalCall(hBind))
	{
		TrERROR(RPC, "Failed to verify Local RPC");
		ASSERT_BENIGN(("Failed to verify Local RPC", 0));
		return ERROR_ACCESS_DENIED;
	}
	
	TrTRACE(RPC, "ISE2QMSecurityCallback passed successfully");
	return RPC_S_OK;
}

void IntializeHttpRpc(void)
{
    //
    // The limitation on HTTP body size is taken from msmq ISAPI extension code (mqise.cpp)
    // ISAPI does not allow HTTP body to be greater than 10MB
    // the size of RPC-block should be not greater than maximal HTTP body + delta
    //
    const DWORD xHTTPBodySizeMaxValue = 10485760;  // 10MB = 10 * 1024 * 1024

    RPC_STATUS status = RpcServerRegisterIf2(
				            ISE2QM_v1_0_s_ifspec,
                            NULL,
                            NULL,
				            RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
				            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
				            xHTTPBodySizeMaxValue + 1024,	
				            ISE2QMSecurityCallback
				            );

    if(status != RPC_S_OK)
    {
        TrERROR(SRMP, "Failed to initialize HTTP RPC. Error %x", status);
        LogRPCStatus(status, s_FN, 50);
        throw exception();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\joinstat.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    joinstat.h

Abstract:

    Handle the case where workgroup machine join a domain, or domain
    machine leave the domain.

Author:

    Doron Juster  (DoronJ)
    Ilan Herbst   (ilanh)  20-Aug-2000

--*/

void HandleChangeOfJoinStatus();

void SetMachineForDomain();

bool SetMachineSidCacheForAlwaysWorkgroup();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\license.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    license.cpp

Abstract:
    Handle licensing issues

Author:
    Doron Juster  (DoronJ)  04-May-1997   Created

--*/

#include "stdh.h"
#include "license.h"
#include "qmutil.h"
#include <strsafe.h>

#include "license.tmh"

extern DWORD g_dwOperatingSystem;

static WCHAR *s_FN=L"license";

template<>
void AFXAPI DestructElements(ClientInfo ** ppClientInfo, int n)
{
    int i;
    for (i=0;i<n;i++)
	{
		delete [] (*ppClientInfo)->lpClientName;
        delete *ppClientInfo++;
	}
}


//
// global object which keep the licensing data.
//
CQMLicense  g_QMLicense ;

//
// CQMLicense::CQMLicense()
// constructor.
//
CQMLicense::CQMLicense()
{
 
	m_dwLastEventTime = 0;
}

//
// CQMLicense::~CQMLicense()
// destructor.
//
CQMLicense::~CQMLicense()
{
}

//
// CQMLicense::Init()
//
// Initialize the object.
// At present, read licensing data from registry.
// Future: read from license mechanism of NT.
//
HRESULT
CQMLicense::Init()
{
	//
	// Assume no licensing data - until we read it from the registry
	//
    m_fPerServer = FALSE ;

	if(OS_SERVER(g_dwOperatingSystem))
	{

		//
		// Read number of CALs for servers
		//
        //
        // NT4 has bug in licensing server when mode is per-server. So we
        // read the mode and number of cals. If mode is per-server then we
        // count the cals ourselves and do not use NT license apis.
        //

        HKEY  hKey ;
        LONG rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\LicenseInfo\\FilePrint",
                               0L,
                               KEY_READ,
                               &hKey);
        if (rc == ERROR_SUCCESS)
        {
            DWORD dwMode ;
            DWORD dwSize = sizeof(DWORD) ;
            DWORD dwType = REG_DWORD ;
            rc = RegQueryValueEx(hKey,
                                 L"Mode",
                                 NULL,
                                 &dwType,
                                 (BYTE*)&dwMode,
                                 &dwSize) ;
            if ((rc == ERROR_SUCCESS) && (dwMode == 1))
            {
                ASSERT(dwSize == sizeof(DWORD)) ;
                ASSERT(dwType == REG_DWORD) ;

                //
                // Per-server. read number of cals.
                //
                DWORD dwCals ;
                rc = RegQueryValueEx(hKey,
                                     L"ConcurrentLimit",
                                     NULL,
                                     &dwType,
                                     (BYTE*)&dwCals,
                                     &dwSize) ;
                if (rc == ERROR_SUCCESS)
                {
                    m_fPerServer = TRUE ;
                    m_dwPerServerCals = dwCals ;
                }
            }
        }
	}

    return MQ_OK ;
}

//
// CQMLicense::IncrementActiveConnections
//
//  Update the number of active session after creating a new session
//
//  This routine always increment a connection. Checking if it is legal to
//  increment the connections is done in NewConnectionAllowed
//
//
void
CQMLicense::IncrementActiveConnections(
    CONST GUID* pGuid,
    LPWSTR lpwClientName
    )
{
    CS lock(m_cs);

    ClientInfo * pClientInfo;

	//
	// If connection already counted, 
	// increment reference count and return
	//
    if (m_MapQMid2ClientInfo.Lookup(*pGuid, pClientInfo))
    {
        pClientInfo->dwRefCount++ ;

        TrTRACE(
            NETWORKING,
            "License::Increment ref count of " LOG_GUID_FMT " to %d",
            LOG_GUID(pGuid),
            pClientInfo->dwRefCount
            );

	    return;
    }
    
    //
    // Consume a CAL on servers
    //
    bool fConsumedLicense = false;
    if (OS_SERVER(g_dwOperatingSystem))
    {
        fConsumedLicense = GetNTLicense();
    }

    //
    // Keep info of the new connection
    //
    pClientInfo = new ClientInfo;
    pClientInfo->fConsumedLicense = fConsumedLicense;
    pClientInfo->dwRefCount = 1;
    if (lpwClientName)
    {
        pClientInfo->dwNameLength = wcslen( lpwClientName) + 1;
        pClientInfo->lpClientName = new WCHAR[ pClientInfo->dwNameLength];
        HRESULT hr = StringCchCopy(pClientInfo->lpClientName, pClientInfo->dwNameLength, lpwClientName);
        ASSERT(SUCCEEDED(hr));
        DBG_USED(hr);
    }
    else
    {
        pClientInfo->dwNameLength = 0 ;
        pClientInfo->lpClientName = NULL ;
    }
    
    m_MapQMid2ClientInfo[ *pGuid ] = pClientInfo ;
    
    TrTRACE(NETWORKING, "License::Add computer " LOG_GUID_FMT, LOG_GUID(pGuid));
    
    TrTRACE(NETWORKING, "License::Current number of license connections incremented to %d",
        m_MapQMid2ClientInfo.GetCount());
}

//
// CQMLicense::DecrementActiveConnections
//
//  Update the number of active connections after closing a session or
//  closing a connection with dependent client / remote-read clients.
//
void
CQMLicense::DecrementActiveConnections(CONST GUID *pGuid)
{
    CS lock(m_cs);
    ClientInfo * pClientInfo ;
    
    if (m_MapQMid2ClientInfo.Lookup(*pGuid, pClientInfo))
    {
        pClientInfo->dwRefCount--;
        TrTRACE(NETWORKING, "License::Decrement ref count of " LOG_GUID_FMT " to %d",
                LOG_GUID(pGuid), pClientInfo->dwRefCount);

        if (pClientInfo->dwRefCount <= 0)
        {
            //
            // release the license
            //
            if (pClientInfo->fConsumedLicense)
            {
                ReleaseNTLicense();
            }

            //
            // remove client from license list.
            //
            BOOL f = m_MapQMid2ClientInfo.RemoveKey(*pGuid) ;
            ASSERT(f) ;
			DBG_USED(f);
        }
    }


    TrTRACE(NETWORKING, "License::Current number of license connections is %d",
                m_MapQMid2ClientInfo.GetCount());
};

//****************************************************************
//
//  void CQMLicense::ReleaseNTLicense()
//
//****************************************************************

void CQMLicense::ReleaseNTLicense(void)
{
    if (m_fPerServer)
    {
        m_dwPerServerCals++ ;
    }
}

//****************************************************************
//
//  bool CQMLicense::GetNTLicense()
//
//  Request a CAL from the NT license manager
//
//****************************************************************

bool CQMLicense::GetNTLicense(void)
{
    if (!m_fPerServer)
    	return true;
    
    if (m_dwPerServerCals == 0)
        return false;

    m_dwPerServerCals--;
    return true;
}

//
// CQMLicense::IsClientRPCAccessAllowed(GUID *pGuid)
//
// Check if remote machine can access (as far as license is concerned) the
// server.
//
BOOL
CQMLicense::IsClientRPCAccessAllowed(GUID* pGuid, LPWSTR lpwClientName)
{
    if (!NewConnectionAllowed(TRUE, pGuid))
    {
        return LogBOOL(FALSE, s_FN, 10);
    }

    IncrementActiveConnections(pGuid, lpwClientName);
    return TRUE ;
}

//
// CQMLicense::NewConnectionAllowed()
//
// Check if this machine can create a new connection with another
// machine.
// Params: fWorkstation - we want a connection with NTW or Win95
//         pGuid is the QM Guid of the other machine.
//
BOOL
CQMLicense::NewConnectionAllowed(BOOL   fWorkstation,
                                 GUID * pGuid )
{
    CS lock(m_cs);
    
	//
	// Always allow a connection to a server
	//
	if(fWorkstation == FALSE)
		return(TRUE);

    if (!pGuid)
    {
       ASSERT(0) ;
       return LogBOOL(FALSE, s_FN, 20);
	}

#ifdef _DEBUG
    if (memcmp(pGuid, &GUID_NULL, sizeof(GUID)) == 0)
    {
       ASSERT(0) ;
    }
#endif

    CS Lock(m_cs) ;

    ClientInfo * pClientInfo;

	//
	// We already have a connection - so we allow a new one
	//
    if (m_MapQMid2ClientInfo.Lookup(*pGuid, pClientInfo))
		return(TRUE);

	//
	// If we are NTW or Win95, count max number of allowed connections
	//
    if(!OS_SERVER(g_dwOperatingSystem))
		 return(m_MapQMid2ClientInfo.GetCount() < DEFAULT_FALCON_MAX_SESSIONS_WKS);

	//
	// We are a server, so check if enough CALs
	//	
	// 1. Consume a CAL
	//
	if(!GetNTLicense())
	{
		DisplayEvent(SERVER_NO_MORE_CALS);
		return(FALSE);
	}
    //
    // 2. And free it, if you have it. It will be re-aqcuired when the number
    // of connections is incremented.
    //
    ReleaseNTLicense();

	//
	// On NTE and NTS, no limits on number of connections.
	//
	return(TRUE);
}

//
// CQMLicense::GetClientNames()
//
// Allocates and returns the buffer with all client names
//  (to be released by caller)
void CQMLicense::GetClientNames(ClientNames **ppNames)
{
    CS Lock(m_cs) ;

    ClientInfo *pClientInfo;
    GUID        guid;

    // Calculate buffer length
    ULONG    len = sizeof(ClientNames);

    POSITION posInList = m_MapQMid2ClientInfo.GetStartPosition();
    while (posInList != NULL)
    {
        m_MapQMid2ClientInfo.GetNextAssoc(posInList, guid, pClientInfo);
        len += (pClientInfo->dwNameLength * sizeof(WCHAR));
    }

    // Allocate memory
    *ppNames = (ClientNames *) new UCHAR[len];

    // Fill the buffer
    (*ppNames)->cbBufLen  = len;
    WCHAR *pw = &(*ppNames)->rwName[0];

    ULONG ulCount = 0 ;
    posInList = m_MapQMid2ClientInfo.GetStartPosition();
    while (posInList != NULL)
    {
        m_MapQMid2ClientInfo.GetNextAssoc(posInList, guid, pClientInfo);
        if (pClientInfo->dwNameLength > 0)
        {
            CopyMemory(pw,
                       pClientInfo->lpClientName,
                       pClientInfo->dwNameLength * sizeof(WCHAR));
            pw += pClientInfo->dwNameLength;
            ulCount++ ;
        }
    }
    (*ppNames)->cbClients = ulCount ;
    ASSERT((int)ulCount <= m_MapQMid2ClientInfo.GetCount());
}


//
// Display an event in the event log file, in case 
// of a licensing error.
//
void CQMLicense::DisplayEvent(DWORD dwFailedError)
{
	DWORD t1;

	//
	// Get current time, and check that
	// last event was added more than 1hour ago.
	// (works correctly when GetTickCount wrap around)
	//
	t1 = GetTickCount();
	if(t1 - m_dwLastEventTime > 60 * 60 * 1000)
	{
		m_dwLastEventTime = t1;
		EvReport(dwFailedError);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\joinstat.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    joinstat.cpp

Abstract:

    Handle the case where workgroup machine join a domain, or domain
    machine leave the domain.

Author:		 

    Doron Juster  (DoronJ)
    Ilan  Herbst  (ilanh)  20-Aug-2000

--*/

#include "stdh.h"
#include <new.h>
#include <autoreln.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include "setup.h"
#include "cqmgr.h"
#include <adsiutil.h>
#include "..\ds\h\mqdsname.h"
#include "mqexception.h"
#include "uniansi.h"
#include <adshlp.h>
#include <dsgetdc.h>
#include "cm.h"
#include <strsafe.h>
#include <mqsec.h>

#define SECURITY_WIN32
#include <security.h>
#include <adsiutl.h>

#include "joinstat.tmh"


extern HINSTANCE g_hInstance;
extern BOOL      g_fWorkGroupInstallation;
extern LPTSTR       g_szMachineName;

enum JoinStatus
{
    jsNoChange,
    jsChangeDomains,
    jsMoveToWorkgroup,
    jsJoinDomain
};

static WCHAR *s_FN=L"joinstat";

static 
void
GetQMIDRegistry(
	OUT GUID* pQmGuid
	)
/*++
Routine Description:
	Get current QMID from registry.

Arguments:
	pQmGuid - [out] pointer to the QM GUID

Returned Value:
	None

--*/
{
	DWORD dwValueType = REG_BINARY ;
	DWORD dwValueSize = sizeof(GUID);

	LONG rc = GetFalconKeyValue(
					MSMQ_QMID_REGNAME,
					&dwValueType,
					pQmGuid,
					&dwValueSize
					);

	DBG_USED(rc);

	ASSERT(rc == ERROR_SUCCESS);
}


static 
LONG
GetMachineDomainRegistry(
	OUT LPWSTR pwszDomainName,
	IN OUT DWORD* pdwSize
	)
/*++
Routine Description:
	Get MachineDomain from MACHINE_DOMAIN registry.

Arguments:
	pwszDomainName - pointer to domain string buffer
	pdwSize - pointer to buffer length

Returned Value:
	None

--*/
{
    DWORD dwType = REG_SZ;
    LONG res = GetFalconKeyValue( 
					MSMQ_MACHINE_DOMAIN_REGNAME,
					&dwType,
					(PVOID) pwszDomainName,
					pdwSize 
					);
	return res;
}


static 
void
SetMachineDomainRegistry(
	IN LPCWSTR pwszDomainName
	)
/*++
Routine Description:
	Set new domain in MACHINE_DOMAIN registry

Arguments:
	pwszDomainName - pointer to new domain string

Returned Value:
	None

--*/
{
    DWORD dwType = REG_SZ;
    DWORD dwSize = (wcslen(pwszDomainName) + 1) * sizeof(WCHAR);

    LONG res = SetFalconKeyValue( 
					MSMQ_MACHINE_DOMAIN_REGNAME,
					&dwType,
					pwszDomainName,
					&dwSize 
					);

    ASSERT(res == ERROR_SUCCESS);
	DBG_USED(res);

	TrTRACE(GENERAL, "Set registry setup\\MachineDomain = %ls", pwszDomainName);
}


static 
LONG
GetMachineDNRegistry(
	OUT LPWSTR pwszComputerDN,
	IN OUT DWORD* pdwSize
	)
/*++
Routine Description:
	Get ComputerDN from MACHINE_DN registry.

	Note: we are using this function also to get MachineDN length
	by passing pwszComputerDN == NULL.
	in that case the return value of GetFalconKeyValue will not be ERROR_SUCCESS.

Arguments:
	pwszComputerDN - pointer to ComputerDN string
	pdwSize - pointer to buffer length

Returned Value:
	GetFalconKeyValue result

--*/
{
    DWORD  dwType = REG_SZ;

    LONG res = GetFalconKeyValue( 
					MSMQ_MACHINE_DN_REGNAME,
					&dwType,
					pwszComputerDN,
					pdwSize 
					);
	return res;
}


static 
void
SetMachineDNRegistry(
	IN LPCWSTR pwszComputerDN,
	IN ULONG  uLen
	)
/*++
Routine Description:
	Set new ComputerDN in MACHINE_DN registry

Arguments:
	pwszComputerDN - pointer to new ComputerDN string
	uLen - string length

Returned Value:
	None

--*/
{
    DWORD  dwSize = uLen * sizeof(WCHAR);
    DWORD  dwType = REG_SZ;

    LONG res = SetFalconKeyValue( 
					MSMQ_MACHINE_DN_REGNAME,
					&dwType,
					pwszComputerDN,
					&dwSize 
					);

    ASSERT(res == ERROR_SUCCESS);
	DBG_USED(res);

	TrTRACE(GENERAL, "Set registry setup\\MachineDN = %ls", pwszComputerDN);
}


static 
void
SetWorkgroupRegistry(
	IN DWORD dwWorkgroupStatus
	)
/*++
Routine Description:
	Set Workgroup Status in registry

Arguments:
	dwWorkgroupStatus - [in] Workgroup Status value

Returned Value:
	None

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    LONG res = SetFalconKeyValue(
					MSMQ_WORKGROUP_REGNAME,
					&dwType,
					&dwWorkgroupStatus,
					&dwSize 
					);
    ASSERT(res == ERROR_SUCCESS);
	DBG_USED(res);

	TrTRACE(GENERAL, "Set registry Workgroup = %d", dwWorkgroupStatus);
}


static 
LONG
GetAlwaysWorkgroupRegistry(
	OUT DWORD* pdwAlwaysWorkgroup
	)
/*++
Routine Description:
	Get Always Workgroup from registry.

Arguments:
	pdwAlwaysWorkgroup - [out] pointer to Always Workgroup value

Returned Value:
	None

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    LONG res = GetFalconKeyValue( 
					MSMQ_ALWAYS_WORKGROUP_REGNAME,
					&dwType,
					pdwAlwaysWorkgroup,
					&dwSize 
					);

	return res;
}


static void SetAlwaysWorkgroupRegistry()
/*++
Routine Description:
	Set Always Workgroup registry.

Arguments:
	None

Returned Value:
	None

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
	DWORD dwAlwaysWorkgroupStatus = 1;

    LONG res = SetFalconKeyValue(
					MSMQ_ALWAYS_WORKGROUP_REGNAME,
					&dwType,
					&dwAlwaysWorkgroupStatus,
					&dwSize 
					);

    ASSERT(res == ERROR_SUCCESS);
	DBG_USED(res);

	TrTRACE(GENERAL, "Set always workgroup, in this mode MSMQ will not join domain");
}


static void RemoveADIntegratedRegistry()
/*++
Routine Description:
	Remove ADIntegrated Registry.
	This simulate setup deselect of AD integration subcomponent.

	Note: this function uses MSMQ_REG_SETUP_KEY so it is not cluster aware.

Arguments:
	None

Returned Value:
	None

--*/
{
    const RegEntry xAdIntegratedReg(MSMQ_REG_SETUP_KEY, AD_INTEGRATED_SUBCOMP, 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
	CmDeleteValue(xAdIntegratedReg);

	TrWARNING(GENERAL, "AD_INTEGRATED_SUBCOMP was removed");
}


static 
HRESULT 
GetMsmqGuidFromAD( 
	IN WCHAR          *pwszComputerDN,
	OUT GUID          *pGuid 
	)
/*++
Routine Description:
	Get guid of msmqConfiguration object from active directory
	that match the Computer distinguish name supplied in pwszComputerDN.

Arguments:
	pwszComputerDN - computer distinguish name
	pGuid - pointer to guid

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    DWORD dwSize = wcslen(pwszComputerDN);
    dwSize += x_LdapMsmqConfigurationLen + 1;

    AP<WCHAR> pwszName = new WCHAR[dwSize];
	HRESULT hr = StringCchPrintf(pwszName, dwSize, L"%s%s", x_LdapMsmqConfiguration, pwszComputerDN);
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "StringCchPrintf failed, %!hresult!", hr);
        return hr;
	}

	TrTRACE(GENERAL, "configuration DN = %ls", pwszName);

	//
    // Bind to RootDSE to get configuration DN
    //
    R<IDirectoryObject> pDirObj = NULL;
	AP<WCHAR> pEscapeAdsPathNameToFree;
	
	hr = ADsOpenObject( 
				UtlEscapeAdsPathName(pwszName, pEscapeAdsPathNameToFree),
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IDirectoryObject,
				(void **)&pDirObj 
				);
    

    if (FAILED(hr))
    {
		TrWARNING(GENERAL, "Fail to Bind to RootDSE to get configuration DN, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 40);
    }

	TrTRACE(GENERAL, "bind to msmq configuration DN = %ls", pwszName);

    QmpReportServiceProgress();

    LPWSTR  ppAttrNames[1] = {const_cast<LPWSTR> (x_AttrObjectGUID)};
    DWORD   dwAttrCount = 0;
    ADS_ATTR_INFO *padsAttr = NULL;

    hr = pDirObj->GetObjectAttributes( 
						ppAttrNames,
						(sizeof(ppAttrNames) / sizeof(ppAttrNames[0])),
						&padsAttr,
						&dwAttrCount 
						);

    ASSERT(SUCCEEDED(hr) && (dwAttrCount == 1));

    if (FAILED(hr))
    {
		TrERROR(GENERAL, "Fail to get QM Guid from AD, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 50);
    }
    else if (dwAttrCount == 0)
    {
        ASSERT(!padsAttr) ;
        hr =  MQDS_OBJECT_NOT_FOUND;
    }
    else
    {
        ADS_ATTR_INFO adsInfo = padsAttr[0];
        hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;

        ASSERT(adsInfo.dwADsType == ADSTYPE_OCTET_STRING);

        if (adsInfo.dwADsType == ADSTYPE_OCTET_STRING)
        {
            DWORD dwLength = adsInfo.pADsValues->OctetString.dwLength;
            ASSERT(dwLength == sizeof(GUID));

            if (dwLength == sizeof(GUID))
            {
                memcpy( 
					pGuid,
					adsInfo.pADsValues->OctetString.lpValue,
					dwLength 
					);

				TrTRACE(GENERAL, "GetMsmqGuidFromAD, QMGuid = %!guid!", pGuid);
				
				hr = MQ_OK;
            }
        }
    }

    if (padsAttr)
    {
        FreeADsMem(padsAttr);
    }

    QmpReportServiceProgress();
    return LogHR(hr, s_FN, 60);
}


static bool NT4Domain()
/*++
Routine Description:
	Check if the machine is in NT4 domain

Arguments:
	None.

Returned Value:
	true if we are in NT4 domain, false otherwise.

--*/
{
	static bool s_fInitialized = false;
	static bool s_fNT4Domain = false;

	if(s_fInitialized)
	{
		return s_fNT4Domain;
	}

    PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					NULL, 
					NULL, 
					NULL, 
					NULL, 
					0,
					&pDcInfo
					);

	s_fInitialized = true;

	if(dw != NO_ERROR) 
	{
		//
		// Failed to find dc server. 
		//
		TrERROR(GENERAL, "Fail to verify if the machine domain is NT4 domain, %!winerr!", dw);
		return s_fNT4Domain;   // the Default = false
	}

	if((pDcInfo->DnsForestName == NULL) && ((pDcInfo->Flags && DS_LDAP_FLAG) == 0))
	{
		TrERROR(GENERAL, "machine Domain %ls is NT4 domain", pDcInfo->DomainName);
		s_fNT4Domain = true;
	}

	return s_fNT4Domain;
}


static void RemoveADIntegrated()
/*++
Routine Description:
	remove AD integration subcomponent.
	This is needed when the user try to join NT4 domain.
	Joining NT4 domain is only supported by msmq setup.
	The QM remove AD integrated subcomponent and ask the user to select AD integrated.

Arguments:
	None

Returned Value:
	None

--*/
{
	try
	{
		RemoveADIntegratedRegistry();
		SetAlwaysWorkgroupRegistry();
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to remove ADIntegrated subcomponent");
	}

}


static 
void 
GetComputerDN( 
	OUT WCHAR **ppwszComputerDN,
	OUT ULONG  *puLen 
	)
/*++
Routine Description:
	Get Computer Distinguish name.
	The function return the ComputerDN string and string length.
	the function throw bad_hresult() in case of errors

Arguments:
	ppwszComputerDN - pointer to computer distinguish name string
	puLen - pointer to computer distinguish name string length.

Returned Value:
	Normal terminatin if ok, else throw exception

--*/
{
    //
    // Get the DistinguishedName of the local computer.
    //
	DWORD gle = ERROR_SUCCESS;
    *puLen = 0;
	BOOL fSuccess = false;
	DWORD dwMaxRetries = 5;

	//
	// In case of failure, if the machine is a DC, we need to give it a lot more
	// retries since this may take a while after a DCPROMO operation was done
	//
	if (MQSec_IsDC())
	{
    	dwMaxRetries = 300;
		TrTRACE(GENERAL, "The machine is a DC. Increasing Number of GetComputerObjectName retries to:%d", dwMaxRetries);
	}

	
    for(DWORD Cnt = 0; Cnt < dwMaxRetries; Cnt++)
	{
		fSuccess = GetComputerObjectName( 
						NameFullyQualifiedDN,
						NULL,
						puLen 
						);

		gle = GetLastError();
		if(gle != ERROR_NO_SUCH_DOMAIN)
			break;

		if(NT4Domain())
		{
			//
			// In NT4 domain GetComputerObjectName() will always return ERROR_NO_SUCH_DOMAIN
			// We don't want to continue retrying in this case.
			// MSMQ doesn't support joining NT4 domain, we need the PEC\PSC name to work against.
			// The only option is to use MSMQ setup. 
			//
			// The workaround is to remove ADIntegrated subcomponent and issue EVENT_ERROR_JOIN_NT4_DOMAIN.
			// The event will ask the user to run setup and select ADIntegrated.
			//
			RemoveADIntegrated();
			TrERROR(GENERAL, "MSMQ doesn't support joining NT4 domain");
			throw bad_hresult(EVENT_ERROR_JOIN_NT4_DOMAIN);
		}

		//
		// Retry in case of ERROR_NO_SUCH_DOMAIN
		// netlogon need more time. sleep 1 sec.
		//
		TrWARNING(GENERAL, "GetComputerObjectName failed with error ERROR_NO_SUCH_DOMAIN, Cnt = %d, sleeping 1 seconds and retry", Cnt);
		LogNTStatus(Cnt, s_FN, 305);
		QmpReportServiceProgress();
		Sleep(1000);
	}
	
	if (*puLen == 0)
	{
		TrERROR(GENERAL, "GetComputerObjectName failed, error = 0x%x", gle);
		LogIllegalPoint(s_FN, 310);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}

    *ppwszComputerDN = new WCHAR[*puLen];

    fSuccess = GetComputerObjectName( 
					NameFullyQualifiedDN,
					*ppwszComputerDN,
					puLen
					);

	if(!fSuccess)
	{
        gle = GetLastError();
		TrERROR(GENERAL, "GetComputerObjectName failed, error = 0x%x", gle);
		LogIllegalPoint(s_FN, 320);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	
    QmpReportServiceProgress();
	TrTRACE(GENERAL, "ComputerDNName = %ls", *ppwszComputerDN);
}


void SetMachineForDomain()
/*++
Routine Description:
	Write ComputerDN (Computer Distinguish name) in MSMQ_MACHINE_DN_REGNAME registry.
	if the called GetComputerDN() failed, no update is done.

Arguments:
	None.

Returned Value:
	Normal terminatin if ok

--*/
{

    AP<WCHAR> pwszComputerDN;
    ULONG uLen = 0;

	try
	{
		//
		// throw bad_hresult() in case of errors
		//
		GetComputerDN(&pwszComputerDN, &uLen);
	}
	catch(bad_hresult&)
	{
		TrERROR(GENERAL, "SetMachineForDomain: GetComputerDN failed, got bad_hresult exception");
		LogIllegalPoint(s_FN, 330);
		return;
	}

	SetMachineDNRegistry(pwszComputerDN, uLen);
}


static 
void  
FailMoveDomain( 
	IN  LPCWSTR pwszCurrentDomainName,
	IN  LPCWSTR pwszPrevDomainName,
	IN  ULONG  uEventId 
	)
/*++
Routine Description:
	Report failed to move from one domain to another.

Arguments:
	pwszCurrentDomainName - pointer to current (new) domain string
	pwszPrevDomainName - pointer to previous domain string
	uEventId - event number

Returned Value:
	None

--*/
{
	TrERROR(GENERAL, "Failed To move from domain %ls to domain %ls", pwszPrevDomainName, pwszCurrentDomainName);

    TCHAR tBuf[256];
	StringCchPrintf(tBuf, TABLE_SIZE(tBuf), TEXT("%s, %s"), pwszPrevDomainName, pwszCurrentDomainName);

    EvReport(uEventId, 1, tBuf);
    LogIllegalPoint(s_FN, 540);
}


static 
void  
SucceedMoveDomain( 
	IN  LPCWSTR pwszCurrentDomainName,
	IN  LPCWSTR pwszPrevDomainName,
	IN  ULONG  uEventId 
	)
/*++
Routine Description:
	write new domain to MACHINE_DOMAIN registry and
	Report success to move from one domain to another.

Arguments:
	pwszCurrentDomainName - pointer to current (new) domain string
	pwszPrevDomainName - pointer to previous domain string
	uEventId - event number

Returned Value:
	None

--*/
{
	TrTRACE(GENERAL, "Succeed To move from domain %ls to domain %ls", pwszPrevDomainName, pwszCurrentDomainName);

    if (uEventId != 0)
    {
        EvReport(uEventId, 2, pwszCurrentDomainName, pwszPrevDomainName);
        LogIllegalPoint(s_FN, 550);
    }
}


static bool FindMsmqConfInOldDomain()    
/*++
Routine Description:
	Check if msmq configuration object is found in the old domain with the same GUID.
	If we find the object in the old domain we will use it and not create a new 
	msmq configuration object.

	Note: this function rely on the value in MSMQ_MACHINE_DN_REGNAME registry.
	SetMachineForDomain() change this value to the new MACHINE_DN after joining 
	the new domain. you must call this function before SetMachineForDomain() is called.

Arguments:
	None

Returned Value:
	true if msmq configuration object was found in the old domain with the same OM GUID.
	else false.

--*/
{
	//
    // Get old MACHINE_DN
	// Note this value must not be updated to the new MACHINE_DN
	// before calling this function
    //

    //
	// Get required buffer length
	//
	DWORD  dwSize = 0;
	GetMachineDNRegistry(NULL, &dwSize);

	if(dwSize == 0)
	{
		TrERROR(GENERAL, "CheckForMsmqConfInOldDomain: MACHINE_DN DwSize = 0");
		LogIllegalPoint(s_FN, 350);
		return false;
	}

    AP<WCHAR> pwszComputerDN = new WCHAR[dwSize];
	LONG res = GetMachineDNRegistry(pwszComputerDN, &dwSize);

    if (res != ERROR_SUCCESS)
	{
		TrERROR(GENERAL, "CheckForMsmqConfInOldDomain: Get MACHINE_DN from registry failed");
		LogNTStatus(res, s_FN, 360);
		return false;
	}

	TrTRACE(GENERAL, "CheckForMsmqConfInOldDomain: OLD MACHINE_DN = %ls", pwszComputerDN);

    HRESULT hr;
    GUID msmqGuid;
    hr = GetMsmqGuidFromAD( 
				pwszComputerDN,
				&msmqGuid 
				);

    if (FAILED(hr))
	{
		TrTRACE(GENERAL, "CheckForMsmqConfInOldDomain: did not found msmq configuration object in old domain, hr = 0x%x", hr);
        LogHR(hr, s_FN, 380);
		return false;
	}

	ASSERT(("found msmq configuration object in old domain with different QMID", msmqGuid == *QueueMgr.GetQMGuid()));

    if (msmqGuid == *QueueMgr.GetQMGuid())
    {
		//
        // msmqConfiguration object in old domain.
        // We consider this a success and write name of new
        // domain in registry. we also suggest the user to
        // move the msmq tree to the new domain.
        //
		TrTRACE(GENERAL, "CheckForMsmqConfInOldDomain: found msmq configuration object in old domain with same QMID, MACHINE_DN = %ls", pwszComputerDN);
		return true;
	}

	//
	// ISSUE-2000/08/16-ilanh - If we get here 
	// we found msmqConfiguration object from the old domain with different Guid then QueueMgr
	// this will be caught in the ASSERT above.
	// We are in trouble since we will try to create a new one, if we don't want to use this one.
	//
	TrERROR(GENERAL, "CheckForMsmqConfInOldDomain: found msmq configuration object in old domain with different QMID, MACHINE_DN = %ls", pwszComputerDN);
	LogBOOL(FALSE, s_FN, 390);
	return false;
}
	

static void SetQMIDChanged(void)
{
	//
	// This reg key indicates that we need to create a new msmq configuration object and will have a New QMID
	// It will be used by the driver to convert the QMID in the restored packets and to decide if we want
	// to throw away packets.
	//
	// If we failed to set this key, we don't continue creating a new MSMQ conf object.
	// This means that next recovery we'll still need to create a new MSMQ conf object and
	// try to set this flag again.
	//
	DWORD dwType = REG_DWORD;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwChanged = TRUE;
	LONG rc = SetFalconKeyValue(MSMQ_QM_GUID_CHANGED_REGNAME, &dwType, &dwChanged, &dwSize);
	if (rc != ERROR_SUCCESS)
	{
		TrERROR(GENERAL, "SetFalconKeyValue failed. Error: %!winerr!", rc);
		throw bad_hresult(HRESULT_FROM_WIN32(rc));
	}

	TrTRACE(GENERAL, "QM GUID Changed!!! Throwing away all trasnactional messages in outgoing queues!");
}

	
static void CreateNewMsmqConf()
/*++
Routine Description:
	Create New Msmq Configuration object in ActiveDirectory with new guid

	if failed the function throw bad_hresult.

Arguments:
	None

Returned Value:
	None

--*/
{  
    
	HRESULT hr;
	try
	{
		//
		// Must be inside try/except, so we catch any failure and set
		// again the workgroup flag to TRUE.
		//
		SetQMIDChanged();
		
		hr = CreateTheConfigObj();
    }
    catch(const exception&)
    {
		TrERROR(GENERAL, "CreateNewMsmqConf: got exception");
		hr = MQ_ERROR_CANNOT_JOIN_DOMAIN;
		LogIllegalPoint(s_FN, 80);
    }

	if(FAILED(hr))
	{
		TrERROR(GENERAL, "CreateNewMsmqConf: failed, hr = 0x%x", hr);
        LogHR(hr, s_FN, 400);
		throw bad_hresult(hr);
	}

	//
	// New Msmq Configuration object was created successfully
	//
	TrTRACE(GENERAL, "CreateNewMsmqConf: Msmq Configuration object was created successfully with new guid");

    QmpReportServiceProgress();

	//
	// New msmq configuration object was created and we have new guid.
	// CreateTheConfigObj() wrote the new value to QMID registry
	// so The new value is already in QMID registry.
	//

	GUID QMNewGuid;
	GetQMIDRegistry(&QMNewGuid);

	ASSERT(QMNewGuid != *QueueMgr.GetQMGuid());
	
	TrTRACE(GENERAL, "CreateNewMsmqConf: NewGuid = %!guid!", &QMNewGuid);
    
	hr = QueueMgr.SetQMGuid(&QMNewGuid);
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "setting QM guid failed. The call to CQueueMgr::SetQMGuid failed with error, hr = 0x%x", hr);
        LogHR(hr, s_FN, 410);
		throw bad_hresult(hr);
	}

	TrTRACE(GENERAL, "Set QueueMgr QMGuid");
}


static 
bool 
FindMsmqConfInNewDomain(
	LPCWSTR   pwszNetDomainName
	)
/*++
Routine Description:
	Check if we have the msmq configuration object in the new domain with the same Guid.
    If yes, then we can "join" the new domain.

	throw bad_hresult

Arguments:
	pwszNetDomainName - new domain name

Returned Value:
	true if msmq configuration object was found with the same GUID, false otherwise 

--*/
{
    //
    // Check if user run MoveTree and moved the msmqConfiguration object to
    // new domain.
	//
	// This function can throw exceptions bad_hresult.
	//
    AP<WCHAR> pwszComputerDN;
    ULONG uLen = 0;
    GetComputerDN(&pwszComputerDN, &uLen);

	TrTRACE(GENERAL, "FindMsmqConfInNewDomain: ComputerDN = %ls", pwszComputerDN);

    HRESULT hr;
    GUID msmqGuid;
    hr = GetMsmqGuidFromAD( 
			pwszComputerDN,
			&msmqGuid 
			);

    if (FAILED(hr))
    {
		//
		// We didn't find the msmqConfiguration object in the new domain. 
		// We will try to look in the old domain.
		// or try to create it if not found in the old domain.
		//
		TrTRACE(GENERAL, "FindMsmqConfInNewDomain: did not found msmqConfiguration object in the new Domain");
        LogHR(hr, s_FN, 430);
		return false;
	}

	//
	// We have an msmqConfiguration object in the new domain - use it
	//
	TrTRACE(GENERAL, "FindMsmqConfInNewDomain: found msmqConfiguration, ComputerDN = %ls", pwszComputerDN);

	if (msmqGuid == *QueueMgr.GetQMGuid())
	{
		//
		// msmqConfiguration object moved to its new domain.
		// the user probably run MoveTree
		//
		TrTRACE(GENERAL, "FindMsmqConfInNewDomain: found msmqConfiguration object with same guid");
		return true;
	}

	ASSERT(msmqGuid != *QueueMgr.GetQMGuid());

	//
	// msmqConfiguration object was found in new domain with different guid. 
	// This may cause lot of problems for msmq, 
	// as routing (and maybe other functinoality) may be confused.
	// We will issue an event and throw which means we will be in workgroup.
	// until this msmqConfiguration object will be deleted.
	//
	TrERROR(GENERAL, "FindMsmqConfInNewDomain: found msmqConfiguration object with different guid");
	TrERROR(GENERAL, "QM GUID = " LOG_GUID_FMT, LOG_GUID(QueueMgr.GetQMGuid()));
	TrERROR(GENERAL, "msmq configuration guid = " LOG_GUID_FMT, LOG_GUID(&msmqGuid));
	LogHR(EVENT_JOIN_DOMAIN_OBJECT_EXIST, s_FN, 440);
    EvReport(EVENT_JOIN_DOMAIN_OBJECT_EXIST, 1, pwszNetDomainName);
	throw bad_hresult(EVENT_JOIN_DOMAIN_OBJECT_EXIST);

}


static void SetMachineForWorkgroup()
/*++
Routine Description:
	set Workgroup flag and registry.

Arguments:
	None

Returned Value:
	None 

--*/
{
    //
    // Turn on workgroup flag.
    //
    g_fWorkGroupInstallation = TRUE;
	SetWorkgroupRegistry(g_fWorkGroupInstallation);
}


static
JoinStatus  
CheckIfJoinStatusChanged( 
	IN  NETSETUP_JOIN_STATUS status,
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Check if there where changes in Join Status.

Arguments:
	status - [in] Network join status
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	JoinStatus that hold the Join Status 
	(no change. move to workgroup, join domain, change domains)

--*/
{
    if (status != NetSetupDomainName)
    {
        //
        // Currently, machine in workgroup mode,  not in domain.
        //
        if (g_fWorkGroupInstallation)
        {
            //
            // No change. Was and still is in workgroup mode.
            //
			TrTRACE(GENERAL, "No change in JoinStatus, remain Workgroup");
            return jsNoChange;
        }
        else
        {
            //
            // Status changed. Domain machine leaved its domain.
            //
			TrTRACE(GENERAL, "detect change in JoinStatus: Move from Domain to Workgroup");
            return jsMoveToWorkgroup;
        }
    }

	//
    //  Currently, machine is in domain.
    //

    if (g_fWorkGroupInstallation)
	{
        //
        // workgroup machine joined a domain.
        //
		TrTRACE(GENERAL, "detect change in JoinStatus: Move from Workgroup to Domain %ls", pwszNetDomainName);
        return jsJoinDomain;
	}

    if ((CompareStringsNoCase(pwszPrevDomainName, pwszNetDomainName) == 0))
    {
        //
        // No change. Was and still is member of domain.
        //
		TrTRACE(GENERAL, "No change in JoinStatus, remain in domain %ls", pwszPrevDomainName);
        return jsNoChange;
    }

	//
	// if Prev Domain not available we are treating this as moving to a new domain.
	//
    // Status changed. Machine moved from one domain to another.
    //
	TrTRACE(GENERAL, "detect change in JoinStatus: Move from Domain %ls to Domain %ls", pwszPrevDomainName, pwszNetDomainName);
    return jsChangeDomains;
}


static
void
EndChangeDomains(
	IN  LPCWSTR   pwszNewDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	End of change domain.
	Set MachineDN, MachineDomain registry to the new values.
	MsmqMoveDomain_OK event.

Arguments:
	pwszNewDomainName - [in] new domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name (current machine domain)

Returned Value:
	None

--*/
{
	SetMachineForDomain();
	SetMachineDomainRegistry(pwszNewDomainName);

	SucceedMoveDomain( 
		pwszNewDomainName,
		pwszPrevDomainName,
		MsmqMoveDomain_OK 
		);
}


static
void
EndJoinDomain(
	IN  LPCWSTR   pwszDomainName
	)
/*++
Routine Description:
	End of join domain operations.

Arguments:
	pwszDomainName - [in] Net domain name (current machine domain)

Returned Value:
	None

--*/
{
	//
	// Reset Workgroup registry and restore old list of MQIS servers.
	//
    g_fWorkGroupInstallation = FALSE;
	SetWorkgroupRegistry(g_fWorkGroupInstallation);
	
	//
	// Set MachineDN registry
	//
	SetMachineForDomain();

	//
	// Set MachineDomain registry
	//
	SetMachineDomainRegistry(pwszDomainName);

	EvReport(JoinMsmqDomain_SUCCESS, 1, pwszDomainName);

	TrTRACE(GENERAL, "successfully join Domain %ls from workgroup", pwszDomainName);

}


static
void
ChangeDomains(
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Change between 2 domains.
	If failed throw bad_hresult or bad_win32_erorr

Arguments:
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	None

--*/
{
	bool fFound = FindMsmqConfInNewDomain(pwszNetDomainName);
	if(fFound)
	{
		//
		// Found msmqconfiguration object in the new domain
		// update registry, event
		//
		TrTRACE(GENERAL, "ChangeDomains: successfully change Domains, PrevDomain = %ls, NewDomain = %ls, existing msmq configuration", pwszPrevDomainName, pwszNetDomainName);

		EndChangeDomains(pwszNetDomainName, pwszPrevDomainName);

		return;
	}
	
    ASSERT(CompareStringsNoCase(pwszPrevDomainName, pwszNetDomainName) != 0);

	fFound = FindMsmqConfInOldDomain();
	if(fFound)
	{
		//
		// Found msmqconfiguration object in the old domain
		// We dont change MachineDNRegistry, MachineDomainRegistry
		// So next boot we will also try to ChangeDomain 
		// and we will also get this event, or if the user move msmqconfiguration object
		// we will update the registry.
		//
		TrTRACE(GENERAL, "ChangeDomains: successfully change Domains, PrevDomain = %ls, NewDomain = %ls, existing msmq configuration in old domain", pwszPrevDomainName, pwszNetDomainName);

		SucceedMoveDomain( 
			pwszNetDomainName,
			pwszPrevDomainName,
			MsmqNeedMoveTree_OK 
			);

		return;
	}

	//
	// Try to create new msmqconfiguration object.
	// we get here if we did not found the msmqconfiguration object in both domain:
	// new and old domain.
	//
	CreateNewMsmqConf();

	//
	// Create msmqconfiguration object in the new domain
	// update registry, event
	//
	TrTRACE(GENERAL, "ChangeDomains: successfully change Domains, PrevDomain = %ls, NewDomain = %ls, create new msmq configuration object", pwszPrevDomainName, pwszNetDomainName);

	EndChangeDomains(pwszNetDomainName, pwszPrevDomainName);
}


static
void
JoinDomain(
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Join domain from workgroup
	If failed throw bad_hresult or bad_win32_error

Arguments:
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	None

--*/
{

	bool fFound = FindMsmqConfInNewDomain(pwszNetDomainName);
	if(fFound)
	{
		//
		// Found msmqconfiguration object in the new domain
		// update registry, event
		//
		TrTRACE(GENERAL, "JoinDomain: successfully join Domain %ls from workgroup, existing msmq configuration", pwszNetDomainName);

		EndJoinDomain(pwszNetDomainName);

		return;
	}
	
    if((pwszPrevDomainName[0] != 0) 
		&& (CompareStringsNoCase(pwszPrevDomainName, pwszNetDomainName) != 0))
	{
		//
		// We have PrevDomain different than the new domain name try to find msmq configuration object there
		//
		TrTRACE(GENERAL, "JoinDomain: Old domain name exist and different PrevDomain = %ls", pwszPrevDomainName);
		fFound = FindMsmqConfInOldDomain();
	}

	if(fFound)
	{
		//
		// Found msmqconfiguration object in the old domain
		// We dont change MachineDNRegistry, MachineDomainRegistry
		// So next boot we will also try to ChangeDomain 
		// and we will also get this event, or if the user move msmqconfiguration object
		// we will update the registry.
		//
		// ISSUE - qmds, in UpdateDs - update MachineDNRegistry, we might need another registry
		// like MsmqConfObj
		//
		TrTRACE(GENERAL, "JoinDomain: successfully join Domain %ls from workgroup, existing msmq configuration in old domain %ls", pwszNetDomainName, pwszPrevDomainName);

		g_fWorkGroupInstallation = FALSE;
		SetWorkgroupRegistry(g_fWorkGroupInstallation);

		//
		// Event for the user to change msmqconfiguration object.
		//
		SucceedMoveDomain( 
			pwszNetDomainName,
			pwszPrevDomainName,
			MsmqNeedMoveTree_OK 
			);

		return;
	}

	//
	// Try to create new msmqconfiguration object.
	// we get here if we did not found the msmqconfiguration object in both domain:
	// new and old domain.
	//
	CreateNewMsmqConf();  

	TrTRACE(GENERAL, "JoinDomain: successfully join Domain %ls from workgroup, create new msmq configuration object", pwszNetDomainName);

	//
	// update registry, event
	//
	EndJoinDomain(pwszNetDomainName);
}


static
void
FailChangeDomains(
	IN  HRESULT  hr,
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Fail to change domains

Arguments:
	hr - [in] hresult
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	None

--*/
{
	TrERROR(GENERAL, "Failed to change domains from domain %ls to domain %ls, bad_hresult exception", pwszPrevDomainName, pwszNetDomainName);
	LogHR(hr, s_FN, 460);

	SetMachineForWorkgroup();


	if(hr == EVENT_JOIN_DOMAIN_OBJECT_EXIST)
	{
		TrERROR(GENERAL, "Failed To join domain %ls, msmq configuration object already exist in the new domain with different QM guid", pwszNetDomainName);
		return;
	}

	if(hr == EVENT_ERROR_JOIN_NT4_DOMAIN)
	{
		TrERROR(GENERAL, "MSMQ will not join the %ls NT4 domain", pwszNetDomainName);
	    EvReport(EVENT_ERROR_JOIN_NT4_DOMAIN, 1, pwszNetDomainName);
		return;
	}

	FailMoveDomain( 
		pwszNetDomainName,
		pwszPrevDomainName,
		MoveMsmqDomain_ERR 
		);
}

	
static void MoveToWorkgroup(LPCWSTR   pwszPrevDomainName)
/*++
Routine Description:
	Move from domain to workgroup

Arguments:
	pwszPrevDomainName - prev domain name.

Returned Value:
	None

--*/
{
	TrTRACE(GENERAL, "Moving from '%ls' domain to workgroup", pwszPrevDomainName);

	SetMachineForWorkgroup();

	if(IsRoutingServer())
	{
		//
		// This computer is MSMQ routing server that was moved from domain to workgroup.
		// msmq clients will regard this computer as msmq routinf server 
		// As long as msmq objects (setting object) are in AD.
		//
		// The move to workgroup might be only temporarily because of domain problems
		// So we don't want to change the routing functionality of this machine.
		//
		// We will issue an event that will ask the user to delete msmq objects in AD
		// and run msmq setup to clear server functionality components.
		//
		EvReport(EVENT_ERROR_ROUTING_SERVER_LEAVE_DOMAIN, 2, pwszPrevDomainName, g_szMachineName);
	}

	EvReport(LeaveMsmqDomain_SUCCESS);
}

	
static 
void 
FailJoinDomain(
	HRESULT  hr,
	LPCWSTR   pwszNetDomainName
	)
/*++
Routine Description:
	Fail to join domain from workgroup

Arguments:
	hr - [in] hresult
	pwszNetDomainName - [in] Net domain name (the domain we tried to join)

Returned Value:
	None

--*/
{
	//
	// Let's remain in workgroup mode.
	//
	SetMachineForWorkgroup();

	LogHR(hr, s_FN, 480);

	if(hr == EVENT_JOIN_DOMAIN_OBJECT_EXIST)
	{
		TrERROR(GENERAL, "Failed To join domain %ls, msmq configuration object already exist in the new domain with different QM guid", pwszNetDomainName);
		return;
	}

	if(hr == EVENT_ERROR_JOIN_NT4_DOMAIN)
	{
		TrERROR(GENERAL, "MSMQ will not join the %ls NT4 domain", pwszNetDomainName);
	    EvReport(EVENT_ERROR_JOIN_NT4_DOMAIN, 1, pwszNetDomainName);
		return;
	}

	EvReportWithError(JoinMsmqDomain_ERR, hr, 1, pwszNetDomainName);
	TrERROR(GENERAL, "Failed to join Domain, bad_hresult, hr = 0x%x", hr);
}


static void GetMachineSid(AP<BYTE>& pSid)
/*++
Routine Description:
	Get machine account sid.

Arguments:
	pSid - pointer to PSID.

Returned Value:
	None.

--*/
{
    //
    // Get join status and DomainName.
    //
    PNETBUF<WCHAR> pwszNetDomainName = NULL;
    NETSETUP_JOIN_STATUS status = NetSetupUnknownStatus;
    NET_API_STATUS rc = NetGetJoinInformation( 
							NULL,
							&pwszNetDomainName,
							&status 
							);

    if (NERR_Success != rc)
    {
		TrERROR(GENERAL, "NetGetJoinInformation failed error = 0x%x", rc);
        throw bad_hresult(MQ_ERROR);
    }

	TrTRACE(GENERAL, "NetGetJoinInformation: status = %d", status);
	TrTRACE(GENERAL, "NetDomainName = %ls", pwszNetDomainName);

    if(status != NetSetupDomainName)
    {
		TrTRACE(GENERAL, "The machine isn't join to domain");
        throw bad_hresult(MQ_ERROR);
    }

	ASSERT(pwszNetDomainName != NULL);

	//
	// Build machine account name - Domain\MachineName$
	//
	DWORD len = wcslen(pwszNetDomainName) + wcslen(g_szMachineName) + 3;
	AP<WCHAR> MachineAccountName = new WCHAR[len];
	HRESULT hr = StringCchPrintf(MachineAccountName, len, L"%s\\%s$", pwszNetDomainName, g_szMachineName);
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "StringCchPrintf failed, %!hresult!", hr);
        throw bad_hresult(hr);
	}

	//
	// Get buffer size.
	//
    DWORD dwDomainSize = 0;
    DWORD dwSidSize = 0;
    SID_NAME_USE su;
    BOOL fSuccess = LookupAccountName( 
						NULL,
						MachineAccountName,
						NULL,
						&dwSidSize,
						NULL,
						&dwDomainSize,
						&su 
						);

    if (fSuccess || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
		DWORD gle = GetLastError();
        TrWARNING(GENERAL, "LookupAccountName Failed to get %ls sid, gle = %!winerr!", MachineAccountName, gle);
        throw bad_win32_error(gle);
    }

	//
	// Get sid and domain information.
	//
    pSid = new BYTE[dwSidSize];
    AP<WCHAR> pDomainName = new WCHAR[dwDomainSize];

    fSuccess = LookupAccountName( 
					NULL,
					MachineAccountName,
					pSid,
					&dwSidSize,
					pDomainName,
					&dwDomainSize,
					&su 
					);

    if (!fSuccess)
    {
		DWORD gle = GetLastError();
        TrWARNING(GENERAL, "LookupAccountName Failed to get %ls sid, gle = %!winerr!", MachineAccountName, gle);
        throw bad_win32_error(gle);
    }

    ASSERT(su == SidTypeUser);
    TrTRACE(GENERAL, "MachineAccountName = %ls, sid = %!sid!", MachineAccountName, pSid);
}


static void UpdateMachineSidCache()
/*++
Routine Description:
	Update machine sid cache for always workgroup mode.
	In this mode the machine might be in domain so we need to have machine$ sid.

Arguments:
	None

Returned Value:
	None

--*/
{
#ifdef _DEBUG
	//
	// Validate we call this code only in AlwaysWorkgroup mode.
	// in this mode we can't call ADGet* to get the computer sid since we have a workgroup provider.
	//
    DWORD dwAlwaysWorkgroup = 0;
	LONG res = GetAlwaysWorkgroupRegistry(&dwAlwaysWorkgroup);
    ASSERT((dwAlwaysWorkgroup == 1) || (res != ERROR_SUCCESS));
#endif

	AP<BYTE> pSid;
	GetMachineSid(pSid);

    ASSERT((pSid != NULL) && IsValidSid(pSid));

    DWORD  dwSize = GetLengthSid(pSid);
    DWORD  dwType = REG_BINARY;
    LONG rc = SetFalconKeyValue( 
					MACHINE_ACCOUNT_REGNAME,
					&dwType,
					pSid,
					&dwSize
					);

	if (rc != ERROR_SUCCESS)
	{
        TrERROR(GENERAL, "Failed to update machine account sid. gle = %!winerr!", rc);
        throw bad_win32_error(rc);
	}

	MQSec_UpdateLocalMachineSid(pSid);
}


bool SetMachineSidCacheForAlwaysWorkgroup()
/*++
Routine Description:
	Update machine sid cache for always workgroup mode.
	this function return if we are in always workgroup mode.
	and Update machine sid cache in this mode.

Arguments:
	None

Returned Value:
	true if we are in AlwaysWorkgroup mode (ds less), false otherwise

--*/
{
    if (!g_fWorkGroupInstallation)
    	return false;
    
    DWORD dwAlwaysWorkgroup = 0;
	LONG res = GetAlwaysWorkgroupRegistry(&dwAlwaysWorkgroup);

    if ((res != ERROR_SUCCESS) || (dwAlwaysWorkgroup != 1))
    	return false;

    //
    // We are in AlwaysWorkgroup (ds less) mode
    //

	try
	{
		UpdateMachineSidCache();
	}
    catch(const exception&)
    {
    }

    return true;
}


void HandleChangeOfJoinStatus()
/*++
Routine Description:
	Handle join status.
	This function check if there was change in join status.
	if detect a change perform the needed operations to comlete the change.

Arguments:
	None

Returned Value:
	None

--*/
{
	bool fAlwaysWorkgroup = SetMachineSidCacheForAlwaysWorkgroup();
    if (fAlwaysWorkgroup)
    {
        //
        // User wants to remain in ds-less mode, unconditioanlly.
        // We always respect user wishs !
        //
		TrTRACE(GENERAL, "Always WorkGroup!");
        return;
    }

    //
    // Read join status.
    //
    PNETBUF<WCHAR> pwszNetDomainName = NULL;
    NETSETUP_JOIN_STATUS status = NetSetupUnknownStatus;

    NET_API_STATUS rc = NetGetJoinInformation( 
							NULL,
							&pwszNetDomainName,
							&status 
							);

    if (NERR_Success != rc)
    {
		TrERROR(GENERAL, "NetGetJoinInformation failed error = 0x%x", rc);
		LogNTStatus(rc, s_FN, 500);
        return;
    }

	TrTRACE(GENERAL, "NetGetJoinInformation: status = %d", status);
	TrTRACE(GENERAL, "NetDomainName = %ls", pwszNetDomainName);

    QmpReportServiceProgress();

	WCHAR wszPrevDomainName[256] = {0}; // name of domain from msmq registry.

	//
    //  Read previous domain name, to check if machine moved from one
    //  domain to another.
    //
    DWORD dwSize = 256;
	LONG res = GetMachineDomainRegistry(wszPrevDomainName, &dwSize);

    if (res != ERROR_SUCCESS)
    {
        //
        // Previous name not available.
        //
		TrWARNING(GENERAL, "Prev Domain name is not available");
        wszPrevDomainName[0] = 0;
    }

	TrTRACE(GENERAL, "PrevDomainName = %ls", wszPrevDomainName);
    
	
	JoinStatus JStatus = CheckIfJoinStatusChanged(
								status,
								pwszNetDomainName,
								wszPrevDomainName
								);

    switch(JStatus)
    {
        case jsNoChange:
            return;

        case jsMoveToWorkgroup:

			ASSERT(g_fWorkGroupInstallation == FALSE);
			ASSERT(status != NetSetupDomainName);

			//
			// Move from Domain To Workgroup
			//
			MoveToWorkgroup(wszPrevDomainName);
            return;

        case jsChangeDomains:

			ASSERT(g_fWorkGroupInstallation == FALSE);
			ASSERT(status == NetSetupDomainName);

			//
			// Change Domains
			//
			try
			{
				ChangeDomains(pwszNetDomainName, wszPrevDomainName);
				return;
			}
			catch(bad_hresult& exp)
			{
				FailChangeDomains(exp.error(), pwszNetDomainName, wszPrevDomainName);
				LogHR(exp.error(), s_FN, 510);
				return;
			}

        case jsJoinDomain:

			ASSERT(g_fWorkGroupInstallation);
			ASSERT(status == NetSetupDomainName);

			//
			// Join Domain from workgroup
			//
			try
			{
				JoinDomain(pwszNetDomainName, wszPrevDomainName);
				return;
			}
			catch(bad_hresult& exp)
			{
				FailJoinDomain(exp.error(), pwszNetDomainName);
				LogHR(exp.error(), s_FN, 520);
				return;
			}

		default:
			ASSERT(("should not get here", 0));
			return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\localsecurity.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    LocalSecurity.h

Abstract:
    functions for local security 

Author:
    Ilan Herbst (ilanh) 19-Nov-2000

Environment:
    Platform-independent,

--*/

#ifndef _LOCALSECURITY_H_
#define _LOCALSECURITY_H_


void
QMpHandlePacketSecurity(
    CQmPacket *   pQmPkt,
    USHORT *      pAck,
    bool          fProtocolSrmp
    );


#endif // _LOCALSECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\lms.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lms.cpp

Abstract:
    Local Message Storage

Author:
    Erez Haba (erezh) 7-May-97

--*/

#include "stdh.h"
#include "heap.h"
#include "ph.h"
#include "ac.h"
#include <Ex.h>
#include "qmacapi.h"
#include "mqexception.h"

#include "lms.tmh"

static WCHAR *s_FN=L"lms";

#define PAGE_SIZE 0x1000
#define PAGE_ALLIGN_DN(p) ((PCHAR)(((ULONG_PTR)(p)) & ~((ULONG_PTR)(PAGE_SIZE-1))))
#define PAGE_ALLIGN_UP(p) ((PCHAR)((((ULONG_PTR)(p)) + (PAGE_SIZE-1)) & ~((ULONG_PTR)(PAGE_SIZE-1))))

template <class T>
inline T* value_type(const T*) { return (T*)(0); }

template <class T>
inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }

//
//  External linkage
//
extern HANDLE g_hAc;

//
//  Forwards
//
void WINAPI FlushPackets(EXOVERLAPPED*);

//---------------------------------------------------------
//
//  class CPacketFlusher
//
//---------------------------------------------------------
class CPacketFlusher {

    struct CNode;

    enum { max_entries = 1024 };

public:
    void add(CBaseHeader* pBase, PVOID pCookie, PVOID pPool, ULONG ulSize);
    BOOL isempty() const;
    BOOL isfull() const;
    void reset();
    void flush();

    CPacketFlusher& operator=(const CPacketFlusher& other);

private:
    PCHAR get_batch_end(PCHAR pEnd, PVOID pPool);
    const CNode& first() const;
    void pop();
    BOOL flush_batch(PCHAR pStart, PCHAR pEnd);
    HRESULT flush_all();
    void notify(int nEntries, HRESULT rc);

private:

    struct CNode {
    public:
        CNode() {}
        CNode(CBaseHeader* base, PVOID pool, ULONG ulSize, int index) :
            m_base(base), m_pool(pool), m_size(ulSize), m_index(index) {}

        CBaseHeader* base() const
        {
            return m_base;
        }

        PVOID pool() const
        {
            return m_pool;
        }

		ULONG size() const
		{
			return m_size;
		}

    public:
        inline static BOOL greater(const CNode& x, const CNode& y)
        {
			if(x.m_base == y.m_base)
				return(x.m_index > y.m_index);
	
	        return (x.m_base > y.m_base);
        }

    private:
        CBaseHeader* m_base;
        PVOID m_pool;
		ULONG m_size;
		int	  m_index;
    };

private:
    PVOID m_cookies[max_entries];
    CNode m_entries[max_entries];
    int m_nEntries;

};


inline void CPacketFlusher::add(CBaseHeader* pBase, PVOID pCookie, PVOID pPool, ULONG ulSize)
{
    m_cookies[m_nEntries] = pCookie;
    m_entries[m_nEntries] = CNode(pBase, pPool, ulSize, m_nEntries);
    ++m_nEntries;
    push_heap(m_entries, m_entries + m_nEntries, CNode::greater);
}

inline BOOL CPacketFlusher::isempty() const
{
    return (m_nEntries == 0);
}

inline BOOL CPacketFlusher::isfull() const
{
    return (m_nEntries == max_entries);
}

CPacketFlusher& CPacketFlusher::operator=(const CPacketFlusher& o)
{
    m_nEntries = o.m_nEntries;
    memcpy(m_cookies, o.m_cookies, m_nEntries * sizeof(m_cookies[0]));
    memcpy(m_entries, o.m_entries, m_nEntries * sizeof(m_entries[0]));
    return *this;
}

const CPacketFlusher::CNode& CPacketFlusher::first() const
{
    ASSERT(!isempty());
    return m_entries[0];
}

inline void CPacketFlusher::reset()
{
    m_nEntries = 0;
}

void CPacketFlusher::pop()
{
    ASSERT(!isempty());
    pop_heap(m_entries, m_entries + m_nEntries, CNode::greater);
    --m_nEntries;
}

inline PCHAR CPacketFlusher::get_batch_end(PCHAR pEnd, PVOID pPool)
{
    pEnd = PAGE_ALLIGN_UP(pEnd);

    while(!isempty())
    {
        CBaseHeader* pBase = first().base();
        PCHAR pStart = PAGE_ALLIGN_DN(pBase);

        if((pStart > pEnd) || (pPool != first().pool()))
        {
            break;
        }

        ULONG ulSize = first().size();
        pEnd = PAGE_ALLIGN_UP(reinterpret_cast<PCHAR>(pBase) + ulSize);
        pop();
    }

    return pEnd;
}

inline BOOL CPacketFlusher::flush_batch(PCHAR pStart, PCHAR pEnd)
{
    BOOL fSuccess = FlushViewOfFile(
                        pStart,
                        pEnd - pStart
                        );

    return LogBOOL(fSuccess, s_FN, 5);
}

inline HRESULT CPacketFlusher::flush_all()
{
    while(!isempty())
    {
        CBaseHeader* pBase = first().base();
        PVOID pPool = first().pool();
		ULONG ulSize = first().size();
		pop();
        PCHAR pStart = PAGE_ALLIGN_DN(pBase);
        PCHAR pEnd = get_batch_end(reinterpret_cast<PCHAR>(pBase) + ulSize, pPool);

        if(!flush_batch(pStart, pEnd))
        {
            return LogHR(MQ_ERROR_MESSAGE_STORAGE_FAILED, s_FN, 10);
        }
    }

     return MQ_OK;
}


inline void CPacketFlusher::notify(int nEntries, HRESULT rc)
{
	//
	// The notification to the driver must succeed so we try until it
	// passes OK.
	//
	for(;;)
	{
		try
		{
		    QmAcStorageCompleted(
		        g_hAc,
		        nEntries,
		        m_cookies,
		        rc,
		        eDoNotDeferOnFailure
		        );
		    return;
		}
		catch (const bad_hresult&)
		{
			TrERROR(GENERAL, "Failed to notify storage completed to the driver. Sleep 100ms and retry");
			Sleep(100);
		}
	}
}

inline void CPacketFlusher::flush()
{
    int nEntries = m_nEntries;
    notify(nEntries, flush_all());
}


static CCriticalSection s_pending_lock(CCriticalSection::xAllocateSpinCount);
static CPacketFlusher s_pending;
static CPacketFlusher s_flushing;

static bool s_flush_scheduled = false;
static EXOVERLAPPED  s_flush_ov(FlushPackets, FlushPackets);


VOID
ExPostRequestMustSucceeded(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
  Post an Executive overlapped request to the completion port.
  this function retry if not enough memory

Arguments:
  pov - An Executive overlapped structure

Returned Value:
  None

--*/
{
	for (;;)
	{
		try
		{
			ExPostRequest(pov);
			return;
		}
		catch(const bad_alloc&)
		{
			//
			// continue the loop, let other threads some time to free memory.
			// no problem with keeping the critical section for some time
			// because no one else will try to grab it.
			//
			Sleep(100);
 		}
	}
}


void QmpStorePacket(CBaseHeader* pBase, PVOID pCookie, PVOID pPool, ULONG ulSize)
{
	for(;;)
	{
		{
			CS lock(s_pending_lock);
			if(!s_pending.isfull())
			{
				s_pending.add(pBase, pCookie, pPool, ulSize);

				if(s_flush_scheduled)
				{
					//
					// Flushing already scheduled.
					//
					return;
				}

				s_flush_scheduled = true;
				ExPostRequestMustSucceeded(&s_flush_ov);
				return;
			}
		}
    
		//
		// Pending list is full. Wait until flush thread read the messages
		//
		Sleep(1);
	}
}


void WINAPI FlushPackets(EXOVERLAPPED*)
{
	ASSERT(("Flush should be scheduled", s_flush_scheduled));
	for(;;)
	{
		{
			CS lock(s_pending_lock);
			if(s_pending.isempty())
			{
				s_flush_scheduled = false;
				return;
			}
			
		    s_flushing = s_pending;
		    s_pending.reset();
		}
			
		s_flushing.flush();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\localsend.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSend.h

Abstract:

    QM Local Send Packet Creation processing.

Author:

    Shai Kariv (shaik) 31-Oct-2000

Revision History:

--*/


#pragma once

#ifndef _QM_LOCAL_SEND_H_
#define _QM_LOCAL_SEND_H_

#include <ph.h>


void 
QMpCreatePacket(
    CBaseHeader * pBase, 
    CPacket *     pDriverPacket,
    bool          fProtocolSrmp
    );


#endif // _QM_LOCAL_SEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\localsend.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSend.cpp

Abstract:

    QM Local Send Pakcet Creation processing.

Author:

    Shai Kariv (shaik) 31-Oct-2000

Revision History: 

--*/

#include "stdh.h"
#include <ac.h>
#include <Tr.h>
#include <ref.h>
#include <Ex.h>
#include <qmpkt.h>
#include "LocalSend.h"
#include "LocalSecurity.h"
#include "LocalSrmp.h"

#include "qmacapi.h"

#include "LocalSend.tmh"

extern HANDLE g_hAc;

static WCHAR *s_FN=L"localsend";

class CCreatePacketOv : public EXOVERLAPPED
{
public:

    CCreatePacketOv(
        EXOVERLAPPED::COMPLETION_ROUTINE pfnCompletionRoutine,
        CBaseHeader *                    pBase,
        CPacket *                        pDriverPacket,
        bool                             fProtocolSrmp
        ) :
        EXOVERLAPPED(pfnCompletionRoutine, pfnCompletionRoutine),
        m_pBase(pBase),
        m_pDriverPacket(pDriverPacket),
        m_fProtocolSrmp(fProtocolSrmp)
    {
    }

public:

    CBaseHeader * m_pBase;
    CPacket *     m_pDriverPacket;
    bool          m_fProtocolSrmp;

}; // class CCreatePacketOv


static
void
QMpCompleteHandleCreatePacket(
    CPacket *    pOriginalDriverPacket,
    CPacket *    pNewDriverPacket,
    HRESULT      status,
    USHORT       ack
    )
{
	//
	// If ack is set, status must be MQ_OK.
	//
	ASSERT(ack == 0 || SUCCEEDED(status));
	
    QmAcCreatePacketCompleted(
                     g_hAc,
                     pOriginalDriverPacket,
                     pNewDriverPacket,
                     status,
                     ack,
                     eDeferOnFailure
                     );
} // QMpCompleteHandleCreatePacket


static
void
QmpHandleLocalCreatePacket(
	CQmPacket& QmPkt,
	bool fProtocolSrmp
	)
{
	if(!fProtocolSrmp)
	{
		//
		// Do authentication/decryption. If ack is set, status must be MQ_OK.
		//
	    USHORT ack = 0;
		QMpHandlePacketSecurity(&QmPkt, &ack, false);

		//
		// Give the results to AC
		//
		QMpCompleteHandleCreatePacket(QmPkt.GetPointerToDriverPacket(), NULL, MQ_OK, ack);
		return;
	}

	//
    // Do SRMP serialization. Create a new packet if needed (AC will free old one).
    //
	ASSERT(fProtocolSrmp);
	
    P<CQmPacket> pQmPkt;
    QMpHandlePacketSrmp(&QmPkt, pQmPkt);
    
    CBaseHeader * pBase = pQmPkt->GetPointerToPacket();
    CPacketInfo * ppi = reinterpret_cast<CPacketInfo*>(pBase) - 1;
    ppi->InSourceMachine(TRUE);
    
	//
	// Srmp success path always create new packet
	//
	ASSERT(pQmPkt.get() != &QmPkt);
    CPacket * pNewDriverPacket = pQmPkt->GetPointerToDriverPacket();

	//
	// Do authentication/decryption. If ack is set, status must be MQ_OK.
	//
	USHORT ack = 0;
	try
	{
		QMpHandlePacketSecurity(pQmPkt, &ack, true);
	}
	catch(const exception&)
	{
		//
		// Fail in packet security, need to free the new packet that was created by Srmp.
		// The driver don't expect new packet in case of failure. only in case of ack.
		//
	    QmAcFreePacket( 
    				   pNewDriverPacket, 
    				   0, 
    				   eDeferOnFailure);
		throw;
	}

    //
    // Give the results to AC
    //
    QMpCompleteHandleCreatePacket(QmPkt.GetPointerToDriverPacket(), pNewDriverPacket, MQ_OK, ack);

}

static
void
WINAPI
QMpHandleCreatePacket(
    EXOVERLAPPED * pov
    )
{
	CCreatePacketOv * pCreatePacketOv = static_cast<CCreatePacketOv*> (pov);
    ASSERT(SUCCEEDED(pCreatePacketOv->GetStatus()));

    //
    // Get the context from the overlapped and deallocate the overlapped
    //
    CQmPacket QmPkt(pCreatePacketOv->m_pBase, pCreatePacketOv->m_pDriverPacket);
    bool fProtocolSrmp = pCreatePacketOv->m_fProtocolSrmp;
    delete pCreatePacketOv;

	try
	{
		QmpHandleLocalCreatePacket(QmPkt, fProtocolSrmp);
	}
	catch(const exception&)
	{
        //
        // Failed to handle the create packet request, no resources.
        //
        QMpCompleteHandleCreatePacket(QmPkt.GetPointerToDriverPacket() , NULL, MQ_ERROR_INSUFFICIENT_RESOURCES, MQMSG_CLASS_NORMAL);
        LogIllegalPoint(s_FN, 10);
	}
} // QMpHandleCreatePacket


void 
QMpCreatePacket(
    CBaseHeader * pBase, 
    CPacket *     pDriverPacket,
    bool          fProtocolSrmp
    )
{
    try
    {
        //
        // Handle the create packet request in a different thread, since it is lengthy.
        //
        P<CCreatePacketOv> pov = new CCreatePacketOv(QMpHandleCreatePacket, pBase, pDriverPacket, fProtocolSrmp);
        pov->SetStatus(STATUS_SUCCESS);
        ExPostRequest(pov);
        pov.detach();
    }
    catch (const std::exception&)
    {
        //
        // Failed to handle the create packet request, no resources.
        //
        QMpCompleteHandleCreatePacket(pDriverPacket, NULL, MQ_ERROR_INSUFFICIENT_RESOURCES, MQMSG_CLASS_NORMAL);
        LogIllegalPoint(s_FN, 20);
    }
} // QMpCreatePacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\license.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    license.h

Abstract:
    Handle licensing issues
    1. Number of clients allowed.
    2. ...

Author:
    Doron Juster  (DoronJ)  04-May-1997   Created

--*/

#ifndef  __LICENSE_H_
#define  __LICENSE_H_

#include "cqmgr.h"
#include "admcomnd.h"
EXTERN_C
{
#include "ntlsapi.h"
}

typedef struct _ClientInfo {
	DWORD		dwRefCount;
    bool fConsumedLicense;
	DWORD		dwNameLength;
	LPWSTR		lpClientName;
} ClientInfo;

class  CQMLicense
{
   public:
      CQMLicense() ;
      ~CQMLicense() ;

      HRESULT  Init() ;

      BOOL     NewConnectionAllowed(BOOL, GUID *);
      void     IncrementActiveConnections(CONST GUID *, LPWSTR);
      void     DecrementActiveConnections(CONST GUID *);
      void     GetClientNames(ClientNames **ppNames);

	BOOL IsClientRPCAccessAllowed(GUID* pGuid, LPWSTR lpClientName);

   private:
	  void		DisplayEvent(DWORD dwFailedError);

      BOOL      m_fPerServer ; // TRUE if licensing mode is per-server.
      DWORD     m_dwPerServerCals ;

      bool GetNTLicense(void);
      void ReleaseNTLicense(void);

      CMap<GUID, const GUID&, ClientInfo *, ClientInfo*&>
                                                 m_MapQMid2ClientInfo ;


      CCriticalSection m_cs ;
	  DWORD			   m_dwLastEventTime;
} ;


extern CQMLicense  g_QMLicense ;

#endif //  __LICENSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\localsecurity.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    LocalSecurity.cpp

Abstract:
    functions for local security 

Author:
    Ilan Herbst (ilanh) 19-Nov-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"

#include "qmsecutl.h"
#include "HttpAuthr.h"

#include "LocalSecurity.tmh"

static WCHAR *s_FN=L"localsecurity";

static
HRESULT
QMpHandlePacketAuthentication(
    CQmPacket *   pQmPkt
    )
/*++

Routine Description:

	Handle Local queue receiving side authentication.

Arguments:

    pQmPkt     - Pointer to the packet to authenticate.

Return Value:

	HRESULT

--*/
{
    if ((pQmPkt->GetSenderIDType() == MQMSG_SENDERID_TYPE_QM) || 
		((pQmPkt->GetSignatureSize() == 0) && (pQmPkt->GetSignatureMqfSize() == 0)))
    {
		//
		// The sender is the QM or no signatures
		//
        return MQ_OK;
    }

    return VerifySignature(pQmPkt);
} // QMpHandlePacketAuthentication


static
USHORT
QMpHandleHttpPacketAuthentication(
    CQmPacket *   pQmPkt
    )
/*++

Routine Description:

	Handle Local queue receiving side http authentication.

Arguments:

    pQmPkt     - Pointer to the packet to authenticate.

Return Value:

	HRESULT

--*/
{
    if ((pQmPkt->GetSenderIDType() == MQMSG_SENDERID_TYPE_QM) || (pQmPkt->GetSignatureSize() == 0))
    {
		//
		// The sender is the QM or no signatures
		//
        return MQMSG_CLASS_NORMAL;
    }

    R<CERTINFO> pCertInfo;
    return VerifyAuthenticationHttpMsg(pQmPkt, &pCertInfo.ref());
} // QMpHandleHttpPacketAuthentication


static
HRESULT
QMpHandlePacketDecryption(
    CQmPacket *   pQmPkt
    )
/*++

Routine Description:

	Handle Local queue receiving side decryption.

Arguments:

    pQmPkt     - Pointer to the original packet to decrypt.

Return Value:

	MQ_OK - The operation completed successfully in the sender's view.

    other - The operation failed, ppNewQmPkt does not point to new packet.

--*/
{
	if(!pQmPkt->IsEncrypted())
	{
		return MQ_OK;
	}

	return pQmPkt->Decrypt();

} // QMpHandlePacketDecryption


void
QMpHandlePacketSecurity(
    CQmPacket* pQmPkt,
    USHORT* pAck,
    bool fProtocolSrmp
    )
/*++

Routine Description:

	Handle Local queue receiving side security.

Arguments:

    pQmPkt     - Pointer to the packet to authenticate/decrypt.

    pAck       - Pointer to ack class, on output. This field is non zero when
                 authentication/decryption fails and NACK should be issued. The
                 sender views it as success but the packet is revoked in AC.
                 If you set this field, return MQ_OK so that sender will view it
                 as success.

    fProtocolSrmp - Indicates whether the send is over SRMP protocol.

Return Value:

    MQ_OK - The operation completed successfully in the sender's view.
            If pAck is zero: security was handled OK, 
			If pAck is non zero, security checks failed and NACK should be issued, 

    other - The operation failed.

--*/
{
    (*pAck) = 0;

	if(fProtocolSrmp)
	{
		//
		// No encryption is allowed in http/multicast.
		//
		ASSERT(!pQmPkt->IsEncrypted());

		USHORT usClass = QMpHandleHttpPacketAuthentication(pQmPkt);
		if(MQCLASS_NACK(usClass))
		{
			*pAck = usClass;
			return;
		}
		return;
	}

	//
	// non-http message
	// First Decryption if needed
	// if decryption is done m_ulBodySize is updated (reduced)
	// but not m_ulAllocBodySize so no need to create a new packet
	//
    HRESULT hr = QMpHandlePacketDecryption(pQmPkt);
    if (FAILED(hr))
    {
        if (hr == MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED)
        {
            *pAck = MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER;
            return;
        }

        *pAck = MQMSG_CLASS_NACK_BAD_ENCRYPTION;
        return;
    }

    hr = QMpHandlePacketAuthentication(pQmPkt);
    if (FAILED(hr))
    {
        *pAck = MQMSG_CLASS_NACK_BAD_SIGNATURE;
        return;
    }
} // QMpHandlePacketSecurity
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\localsrmp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSrmp.cpp

Abstract:

    QM Local Send SRMP properties serialization.

Author:

    Shai Kariv (shaik) 21-Nov-2000

Revision History:

--*/

#include "stdh.h"
#include <Tr.h>
#include <ref.h>
#include <Mp.h>
#include "LocalSrmp.h"
#include "HttpAccept.h"

#include "LocalSrmp.tmh"

extern HANDLE g_hAc;
extern LPTSTR g_szMachineName;

static WCHAR *s_FN=L"localsrmp";


void 
QMpHandlePacketSrmp(
    const CQmPacket* pInQmPkt,
    P<CQmPacket>& pOutQmPkt
    )
    throw()
/*++

Routine Description:

	Handle serialization of SRMP properties for a packet sent to local queue.

    Algorithm:

    * Serialize the original packet to network representation.
    * Deserialize the network representation to a newly created packet.
    * Point pOutQmPkt to the newly created packet.
    * Do not free the original packet, it is the caller responsibility.
    * On failure: cleanup after myself if needed and return failure code. Do not
      throw exceptions.

Arguments:

    pInQmPkt  - Pointer to original packet.
    pOutQmPkt - Pointer to newly created packet.

Return Value:
    NONE.

Exceptions:
	Throws std::exception hirarchy

--*/
{
    //
    // Serialize original packet to SRMP format
    //
    R<CSrmpRequestBuffers> srb = MpSerialize(*pInQmPkt, g_szMachineName, L"//localhost");

    //
    // Construct a network representation of the http header and body
    //
    const char * HttpHeader = srb->GetHttpHeader();
    ASSERT(HttpHeader != NULL);

    DWORD HttpBodySize = numeric_cast<DWORD>(srb->GetHttpBodyLength());
    AP<BYTE> HttpBody = srb->SerializeHttpBody();

    //
    // Build packet from the network representation buffers
    //
    QUEUE_FORMAT qf;
    pInQmPkt->GetDestinationQueue(&qf);
    pOutQmPkt = MpDeserialize(HttpHeader, HttpBodySize, HttpBody, &qf, true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\localsrmp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSrmp.h

Abstract:

    QM Local Send SRMP properties serialization.

Author:

    Shai Kariv (shaik) 21-Nov-2000

Revision History:

--*/


#pragma once

#ifndef _QM_LOCAL_SRMP_H_
#define _QM_LOCAL_SRMP_H_

#include <qmpkt.h>


void
QMpHandlePacketSrmp(
    const CQmPacket* pInQmPkt,
    P<CQmPacket>& pOutQmPkt
    )
    throw();


#endif // _QM_LOCAL_SRMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\midluser.cpp ===
#include <stdh.h>

#include "..\\common\\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\lqs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lqs.h

Abstract:
    Local Queue Store.

Author:
    Boaz Feldbaum (BoazF) 12-Feb-1997.

--*/

#ifndef _HLQS_H_
#define _HLQS_H_

//
// We need to allocate buffers for the file names that are larger than
// MAX_PATH this in order to be on the safe side. We need:
// 5 chars for the \LQS\
// 32 chars for the GUID
// 1 character for the dot
// 8 characters for the queue path name hash
//
#define MAX_PATH_PLUS_MARGIN            (MAX_PATH + 5+32+1+8)

typedef LPVOID HLQS;

HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,
    const GUID *pguidQueue,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    HLQS *phLQS
    );

HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,
    DWORD dwQueueId,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    HLQS *phLQS
    );

HRESULT
LQSSetProperties(
    HLQS hLQS,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    BOOL fNewFile = FALSE
    );

HRESULT
LQSGetProperties(
    HLQS        hLQS,
    DWORD       cProps,
    PROPID      aPropId[],
    PROPVARIANT aPropVar[],
    BOOL        fCheckFile = FALSE
    );

HRESULT
LQSOpen(
    LPCWSTR pszQueuePath,
    HLQS *phLQS,
    LPWSTR pFilePath
    );

HRESULT
LQSOpen(
    DWORD dwQueueId,
    HLQS *phLQS,
    LPWSTR pFilePath
    );

HRESULT
LQSOpen(
    const GUID *pguidQueue,
    HLQS *phLQS,
    LPWSTR pFilePath
    );

HRESULT
LQSClose(
    HLQS hLQS
    );

#ifdef _WIN64
HRESULT
LQSCloseWithMappedHLQS(
    DWORD dwMappedHLQS
    );
#endif //_WIN64

HRESULT
LQSDelete(
    DWORD dwQueueId
    );

HRESULT
LQSDelete(
    const GUID *pguidQueue
    );

HRESULT
LQSGetIdentifier(
    HLQS hLQS,
    DWORD *pdwId
    );

HRESULT
LQSGetFirst(
    HLQS *hLQS,
    GUID *pguidQueue
    );

HRESULT
LQSGetFirst(
    HLQS *hLQS,
    DWORD *pdwQueueId
    );

HRESULT
LQSGetNext(
    HLQS hLQS,
    GUID *pguidQueue
    );

HRESULT
LQSGetNext(
    HLQS hLQS,
    DWORD *pdwQueueId
    );

#ifdef _WIN64
HRESULT
LQSGetFirstWithMappedHLQS(
    DWORD *pdwMappedHLQS,
    DWORD *pdwQueueId
    );

HRESULT
LQSGetNextWithMappedHLQS(
    DWORD dwMappedHLQS,
    DWORD *pdwQueueId
    );
#endif //_WIN64

HRESULT
LQSDelete(
    HLQS hLQS
	);

//
// Auto-free HLQS
//
class CHLQS
{
public:
    CHLQS(HLQS h =NULL) { m_h = h; };
    ~CHLQS() { if (m_h) LQSClose(m_h); };

public:
    CHLQS & operator =(HLQS h) { m_h = h; return(*this); };
    HLQS * operator &() { return &m_h; };
    operator HLQS() { return m_h; };

private:
    HLQS m_h;
};

#ifdef _WIN64
//
// Auto-free Mapped HLQS
//
class CMappedHLQS
{
public:
    CMappedHLQS(DWORD dw =NULL) { m_dw = dw; };
    ~CMappedHLQS() { if (m_dw) LQSCloseWithMappedHLQS(m_dw); };

public:
    CMappedHLQS & operator =(DWORD dw) { m_dw = dw; return(*this); };
    DWORD * operator &() { return &m_dw; };
    operator DWORD() { return m_dw; };

private:
    DWORD m_dw;
};
#endif //_WIN64


//
// LQS Migration routine
//
BOOL MigrateLQS();

void SetLqsUpdatedSD();


//
// Delete temporary files at startup
//
void
LQSCleanupTemporaryFiles();


#endif // _HLQS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\mgmt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mgmt.cpp

Abstract:

   MSMQ Local machine adminstration

Author:

    Uri Habusha (urih) June, 1998

--*/

#include "stdh.h"

#include <qmmgmt.h>
#include <mqutil.h>

#include "cqmgr.h"
#include "cqpriv.h"
#include "sessmgr.h"
#include "acapi.h"
#include "xact.h"
#include "xactout.h"
#include "xactin.h"
#include "onhold.h"
#include "Fn.h"
#include "ad.h"
#include "perf.h"
#include <lmcons.h>
#include <lmapibuf.h>
#include <autoreln.h>
#include <dsgetdc.h>
#include "qal.h"
#include "mgmt.tmh"

extern CSessionMgr SessionMgr;
extern LPTSTR g_szMachineName;
extern HANDLE g_hAc;

static WCHAR *s_FN=L"mgmt";

static
void
FreeVariant(
    PROPVARIANT& var
    );

class CPropVar
{
public:
	CPropVar(PROPVARIANT* PropVar, DWORD Props):
		m_PropVar(PropVar),
		m_Props(Props)
	{
	}
		
	~CPropVar()
	{
		for (DWORD i = 0; i < m_Props; ++i)
		{
			FreeVariant(m_PropVar[i]);
		}
	}
	
	void detach()
	{
		m_Props=0;
		m_PropVar=NULL;
	}

private:
	CPropVar(const CPropVar&);
	CPropVar& operator=(const CPropVar&);


private:
	PROPVARIANT* m_PropVar;
	DWORD m_Props;

};

static
void
GetOpenQueues(
    PROPVARIANT& var
    )
{
    //
    // Initialize the LPWSTR array
    //
    var.calpwstr.cElems = 0;
    var.calpwstr.pElems = NULL;

    QueueMgr.GetOpenQueuesFormatName(
                    &var.calpwstr.pElems,
                    &var.calpwstr.cElems
                    );

    var.vt = VT_LPWSTR | VT_VECTOR;
}


static
void
GetPrivateQueueList(
    PROPVARIANT& var
    )
{
    HRESULT  hr;
    LPWSTR  strPathName;
    DWORD  dwQueueId;
    LPVOID pos;
    DWORD NumberOfQueues = 0;

    //
    // lock to ensure private queues are not added or deleted while filling the
    // buffer.
    //
    CS lock(g_QPrivate.m_cs);

    //
    // Write the pathnames into the buffer.
    //
    hr = g_QPrivate.QMGetFirstPrivateQueuePosition(pos, strPathName, dwQueueId);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "QMGetFirstPrivateQueuePosition failed. Error: %!hresult!", hr);
	}

    const DWORD x_IncrementBufferSize = 100;
    LPWSTR* listPrivateQueue = NULL;
    DWORD MaxBufferSize = 0;

    try
    {
        while (SUCCEEDED(hr))
        {
			if(dwQueueId <= MAX_SYS_PRIVATE_QUEUE_ID)
			{
				//
				// Filter out system queues out of the list
				//
				hr = g_QPrivate.QMGetNextPrivateQueue(pos, strPathName, dwQueueId);
				continue;
			}

            //
            // Check if there is still enough space
            //
            if (NumberOfQueues == MaxBufferSize)
            {
                //
                // Allocate a new buffer
                //
                DWORD NewBufferSize = MaxBufferSize + x_IncrementBufferSize;
                LPWSTR* tempBuffer = new LPWSTR [NewBufferSize];
                memset(tempBuffer, 0 , sizeof(LPWSTR)*NewBufferSize);
                MaxBufferSize = NewBufferSize;

                //
                // Copy the information from the old buffer to the new one
                //
                if (NumberOfQueues != 0)
                {
                	memcpy(tempBuffer, listPrivateQueue, NumberOfQueues*sizeof(LPWSTR));
	                delete [] listPrivateQueue;
                }
                listPrivateQueue= tempBuffer;
            }

            //
            // Add the Queue to the list
            //
            listPrivateQueue[NumberOfQueues] = strPathName;
            ++NumberOfQueues;

            //
            // Get Next Private queue
            //
            hr = g_QPrivate.QMGetNextPrivateQueue(pos, strPathName, dwQueueId);
        }
    }
    catch(const bad_alloc&)
    {
        while(NumberOfQueues)
        {
            delete []  listPrivateQueue[--NumberOfQueues];
        }

        delete [] listPrivateQueue;
        LogIllegalPoint(s_FN, 61);

        throw;
    }


    var.calpwstr.cElems = NumberOfQueues;
    var.calpwstr.pElems = listPrivateQueue;
    var.vt = VT_LPWSTR | VT_VECTOR;

    return;
}


static
void
GetMsmqType(
    PROPVARIANT& var
    )
{
    var.pwszVal = newwcs(L"");
    var.vt = VT_LPWSTR;
}

static
void
GetMqisDsServer(
    PROPVARIANT& var
    )
{
    WCHAR DSServerName[MAX_PATH];
    DWORD dwSize = sizeof(DSServerName);
    DWORD dwType = REG_SZ;
    LONG rc = GetFalconKeyValue(
                    MSMQ_DS_CURRENT_SERVER_REGNAME,
                    &dwType,
                    DSServerName,
                    &dwSize
                    );

    if (rc != ERROR_SUCCESS)
    {
        //
        // No DS server.
        //
        return;
    }

    if(DSServerName[0] == L'\0')
    {
        return;
    }

	var.pwszVal = newwcs(DSServerName+2);
    var.vt = VT_LPWSTR;
}

static
void
GetDsServer(
    PROPVARIANT& var
    )
{
    if (!QueueMgr.CanAccessDS())
    {
        return;
    }

    switch (ADProviderType())
    {
        case eMqdscli:
            GetMqisDsServer(var);
            return;

        case eMqad:
            {
                PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	            DWORD dw = DsGetDcName(
					            NULL,
					            NULL,
					            NULL,
					            NULL,
					            DS_DIRECTORY_SERVICE_REQUIRED,
					            &pDcInfo
					            );
                if(dw != NO_ERROR)
	            {
                    return;
                }

                if (pDcInfo->DomainControllerName == NULL)
                {
                    ASSERT(("DsGetDcName did not return DC name", 0));
                    return;
                }
				var.pwszVal = newwcs(pDcInfo->DomainControllerName+2);
                var.vt = VT_LPWSTR;
                return;
            }

        default:
            return;
    }
}

static
void
GetDSConnectionMode(
    PROPVARIANT& var
    )
{
    if (QueueMgr.IsConnected())
    {
        var.pwszVal = newwcs(MSMQ_CONNECTED);
    }
    else
    {
        var.pwszVal = newwcs(MSMQ_DISCONNECTED);
    }
    var.vt = VT_LPWSTR;
}


static
void
GetBytesInAllQueues(
	PROPVARIANT& var
	)
{
	ULONGLONG ullUsedQuota;
	ACGetUsedQuota(g_hAc, &ullUsedQuota);
	var.hVal.QuadPart = static_cast<LONGLONG>(ullUsedQuota);
	var.vt = VT_I8;
}


static
void
GetMachineInfo(
    DWORD cprop,
    PROPID* propId,
    PROPVARIANT* propVar
    )
{
    for(DWORD i = 0; i < cprop; ++i)
    {
    	ASSERT(("vt must be VT_NULL here", propVar[i].vt == VT_NULL));
    	
        switch(propId[i])
        {
            case PROPID_MGMT_MSMQ_ACTIVEQUEUES:
                GetOpenQueues(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_DSSERVER:
                GetDsServer(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_CONNECTED:
                GetDSConnectionMode(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_PRIVATEQ:
                GetPrivateQueueList(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_TYPE:
                GetMsmqType(propVar[i]);
                break;

			case PROPID_MGMT_MSMQ_BYTES_IN_ALL_QUEUES:
				GetBytesInAllQueues(propVar[i]);
				break;
			
            default:
            	ASSERT_BENIGN(("Got an invalid propID", 0));
            	TrERROR(RPC, "Got an illegal prop ID - propID=%d", propId[i]);
				throw bad_hresult(MQ_ERROR_ILLEGAL_PROPID);
        }
    }
}


static
void
GetQueuePathName(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    ASSERT(pQueue != NULL);

    if ((pQueue->GetQueueType() == QUEUE_TYPE_UNKNOWN) ||
        (pQueue->IsPrivateQueue() && !pQueue->IsLocalQueue()))
        return;

    //
    // retrieve the Queue Name from the Queue Object
    //
    LPCWSTR pQueueName = pQueue->GetQueueName();

    if (pQueueName == NULL)
        return;

    var.pwszVal = newwcs(pQueueName);
    var.vt = VT_LPWSTR;
}


static
void
GetQueueFormatName(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    ASSERT(pQueue != NULL);

    DWORD dwFormatSize = 0;

    HRESULT hr = ACHandleToFormatName(
            pQueue->GetQueueHandle(),
            NULL,
            &dwFormatSize
            );
	ASSERT(FAILED(hr));
	AP<WCHAR> FormatName;
	if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
	{
		FormatName = new WCHAR[dwFormatSize];
		hr = ACHandleToFormatName(
            pQueue->GetQueueHandle(),
            FormatName,
            &dwFormatSize
            );
	}
	
	if (FAILED(hr))
	{
		LogHR(hr, s_FN, 101);
		return;
	}

    var.pwszVal = FormatName.detach();
    var.vt = VT_LPWSTR;
}


static
void
GetQueueState(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    LPCWSTR ConnectionState = pQueue->GetConnectionStatus();
    ASSERT (ConnectionState != NULL);

    var.pwszVal = newwcs(ConnectionState);
    var.vt = VT_LPWSTR;
}


static
void
GetQueueType(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    LPCWSTR pQueueType = pQueue->GetType();
    ASSERT (pQueueType != NULL);

    var.pwszVal = newwcs(pQueueType);
    var.vt = VT_LPWSTR;
}



static
void
GetQueueLocation(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    if (pQueue->IsLocalQueue())
    {
        var.pwszVal = newwcs(MGMT_QUEUE_LOCAL_LOCATION);
    }
    else
    {
        var.pwszVal = newwcs(MGMT_QUEUE_REMOTE_LOCATION);
    }
    var.vt = VT_LPWSTR;
}


static
void
GetQueueXact(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    if (pQueue->IsUnkownQueueType())
    {
        var.pwszVal = newwcs(MGMT_QUEUE_UNKNOWN_TYPE);
    }
    else
    {
        if (pQueue->IsTransactionalQueue())
        {
            var.pwszVal = newwcs(MGMT_QUEUE_CORRECT_TYPE);
        }
        else
        {
            var.pwszVal = newwcs(MGMT_QUEUE_INCORRECT_TYPE);
        }
    }
    var.vt = VT_LPWSTR;
}


static
void
GetQueueForeign(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    if (pQueue->IsUnkownQueueType())
    {
        if (pQueue->IsPrivateQueue())
        {
            var.pwszVal = newwcs(MGMT_QUEUE_INCORRECT_TYPE);
        }
        else
        {
            var.pwszVal = newwcs(MGMT_QUEUE_UNKNOWN_TYPE);
        }
    }
    else
    {
        if (pQueue->IsForeign())
        {
            var.pwszVal = newwcs(MGMT_QUEUE_CORRECT_TYPE);
        }
        else
        {
            var.pwszVal = newwcs(MGMT_QUEUE_INCORRECT_TYPE);
        }
    }
    var.vt = VT_LPWSTR;
}


static
void
GetQueueNextHops(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    LPWSTR* NextHopsArray;
    DWORD NoOfNextHops;

    ASSERT(pQueue != NULL);

    if(pQueue->IsLocalQueue())
        return;

    for (;;)
    {
        HRESULT hr;
        LPCWSTR ConnectionStatus = pQueue->GetConnectionStatus();

        if (pQueue->IsDirectHttpQueue())
        {
            //
            // BUGBUG: must add GetAddress methode to CTransport
            //                              Uri Habusha, 16-May-2000
            //
            return;
        }

        if (wcscmp(ConnectionStatus, MGMT_QUEUE_STATE_CONNECTED) == 0)
        {

            LPWSTR pNextHop = pQueue->GetNextHop();
            if (pNextHop == NULL)
            {
                //
                // The Queue isn't in connected status anymore. Get the new status
                //
                continue;
            }

            NoOfNextHops = 1;
            NextHopsArray = new LPWSTR[1];
            NextHopsArray[0] = pNextHop;
            break;
        }

        if (wcscmp(ConnectionStatus, MGMT_QUEUE_STATE_WAITING) == 0)
        {
            hr = SessionMgr.ListPossibleNextHops(pQueue, &NextHopsArray, &NoOfNextHops);
            if (FAILED(hr))
            {
                //
                // The Queue isn't in waiting status anymore. Get the new status
                //
                continue;
            }

            break;

        }

        //
        // The Queue is in NONACTIVE or NEADVALIDATE status.
        //
        return;
    }

    var.calpwstr.cElems = NoOfNextHops;
    var.calpwstr.pElems = NextHopsArray;
    var.vt = VT_LPWSTR | VT_VECTOR;
}


static
void
GetQueueMessageCount(
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulCount;
    var.vt = VT_UI4;
}


static
void
GetJournalQueueMessageCount(
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulJournalCount;
    var.vt = VT_UI4;
}


static
void
GetQueueUsedQuata(
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulQuotaUsed;
    var.vt = VT_UI4;
}


static
void
GetJournalQueueUsedQuata(
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulJournalQuotaUsed;
    var.vt = VT_UI4;
}


static
void
GetQueueEODNextSequence(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    SEQUENCE_INFO* pSeqInfo = new SEQUENCE_INFO;
    pSeqInfo->SeqID = qp.liSeqID;
    pSeqInfo->SeqNo = qp.ulSeqNo;
    pSeqInfo->PrevNo = qp.ulPrevNo;

    var.blob.cbSize = sizeof(SEQUENCE_INFO);
    var.blob.pBlobData = reinterpret_cast<BYTE*>(pSeqInfo);
    var.vt = VT_BLOB;
}


static
void
GetQueueEODLastAcked(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    HRESULT hr;
    ULONG AckedSeqNumber;
    hr = g_OutSeqHash.GetLastAck(qp.liSeqID, AckedSeqNumber);
    if (FAILED(hr))
    {
        //
        // The sequence was not found in the internal data
        // structure. This can be only when all the messages
        // have been acknowledged
        //
        return;
    }

    SEQUENCE_INFO* pSeqInfo = new SEQUENCE_INFO;
    pSeqInfo->SeqID = qp.liSeqID;
    pSeqInfo->SeqNo = AckedSeqNumber;
    pSeqInfo->PrevNo = 0;

    var.blob.cbSize = sizeof(SEQUENCE_INFO);
    var.blob.pBlobData = reinterpret_cast<BYTE*>(pSeqInfo);
    var.vt = VT_BLOB;
}


static
void
GetQueueEODUnAcked(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp,
    BOOL fFirst
    )
{
    if (pQueue->IsLocalQueue())
        return;

    HRESULT hr;
    P<SEQUENCE_INFO> pSeqInfo = new SEQUENCE_INFO;
    pSeqInfo->SeqID = qp.liSeqID;

    hr = g_OutSeqHash.GetUnackedSequence(
                        qp.liSeqID,
                        &pSeqInfo->SeqNo,
                        &pSeqInfo->PrevNo,
                        fFirst
                        );

    if (FAILED(hr))
        return;

    var.blob.cbSize = sizeof(SEQUENCE_INFO);
    var.blob.pBlobData = reinterpret_cast<BYTE*>(pSeqInfo.detach());
    var.vt = VT_BLOB;
}

static
void
GetUnackedCount(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.ulVal = g_OutSeqHash.GetUnackedCount(qp.liSeqID);
    var.vt = VT_UI4;
}


static
void
GetAckedNoReadCount(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.ulVal = g_OutSeqHash.GetAckedNoReadCount(qp.liSeqID);
    var.vt = VT_UI4;
}


static
void
GetLastAckedTime(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    time_t LastAckTime;
    LastAckTime = g_OutSeqHash.GetLastAckedTime(qp.liSeqID);

    if (LastAckTime == 0)
    {
        return;
    }

    var.lVal = INT_PTR_TO_INT(LastAckTime); //BUGBUG bug year 2038
    var.vt = VT_I4;
}

static
void
GetNextResendTime(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.lVal = INT_PTR_TO_INT(g_OutSeqHash.GetNextResendTime(qp.liSeqID)); //BUGBUG bug year 2038
    var.vt = VT_I4;
}

static
void
GetResendIndex(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.lVal = g_OutSeqHash.GetResendIndex(qp.liSeqID);
    var.vt = VT_UI4;

}

static
void
GetEDOSourceInfo(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    if (!pQueue->IsLocalQueue() ||
        (!pQueue->IsDSQueue() && !pQueue->IsPrivateQueue()))
    {
        return;
    }

    const QUEUE_FORMAT qf = pQueue->GetQueueFormat();

    ASSERT((qf.GetType() == QUEUE_FORMAT_TYPE_PUBLIC) ||
           (qf.GetType() == QUEUE_FORMAT_TYPE_PRIVATE));

    //
    // Remove the machine name
    //
    LPCWSTR QueueName = pQueue->GetQueueName();
	ASSERT (QueueName != NULL);
    QueueName = wcschr(QueueName , L'\\') + 1;
	if(QueueName == NULL)
	{
		TrERROR(RPC, "Bad queue name.  Missing backslash in %ls", pQueue->GetQueueName());
		ASSERT (("Bad queuename.", 0));
		throw bad_hresult(MQ_ERROR);
	}

    GUID* pSenderId;
    ULARGE_INTEGER* pSeqId;
    DWORD* pSeqN;
    LPWSTR* pSendQueueFormatName;
    TIME32* pLastActiveTime;
    DWORD* pRejectCount;
    DWORD size;
    AP<PROPVARIANT> RetVar = new PROPVARIANT[6];

    g_pInSeqHash->GetInSequenceInformation(
                        &qf,
                        QueueName,
                        &pSenderId,
                        &pSeqId,
                        &pSeqN,
                        &pSendQueueFormatName,
                        &pLastActiveTime,
                        &pRejectCount,
                        &size
                        );

    if (size == 0)
        return;


    var.vt = VT_VECTOR | VT_VARIANT;
    var.capropvar.cElems = 6;
    var.capropvar.pElems = RetVar.detach();

    PROPVARIANT* pVar = var.capropvar.pElems;
    //
    // Return the format name
    //
    pVar->vt = VT_LPWSTR | VT_VECTOR;
    pVar->calpwstr.cElems = size;
    pVar->calpwstr.pElems = pSendQueueFormatName;
    ++pVar;

    //
    // Return Sender QM ID
    //
    pVar->vt = VT_CLSID | VT_VECTOR;
    pVar->cauuid.cElems = size;
    pVar->cauuid.pElems = pSenderId;
    ++pVar;

    //
    // Return Sequence ID
    //
    pVar->vt = VT_UI8 | VT_VECTOR;
    pVar->cauh.cElems = size;
    pVar->cauh.pElems = pSeqId;
    ++pVar;

    //
    // Return Sequence Number
    //
    pVar->vt = VT_UI4 | VT_VECTOR;
    pVar->caul.cElems = size;
    pVar->caul.pElems = pSeqN;
    ++pVar;

    //
    // Return Last Access Time
    //
    pVar->vt = VT_I4 | VT_VECTOR;
    pVar->cal.cElems = size;
    pVar->cal.pElems = pLastActiveTime; //BUGBUG bug year 2038
    ++pVar;

    //
    // Return Reject Count
    //
    pVar->vt = VT_UI4 | VT_VECTOR;
    pVar->cal.cElems = size;
    pVar->caul.pElems = pRejectCount;
}


static
void
GetResendInterval(
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.lVal = g_OutSeqHash.GetResendInterval(qp.liSeqID);
    var.vt = VT_UI4;
}


static
void
GetLastAckCount(
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.lVal = g_OutSeqHash.GetLastAckCount(qp.liSeqID);
    var.vt = VT_UI4;
}


static
bool
IsMgmtValidQueueFormatName(
	const QUEUE_FORMAT* pQueueFormat
	)
{
	switch (pQueueFormat->GetType())
	{
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
        case QUEUE_FORMAT_TYPE_DIRECT:
			return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_MULTICAST:
        case QUEUE_FORMAT_TYPE_CONNECTOR:
			return true;

		case QUEUE_FORMAT_TYPE_DL:
		case QUEUE_FORMAT_TYPE_MACHINE:
			return false;
	}

	return false;
}


static
void
GetQueueInfo(
    QUEUE_FORMAT* pQueueFormat,
    DWORD cprop,
    PROPID* propId,
    PROPVARIANT* propVar
    )
{

	if ( !IsMgmtValidQueueFormatName(pQueueFormat) )
	{
		TrERROR(RPC, "Got an invalid queue format name");
		throw bad_hresult(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION);
	}

	QUEUE_FORMAT_TRANSLATOR  RealDestinationQueue(pQueueFormat, CONVERT_SLASHES | MAP_QUEUE);

    R<CQueue> pQueue = NULL;

    if (!QueueMgr.LookUpQueue(RealDestinationQueue.get(), &pQueue.ref(), false, false))
    {
    	TrERROR(RPC, "Queue is not active");
        throw bad_hresult(MQ_ERROR_QUEUE_NOT_ACTIVE);
    }

    //
    // Get Queue information from AC
    //
    HRESULT hr;
    CACGetQueueProperties qp;
    hr = ACGetQueueProperties(pQueue->GetQueueHandle(), qp);
    if (FAILED(hr))
    {
    	TrERROR(RPC, "Failed to get queue %ls properties. Error: %!hresult!", pQueue->GetQueueName(), hr);
        throw bad_hresult(hr);
    }

    for(DWORD i =0; i < cprop; ++i)
    {
    	ASSERT(("vt must be VT_NULL here", propVar[i].vt == VT_NULL));
    	
    	switch(propId[i])
        {
        case PROPID_MGMT_QUEUE_PATHNAME:
            GetQueuePathName(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_FORMATNAME:
            GetQueueFormatName(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_TYPE:
            GetQueueType(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_LOCATION:
            GetQueueLocation(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_XACT:
            GetQueueXact(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_FOREIGN:
            GetQueueForeign(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_MESSAGE_COUNT:
            GetQueueMessageCount(propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_USED_QUOTA:
            GetQueueUsedQuata(propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT:
            GetJournalQueueMessageCount(propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA:
            GetJournalQueueUsedQuata(propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_STATE:
            GetQueueState(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_NEXTHOPS:
            GetQueueNextHops(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_EOD_NEXT_SEQ:
            GetQueueEODNextSequence(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_ACK:
            GetQueueEODLastAcked(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK:
            GetQueueEODUnAcked(pQueue.get(), propVar[i], qp, TRUE);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK:
            GetQueueEODUnAcked(pQueue.get(), propVar[i], qp, FALSE);
            break;

        case PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT:
            GetUnackedCount(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT:
            GetAckedNoReadCount(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME:
            GetLastAckedTime(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_RESEND_TIME:
            GetNextResendTime(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_RESEND_COUNT:
            GetResendIndex(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL:
            GetResendInterval(propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_ACK_COUNT:
            GetLastAckCount(propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_SOURCE_INFO:
            GetEDOSourceInfo(pQueue.get(), propVar[i]);
            break;

        default:
        	ASSERT_BENIGN(("Got an invalid propID", 0));
        	TrERROR(RPC, "Got an illegal prop ID - propID=%d", propId[i]);
			throw bad_hresult(MQ_ERROR_ILLEGAL_PROPID);
        }
    }
}



static
HRESULT
VerifyMgmtGetInfoAccess()
{
	static bool   s_bRestrictRead = false ;
	static DWORD  s_dwRestrictToAdmin = MSMQ_DEFAULT_RESTRICT_ADMIN_API ;
	
    if (!s_bRestrictRead)
    {
        //
        // read restrict value from registry.
        //
		DWORD ValueType = REG_DWORD;
		DWORD Size = sizeof(DWORD);
		LONG rc = GetFalconKeyValue(
                        MSMQ_RESTRICT_ADMIN_API_REGNAME,
                        &ValueType,
                        &s_dwRestrictToAdmin,
                        &Size
                        );
        if (rc != ERROR_FILE_NOT_FOUND && rc != ERROR_SUCCESS)
        {
			TrERROR(GENERAL, "Reading from registry failed. Error: %!winerr!", rc);
			return HRESULT_FROM_WIN32(rc);
        }

        s_bRestrictRead = true ;
    }

    if (s_dwRestrictToAdmin == MSMQ_RESTRICT_ADMIN_API_TO_LA)
    {
        //
        // Perform access check to see if caller is local administrator.
        // this access check ignore the DACL in the security descriptor
        // of the msmqConfiguration object.
        //
        HRESULT hr = VerifyMgmtPermission( QueueMgr.GetQMGuid(),
                                    g_szMachineName );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 360);
        }
    }
    else if (s_dwRestrictToAdmin == MSMQ_DEFAULT_RESTRICT_ADMIN_API)
    {
        //
        // Perform "classic" access check. Allow this query only if caller
        // has the "get properties" permission on the msmqConfiguration
        // object.
        //
        HRESULT hr = VerifyMgmtGetPermission( QueueMgr.GetQMGuid(),
                                       g_szMachineName );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 365);
        }
    }
    else
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 370);
    }

    return MQ_OK ;
}

static
void
MgmtGetInfo(
    const MGMT_OBJECT* pObjectFormat,
    DWORD cp,
    PROPID* pProp,
    PROPVARIANT* ppVar
    )
{
    HRESULT hr = VerifyMgmtGetInfoAccess() ;
    if (FAILED(hr))
    {
	    TrERROR(RPC, "Failed to verify permissions to get info. Error: %!hresult!", hr);
        throw bad_hresult(hr);
    }

    for (DWORD i=0; i<cp; i++)
    {
		if (ppVar[i].vt != VT_NULL)
		{
			TrERROR(RPC, "Got a vt different than VT_NULL. vt=%d", ppVar[i].vt);
			throw bad_hresult(MQ_ERROR_INVALID_PARAMETER);	
		}
    }

    //
    // This is an automatic class to free the PropVariant array if the call to GetMachineInfo
    // or GetQueueInfo fails for some reason. If the call succeeds, we'll call detach so that
    // the array will not get freed.
    //
	CPropVar PropVar(ppVar, cp);

	switch (pObjectFormat->type)
    {
        case MGMT_MACHINE:
            GetMachineInfo(cp, pProp, ppVar);
            break;

        case MGMT_QUEUE:
            GetQueueInfo(
                        pObjectFormat->pQueueFormat,
                        cp,
                        pProp,
                        ppVar);
            break;

        default:
        	TrERROR(RPC, "Got an invalid object type. Object type=%d", pObjectFormat->type);
            throw bad_hresult(MQ_ERROR_INVALID_PARAMETER);
    }
	
	PropVar.detach();	
}

static
void
FreeVariant(
    PROPVARIANT& var
    )
{
    ULONG i;

    switch (var.vt)
    {
        case VT_CLSID:
            delete var.puuid;
            break;

        case VT_LPWSTR:
            delete[] var.pwszVal;
            break;

        case VT_BLOB:
            delete[] var.blob.pBlobData;
            break;

        case (VT_I4 | VT_VECTOR):
            delete [] var.cal.pElems;
            break;

        case (VT_UI4 | VT_VECTOR):
            delete [] var.caul.pElems;
            break;

        case (VT_UI8 | VT_VECTOR):
            delete [] var.cauh.pElems;
            break;

        case (VT_VECTOR | VT_CLSID):
            delete[] var.cauuid.pElems;
            break;

        case (VT_VECTOR | VT_LPWSTR):
            for(i = 0; i < var.calpwstr.cElems; i++)
            {
                delete[] var.calpwstr.pElems[i];
            }
            delete [] var.calpwstr.pElems;
            break;

        case (VT_VECTOR | VT_VARIANT):
            for(i = 0; i < var.capropvar.cElems; i++)
            {
                FreeVariant(var.capropvar.pElems[i]);
            }

            delete[] var.capropvar.pElems;
            break;

        default:
            break;
    }

    var.vt = VT_NULL;
}

static bool IsValidMgmtObject(const MGMT_OBJECT* p)
{
    if(p == NULL)
        return false;

    if(p->type == MGMT_MACHINE)
        return true;

    if(p->type != MGMT_QUEUE)
        return false;

    if(p->pQueueFormat == NULL)
        return false;

	return FnIsValidQueueFormat(p->pQueueFormat);
}


/*====================================================

QMMgmtGetInfo

Arguments:

Return Value:

=====================================================*/
HRESULT R_QMMgmtGetInfo(
    /* [in] */ handle_t /* hBind */,
    /* [in] */ const MGMT_OBJECT* pObjectFormat,
    /* [in] */ DWORD cp,
    /* [size_is][in] */ PROPID __RPC_FAR aProp[  ],
    /* [size_is][out][in] */ PROPVARIANT __RPC_FAR apVar[  ]
    )
{
    if(!IsValidMgmtObject(pObjectFormat))
    {
		TrERROR(RPC, "Got an invalid mgmt object");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    try
    {
	    MgmtGetInfo(pObjectFormat, cp, aProp, apVar);
	    return MQ_OK;
    }
    catch(const bad_alloc&)
    {
    	TrERROR(RPC, "Got bad_alloc");
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
    catch (const bad_hresult& e)
    {
		return e.error();
    }

}

//
//  Skip white space characters, return next non ws char
//
inline LPCWSTR skip_ws(LPCWSTR p)
{
    while(isspace(*p))
    {
        ++p;
    }

    return p;
}


static
BOOL
IsTheAction(
    LPCWSTR pInputBuffer,
    LPCWSTR pAction
    )
{
    LPCWSTR p = skip_ws(pInputBuffer);
    if (_wcsnicmp(p, pAction, wcslen(pAction)) == 0)
    {
        p = skip_ws(p + wcslen(pAction));
        if (*p == '\0')
            return TRUE;
    }

    return FALSE;

}

static
HRESULT
MachineAction(
    LPCWSTR pAction
    )
{
    if (IsTheAction(pAction, MACHINE_ACTION_CONNECT))
    {
        QueueMgr.SetConnected();
        return MQ_OK;
    }

    if (IsTheAction(pAction, MACHINE_ACTION_DISCONNECT))
    {
        QueueMgr.SetDisconnected();
        return MQ_OK;
    }

    if (IsTheAction(pAction, MACHINE_ACTION_TIDY))
    {
        return LogHR(ACReleaseResources(g_hAc), s_FN, 90);
    }

    return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 100);
}

static
HRESULT
EdoResendAction(
    const QUEUE_FORMAT* pQueueFormat
    )
{
	R<CQueue> pQueue = NULL;
    if (!QueueMgr.LookUpQueue(pQueueFormat, &pQueue.ref(), false, false))
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_ACTIVE, s_FN, 110);
    }

    //
    // Local queue can't hold. It is meaningless
    //
    if (pQueue->IsLocalQueue())
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 250);
    }

    //
    // Get Queue information from AC
    //
    HRESULT hr;
    CACGetQueueProperties qp;
    hr = ACGetQueueProperties(pQueue->GetQueueHandle(), qp);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }

    g_OutSeqHash.AdminResend(qp.liSeqID);

    return MQ_OK;
}


static
bool
IsMgmtActionValidQueueFormatName(
	const QUEUE_FORMAT* pQueueFormat
	)
{
	switch (pQueueFormat->GetType())
	{
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
        case QUEUE_FORMAT_TYPE_DIRECT:
			return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_MULTICAST:
			return true;

		case QUEUE_FORMAT_TYPE_DL:
		case QUEUE_FORMAT_TYPE_MACHINE:
        case QUEUE_FORMAT_TYPE_CONNECTOR:
			return false;
	}

	return false;
}


static
HRESULT
QueueAction(
    QUEUE_FORMAT* pQueueFormat,
    LPCWSTR pAction
    )
{
	if ( !IsMgmtActionValidQueueFormatName(pQueueFormat) )
	{
		return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 240);
	}

	QUEUE_FORMAT_TRANSLATOR  RealDestinationQueue(pQueueFormat, CONVERT_SLASHES);
	
    if (IsTheAction(pAction, QUEUE_ACTION_PAUSE))
    {
        return LogHR(PauseQueue(RealDestinationQueue.get()), s_FN, 125);
    }

    if (IsTheAction(pAction, QUEUE_ACTION_RESUME))
    {
        return LogHR(ResumeQueue(RealDestinationQueue.get()), s_FN, 130);
    }

    if (IsTheAction(pAction, QUEUE_ACTION_EOD_RESEND))
    {
        return LogHR(EdoResendAction(RealDestinationQueue.get()), s_FN, 140);
    }

    return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 150);
}


HRESULT
MgmtAction(
    const MGMT_OBJECT* pObjectFormat,
    LPCWSTR lpwszAction
    )
{
    HRESULT hr;
    hr = VerifyMgmtPermission(
                QueueMgr.GetQMGuid(),
                g_szMachineName
                );

    if (FAILED(hr))
        return LogHR(hr, s_FN, 160);

	switch (pObjectFormat->type)
    {
        case MGMT_MACHINE:
            return LogHR(MachineAction(lpwszAction), s_FN, 170);

        case MGMT_QUEUE:
            hr = QueueAction(
                             pObjectFormat->pQueueFormat,
                             lpwszAction
                            );
            return LogHR(hr, s_FN, 180);

        default:
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 190);
    }
}

/*====================================================

QMMgmtAction

Arguments:

Return Value:

=====================================================*/
HRESULT R_QMMgmtAction(
    /* [in] */ handle_t /* hBind */,
    /* [in] */ const MGMT_OBJECT* pObjectFormat,
    /* [in] */ LPCWSTR lpwszAction
    )
{
    if(!IsValidMgmtObject(pObjectFormat))
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 199);
    }
	
    try
    {
        return LogHR(MgmtAction(pObjectFormat, lpwszAction), s_FN, 200);
    }
    catch(const bad_hresult& e)
    {
        return LogHR(e.error(), s_FN, 211);
    }
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 210);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\msgprops.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    msgprops.h

Abstract:
    Message properties class

Author:
    Erez Haba (erezh) 23-Feb-2001

--*/

#pragma once

#ifndef _MSGPROPS_H_
#define _MSGPROPS_H_

#include "qmpkt.h"

//---------------------------------------------------------
//
// class CMessageProperty
//
//---------------------------------------------------------

class CMessageProperty {
public:
    //
    //  Message properties
    //
    USHORT wClass;
    DWORD dwTimeToQueue;
    DWORD dwTimeToLive;
    OBJECTID* pMessageID;
    PUCHAR pCorrelationID;
    UCHAR bPriority;
    UCHAR bDelivery;
    UCHAR bAcknowledge;
    UCHAR bAuditing;
    UCHAR bTrace;
    DWORD dwApplicationTag;
    DWORD dwTitleSize;
    const TCHAR* pTitle;
    DWORD dwMsgExtensionSize;
    const UCHAR* pMsgExtension;
    DWORD dwBodySize;
    DWORD dwAllocBodySize;
    const UCHAR* pBody;
    DWORD dwBodyType;
    const UCHAR* pSenderID;
    const UCHAR* pSymmKeys;
    LPCWSTR wszProvName;
    ULONG ulSymmKeysSize;
    ULONG ulPrivLevel;
    ULONG ulHashAlg;
    ULONG ulEncryptAlg;
    ULONG ulSenderIDType;
    ULONG ulProvType;
    UCHAR bDefProv;
    USHORT uSenderIDLen;
    UCHAR bAuthenticated;
    UCHAR bEncrypted;
    const UCHAR *pSenderCert;
    ULONG ulSenderCertLen;
    const UCHAR *pSignature;
    ULONG ulSignatureSize;
    UCHAR bConnector;
	const UCHAR*  pEodAckStreamId;
	ULONG EodAckStreamIdSizeInBytes;
	LONGLONG EodAckSeqId;
	LONGLONG EodAckSeqNum;
	const CSenderStream* pSenderStream;



public:
    CMessageProperty(void);
    CMessageProperty(CQmPacket* pPkt);
    CMessageProperty(
        USHORT usClass,
        PUCHAR pCorrelationId,
        USHORT usPriority,
        UCHAR  ucDelivery
        );

    ~CMessageProperty();

private:
    BOOLEAN fCreatedFromPacket;
};


//
// CMessageProperty constructor
//
inline CMessageProperty::CMessageProperty(void)
{
    memset(this, 0, sizeof(CMessageProperty));
}


inline CMessageProperty::~CMessageProperty()
{
    if (fCreatedFromPacket == TRUE)
    {
        if (pMessageID)
        {
            delete pMessageID;
        }
        if (pCorrelationID)
        {
            delete pCorrelationID;
        }
    }
}

#endif // _MSGPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\main.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    main.cpp

Abstract:


Author:

    Raphi Renous (RaphiR)
    Uri Habusha (urih)

--*/
#include "stdh.h"
#include <new.h>
#include <eh.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include "_rstrct.h"
#include "qmres.h"
#include "sessmgr.h"
#include "perf.h"
#include <ac.h>
#include <qm.h>
#include "qmthrd.h"
#include "cqmgr.h"
#include "cqpriv.h"
#include "qmsecutl.h"
#include "admin.h"
#include "qmnotify.h"
#include <mqcrypt.h>
#include "xact.h"
#include "xactrm.h"
#include "xactin.h"
#include "xactout.h"
#include "xactlog.h"
#include "license.h"
#include "mqcacert.h"
#include "cancel.h"
#include <mqsec.h>
#include "onhold.h"
#include "xactrm.h"
#include "xactmode.h"
#include "lqs.h"
#include "setup.h"
#include "mqsocket.h"
#include "uniansi.h"
#include "process.h"
#include "verstamp.h"
#include <mqnames.h>
#include "qmds.h"
#include "joinstat.h"
#include "_mqres.h"
#include "autohandle.h"
#include "autoreln.h"

//
// mqwin64.cpp may be included only once in a module
//
#include <mqwin64.cpp>

#include <mqstl.h>
#include <Tr.h>
#include <Cm.h>
#include <No.h>
#include <Mt.h>
#include <Mmt.h>
#include <St.h>
#include <Tm.h>
#include <Mtm.h>
#include <Rd.h>
#include <Ad.h>
#include <Xds.h>
#include <Mp.h>
#include <qal.h>
#include <Fn.h>
#include <Msm.h>
#include <Svc.h>

#include "main.tmh"

extern CSessionMgr SessionMgr;
extern CAdmin      Admin;
extern CNotify     g_NotificationHandler;
extern UINT        g_dwIPPort ;

extern void        InitDeferredItemsPool();

LPTSTR  g_szMachineName = NULL;
AP<WCHAR> g_szComputerDnsName;

//
// Windows Bug 612988
// Number of working threads.
//
DWORD  g_dwThreadsNo = 0 ;

//
// Holds the interval in milliseconds of progress report to SCM
//
DWORD g_ServiceProgressTime = MSMQ_PROGRESS_REPORT_TIME_DEFAULT;
DWORD gServiceStopProgressTime = 30000;  // 30 seconds bulk for stop progress

//
// Holds the OS we are running on
//
DWORD   g_dwOperatingSystem;

//
// Holds MSMQ version for debugging purposes
//
CHAR *g_szMsmqBuildNo = VER_PRODUCTVERSION_STR;

static WCHAR *s_FN=L"main";


HANDLE    g_hAc = INVALID_HANDLE_VALUE;
HANDLE    g_hMachine = INVALID_HANDLE_VALUE;
CQGroup * g_pgroupNonactive;
CQGroup * g_pgroupWaiting;
//
// The g_pgroupNotValidated group hold all queues that where opened
// for send without MQIS validation. When MQIS becomes available the
// queue will be validated and moved to the Nonactive group.
//
CQGroup * g_pgroupNotValidated;

//
// The g_pgroupDisconnected group contains all the queues that are on hold
//
CQGroup* g_pgroupDisconnected;

//
// The g_pgroupHardened group contains all the outgoing queues that are not HTTP when
// operating in hardened mode.
//
CQGroup* g_pgroupLocked;

//
//  WorkGroup Installed machine
//
BOOL g_fWorkGroupInstallation = FALSE;
BOOL g_fPureWorkGroupMachine = FALSE;

WCHAR  g_wzDeviceName[MAX_PATH] = {0};

GUID CQueueMgr::m_guidQmQueue = {0};
bool CQueueMgr::m_fDSOnline = false;
bool CQueueMgr::m_bIgnoreOsValidation = false;
bool CQueueMgr::m_fReportQM = false;
bool CQueueMgr::m_bMQSRouting = false;
bool CQueueMgr::m_bTransparentSFD = false;
bool CQueueMgr::m_bMQSDepClients = false;
bool CQueueMgr::m_bEnableReportMessages = false;
LONG CQueueMgr::m_Connected = 0;
bool CQueueMgr::m_fLockdown = false;
bool CQueueMgr::m_fCreatePublicQueueOnBehalfOfRT = MSMQ_SERVICE_QUEUE_CREATION_DEFAULT;

HINSTANCE g_hInstance;

//
// Get the mqutil resource only DLL handle first
//
HMODULE g_hResourceMod = MQGetResourceHandle();

HRESULT RecoverPackets();
static void InitLogging(LPCWSTR lpwszServiceName, DWORD dwSetupStatus);

// Flags for RM init coordination
extern unsigned int g_cMaxCalls;

extern MQUTIL_EXPORT CCancelRpc  g_CancelRpc;

LONG g_ActiveCommitThreads = 0;
bool g_QmGoingDown = false;

TrControl* pMSMQTraceControl = NULL;

bool StartRpcServer(void)
{
    //
    // Issuing RPC Listen ourselves.
    //
    // Note for WinNT: all our interfaces are registed as "AUTOLISTEN".
    // The only reason we need this call here is to enable Win95 (and w2k)
    // clients to call us. Otherwise, when Win95 call RpcBindingSetAuthInfo()
    // it will get a Busy (0x6bb) error.
    //
    // This initialization is needed also for w2k.
    // Otherwise RpcMgmtInqServerPrincName() will get a Busy (0x6bb) error.
    // ilanh 9-July-2000
    //

    RPC_STATUS status = RpcServerListen(
                            1, /* Min Call Threads */
                            g_cMaxCalls,
                            TRUE /* fDontWait */
                            );

    if (status == RPC_S_OK)
        return true;

    //
    // On WinNT, a listen may be issued by DTC, until they fix their
    // code to use RegisterIfEx() instead of RegisterIf().
    //
    if (status == RPC_S_ALREADY_LISTENING)
        return true;

    TrERROR(RPC, "RpcServerListen failed. RPC status=%d", status);

    ASSERT(("RPC failed on RpcServerListen", 0));
    LogRPCStatus(status, s_FN, 1213);
    return false;
}


/*======================================================

Function:        GetStoragePath

Description:     Get storage path for mmf

Arguments:       None

Return Value:    None

========================================================*/
BOOL GetStoragePath(PWSTR PathPointers[AC_PATH_COUNT], int PointersLength)
{
    return (
        //
        //  This first one is a hack to verify that the registry key exists
        //
        GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME,        PathPointers[0], PointersLength, L"") &&

        GetRegistryStoragePath(MSMQ_STORE_RELIABLE_PATH_REGNAME,    PathPointers[0], PointersLength, L"\\r%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_PERSISTENT_PATH_REGNAME,  PathPointers[1], PointersLength, L"\\p%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_JOURNAL_PATH_REGNAME,     PathPointers[2], PointersLength, L"\\j%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_LOG_PATH_REGNAME,         PathPointers[3], PointersLength, L"\\l%07x.mq")
        );
}


/*======================================================

Function:        GetQueueAliasDir

Description:

Arguments:       None

Return Value:    Pointer to queue alias directory path.

Note : Currently - the queue alias directory is on %WINDIR%\SYSTEM32\MSMQ.
       In the future it will set by the setup in the registry
       and will be retrieved by  calling CQueueAliasCfg::GetQueueAliasDirectory()
========================================================*/
static WCHAR* GetQueueAliasPath(void)
{
    //
    // Get mapping directory according to mapping special registry key
    //
    RegEntry registry(0, MSMQ_MAPPING_PATH_REGNAME);
    AP<WCHAR> pRetStr;
    CmQueryValue(registry, &pRetStr);
    if(pRetStr.get() == NULL)
    {
        //
        // Get msmq root path and append to it "mapping" string
        //
        RegEntry registry(0, MSMQ_ROOT_PATH);
        CmQueryValue(registry, &pRetStr);
        if(pRetStr.get() == NULL)
        {
            ASSERT(("Could not find storage directory in registry",0));
            LogIllegalPoint(s_FN, 200);
            return NULL;
        }
        return newwcscat(pRetStr.get() , DIR_MSMQ_MAPPING);
    }
    return pRetStr.detach();
}



/*======================================================

Function:        ConnectToDriver

Description:     Gets all relevant registry data and connects to the AC driver

Arguments:       None

Return Value:    None

========================================================*/
static BOOL ConnectToDriver()
{
    WCHAR StoragePath[AC_PATH_COUNT][MAX_PATH];
    PWSTR StoragePathPointers[AC_PATH_COUNT];
    for(int i = 0; i < AC_PATH_COUNT; i++)
    {
        StoragePathPointers[i] = StoragePath[i];
    }

    if(GetStoragePath(StoragePathPointers, MAX_PATH) == FALSE)
    {
        TrERROR(GENERAL, "Storage path is invalid, look at registry StoreXXXPath");
        return LogBOOL(FALSE, s_FN, 1010);
    }

    ULONG ulMaxMessageSize = MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT;
    ULONG ulDefault = MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT;
    READ_REG_DWORD(
        ulMaxMessageSize,
        MSMQ_MESSAGE_SIZE_LIMIT_REGNAME,
        &ulDefault
        );

    ulDefault = 0;
    ULONG MessageIdLow32 = 0;
    READ_REG_DWORD(
        MessageIdLow32,
        MSMQ_MESSAGE_ID_LOW_32_REGNAME,
        &ulDefault
        );

    ulDefault = 0;
    ULONG MessageIdHigh32 = 0;
    READ_REG_DWORD(
        MessageIdHigh32,
        MSMQ_MESSAGE_ID_HIGH_32_REGNAME,
        &ulDefault
        );

    ULONGLONG MessageId = MessageIdHigh32;
    MessageId = (MessageId << 32);
    MessageId += MessageIdLow32;

    ulDefault = 0;
    ULONG ulSeqID = 0;
    READ_REG_DWORD(
        ulSeqID,
        MSMQ_LAST_SEQID_REGNAME,
        &ulDefault
        );
    LONGLONG liSeqIdAtRestore = 0;
    ((LARGE_INTEGER*)&liSeqIdAtRestore)->HighPart = ulSeqID;


    ulDefault = FALCON_DEFAULT_XACT_V1_COMPATIBLE;
    ULONG ulCompMode = 0;
    READ_REG_DWORD(
        ulCompMode,
        FALCON_XACT_V1_COMPATIBLE_REGNAME,
        &ulDefault
        );

    HRESULT rc = ACConnect(
                    g_hMachine,
                    QueueMgr.GetQMGuid(),
                    StoragePathPointers,
                    MessageId,
                    ulMaxMessageSize,
                    liSeqIdAtRestore,
                    (ulCompMode != 0)
                    );

    if (FAILED(rc))
    {
        LogHR(rc, s_FN, 1030);

        TrERROR(GENERAL, "QM failed to connect to the driver, rc=0x%x", rc);

        return(FALSE);
    }
    return TRUE;
}

//+----------------------------------
//
//  HRESULT  _InitFromRegistry()
//
//+----------------------------------

HRESULT  _InitFromRegistry()
{
    HRESULT hr = QueueMgr.SetQMGuid();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    //
    // Set Machine service type ( read from registry )
    //
    hr = QueueMgr.SetMQSRouting();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    hr = QueueMgr.SetMQSTransparentSFD();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    hr = QueueMgr.SetMQSDepClients();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    hr = QueueMgr.SetEnableReportMessages();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 3143);
    }


    return LogHR(hr, s_FN, 50);
}


void InitializeACDriverName(void)
{
    #define DEVICE_DRIVER_PERFIX TEXT("\\\\.\\")
    READ_REG_STRING(wzReg, MSMQ_DRIVER_REGNAME, MSMQ_DEFAULT_DRIVER);
    if(wcslen(wzReg) + STRLEN(DEVICE_DRIVER_PERFIX) >= TABLE_SIZE(g_wzDeviceName))
    {
        //
        // Very rare case: We do not accept a driver name with that length from the registry
        //
        TrERROR(GENERAL, "Driver name in registry too long %ls", wzReg);
        throw exception();
    }

    wcscpy(g_wzDeviceName, DEVICE_DRIVER_PERFIX);
    wcscat(g_wzDeviceName, wzReg) ;
}


static void InitPureWorkgroupFlag()
{
    if (!g_fWorkGroupInstallation)
    	return;

    //
    // Read join status.
    //
    PNETBUF<WCHAR> pwszNetDomainName = NULL;
    NETSETUP_JOIN_STATUS status = NetSetupUnknownStatus;

    NET_API_STATUS rc = NetGetJoinInformation(
							NULL,
							&pwszNetDomainName,
							&status
							);

    if (NERR_Success != rc)
    {
		TrERROR(GENERAL, "NetGetJoinInformation failed error = 0x%x", rc);
        return;
    }

	if(status == NetSetupWorkgroupName)
		g_fPureWorkGroupMachine = TRUE;
}



BOOL
QmpInitializeInternal(
    DWORD dwSetupStatus
    )
/*++

Routine Description:

    Various initializations.

Arguments:

    dwSetupStatus - Indicates whether this is first time QM is running after setup.

Returned Value:

    TRUE  - Initialization completed successfully.
    FALSE - Initialization failed.

--*/
{
    HRESULT hr =  _InitFromRegistry() ;
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 1050);
        return FALSE;
    }

    if ((dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_NT) ||
        (dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_WIN9X))
    {
        CompleteServerUpgrade();
    }

    //
    // Delete temporary queue (LQS) files
    //
    LQSCleanupTemporaryFiles();

    //
    // Initialize driver related names.
    //
    InitializeACDriverName();

    //
    // Get AC handle
    //
    HRESULT rc;
    rc = ACCreateHandle(&g_hAc);
    if(FAILED(rc))
    {
        TrERROR(GENERAL, "Failed to get first MQAC handle %!status!", rc);
        EvReport(SERVICE_START_ERROR_CONNECT_AC);
        LogHR(rc, s_FN, 1080);
        return(FALSE);
    }

    rc = ACCreateHandle(&g_hMachine);
    if(FAILED(rc))
    {
        TrERROR(GENERAL, "Failed to get MQAC connect handle %!status!", rc);
        EvReport(SERVICE_START_ERROR_CONNECT_AC);
        LogHR(rc, s_FN, 1081);
        return(FALSE);
    }

    //
    // Connect to AC
    //
    if(!ConnectToDriver())
    {
        TrERROR(GENERAL, "INTERNAL ERROR: Unable to connect to the driver");
        EvReport(SERVICE_START_ERROR_CONNECT_AC);
        return LogBOOL(FALSE, s_FN, 1090);
    }

    //
    //  Update machine & journal queue quotas
    //
    DWORD dwQuota;
    DWORD dwJournalQuota;
    GetMachineQuotaCache(&dwQuota, &dwJournalQuota);

    rc = ACSetMachineProperties(g_hMachine, dwQuota);

    ASSERT(SUCCEEDED(rc));
    LogHR(rc, s_FN, 121);


    rc = ACSetQueueProperties(
            g_hMachine,
            FALSE,
            FALSE,
            MQ_PRIV_LEVEL_OPTIONAL,
            DEFAULT_Q_QUOTA,
            dwJournalQuota,
            0,
            FALSE,
            NULL,
            FALSE
            );

    ASSERT(SUCCEEDED(rc));
    LogHR(rc, s_FN, 117);

    //
    // Enable completion port notifications for this handle
    //
    ExAttachHandle(g_hAc);
    ExAttachHandle(g_hMachine);

    //
    // Create wait, Validate and Non-active groups.
    //
    g_pgroupNonactive = new CQGroup;
    g_pgroupNonactive->InitGroup(NULL, FALSE);

    g_pgroupWaiting = new CQGroup;
    g_pgroupWaiting->InitGroup(NULL, TRUE);

    g_pgroupNotValidated = new CQGroup;
    g_pgroupNotValidated->InitGroup(NULL, TRUE);

    g_pgroupDisconnected = new CQGroup;
    g_pgroupDisconnected->InitGroup(NULL, TRUE);

    g_pgroupLocked = new CQGroup;
    g_pgroupLocked->InitGroup(NULL, TRUE);


    return TRUE;

} // QmpInitializeInternal


//
// Following routines deal with recovery of logger and logged subsystems:
//   Resource Manager and Incoming Sequences
//

/*======================================================

 BOOL LoadOldStyleCheckpoint()

 Gets data from the old-style (pre-RC1 B3) checkpoint
 Then logger did not keep the checkpoint versions
 This code will work only once after the upgrade

======================================================*/
BOOL LoadOldStyleCheckpoint()
{
    TrTRACE(GENERAL, "QM Loads Old Style (pre-RC1B3) Checkpoint");

    // Pre-init InSeqHash (create object, find and load last checkpoint)
    HRESULT hr = QMPreInitInSeqHash(0, piOldData);
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_QM_INIT_INSEQ_FILE, hr);
        LogHR(hr, s_FN, 230);
        return FALSE;
    }

    // Pre-init Resource Manager (create RM, find and load last checkpoint)
    hr = QMPreInitResourceManager(0, piOldData);
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_QM_INIT_TRANS_FILE, hr);
        LogHR(hr, s_FN, 240);
        return FALSE;
    }

    // Initizlize logger in the old fashion
    hr = g_Logger.Init_Legacy();
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
        LogHR(hr, s_FN, 250);
        return FALSE;
    }

    return TRUE;
}

/*======================================================

 BOOL LoadCheckpoint(ulNumChkpt)

 ulNumChkpt = # of the checkpoint from the end (1=last, 2=one before, etc.)

 Recovers all logged susbsystems from the specified checkpoint
 Logger keeps appropriate checkpoint versions in consolidation record

======================================================*/
BOOL LoadCheckpoint(ULONG ulNumChkpt)
{
    HRESULT  hr;
    ULONG    ulVerInSeq, ulVerXact;

    //
    // Initialize Logger, get proper versions
    //
    hr = g_Logger.Init(&ulVerInSeq, &ulVerXact, ulNumChkpt);
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
        LogHR(hr, s_FN, 260);
        return FALSE;
    }

    //
    // PreInit In-Sequences hash table (crwate object, load checkpoint data)
    //
    hr = QMPreInitInSeqHash(ulVerInSeq, piNewData);
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_QM_INIT_INSEQ_FILE, hr);
        LogHR(hr, s_FN, 270);
        return FALSE;
    }

    //
    // Pre-init Resource Manager (create RM, load xact data file)
    //
    hr = QMPreInitResourceManager(ulVerXact, piNewData);
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_QM_INIT_TRANS_FILE, hr);
        LogHR(hr, s_FN, 280);
        return FALSE;
    }

    return TRUE;
}

/*======================================================

 BOOL RecoverLoggedSubsystems()

 Initialization and recovery of all log-based subsystems

 Initializes log
 Reads consolidation record and gets versions of checkpoint files
 Reads these correct checkpoint files for all subsystems.
 Reads all post-checkpoint log records

 We may be in 3 valid situations:
   a. New logger data exists (usually)
   b. Old Logger data exists (after upgrade)- then use existing and continue in a new mode
   c. No logger data exists (after setup) - then create log file

======================================================*/
BOOL RecoverLoggedSubsystems(DWORD dwSetupStatus)
{
    // Preinit logger and find out whether the log file exists
    BOOL fLogFileFound;
	BOOL fNewTypeLogFile;	
	//
	// On upgrade we must find an existing log file.
	//
	BOOL fLogFileMustExist = (dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_NT) || (dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_WIN9X);
    HRESULT hr = g_Logger.PreInit(&fLogFileFound, &fNewTypeLogFile, fLogFileMustExist);
    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
        LogHR(hr, s_FN, 290);
        return(FALSE);
    }

    // Case a: New logger data exists - recover in a new fashion
    if (fLogFileFound && fNewTypeLogFile)
    {
        // ConfigureXactMode saw flag of new data in registry
        // Recover checkpoint data from the last checkpoint
        if (!LoadCheckpoint(1))
        {
            TrERROR(GENERAL, "First Checkpoint failed to load");

            LogIllegalPoint(s_FN, 300);
            // Try to use 2nd checkpoint from the end

            // Return to the initial state
            QMFinishResourceManager();
            QMFinishInSeqHash();
            g_Logger.Finish();

            // Recover checkpoint data from the 2nd last checkpoint
            if (!LoadCheckpoint(2))
            {
                TrERROR(GENERAL, "Second Checkpoint failed to load");
                EvReport(CHECKPOINT_RECOVER_ERROR, 1, L"checkpoint");
                LogIllegalPoint(s_FN, 310);
                return FALSE;
            }
        }
    }

    // Case b: Old logger data exists (after upgrade) - recover in an old fashion
    else if (fLogFileFound)
    {
        // Gets checkpoint data from the old-style checkpoint
        if (!LoadOldStyleCheckpoint())
        {
            EvReport(CHECKPOINT_RECOVER_ERROR, 1, L"old checkpoint");
            LogIllegalPoint(s_FN, 320);
            return FALSE;
        }
    }

    // Case c: No logger data existed - we've created log file already, creating objects
    else
    {
        // Pre-init InSeqHash (create CInSeqHash)
        HRESULT hr = QMPreInitInSeqHash(0, piNoData);
        if (FAILED(hr))
        {
            EvReportWithError(EVENT_ERROR_QM_INIT_INSEQ_FILE, hr);
            LogHR(hr, s_FN, 330);
            return FALSE;
        }

        // Pre-init Resource Manager (create RM)
        hr = QMPreInitResourceManager(0, piNoData);
        if (FAILED(hr))
        {
            EvReportWithError(EVENT_ERROR_QM_INIT_TRANS_FILE, hr);
            LogHR(hr, s_FN, 340);
            return FALSE;
        }

    }

    // Now, do recover
    hr = g_Logger.Recover();
    if (FAILED(hr))
    {
       EvReport(CHECKPOINT_RECOVER_ERROR, 1, L"log");
       LogHR(hr, s_FN, 350);
       return(FALSE);
    }

    return TRUE;
}


static DWORD GetThreadPoolCount()
/*++

Routine Description:
  Calculate the number of threads required for the thread pool.

Arguments:
  None.

Returned Value:
  Number of threads desired from the thread pool.

--*/
{
    //
    // Read if there is a preset thread count in configuration store
    //
    DWORD dwThreadNo;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    LONG rc = GetFalconKeyValue(
                FALCON_QM_THREAD_NO_REGNAME,
                &dwType,
                &dwThreadNo,
                &dwSize
                );

    if (rc == ERROR_SUCCESS)
        return dwThreadNo;

    //
    // No thread count was configured, use default values base on operating
    // system functionality and processor count.
    //

    SYSTEM_INFO     SystemInfo;
    GetSystemInfo(&SystemInfo);
    DWORD nProcessors = SystemInfo.dwNumberOfProcessors;

    if (OS_SERVER(g_dwOperatingSystem))
    {
        return (nProcessors * 5 + 3);
    }

    return (nProcessors * 3);
}


static void QmpSetServiceProgressReportTime(void)
{
    const RegEntry reg(0, MSMQ_PROGRESS_REPORT_TIME_REGNAME, MSMQ_PROGRESS_REPORT_TIME_DEFAULT);
    CmQueryValue(reg, &g_ServiceProgressTime);
}


void QmpReportServiceProgress(void)
{
    SvcReportProgress(g_ServiceProgressTime);
}


void SetAssertBenign(void)
{
#ifdef _DEBUG
    DWORD AssertBenignValue = 0;
    const RegEntry reg(L"Debug", L"AssertBenign");
    CmQueryValue(reg, &AssertBenignValue);
    g_fAssertBenign = (AssertBenignValue != 0);
#endif
}


void CheckSecureCommRegistry(void)
{
    DWORD SecureCommWin2k = 0;
    const RegEntry reg(L"Security", L"SecureDSCommunication");
    CmQueryValue(reg, &SecureCommWin2k);
    CmDeleteValue(reg);

    DWORD SecureCommWinNT = 0;
    const RegEntry reg2(NULL, L"SecuredServerConnection");
    CmQueryValue(reg2, &SecureCommWinNT);
    CmDeleteValue(reg2);

	if (SecureCommWin2k || SecureCommWinNT)
	{
		EvReport(SECURE_DS_COMMUNICATION_DISABLED);
	}
}

void
QmpEnableMSMQTracing(
    void
                     )
{
    TCHAR szTraceDirectory[MAX_PATH + 1] = L"";
    int nTraceFileNameLength=0;

    nTraceFileNameLength = GetSystemWindowsDirectory(
                                szTraceDirectory,
                                TABLE_SIZE(szTraceDirectory)
                                );


    //
    // If the return value is greater or equal to the space allow
    // We can't process the buffer since we might not have enough space
    // or it is not NULL terminated properly with the given space.
    //
    if( nTraceFileNameLength < TABLE_SIZE(szTraceDirectory) && nTraceFileNameLength != 0 )
    {
        pMSMQTraceControl = new TrControl(
                                     MSMQ_DEFAULT_TRACE_FLAGS,
                                     MSMQ_TRACE_LOGSESSION_NAME,
                                     szTraceDirectory,
                                     MSMQ_TRACE_FILENAME,
                                     MSMQ_TRACE_FILENAME_EXT,
                                     MSMQ_TRACE_FILENAME_BACKUP_EXT
                                     );

        //
        // Start trace and ignore return code
        //
        pMSMQTraceControl->Start();

    }
}



BOOL
QmpInitialize(
    LPCWSTR pwzServiceName
    )
{

	QmpReportServiceProgress();

    //
    // ISSUE-2000/10/01-erezh hack for cluster/winsock
    // Set the environment variable to filter out cluster
    // addresses.
    //
    if(IsLocalSystemCluster())
    {
        //
        // Cluster is installed and configured on this machine
        // Environment variable is set in the context of the node QM and
        // the virtual machine QM.
        //
        TrERROR(GENERAL, "Setting environement variable DnsFilterClusterIp=1 for cluster address filtering");
        SetEnvironmentVariable(L"DnsFilterClusterIp", L"1");
    }

    QmpReportServiceProgress();

    //
    // Retrieve name of the machine (Always UNICODE)
    //
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    g_szMachineName = new WCHAR[dwSize];

    HRESULT res = GetComputerNameInternal(g_szMachineName, &dwSize);
    if(FAILED(res))
    {
        TrERROR(GENERAL, "Cannot retrieve computer name");
        return LogBOOL(FALSE, s_FN, 1201);
    }

    ASSERT(("must have a service name", NULL != pwzServiceName));
    if (0 == CompareStringsNoCase(pwzServiceName, QM_DEFAULT_SERVICE_NAME))
    {
        //
        // Retrieve the DNS name of this computer ( in unicode).
        // Clustered QM does not have DNS name.
        //

        //
        // Get ComputerDns Size, ignore the returned error
        //
        dwSize = 0;
        GetComputerDnsNameInternal(NULL, &dwSize);

        g_szComputerDnsName = new WCHAR[dwSize];

        res = GetComputerDnsNameInternal(g_szComputerDnsName, &dwSize);
        if(FAILED(res))
        {
            TrERROR(GENERAL, "Cannot retrieve computer DNS name");

            g_szComputerDnsName.free();
            //
            //  this can be a valid situation, where a computer doesn't
            //  have DNS name.
            //
        }
    }

    //
    //  Log down the time, place and version data
    //
    QmpReportServiceProgress();

    //
    // Registry section of the QM is based on the service name.
    // This allows multiple QMs on same machine. (ShaiK)
    //
    SetFalconServiceName(pwzServiceName);

    //
    // The very first time QM is running, it should finish
    // setup/upgrade work.
    //
    DWORD dwSetupStatus = MSMQ_SETUP_DONE;
    READ_REG_DWORD(dwSetupStatus, MSMQ_SETUP_STATUS_REGNAME, &dwSetupStatus);

    //
    // Read workgroup flag from registry.
    //
    READ_REG_DWORD( g_fWorkGroupInstallation,
                    MSMQ_WORKGROUP_REGNAME,
                   &g_fWorkGroupInstallation) ;

    InitLogging(pwzServiceName, dwSetupStatus);

    //
    // Initialize registry, and debug tracing
    //
    CmInitialize(HKEY_LOCAL_MACHINE, GetFalconSectionName(), KEY_ALL_ACCESS);
    SetAssertBenign();
    TrInitialize();

    //
    //  Log down the time, place and version data
    //
    QmpReportServiceProgress();

    QmpEnableMSMQTracing();

    //
    //  Log down the time, place and version data
    //
    QmpReportServiceProgress();

    EvInitialize(pwzServiceName);
    //
    //  Must be called before any COM & ADSI calls
    //
    g_CancelRpc.Init();

    QmpSetServiceProgressReportTime();

    if (dwSetupStatus != MSMQ_SETUP_FRESH_INSTALL)
    {
        QmpReportServiceProgress();

        //
        // Set QM GUID (read from registry). This guid is needed for algorithm
        // of join/move domain, so initialize it here, not in QmpInitializeInternal().
        //
        HRESULT hr =  _InitFromRegistry() ;
        if(FAILED(hr))
        {
            return LogBOOL(FALSE, s_FN, 1200);
        }

        if  (!IsLocalSystemCluster())
        {
            //
            // check if we were workgroup that join domain or domain machine
            // that leave its domain and return to workgroup. This function does
            // not return any value. We won't stop the msmq service just because
            // it failed. Do not call it immediately after setup.
            //
            //  For DS server do not check those transitions. The reason is DC
            //  in safe mode is actually in workgroup, and in this state we don't
            //  want to move to workgroup
            //
            //  On a Cluster system do not check those transitions.
            //  Multiple QMs can live, and some can fail to join, leaving the system
            //  unmanageable. Also Clustered QMs should be managed only by mqclus.dll .
            //
            HandleChangeOfJoinStatus() ;
        }
    } //if (dwSetupStatus != MSMQ_SETUP_FRESH_INSTALL)

	InitPureWorkgroupFlag();

    //
    // Log what we did so far
    //
    TrTRACE(GENERAL, "QM Service name: %ls", pwzServiceName);
    TrTRACE(GENERAL, "QM Setup status: %x", dwSetupStatus);
    TrTRACE(GENERAL, "QM Workgroup Installation: %x", g_fWorkGroupInstallation);
    TrTRACE(GENERAL, "QM Pure Workgroup Machine: %x", g_fPureWorkGroupMachine);
    TrTRACE(GENERAL, "QM found computer name: %ls", g_szMachineName);
    TrTRACE(GENERAL, "QM found computer DNS name: %ls", g_szComputerDnsName);
	

    if ((MSMQ_SETUP_UPGRADE_FROM_NT == dwSetupStatus) ||
        (MSMQ_SETUP_UPGRADE_FROM_WIN9X == dwSetupStatus))
    {
        QmpReportServiceProgress();

        TrTRACE(GENERAL, "QM will now execute migration from NT4/Win98/Win2000: 0x%x", dwSetupStatus);

        MigrateLQS();
        CheckSecureCommRegistry();
    }

	if ((MSMQ_SETUP_UPGRADE_FROM_WIN9X == dwSetupStatus)  ||
         ((MSMQ_SETUP_FRESH_INSTALL == dwSetupStatus) &&
            g_fWorkGroupInstallation) )
    {
        //
        // Add machine security cache, if fresh install of workgroup or
        // upgrade of win9x.
        //
        QmpReportServiceProgress();
        TrTRACE(GENERAL, "QM will now add machine security cache: 0x%x", dwSetupStatus);
        AddMachineSecurity() ;
    }

    //
    // Initialize the qm AC api deferred items pool
    //
    InitDeferredItemsPool();

    //
    // Initialize the private-queues manager object.
    //
    res = g_QPrivate.PrivateQueueInit();

    TrTRACE(GENERAL, "QM Initialized the private-queues manager: 0x%x", res);


    //
    // Get the OS we are running on
    //
    g_dwOperatingSystem = MSMQGetOperatingSystem();

    TrTRACE(GENERAL, "QM detected the OS type: 0x%x", g_dwOperatingSystem);

    //
    // First time QM is running after fresh install,
    // it should create storage directories and
    // machine (system) queues.
    //
    if (MSMQ_SETUP_FRESH_INSTALL == dwSetupStatus)
    {
        try
        {
            QmpReportServiceProgress();

            TrTRACE(GENERAL, "QM creates storage, machine queues, setups ADS (after fresh install)");

            DeleteFalconKeyValue(FALCON_LOGDATA_CREATED_REGNAME);
			CreateMsmqDirectories();
            CreateMachineQueues();
			SetLqsUpdatedSD();
			CompleteMsmqSetupInAds();
			SetMachineSidCacheForAlwaysWorkgroup();
        }
        catch (const CSelfSetupException& err)
        {
            EvReport(err.m_id);
            LogIllegalPoint(s_FN, 181);
            return FALSE;
        }
    }

    //
    // Recreate all machine queues when upgrading from NT
    //
    if ((MSMQ_SETUP_UPGRADE_FROM_NT == dwSetupStatus) ||
        (MSMQ_SETUP_UPGRADE_FROM_WIN9X == dwSetupStatus))
    {
        TrTRACE(GENERAL, "QM creates machine queues (after upgrade from NT)");

		//
		// On .NET, MSMQ doesn't support mix mode of MQIS, W2K and .NET. As a result
		// the mqis_queu$ and nt5pec_mqis_queue$ isn't needed any more. In upgrade mode
		// delete those queues
		//
		DeleteObsoleteMachineQueues();
        CreateMachineQueues();
    }

    QmpReportServiceProgress();
    QMSecurityInit();


    //
    // Initialize the Thread pool and Scheduler
    //
    QmpReportServiceProgress();
    g_dwThreadsNo = GetThreadPoolCount();
    ExInitialize(g_dwThreadsNo);

    TrTRACE(GENERAL, "Succeeded to Create %d QM thread.", g_dwThreadsNo);

    if(!g_fWorkGroupInstallation)
    {
        McInitialize();
    }

    MpInitialize();
	NoInitialize();

	//
	// Init Listening IP address
	//
	InitBindingIPAddress();

    MtInitialize();
    MmtInitialize();
    StInitialize(GetBindingIPAddress());
    TmInitialize();
    MtmInitialize();
    XdsInitialize();
    XmlInitialize();
    CryInitialize();
    FnInitialize();
    MsmInitialize();



    QmpReportServiceProgress();
    QalInitialize(AP<WCHAR>(GetQueueAliasPath()));

    QmpReportServiceProgress();
    if(!QmpInitializeInternal(dwSetupStatus))
    {
       return LogBOOL(FALSE, s_FN, 1202);
    }

    //
    // Initialize the licensing manager object.
    //
    QmpReportServiceProgress();
    res = g_QMLicense.Init() ;
    if(FAILED(res))
    {
        TrERROR(GENERAL, "Cannot initialize licensing");
        return LogBOOL(FALSE, s_FN, 1203);
    }

    //
    // Init QM Perf
    //
    res = QMPrfInit();
    if(FAILED(res))
    {
        EvReportWithError(EVENT_WARN_QM_PERF_INIT_FAILED, res);
        ASSERT_BENIGN(("Failed QMPrfInit(). Performace data will not be available.", FALSE));
    }

    SessionMgr.Init();

    //
    // Activate the QM threads
    //
    BOOL Success = QueueMgr.InitQueueMgr();
    if (!Success)
    {
        return LogBOOL(FALSE, s_FN, 1205);
    }


	

    //
    // Init Admin command queue
    //
    HRESULT hr = Admin.Init();
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to Init Admin command queue, hr=0x%x", hr);
        EvReportWithError(EVENT_ERROR_QM_SYSTEM_QUEUE_INIT, hr, 1, ADMINISTRATION_QUEUE_NAME);
        return FALSE;
    }

    //
    // Init Ordering command queue
    //
    QmpReportServiceProgress();
    hr = QMInitOrderQueue();
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to Init order queue, hr=0x%x", hr);
        EvReportWithError(EVENT_ERROR_QM_SYSTEM_QUEUE_INIT, hr, 1, ORDERING_QUEUE_NAME);
        return FALSE;
    }

    //
    // Get fine-tuning parameters for xact mechanism
    //
    QMPreInitXact();

    //
    // Configure transactional mode
    //
    hr = ConfigureXactMode();
    if(FAILED(hr))
    {
        //
        // Error already reported to the event log
        //
        return LogBOOL(FALSE, s_FN, 1207);
    }

    // Initilize log and recover all logged subsystems
    //   (including data recovery for InSeq and Xacts)
    //
    QmpReportServiceProgress();
    if(!RecoverLoggedSubsystems(dwSetupStatus))
    {
        TrERROR(GENERAL, "Failed to recover logged subsystems");
        return LogBOOL(FALSE, s_FN, 1208);
    }

    //
    // Recover all packets and transactions
    //
    QmpReportServiceProgress();
    hr = RecoverPackets();
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to recover packets, hr=0x%x", hr);
        EvReportWithError(EVENT_ERROR_QM_RECOVERY, hr);
        return LogBOOL(FALSE, s_FN, 1209);
    }

    //
    // Make checkpoint after the end of recovery
    //
    g_Logger.Activate();
    HANDLE h = CreateEvent(0, TRUE,FALSE, 0);
    if (h == NULL)
    {
        LogNTStatus(GetLastError(), s_FN, 171);
        ASSERT(0);
    }

    QmpReportServiceProgress();
    BOOL b =  g_Logger.MakeCheckpoint(h);
    if (!b)
    {
        CloseHandle(h);
        return LogBOOL(FALSE, s_FN, 191);
    }

    DWORD dwResult = WaitForSingleObject(h, INFINITE);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 192);
    }
    CloseHandle(h);

	//
	// Finished recovery. If the log file was an 'old type' this will mark it as new.
	// We don't care if we fail here since we can recover new type data with the old algorithms,
	// And on next recovery we will try to set the registry value again.
	//
	hr = g_Logger.SetLogFileCreated();
	if(FAILED(hr))
	{
		EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
		TrERROR(GENERAL, "Failed to complete log file creation. %!hresult!", hr);
		return FALSE;
	}

	//
    // Recovery completed successfully, reconfigure
    // transactional mode
    //
    hr = ReconfigureXactMode();
    if(FAILED(hr))
    {
		EvReportWithError(EVENT_ERROR_CANT_INIT_LOGGER, hr);
		TrERROR(GENERAL, "Failed to reconfigure xact mode to default commit. %!hresult!", hr);
        return LogBOOL(FALSE, s_FN, 1210);
    }


    //
    // Initialize resource manager
    // We allready made a checkpoint therefore it is safe to report
    // to DTC that recovery is complete.
    //
    QmpReportServiceProgress();
    hr = QMInitResourceManager();
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to initialize resource manager, hr=0x%x", hr);


    }
	else
	{
		TrTRACE(GENERAL, "Successful Resource Manager initialization");
	}

    //
    // read IP port from registry.
    //
    DWORD dwDef = FALCON_DEFAULT_IP_PORT ;
    READ_REG_DWORD(g_dwIPPort,
                   FALCON_IP_PORT_REGNAME,
                   &dwDef ) ;

    TrTRACE(GENERAL, "QM will use IP port : %d", g_dwIPPort);

    //
    // Restore the onhold queues. It must be after recovery.
    // During the recovery we open the foreign queue with the connector
    // information. If it is done in oposite order the connector machine
    // guid isn't set and we can get messages out of order.
    //
    QmpReportServiceProgress();
    InitOnHold();


    //
    // Retreive the machine connection status from the registery
    //
    QueueMgr.InitConnected();

    //
    // Init routing should be called before OnlineInitialization, since it can called
    // RdGetConnector during the Validation of open queue.
    //
    QmpReportServiceProgress();

	DWORD  routingRefreshIntervalInMinutes;
    const RegEntry routingRefresh(NULL, MSMQ_ROUTING_REFRESH_INTERVAL_REGNAME, MSMQ_DEFAULT_ROUTING_REFRESH_INTERVAL);
    CmQueryValue(routingRefresh, &routingRefreshIntervalInMinutes);
    RdInitialize(
    	IsRoutingServer(),
    	CTimeDuration::FromMilliSeconds(routingRefreshIntervalInMinutes * 60 *1000)
    	);

    hr = ADInit(
            QMLookForOnlineDS,
            NULL,   // pGetServers
            false,  // fSetupMode
            true,   // fQMDll
            false,  // fIgnoreWorkGroup
            true    // fDisableDownlevelNotifications
            );

    if (FAILED(hr))
    {
        EvReportWithError(EVENT_ERROR_DS_INIT_FAILED, hr);
        return LogBOOL(FALSE, s_FN, 1215);
    }

    //
    //  Init notification queue
    //
    QmpReportServiceProgress();
    hr = g_NotificationHandler.Init();
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to initialize notification handler, hr=0x%x", hr);
        EvReportWithError(EVENT_ERROR_QM_SYSTEM_QUEUE_INIT, hr, 1, NOTIFICATION_QUEUE_NAME);
        return FALSE;
    }

    //
    // Try to get online with the Active Directory
    //
    QmpReportServiceProgress();
    ScheduleOnlineInitialization();

    QmpReportServiceProgress();
    if (!QMOneTimeInit())
    {
    	TrERROR(GENERAL, "Failed QM one time init, exiting");
        return LogBOOL(FALSE, s_FN, 1214);
    }

    if ((MSMQ_SETUP_UPGRADE_FROM_NT == dwSetupStatus) ||
        (MSMQ_SETUP_UPGRADE_FROM_WIN9X == dwSetupStatus))
    {
		//
		// Update msmq properties in AD.
		// Add enhanced encryption support if needed.
		//
        TrTRACE(GENERAL, "Add enhanced encryption support if needed");
        UpgradeMsmqSetupInAds();
    }

    //
    // No need to do post setup work next time we start!
    // We reset the value rather than deleting the key b/c mqclus depends on that (otherwise
    // every Open of cluster resource will be treated as Create). (shaik, 10-Jul-2000)
    //
    DWORD dwType = REG_DWORD;
    DWORD dwDone = MSMQ_SETUP_DONE;
    dwSize = sizeof(DWORD);
    SetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, &dwType, &dwDone, &dwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwDone = TRUE;
    SetFalconKeyValue(MSMQ_SEQUENTIAL_ID_MSMQ3_FORMAT_REGNAME, &dwType, &dwDone, &dwSize);

	if(QueueMgr.GetLockdown())
	{
		EvReport(EVENT_INFO_LOCKDOWN);
		TrTRACE(GENERAL, "MSMQ is operating in Lockdown mode.");
	}

    TrTRACE(GENERAL, "QMinit succeeded");
    EvReport(EVENT_INFO_MSMQ_SERVICE_STARTED);

    return TRUE;

} // QmpInitialize


static void StopServiceActivity()
/*++

Routine Description:
    Gracefully stopping the service activity
    1. Wake up the transaction logger thread to in order for it to terminate
    2. While waiting for the thread to end - indicate to the Service Control Manager that the service stop is pending

Arguments:
    None

Returned Value:
    None.

--*/
{
    TrTRACE(GENERAL, "Begin to stop the service");

    SvcReportProgress(gServiceStopProgressTime);

	
	g_QmGoingDown = true;
	HRESULT hr = RpcMgmtStopServerListening(NULL);
	ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);

	//
	// ISSUE-2002/08/18-tomerw we need to cancel progrematically all the rpc calls
	// we want to cancel and use RpcMgmtWaitServerListen() to wait till all the calls
	// we dont want to cancel will finish. meanwhile we will use this hack to wait
	// till Commit request which already started will be finished.
	//
    for (int i=0; i<10; i++)
    {
    	if (g_ActiveCommitThreads == 0)
    	{
			//
			// We wait here to be sure that the rpc threads has enough time to return to their
			// caller after decreassing the thread count.
    		//
		   	Sleep(100);
    		break;
    	}
    	Sleep(500);
    }


    HANDLE hLoggerThreadObject = XactLogSignalExitThread();
    if (INVALID_HANDLE_VALUE == hLoggerThreadObject)
    	return;

	//
    // Wait for the logger to finish.
    // We do this within a loop in order to continue indicating to the service
    // control manager that we are progressing with the termination.
    // Note that we wait for half the time we are requesting so that we can
    // request an extension before the time is over
    //
    for (;;)
    {
    	DWORD rc = WaitForSingleObject(hLoggerThreadObject, gServiceStopProgressTime/2);
    	if (rc == WAIT_OBJECT_0)
    	{
    		TrTRACE(GENERAL, "Logger event signaled. Service will now stop");
    		break;
    	}
    	else if (rc == WAIT_FAILED)
    	{
    		DWORD gle = GetLastError();
    		TrERROR(GENERAL, "Failed WaitForSingleObject on logger thread. %!winerr!",gle);
    		break;
    	}

		//
    	// Indicate that we are still pending
    	//
	    TrTRACE(GENERAL, "Still pending - Indicate progress and loop");
    	SvcReportProgress(gServiceStopProgressTime);
    }
}

//
// Create the NT event object that will be used to control service shutdown/stop
//
static CHandle  shStopEvent(CreateEvent(NULL, FALSE, FALSE, NULL));

static bool     sfServiceStopRequested = FALSE;





VOID
AppRun(
    LPCWSTR pServiceName
    )
/*++

Routine Description:
    Service startup code. It should immidiatly report it state and enable the
    controls it accepts.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
    try
    {
        if(!QmpInitialize(pServiceName))
        {
            throw exception();
        }

        if(!StartRpcServer())
        {
            throw exception();
        }

        if ((shStopEvent == NULL))
        {
    		TrERROR(GENERAL, "start-up failed. Can't create an event");
            throw exception();
        }
        sfServiceStopRequested = FALSE;

        SvcReportState(SERVICE_RUNNING);

        SvcEnableControls(
            SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_SHUTDOWN
            );

		//
        // Wait for a stop service or shutdwon service event
        //
        DWORD dwResult = WaitForSingleObject(shStopEvent, INFINITE);
    	if (dwResult != WAIT_OBJECT_0)
    	{
    		TrERROR(GENERAL, "Failed WaitForSingleObject on  stop event. error=0x%x",GetLastError());
     	   	LogIllegalPoint(s_FN, 1422);
     	   	ASSERT(("AppRun - WaitForSingleObject failed", FALSE));
    	}

        pMSMQTraceControl->WriteRegistry();

        delete pMSMQTraceControl;

    	//
    	// Try to gracefully stop
    	//
		StopServiceActivity();    	
    	if (sfServiceStopRequested)
    	{	
    		EvReport(QM_SERVICE_STOPPED);
    	}

    }
    catch (const bad_alloc&)
    {
        EvReport(SERVICE_START_ERROR_LOW_RESOURCES);
        LogIllegalPoint(s_FN, 1425);
    }
    catch(const exception&)
    {
        LogIllegalPoint(s_FN, 1420);
    }

    SvcReportState(SERVICE_STOPPED);
}

VOID
AppStop(
    VOID
    )
{
    TrTRACE(GENERAL, "MSMQ Service is stopping...");
    sfServiceStopRequested = TRUE;

	//
	//  Report a 'service is stopping' progress to SCM.
	//
    SvcReportState(SERVICE_STOP_PENDING);

	// Signal a stop request - handled by AppRun()
	if (!SetEvent(shStopEvent))
	{
		TrERROR(GENERAL, "Failed to set service stop event. error=0x%x",GetLastError());
	}
}


VOID
AppShutdown(
    VOID
    )
{
    TrTRACE(GENERAL, "MSMQ Service is shutting down...");

	//
	//  Report a 'service is stopping' progress to SCM.
	//
    SvcReportState(SERVICE_STOP_PENDING);

	// Signal a stop request - handled by AppRun()
	if (!SetEvent(shStopEvent))
	{
		TrERROR(GENERAL, "Failed to set service stop event. error=0x%x",GetLastError());
	}
}


VOID
AppPause(
    VOID
    )
{
    ASSERT(("MQMQ Service unexpectedly got Pause control from SCM", 0));
}


VOID
AppContinue(
    VOID
    )
{
    ASSERT(("MSMQ Service unexpectedly got Continue control from SCM", 0));
}


QM_EXPORT
int
APIENTRY
QMMain(
    int argc,
    LPCTSTR argv[]
    )
{
    try
    {

        //
        // If a command line parameter is passed, use it as the dummy service
        // name. This is very usful for debugging cluster startup code.
        //
        LPCWSTR DummyServiceName = (argc == 2) ? argv[1] : L"MSMQ";
        SvcInitialize(DummyServiceName);
    }
    catch(const exception&)
    {
        return -1;
    }

    return 0;
}





HRESULT
QmpOpenAppsReceiveQueue(
    const QUEUE_FORMAT* pQueueFormat,
    LPRECEIVE_COMPLETION_ROUTINE lpReceiveRoutine
    )
{
    HRESULT hr2 = QueueMgr.OpenAppsReceiveQueue(
                        pQueueFormat,
                        lpReceiveRoutine
                        );
    return LogHR(hr2, s_FN, 70);
}


static
HRESULT
QMSignPacket(
    IN CMessageProperty*   pmp,
    IN const QUEUE_FORMAT* pAdminQueueFormat,
    IN const QUEUE_FORMAT* pResponseQueueFormat
    )
{
    DWORD   dwErr ;
    HRESULT hr;

    pmp->ulSenderIDType = MQMSG_SENDERID_TYPE_QM;
    pmp->pSenderID = (PUCHAR)QueueMgr.GetQMGuid();
    pmp->uSenderIDLen = sizeof(GUID);
    pmp->ulHashAlg = PROPID_M_DEFUALT_HASH_ALG;
    pmp->bDefProv = TRUE;

    //
    // Compute the hash value for the message body and sign the message.
    //

    CHCryptHash hHash;

    HCRYPTPROV hProvQM = NULL ;
    hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                     &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 80);
    }

    ASSERT(hProvQM) ;
    if (!CryptCreateHash(       // Create a hash object
            hProvQM,
            pmp->ulHashAlg,
            0,
            0,
            &hHash))
    {
        dwErr = GetLastError() ;
        TrERROR(SECURITY, "QMSignPacket(), fail at CryptCreateHash(), err- %lut", dwErr);

        LogNTStatus(dwErr, s_FN, 90);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    hr = HashMessageProperties( // Compute the hash value for the mesage body.
            hHash,
            pmp,
            pResponseQueueFormat,
            pAdminQueueFormat
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

    if (!CryptSignHash(        // Sign the message.
            hHash,
            AT_SIGNATURE,
            NULL,
            0,
            const_cast<PUCHAR>(pmp->pSignature),
            &pmp->ulSignatureSize))
    {
        dwErr = GetLastError();
        TrERROR(SECURITY, "Failed to SignHash, err = %!winerr!", dwErr);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    return(MQ_OK);
}


HRESULT
QmpSendPacket(
    CMessageProperty  * pmp,
    CONST QUEUE_FORMAT* pqdDstQueue,
    CONST QUEUE_FORMAT* pqdAdminQueue,
    CONST QUEUE_FORMAT* pqdResponseQueue,
    BOOL fSign /* = FALSE */
    )
{
    HRESULT hr;
    BYTE abMessageSignature[MAX_MESSAGE_SIGNATURE_SIZE];

    if (fSign)
    {
        pmp->pSignature = abMessageSignature;
        pmp->ulSignatureSize = sizeof(abMessageSignature);
        hr = QMSignPacket(
                 pmp,
                 pqdAdminQueue,
                 pqdResponseQueue
                 );

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 120);
        }
    }

    HRESULT hr2 = QueueMgr.SendPacket(
                        pmp,
                        pqdDstQueue,
                        1,
                        pqdAdminQueue,
                        pqdResponseQueue
                        );
    return LogHR(hr2, s_FN, 130);
} // QmpSendPacket


static void __cdecl QmpExceptionTranslator(unsigned int u, PEXCEPTION_POINTERS)
{
    switch(u)
    {
        case STATUS_NO_MEMORY:
        case STATUS_STACK_OVERFLOW:
        case STATUS_INSUFFICIENT_RESOURCES:
            LogHR(u, s_FN, 164);
            throw bad_alloc();

    }
}


static void __cdecl QmpAbnormalTerminationHandler()
{
    LogBOOL(FALSE, s_FN, 1300);
    ASSERT_RELEASE(("Abnormal Termination", 0));
}


/*====================================================

DllMain

Initialize/cleanup dll

=====================================================*/

//
// ISSUE-2000/12/07-erezh Compiler bug, warning 4535
// This seems like a compiler bug, warning 4535 is generated even though
// that /EHc is specified to the compiler.
//
// Specify /EHa with the use of _set_se_translator() library function
//
#pragma warning(disable: 4535)

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID /*lpvReserved*/)
{
    g_hInstance = hMod;

    switch(dwReason)
    {
       case DLL_PROCESS_ATTACH:
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");
            AllocateThreadTLSs();
            MQUInitGlobalScurityVars() ;
            // FALL Through

        case DLL_THREAD_ATTACH:
            //
            // Install structured exceptions translator, and abnormal termination handlers
            //
            _set_se_translator(QmpExceptionTranslator);
            set_terminate(QmpAbnormalTerminationHandler);
            break;

       case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            // FALL Through

        case DLL_THREAD_DETACH:
            FreeThreadEvent();
            FreeHandleForRpcCancel() ;
            _set_se_translator(0);
            set_terminate(0);
            break;
    }

    return TRUE;
}


void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, hr));
	TrERROR(LOG, "%ls(%u), HRESULT: 0x%x", wszFileName, usPoint, hr);
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, status));
	TrERROR(LOG, "%ls(%u), NT STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, status));
	TrERROR(LOG, "%ls(%u), RPC STATUS: 0x%x", wszFileName, usPoint, status);
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((wszFileName, usPoint, b));
	TrERROR(LOG, "%ls(%u), BOOL: 0x%x", wszFileName, usPoint, b);
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
	KEEP_ERROR_HISTORY((wszFileName, usPoint, 0));
	TrERROR(LOG, "%ls(%u), Illegal point", wszFileName, usPoint);
}

void LogIllegalPointValue(DWORD_PTR dw3264, LPCWSTR wszFileName, USHORT usPoint)
{
	KEEP_ERROR_HISTORY((wszFileName, usPoint, 0));
	TrERROR(LOG, "%ls(%u), Illegal point Value=%Ix", wszFileName, usPoint, dw3264);
}

static void InitLogging(LPCWSTR lpwszServiceName, DWORD dwSetupStatus)
{
	TrPRINT(GENERAL, "*** MSMQ v%s service started ***", g_szMsmqBuildNo);
	TrPRINT(
		GENERAL,
		"*** Machine:'%ls' DNSName:'%ls' ServiceName:'%ls' Workgroup:%d Setup status:%d ***",
		g_szMachineName,
		g_szComputerDnsName,
		lpwszServiceName,
		g_fWorkGroupInstallation,
		dwSetupStatus
		);

    OSVERSIONINFO verOsInfo;
    verOsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&verOsInfo))
    {
    	TrPRINT(
    		GENERAL,
    		"*** OS: %d.%d.%d %ls ***",
    		verOsInfo.dwMajorVersion,
    		verOsInfo.dwMinorVersion,
    		verOsInfo.dwBuildNumber,
    		verOsInfo.szCSDVersion
    		);
    }
}


//
// Nedded for linking with fn.lib
//
LPCWSTR
McComputerName(
    void
    )
{
    ASSERT(g_szMachineName != NULL);
    return g_szMachineName;
}

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
    void
    )
{
    ASSERT(g_szMachineName != NULL);
    return wcslen(g_szMachineName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\lqs.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lqs.cpp

Abstract:
    Loacl Queue Store.

Author:
    Boaz Feldbaum (BoazF) 12-Feb-1997.

--*/
#include "stdh.h"
#include "cqmgr.h"
#include "lqs.h"
#include "regqueue.h"
#include "uniansi.h"
#include "qmutil.h"
#include <mqsec.h>
#include "DumpAuthzUtl.h"
#include <aclapi.h>
#include <autoreln.h>
#include <fn.h>

#include "lqs.tmh"

extern LPTSTR      g_szMachineName;
extern CQueueMgr       QueueMgr;
#ifdef _WIN64
//
//HLQS handle for enumeration of private queues from admin, passed inside an MSMQ message as 32 bit value
//
extern CContextMap g_map_QM_HLQS;
#endif //_WIN64

static WCHAR *s_FN=L"lqs";

#define LQS_SUBDIRECTORY                TEXT("\\LQS\\")

#define LQS_TYPE_PROPERTY_NAME          TEXT("Type")
#define LQS_INSTANCE_PROPERTY_NAME      TEXT("Instance")
#define LQS_BASEPRIO_PROPERTY_NAME      TEXT("BasePriority")
#define LQS_JOURNAL_PROPERTY_NAME       TEXT("Journal")
#define LQS_QUOTA_PROPERTY_NAME         TEXT("Quota")
#define LQS_JQUOTA_PROPERTY_NAME        TEXT("JournalQuota")
#define LQS_TCREATE_PROPERTY_NAME       TEXT("CreateTime")
#define LQS_TMODIFY_PROPERTY_NAME       TEXT("ModifyTime")
#define LQS_SECURITY_PROPERTY_NAME      TEXT("Security")
#define LQS_TSTAMP_PROPERTY_NAME        TEXT("TimeStamp")
#define LQS_PATHNAME_PROPERTY_NAME      TEXT("PathName")
#define LQS_QUEUENAME_PROPERTY_NAME     TEXT("QueueName")
#define LQS_LABEL_PROPERTY_NAME         TEXT("Label")
#define LQS_MULTICAST_ADDRESS_PROPERTY_NAME TEXT("MulticastAddress")
#define LQS_AUTH_PROPERTY_NAME          TEXT("Authenticate")
#define LQS_PRIVLEVEL_PROPERTY_NAME     TEXT("PrivLevel")
#define LQS_TRANSACTION_PROPERTY_NAME   TEXT("Transaction")
#define LQS_SYSQ_PROPERTY_NAME          TEXT("SystemQueue")
#define LQS_PROP_SECTION_NAME           TEXT("Properties")

#define LQS_SIGNATURE_NAME              TEXT("Signature")
#define LQS_SIGNATURE_VALUE             TEXT("DoronJ")
#define LQS_SIGNATURE_NULL_VALUE        TEXT("EpspoK")

static const WCHAR x_szTemporarySuffix[] = TEXT(".tmp");

//
// Purely local definitions.
//
#define LQS_PUBLIC_QUEUE                1
#define LQS_PRIVATE_QUEUE               2

HRESULT IsBadLQSFile( LPCWSTR lpszFileName,
                      BOOL    fDeleteIfBad = TRUE) ;

//
// LQS_MAX_VALUE_SIZE is the maximum length a property value can have in the
// INI file.
//
#define LQS_MAX_VALUE_SIZE              (64 * 1024)

#ifdef _DEBUG
#define LQS_HANDLE_TYPE_QUEUE           1
#define LQS_HANDLE_TYPE_FIND            2
#endif

#ifdef _DEBUG
#define LQS_MAGIC_NUMBER                0x53514c00  // 'LQS'
#endif

class CAutoCloseFindFile
{
public:
    CAutoCloseFindFile(HANDLE h =INVALID_HANDLE_VALUE) { m_h = h; };
    ~CAutoCloseFindFile() { if (m_h != INVALID_HANDLE_VALUE) FindClose(m_h); };

public:
    CAutoCloseFindFile & operator =(HANDLE h) { m_h = h; return(*this); };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

//
// The local queue store handle class
//
class _HLQS
{
public:
    _HLQS(LPCWSTR lpszQueuePath, LPCWSTR lpszFilePathName); // For queue operations
    _HLQS(HANDLE hFindFile); // For queue enumerations
    ~_HLQS();
    BOOL IsEqualQueuePathName(LPCWSTR lpszPathName);
    LPCWSTR GetFileName();
    LPCWSTR GetTemporaryFileName();
    LPCWSTR GetQueuePathName();
    HANDLE GetFindHandle();
    DWORD AddRef();
    DWORD Release();
#ifdef _DEBUG
    BOOL Validate() const;
#endif
#ifdef _WIN64
    void SetMappedHLQS(DWORD dwMappedHLQS);
#endif //_WIN64

private:
    void SetFilePathName(LPCWSTR lpszFilePathName);
    void SetQueuePathName(LPCWSTR lpszQueuePathName);

private:
    AP<WCHAR> m_lpszFilePathName;
    AP<WCHAR> m_lpszTemporaryFilePathName;
    AP<WCHAR> m_lpszQueuePathName;
    int m_iRefCount;
    CAutoCloseFindFile m_hFindFile;
#ifdef _DEBUG
    BYTE m_bType;
    DWORD m_dwMagic;
#endif
#ifdef _WIN64
    DWORD m_dwMappedHLQS;
#endif //_WIN64
};

//
// Constractor for queue operations
//
_HLQS::_HLQS(
    LPCWSTR lpszQueuePath,
    LPCWSTR lpszFilePathName)
{
    SetQueuePathName(lpszQueuePath);
    SetFilePathName(lpszFilePathName);
    m_iRefCount = 0;
#ifdef _DEBUG
    m_bType = LQS_HANDLE_TYPE_QUEUE;
    m_dwMagic = LQS_MAGIC_NUMBER;
#endif
#ifdef _WIN64
    m_dwMappedHLQS = 0;
#endif //_WIN64
}

//
// Constractor for queue enumerations.
//
_HLQS::_HLQS(HANDLE hFindFile)
{
    m_iRefCount = 0;
    m_hFindFile = hFindFile;
#ifdef _DEBUG
    m_bType = LQS_HANDLE_TYPE_FIND;
    m_dwMagic = LQS_MAGIC_NUMBER;
#endif
#ifdef _WIN64
    m_dwMappedHLQS = 0;
#endif //_WIN64
}

_HLQS::~_HLQS()
{
    ASSERT(m_iRefCount == 0);
#ifdef _WIN64
    //
    // remove mapping of this instance from the map
    //
    if (m_dwMappedHLQS != 0)
    {
        DELETE_FROM_CONTEXT_MAP(g_map_QM_HLQS, m_dwMappedHLQS);
    }
#endif //_WIN64
}

#ifdef _DEBUG
//
// Validate that the handle is a valid local queue store handle.
//
BOOL _HLQS::Validate() const
{
    return !IsBadReadPtr(&m_dwMagic, sizeof(m_dwMagic)) &&
           (m_dwMagic == LQS_MAGIC_NUMBER);
}
#endif

//
// Store the path to the file that contains the queue properties.
//
void _HLQS::SetFilePathName(LPCWSTR lpszFilePathName)
{
    delete[] m_lpszFilePathName.detach();
    delete[] m_lpszTemporaryFilePathName.detach();
    if (lpszFilePathName)
    {
        m_lpszFilePathName = new WCHAR[wcslen(lpszFilePathName) + 1];
        wcscpy(m_lpszFilePathName, lpszFilePathName);
    }
}

//
// Store the queue path name.
//
void _HLQS::SetQueuePathName(LPCWSTR lpszQueuePathName)
{
    delete[] m_lpszQueuePathName.detach();
    if (lpszQueuePathName)
    {
        m_lpszQueuePathName = new WCHAR[wcslen(lpszQueuePathName) + 1];
        wcscpy(m_lpszQueuePathName, lpszQueuePathName);
    }
}

//
// Return TRUE if the queue path name equals to the passed path name.
//
BOOL _HLQS::IsEqualQueuePathName(LPCWSTR lpszQueuePathName)
{
    return CompareStringsNoCaseUnicode(m_lpszQueuePathName, lpszQueuePathName) == 0;
}

//
// Add one to the reference count of the handle.
//
DWORD _HLQS::AddRef(void)
{
    //
    // No need to lock because the entire Local Queue Store is locked.
    //
    return ++m_iRefCount;
}

//
// Substract one from the reference count and delete the handle if the
// reference count drops to zero.
//
DWORD _HLQS::Release()
{
    //
    // No need to lock because the entire Local Queue Store is locked.
    //
    int iRefCount = --m_iRefCount;

    if (iRefCount == 0)
    {
        delete this;
    }

    return iRefCount;
}

//
// Get the name of the files that holds the queue properties.
//
LPCWSTR _HLQS::GetFileName(void)
{
    ASSERT(m_bType == LQS_HANDLE_TYPE_QUEUE);
    return m_lpszFilePathName;
}

//
// Get the name of the backup file that holds the "last known good" queue properties.
//
LPCWSTR _HLQS::GetTemporaryFileName(void)
{
    //
    // Note that we use both prefix and suffix. this is because the 
    // wildcard for finding private queue files ends with "*", and the one for public begins with "*",
    // and we don't want them to find the temporary files (YoelA, 1-Aug-99)
    //
    static const WCHAR x_szTemporaryPrefix[] = TEXT("~T~");
    static const DWORD x_dwAdditionsLen = TABLE_SIZE(x_szTemporaryPrefix) + TABLE_SIZE(x_szTemporarySuffix);
    ASSERT(m_bType == LQS_HANDLE_TYPE_QUEUE);
    if (m_lpszTemporaryFilePathName == 0)
    {
        //
        // Find the beginning of the file name - after the last backslash
        //
        LPCTSTR lpszStartName = wcsrchr(m_lpszFilePathName, L'\\');
        if (lpszStartName == NULL)
        {
            lpszStartName = m_lpszFilePathName;
        }
        else
        {
            lpszStartName++;
        }

        //
        // Allocate abuffer for the new name
        //
        m_lpszTemporaryFilePathName = new WCHAR[wcslen(m_lpszFilePathName) + x_dwAdditionsLen + 1];

        //
        // Copy the path (drive, dirs, etc) except for the file name
        //
        DWORD_PTR dwPrefixLen = lpszStartName - m_lpszFilePathName;
        wcsncpy(m_lpszTemporaryFilePathName, m_lpszFilePathName, dwPrefixLen);

        //
        // Add the file name with prefix and suffix
        //
        swprintf(m_lpszTemporaryFilePathName + dwPrefixLen, 
                 TEXT("%s%s%s"),
                 x_szTemporaryPrefix,
                 lpszStartName,
                 x_szTemporarySuffix);
    }

    return m_lpszTemporaryFilePathName;
}

//
// Get the original queue path name
//
LPCWSTR _HLQS::GetQueuePathName(void)
{
    ASSERT(m_bType == LQS_HANDLE_TYPE_QUEUE);
    return m_lpszQueuePathName;
}

//
// Get the find handle for enumerating the queues in the LQS.
//
HANDLE _HLQS::GetFindHandle(void)
{
    ASSERT(m_bType == LQS_HANDLE_TYPE_FIND);
    return m_hFindFile;
}

#ifdef _WIN64
//
// Saves a DWORD mapping of this HQLS object to be removed from the map upon destruction
//
void _HLQS::SetMappedHLQS(DWORD dwMappedHLQS)
{
    ASSERT(m_dwMappedHLQS == 0);
    m_dwMappedHLQS = dwMappedHLQS;
}
#endif //_WIN64

//
// Synchronously flush content of existing file
// 
static
BOOL
LqspFlushFile(
    LPCWSTR pFile
    )
{
    CAutoCloseHandle hFile;
    hFile = CreateFile(
                pFile,
                GENERIC_WRITE,
                0,
                0,
                OPEN_EXISTING,
                FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                0
                );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TrERROR(GENERAL, "Failed to open file '%ls' for flush, error 0x%x", pFile, GetLastError());        
        return LogBOOL(false, s_FN, 560);
    }

    if (!FlushFileBuffers(hFile))
    {
        TrERROR(GENERAL, "Failed to flush file '%ls', error 0x%x", pFile, GetLastError());        
        return LogBOOL(false, s_FN, 570);
    }

    return true;

} // LqspFlushFile


//
// Determines wheather or not a file exists
//
BOOL DoesFileExist(LPCTSTR lpszFilePath)
{
    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(lpszFilePath, &FindData);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing was found.
        //
        return FALSE;
    }
    return TRUE;
}
//
// Hash the queue path to a DWORD. This serves us for creating the file name
// of the file that holds the queue properties.
//
static
DWORD
HashQueuePath(
    LPCWSTR lpszPathName)
{
    DWORD dwHash = 0;

    AP<WCHAR> pTemp = new WCHAR[wcslen(lpszPathName) + 1];
    wcscpy(pTemp, lpszPathName);

    //
    // Call CharLower on all string and not every character, to enalbe Win95.
    // This is how MQ implementation supports it. erezh 19-Mar-98
    //
    WCHAR* pName = pTemp;
    CharLower(pName);

    while (*pName)
    {
        dwHash = (dwHash<<5) + dwHash + *pName++;
    }

    return dwHash;
}

//
// Convert a GUID to it's string representation.
//
static
DWORD
GuidToStr(
    LPWSTR lpszGuid,
    const GUID *lpGuid)
{
    swprintf(lpszGuid,
            TEXT("%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x"),
            lpGuid->Data1,
            lpGuid->Data2,
            lpGuid->Data3,
            lpGuid->Data4[0],
            lpGuid->Data4[1],
            lpGuid->Data4[2],
            lpGuid->Data4[3],
            lpGuid->Data4[4],
            lpGuid->Data4[5],
            lpGuid->Data4[6],
            lpGuid->Data4[7]);

    return (8+4+4+8*2);
}

//
// Fill a buffer with the directory of the LQS and return a pointer to the
// location in the buffer after the directory name.
//
static
LPWSTR
LQSGetDirectory(
    LPWSTR lpszFilePath)
{
    static WCHAR szDirectory[MAX_PATH] = {TEXT("")};
    static DWORD dwDirectoryLength = 0;

    //
    // We do not have the directory name yet cached in the static variable
    // so get the value from the registry.
    //
    if (!szDirectory[0])
    {
        DWORD dwValueType = REG_SZ ;
		DWORD dwDirectorySize = sizeof(szDirectory); // In bytes!!!

        LONG rc = GetFalconKeyValue(
                        MSMQ_STORE_PERSISTENT_PATH_REGNAME,
                        &dwValueType,
                        szDirectory,
                        &dwDirectorySize
                        );
        
        ASSERT(rc == ERROR_SUCCESS);
        
        //
        // BUGBUG - Should throw exception and handle it, if the
        //          above assertion is triggered.
        //
        if (rc != ERROR_SUCCESS)
        {
            TrERROR(GENERAL, "LQSGetDirectory - failed to retrieve the LQS directory from the registry, error = %d", rc);
        }
        dwDirectoryLength = dwDirectorySize / sizeof(WCHAR) - 1;
    }

    wcscpy(lpszFilePath, szDirectory);
    wcscpy(lpszFilePath += dwDirectoryLength, LQS_SUBDIRECTORY);

    return lpszFilePath +
           sizeof(LQS_SUBDIRECTORY) / sizeof(WCHAR) - 1;
}

//
// Fill a buffer with the path to the file that should contain the
// queue properties. The file name for private queues is the hex value of the
// queue's ID with leading zeroes. The file name for public queues is the
// queue's GUID. The file names extension is always the DWORD hash value of
// the queue path name.
//
// It is possible to pass a NULL for each of the parameters: queue path, queue
// giud, or queue ID. In this case the file name will contain an asterisk - '*'.
// This results in a wild carded path that can be used for finding the file
// for the queue using FindFirst/NextFile.
//
static
HRESULT
LQSFilePath(
    DWORD dwQueueType,
    LPWSTR lpszFilePath,
    LPCWSTR pszQueuePath,
    const GUID *pguidQueue,
    DWORD *pdwQueueId)
{
    WCHAR *p = LQSGetDirectory(lpszFilePath);

    switch (dwQueueType)
    {
    case LQS_PUBLIC_QUEUE:
        if (pguidQueue)
        {
            p += GuidToStr(p, pguidQueue);
        }
        else
        {
            *p++ = L'*';
        }
        break;

    case LQS_PRIVATE_QUEUE:
        if (pdwQueueId)
        {
            p += swprintf(p, TEXT("%08x"), *pdwQueueId);
        }
        else
        {
            *p++ = L'*';
        }
        break;

    default:
        ASSERT(0);
        break;
    }

    *p++ = L'.';

    if (pszQueuePath)
    {
		LPWSTR pSlashStart = wcschr(pszQueuePath,L'\\');
		if(pSlashStart == NULL)
		{
			TrERROR(GENERAL, "Bad queue path. Missing backslash in %ls", pszQueuePath);
			ASSERT(("Bad queue path. Missing backslash.", 0));
			return MQ_ERROR_INVALID_PARAMETER;
		}

        swprintf(p, TEXT("%08x"), HashQueuePath(pSlashStart));
    }
    else
    {
        *p++ = L'*';
        *p = L'\0';
    }

	return MQ_OK;
}

//
// Add to the reference count of the handle and cast it to PVOID, so it can be
// returned to the caller.
//
static
HRESULT
LQSDuplicateHandle(
    HLQS *phLQS,
    _HLQS *hLQS)
{
    hLQS->AddRef();
    *phLQS = (PVOID)hLQS;

    return MQ_OK;
}

//
// Create an LQS handle for queue operations.
//
static
HRESULT
LQSCreateHandle(
    LPCWSTR lpszQueuePath,
    LPCWSTR lpszFilePath,
    _HLQS **pphLQS)
{
	try
	{
		*pphLQS = new _HLQS(lpszQueuePath, lpszFilePath);
		return MQ_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to allocate a new lqs handle. Queue = %ls, File = %ls",lpszQueuePath, lpszFilePath);
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//
// Create an LQS handle for queue enumerations.
//
static
HRESULT
LQSCreateHandle(
    HANDLE hFindFile,
    _HLQS **pphLQS)
{
	try
	{
		*pphLQS = new _HLQS(hFindFile);
		return MQ_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to allocate a new lqs handle class.");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}

#ifdef _DEBUG
static
BOOL
LQSValidateHandle(HLQS hLQS)
{
    return (reinterpret_cast<const _HLQS *>(hLQS))->Validate();
}
#endif

static
_HLQS * LQSReferenceHandle(HLQS hLQS)
{
    ASSERT(LQSValidateHandle(hLQS));
    return reinterpret_cast<_HLQS *>(hLQS);
}

//
// All the operations on the LQS are serialized using this critical section
// object.
//
static CCriticalSection g_LQSCS;

//
// Create a queue in the LQS. If the queue already exists, the queue
// properties are not modified, but a valid handle is returned.
//
static
HRESULT
LQSCreateInternal(
    DWORD dwQueueType,          // Public or private queue.
    LPCWSTR pszQueuePath,       // The queue path name.
    const GUID *pguidQueue,     // The queue's GUID - valid only for public queues
    DWORD dwQueueId,            // The queus's ID - valid only for private queues
    DWORD cProps,               // The number of properties.
    PROPID aPropId[],           // The property IDs.
    PROPVARIANT aPropVar[],     // The property values.
    HLQS *phLQS)                // A buffer for the created handle.
{
    CS lock(g_LQSCS);
    P<_HLQS> hLQS;
    HRESULT hr1;
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    //
    // Get the path to the file.
    //
    HRESULT hr = LQSFilePath(dwQueueType,
								szFilePath,
								pszQueuePath,
								pguidQueue,
								&dwQueueId);
	if(FAILED(hr))
		return hr;

    //
    // If the file already exists, it means that the queue already exists.
    //
    if (_waccess(szFilePath, 0) == 0)
    {
        hr = MQ_ERROR_QUEUE_EXISTS;
    }

    //
    // Create a handle to the queue.
    //
	hr = LQSCreateHandle(pszQueuePath, szFilePath, &hLQS);
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to create handle in LQS Create Internal.");
		return hr;
	}

    //
    // If the queue does not exist, set the queue properties. Writing the
    // queue properties also creates the file.
    //
    if (hr != MQ_ERROR_QUEUE_EXISTS)
    {
        hr1 = LQSSetProperties((HLQS)hLQS, cProps, aPropId, aPropVar, TRUE);
        if (FAILED(hr1))
        {
            return LogHR(hr1, s_FN, 20);
        }
    }

    //
    // Pass the created handle to the user.
    //
    LQSDuplicateHandle(phLQS, hLQS);
    hLQS.detach();

    return LogHR(hr, s_FN, 30);
}


//
// Create a public queue in the LQS. If the queue already exists, the queue
// properties are not modified, but a valid handle is returned.
//
HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,       // The queue path name.
    const GUID *pguidQueue,     // The queue's GUID.
    DWORD cProps,               // The number of properties.
    PROPID aPropId[],           // The property IDs.
    PROPVARIANT aPropVar[],     // The property values.
    HLQS *phLQS)                // A buffer for the created handle.
{
    ASSERT(pguidQueue);

    if (!pszQueuePath)
    {
        for (DWORD i = 0;
             (i < cProps) && (aPropId[i] != PROPID_Q_PATHNAME);
             i++)
		{
			NULL;
		}

        if (i == cProps)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 40);
        }

        pszQueuePath = aPropVar[i].pwszVal;
    }

    HRESULT hr2 = LQSCreateInternal(LQS_PUBLIC_QUEUE,
                             pszQueuePath,
                             pguidQueue,
                             0,
                             cProps,
                             aPropId,
                             aPropVar,
                             phLQS);
    return LogHR(hr2, s_FN, 50);
}

//
// Create a private queue in the LQS. If the queue already exists, the queue
// properties are not modified, but a valid handle is returned.
//
HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,     // The queue path name.
    DWORD dwQueueId,          // The queue's ID.
    DWORD cProps,             // The number of properties.
    PROPID aPropId[],         // The property IDs.
    PROPVARIANT aPropVar[],   // The property values.
    HLQS *phLQS)              // A buffer for the created handle.
{
    ASSERT(pszQueuePath);

    HRESULT hr2 = LQSCreateInternal(LQS_PRIVATE_QUEUE,
                             pszQueuePath,
                             NULL,
                             dwQueueId,
                             cProps,
                             aPropId,
                             aPropVar,
                             phLQS);
    return LogHR(hr2, s_FN, 60);
}

//
// Write a property as a string in the INI file.
//
static
HRESULT
WriteProperyString(
    LPCWSTR lpszFileName,       // The path of the INI file.
    LPCWSTR lpszLQSPropName,    // The property name (e.g., "BasePriority").
    VARTYPE vt,                 // The var type of the property (e.g., VT_UI4).
    const BYTE * pBuff)         // The property value.
{
    WCHAR awcShortBuff[64];
    AP<WCHAR> pLongBuff;
    WCHAR *pValBuff = awcShortBuff;

    //
    // Convert the property value into it's string representation.
    //
    switch (vt)
    {
    case VT_UI1:
        swprintf(pValBuff, TEXT("%02x"), *pBuff);
        break;

    case VT_I2:
        swprintf(pValBuff, TEXT("%d"), *(short *)pBuff);
        break;

    case VT_I4:
        swprintf(pValBuff, TEXT("%d"), *(long *)pBuff);
        break;

    case VT_UI4:
        swprintf(pValBuff, TEXT("%u"), *(DWORD *)pBuff);
        break;

    case VT_LPWSTR:
        pValBuff = const_cast<LPWSTR>(reinterpret_cast<LPCWSTR>(pBuff));
        break;

    case VT_EMPTY:
        pValBuff = NULL;
        break;

    case VT_CLSID:
        {
            const GUID *pGuid = reinterpret_cast<const GUID *>(pBuff);
            swprintf(pValBuff,
                     TEXT("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
                     pGuid->Data1,
                     pGuid->Data2,
                     pGuid->Data3,
                     pGuid->Data4[0],
                     pGuid->Data4[1],
                     pGuid->Data4[2],
                     pGuid->Data4[3],
                     pGuid->Data4[4],
                     pGuid->Data4[5],
                     pGuid->Data4[6],
                     pGuid->Data4[7]);
        }
        break;

    case VT_BLOB:
        {
            const BLOB *pBlob = reinterpret_cast<const BLOB *>(pBuff);
            if (2*pBlob->cbSize > sizeof(awcShortBuff)/sizeof(WCHAR))
            {
                if (2*pBlob->cbSize + 1 > LQS_MAX_VALUE_SIZE)
                {
                    return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 70);
                }
                pLongBuff = new WCHAR[2*pBlob->cbSize + 1];
                pValBuff = pLongBuff;
            }
            WCHAR *p = pValBuff;
            for (DWORD i = 0;
                 i < pBlob->cbSize;
                 i++)
            {
                p += swprintf(p, TEXT("%02x"), pBlob->pBlobData[i]);
            }
            *p = '\0';
        }
        break;

    default:
        ASSERT(0);
        break;
    }

    //
    // Write the property in the INI file.
    //
    if (!WritePrivateProfileString(LQS_PROP_SECTION_NAME,
                                   lpszLQSPropName,
                                   pValBuff,
                                   lpszFileName))
    {
        LogNTStatus(GetLastError(), s_FN, 80);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    return MQ_OK;
}


//
// Create the file and add 0xFF + 0xFE at the beggining to mark
// it as unicode. If we do not do it, global characters will not 
// be supported unless they belong to the default locale of the
// current computer.
// This is a fix to bug 5005, and it is actually a workaroung 
// for a bug in WritePrivateProfileStringW, that does not support unicode
// YoelA - 20-Oct-99
//
HRESULT CreateLqsUnicodeFile (LPCTSTR lpszFileName )
{
	CAutoCloseFileHandle hLogFileHandle = CreateFile(lpszFileName,GENERIC_WRITE,0,0,
			CREATE_NEW,FILE_ATTRIBUTE_TEMPORARY,0);
	if (hLogFileHandle == INVALID_HANDLE_VALUE )
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to create LQS file '%ls'. Error: %!winerr!", lpszFileName, gle); 
		return HRESULT_FROM_WIN32(gle);
	}

	UCHAR strUnicodeMark[]={(UCHAR)0xff,(UCHAR)0xfe};
	DWORD dwWrittenSize;
	if (0 == WriteFile( hLogFileHandle , strUnicodeMark , sizeof(strUnicodeMark), &dwWrittenSize , NULL))
    {
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to write Unicode marker to LQS file '%ls'. Error: %!winerr!", lpszFileName, gle); 
		return HRESULT_FROM_WIN32(gle);
    }

    if (dwWrittenSize != sizeof(strUnicodeMark))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 615);
    }

    return S_OK;
}

//
// Write the properties of a queue in the queue peroperties file.
//
HRESULT
LQSSetProperties(
    HLQS hLQS,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    BOOL fNewFile)
{
    CS lock(g_LQSCS);

    HRESULT hr = MQ_OK ;
    BOOL fModifyTimeIncluded = FALSE;
    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();
    LPCWSTR lpszTemporaryFile = LQSReferenceHandle(hLQS)->GetTemporaryFileName();
    LPCWSTR lpszQueueName = LQSReferenceHandle(hLQS)->GetQueuePathName(); // Requeired for reporting purposes

    if (!fNewFile)
    {
       //
       // Copy the LQS file to a temporary work file - in case we will fail during the update
       //
       BOOL bCancelDummy = FALSE; // Cancle flag. CopyFileEx require it, but we don't use it.
       BOOL fCopySucceeded = CopyFileEx(lpszIniFile, lpszTemporaryFile, 0, 0, &bCancelDummy, 0);
       if (!fCopySucceeded)
       {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to copy LQS file '%ls' to temp file %ls. Queue: '%ls', Error: %!winerr!", lpszIniFile, lpszTemporaryFile, lpszQueueName, gle);

			EvReportWithError(
			   SET_QUEUE_PROPS_FAIL_COUND_NOT_COPY,
			   gle,
			   3,
			   lpszQueueName,
			   lpszIniFile,
			   lpszTemporaryFile
			   );

			return HRESULT_FROM_WIN32(gle);
       }
       //
       // Make the file a temporary file. We do not check return code here except for
       // debug / report purposes.
       //
       BOOL fSetAttrSucceeded = SetFileAttributes(lpszTemporaryFile, FILE_ATTRIBUTE_TEMPORARY);
       if (!fSetAttrSucceeded)
       {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to set temp file attributes '%ls'. Queue: '%ls', Error: %!winerr!", lpszTemporaryFile, lpszQueueName, gle); 
       }
    }
    else
    {
        //
        // Create the file first so it will be globalizable.See explanation above in CreateLqsUnicodeFile
        // YoelA - 20-Oct-99
        //
        CreateLqsUnicodeFile(lpszTemporaryFile);


        //
        // Note: We don't care if we failed to create the file and mark it as UNICODE. In the worst case,
        // WritePrivateProfileString (called from WriteProperyString) will create it, and it will not support
        // characters that do not come from the default language (see bug 5005). This is why we just assert 
        // and continue (There will be a message in the log file, however).
        // YoelA - 20-Oct-99
        //
    }

    try
    {
        for (DWORD i = 0 ; SUCCEEDED(hr) && (i < cProps) ; i++ )
        {
            switch( aPropId[i] )
            {
                case PROPID_Q_TYPE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TYPE_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) aPropVar[i].puuid);
                    break;

                case PROPID_Q_INSTANCE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_INSTANCE_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) aPropVar[i].puuid);
                    break;

                case PROPID_Q_BASEPRIORITY:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_BASEPRIO_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].iVal);
                    break;

                case PROPID_Q_JOURNAL:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_JOURNAL_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PROPID_Q_QUOTA:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_QUOTA_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].ulVal);
                    break;

                case PROPID_Q_JOURNAL_QUOTA:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_JQUOTA_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].ulVal);
                    break;

                case PROPID_Q_CREATE_TIME:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TCREATE_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].lVal);
                    break;

                case PROPID_Q_MODIFY_TIME:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TMODIFY_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].lVal);
                     //
                     //  Modify time will be part of the properties only when
                     //  queue is created.
                     //
                     fModifyTimeIncluded = TRUE;
                     break;

                case PROPID_Q_SECURITY:
				    ASSERT( aPropVar[i].blob.pBlobData != NULL);
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_SECURITY_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].blob);
                    break;

                case PPROPID_Q_TIMESTAMP:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TSTAMP_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].blob);
                    break;

                case PROPID_Q_PATHNAME:
                    {
                        DWORD dwstrlen = wcslen(aPropVar[i].pwszVal);
                        AP<WCHAR> lpQueuePathName = new WCHAR [dwstrlen+1];
                        wcscpy(lpQueuePathName, aPropVar[i].pwszVal);
                        CharLower(lpQueuePathName);
    #ifdef _DEBUG
					    BOOL bIsDns;

					    if (! (IsPathnameForLocalMachine( lpQueuePathName,
                                                         &bIsDns)))
                        {
                            //
                            // This will happen when migrated BSC, after
                            // dcpromo create local queue. Such an operation
                            // issue a write-request to the PSC and we'll
                            // be here when notification arrive.
                            //
                            ASSERT((lpQueuePathName[0] == L'.') &&
                                   (lpQueuePathName[1] == L'\\')) ;
                        }

    #endif
					    //
					    // Extract the queue name from the path name
					    //
					    LPWSTR pSlashStart = wcschr(lpQueuePathName,L'\\');
						if(pSlashStart == NULL)
						{
							TrERROR(GENERAL, "Bad pathname. Missing backslash in %ls", lpQueuePathName);
							ASSERT(("Bad queue pathname.", 0));
							hr =  MQ_ERROR_INVALID_PARAMETER;
							break;
						}

                        hr = WriteProperyString(
                                 lpszTemporaryFile,
                                 LQS_QUEUENAME_PROPERTY_NAME,
                                 aPropVar[i].vt,
                                 (const BYTE *)(WCHAR *)pSlashStart);

                    }
                    break;

                case PROPID_Q_LABEL:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_LABEL_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) aPropVar[i].pwszVal);
                    break;

                case PROPID_Q_AUTHENTICATE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_AUTH_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PROPID_Q_PRIV_LEVEL:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_PRIVLEVEL_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].ulVal);
                    break;

                case PROPID_Q_TRANSACTION:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TRANSACTION_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PPROPID_Q_SYSTEMQUEUE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_SYSQ_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PROPID_Q_MULTICAST_ADDRESS:
                    ASSERT(("Must be VT_EMPTY or VT_LPWSTR", aPropVar[i].vt == VT_EMPTY || aPropVar[i].vt == VT_LPWSTR));
                    ASSERT(("NULL not allowed", aPropVar[i].vt == VT_EMPTY || aPropVar[i].pwszVal != NULL));
                    ASSERT(("Empty string not allowed", aPropVar[i].vt == VT_EMPTY || L'\0' != *aPropVar[i].pwszVal));

                    hr = WriteProperyString(
                            lpszTemporaryFile,
                            LQS_MULTICAST_ADDRESS_PROPERTY_NAME,
                            aPropVar[i].vt,
                            (const BYTE*) aPropVar[i].pwszVal
                            );
                    break;

                case PROPID_Q_ADS_PATH:
                    ASSERT(("Setting PROPID_Q_ADS_PATH is not allowed", 0));
                    break;

                default:
                    // ASSERT(0);
                    break;
            }
        }

        //
        //  Update modify time field, if not included in the input properties
        //
        if (SUCCEEDED(hr) && !fModifyTimeIncluded)
        {
            TIME32 lTime = INT_PTR_TO_INT(time(NULL)); //BUGBUG bug year 2038
            hr = WriteProperyString(
                     lpszTemporaryFile,
                     LQS_TMODIFY_PROPERTY_NAME,
                     VT_I4,
                     (const BYTE*) &lTime);
        }
    }
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to write the properties of a queue in the queue peroperties file because of insufficient resources.");
		hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
    catch(...)
    {
        ASSERT(0);
        LogIllegalPoint(s_FN, 700);
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

	try
	{
		if (FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to WriteProperyString. %!hresult!", hr);
			throw bad_hresult(hr);
		}

		//
		// Write signature.
		//
		hr = WriteProperyString(lpszTemporaryFile,
								LQS_SIGNATURE_NAME,
								VT_LPWSTR,
								(const BYTE*) LQS_SIGNATURE_VALUE ) ;

		if (FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to write signatue. %!hresult!", hr);
			throw bad_hresult(hr);
		}

		if (!LqspFlushFile(lpszTemporaryFile))
		{
			throw bad_hresult(HRESULT_FROM_WIN32(GetLastError()));
		}

		//
		// Now that update is completed, we move the temporary file to the real file. 
		// This is an atomic operation
		//
		BOOL fMoveSucceeded = FALSE;
		DWORD LastError = 0;
		if (fNewFile)
		{
			fMoveSucceeded = MoveFileEx(lpszTemporaryFile, lpszIniFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
			if(!fMoveSucceeded)
			{
    			LastError = GetLastError();
				TrERROR(GENERAL, "Failed to move file '%ls' to file %ls. Queue: '%ls', Error: %!winerr!", lpszTemporaryFile, lpszIniFile, lpszQueueName, LastError); 
			}
        		
			//
			// Remove the temporary flag
			//
			BOOL fSetAttrSucceeded = SetFileAttributes(lpszIniFile, FILE_ATTRIBUTE_ARCHIVE);
			if (!fSetAttrSucceeded)
			{
				DWORD gle = GetLastError();
				TrERROR(GENERAL, "Failed to set normal file attributes '%ls'. Queue: '%ls', Error: %!winerr!", lpszTemporaryFile, lpszQueueName, gle); 
			}

		}
		else
		{
			fMoveSucceeded = ReplaceFile(lpszIniFile, lpszTemporaryFile, 0, REPLACEFILE_WRITE_THROUGH, 0, 0);
			if(!fMoveSucceeded)
			{
    			LastError = GetLastError();
				TrERROR(GENERAL, "Failed to replace file '%ls' with %ls. Queue: '%ls', Error: %!winerr!", lpszIniFile, lpszTemporaryFile, lpszQueueName, LastError); 
			}
		}

		if (!fMoveSucceeded)
		{
			//
			// Generate an event log file to notify the user that the move failed
			//
			EvReportWithError(
				SET_QUEUE_PROPS_FAIL_COUND_NOT_REPLACE,
				LastError,
				3,
				lpszQueueName,
				lpszIniFile,
				lpszTemporaryFile
				);
			
			TrERROR(GENERAL, "Failed to move file. %!hresult!", HRESULT_FROM_WIN32(LastError));
			throw bad_hresult(HRESULT_FROM_WIN32(LastError));
		}

		return (MQ_OK);
	}

	catch(const bad_hresult& e)
	{
		BOOL bDeleted = DeleteFile(lpszTemporaryFile);
		if (bDeleted == 0)
		{
			DWORD gle = GetLastError();
			ASSERT_BENIGN (gle != ERROR_FILE_NOT_FOUND);
			TrERROR(GENERAL, "Failed to delete file. %!hresult!", HRESULT_FROM_WIN32(gle));
		}
		return (e.error());
	}
}

//
// Read a property from an INI file.
//
static
HRESULT
GetPropertyValue(
    LPCWSTR lpszFileName,   // The INI file name.
    LPCWSTR lpszPropName,   // The property name.
    VARTYPE vt,             // The var type of the property.
    PROPVARIANT *pPropVal)  // The propvar of the prperty.
{
    BOOL bShouldAllocate = FALSE;

    if (pPropVal->vt == VT_NULL)
    {
        //
        // Set the var type on the propvar and mark that we should allocate
        // the buffer for the property valkue, as neccessary.
        //
        pPropVal->vt = vt;
        bShouldAllocate = TRUE;
    }
    else
    {
        //
        // Validate the var type.
        //
        if (pPropVal->vt != vt)
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VT, s_FN, 95);
        }
    }

    //
    // Try to retrieve the property value into a short buffer.
    //
    WCHAR awcShortBuff[64];
    AP<WCHAR> pLongBuff;
    WCHAR *pValBuff = awcShortBuff;
    DWORD dwBuffLen = sizeof(awcShortBuff)/sizeof(WCHAR);
    DWORD dwReqBuffLen;
    awcShortBuff[0] = '\0'; //for win95, when the entry is empty

    dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                           lpszPropName,
                                           TEXT(""),
                                           pValBuff,
                                           dwBuffLen,
                                           lpszFileName);

    //
    //   Either default string length, or
    //   a NULL string
    //
    if ( (!dwReqBuffLen) && (vt != VT_LPWSTR) )
    {
        //
        // Nothing was read, this is an error.
        //
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 100);
    }

    if (dwReqBuffLen == dwBuffLen - 1)
    {
        //
        // The buffer seem to be too short, try a larger buffer.
        //
        dwBuffLen = 512;
        do
        {
            delete[] pLongBuff.detach();
            //
            // Start with a 1K buffer. Each time that we fail we try with a
            // buffer that is twice as large, up to 64K.
            //
            dwBuffLen *= 2;
            pLongBuff = new WCHAR[dwBuffLen];
            pValBuff = pLongBuff;
            dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                                   lpszPropName,
                                                   TEXT(""),
                                                   pValBuff,
                                                   dwBuffLen,
                                                   lpszFileName);

        } while (dwReqBuffLen &&
                 (dwReqBuffLen == dwBuffLen - 1) &&
                 (dwBuffLen < LQS_MAX_VALUE_SIZE));

        if (!dwReqBuffLen)
        {
            //
            // Nothing was read, this is an error.
            //
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 110);
        }
    }


    //
    // Convert the string representation into the actual representation depending
    // on the property data type.
    //
    switch (vt)
    {
    case VT_UI1:
        _snwscanf(pValBuff, dwBuffLen, TEXT("%x"), &pPropVal->bVal);
        break;

    case VT_I2:
        {
            LONG lShort;

            _snwscanf(pValBuff, dwBuffLen, TEXT("%d"), &lShort);
            pPropVal->iVal = (SHORT)lShort;
        }
        break;

    case VT_I4:
        _snwscanf(pValBuff, dwBuffLen, TEXT("%d"), &pPropVal->lVal);
        break;

    case VT_UI4:
        _snwscanf(pValBuff, dwBuffLen, TEXT("%u"), &pPropVal->ulVal);
        break;

    case VT_LPWSTR:
        ASSERT(("Must be VT_NULL for strings!", bShouldAllocate));
        pPropVal->pwszVal = new WCHAR[dwReqBuffLen + 1];
        memcpy(pPropVal->pwszVal, pValBuff, sizeof(WCHAR) * (dwReqBuffLen + 1));
        break;

    case VT_CLSID:
        {
            ASSERT(dwReqBuffLen == 36);
            if (bShouldAllocate)
            {
                pPropVal->puuid = new GUID;
            }

			FnParseGuidString (pValBuff, pPropVal->puuid);
        }
        break;

    case VT_BLOB:
       {
            if (bShouldAllocate)
            {
			     pPropVal->blob.cbSize = dwReqBuffLen / 2;
                 pPropVal->blob.pBlobData = new BYTE[dwReqBuffLen / 2];
            }

            WCHAR *p = pValBuff;
    		DWORD dwPlen = dwBuffLen;
  
            for (DWORD i = 0;
                 i < pPropVal->blob.cbSize;
                 i++, p += 2, dwPlen -= 2)
			{
                 DWORD dwByte;
                 int f = _snwscanf(p, dwPlen, TEXT("%02x"), &dwByte);
    	         DBG_USED(f);
                 pPropVal->blob.pBlobData[i] = (BYTE)dwByte;
                 ASSERT(f == 1);
			}
	   }
	   break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 120);
        break;
    }

    return MQ_OK;
}



//
// Get the queue name for the LQS file and concatenate the machine name
// to get the pathname
//
HRESULT GetPathNameFromQueueName(LPCWSTR lpszIniFile, LPCWSTR pMachineName, PROPVARIANT * pvar)
{
	ASSERT(pvar->vt == VT_NULL);

	HRESULT hr =  GetPropertyValue(lpszIniFile,
						LQS_QUEUENAME_PROPERTY_NAME,
						VT_LPWSTR,
						pvar);

	if(FAILED(hr))
		return LogHR(hr, s_FN, 130);

	ASSERT(pvar->pwszVal != NULL);
	DWORD dwLen=wcslen(pvar->pwszVal) + 1;
	AP<WCHAR> pwcsQueueName = pvar->pwszVal; //Keep original queuename.
											 //Will be automatically freed
	
    pvar->pwszVal=0; 
	pvar->pwszVal = new WCHAR [wcslen(pMachineName) +
							   dwLen];

	wcscpy(pvar->pwszVal, pMachineName);
	wcscat(pvar->pwszVal, pwcsQueueName);

	return LogHR(hr, s_FN, 140);
}



//
// Retrieve a queue properties out of the properties file.
//
HRESULT
LQSGetProperties(
    HLQS hLQS,              // A handle to the queue storage file.
    DWORD cProps,           // The number of properties.
    PROPID aPropId[],       // The property IDs.
    PROPVARIANT aPropVar[], // The property values.
    BOOL  fCheckFile)       // Check if file is corrupt.
{
    CS lock(g_LQSCS);
    HRESULT hr = MQ_OK ;
    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();

	AP<bool> isAllocatedByUser = NULL;
    VARIANT var;
	VariantInit(&var);

	ASSERT (cProps != 0);

	//
	// on failure, the routine should release the data it allocated. The problem is that 
	// some of the buffers are supplied by the caller and the other allocated by the routine.
	// The code use a boolean array to distinguish between data that was allocated by the 
	// caller and data that was allocated by the routine itself. When the property data is allocated 
	// by the user the suitable entry in the array is set to true.		
	// On failure only properties that didnt supply by the user are released.
	//
	isAllocatedByUser = new bool[cProps];
	for(DWORD i = 0; i < cProps; ++i)
	{
		isAllocatedByUser[i] = ((aPropVar[i].vt != VT_NULL) && (aPropVar[i].vt != VT_EMPTY));
	}

	for (DWORD i = 0 ;
	    SUCCEEDED(hr) && (i < cProps);
	    i++)
	{
		try
	    {
			switch (aPropId[i])
			{
             case PROPID_Q_TYPE:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TYPE_PROPERTY_NAME,
                                        VT_CLSID,
                                        aPropVar + i);
                 break;

             case PROPID_Q_INSTANCE:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_INSTANCE_PROPERTY_NAME,
                                        VT_CLSID,
                                        aPropVar + i);
                 break;

             case PROPID_Q_JOURNAL:
                 hr = GetPropertyValue(lpszIniFile,
                                       LQS_JOURNAL_PROPERTY_NAME,
                                       VT_UI1,
                                       aPropVar + i);
                 break;

             case PROPID_Q_BASEPRIORITY:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_BASEPRIO_PROPERTY_NAME,
                                        VT_I2,
                                        aPropVar + i);
                 break;

             case PROPID_Q_QUOTA:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_QUOTA_PROPERTY_NAME,
                                        VT_UI4,
                                        aPropVar + i);
                 break;

             case PROPID_Q_JOURNAL_QUOTA:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_JQUOTA_PROPERTY_NAME,
                                        VT_UI4,
                                        aPropVar + i);
                 break;
             case PROPID_Q_CREATE_TIME:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TCREATE_PROPERTY_NAME,
                                        VT_I4,
                                        aPropVar + i);
                 break;
             case PROPID_Q_MODIFY_TIME:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TMODIFY_PROPERTY_NAME,
                                        VT_I4,
                                        aPropVar + i);
                 break;
             case PROPID_Q_SECURITY:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_SECURITY_PROPERTY_NAME,
                                        VT_BLOB,
                                        aPropVar + i);
                 break;
             case PPROPID_Q_TIMESTAMP:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TSTAMP_PROPERTY_NAME,
                                        VT_BLOB,
                                        aPropVar + i);
                 break;

			 case PROPID_Q_PATHNAME_DNS:
				 {
						AP<WCHAR> pwcsLocalMachineDnsName;

						GetDnsNameOfLocalMachine(&pwcsLocalMachineDnsName);

						if ( pwcsLocalMachineDnsName == NULL)
						{
							PROPVARIANT *pvar = aPropVar + i;
							//
							//  The DNS name of the local machine is unknown
							//
							pvar->vt = VT_EMPTY;
							pvar->pwszVal = NULL;
							hr = MQ_OK;
							break;
						}

						hr = GetPathNameFromQueueName(lpszIniFile, pwcsLocalMachineDnsName, aPropVar + i);

						break;

				 }

					
             case PROPID_Q_PATHNAME:
					hr = GetPathNameFromQueueName(lpszIniFile, g_szMachineName, aPropVar + i);
			
                 break;

             case PROPID_Q_LABEL:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_LABEL_PROPERTY_NAME,
                                        VT_LPWSTR,
                                        aPropVar + i);
                 break;

             case PROPID_Q_QMID:
                 //
                 // The QM GUID is not in queue registry (it's in each
                 // queue record in the MQIS database but not in registry
                 // which cache only local queues).
                 //
                 if (aPropVar[i].vt == VT_NULL)
                 {
                     aPropVar[i].puuid = new GUID;
                     aPropVar[i].vt = VT_CLSID;
                 }
                 *(aPropVar[i].puuid) = *(QueueMgr.GetQMGuid()) ;
                 break;

              case PROPID_Q_AUTHENTICATE:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_AUTH_PROPERTY_NAME,
                                         VT_UI1,
                                         aPropVar + i);
                  break;

              case PROPID_Q_PRIV_LEVEL:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_PRIVLEVEL_PROPERTY_NAME,
                                         VT_UI4,
                                         aPropVar + i);
                  break;

              case PROPID_Q_TRANSACTION:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_TRANSACTION_PROPERTY_NAME,
                                         VT_UI1,
                                         aPropVar + i);
                  break;

              case PPROPID_Q_SYSTEMQUEUE:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_SYSQ_PROPERTY_NAME,
                                         VT_UI1,
                                         aPropVar + i);
                  break;

             case PROPID_Q_MULTICAST_ADDRESS:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_MULTICAST_ADDRESS_PROPERTY_NAME,
                                        VT_LPWSTR,
                                        aPropVar + i);
                 if (SUCCEEDED(hr) && wcslen((aPropVar + i)->pwszVal) == 0)
                 {
                     delete (aPropVar + i)->pwszVal;
                     (aPropVar + i)->vt = VT_EMPTY;
                 }
                 break;

             case PROPID_Q_ADS_PATH:
                 (aPropVar + i)->vt = VT_EMPTY;
                 break;

 			 default:
	             break;
			}
		}
		catch(const bad_alloc&)
	    {
	        LogIllegalPoint(s_FN, 710);
	        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	    }
	    catch(...)
	    {
	        LogIllegalPoint(s_FN, 715);
	        hr = MQ_ERROR_INVALID_PARAMETER;
	    }
    }


    if (fCheckFile)
    {
       //
       // Check if file is corrupted.
       //
       HRESULT hr1 = IsBadLQSFile(lpszIniFile) ;
	   if (FAILED(hr1))
       {
          hr=hr1;
       }
    }

	if (FAILED(hr))
	{
		if (isAllocatedByUser != NULL)
		{
			//
			// We failed to retrieve the properties value. Cleanup the PROPVARIANT array
			//
			for(DWORD j = 0; j < i-1; ++j)
			{
				if (!isAllocatedByUser[j])
				{
					MQFreeVariant(aPropVar[j]);
				}
			}
		}
	}
	
    return LogHR(hr, s_FN, 150);
}

//
// Open a queue store file according to the queue's path name.
//
static
HRESULT
LQSOpenInternal(
    LPCWSTR lpszFilePath,   // The file path in a wild card form.
    LPCWSTR lpszQueuePath,  // The queue path name
    HLQS *phLQS,            // A buffer to receive the new handle.
    LPWSTR pFilePath        // An optional buffer to receive the full filename
    )
{
    //
    // The file path is in the following format: drive:\path\*.xxxxxxxx The
    // xxxxxxxx is the hex value of the hash value for the queue name. Since
    // there might be colosions in the hash value, we should enumerate all
    // the files with the same hash value and see if the queue path name that
    // is stored inside the file matches the passed queue path name.
    // It is also possible that the file path will be as follows:
    // drive:\path\xxxxxxxx.* In this case, the searched queue is a private
    // queue. Also in this case, the queue path euals NULL. There should
    // be only one file that matches this wild card, because the queue ID is
    // unique.
    // A similar case also exist for a public queue when the passed file path
    // is of the following form:
    // drive\path\xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.*
    //
    HRESULT hr;
    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(lpszFilePath, &FindData);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing was found.
        //
		TrWARNING(GENERAL, "The queue %ls was not found.", lpszFilePath);
        return MQ_ERROR_QUEUE_NOT_FOUND;
    }

    while (TRUE)
    {
        P<_HLQS> hLQS;

        wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
        if (pFilePath)
        {
            wcscpy(pFilePath, szFilePath);
        }
        
        hr = LQSCreateHandle(NULL, szFilePath, &hLQS);
		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to create handle in LQS Open Internal.");
			return hr;
		}

        //
        // Retrieve the queue path name.
        //
        PROPID PropId[1] = {PROPID_Q_PATHNAME};
        PROPVARIANT PropVal[1];
        PropVal[0].pwszVal = NULL ;
        PropVal[0].vt = VT_NULL;

        //
        // Check if file is corrupt and delete it if it is.
        //
        hr = LQSGetProperties(hLQS,
                              1,
                              PropId,
                              PropVal,
                              TRUE) ;

        //
        // Make sure that the buffer will get freed.
        //
        AP<WCHAR> pszQueuePath1 = PropVal[0].pwszVal;

        if (SUCCEEDED(hr))
        {
            if (!lpszQueuePath ||
                CompareStringsNoCaseUnicode(pszQueuePath1, lpszQueuePath) == 0)
            {
                //
                // If this is a private queue, or we have a match in the queue
                // path, we found it!
                //
                _HLQS *hRet;

                wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
                HRESULT hr2 = LQSCreateHandle(pszQueuePath1, szFilePath, &hRet);
				if(FAILED(hr2))
				{
					TrERROR(GENERAL, "Failed to create handle in LQS Open Internal.");
					return hr2;
				}

                LQSDuplicateHandle(phLQS, hRet);
                return MQ_OK;
            }
        }
        else if (hr == MQ_CORRUPTED_QUEUE_WAS_DELETED)
        {
            LPWSTR lpName = szFilePath ;
            if (PropVal[0].pwszVal && (wcslen(PropVal[0].pwszVal) > 1))
            {
               lpName = PropVal[0].pwszVal ;
            }

			EvReport(
				(DWORD)MQ_CORRUPTED_QUEUE_WAS_DELETED,
				2,
				FindData.cFileName,
				lpName
				);
        }

        //
        // Try the next file.
        //
        if (!FindNextFile(hFindFile, &FindData))
        {
            LogHR(GetLastError(), s_FN, 190);
            return MQ_ERROR_QUEUE_NOT_FOUND;
        }
    }

    return MQ_OK;
}

//
// Open either a private or public queue store according to the queue path.
//
HRESULT
LQSOpen(
    LPCWSTR pszQueuePath,
    HLQS *phLQS,
    LPWSTR pFilePath
    )
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    HRESULT hr = LQSFilePath(LQS_PUBLIC_QUEUE,
								szFilePath,
								pszQueuePath,
								NULL,
								NULL);
	if(FAILED(hr))
		return hr;

    hr = LQSOpenInternal(szFilePath, pszQueuePath, phLQS, pFilePath);
    if(FAILED(hr))
    {
		TrERROR(GENERAL, "Failed to open %ls. hr = %!hresult!", pszQueuePath, hr);
	}
    
    return hr;
}

//
// Open a private queue store according to the queue ID.
//
HRESULT
LQSOpen(
    DWORD dwQueueId,
    HLQS *phLQS,
    LPWSTR pFilePath
    )
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    HRESULT hr = LQSFilePath(LQS_PRIVATE_QUEUE,
								szFilePath,
								NULL,
								NULL,
								&dwQueueId);
	if(FAILED(hr))
		return hr;

    hr = LQSOpenInternal(szFilePath, NULL, phLQS, pFilePath);
    if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to open %ls. hr = %!hresult!", pFilePath, hr);
    }

    return hr;
}

//
// Open a public queue store according to the queue GUID.
//
HRESULT
LQSOpen(
    const GUID *pguidQueue,
    HLQS *phLQS,
    LPWSTR pFilePath
    )
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    HRESULT hr = LQSFilePath(LQS_PUBLIC_QUEUE,
								szFilePath,
								NULL,
								pguidQueue,
								NULL);
	if(FAILED(hr))
		return hr;

    hr = LQSOpenInternal(szFilePath, NULL, phLQS, pFilePath);
    if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to open %ls. hr = %!hresult!", pFilePath, hr);
    }

    return hr;
}

//
// Close a queue store handle, or an enumeration handle.
//
HRESULT
LQSClose(
    HLQS hLQS)
{
    CS lock(g_LQSCS);

    LQSReferenceHandle(hLQS)->Release();

    return MQ_OK;
}

#ifdef _WIN64
HRESULT
LQSCloseWithMappedHLQS(
    DWORD dwMappedHLQS)
{
	try
	{
    	HLQS hLQS = GET_FROM_CONTEXT_MAP(g_map_QM_HLQS, dwMappedHLQS);
    	HRESULT hr = LQSClose(hLQS);
    	return LogHR(hr, s_FN, 690);
	}
	catch(const exception&)
	{
		return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 691);
	}
}
#endif //_WIN64

//
// Delete a queue store.
//
HRESULT
LQSDeleteInternal(
    LPCWSTR lpszFilePath)   // The qeueu store path - wild card.
{
    //
    // Find the queue store file.
    //
    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(lpszFilePath, &FindData);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 230);
    }

    //
    // Delete the file.
    //
    wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
    if (!DeleteFile(szFilePath))
    {
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to delete LQS file '%ls'. Error: %!winerr!", lpszFilePath, gle); 
        return MQ_ERROR_QUEUE_NOT_FOUND;
    }

    return MQ_OK;
}

//
// Delete a private queue store.
//
HRESULT
LQSDelete(
    DWORD dwQueueId)
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    HRESULT hr = LQSFilePath(LQS_PRIVATE_QUEUE,
								szFilePath,
								NULL,
								NULL,
								&dwQueueId);
	if(FAILED(hr))
		return hr;

    hr = LQSDeleteInternal(szFilePath);
    return LogHR(hr, s_FN, 250);
}

//
// Delete a public queue store.
//
HRESULT
LQSDelete(
    const GUID *pguidQueue)
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    HRESULT hr = LQSFilePath(LQS_PUBLIC_QUEUE,
								szFilePath,
								NULL,
								pguidQueue,
								NULL);
	if(FAILED(hr))
		return hr;

    hr = LQSDeleteInternal(szFilePath);
    return LogHR(hr, s_FN, 260);
}

//
// Get the unique identifier of the private queue the is associated with the
// queue store handle. This will NOT fail if the handle is of a public queue.
//
HRESULT
LQSGetIdentifier(
    HLQS hLQS,      // The queue store handle
    DWORD *pdwId)   // A buffer that receives the resulted ID.
{
    CS lock(g_LQSCS);

    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();
    LPCWSTR lpszPoint = wcsrchr(lpszIniFile, L'.');
	if(lpszPoint == NULL || (lpszPoint - lpszIniFile) < 8)
	{
		TrERROR(GENERAL, "Bad File Name in %ls", lpszIniFile);
		ASSERT(("Bad File Name.", 0));
		return MQ_ERROR_INVALID_PARAMETER;
	}

    int f = _snwscanf(lpszPoint - 8,8, TEXT("%08x"), pdwId);
	DBG_USED(f);
    ASSERT(f);

    return MQ_OK;
}

//
// Convert a file name string of a public queue store to it's GUID
// representation.
//
static
void
LQSFileNameToGuid(
    LPCWSTR lpszFileName,
    GUID *pQueueGuid)
{
    WCHAR szData[9];
    int i;

    memcpy(szData, lpszFileName, 8 * sizeof(WCHAR));
    szData[8] = L'\0';
    _snwscanf(szData,STRLEN(szData), TEXT("%08x"), &pQueueGuid->Data1);
 	memcpy(szData, lpszFileName += 8, 4 * sizeof(WCHAR));
    szData[5] = L'\0';
    _snwscanf(szData,STRLEN(szData), TEXT("%04x"), &pQueueGuid->Data2);
    memcpy(szData, lpszFileName += 4, 4 * sizeof(WCHAR));
    szData[5] = L'\0';
    _snwscanf(szData,STRLEN(szData), TEXT("%04x"), &pQueueGuid->Data3);
    for (i = 0, lpszFileName += 4;
         i < 8;
         i++, lpszFileName += 2)
    {
        DWORD dwData4;
        memcpy(szData, lpszFileName, 2 * sizeof(WCHAR));
        szData[3] = L'\0';
        _snwscanf(szData, STRLEN(szData), TEXT("%02x"), &dwData4);
        pQueueGuid->Data4[i] = static_cast<BYTE>(dwData4);
    }
}

//
// Convert a file name string of a private queue store to it's ID
// representation.
//
static
void
LQSFileNameToId(
    LPCWSTR lpszFileName,
	DWORD dwFileNameLen,
    DWORD *pQueueId)
{
    int f = _snwscanf(lpszFileName, dwFileNameLen, TEXT("%08x"), pQueueId);
    ASSERT(f);
	DBG_USED(f);
}

//
// Get either the queue GUID or the queue unique ID from the queue store file
// name string.
//
static
BOOL
LQSGetQueueInfo(
    LPCWSTR pszFileName,    // The queue store file name - not a full path.
    DWORD dwFileNameLen,
	GUID *pguidQueue,       // A pointer to a buffer that receives the GUID.
                            // Should be NULL in case of a private queue.
    DWORD *pdwQueueId)      // A pointer to a buffer that receives the unique
                            // ID. Should be NULL in case of a public queue.
{
    BOOL bFound = FALSE;

    //
    // Find the point in the file name.
    //
    LPCWSTR lpszPoint = wcschr(pszFileName, L'.');
	if(lpszPoint == NULL)
		return FALSE;

	//
	// We dont want to assert on not deleted yet queue file (which begin with ~T~)
	// but it isnt valid file for opening
	//

	ASSERT(((lpszPoint - pszFileName) == 8)  ||  // In case of a private queue.
           ((lpszPoint - pszFileName) == 11) ||  // In case of a TEMP private queue.
           ((lpszPoint - pszFileName) == 32) ||  // In case of a public queue.
           ((lpszPoint - pszFileName) == 35));   // In case of a TEMP public queue.

    if (pguidQueue)
    {
        ASSERT(!pdwQueueId);
        //
        // We're interested in public queues only.
        //
        if (lpszPoint - pszFileName == 32)
        {
            //
            // This is indeed a public queue.
            //
            bFound = TRUE;
            LQSFileNameToGuid(pszFileName, pguidQueue);
        }
    }
    else
    {
        ASSERT(!pguidQueue);
        //
        // We're interested in private queues only.
        //
        if (lpszPoint - pszFileName == 8)
        {
            //
            // This is indeed a private queue.
            //
            bFound = TRUE;
            LQSFileNameToId(pszFileName, dwFileNameLen, pdwQueueId);
        }
    }

    return bFound;
}

//
// Start the enumeration of either public or private queues
//
static
HRESULT
LQSGetFirstInternal(
    HLQS *phLQS,        // The enumeration handle.
    GUID *pguidQueue,   // A buffer to receive the resulted GUID.
    DWORD *pdwQueueId)  // A buffer to receive the resulted ID.
{
    CS lock(g_LQSCS);
    WCHAR lpszFilePath[MAX_PATH_PLUS_MARGIN];
    //
    // Start the enumeration.
    //
    wcscpy(LQSGetDirectory(lpszFilePath), TEXT("*.*"));
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = FindFirstFile(lpszFilePath, &FindData);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 270);
    }

    BOOL bFound = FALSE;

    //
    // Loop while we did not found the appropriate queue, i.e., public
    // or private
    //
    while (!bFound)
    {
        //
        // Skip over directories and queue of wrong type (private/public).
        //
        bFound = !(FindData.dwFileAttributes &
                        (FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_READONLY |      // Setup for some reasone creates a read-only
                         FILE_ATTRIBUTE_HIDDEN |        // hidden file named CREATE.DIR.
                         FILE_ATTRIBUTE_TEMPORARY)) &&  // Left-over temporary files   
                 LQSGetQueueInfo(FindData.cFileName, STRLEN(FindData.cFileName), pguidQueue, pdwQueueId);

        if (bFound)
        {
            //
            // Found one! return a queue store handle.
            //
            _HLQS *hLQS = NULL;

            HRESULT hr = LQSCreateHandle(hFindFile, &hLQS);
			if(FAILED(hr))
			{
				TrERROR(GENERAL, "Failed to create handle in LQS Get First Internal.");
                FindClose(hFindFile);
                return MQ_ERROR_INSUFFICIENT_RESOURCES;
			}

            LQSDuplicateHandle(phLQS, hLQS);
        }
        else
        {
            //
            // Continue searching.
            //
            if (!FindNextFile(hFindFile, &FindData))
            {
                //
                // Found none!
                //
                TrWARNING(GENERAL, "Failed to find the next file. gle = %!winerr!", GetLastError());
                FindClose(hFindFile);
                return MQ_ERROR_QUEUE_NOT_FOUND;
            }
        }
    }

    return MQ_OK;
}

//
// Start the enumeration of public queues
//
HRESULT
LQSGetFirst(
    HLQS *phLQS,        // A buffer to receive the resulted enumeration handle.
    GUID *pguidQueue)   // A buffer to receive the GUID of the first found queue.
{
    return LQSGetFirstInternal(phLQS, pguidQueue, NULL);
}

//
// Start the enumeration of private queues
//
HRESULT
LQSGetFirst(
    HLQS *phLQS,        // A buffer to receive the resulted enumeration handle.
    DWORD *pdwQueueId)  // A buffer to receive the ID of the first found queue.
{
    HRESULT hr2 = LQSGetFirstInternal(phLQS, NULL, pdwQueueId);
    return LogHR(hr2, s_FN, 300);
}

//
// Continue searching for more queues. Once the search fails, the handle should
// not be closed.
//
static
HRESULT
LQSGetNextInternal(
    HLQS hLQS,          // The enumeration handle.
    GUID *pguidQueue,   // A buffer to receive the resulted queue GUID.
    DWORD *pdwQueueId)  // A buffer to receive the resulted queue ID.
{
    CS lock(g_LQSCS);
    BOOL bFound;
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = LQSReferenceHandle(hLQS)->GetFindHandle();

    do
    {
        //
        // Get the next file.
        //
        if (!FindNextFile(hFindFile, &FindData))
        {
            TrWARNING(GENERAL, "Failed to find the next file. gle = %!winerr!", GetLastError());
            LQSClose(hLQS);
            return MQ_ERROR_QUEUE_NOT_FOUND;
        }

        //
        // Skip directories and queue of wrong type (private/public).
        //
        bFound = !(FindData.dwFileAttributes &
                        (FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_READONLY |      // Setup for some reasone creates a read-only
                         FILE_ATTRIBUTE_HIDDEN   |      // hidden file named CREATE.DIR.
                         FILE_ATTRIBUTE_TEMPORARY)) &&  // Left-over temporary files   
                 LQSGetQueueInfo(FindData.cFileName, STRLEN(FindData.cFileName), pguidQueue, pdwQueueId);
    } while (!bFound);

    return MQ_OK;
}

//
// Continue searching for more public queues. Once the search fails, the handle
// should not be closed.
//
HRESULT
LQSGetNext(
    HLQS hLQS,
    GUID *pguidQueue)
{
    return LQSGetNextInternal(hLQS, pguidQueue, NULL);
}

//
// Continue searching for more private queues. Once the search fails, the handle
// should not be closed.
//
HRESULT
LQSGetNext(
    HLQS hLQS,
    DWORD *pdwQueueId)
{
    return LQSGetNextInternal(hLQS, NULL, pdwQueueId);
}

#ifdef _WIN64
//
// Start the enumeration of public queues, return a mapped HLQS (e.g. DWORD)
//
HRESULT
LQSGetFirstWithMappedHLQS(
    DWORD *pdwMappedHLQS,
    DWORD *pdwQueueId)
{
    CS lock(g_LQSCS);
    CHLQS hLQS;

    HRESULT hr = LQSGetFirst(&hLQS, pdwQueueId);
    if (SUCCEEDED(hr))
    {
        //
        // create a DWORD mapping of this instance
        //
        DWORD dwMappedHLQS = ADD_TO_CONTEXT_MAP(g_map_QM_HLQS, (HLQS)hLQS);
        ASSERT(dwMappedHLQS != 0);
        //
        // save mapped HLQS in the _HLQS object for self destruction
        //
        LQSReferenceHandle(hLQS)->SetMappedHLQS(dwMappedHLQS);
        //
        // set returned mapped handle
        //
        *pdwMappedHLQS = dwMappedHLQS;
        hLQS = NULL;
    }
    return LogHR(hr, s_FN, 650);
}

//
// Continue searching for more private queues. Once the search fails, the handle
// should not be closed. Based on a mapped HLQS
//
HRESULT
LQSGetNextWithMappedHLQS(
    DWORD dwMappedHLQS,
    DWORD *pdwQueueId)
{
    HLQS hLQS = GET_FROM_CONTEXT_MAP(g_map_QM_HLQS, dwMappedHLQS);
    HRESULT hr = LQSGetNext(hLQS, pdwQueueId);
    return LogHR(hr, s_FN, 670);
}
#endif //_WIN64

HRESULT IsBadLQSFile( LPCWSTR lpszFileName,
                      BOOL    fDeleteIfBad /*= TRUE*/)
{
    WCHAR awcShortBuff[64];
    WCHAR *pValBuff = awcShortBuff;
    DWORD dwBuffLen = sizeof(awcShortBuff)/sizeof(WCHAR);
    DWORD dwReqBuffLen;
    awcShortBuff[0] = '\0';

    dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                           LQS_SIGNATURE_NAME,
                                           TEXT(""),
                                           pValBuff,
                                           dwBuffLen,
                                           lpszFileName);
    if ((dwReqBuffLen == wcslen(LQS_SIGNATURE_VALUE)) &&
        (CompareStringsNoCaseUnicode(pValBuff, LQS_SIGNATURE_VALUE) == 0))
    {
       //
       // Signature OK!
       //
       return MQ_OK ;
    }
    if ( dwReqBuffLen == 0)
    {
        //
        //  This can happen in low resources situation,
        //  GetPrivateProfileString will return zero bytes,
        //  assume the file is ok
        //
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 340);
    }

    if (fDeleteIfBad)
    {
        BOOL f = DeleteFile(lpszFileName) ;
        if (f)
        {
            return LogHR(MQ_CORRUPTED_QUEUE_WAS_DELETED, s_FN, 350);
        }

		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to delete bad LQS file '%ls'. Error: %!winerr!", lpszFileName, gle); 
        ASSERT(("should succeed to delete lqs file!", f));
    }

    return LogHR(MQ_ERROR, s_FN, 360);
}

//
// Delete a queue store.
//
HRESULT
LQSDelete(
    HLQS hLQS
	)
{
    CS lock(g_LQSCS);

    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();

    BOOL f = DeleteFile(lpszIniFile) ;
    if (f)
	{
		LogNTStatus(GetLastError(), s_FN, 370);
        return MQ_CORRUPTED_QUEUE_WAS_DELETED;
	}
	return LogHR(MQ_ERROR, s_FN, 380);
}

//
// Cleanup temporary files. This is called from QMInit to delete 
// temporary (.tmp) files - result of previously failed SetProperties attempt
//
void
LQSCleanupTemporaryFiles()
{
    //
    // We don't really need the critical section here, since we are called from
    // QMInit. Just wanted to be on the safe side.
    //
    CS lock(g_LQSCS);

    WCHAR szTempFileWildcard[MAX_PATH_PLUS_MARGIN];
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];
    //
    // Start the enumeration.
    //
    swprintf(LQSGetDirectory(szTempFileWildcard), TEXT("*%s"), x_szTemporarySuffix);
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = FindFirstFile(szTempFileWildcard, &FindData);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // No temporary files left (normal case) return.
        //
        return;
    }

    //
    // Loop over the temporary files and delete them
    //
    while (TRUE)
    {
        QmpReportServiceProgress();

        wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
        BOOL fDeleteSucceeded = DeleteFile(szFilePath);
        if (!fDeleteSucceeded)
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to delete temporary LQS file '%ls'. Error: %!winerr!", szFilePath, gle); 
        }

        //
        // Loop step
        //
        if (!FindNextFile(hFindFile, &FindData))
        {
            FindClose(hFindFile);
            break;
        }
    }

}


static
bool
ShouldAddAnonymous(
	PSECURITY_DESCRIPTOR pSD
	)
/*++
Routine Description:
	Check if we should add Anonymous write message permissions
	to the security descriptor.
	The function return true in the following case only:
	the security descriptor has no deny on MQSEC_WRITE_MESSAGE permission
	everyone has that permission and anonymous don't have that permissions.

Arguments:
	pSD - pointer to the security descriptor.

Returned Value:
	true - should add write message permission to Anonymous, false - should not add.

--*/
{
	bool fAllGranted = false;
	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;

	IsPermissionGranted(
		pSD, 
		MQSEC_WRITE_MESSAGE,
		&fAllGranted, 
		&fEveryoneGranted, 
		&fAnonymousGranted 
		);

	TrTRACE(GENERAL, "fEveryoneGranted = %d, fAnonymousGranted = %d", fEveryoneGranted, fAnonymousGranted);
	
	if(fEveryoneGranted && !fAnonymousGranted)
	{
		//
		// Only when everyone allowed and anonymous don't we should return true.
		//
		TrWARNING(GENERAL, "The security descriptor need to add Anonymous");
		return true;
	}

	return false;
}


static
bool
AddAnonymousWriteMessagePermission( 
	PACL pDacl,
	CAutoLocalFreePtr& pDaclNew
    )
/*++
Routine Description:
	Create new DACL by adding anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permission
	to existing DACL.

Arguments:
	pDacl - original DACL.
	pDaclNew - pointer to the new DACL that is created by this function

Returned Value:
	true - success, false - failure.

--*/
{
    ASSERT((pDacl != NULL) && IsValidAcl(pDacl));

    //
    // Create ace for the Anonymous, granting MQSEC_WRITE_MESSAGE permission.
    //
    EXPLICIT_ACCESS expAcss;
    memset(&expAcss, 0, sizeof(expAcss));

    expAcss.grfAccessPermissions = MQSEC_WRITE_MESSAGE;
    expAcss.grfAccessMode = GRANT_ACCESS;

    expAcss.Trustee.pMultipleTrustee = NULL;
    expAcss.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    expAcss.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    expAcss.Trustee.TrusteeType = TRUSTEE_IS_USER;
    expAcss.Trustee.ptstrName = (WCHAR*) MQSec_GetAnonymousSid();

    //
    // Obtain new DACL, that merge present one with new ace.
    //
    DWORD rc = SetEntriesInAcl( 
						1,
						&expAcss,
						pDacl,
						reinterpret_cast<PACL*>(&pDaclNew) 
						);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(GENERAL, "SetEntriesInAcl failed, error = 0x%x", rc);
		return false;
    }

    return true;
}


static
void
AddAnonymousToPrivateQueue(
	LPWSTR pFilePath, 
	LPWSTR pQueueName
	)
/*++
Routine Description:
	If needed add Anonymous MQSEC_WRITE_MESSAGE permission ACE to the
	queue security descriptor DACL.
	This will be done only to private queues. 

Arguments:
    pFilePath - the queue file path.
	pQueueName - Queue name

Returned Value:
	None

--*/
{
	TrTRACE(GENERAL, "pQueueName = %ls", pQueueName);

	//
	// Check if this is Private queue
	//
	if(!FnIsPrivatePathName(pQueueName))
	{
		TrTRACE(GENERAL, "The queue %ls is not private queue", pQueueName);
		return;
	}

	TrTRACE(GENERAL, "The queue %ls is private queue", pQueueName);

	//
	// Get Queue Security descriptor
	//
	PROPVARIANT PropVal;
	PropVal.vt = VT_NULL;
    PropVal.blob.pBlobData = NULL;
    PropVal.blob.cbSize = 0;

    HRESULT hr =  GetPropertyValue( 
						pFilePath,
						LQS_SECURITY_PROPERTY_NAME,
						VT_BLOB,
						&PropVal 
						);

	if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to get LQS_SECURITY_PROPERTY_NAME for queue %ls, hr = 0x%x", pQueueName, hr);
		return;
	}

    AP<BYTE> pAutoReleaseSD = PropVal.blob.pBlobData;

	if(!ShouldAddAnonymous(PropVal.blob.pBlobData))
	{
		TrTRACE(GENERAL, "No need to add anonymous permissions for queue %ls", pQueueName);
		return;
	}

	//
	// Get DACL Information
	//
	BOOL Defaulted;
	BOOL fAclExist;
	PACL pDacl;
	if (!GetSecurityDescriptorDacl(PropVal.blob.pBlobData, &fAclExist, &pDacl, &Defaulted))
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "GetSecurityDescriptorDacl() failed, gle = 0x%x", gle);
		return;
	}

#ifdef _DEBUG
	TrTRACE(GENERAL, "DACL information:");
	PrintAcl(fAclExist, Defaulted, pDacl);
#endif

	//
	// Create new DACL with Anonymous ALLOW_ACE for MQSEC_WRITE_MESSAGE permission 
	//
	CAutoLocalFreePtr pNewDacl;
	if(!AddAnonymousWriteMessagePermission(pDacl, pNewDacl))
	{
		TrERROR(GENERAL, "Failed to create new DACL with Anonymous permissions");
		return;
	}

	ASSERT((pNewDacl.get() != NULL) && 
			IsValidAcl(reinterpret_cast<PACL>(pNewDacl.get())));

#ifdef _DEBUG
	TrTRACE(GENERAL, "new DACL information:");
	PrintAcl(
		true, 
		false, 
		reinterpret_cast<PACL>(pNewDacl.get())
		);
#endif

	//
	// Merge the new DACL in the security descriptor
	//

    AP<BYTE> pNewSd;
	if(!MQSec_SetSecurityDescriptorDacl(
			reinterpret_cast<PACL>(pNewDacl.get()),
			PropVal.blob.pBlobData,
			pNewSd
			))
	{
		TrERROR(GENERAL, "MQSec_UpdateSecurityDescriptorDacl() failed");
		return;
	}

    ASSERT((pNewSd.get() != NULL) && IsValidSecurityDescriptor(pNewSd));
	ASSERT(GetSecurityDescriptorLength(pNewSd) != 0);

    PropVal.vt = VT_BLOB;
    PropVal.blob.pBlobData = pNewSd.get();
    PropVal.blob.cbSize = GetSecurityDescriptorLength(pNewSd);

    hr = WriteProperyString( 
				pFilePath,
				LQS_SECURITY_PROPERTY_NAME,
				VT_BLOB,
				reinterpret_cast<const BYTE*>(&PropVal.blob) 
				);

	if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to set LQS_SECURITY_PROPERTY_NAME for queue %ls, hr = 0x%x", pQueueName, hr);
		return;
	}

	TrTRACE(GENERAL, "Anonymous permissions were set for queue %ls", pQueueName);

}


void SetLqsUpdatedSD()
/*++
Routine Description:
	Set MSMQ_LQS_UPDATED_SD_REGNAME registry value to 1

Arguments:
	None

Returned Value:
	None

--*/
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
	DWORD Value = 1;

    LONG rc = SetFalconKeyValue(
					MSMQ_LQS_UPDATED_SD_REGNAME,
					&dwType,
					&Value,
					&dwSize
					);

	DBG_USED(rc);
    ASSERT(rc == ERROR_SUCCESS);
}


static bool IsLqsUpdatedSD()
/*++
Routine Description:
	Read MSMQ_LQS_UPDATED_SD_REGNAME registry value

Arguments:
	None

Returned Value:
	true - lqs was already updated, false otherwise

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwLqsUpdated = REG_DWORD;

    LONG rc = GetFalconKeyValue( 
					MSMQ_LQS_UPDATED_SD_REGNAME,
					&dwType,
					&dwLqsUpdated,
					&dwSize 
					);

	if((rc == ERROR_SUCCESS) && (dwLqsUpdated != 0))
		return true;

	return false;
}


//-----------------------------
// MigrateLQSFromNT4
//
// Migrate all the LQS files from NT4 format.
//
// In NT4 format - the suffix (Hash) of the file name is based on machinename\queuename
//
// We will migrate so suffix (hash) is based on \queuename only.
//
// In addition this routine check if we need to update private queues DACL 
//
// and add Anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permissinn
//
// This routine is idempotent (can be called several times without destroying anything)
//
// Return TRUE always
//
// -----------------------------
BOOL MigrateLQS()
{
	if(IsLqsUpdatedSD())
	{
		//
		// In this case that we already updated the lqs security descriptor
		// lqs files are already converted so no need to perform
		// the migration again
		//
		TrTRACE(GENERAL, "LQS already updated its security descriptor");
		return TRUE;
	}
    
	WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    wcscpy(LQSGetDirectory(szFilePath), L"*.*");

	TrTRACE(GENERAL, "LQS search path = %ls", szFilePath);

    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(szFilePath, &FindData);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing was found. This is weird...
        //
		ASSERT(0);
        return TRUE;
    }

    AP<BYTE> pSecurityDescriptor;
	do  // while(FindNextFile(hFindFile, &FindData) != FALSE)
    {
        QmpReportServiceProgress();

        //
        // Skip over directories and queue of wrong type (private/public).
        //
        BOOL fFound = !(FindData.dwFileAttributes &
                        (FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_READONLY  |     // Setup for some reasone creates a read-only
                         FILE_ATTRIBUTE_HIDDEN    |     // hidden file named CREATE.DIR.
                         FILE_ATTRIBUTE_TEMPORARY));   // Left-over temporary files    

		if(!fFound)
			continue;


        wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);

		TrTRACE(GENERAL, "LQS file = %ls", szFilePath);

        //
        // Try to retrieve the queue name.
        //
		PROPVARIANT PropVal;
        PropVal.pwszVal = NULL;
        PropVal.vt = VT_NULL;
		HRESULT hr =  GetPropertyValue(
							szFilePath,
							LQS_QUEUENAME_PROPERTY_NAME,
							VT_LPWSTR, 
							&PropVal
							);


		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to get LQS_QUEUENAME_PROPERTY_NAME from file %ls, hr = 0x%x", szFilePath, hr);
		}

        //
        // Make sure that the buffer will get freed.
        //
        AP<WCHAR> pqp = PropVal.pwszVal;

		if(PropVal.pwszVal[0] != 0)
		{
			//
			// File has a pathname property
			// This means that it is a converted one
			// check if we need to update private queues DACL 
			// and add Anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permissinn
			//
			TrTRACE(GENERAL, "the file %ls is already in w2k format", szFilePath);
			AddAnonymousToPrivateQueue(szFilePath, pqp.get());

			//
			// skip to the next file
			//
			continue;
		}


        //
        // Retrieve the path name.
        //
        PropVal.pwszVal = NULL;
        PropVal.vt = VT_NULL;
		hr =  GetPropertyValue(
					szFilePath,
					LQS_PATHNAME_PROPERTY_NAME,
					VT_LPWSTR, 
					&PropVal
					);

        //
        // Make sure that the buffer will get freed.
        //
        AP<WCHAR> pqp1 = PropVal.pwszVal;

		if(PropVal.pwszVal[0] == 0)
		{
			//
			// File does not have a PATHNAME
			// Bad file
			//
			TrERROR(GENERAL, "File %ls doesn't have LQS_PATHNAME_PROPERTY_NAME, hr = 0x%x", szFilePath, hr);
			continue;
		}
	
		//
		// Extract the queue name from the path name
		//
		LPWSTR pSlashStart = wcschr(PropVal.pwszVal,L'\\');

		if(pSlashStart == NULL)
		{
			//
			// Invalid queue name - No slash in queue name - Ignore
			//
			TrERROR(GENERAL, "Invalid queue name, path = %ls", PropVal.pwszVal);
			ASSERT(pSlashStart);
			continue;
		}


		//
		// Compute Hash value
		//
		DWORD Win2000HashVal = HashQueuePath(pSlashStart);

		WCHAR Win2000LQSName[MAX_PATH_PLUS_MARGIN];
        wcscpy(Win2000LQSName, szFilePath);

		LPWSTR pDot = wcsrchr(Win2000LQSName, L'.');
		if(pDot == NULL)
		{
			TrERROR(GENERAL, "Bad File Name in %ls", Win2000LQSName);
			ASSERT(("Bad File Name.", 0));
			continue;
		}

		if(lstrlen(pDot) != 9)
		{
			//
			// File suffix is not in the form *.1234578 - ignore
			// For example - 000000001.12345678.old
			//
			TrERROR(GENERAL, "File %ls, prefix is not in the required form", szFilePath);
			continue;
		}

#ifdef _DEBUG

		DWORD fp;
		swscanf(pDot+1, TEXT("%x"), &fp);

		ASSERT(fp != Win2000HashVal);

#endif

		//
		// If we got up to here - this means we need to update
		// the file
		//

		//
		// Write the queue name in the LQS file
		//
        hr = WriteProperyString(
                 szFilePath,
                 LQS_QUEUENAME_PROPERTY_NAME,
                 VT_LPWSTR, 
				 (const BYTE *)(WCHAR *)pSlashStart
				 );

		
		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to set LQS_QUEUENAME_PROPERTY_NAME for file %ls, hr = 0x%x", szFilePath, hr);
			ASSERT(0);
			continue;
		}

        PropVal.vt = VT_NULL ;
        PropVal.blob.pBlobData = NULL ;
        PropVal.blob.cbSize = 0 ;

        hr =  GetPropertyValue( 
					szFilePath,
					LQS_SECURITY_PROPERTY_NAME,
					VT_BLOB,
					&PropVal 
					);

        if (hr == MQ_ERROR_INVALID_PARAMETER)
        {
            //
            // Security property does not exist. This may happen when
            // upgrading from Win9x to Windows. Create a security
            // descriptor that grant everyone full control.
            //
            static  BOOL  fInit = FALSE;
            static  DWORD dwSDLen = 0;

            if (!fInit)
            {
                //
                // the defautl descriptor will include everyone full control and
                // will retrieve owner and group from thread access token.
                //
                hr =  MQSec_GetDefaultSecDescriptor(
                             MQDS_QUEUE,
                            (PSECURITY_DESCRIPTOR *) &pSecurityDescriptor,
                             FALSE, // fImpersonate
                             NULL,	// pInSecurityDescriptor
                             0,		// seInfoToRemove
                             e_GrantFullControlToEveryone
							 );

                ASSERT(SUCCEEDED(hr));
                LogHR(hr, s_FN, 193);

                if (SUCCEEDED(hr))
                {
                    dwSDLen = GetSecurityDescriptorLength(pSecurityDescriptor);
                }

                fInit = TRUE;
            }

            if (dwSDLen > 0)
            {
                PropVal.vt = VT_BLOB;
                PropVal.blob.pBlobData = (BYTE*) pSecurityDescriptor;
                PropVal.blob.cbSize = dwSDLen;

                ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));

                hr = WriteProperyString( 
						szFilePath,
						LQS_SECURITY_PROPERTY_NAME,
						VT_BLOB,
						(const BYTE*) &PropVal.blob 
						);

                PropVal.blob.pBlobData = NULL; // prevent auto-release.
            }
        }

        ASSERT(SUCCEEDED(hr));
        LogHR(hr, s_FN, 192);
        AP<BYTE> pAutoReleaseSD = PropVal.blob.pBlobData;

		//
		// check if we need to update private queues DACL 
		// and add Anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permission
		//
		AddAnonymousToPrivateQueue(szFilePath, pSlashStart);

		//
		// Replace the old hash by the new one in the file name
		//
		swprintf(pDot, TEXT(".%08x"), Win2000HashVal);

		//
		// And rename the file
		//
		int rc = _wrename(szFilePath, Win2000LQSName);
		DBG_USED(rc);
		
		ASSERT(rc == 0);

	} while(FindNextFile(hFindFile, &FindData) != FALSE);

	SetLqsUpdatedSD();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\msmqdbgext.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    msmqdbgext.cpp

Abstract:

    Add definitions to help windbg list msmq structures and lists.

Author:

    Doron Juster (DoronJ)
--*/

#include "stdh.h"
#include "sessmgr.h"
#include "session.h"
#include "cqueue.h"
#include "qmpkt.h"
#include "Xact.h"
#include "XactStyl.h"
#include "xactin.h"
#include "xactout.h"
#include "xactsort.h"

//+----------------------------------------
//
// structure to mimic CNode in CList
//
//+----------------------------------------

struct CQueueCNode
{
	CQueueCNode* pNext;
	CQueueCNode* pPrev;
	CQueue*      data;
};

volatile CQueueCNode dbgCQueueCNode = {NULL,NULL,NULL} ;

struct CBaseQueueCNode
{
	CBaseQueueCNode* pNext;
	CBaseQueueCNode* pPrev;
	CBaseQueue*      data;
};

volatile CBaseQueueCNode dbgCBaseQueueCNode = {NULL,NULL,NULL} ;

struct CTransportBaseCNode
{
	CTransportBaseCNode* pNext;
	CTransportBaseCNode* pPrev;
	CTransportBase*      data;
};

volatile CTransportBaseCNode dbgCTransportBaseCNode = {NULL,NULL,NULL} ;

struct CQmPacketCNode
{
	CQmPacketCNode* pNext;
	CQmPacketCNode* pPrev;
	CQmPacket*      data;
};

volatile CQmPacketCNode dbgCQmPacketCNode = {NULL,NULL,NULL} ;

struct CInSeqPacketEntryCNode
{
	CInSeqPacketEntryCNode* pNext;
	CInSeqPacketEntryCNode* pPrev;
	CInSeqPacketEntry*      data;
};

volatile CInSeqPacketEntryCNode dbgCInSeqPacketEntryCNode = {NULL,NULL,NULL} ;

struct CSeqPacketCNode
{
	CSeqPacketCNode* pNext;
	CSeqPacketCNode* pPrev;
	CSeqPacket*      data;
};

volatile CSeqPacketCNode dbgCSeqPacketCNode = {NULL,NULL,NULL} ;

struct CSortedTransactionCNode
{
	CSortedTransactionCNode* pNext;
	CSortedTransactionCNode* pPrev;
	CSortedTransaction*      data;
};

volatile CSortedTransactionCNode dbgCSortedTransactionCNode = {NULL,NULL,NULL} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\onhold.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    onhold.cpp

Abstract:

   Handle queue onhold/resume decleration

Author:

    Uri Habusha (urih) July, 1998

--*/

#ifndef __ONHOLD__
#define __ONHOLD__

HRESULT
InitOnHold(
    void
    );

HRESULT
PauseQueue(
    const QUEUE_FORMAT* pqf
    );

HRESULT
ResumeQueue(
    const QUEUE_FORMAT* pqf
    );

void
ResumeDeletedQueue(
	CQueue* PQueue 
	);

#endif //__ONHOLD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\onhold.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    onhold.cpp

Abstract:

   Handle queue onhold/resume

Author:

    Uri Habusha (urih) July, 1998

--*/

#include "stdh.h"

#include <fntoken.h>
#include <qformat.h>
#include <mqformat.h>
#include "cqmgr.h"
#include "cqueue.h"
#include "sessmgr.h"

#include "onhold.tmh"

extern CSessionMgr SessionMgr;
const WCHAR ONHOLDRegKey[] = L"OnHold Queues";

static WCHAR *s_FN=L"onhold";

static
HRESULT
GetRegValueName(
    const QUEUE_FORMAT* pqf,
    AP<WCHAR>& pRegValueName
    )
{
	ULONG BufferSize = 500;
    const ULONG x_KeyNameLen = STRLEN(ONHOLDRegKey) + 1; // for '\'
	HRESULT hr;
	do
	{
 		pRegValueName = new WCHAR[BufferSize+x_KeyNameLen];

		//
		// build the registery value name. It consist from the key name
		// and the Queue format name
		//

		wsprintf(pRegValueName.get(), L"%s\\", ONHOLDRegKey);

		DWORD QueueFormatNameLen;
		hr = MQpQueueFormatToFormatName(
							pqf,
							pRegValueName.get() + x_KeyNameLen,
							BufferSize,
							&QueueFormatNameLen,
							false
							);
		if (MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL == hr)
		{
			pRegValueName.free();
			BufferSize = QueueFormatNameLen;
			continue;
		}
		break;
	} while (TRUE);

    return LogHR(hr, s_FN, 20);
}

HRESULT
InitOnHold(
    void
    )
{
    //
    // Get a handle to Falcon registry. Don't close this handle
    // because it is cached in MQUTIL.DLL. If you close this handle,
    // the next time you'll need it, you'll get a closed handle.
    //
    HKEY hOnHoldKey;
    LONG lError;
    lError = GetFalconKey(ONHOLDRegKey, &hOnHoldKey);
    if (lError != ERROR_SUCCESS)
    {
        return LogHR(MQ_ERROR, s_FN, 30);
    }


    DWORD Index = 0;
    for(;;)
    {
        WCHAR QueueFormatName[256];
        DWORD BuffSize = 256;

        QUEUE_FORMAT qf;
        DWORD qfSize = sizeof(QUEUE_FORMAT);

        lError= RegEnumValue(
                    hOnHoldKey,
                    Index,
                    QueueFormatName,
                    &BuffSize,
                    0,
                    NULL,
                    reinterpret_cast<BYTE*>(&qf),
                    &qfSize
                    );

        if (lError != ERROR_SUCCESS)
        {
            break;
        }

        ASSERT((qf.GetType() == QUEUE_FORMAT_TYPE_PUBLIC) ||
               (qf.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
               (qf.GetType() == QUEUE_FORMAT_TYPE_DIRECT)  ||
			   (qf.GetType() == QUEUE_FORMAT_TYPE_MULTICAST));

        if (qf.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
        {
            ASSERT(wcsncmp(QueueFormatName, FN_DIRECT_TOKEN, FN_DIRECT_TOKEN_LEN) == 0);
            ASSERT(QueueFormatName[FN_DIRECT_TOKEN_LEN] == L'=');
            //
            // the format name for direct is stored without the
            // direct sting. reconstruct it from the queue format name
            //
            qf.DirectID(&QueueFormatName[FN_DIRECT_TOKEN_LEN+1]);
        }

        //
        // Get the Queue object
        //
        CQueue* pQueue;
        HRESULT hr = QueueMgr.GetQueueObject(&qf, &pQueue, NULL, false, false);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 40);
        }

        //
        // On Hold for local queue isn't allowed
        //
        ASSERT(!pQueue->IsLocalQueue());
        pQueue->Pause();

        //
        // Decrement the refernce count. It already increment in
        // GetQueueObject  function
        //
        pQueue->Release();

        ++Index;
    }

    return MQ_OK;
}


static
HRESULT
RegAddOnHoldQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // build the registery value name. It consist from the key name
    // and the Queue format name
    //
    AP<WCHAR> RegValueName;
    HRESULT hr = GetRegValueName(
            pqf,
            RegValueName
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    //
    // Set the value in registery.
    //
    DWORD dwSize = sizeof(QUEUE_FORMAT);
    DWORD dwType = REG_BINARY;
    hr = SetFalconKeyValue(
                RegValueName,
                &dwType,
                const_cast<QUEUE_FORMAT*>(pqf),
                &dwSize
                );

    return LogHR(hr, s_FN, 60);
}


static
HRESULT
RegRemoveOnHoldQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // build the registery value name. It consist from the key name
    // and the Queue format name
    //
    AP<WCHAR> RegValueName;
    HRESULT hr = GetRegValueName(
            pqf,
            RegValueName
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }

    //
    // Delet the value from registery.
    //
    hr = DeleteFalconKeyValue(RegValueName);
    return LogHR(hr, s_FN, 80);
}


HRESULT
PauseQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // Get the Queue object
    //
    R<CQueue> pQueue;
    HRESULT hr = QueueMgr.GetQueueObject(pqf, &pQueue.ref(), NULL, false, false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }

    //
    // Local queue can't hold. It is meaningless
    //
    if (pQueue->IsLocalQueue())
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 100);
    }

    //
    // Save the queue format in registery. So after next
    // MSMQ start-up it'll be open in onhold state
    //
    hr = RegAddOnHoldQueue(pqf);
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 189);

    //
    // Mark the queue as onhold queue
    //
    pQueue->Pause();
    return MQ_OK;
}


HRESULT
ResumeQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // Get the Queue object
    //
    R<CQueue> pQueue;
    BOOL fSucc = QueueMgr.LookUpQueue(pqf, &pQueue.ref(), false, false);

    //
    // onhold queue should be in the internal data structure.
    //
    if (!fSucc)
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_ACTIVE, s_FN, 110);
    }

    //
    // Local queue can't hold. It is meaningless
    //
    if (pQueue->IsLocalQueue())
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 120);
    }

    //
    // Mark the queue as regular queue
    //
    pQueue->Resume();

    //
    // Remove the format name from registery
    //
    HRESULT hr = RegRemoveOnHoldQueue(pqf);
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 193);

    return MQ_OK;
}

void
ResumeDeletedQueue(
    CQueue* pQueue
    )
{
	ASSERT(pQueue->GetGroup() == NULL);
	
    //
    // Remove the format name from registery
    //
    const QUEUE_FORMAT qf = pQueue->GetQueueFormat();
    HRESULT hr = RegRemoveOnHoldQueue(&qf);
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 193);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\outdlv.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    outdlv.cpp

Abstract:
	Implementation 	of function declared in outdlv.h					

Author:
    Gil Shafriri 4-Oct-2000


Environment:
    Platform-independent

--*/
#include "stdh.h"
#include "outdlv.h"
#include "qmpkt.h"
#include "xactout.h"
#include "xact.h"
#include "xactin.h"

#include "outdlv.tmh"

extern BOOL QmpIsLocalMachine(const GUID * pGuid);
extern COutSeqHash g_OutSeqHash;


static bool IsOrderNeeded(CQmPacket* pPkt)
{
	return pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid() );
}



bool AppCanDeliverPacket(CQmPacket* pPkt)
/*++

Routine Description:
    Test if given packet should be delivered now.	

	
Arguments:
	CQmPacket* pPkt - packet.

 Returned Value: true if the packet should be delivered - otherwise false.
--*/
{
	if(!IsOrderNeeded(pPkt))
		return true;

	return g_OutSeqHash.PreSendProcess(pPkt, false) == TRUE;
}

void AppPutPacketOnHold(CQmPacket* pPkt)
/*++

Routine Description:
    Put packet onhold for later delivery.	

	
Arguments:
	CQmPacket* pPkt - packet.


Returned Value: None

--*/
{
	ASSERT(IsOrderNeeded(pPkt));
	g_OutSeqHash.PostSendProcess(pPkt);	
}


bool AppPostSend(CQmPacket* pPkt, USHORT mqclass)
/*++

Routine Description:
    called for handling packet after send.	

	
Arguments:
	CQmPacket* pPkt - packet.


Returned Value: true if ownership is taken on the packet - otherwise false.

--*/
{
	if(!IsOrderNeeded(pPkt))
		return false;

	try
	{
		if(mqclass == MQMSG_CLASS_NORMAL)
		{
			g_OutSeqHash.PostSendProcess(pPkt);			
		}
		else
		{
			g_OutSeqHash.NonSendProcess(pPkt, mqclass);		
		}
	}
	catch(const bad_alloc&)
	{
		QmpRequeueAndDelete(pPkt);
		return true;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\outdlv.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    outdlv.h

Abstract:
	header for functions that handlers actions needed befor and after sending messages.					

Author:
    Gil Shafriri 4-Oct-2000

Environment:
    Platform-independent

--*/


class  CQmPacket;

bool AppCanDeliverPacket(CQmPacket* pPkt);
void AppPutPacketOnHold(CQmPacket* pPkt);
bool AppPostSend(CQmPacket* pPkt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\perfcomn.cpp ===
#include <stdh.h>

#include "..\\mqperf\\perfcomn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\perfdata.cpp ===
#include <stdh.h>

#include "..\\mqperf\\perfdata.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\perf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name : perfctr.h

Abstract    :

    This file defines the CPerf class which manages the counter objects and their intances.



Prototype   :

Author:

    Gadi Ittah (t-gadii)

--*/

#ifndef _PERF_H_
#define _PERF_H_

#include "perfctr.h"
#include "cs.h"
#include "spi.h"

class CPerf
{

public:

    // the constructor does not initalize the shared memory automatically
    // InitPerf() should be called.
    CPerf (PerfObjectDef * pObjectArray,DWORD dwObjectC);
    ~CPerf();

    void * GetCounters (IN LPTSTR pszObjectName);

    BOOL ValidateObject (IN LPTSTR pszObjectName);
    BOOL InValidateObject (IN LPTSTR pszObjectName);
    void * AddInstance (IN LPCTSTR pszObjectName,IN LPCTSTR pszInstanceName);
    BOOL RemoveInstance (LPTSTR IN pszObjectName, void* pCounters);
    HRESULT InitPerf ();
    BOOL IsDummyInstance(void*);
    BOOL SetInstanceName(const void* pCounters, LPCTSTR pszInstanceName);

private:
    //
    // private member functions
    //
    int FindObject (LPCTSTR pszObjectName);

    //
    // private data members
    //
    PBYTE  m_pSharedMemBase;                // pointer to base of shared memory
    DWORD  m_dwMemSize;                     // size of shared memory

    HANDLE m_hSharedMem;                    // handle to shared memory

    PerfObjectInfo * m_pObjectDefs;         // ponter to an array of information on the objects

    BOOL m_fShrMemCreated;                  // flag - set to true after shared memory has been allocated

    PerfObjectDef *     m_pObjects  ;       // pointer to array of objects
    DWORD               m_dwObjectCount;    // number of objects.

    void *   m_pDummyInstance;              // pointer to a buffer to dummy counters. This buffer is returned
                                            // when the AddInstance member failes. This enables the application
                                            // to assume the member always returns a valid pointer

    CCriticalSection m_cs;                  // critical section object used to synchronize threads
};

inline
BOOL
CPerf::IsDummyInstance(
    void *pInstance
    )
{
    return(pInstance == m_pDummyInstance);
}


#define UPDATE_COUNTER(addr,op)  op;

class CSessionPerfmon : public ISessionPerfmon
{
	public:
		CSessionPerfmon() :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~CSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);

		virtual void UpdateBytesSent(DWORD bytesSent);
		virtual void UpdateMessagesSent(void);
		
		virtual void UpdateBytesReceived(DWORD bytesReceived);
		virtual void UpdateMessagesReceived(void);

	private:
		SessionCounters* m_pSessCounters;
};


class COutHttpSessionPerfmon : public ISessionPerfmon
{
	public:
		COutHttpSessionPerfmon()  :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~COutHttpSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesSent(void);
		virtual void UpdateBytesSent(DWORD bytesSent);

		virtual void UpdateBytesReceived(DWORD)
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesReceived(void)
		{
			ASSERT(("unexpected call", 0));
		}

	private:
		COutSessionCounters* m_pSessCounters;
};

 
class CInHttpPerfmon : public ISessionPerfmon
{
	public:
		CInHttpPerfmon()  :
			m_pSessCounters(NULL)
		{
			CreateInstance(NULL);
		}

		virtual ~CInHttpPerfmon()
		{
		}

	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesReceived(void);
		virtual void UpdateBytesReceived(DWORD bytesRecv);

		virtual void UpdateBytesSent(DWORD )
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesSent(void)
		{
			ASSERT(("unexpected call", 0));
		}


	private:
		CInSessionCounters* m_pSessCounters;
};


class COutPgmSessionPerfmon : public ISessionPerfmon
{
	public:
		COutPgmSessionPerfmon()  :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~COutPgmSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesSent(void);
		virtual void UpdateBytesSent(DWORD bytesSent);

		virtual void UpdateBytesReceived(DWORD)
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesReceived(void)
		{
			ASSERT(("unexpected call", 0));
		}


	private:
		COutSessionCounters* m_pSessCounters;
};

 
class CInPgmSessionPerfmon : public ISessionPerfmon
{
	public:
		CInPgmSessionPerfmon()  :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~CInPgmSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesReceived(void);
		virtual void UpdateBytesReceived(DWORD bytesRecv);

		virtual void UpdateBytesSent(DWORD )
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesSent(void)
		{
			ASSERT(("unexpected call", 0));
		}


	private:
		CInSessionCounters* m_pSessCounters;
};


DWORD PerfGetBytesInAllQueues();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\ping.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ping.h

Abstract:

  Falcon private ping

Author:

    Lior Moshaiov (LiorM) 19-Apr-1997

--*/

#ifndef _PING_H_
#define _PING_H_


BOOL ping(const SOCKADDR* pAddr, DWORD dwTimeout);
void StartPingClient();
void StartPingServer();

#endif // _PING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\perf.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name : perfapp.cpp



Abstract    : Defines the methods of the CPerf class.



Prototype   : perfctr.h

Author:

    Gadi Ittah (t-gadii)

--*/

#include "stdh.h"

#include <string.h>
#include <TCHAR.H>
#include <stdio.h>
#include <winperf.h>
#include "qmperf.h"
#include "perfdata.h"
#include <ac.h>
#include "qmres.h"
#include <mqexception.h>
#include <autoreln.h>
#include <Aclapi.h>
#include <mqsec.h>
#include <strsafe.h>

#include "perf.tmh"

CPerf * g_pPerfObj = NULL;

static WCHAR *s_FN=L"perf";
extern HMODULE   g_hResourceMod;


//
// pqmCounters will point to the shared memory area, where the counters are stored.
// This area is updated by the QM and read by the Performance Monitor.
//
QmCounters dummyCounters;
QmCounters *g_pqmCounters = &dummyCounters;


extern HANDLE g_hAc;




inline PERF_INSTANCE_DEFINITION* Counters2Instance(const void* pCounters)
{
    BYTE* p = reinterpret_cast<BYTE*>(const_cast<void*>(pCounters));
    return reinterpret_cast<PPERF_INSTANCE_DEFINITION>(
            p -
            sizeof(PERF_INSTANCE_DEFINITION) -
            INSTANCE_NAME_LEN_IN_BYTES -
            sizeof (PERF_COUNTER_BLOCK)
            );
}


#if 0
//
// BUGBUG: this code is here for completness. it is not tested and not used
// in this file
//
inline void* Instance2Counters(PERF_INSTANCE_DEFINITION* pInstance)
{
    BYTE* p = reinterpret_cast<BYTE*>(pInstance);
    return reinterpret_cast<void*>(
            p +
            sizeof(PERF_INSTANCE_DEFINITION) +
            INSTANCE_NAME_LEN_IN_BYTES +
            sizeof (PERF_COUNTER_BLOCK)
            );
}
#endif // 0
/*====================================================



Description : Constructor for CPerf class


Arguments   :
                IN PerfObjectDef * pObjectArray - Pointer to an array of objects.
                IN DWORD dwObjectCount          - The number of objects.
                IN LPTSTR pszPerfApp            - The name of the application as it written in the registery.


=====================================================*/
CPerf::CPerf(IN PerfObjectDef * pObjectArray,IN DWORD dwObjectCount):
m_fShrMemCreated(FALSE),m_pObjectDefs (NULL),m_hSharedMem(NULL)

{
    //
    // There should be only one instance of the cperf object
    //
    ASSERT(g_pPerfObj == NULL);

    g_pPerfObj = this;

    m_pObjects      = pObjectArray;
    m_dwObjectCount = dwObjectCount;
    m_dwMemSize     = 0;

    //
    // find the maximum number of counters per object and initalize a dummy array
    // with maximum number of counters
    //

    DWORD dwMaxCounters = 1;

    for (DWORD i = 0;i<dwObjectCount;i++)
    {
        if (pObjectArray[i].dwNumOfCounters > dwMaxCounters)
        {
           dwMaxCounters = pObjectArray[i].dwNumOfCounters;
        }
    }

    m_pDummyInstance = new DWORD[dwMaxCounters];
}


/*====================================================



Description :Destructor for CPerf class. Closes shared memory and frees allocated memory


Arguments   :

Return Value:

=====================================================*/


CPerf::~CPerf()
{

    if (m_fShrMemCreated)
    {
        //
        // Clear the shared memory so objects won't be displayed in permon
        // after the QM goes down.
        //
        memset (m_pSharedMemBase,0,m_dwMemSize);

        UnmapViewOfFile (m_pSharedMemBase);
        CloseHandle(m_hSharedMem);
        delete m_pObjectDefs;
        m_pObjectDefs = 0;

    }

    delete m_pDummyInstance;
}


/*====================================================


CPerf::InValidateObject

Description :   Invalidates an object.The object will not be displayed in the performance monitor.
                The pointers to the objects counters thst were returned by the method GetCounters
                will still be valid.

Arguments   : IN LPTSTR pszObjectName - Name of object to invalidate

Return Value: TRUE if sucsesfull FALSE otherwise.

=====================================================*/


BOOL CPerf::InValidateObject (IN LPTSTR pszObjectName)

{
    CS lock(m_cs);

    if (!m_fShrMemCreated)
        return LogBOOL(FALSE, s_FN, 50);


    int  iObjectIndex = FindObject(pszObjectName);

    if (iObjectIndex==-1)
    {
        TrERROR(GENERAL,"CPerf::InValidateObject : No object named %ls", pszObjectName);
        ASSERT (0);
        return LogBOOL(FALSE, s_FN, 40);
    }


    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);

    //
    // Invalidate the object
    //
    pPerfObject-> TotalByteLength = PERF_INVALID;

    return TRUE;
}


/*====================================================


CPerf::ValidateObject

Description :   Validates an object.If the object is instensiable it must have at least one instance for it to be
                validated. After the object is validated it will appear in the performance monitor

Arguments   : IN LPTSTR pszObjectName - Name of object to invalidate

Return Value: TRUE if sucsesfull FALSE otherwise.

=====================================================*/

BOOL CPerf::ValidateObject (IN LPTSTR pszObjectName)

{
    CS lock(m_cs);


    if (!m_fShrMemCreated)
        return LogBOOL(FALSE, s_FN, 10);

    int  iObjectIndex = FindObject(pszObjectName);

    if (iObjectIndex==-1)
    {
        TrERROR(GENERAL, "CPerf::ValidateObject : No object named %ls", pszObjectName);
        ASSERT (0);
        return LogBOOL(FALSE, s_FN, 20);
    }


    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);

    //
    // if object has instances at least one of its instances must be valid for it to be valid
    //
    if (m_pObjects[iObjectIndex].dwMaxInstances >0)
    {
        if (m_pObjectDefs[iObjectIndex].dwNumOfInstances  ==  0)
        {
            TrERROR(GENERAL, "CPerf::ValidateObject : Non of object's %ls instances is valid.", pszObjectName);
	        return FALSE;
        }
    }

    //
    // Validate the object
    //
    pPerfObject-> TotalByteLength = PERF_VALID;

    return TRUE;
}




/*====================================================

GetCounters

Description : Returns a pointer to an array of counters for an object with no instances.
              The application should cache this pointer and use it to update the counters directly.
              Note that the object will be valid this method is returns.


Arguments   :

Return Value: If succefull returns a pointer to an array of counters , otherwise returns NULL.

=====================================================*/


void * CPerf::GetCounters(IN LPTSTR pszObjectName)
{
    CS lock(m_cs);

    if (!m_fShrMemCreated)
        return m_pDummyInstance;

    int  iObjectIndex = FindObject(pszObjectName);

    if (iObjectIndex==-1)
    {
        TrERROR(GENERAL, "CPerf::GetCounters : No object named %ls", pszObjectName);
        ASSERT (0);
        return NULL;
    }

    if (m_pObjects[iObjectIndex].dwMaxInstances != 0)
    {
        TrERROR(GENERAL, "CPerf::GetCounters  : Object %ls has instances use CPerf::AddInstance()", pszObjectName);
        ASSERT (0);
        return NULL;
    }

    ValidateObject (pszObjectName);

    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);

    return ((PBYTE)pPerfObject)+sizeof (PERF_COUNTER_BLOCK)+OBJECT_DEFINITION_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters);
}


/*====================================================

SetInstanceNameInternal

Description :  Set instance name internal, does not lcok instance

Arguments   :  pInstance  - Instance to update its name
               pszInstanceName - the new instance name

Return Value:  None

=====================================================*/
static void SetInstanceNameInternal(PERF_INSTANCE_DEFINITION* pInstance, LPCTSTR pszInstanceName)
{
    ASSERT(pszInstanceName != 0);

    DWORD length = min(wcslen(pszInstanceName) + 1, INSTANCE_NAME_LEN);
    LPTSTR pName = reinterpret_cast<LPTSTR>(pInstance + 1);

	pInstance->NameLength = length * sizeof(WCHAR);
    StringCchCopy(pName, length, pszInstanceName);

	//
	// replace '/' with '\' due bug in perfmon
	//
	LPWSTR pStart = pName;
	LPWSTR pEnd = pName + length - 1;

	std::replace(pStart, pEnd, L'/', L'\\');
}



/*====================================================

CPerf::SetInstanceName

Description :  Replace instance name

Arguments   :  pInstance  - Instance to update its name
               pszInstanceName - the new instance name

Return Value:  TRUE if successfull, FALSE otherwise.

=====================================================*/
BOOL CPerf::SetInstanceName(const void* pCounters, LPCTSTR pszInstanceName)
{
    CS lock(m_cs);

    if (pCounters == m_pDummyInstance)
        return TRUE;

    if (!m_fShrMemCreated)
        return FALSE;

    if (pCounters == NULL)
        return FALSE;

    PPERF_INSTANCE_DEFINITION pInstance;
    pInstance = Counters2Instance(pCounters);

    SetInstanceNameInternal(pInstance, pszInstanceName);

    return TRUE;
}


/*====================================================

CPerf::AddInstance

Description :  Adds an instance to an object.

Arguments   :  IN LPTSTR pszObjectName  - name of object to add the instance to.
               IN LPTSTR pszInstanceName    - name of the instance;

Return Value:  if succeeds returns a pointer to a an array of counters
               for the instance.
               if fails returns a pointer to a dummy array of pointers.
               The application can update the dummy array but the results will not be shown in the performance
               monitor.
=====================================================*/
void * CPerf::AddInstance(IN LPCTSTR pszObjectName,IN LPCTSTR pszInstanceName)
{
    CS lock(m_cs);

    if (!m_fShrMemCreated)
        return m_pDummyInstance;


    //
    // BugBug. Should put an assert
    //
    if ((pszObjectName==NULL) || (pszInstanceName==NULL))
    {
       TrTRACE(GENERAL, "CPerf::AddInstance:Either object or instance == NULL. (No damage done)");
       return(m_pDummyInstance);
    }

    int  iObjectIndex = FindObject (pszObjectName);
    if (iObjectIndex==-1)
    {
        TrERROR(GENERAL, "CPerf::AddInstence : No object named %ls", pszObjectName);
        ASSERT(0) ;
        return m_pDummyInstance;
    }

    TrTRACE(GENERAL, "CPerf::AddInstence : Object Name - %ls", pszObjectName);

    if (m_pObjects[iObjectIndex].dwMaxInstances == 0)
    {
        TrERROR(GENERAL, "CPerf::AddInstance: Object %ls can not have instances use CPerf::GetCounters()",pszObjectName);
        ASSERT (m_pObjects[iObjectIndex].dwMaxInstances == 0);
        return m_pDummyInstance;
    }


    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);

    if (m_pObjectDefs[iObjectIndex].dwNumOfInstances  ==  m_pObjects[iObjectIndex].dwMaxInstances)

    {
        // if there is no memory than an instamce can't be added
        TrWARNING(GENERAL, "Perf: No memory for instance %ls of Object %ls.", pszInstanceName, pszObjectName);
        return m_pDummyInstance;
    };


    PPERF_INSTANCE_DEFINITION pInstance = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfObject+OBJECT_DEFINITION_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters));

    //
    // find the first free place for the instance
    //
    DWORD i;
    for (i = 0; i < m_pObjects[iObjectIndex].dwMaxInstances; i++)
    {
        if (pInstance->ByteLength == PERF_INVALID)
            break;
        pInstance =( PPERF_INSTANCE_DEFINITION) ((PBYTE)pInstance+INSTANCE_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters));
    }

    //ASSERT (i < m_pObjects[iObjectIndex].dwMaxInstances); (this assert breaks me on multi-qm. ShaiK)
    //
    // if there are less than dwMaxInstances Instances there must always be a free place
    //
    if(i >= m_pObjects[iObjectIndex].dwMaxInstances)
    {
       //
       // If we reach here, there is a Bug in our code.
       // Until we found where, at least return a dummy instance.
       //
       return(m_pDummyInstance);
    }


    TrTRACE(GENERAL, "CPerf:: First free place for instance - %d. Instance Address %p", i, pInstance);

    //
    // Initialize the instance
    //
    pInstance->ByteLength = PERF_VALID ;
    pInstance->ParentObjectTitleIndex = 0;
    pInstance->ParentObjectInstance = 0;
    pInstance->UniqueID     = PERF_NO_UNIQUE_ID;
    pInstance->NameOffset   = sizeof(PERF_INSTANCE_DEFINITION);
    pInstance->NameLength   = 0;

    SetInstanceNameInternal(pInstance, pszInstanceName);

    //
    // setup counter block
    //
    DWORD* pdwCounters = (DWORD*)(((PBYTE)(pInstance + 1)) + INSTANCE_NAME_LEN_IN_BYTES);
    *pdwCounters = COUNTER_BLOCK_SIZE(pPerfObject->NumCounters);
    pdwCounters = (DWORD *) (((PBYTE)pdwCounters)+sizeof (PERF_COUNTER_BLOCK));

    void * pvRetVal = pdwCounters;

    //
    // initalize counters to zero
    //
    //ASSERT(pPerfObject->NumCounters == m_pObjects[iObjectIndex].dwNumOfCounters); (ShaiK)

    for (i=0;i<pPerfObject->NumCounters;i++,pdwCounters++)
        *pdwCounters =0;


    m_pObjectDefs[iObjectIndex].dwNumOfInstances++;

    return pvRetVal;
}





/*====================================================

CPerf::RemoveInstance

Description : Removes an objects instance.


Arguments: Pointer to instance


Return Value: If the function fails returns FALSE, otherwise TRUE is returned.

=====================================================*/



BOOL CPerf::RemoveInstance (LPTSTR IN pszObjectName, IN void* pCounters)
{
    CS lock(m_cs);

    if (pCounters == m_pDummyInstance)
        return TRUE;

    if (!m_fShrMemCreated)
        return FALSE;

    if (pCounters == NULL)
        return FALSE;

    PPERF_INSTANCE_DEFINITION pInstance;
    pInstance = Counters2Instance(pCounters);;

    int iObjectIndex = FindObject (pszObjectName);

    ASSERT(iObjectIndex != -1);

    TrTRACE(GENERAL, "CPerf::RemoveInstance : Object Name - %ls. Instance Address %p",pszObjectName, pInstance);


    //
    // Check if instance already removed
    //
    if (pInstance->ByteLength == PERF_INVALID)
    {
        //ASSERT(0);  (this assert breaks me on multi-qm. ShaiK)
        TrTRACE(GENERAL, "CPerf::RemoveInstance : Object Name - %ls. Instance already removed!", pszObjectName);
        return FALSE;
    }

    //
    // Check if instance has already been removed
    //
    if (pInstance->ByteLength == PERF_INVALID)
    {
        ASSERT(0);
        TrTRACE(GENERAL, "CPerf::RemoveInstance : Object Name - %ls. Instance already removed!", pszObjectName);
        return FALSE;
    }


    //
    // invalidate the instance so it won't be displayed in perfmon
    //
    pInstance->ByteLength = PERF_INVALID;


    if (m_pObjectDefs[iObjectIndex].dwNumOfInstances == 0)
        return TRUE;

    m_pObjectDefs[iObjectIndex].dwNumOfInstances--;

    //
    // if this was the last instance of the object then the object should be invalidated
    //

    if (m_pObjectDefs[iObjectIndex].dwNumOfInstances == 0)
    {
        PPERF_OBJECT_TYPE pPerfObject   = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);
        pPerfObject->TotalByteLength    = PERF_INVALID;
    }

    return TRUE;

}


static
void
GetKernelObjectSecurityDescriptor(
	LPCWSTR KernelObjectName,
	CAutoLocalFreePtr& pSD,
    PSID* ppOwnerSid,
    PACL* ppDacl
	)
/*++
Routine Description:
	Get the security descriptor information for a kernel object.
	In case of failure throw bad_win32_error.

Arguments:
	KernelObjectName - Kernel Object name
	pSD - [out] auto free pointer to the security descriptor
	ppOwnerSid - [out] Owner sid
    ppDacl - [out] DACL

Returned Value:
	None

--*/
{
    PSID pGroupSid = NULL;

    SECURITY_INFORMATION  SeInfo = OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION;

    //
    // Obtain owner and present DACL.
    //
    DWORD rc = GetNamedSecurityInfo( 
						const_cast<LPWSTR>(KernelObjectName),
						SE_KERNEL_OBJECT,
						SeInfo,
						ppOwnerSid,
						&pGroupSid,
						ppDacl,
						NULL,
						reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pSD) 
						);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(GENERAL, "Failed to get the security descriptor of the kernel object %ls, rc = 0x%x", KernelObjectName, rc);
		throw bad_win32_error(rc);
    }

	ASSERT((pSD != NULL) && IsValidSecurityDescriptor(pSD));
	ASSERT((*ppOwnerSid != NULL) && IsValidSid(*ppOwnerSid));
	ASSERT((pGroupSid != NULL) && IsValidSid(pGroupSid));
	ASSERT((*ppDacl != NULL) && IsValidAcl(*ppDacl));
}


//
// PERF_DACL_ACE_COUNT is used when creating the security descriptor of the PERF object
// And when verifying existing object security descriptor.
//
#define PERF_DACL_ACE_COUNT		2 


static
void
VerifyExistingKernelObjectDACL(
	PACL pDacl,
	PSID pOwnerSid
	)
/*++
Routine Description:
	Verify that the Existing kernel object security descriptor DACL is the one we expect.
	In case of failure throw bad_win32_error.

Arguments:
	pDacl - DACL of existing kernel object.
	pOwnerSid - owner sid.

Returned Value:
	None

--*/
{
	//
	// Verify AceCount
	//
	if(pDacl->AceCount != PERF_DACL_ACE_COUNT)
	{
		TrERROR(GENERAL, "Existing Kernel Object security descriptor DACL AceCount = %d, should have 2 ACEs", pDacl->AceCount);
		throw bad_win32_error(ERROR_INVALID_ACL);
	}
    
	//
	// Verify ACL
	//
	bool fOwnerAce = false;
	bool fEveryoneAce = false;
	for (DWORD i = 0; i < pDacl->AceCount; i++)
    {
		ACCESS_ALLOWED_ACE* pAce;
        if(!GetAce(pDacl, i, (LPVOID*)&(pAce)))
        {
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "GetAce() failed, gle = 0x%x", gle);
			throw bad_win32_error(gle);
        }

		//
		// Verify ACCESS_ALLOWED_ACE_TYPE
		//
		if(pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)
		{
			TrERROR(GENERAL, "Existing Kernel Object security descriptor DACL ACE type = %d, should be ACCESS_ALLOWED_ACE_TYPE", pAce->Header.AceType);
			throw bad_win32_error(ERROR_INVALID_ACL);
		}

		PSID pAceSid = reinterpret_cast<PSID>(&(pAce->SidStart));
		ASSERT((pAceSid != NULL) && IsValidSid(pAceSid));

		//
		// Verify ACE sid and permissions
		//
		if(EqualSid(pOwnerSid, pAceSid))
		{
			//
			// Owner ACE
			//
			if(pAce->Mask != FILE_MAP_ALL_ACCESS)
			{
				TrERROR(GENERAL, "permission for owner are %d, expected to be %d", pAce->Mask, FILE_MAP_ALL_ACCESS);
				throw bad_win32_error(ERROR_INVALID_ACL);
			}
			fOwnerAce = true;
			TrTRACE(GENERAL, "Owner FILE_MAP_ALL_ACCESS permission were verified");
		}
		else if(EqualSid(MQSec_GetWorldSid(), pAceSid))
		{
			//
			// everyone ACE
			//
			if(pAce->Mask != FILE_MAP_READ)
			{
				TrERROR(GENERAL, "permission for everyone are %d, expected to be %d", pAce->Mask, FILE_MAP_READ);
				throw bad_win32_error(ERROR_INVALID_ACL);
			}
			fEveryoneAce = true;
			TrTRACE(GENERAL, "Everyone FILE_MAP_READ permission were verified");
		}
		else
		{
			//
			// unexpected ACE
			//
			TrERROR(GENERAL, "Unexpected Ace sid %!sid!", pAceSid);
			throw bad_win32_error(ERROR_INVALID_ACL);
		}
    }

	if(!fEveryoneAce || !fOwnerAce)
	{
		TrERROR(GENERAL, "One of the Owner or everyone ACE is missing");
		throw bad_win32_error(ERROR_INVALID_ACL);
	}
}


static
void
VerifyExistingKernelObjectSD(
	LPCWSTR KernelObjectName,
	PSID pOwnerSid
	)
/*++
Routine Description:
	Verify that the Existing kernel object security descriptor is the one we expect.
	In case of failure throw bad_win32_error.

Arguments:
	KernelObjectName - Kernel Object name
	pOwnerSid - owner sid.

Returned Value:
	None

--*/
{
	ASSERT((pOwnerSid != NULL) && IsValidSid(pOwnerSid));

	CAutoLocalFreePtr pSD;
	PSID pExistingOwnerSid;
	PACL pDacl;
	GetKernelObjectSecurityDescriptor(KernelObjectName, pSD, &pExistingOwnerSid, &pDacl);

	//
	// Verified existing Owner sid
	//
	if(!EqualSid(pOwnerSid, pExistingOwnerSid))
	{
		TrERROR(GENERAL, "Existing Kernel Object security descriptor owner %!sid! is different from the expected owner sid %!sid!", pExistingOwnerSid, pOwnerSid);
		throw bad_win32_error(ERROR_INVALID_OWNER);
	}

	TrTRACE(GENERAL, "Existing Kernel Object security descriptor Owner sid %!sid! was verified", pOwnerSid);
	
	//
	// Verify existing DACL
	//
	VerifyExistingKernelObjectDACL(pDacl, pOwnerSid);
	TrTRACE(GENERAL, "Existing Kernel Object security descriptor DACL was verified");
}


/*====================================================

CPerf::InitPerf()

Description :   Allocates shared memory and initalizes performance data structures.
                This function must be called before any other method of the object.


Arguments   :

Return Value: Returns TRUE if succeful ,FALSE otherwise.

=====================================================*/

#ifdef _DEBUG

static LONG s_fInitialized = FALSE;

void PerfSetInitialized(void)
{
    LONG fCPerfAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);
    ASSERT(!fCPerfAlreadyInitialized);
}

#else
#define PerfSetInitialized()
#endif


HRESULT CPerf::InitPerf ()
{
    PerfSetInitialized();

    CS lock(m_cs);
    if (m_fShrMemCreated)
        return MQ_OK;

    m_dwMemSize = 0;

    if  (!m_fShrMemCreated)
    {
		//
        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data structures by adding base to
        //          offset value in structure.
		//
        _TCHAR szPerfKey [255];

        HRESULT hr = StringCchPrintf(szPerfKey, TABLE_SIZE(szPerfKey),  _T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"), MQQM_SERVICE_NAME);
		if(FAILED(hr))
		{
            TrERROR(GENERAL, "Registry path too long. %ls, %!hresult!", szPerfKey, hr);
	        return hr;
		}

	    LONG dwStatus;
	    HKEY hKeyDriverPerf;
        dwStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,szPerfKey,0L,KEY_QUERY_VALUE,&hKeyDriverPerf);

        if (dwStatus != ERROR_SUCCESS)
        {

			//
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
			//
            TrERROR(GENERAL, "CPerf :: PerfInit Could not open registery key for application");
	        return LogHR(HRESULT_FROM_WIN32(dwStatus), s_FN, 70);
        }

        DWORD dwSize = sizeof (DWORD);
	    DWORD dwType;
		DWORD dwFirstCounter;
        dwStatus = RegQueryValueEx(hKeyDriverPerf,_T("First Counter"),0L,&dwType,(LPBYTE)&dwFirstCounter,&dwSize);

        if (dwStatus != ERROR_SUCCESS)
        {
			//
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
			//
            TrERROR(GENERAL, "CPerf :: PerfInit Could not get base values of counters");
	        return LogHR(HRESULT_FROM_WIN32(dwStatus), s_FN, 80);
        }

        dwSize = sizeof(DWORD);
		DWORD dwFirstHelp;
        dwStatus = RegQueryValueEx(hKeyDriverPerf,_T("First Help"),0L,&dwType,(LPBYTE)&dwFirstHelp,&dwSize);

        if (dwStatus != ERROR_SUCCESS)
        {
			//
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
			//
            TrERROR(GENERAL, "CPerf :: PerfInit Could not get vbase values of counters");
	        return LogHR(HRESULT_FROM_WIN32(dwStatus), s_FN, 90);
        }

        RegCloseKey (hKeyDriverPerf); // close key to registry

        m_pObjectDefs = new PerfObjectInfo[m_dwObjectCount];
        for (DWORD i = 0; i < m_dwObjectCount; i++)
        {

            m_dwMemSize += m_pObjects[i].dwMaxInstances*INSTANCE_SIZE(m_pObjects[i].dwNumOfCounters)
                        +OBJECT_DEFINITION_SIZE (m_pObjects[i].dwNumOfCounters);

            //
            // if this object dosn't have instances then it has a counter block
            //
            if (m_pObjects[i].dwMaxInstances == 0)
                m_dwMemSize += COUNTER_BLOCK_SIZE(m_pObjects[i].dwNumOfCounters);
        }

        //
        // Create a security descriptor for the shared memory. The security
        // descriptor gives full access to the shared memory for the creator
        // and read acccess for everyone else. By default, only the creator
        // can access the shared memory. But we want that anyone will be able
        // to read the performance data. So we must give read access to
        // everyone.
		//
		// When the kernel object already exist, we verified the existing security descriptor. 
		// If you change this security descriptor remember also to change VerifyExistingKernelObjectDACL().
		//

		//
        // Initialize the security descriptor
		//
		SECURITY_DESCRIPTOR	sd;
        BOOL bRet = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        if(!bRet)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to initialize the security descriptor. gle = %!winerr!", gle);
			ASSERT(("Failed to initialize the security descriptor.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		//
        // Open the process token for query.
		//
		CAutoCloseHandle hToken;
        bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        if(!bRet)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to open process token. gle = %!winerr!", gle);
			ASSERT(("Failed to open process token.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		//
        // Get the owner information from the token.
		//
		DWORD dwLen;
        bRet = GetTokenInformation(hToken, TokenOwner, NULL, 0, &dwLen);
        if(bRet || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to get token information. gle = %!winerr!", gle);
			ASSERT(("Failed to get token information.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

        AP<char> to_buff = new char[dwLen];
        TOKEN_OWNER* to = (TOKEN_OWNER*)(char*)to_buff;
        bRet = GetTokenInformation(hToken, TokenOwner, to, dwLen, &dwLen);
        if(!bRet)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to get token information. gle = %!winerr!", gle);
			ASSERT(("Failed to get token information.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		PSID pWorldSid = MQSec_GetWorldSid();

		//
        // Allcoate buffer for the DACL.
		//
        DWORD dwAclSize = sizeof(ACL) +
                    PERF_DACL_ACE_COUNT * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                    GetLengthSid(pWorldSid) + GetLengthSid(to->Owner);
        AP<char> Dacl_buff = new char[dwAclSize];
        PACL pDacl = (PACL)(char*)Dacl_buff;

		//
        // Initialize the DACL.
		//
        bRet = InitializeAcl(pDacl, dwAclSize, ACL_REVISION);
        if(!bRet)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to initialize ACL. gle = %!winerr!", gle);
			ASSERT(("Failed to initialize ACL.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		//
        // Add read access to everyone.
		//
        bRet = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					FILE_MAP_READ,
					pWorldSid
					);
        if(!bRet)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to add access allowed ACE. gle = %!winerr!", gle);
			ASSERT(("Failed to add access allowed ACE.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		//
        // Add full access to the creator.
		//
        bRet = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					FILE_MAP_ALL_ACCESS,
					to->Owner
					);
        if(!bRet)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to add access allowed ACE. gle = %!winerr!", gle);
			ASSERT(("Failed to add access allowed ACE.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		//
        // Set the security descriptor's DACL.
		//
        bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
        if(!bRet)
		{
			DWORD gle = GetLastError();
			TrERROR(GENERAL, "Failed to set security descriptor DACL. gle = %!winerr!", gle);
			ASSERT(("Failed to set security descriptor DACL.", 0));
			return MQ_ERROR_INSUFFICIENT_RESOURCES;
		}

		//
        // Prepare the SECURITY_ATTRIBUTES structure.
		//
		SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = FALSE;

#ifdef _DEBUG
        if ((m_dwMemSize/4096+1)*4096 - m_dwMemSize > 200)
        {
            TrWARNING(GENERAL, "Shared memory can be enlarged without actually consume more memory. See file perfdata.h");
        }
#endif

		WCHAR ComputerName[MAX_PATH];
		DWORD length = TABLE_SIZE(ComputerName);
		BOOL fRes = GetComputerName(ComputerName, &length);
		if(!fRes)
		{
			DWORD gle = GetLastError();
            TrERROR(GENERAL, "Failed to get computer name, %!winerr!", gle);
	        return HRESULT_FROM_WIN32(gle);
		}

		std::wstring ObjectName = L"Global\\MSMQ";
		ObjectName += ComputerName;

		//
        // Create the shared memory.
        //
        m_hSharedMem = CreateFileMapping(
							INVALID_HANDLE_VALUE,
							&sa,
							PAGE_READWRITE,
							0,
							m_dwMemSize,
							ObjectName.c_str()
							);

        if ( m_hSharedMem== NULL)
        {
            DWORD gle = GetLastError();
            TrERROR(GENERAL, "CPerfInit :: Could not Create shared memory");
	        return HRESULT_FROM_WIN32(gle);
        }

		if(GetLastError() == ERROR_ALREADY_EXISTS)
		{
			//
			// The kernel object already exist
			// We should verify that the kernel object security descriptor is the expected one
			// This will be the case if msmq service create this object
			// It will not be the case if other application created this object.
			//
			TrTRACE(GENERAL, "kernel object %ls already exist", ObjectName.c_str());
			try
			{
				VerifyExistingKernelObjectSD(ObjectName.c_str(), to->Owner);
				TrTRACE(GENERAL, "Existing Kernel Object security descriptor was verified");
			}
			catch(const bad_win32_error& exp)
			{
				TrERROR(GENERAL, "Failed to verify existing kernel object security descriptor, gle = %!winerr!", exp.error());
				return HRESULT_FROM_WIN32(exp.error());
			}
		}

#ifdef _DEBUG
		//
		// This code ensure that when someone will change the security descriptor of the perf object
		// and will forget to update VerifyExistingKernelObjectDACL() function accordingly
		// he will hit this ASSERT
		//
		try
		{
			VerifyExistingKernelObjectSD(ObjectName.c_str(), to->Owner);
		}
		catch(const bad_win32_error&)
		{
			//
			// If you hit this ASSERT you should update VerifyExistingKernelObjectDACL()
			// with the new changes to the security descriptor
			//
			ASSERT(("VerifyExistingKernelObjectSD failed", 0));
		}
#endif

		
		m_pSharedMemBase = (PBYTE)MapViewOfFile(m_hSharedMem, FILE_MAP_WRITE, 0, 0, 0);

        if (!m_pSharedMemBase)
        {
            DWORD gle = GetLastError();
            TrERROR(GENERAL, "CPerf::PerfInit : Could not map shared memory");
	        return HRESULT_FROM_WIN32(gle);
        }

        //
        // Initalize shared memory
        //
        memset(m_pSharedMemBase, 0, m_dwMemSize);


        MapObjects (m_pSharedMemBase, m_dwObjectCount, m_pObjects, m_pObjectDefs);

        //
        // invalidate all the instances of all objects
        //
        for (i = 0; i < m_dwObjectCount; i++)
        {
            PBYTE pTemp =(PBYTE)m_pObjectDefs[i].pSharedMem;
            pTemp+=OBJECT_DEFINITION_SIZE(m_pObjects[i].dwNumOfCounters);

            for (DWORD j = 0; j < m_pObjects[i].dwMaxInstances; j++)
            {
                ((PPERF_INSTANCE_DEFINITION)pTemp)->ByteLength = PERF_INVALID;
                pTemp+=INSTANCE_SIZE(m_pObjects[i].dwNumOfCounters);
            }
        }

	    m_fShrMemCreated = TRUE;

        for (i = 0; i < m_dwObjectCount; i++)
        {

            //
            // for each object we update the offset of title and help index's
            //
            m_pObjects[i].dwObjectNameTitleIndex += dwFirstCounter;
            m_pObjects[i].dwObjectHelpTitleIndex += dwFirstHelp;

            for (DWORD j = 0; j < m_pObjects[i].dwNumOfCounters; j++)
            {
                m_pObjects[i].pCounters [j].dwCounterNameTitleIndex += dwFirstCounter;
                m_pObjects[i].pCounters [j].dwCounterHelpTitleIndex += dwFirstHelp;
            }


            //
            // for each object we initalizes the shared memory with the object                                                ;
            //
            PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) m_pObjectDefs[i].pSharedMem;

            //
            // invalidate all objects untill get counters are called
            //
            pPerfObject->TotalByteLength = PERF_INVALID;

            pPerfObject->DefinitionLength       = OBJECT_DEFINITION_SIZE(m_pObjects[i].dwNumOfCounters);
            pPerfObject->HeaderLength           = sizeof(PERF_OBJECT_TYPE);
            pPerfObject->ObjectNameTitleIndex   = m_pObjects[i].dwObjectNameTitleIndex;
            pPerfObject->ObjectNameTitle        = NULL;
            pPerfObject->ObjectHelpTitleIndex   = m_pObjects[i].dwObjectHelpTitleIndex;
            pPerfObject->ObjectHelpTitle        = NULL;
            pPerfObject->DetailLevel            = PERF_DETAIL_NOVICE;
            pPerfObject->NumCounters            = m_pObjects[i].dwNumOfCounters;
            pPerfObject->DefaultCounter         = 0;
            pPerfObject->NumInstances           = -1;
            pPerfObject->CodePage               = 0;

            PPERF_COUNTER_DEFINITION pCounter;
            pCounter = (PPERF_COUNTER_DEFINITION) ((BYTE *)pPerfObject+sizeof(PERF_OBJECT_TYPE));

            //
            // here we initalizes the counter defenitions
            //
            for (j=0;j<m_pObjects[i].dwNumOfCounters;j++)
            {

                pCounter->ByteLength = sizeof (PERF_COUNTER_DEFINITION);
                pCounter->CounterNameTitleIndex = m_pObjects[i].pCounters[j].dwCounterNameTitleIndex;
                pCounter->CounterNameTitle = NULL;
                pCounter->CounterHelpTitleIndex  = m_pObjects[i].pCounters[j].dwCounterHelpTitleIndex;
                pCounter->CounterHelpTitle = NULL;
                pCounter->DefaultScale = m_pObjects[i].pCounters[j].dwDefaultScale;
                pCounter->DetailLevel = PERF_DETAIL_NOVICE;
                pCounter->CounterType = m_pObjects[i].pCounters[j].dwCounterType;
                pCounter->CounterSize = sizeof (DWORD);
                pCounter->CounterOffset = j*sizeof (DWORD)+sizeof (PERF_COUNTER_BLOCK);

                pCounter=(PPERF_COUNTER_DEFINITION ) ((BYTE *)pCounter + sizeof (PERF_COUNTER_DEFINITION));

            }

            //
            //if the object has no instances then we must setup a counter block for it
            //
            if (m_pObjects[i].dwMaxInstances == 0)
                // setup the counter block
                * (DWORD *) pCounter = COUNTER_BLOCK_SIZE(m_pObjects[i].dwNumOfCounters);
        }
    }

	WCHAR PerfMachineQueueInstance[128];
	int Result = LoadString(
					g_hResourceMod, 
					IDS_MACHINE_QUEUES_INSTANCE,
					PerfMachineQueueInstance, 
					TABLE_SIZE(PerfMachineQueueInstance)
					);

	if(Result == 0)
	{
        DWORD gle = GetLastError();
        TrERROR(GENERAL, "CPerf::PerfInit Could not load string from resource file.");
        return HRESULT_FROM_WIN32(gle);
	}

    //
    // Inform the device driver about the performance counters buffer, so it'll
    // update the queues and QM counters.
    //
    QueueCounters *pMachineQueueCounters = static_cast<QueueCounters*>(
        AddInstance(PERF_QUEUE_OBJECT, PerfMachineQueueInstance));
    g_pqmCounters = (QmCounters *)GetCounters(PERF_QM_OBJECT);


    HRESULT rc = ACSetPerformanceBuffer(
						g_hAc,
						m_hSharedMem,
						m_pSharedMemBase,
						pMachineQueueCounters,
						g_pqmCounters
						);

    TrTRACE(GENERAL, "CPerf :: Initalization Ok.");

    return LogHR(rc, s_FN, 140);
}



/*====================================================

CPerf::FindObject

Description : Helper function for locating the objects index in the object array.


Arguments   : IN LPTSTR pszObjectName - objects name

Return Value: if succefull returns the objects index. Otherwise -1 is returned

=====================================================*/
int CPerf::FindObject (IN LPCTSTR pszObjectName)
{

    PerfObjectDef * pPerfObject = m_pObjects;

    for (DWORD i=0;i<m_dwObjectCount;i++)
    {
        if (!_tcscmp (pPerfObject->pszName,pszObjectName))
          return i;

        pPerfObject++;
    }

    return -1;
}


void
CSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<SessionCounters*>(PerfApp.AddInstance(PERF_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_SESSION_OBJECT);

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nIPSessions += 1);
}


CSessionPerfmon::~CSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nIPSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
CSessionPerfmon::UpdateBytesSent(
	DWORD bytesSent
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nOutBytes, m_pSessCounters->nOutBytes += bytesSent)
    UPDATE_COUNTER(&m_pSessCounters->tOutBytes, m_pSessCounters->tOutBytes += bytesSent)
}


void 
CSessionPerfmon::UpdateMessagesSent(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nOutPackets, m_pSessCounters->nOutPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tOutPackets, m_pSessCounters->tOutPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nOutPackets, g_pqmCounters->nOutPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tOutPackets, g_pqmCounters->tOutPackets += 1)
}


void 
CSessionPerfmon::UpdateBytesReceived(
	DWORD bytesReceived
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nInBytes, m_pSessCounters->nInBytes += bytesReceived)
    UPDATE_COUNTER(&m_pSessCounters->tInBytes, m_pSessCounters->tInBytes += bytesReceived)

}


void 
CSessionPerfmon::UpdateMessagesReceived(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nInPackets, m_pSessCounters->nInPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tInPackets, m_pSessCounters->tInPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nInPackets, g_pqmCounters->nInPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tInPackets, g_pqmCounters->tInPackets += 1)
}


void
COutHttpSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<COutSessionCounters*>(PerfApp.AddInstance(PERF_OUT_HTTP_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_OUT_HTTP_SESSION_OBJECT);


    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutHttpSessions += 1);
}


COutHttpSessionPerfmon::~COutHttpSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutHttpSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_OUT_HTTP_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
COutHttpSessionPerfmon::UpdateMessagesSent(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nOutPackets, m_pSessCounters->nOutPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tOutPackets, m_pSessCounters->tOutPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nOutPackets, g_pqmCounters->nOutPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tOutPackets, g_pqmCounters->tOutPackets += 1)
}


void 
COutHttpSessionPerfmon::UpdateBytesSent(
	DWORD bytesSent
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nOutBytes, m_pSessCounters->nOutBytes += bytesSent)
    UPDATE_COUNTER(&m_pSessCounters->tOutBytes, m_pSessCounters->tOutBytes += bytesSent)
}


void
COutPgmSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<COutSessionCounters*>(PerfApp.AddInstance(PERF_OUT_PGM_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_OUT_PGM_SESSION_OBJECT);

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutPgmSessions += 1);
}


COutPgmSessionPerfmon::~COutPgmSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutPgmSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_OUT_PGM_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
COutPgmSessionPerfmon::UpdateMessagesSent(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nOutPackets, m_pSessCounters->nOutPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tOutPackets, m_pSessCounters->tOutPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nOutPackets, g_pqmCounters->nOutPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tOutPackets, g_pqmCounters->tOutPackets += 1)
}
   

void 
COutPgmSessionPerfmon::UpdateBytesSent(
	DWORD bytesSent
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nOutBytes, m_pSessCounters->nOutBytes += bytesSent)
    UPDATE_COUNTER(&m_pSessCounters->tOutBytes, m_pSessCounters->tOutBytes += bytesSent)
}


void
CInPgmSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<CInSessionCounters*>(PerfApp.AddInstance(PERF_IN_PGM_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_IN_PGM_SESSION_OBJECT);

	UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nInPgmSessions += 1);
}


CInPgmSessionPerfmon::~CInPgmSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nInPgmSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_IN_PGM_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
CInPgmSessionPerfmon::UpdateBytesReceived(
	DWORD bytesReceived
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nInBytes, m_pSessCounters->nInBytes += bytesReceived)
    UPDATE_COUNTER(&m_pSessCounters->tInBytes, m_pSessCounters->tInBytes += bytesReceived)

}


void 
CInPgmSessionPerfmon::UpdateMessagesReceived(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nInPackets, m_pSessCounters->nInPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tInPackets, m_pSessCounters->tInPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nInPackets, g_pqmCounters->nInPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tInPackets, g_pqmCounters->tInPackets += 1)
}


void
CInHttpPerfmon::CreateInstance(
	LPCWSTR 
	)
{
	ASSERT(m_pSessCounters == NULL);
    m_pSessCounters = static_cast<CInSessionCounters*>(PerfApp.GetCounters(PERF_IN_HTTP_OBJECT));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_IN_PGM_SESSION_OBJECT);
}


void 
CInHttpPerfmon::UpdateBytesReceived(
	DWORD bytesReceived
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nInBytes, m_pSessCounters->nInBytes += bytesReceived)
    UPDATE_COUNTER(&m_pSessCounters->tInBytes, m_pSessCounters->tInBytes += bytesReceived)

}


void 
CInHttpPerfmon::UpdateMessagesReceived(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nInPackets, m_pSessCounters->nInPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tInPackets, m_pSessCounters->tInPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nInPackets, g_pqmCounters->nInPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tInPackets, g_pqmCounters->tInPackets += 1)
}


DWORD PerfGetBytesInAllQueues()
{
	return g_pqmCounters->nTotalBytesInQueues; 	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\ping.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ping.cpp

Abstract:

  Falcon private ping client and server

Author:

    Lior Moshaiov (LiorM) 19-Apr-1997

--*/

#include "stdh.h"
#include <winsock.h>
#include <nspapi.h>
#include "ping.h"
#include "cqmgr.h"
#include "license.h"
#include <mqutil.h>
#include "mqexception.h"

#include "ping.tmh"

extern LPTSTR  g_szMachineName;
extern DWORD g_dwOperatingSystem;

#define PING_SIGNATURE       'UH'

static WCHAR *s_FN=L"ping";

//---------------------------------------------------------
//
//  class CPingPacket.
//
//---------------------------------------------------------
struct CPingPacket{
public:
    CPingPacket();
    CPingPacket(DWORD, USHORT, USHORT, GUID);

    DWORD Cookie() const;
    BOOL IsOtherSideClient() const;
    BOOL IsRefuse() const;
    BOOL IsValidSignature(void) const;
    GUID *pOtherGuid() ;

private:
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfIC : 1;
            USHORT m_bfRefuse : 1;
        };
    };
    USHORT  m_ulSignature;
    DWORD   m_dwCookie;
    GUID    m_myQMGuid ;
};

//
// CPingPacket Implementation
//
inline
CPingPacket::CPingPacket()
{
}

inline
CPingPacket::CPingPacket(DWORD dwCookie, USHORT fIC, USHORT fRefuse, GUID QMGuid):
        m_bfIC(fIC),
        m_bfRefuse(fRefuse),
        m_ulSignature(PING_SIGNATURE),
        m_dwCookie(dwCookie),
        m_myQMGuid(QMGuid)
{

}

inline DWORD
CPingPacket::Cookie() const
{
    return m_dwCookie;
}

inline BOOL
CPingPacket::IsOtherSideClient() const
{
    return m_bfIC;
}

inline BOOL
CPingPacket::IsValidSignature(void) const
{
    return(m_ulSignature == PING_SIGNATURE);
}


inline BOOL
CPingPacket::IsRefuse(void) const
{
    return m_bfRefuse;
}

inline GUID *
CPingPacket::pOtherGuid()
{
   return &m_myQMGuid ;
}

//---------------------------------------------------------
//
//  class CPing
//
//---------------------------------------------------------

class CPing
{
    public:
        void Init(DWORD dwPort) ;

        SOCKET Select();
        virtual void Run() = 0;

    public:
        static HRESULT Receive(SOCKET sock,
                               SOCKADDR* pReceivedFrom,
                               CPingPacket* pPkt);
        static HRESULT Send(SOCKET sock,
                            const SOCKADDR* pSendTo,
                            DWORD dwCookie,
                            BOOL  fRefuse);

    private:
        static SOCKET CreateIPPingSocket(UINT dwPortID);

        static DWORD WINAPI WorkingThread(PVOID pThis);

    protected:
        SOCKET m_socket;
};

SOCKET CPing::CreateIPPingSocket(UINT dwPortID)
{
    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock == INVALID_SOCKET)
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "failed to create IP ping socket, gle = %!winerr!", gle);
		throw bad_win32_error(gle);
    }

    BOOL exclusive = TRUE;
    int rc = setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char*)&exclusive, sizeof(exclusive));
    if(rc != 0)
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "failed to set SO_EXCLUSIVEADDRUSE option for ping IP socket, gle = %!winerr!", gle);
		throw bad_win32_error(gle);
    }

    SOCKADDR_IN local_sin;
    local_sin.sin_family = AF_INET;
    local_sin.sin_port = htons(DWORD_TO_WORD(dwPortID));
    local_sin.sin_addr.s_addr = GetBindingIPAddress();

    //
    //  Bind to IP address
    //
    rc = bind(sock, (sockaddr*)&local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "failed bind to port %d for IP ping socket, gle = %!winerr!", dwPortID, gle);
		EvReportWithError(EVENT_WARN_PING_BIND_FAILED, gle);
		throw bad_win32_error(gle);
    }

    return sock;
}



void CPing::Init(DWORD dwPort)
{
    m_socket  = CreateIPPingSocket(dwPort);
    ASSERT(m_socket != INVALID_SOCKET);

    DWORD dwThreadID;
    HANDLE hThread = CreateThread(
                        0,
                        0,
                        WorkingThread,
                        this,
                        0,
                        &dwThreadID
                        );
    if(hThread == NULL)
    {
		DWORD gle = GetLastError();
        LogNTStatus(gle, s_FN, 20);
		TrERROR(NETWORKING, "Failed to initialize CPing object. CreateThread failed. %!winerr!", gle);
		throw bad_win32_error(gle);
    }

    CloseHandle(hThread);
}


SOCKET CPing::Select()
{
    fd_set sockset;
    FD_ZERO(&sockset);
    FD_SET(m_socket, &sockset);

    int rc;
    rc = select(0, &sockset, NULL, NULL, NULL);
    if(rc == SOCKET_ERROR)
    {
        ASSERT(m_socket != INVALID_SOCKET) ;
        TrERROR(NETWORKING, "Ping Server listen: select failed rc = %d", WSAGetLastError());
        return INVALID_SOCKET;
    }

    ASSERT(FD_ISSET(m_socket, &sockset)) ;
    return m_socket;
}


HRESULT CPing::Receive(SOCKET sock,
                       SOCKADDR* pReceivedFrom,
                       CPingPacket* pPkt)
{
    int fromlen = sizeof(SOCKADDR);

    int len = recvfrom(sock, (char*)pPkt, sizeof(CPingPacket), 0, pReceivedFrom, &fromlen);

    if((len != sizeof(CPingPacket)) || !pPkt->IsValidSignature())
    {
        TrERROR(NETWORKING, "CPing::Receive failed, rc=%d, len=%d", WSAGetLastError(), len);
        return LogHR(MQ_ERROR, s_FN, 30);
    }
    TrTRACE(ROUTING, "CPing::Receive succeeded");


    return MQ_OK;
}


HRESULT CPing::Send(SOCKET sock,
                    const SOCKADDR* pSendTo,
                    DWORD dwCookie,
                    BOOL  fRefuse)
{
    CPingPacket Pkt( dwCookie,
                     !OS_SERVER(g_dwOperatingSystem),
                     DWORD_TO_WORD(fRefuse),
                     *(CQueueMgr::GetQMGuid())) ;


    int len = sendto(sock, (char*)&Pkt, sizeof(Pkt), 0, pSendTo, sizeof(SOCKADDR));
    if(len != sizeof(Pkt))
    {
        DWORD gle = WSAGetLastError();
        TrERROR(NETWORKING, "CPing::Send failed, rc=%d", gle);
        LogNTStatus(gle, s_FN, 41);
        return MQ_ERROR;
    }

    return MQ_OK;
}


DWORD WINAPI CPing::WorkingThread(PVOID pThis)
{
    for(;;)
    {
        static_cast<CPing*>(pThis)->Run();
    }
}


//---------------------------------------------------------
//
//  class CPingClient
//
//---------------------------------------------------------

class CPingClient : public CPing
{
    public:
        void Init(DWORD dwServerPort);
        BOOL Ping(const SOCKADDR* pAddr, DWORD dwTimeout);

    private:
        virtual void Run();
        void Notify(DWORD dwCookie,
                    BOOL fRefuse,
                    BOOL fOtherSideClient,
                    GUID *pOtherGuid);
        void SetPingAddress(IN const SOCKADDR* pAddr,
                            OUT SOCKADDR * pPingAddr);

    private:
        CCriticalSection m_cs;
        HANDLE m_hNotification;
        BOOL m_fPingSucc;
        DWORD m_dwCurrentCookie;
        UINT m_server_port;
};

//
//

//---------------------------------------------------------
//
//  CPingClient IMPLEMENTATION
//
//---------------------------------------------------------
void CPingClient::Init(DWORD dwServerPort)
{
    m_server_port = dwServerPort;
    m_fPingSucc = FALSE;
    m_dwCurrentCookie = 0;
    m_hNotification = ::CreateEvent(0, FALSE, FALSE, 0);
    if (m_hNotification == 0)
	{
		DWORD gle = GetLastError();
        TrERROR(NETWORKING, "Failed to create event for ping client. %!winerr!", gle);
		throw bad_win32_error(gle);
	}

    CPing::Init(0);
}

void CPingClient::SetPingAddress(IN const SOCKADDR* pAddr,
                                 OUT SOCKADDR * pPingAddr)
{
    memcpy(pPingAddr, pAddr, sizeof(SOCKADDR));
    ASSERT(pAddr->sa_family == AF_INET);
    ((SOCKADDR_IN*)pPingAddr)->sin_port = htons(DWORD_TO_WORD(m_server_port));
}


BOOL CPingClient::Ping(const SOCKADDR* pAddr, DWORD dwTimeout)
{
    {
        CS lock(m_cs);
        m_fPingSucc = FALSE;
        ResetEvent(m_hNotification);
        SOCKADDR ping_addr;
        SetPingAddress(pAddr,&ping_addr);
        m_dwCurrentCookie++;
        Send(m_socket, &ping_addr, m_dwCurrentCookie, FALSE);
    }

    if(WaitForSingleObject(m_hNotification, dwTimeout) != WAIT_OBJECT_0)
    {
        return FALSE;
    }

    return m_fPingSucc;
}


void CPingClient::Notify(DWORD dwCookie,
                         BOOL  fRefuse,
                         BOOL  fOtherSideClient,
                         GUID  *pOtherGuid)
{
    CS lock(m_cs);

    if(dwCookie == m_dwCurrentCookie)
    {
        if (fRefuse)
        {
            m_fPingSucc = !fRefuse;
        }
        else
        {
            m_fPingSucc = g_QMLicense.NewConnectionAllowed(fOtherSideClient,
                                                           pOtherGuid);
        }

#ifdef _DEBUG
        if (!m_fPingSucc)
        {
            TrWARNING(NETWORKING, "::PING, Client Get refuse to create a new session ");
        }
#endif

        SetEvent(m_hNotification);
    }
}

void CPingClient::Run()
{
    SOCKET sock = Select();
    if(sock == INVALID_SOCKET)
    {
        return;
    }

    SOCKADDR addr;
    HRESULT rc;
    CPingPacket PingPkt;
    rc = Receive(sock, &addr, &PingPkt);
    if(FAILED(rc))
    {
        return;
    }

    Notify( PingPkt.Cookie(),
            PingPkt.IsRefuse(),
            PingPkt.IsOtherSideClient(),
            PingPkt.pOtherGuid());
}


//---------------------------------------------------------
//
//  class CPingServer
//
//---------------------------------------------------------

class CPingServer : public CPing
{
    private:
        virtual void Run();
};

//---------------------------------------------------------
//
//  CPingServer IMPLEMENTATION
//
//---------------------------------------------------------
void CPingServer::Run()
{
    SOCKET sock = Select();
    if(sock == INVALID_SOCKET)
    {
        return;
    }

    SOCKADDR addr;
    HRESULT rc;
    CPingPacket PingPkt;

    rc = Receive(sock, &addr, &PingPkt);
    if(FAILED(rc))
    {
        return;
    }

    BOOL fRefuse = ! g_QMLicense.NewConnectionAllowed(
                                          PingPkt.IsOtherSideClient(),
                                          PingPkt.pOtherGuid());
    if (fRefuse)
    {
        TrWARNING(NETWORKING, "::PING, Server side refuse to create a new session");
    }
    Send(sock, &addr, PingPkt.Cookie(), fRefuse);
}


//---------------------------------------------------------
//
//  Interface Functions
//
//---------------------------------------------------------

CPingServer s_PingServer_IP ;
CPingClient s_PingClient_IP ;

//---------------------------------------------------------
//
//  ping(...)
//
//---------------------------------------------------------

BOOL ping(const SOCKADDR* pAddr, DWORD dwTimeout)
{
    ASSERT(pAddr->sa_family == AF_INET);
    return s_PingClient_IP.Ping(pAddr, dwTimeout);
}

//---------------------------------------------------------
//
//  StartPingClient(...)
//
//---------------------------------------------------------

void StartPingClient()
{
    //
    // read IP port from registry.
    //
    DWORD dwIPPort ;

    DWORD dwDef = FALCON_DEFAULT_PING_IP_PORT ;
    READ_REG_DWORD(dwIPPort,
                   FALCON_PING_IP_PORT_REGNAME,
                   &dwDef ) ;

    s_PingClient_IP.Init(dwIPPort);
}

//---------------------------------------------------------
//
//  StartPingServer(...)
//
//---------------------------------------------------------

void StartPingServer()
{
    //
    // read IP port from registry.
    //
    DWORD dwIPPort ;

    DWORD dwDef = FALCON_DEFAULT_PING_IP_PORT ;
    READ_REG_DWORD(dwIPPort,
                   FALCON_PING_IP_PORT_REGNAME,
                   &dwDef ) ;

    s_PingServer_IP.Init(dwIPPort) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\proxy.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    proxy.h

Abstract:
    Proxy transport definition

Author:
    urih

--*/
#ifndef __PROXY_H__
#define __PROXY_H__

#include "session.h"

void
GetConnectorQueue(
	CQmPacket& pPkt,
    QUEUE_FORMAT& ConnectorFormatName
	);

class CProxyTransport : public CTransportBase
{
    public:

        CProxyTransport();
        ~CProxyTransport();

        HRESULT CreateConnection(IN const TA_ADDRESS *pAddr,
                                 IN const GUID* pguidQMId,
                                 IN BOOL fQuick = TRUE
                                 );
        void CloseConnection(LPCWSTR, bool fClosedOnError);
        void HandleAckPacket(CSessionSection * pcSessionSection);

        HRESULT Send(IN CQmPacket* pPkt, 
                     OUT BOOL* pfGetNext);

        void SetStoredAck(IN DWORD_PTR wStoredAckNo);
    
        void Disconnect(void);

    private:
		void CopyPacket(
			       IN  CQmPacket* pPkt,
                   OUT CBaseHeader**  ppPacket,
                   OUT CPacket**    pDriverPacket
				   );


		void SendEodMdg(CQmPacket* pPkt);
		void SendSimpleMdg(CQmPacket* pPkt);

        CQueue* m_pQueue;
        CQueue* m_pQueueXact;

		GUID m_guidConnector;

};


#endif //__PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\pubcache.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
    pubcache.cpp

Abstract:
    Update cache of local public key.
    Done on client machines only, to enable off-line (no DS) operation.

Author:
    Doron Juster  (DoronJ)

History:
   25-sep-1996   DoronJ       Created

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "_rstrct.h"
#include "regqueue.h"
#include "lqs.h"
#include "ad.h"

#include "pubcache.tmh"

extern CQueueMgr   QueueMgr;

#define MAX_NO_OF_PROPS 40
#define RETRY_INTERVAL_WHEN_OFFLINE  (60 * 1000)

static WCHAR *s_FN=L"pubcache";

//***************************************************************
//
//
//***************************************************************

void  
WINAPI
TimeToPublicCacheUpdate(
    CTimer* pTimer
    )
{
	try
	{
		HRESULT hr = UpdateAllPublicQueuesInCache();

		if(hr == MQ_ERROR_NO_DS)
		{
	        ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(RETRY_INTERVAL_WHEN_OFFLINE));
		}
	}
	catch(const exception&)
	{
		ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(RETRY_INTERVAL_WHEN_OFFLINE));
	}
}

HRESULT UpdateAllPublicQueuesInCache()
/*++
Routine Description:
	Attempts to update public queues in LQS and Queue manager against DS.
	if DS is not available reschedules itself and returns MQ_ERROR_NO_DS.

Arguments:

Return Value:
	returns MQ_ERROR_NO_DS if and only if it reschedulled itself because 
	DS was unavailable.

--*/
{
    if(!QueueMgr.CanAccessDS())
        return LogHR(MQ_ERROR_NO_DS, s_FN, 20);

   //
   // Enumerate local public queues in DS.
   //
   HRESULT        hr = MQ_OK;
   HANDLE         hQuery = NULL ;
   DWORD          dwProps = MAX_NO_OF_PROPS;
   PROPID         propids[ MAX_NO_OF_PROPS ];
   PROPVARIANT    result[ MAX_NO_OF_PROPS ];
   PROPVARIANT*   pvar;
   CColumns       Colset;
   DWORD nCol;

   const GUID* pMyQMGuid =  QueueMgr.GetQMGuid() ;

   //
   //  set Column Set values
   //
   nCol = 0 ;
   propids[ nCol ] = PROPID_Q_INSTANCE ;
   Colset.Add( PROPID_Q_INSTANCE ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_JOURNAL ;
   Colset.Add( PROPID_Q_JOURNAL ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_LABEL ;
   Colset.Add( PROPID_Q_LABEL ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_TYPE ;
   Colset.Add( PROPID_Q_TYPE ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_QUOTA ;
   Colset.Add( PROPID_Q_QUOTA ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_JOURNAL_QUOTA ;
   Colset.Add( PROPID_Q_JOURNAL_QUOTA ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_PATHNAME ;
   Colset.Add( PROPID_Q_PATHNAME ) ;
   DWORD nColPathName = nCol ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_BASEPRIORITY ;
   Colset.Add( PROPID_Q_BASEPRIORITY ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_TRANSACTION ;
   Colset.Add( PROPID_Q_TRANSACTION ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_AUTHENTICATE ;
   Colset.Add( PROPID_Q_AUTHENTICATE ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_PRIV_LEVEL ;
   Colset.Add( PROPID_Q_PRIV_LEVEL ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_MULTICAST_ADDRESS ;
   Colset.Add( PROPID_Q_MULTICAST_ADDRESS ) ;

   nCol++ ;
   ASSERT(nCol <=  MAX_NO_OF_PROPS) ;

   time_t regtime ;
   time(&regtime) ;

   hr = ADQueryMachineQueues(
                NULL,       // pwcsDomainController
				false,		// fServerName
                pMyQMGuid,
                Colset.CastToStruct(),
                &hQuery
                );

   if (SUCCEEDED(hr))
   {
      ASSERT(hQuery) ;

      while ( SUCCEEDED( hr = ADQueryResults( hQuery, &dwProps, result)))
      {
          if (!dwProps)
          {
             //
             //  No more results to retrieve
             //
             break;
          }

          //
          //  For each queue get its properties.
          //
          pvar = result;
          for ( int i = (dwProps / nCol) ; i > 0 ; i-- )
          {
			 UpdateCachedQueueProp(  
				pvar->puuid,
				nCol,
				propids,
				pvar,
				regtime
				);             
			 
			 delete pvar->puuid ;
             PROPVARIANT*  ptmpvar = pvar + nColPathName ;
             delete ptmpvar->pwszVal ;
             pvar = pvar + nCol ;
          }
      }
      //
      // close the query handle
      //
      ADEndQuery( hQuery);
   }

   if (FAILED(hr))
	  return LogHR(hr, s_FN, 10);

   //
   // Now cleanup old registry entries, to prevent garbage accumulation.
   //
   GUID guid;
   HLQS hLQSEnum;

   HRESULT hrEnum = LQSGetFirst(&hLQSEnum, &guid);

   while (SUCCEEDED(hrEnum))
   {
        DeleteCachedQueueOnTimeStamp(&guid, regtime) ;
        hrEnum = LQSGetNext(hLQSEnum, &guid);
        //
        // No need to close the enumeration handle in case LQSGetNext fails
        //
   }

   TrTRACE(GENERAL, "TimeToPublicCacheUpdate successfully terminated");

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qm2qm_c_.c ===
#pragma warning(push, 3)
#include <qm2qm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qm2qm_s_.c ===
#pragma warning(push, 3)
#include <qm2qm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\proxy.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    proxy.cpp

Abstract:

    Implementation of local transport class, used for passing
    messages to the connector queue

Author:

    Uri Habusha (urih)
--*/


#include "stdh.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "proxy.h"
#include "xact.h"
#include "xactrm.h"
#include "xactout.h"
#include "xactin.h"
#include "mqexception.h"

#include "qmacapi.h"

#include "proxy.tmh"

extern CQueueMgr QueueMgr;
extern HANDLE g_hAc;

static WCHAR *s_FN=L"proxy";

void
GetConnectorQueue(
	CQmPacket& pPkt,
    QUEUE_FORMAT& fn
	)
{
    PVOID p = pPkt.GetPointerToPacket();

	CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(p) - 1;
	ASSERT(ppi->InConnectorQueue());
	DBG_USED(ppi);

	
	//
	//Retreive the connector Guid. We save it at the end of the message
	//
	const GUID* pgConnectorQueue = (GUID*)
     (((UCHAR*) pPkt.GetPointerToPacket()) + ALIGNUP4_ULONG(pPkt.GetSize()));

    try
    {
    	fn.ConnectorID(*pgConnectorQueue);
    }
    catch(...)
    {
        //
        // MSMQ1 connector packet not compatibale with the QFE.
        // This is the last packet in memory mapped file that doesn't include the
        // connector queue guid.
        //
        fn.ConnectorID(GUID_NULL);
        LogIllegalPoint(s_FN, 61);
    }
	if (pPkt.IsOrdered())
	{
		//
		// Get transacted connector queue
        //
        fn.Suffix(QUEUE_SUFFIX_TYPE_XACTONLY);
    }
}


void
CProxyTransport::CopyPacket(
	IN  CQmPacket* pPkt,
    OUT CBaseHeader**    ppPacket,
    OUT CPacket**    ppDriverPacket
	)
{
    enum ACPoolType acPoolType;
    HRESULT hr=MQ_OK;

    if (pPkt->IsRecoverable())
    {
        acPoolType = ptPersistent;
    }
    else
    {
        acPoolType = ptReliable;
    }

	DWORD dwSize = 	ALIGNUP4_ULONG(ALIGNUP4_ULONG(pPkt->GetSize()) + sizeof(GUID));
    CACPacketPtrs packetPtrs = {NULL, NULL};
    hr = QmAcAllocatePacket(g_hAc,
                          acPoolType,
                          dwSize,
                          packetPtrs
                         );

	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to allocate packet for copying packet. %!hresult!", hr);
		LogHR(hr, s_FN, 10);
		throw bad_hresult(hr);
	}

    memcpy(packetPtrs.pPacket, pPkt->GetPointerToPacket(), pPkt->GetSize());

	//
	// Copy the connector GUID for recovery porpose
	//
	GUID* pCNId = reinterpret_cast<GUID*>((PUCHAR)packetPtrs.pPacket + ALIGNUP4_ULONG(pPkt->GetSize()));
	*pCNId = m_guidConnector;

	*ppPacket = packetPtrs.pPacket;
    *ppDriverPacket = packetPtrs.pDriverPacket;
}

//
// constructor
//
CProxyTransport::CProxyTransport()
{
    m_pQueue = NULL;
    m_pQueueXact = NULL;
}

//
// destructor
//
CProxyTransport::~CProxyTransport()
{
    //
    // Decrement reference count on connector queue objects.
    //
    if (m_pQueue)
    {
        m_pQueue->Release();
        m_pQueue = NULL;
    }

    if (m_pQueueXact)
    {
        m_pQueueXact->Release();
        m_pQueueXact = NULL;
    }
}

//
// CProxyTransport::CreateConnection
//
HRESULT
CProxyTransport::CreateConnection(
    IN const TA_ADDRESS *pAddr,
    IN const GUID* /* pguidQMId */,
    IN BOOL  /* fQuick = TRUE */
    )
{
    ASSERT(pAddr->AddressType == FOREIGN_ADDRESS_TYPE);

    //
    // Get Forien CN Name
    //
    QUEUE_FORMAT qFormat;
    HRESULT rc;

    //
    // Get Not transacted connector queue
    //
	m_guidConnector = *(GUID*)pAddr->Address;	
    qFormat.ConnectorID(m_guidConnector);
    rc = QueueMgr.GetQueueObject(&qFormat, &m_pQueue, 0, false, false);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 20);
    }

    //
    // Get transacted connector queue
    //
    qFormat.Suffix(QUEUE_SUFFIX_TYPE_XACTONLY);
    rc = QueueMgr.GetQueueObject(&qFormat, &m_pQueueXact, 0, false, false);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 30);
    }



    // set session status to connect
    SetSessionStatus(ssActive);

    //Keep the TA_ADDRESS format
    SetSessionAddress(pAddr);

    // store that this is the client side
    SetClientConnect(TRUE);

    // keep the destination QM ID
    SetQMId(&GUID_NULL);

    TrTRACE(NETWORKING, "Proxy Session created with %ls", GetStrAddr());

    return MQ_OK;
}


/*====================================================

CProxyTransport::CloseConnection

Arguments:

Return Value:

Thread Context:

=====================================================*/
void CProxyTransport::CloseConnection(
                                   LPCWSTR lpcwsDbgMsg,
								   bool	fClosedOnError
                                   )
{
    CS lock(m_cs);

    //
    // Delete the group. move all the queues that associated
    // to this session to non-active group.
    //
    CQGroup* pGroup = GetGroup();
    if (pGroup != NULL)
    {
		if (fClosedOnError)
		{
			pGroup->OnRetryableDeliveryError();
		}

        pGroup->Close();

        pGroup->Release();
        SetGroup(NULL);
    }

    //
    // set session status to not connect
    //
    SetSessionStatus(ssNotConnect);

    TrWARNING(NETWORKING, "Close Connection with %ls. %ls", GetStrAddr(), lpcwsDbgMsg);

}


void CProxyTransport::SendEodMdg(CQmPacket* pPkt)
{
    CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(pPkt->GetPointerToPacket()) - 1;

	ASSERT(!pInfo->InConnectorQueue());
	DBG_USED(pInfo);

    //
    // Exactly-Once:  freshly received ordered message processing
    //

	//
	// Copy the packet
	//
	CBaseHeader* pbuf;
	CPacket* pDriverPacket;
	
	CopyPacket(pPkt,&pbuf, &pDriverPacket);
	CQmPacket newPkt(pbuf, pDriverPacket);

	try
	{
		ASSERT(g_pInSeqHash != NULL);

	    //
	    // Check if the packet should be accepted or ignored
	    // We use the new packet intentionally. The inseq mechanism needs to work
	    // with the pointer to the driver packet.
	    //
		R<CInSequence> pInSeq = g_pInSeqHash->LookupCreateSequence(&newPkt);

		CS lock(pInSeq->GetCriticalSection());

	    if(!pInSeq->VerifyAndPrepare(&newPkt, m_pQueueXact->GetQueueHandle()))
		{
	        //
	        // Packet has a wrong seq number. Seq Ack will be sent back with last good number.
	        //
		    QmAcFreePacket(
	    				   pPkt->GetPointerToDriverPacket(),
	    				   0,
	    				   eDeferOnFailure);

			QmAcFreePacket(
					   newPkt.GetPointerToDriverPacket(),
					   0,
					   eDeferOnFailure);
			return;
		}

		P<CACPacketPtrs> pOldPktPtrs = new CACPacketPtrs;
		pOldPktPtrs->pPacket = pPkt->GetPointerToPacket();
		pOldPktPtrs->pDriverPacket = pPkt->GetPointerToDriverPacket();

		TrTRACE(XACT_SEND,
				"Exactly1 send: Send Transacted packet to Connector queue.: SeqID=%I64d, SeqN=%d, Prev=%d",
				pPkt->GetSeqID(),
				pPkt->GetSeqN(),
				pPkt->GetPrevSeqN()
	            );

		//
		// Save the pointer to old packet, so when the storage of the new packet
		// completes, MSMQ release the old one.
		// Increment the reference count to insure that no one delete the session
		// object before the storage of the packet is completed
		//
		AddRef();

		newPkt.SetStoreAcknowldgeNo((DWORD_PTR) pOldPktPtrs.get());

		//
		// Accepted. Mark as received (to be invisible to readers
		// yet) and store in the queue.
		//
		HRESULT hr = m_pQueueXact->PutOrderedPkt(&newPkt, FALSE, this);
		if (FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to put packet into connector queue. %!hresult!", hr);

			Release();
			throw bad_hresult(hr);
		}
		
		pInSeq->Advance(&newPkt);

		pOldPktPtrs.detach();
	}
	catch(const exception&)
	{
		QmAcFreePacket(
				   newPkt.GetPointerToDriverPacket(),
				   0,
				   eDeferOnFailure);

		throw;
	}
}


void CProxyTransport::SendSimpleMdg(CQmPacket* pPkt)
{
	//
	// Non Transaction message
	//
	P<CACPacketPtrs> pOldPktPtrs = new CACPacketPtrs;
	pOldPktPtrs->pPacket = pPkt->GetPointerToPacket();
	pOldPktPtrs->pDriverPacket = pPkt->GetPointerToDriverPacket();


	//
	// Copy the packet
	//
	CBaseHeader* pbuf;
	CPacket* pDriverPacket;
	
	CopyPacket(pPkt,&pbuf, &pDriverPacket);
	CQmPacket newPkt(pbuf, pDriverPacket);

    //
    // Save the pointer to old packet, so when the storage of the new packet
    // completes, MSMQ release the old one.
    // Increment the reference count to insure that no one delete the session
    // object before the storage of the packet is completed
    //
    AddRef();
    newPkt.SetStoreAcknowldgeNo((DWORD_PTR) pOldPktPtrs.get());
    HRESULT hr = m_pQueue->PutPkt(&newPkt, FALSE, this);

	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to put packet into connector queue. %!hresult!", hr);
		
		Release();
	    QmAcFreePacket(
    				   newPkt.GetPointerToDriverPacket(),
    				   0,
    				   eDeferOnFailure);
		
		throw bad_hresult(hr);
	}

	pOldPktPtrs.detach();
}

/*====================================================

CProxyTransport::Send

Arguments: this function should not be called for proxy session

Return Value:

Thread Context:

=====================================================*/
HRESULT
CProxyTransport::Send(IN  CQmPacket* pPkt,
                      OUT BOOL* pfGetNext)
{
    //
    // The orignal packet will be removed when the ACPutPacket is completed. We do it
    // to avoid the case that persistence message is deleted before writing on the
    // disk completed.
    //
    if (IsDisconnected())
    {
        TrTRACE(NETWORKING, "Session %ls is disconnected. Reque the packet and don't send any more message on this session", GetStrAddr());

        //
        // The session is disconnected. return the packet to the driver
        // and don't get a new packet for sending on this session. All
        // the queues move latter to nonactive group and rerouted using
        // a new session.
        //
        // This deletes pPkt
        //
        RequeuePacket(pPkt);
        *pfGetNext = FALSE;

        return MQ_OK;
    }

	if(WPP_LEVEL_COMPID_ENABLED(rsTrace, NETWORKING))
	{
        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);

        TrTRACE(NETWORKING, "Send packet to Connector queue. Packet ID = " LOG_GUID_FMT "\\%u", LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier);
    }

    *pfGetNext = TRUE;

    //
    // Mark the proxy session as used, such it will not clean up in release session.
    //
    SetUsedFlag(TRUE);

	HRESULT hr;

	try
	{
		if (pPkt->IsOrdered())
		{
			SendEodMdg(pPkt);
		}
		else
		{
			SendSimpleMdg(pPkt);
		}

		return MQ_OK;
	}
	catch(const bad_hresult& e)
	{
		hr = e.error();
	}
	catch(const bad_alloc&)
	{
		hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		hr = MQ_ERROR;
	}

    //
    // We could not copy the packet and the Connector QM is the send machine.
    // Return the message to the queue. We will retry later
    //
    // This deletes pPkt
    //
    RequeuePacket(pPkt);

	Close_Connection(this, L"Failed to send message to connector queue");

	LogHR(hr, s_FN, 42);
	return hr;
}

/*====================================================

CProxyTransport::HandleAckPacket

Arguments: this function should not be called for proxy session

Return Value:

Thread Context:

=====================================================*/
void
CProxyTransport::HandleAckPacket(CSessionSection * /* pcSessionSection */)
{
    ASSERT(0);
}


/*====================================================

CProxyTransport::SetStoredAck

Arguments: this function should not be called for proxy session

Return Value:

Thread Context:

=====================================================*/
void
CProxyTransport::SetStoredAck(IN DWORD_PTR dwStoredAckNo)
{
    P<CACPacketPtrs> pPacketPtrs = (CACPacketPtrs*)dwStoredAckNo;
    P<CQmPacket> pPkt = new CQmPacket(pPacketPtrs->pPacket, pPacketPtrs->pDriverPacket);

    CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(pPkt->GetPointerToPacket()) - 1;

    //
    // free the original packet. If the packet is transacted packet and we are
    // in the source machine we can't free the packet until readReceipt Ack is arrived.
    //
	ASSERT(!pInfo->InConnectorQueue());
	DBG_USED(pInfo);
    if (pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
    {
        //
        // Ordered packet on the sender node: resides in a separate list in COutSeq
        //
        g_OutSeqHash.PostSendProcess(pPkt.detach());
    }
    else
    {
	    QmAcFreePacket(
    				   pPkt->GetPointerToDriverPacket(),
    				   0,
    				   eDeferOnFailure);
    }

    Release();
}

/*====================================================

CProxyTransport::Disconnect

Arguments:

Return Value:

Thread Context:

=====================================================*/
void
CProxyTransport::Disconnect(
    void
    )
{
    CS lock(m_cs);

    SetDisconnected();
    if (GetSessionStatus() == ssActive)
    {
        TrTRACE(NETWORKING, "Disconnect ssesion with %ls", GetStrAddr());

        Close_ConnectionNoError(this, L"Disconnect network");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\pktlist.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    recovery.cpp

Abstract:

    Packet & Transaction Recovery

Author:

    Erez Haba (erezh) 3-Jul-96

Revision History:

--*/


#ifndef __PKTLIST_H
#define __PKTLIST_H

template <class T>
inline T* value_type(const T*) { return (T*)(0); }

template <class T>
inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }

#include "heap.h"

//---------------------------------------------------------
//
//  class CPacketList
//
//---------------------------------------------------------

class CPacketList {

    class CNode;

    enum { xInitialSize = 1024 };

public:
    CPacketList();
   ~CPacketList();

    BOOL isempty() const;
    void pop();
    CPacket* first() const;
    void insert(ULONGLONG key, CPacket* pDriverPacket);

private:
    void realloc_buffer();

private:
    CNode* m_pElements;
    int m_limit;
    int m_used;

};

class CPacketList::CNode {
public:
    CNode() {}
    CNode(ULONGLONG key, CPacket* pDriverPacket) :
        m_key(key), m_pDriverPacket(pDriverPacket) {}


    int operator < (const CNode& a)
    {
        return (m_key > a.m_key);
    }
    
public:
    ULONGLONG m_key;
    CPacket* m_pDriverPacket;

};


CPacketList::CPacketList() :
    m_pElements(new CNode[xInitialSize]),
    m_limit(xInitialSize),
    m_used(0)
{
}

CPacketList::~CPacketList()
{
    delete[] m_pElements;
}

BOOL CPacketList::isempty() const
{
    return (m_used == 0);
}

void CPacketList::pop()
{
    ASSERT(isempty() == FALSE);
    pop_heap(m_pElements, m_pElements + m_used);
    --m_used;
}

CPacket* CPacketList::first() const
{
    ASSERT(isempty() == FALSE);
    return m_pElements->m_pDriverPacket;
}

void CPacketList::insert(ULONGLONG key, CPacket* pDriverPacket)
{
    if(m_used == m_limit)
    {
        realloc_buffer();
    }

    m_pElements[m_used] = CNode(key, pDriverPacket);
    ++m_used;
    push_heap(m_pElements, m_pElements + m_used);
}


void CPacketList::realloc_buffer()
{
    ASSERT(m_limit != 0);
    CNode* pElements = new CNode[m_limit * 2];

    //
    //  NOTE: we do a bitwise copy this might not be good for all purpos
    //        and might be replace with a copy loop
    //
    memcpy(pElements, m_pElements, m_used * sizeof(CNode));

    m_limit *= 2;
    delete[] m_pElements;
    m_pElements = pElements;
}

#endif // __PKTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmacapi.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmacapi.cpp

Abstract:
	This file contains wrappers to ac calls defined in acapi.h
	We need wrappers for ac calls in order to handle failures.

	When a call to the ac fails, we either throw an exception or
	defer the call execution to a later stage.

	To defer the execution we use a CDeferredExecutionList.

	We also make sure that when an a call to the ac fails, we have
	an available list entry item to safetly add the action to the
	deferred exection list. In order to do this, we keep a list of items
	available. This is done by reserving items on a DeferredItemsPool

	Reserving an item at
	====================
	* ACAllocatePacket
	* ACGetPacket
	* ACGetPacketByCookie
	* ACBeginGetPacket2Remote (sync+async)
	* Service -> rfAck
	* Service -> rfStorage
	* Service -> rfCreatePacket
	* Service -> rfTimeout


	Unreserving an item / making deferred execution failure
	===========================================================
	* ACFreePacket <ACAllocatePacket, ACGetPacket, ACBeginGetPacket2Remote, ACGetPacketByCookie>
	* ACFreePacket1  <Service -> rfTimeout>
	* ACFreePacket2  <QmAcGetPacketByCookie>
	* ACPutPacket <ACGetPacket>
	* ACPutPacket(+Overlapped) <QmAcAllocatePacket>
	* ACEndGetPacket2Remote <ACBeginGetPacket2Remote>
	* ACArmPacketTimer  <Service -> rfTimeout>
	* ACAckingCompleted <Service -> rfAck>
	* ACStorageCompleted <Service -> rfStorage>
	* ACCreatePacketCompleted  <Service -> rfCreatePacket>
	* ACPutRestoredPacket   <QmAcGetPacketByCookie>
	* ACPutRemotePacket <QmAcAllocatePacket>


	Not needed
	==========
	ACConvertPacket  <ACGetRestoredPacket> - This is done only in recovery and thus a failure will cause the service to close.
	ACPutPacket1 - This is followed by an ACPutPacket/AcFreePacket which will complete the handling of the packet


Author:

    Nir Ben-Zvi (nirb)

--*/
#include "stdh.h"
#include "ac.h"
#include "mqexception.h"
#include "CDeferredExecutionList.h"



#define QMACAPI_CPP			// Defined so that we will not deprecate the driver functions wrapped by this file.
#include "qmacapi.h"

#include "qmacapi.tmh"

extern HANDLE g_hAc;

CDeferredItemsPool* g_pDeferredItemsPool = NULL;

void InitDeferredItemsPool();

static void WINAPI FreePacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACFreePacketList(FreePacketDeferredExecutionRoutine);

static void WINAPI FreePacket1DeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACFreePacket1List(FreePacket1DeferredExecutionRoutine);

static void WINAPI FreePacket2DeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACFreePacket2List(FreePacket2DeferredExecutionRoutine);

static void WINAPI PutPacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACPutPacketList(PutPacketDeferredExecutionRoutine);

static void WINAPI PutRestoredPacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACPutRestoredPacketList(PutRestoredPacketDeferredExecutionRoutine);

static void WINAPI PutRemotePacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACPutRemotePacketList(PutRemotePacketDeferredExecutionRoutine);

static void WINAPI PutPacketOverlappedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACPutPacketOverlappedList(PutPacketOverlappedDeferredExecutionRoutine);

static void WINAPI EndGetPacket2RemoteDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACEndGetPacket2RemoteList(EndGetPacket2RemoteDeferredExecutionRoutine);

static void WINAPI ArmPacketTimerDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACArmPacketTimerList(ArmPacketTimerDeferredExecutionRoutine);

static void WINAPI AckingCompletedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACAckingCompletedList(AckingCompletedDeferredExecutionRoutine);

static void WINAPI StorageCompletedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACStorageCompletedList(StorageCompletedDeferredExecutionRoutine);

static void WINAPI CreatePacketCompletedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p);
static CDeferredExecutionList<CDeferredItemsPool::CDeferredItem> s_ACCreatePacketCompletedList(CreatePacketCompletedDeferredExecutionRoutine);

void
InitDeferredItemsPool()
{
    g_pDeferredItemsPool = new CDeferredItemsPool();
}

void
QmAcFreePacket(
    CPacket * pkt,
    USHORT usClass,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to free the packet. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	handle - The driver handle
    pkt - The driver packet.
    usClass - If needed, the class of the ack to be generated
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACFreePacket(g_hAc, pkt, usClass);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "AcFreePacket failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.packet1 = pkt;
	pItem->u2.ushort1 = usClass;
	pItem->handle1 = g_hAc;
	s_ACFreePacketList.insert(pItem);
}


static void WINAPI FreePacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred free packet operations

	After freeing the packet, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.packet - A pointer to the driver packet
    	p->u2.ushort1 - The usClass
    	p->handle1 - The hDevice

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for FreePacket");

	HRESULT hr = ACFreePacket(p->handle1, p->u1.packet1, p->u2.ushort1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "AcFreePacket failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcFreePacket1(
    HANDLE handle,
    const VOID* pCookie,
    USHORT usClass,
	DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to free the storage for the packet. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	handle - The driver handle
    pCookie - The driver packet.
    usClass - If needed, the class of the ack to be generated
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACFreePacket1(handle, pCookie, usClass);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACFreePacket1 failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.ptr1 = pCookie;
	pItem->u2.ushort1 = usClass;
	pItem->handle1 = handle;
	s_ACFreePacket1List.insert(pItem);
}


static void WINAPI FreePacket1DeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred free2 packet operations

	After freeing the packet, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.ptr1 - A pointer to the driver packet
    	p->u2.ushort1 - The usClass
    	p->handle1 - The hDevice

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for FreePacket1");

	HRESULT hr = ACFreePacket1(p->handle1, p->u1.ptr1, p->u2.ushort1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "AcFreePacket1 failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcFreePacket2(
    HANDLE handle,
    const VOID* pCookie,
    USHORT usClass,
	DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to free the storage for the packet. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	handle - The driver handle
    pCookie - The driver packet.
    usClass - If needed, the class of the ack to be generated
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACFreePacket2(handle, pCookie, usClass);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACFreePacket2 failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.ptr1 = pCookie;
	pItem->u2.ushort1 = usClass;
	pItem->handle1 = handle;
	s_ACFreePacket2List.insert(pItem);
}


static void WINAPI FreePacket2DeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred free2 packet operations

	After freeing the packet, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.ptr1 - A pointer to the driver packet
    	p->u2.ushort1 - The usClass
    	p->handle1 - The hDevice

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for FreePacket2");

	HRESULT hr = ACFreePacket2(p->handle1, p->u1.ptr1, p->u2.ushort1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "AcFreePacket2 failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcPutPacket(
    HANDLE hQueue,
    CPacket * pkt,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to put the packet. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	handle - The queue handle
    pkt - The driver packet.
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACPutPacket(hQueue, pkt);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACPutPacket failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.packet1 = pkt;
	pItem->handle1 = hQueue;
	s_ACPutPacketList.insert(pItem);
}


static void WINAPI PutPacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred put packet operations

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.packet1 - A pointer to the driver packet
    	p->handle1 - The queue

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for PutPacket");

	HRESULT hr = ACPutPacket(p->handle1, p->u1.packet1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACPutPacket failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcPutRestoredPacket(
    HANDLE hQueue,
    CPacket * pkt,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to put the packet. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	handle - The queue handle
    pkt - The driver packet.
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACPutRestoredPacket(hQueue, pkt);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACPutRestoredPacket failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.packet1 = pkt;
	pItem->handle1 = hQueue;
	s_ACPutRestoredPacketList.insert(pItem);
}


static void WINAPI PutRestoredPacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred put packet operations

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.packet1 - A pointer to the driver packet
    	p->handle1 - The queue

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for PutRestoredPacket");

	HRESULT hr = ACPutRestoredPacket(p->handle1, p->u1.packet1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACPutRestoredPacket failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcPutRemotePacket(
    HANDLE hQueue,
    ULONG ulTag,
    CPacket * pkt,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to put the packet. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	handle - The queue handle
	ulTag - Remote packet tag
    pkt - The driver packet.
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACPutRemotePacket(hQueue, ulTag, pkt);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACPutRemotePacket failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.packet1 = pkt;
	pItem->handle1 = hQueue;
	pItem->u2.dword1 = ulTag;
	s_ACPutRemotePacketList.insert(pItem);
}


static void WINAPI PutRemotePacketDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred put packet operations

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.packet1 - A pointer to the driver packet
    	p->u2.dword1 - Remote packet tag
    	p->handle1 - The queue

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for PutRemotePacket");

	HRESULT hr = ACPutRemotePacket(p->handle1, p->u2.dword1, p->u1.packet1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACPutRemotePacket failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcPutPacketWithOverlapped(
    HANDLE hQueue,
    CPacket * pkt,
    LPOVERLAPPED lpOverlapped,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to put the packet. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	hQueue - The queue handle
    pkt - The driver packet.
    lpOverlapped - The operation overlapped structure
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACPutPacket(hQueue, pkt, lpOverlapped);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACPutPacket failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.packet1 = pkt;
	pItem->u3.overlapped1 = lpOverlapped;
	pItem->handle1 = hQueue;
	s_ACPutPacketOverlappedList.insert(pItem);
}


static void WINAPI PutPacketOverlappedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred put packet operations with overlapped

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.packet1 - A pointer to the driver packet
    	p->u3.overlapped1 - The overlapped
    	p->handle1 - The queue

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for PutPacket");

	HRESULT hr = ACPutPacket(p->handle1, p->u1.packet1, p->u3.overlapped1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACPutPacket failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcEndGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to do execute the command. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	hQueue - The queue handle
    g2r - The remote read context.
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACEndGetPacket2Remote(hQueue, g2r);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACEndGetPacket2Remote failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.pg2r = &g2r;
	pItem->handle1 = hQueue;
	s_ACEndGetPacket2RemoteList.insert(pItem);
}


static void WINAPI EndGetPacket2RemoteDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred ACEndGetPacket2Remote operations with overlapped

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.pg2r - A pointer to remote read context
    	p->handle1 - The queue

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for ACEndGetPacket2Remote");
	HRESULT hr = ACEndGetPacket2Remote(p->handle1, *p->u1.pg2r);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACEndGetPacket2Remote failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcArmPacketTimer(
    HANDLE hDevice,
    const VOID* pCookie,
    BOOL fTimeToBeReceived,
    ULONG ulDelay,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to do execute the command. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	hDevice - The driver handle
    pCookie - The packet context.
    fTimeToBeReceived
    ulDelay
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACArmPacketTimer(hDevice, pCookie, fTimeToBeReceived, ulDelay);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACArmPacketTimer failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.ptr1 = pCookie;
	pItem->handle1 = hDevice;
	pItem->u2.dword1 = fTimeToBeReceived;
	pItem->dword2 = ulDelay;
	s_ACArmPacketTimerList.insert(pItem);
}


static void WINAPI ArmPacketTimerDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred ACArmPacketTimer operations with overlapped

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.ptr1 - A pointer to packet context
    	p->handle1 - The handle to the device
    	p->u2.dword1 - Time to be received flag
    	p->dword2 - Delay

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for ACArmPacketTimer");
	HRESULT hr = ACArmPacketTimer(p->handle1, p->u1.ptr1, p->u2.dword1, p->dword2);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACArmPacketTimer failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcAckingCompleted(
    HANDLE hDevice,
    const VOID* pCookie,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to execute the operation. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	hDevice - The driver handle
    pCookie - The driver packet.
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACAckingCompleted(hDevice, pCookie);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACAckingCompleted failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.ptr1 = pCookie;
	pItem->handle1 = hDevice;
	s_ACAckingCompletedList.insert(pItem);
}


static void WINAPI AckingCompletedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred put packet operations

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.ptr1 - A pointer to the driver packet
    	p->handle1 - The driver handle

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for ACAckingCompleted");

	HRESULT hr = ACAckingCompleted(p->handle1, p->u1.ptr1);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACAckingCompleted failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcStorageCompleted(
    HANDLE hDevice,
    ULONG count,
    VOID* const* pCookieList,
    HRESULT result,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to execute the operation. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	hDevice - The driver handle
	count - Number of packets in packet list
    pCookieList - Packet list
    result - The storage operation result
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	ASSERT(("We excpect to indicate completion for at least one packet.", count > 0));
	HRESULT hr = ACStorageCompleted(hDevice, count, pCookieList, result);
	if (SUCCEEDED(hr))
	{
		g_pDeferredItemsPool->UnreserveItems(count);
		return;
	}

	TrERROR(GENERAL, "ACStorageCompleted failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	g_pDeferredItemsPool->UnreserveItems(count-1);
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.pptr1 = pCookieList;
	pItem->handle1 = hDevice;
	pItem->u2.dword1 = count;
	pItem->dword2 = result;
	s_ACStorageCompletedList.insert(pItem);
}


static void WINAPI StorageCompletedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred put packet operations

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.pptr1 - A pointer to the driver packet list
    	p->handle1 - The driver handle
    	p->u2.dword1 - The number of packets in the list
    	p->dword2 - The storage status result

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for ACStorageCompleted");

	HRESULT hr = ACStorageCompleted(p->handle1, p->u2.dword1, p->u1.pptr1, p->dword2);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACStorageCompleted failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


void
QmAcCreatePacketCompleted(
    HANDLE    hDevice,
    CPacket * pOriginalDriverPacket,
    CPacket * pNewDriverPacket,
    HRESULT   result,
    USHORT    ack,
    DeferOnFailureEnum DeferOnFailure
    )
/*++

Routine Description:
	Call the driver to execute the operation. If the call fails and
	deferred execution is requested, schedule a deferred execution
	
Arguments:
	hDevice - The driver handle
	pOriginalDriverPacket - The packet received in the service routine
    pNewDriverPacket - The new packet
    result - The creation status
    ack - Is ack required
    DeferOnFailure - Indicates wether to defer execution when the call fails.

Returned Value:
    None. The function throws an exception in case of failure.

--*/
{
	HRESULT hr = ACCreatePacketCompleted(hDevice,
										 pOriginalDriverPacket,
										 pNewDriverPacket,
										 result,
										 ack);
	if (SUCCEEDED(hr))
	{
		if (NULL != pNewDriverPacket)
		{
			g_pDeferredItemsPool->UnreserveItems(2);
			return;
		}

		g_pDeferredItemsPool->UnreserveItems(1);
		return;
	}

	TrERROR(GENERAL, "ACCreatePacketCompleted failed hr=%!hresult!",hr);
	if (eDoNotDeferOnFailure == DeferOnFailure)
	{
		throw bad_hresult(hr);
	}

	//
	// Defer the exectution
	//
	if (NULL != pNewDriverPacket)
	{
		g_pDeferredItemsPool->UnreserveItems(1);
	}
	
	CDeferredItemsPool::CDeferredItem *pItem = g_pDeferredItemsPool->GetItem();		
	pItem->u1.packet1 = pOriginalDriverPacket;
	pItem->u3.packet2 = pNewDriverPacket;
	pItem->handle1 = hDevice;
	pItem->u2.dword1 = result;
	pItem->dword2 = ack;
	s_ACCreatePacketCompletedList.insert(pItem);
}


static void WINAPI CreatePacketCompletedDeferredExecutionRoutine(CDeferredItemsPool::CDeferredItem* p)
/*++

Routine Description:
	This routine is used for deferred put packet operations

	Following the operation, the deferred item is released

Arguments:
    p - A deferred execution item which holds the following information:
    	p->u1.packet1 - A pointer to the original driver packet
    	p->u3.packet2 - A pointer to the new driver packet
    	p->handle1 - The driver handle
    	p->u2.dword1 - The creation operation result
    	p->dword2 - Is ack needed

Returned Value:
    The function throws an exception if the operation did not succeed

--*/
{
    TrTRACE(GENERAL, "Deferred execution for ACCreatePacketCompleted");

	HRESULT hr = ACCreatePacketCompleted(p->handle1,
										 p->u1.packet1,
										 p->u3.packet2,
										 p->u2.dword1,
										 p->dword2);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACCreatePacketCompleted failed hr=%!hresult!",hr);
		throw bad_hresult(hr);
	}

	g_pDeferredItemsPool->ReturnItem(p);
}


HRESULT
QmAcAllocatePacket(
    HANDLE handle,
    ACPoolType pt,
    DWORD dwSize,
    CACPacketPtrs& PacketPtrs,
    BOOL fCheckMachineQuota
    )
/*++

Routine Description:
	1. Reserve a deferred execution item that will be used for the packet
	   in case that a deferred execution is needed
	2. Call the driver to allocate the packet.
	
Arguments:
    handle - A handle to the driver.
    pt - Pool type
    dwSize - Size of packet
    PacketPtr - The packet ptrs returned from the driver
    fCheckMachineQuota - If TRUE, a check for the machine quota will be done

Returned Value:
    The result from ACAllocatePacket

--*/
{
	//
	// Reserve an item for a possible deferred execution
	//
	try
	{
		g_pDeferredItemsPool->ReserveItems(1);
	}
	catch (const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to Reserve a deferred execution item for the packet, because of low resources.");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	//
	// Make the API call
	//
	HRESULT hr = ACAllocatePacket(handle,
								  pt,
								  dwSize,
								  PacketPtrs,
								  fCheckMachineQuota);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACAllocatePacket failed hr=%!hresult!",hr);
		g_pDeferredItemsPool->UnreserveItems(1);
	}

	return hr;
}


HRESULT
QmAcGetPacket(
    HANDLE hQueue,
    CACPacketPtrs& PacketPtrs,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:
	1. Reserve a deferred execution item that will be used for the packet
	   in case that a deferred execution is needed
	2. Call the driver to get a packet.
	
Arguments:
    hQueue - A handle to the queue.
    PacketPtr - The packet ptrs returned from the driver
    lpOverlapped - The overlapped structure to be passed to the completion port

Returned Value:
    The result from ACGetPacket

--*/
{
	//
	// Reserve an item for a possible deferred execution
	// And allocate an overlapped in order to wrap the overlapped call
	//
	P<CQmAcWrapOverlapped> pOvl;
	try
	{
		pOvl = new CQmAcWrapOverlapped(lpOverlapped);
		g_pDeferredItemsPool->ReserveItems(1);
	}
	catch (const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to allocate an overlapped for ACGetPacket.");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	//
	// Make the API call
	//
	HRESULT hr = ACGetPacket(hQueue,
							 PacketPtrs,
							 pOvl);
	if (SUCCEEDED(hr))
	{
		pOvl.detach();
		return hr;
	}

	TrERROR(GENERAL, "ACGetPacket failed hr=%!hresult!",hr);
	g_pDeferredItemsPool->UnreserveItems(1);

	return hr;
}


HRESULT
QmAcGetPacketByCookie(
    HANDLE hDriver,
    CACPacketPtrs * pPacketPtrs
    )
/*++

Routine Description:
	1. Reserve a deferred execution item that will be used for the packet
	   in case that a deferred execution is needed
	2. Call the driver to get a packet by cookie.
	
Arguments:
    hQueue - A handle to the queue.
    PacketPtr - The packet ptrs returned from the driver

Returned Value:
    The result from ACGetPacketByCookie

--*/
{
	//
	// Reserve an item for a possible deferred execution
	//
	try
	{
		g_pDeferredItemsPool->ReserveItems(1);
	}
	catch (const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to Reserve a deferred execution item for the packet, because of low resources.");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	//
	// Make the API call
	//
	HRESULT hr = ACGetPacketByCookie(hDriver,
							 		 pPacketPtrs);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACGetPacketByCookie failed hr=%!hresult!",hr);
		g_pDeferredItemsPool->UnreserveItems(1);
	}

	return hr;
}


HRESULT
QmAcBeginGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    CACPacketPtrs& packetPtrs,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:
	1. Reserve a deferred execution item that will be used for the packet
	   in case that a deferred execution is needed
	2. Call the driver to get a packet.
	
Arguments:
    hQueue - A handle to the queue.
    g2r - Contains the details of the required packet
    packetPtrs - Packet pointers to be filled
    lpOverlapped - Overlapped for the call

Returned Value:
    The result from ACBeginGetPacket2Remote

--*/
{
	//
	// Reserve an item for a possible deferred execution
	// And allocate an overlapped in order to wrap the overlapped call
	//
	P<CQmAcWrapOverlapped> pOvl;
	try
	{
		pOvl = new CQmAcWrapOverlapped(lpOverlapped);
		g_pDeferredItemsPool->ReserveItems(1);
	}
	catch (const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to allocate an overlapped for ACBeginGetPacket2Remote.");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	//
	// Make the API call
	//
	HRESULT hr = ACBeginGetPacket2Remote(
					hQueue,
					g2r,
					packetPtrs,
				    pOvl);
	if (SUCCEEDED(hr))
	{
		pOvl.detach();
		return hr;
	}

	TrERROR(GENERAL, "ACBeginGetPacket2Remote failed hr=%!hresult!",hr);
	g_pDeferredItemsPool->UnreserveItems(1);

	return hr;
}


HRESULT
QmAcSyncBeginGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    CACPacketPtrs& packetPtrs,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:
	1. Reserve a deferred execution item that will be used for the packet
	   in case that a deferred execution is needed
	2. Call the driver to get a packet.
	
Arguments:
    hQueue - A handle to the queue.
    g2r - Contains the details of the required packet
    packetPtrs - Packet pointers to be filled
    lpOverlapped - Overlapped for the call

Returned Value:
    The result from ACBeginGetPacket2Remote

--*/
{
	//
	// Reserve an item for a possible deferred execution
	//
	try
	{
		g_pDeferredItemsPool->ReserveItems(1);
	}
	catch (const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to Reserve a deferred execution item for the packet, because of low resources.");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	//
	// Make the API call
	//
	HRESULT hr = ACBeginGetPacket2Remote(
					hQueue,
					g2r,
					packetPtrs,
				    lpOverlapped);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "ACBeginGetPacket2Remote failed hr=%!hresult!",hr);
		g_pDeferredItemsPool->UnreserveItems(1);
	}

	return hr;
}


HRESULT
QmAcGetServiceRequest(
    HANDLE hDevice,
    CACRequest* pRequest,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:
	1. Reserve a deferred execution item that will be used for the packet
	   in case that a deferred execution is needed
	2. Call the driver to get the next service request.
	
Arguments:
    hDevice - A handle to the driver.
    pRequest - The request block filled by the driver
    lpOverlapped - The overlapped structure to be passed to the completion port

Returned Value:
    The result from ACGetServiceRequest

--*/
{
	//
	// Reserve an item for a possible deferred execution
	// And allocate an overlapped in order to wrap the overlapped call
	//
	P<CQmAcWrapOverlapped> pOvl;
	try
	{
		pOvl = new CQmAcWrapOverlapped(lpOverlapped);
		g_pDeferredItemsPool->ReserveItems(1);
	}
	catch (const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to allocate an overlapped for ACGetServiceRequest.");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	//
	// Make the API call
	//
	HRESULT hr = ACGetServiceRequest(hDevice,
							 		 pRequest,
								     pOvl);
	if (SUCCEEDED(hr))
	{
		pOvl.detach();
		return hr;
	}

	TrERROR(GENERAL, "ACGetServiceRequest failed hr=%!hresult!",hr);
	g_pDeferredItemsPool->UnreserveItems(1);

	return hr;
}


void QmAcInternalUnreserve(int nUnreserve)
/*++

Routine Description:
	The routine unreserves items in the deferred items pool.
	This is an internal helpre routine that is used by an auto release class to
	unreserve items in cases that we know that the allocation of items will not be released
	through one of the APIs.
	
Arguments:
    nUnreserve - The number of items to unreserve

Returned Value:
    none

--*/
{
	g_pDeferredItemsPool->UnreserveItems(nUnreserve);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qalappnotify.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    QalappNotify.cpp

Abstract:
    Notification functions from Qal.lib

Author:
    Gil Shafriri(gilsh)

--*/

#include "stdh.h"
#include <ev.h>
#include <fn.h>
#include <mqexception.h>
#include <mqsymbls.h>

#include "QalAppNotify.tmh"

void AppNotifyQalDirectoryMonitoringWin32Error(LPCWSTR pMappingDir, DWORD err)throw()
/*++

Routine Description:
	Called when win32 error accured while monitoring queue alias directory change.
	Report the problem to the event log.

Arguments:
	 err - Win32 error that happened.
	 pMappingDir - Mapping directory path.

Returned value:
	None

--*/
{
	WCHAR errstr[64];
	swprintf(errstr, L"%x", err);

	EvReport(QUEUE_ALIAS_DIR_MONITORING_WIN32_ERROR, 2, pMappingDir, errstr);
}


void AppNotifyQalDuplicateMappingError(LPCWSTR pAliasFormatName, LPCWSTR pFormatName) throw()
/*++

Routine Description:
	Called when alias mapped to a queue has another mapping to different queue.
	Report the problem to the event log.
	

Arguments:
	pAliasFormatName - Queue Alias.
	pFormatName - Queue Name.

Returned value:
	None

--*/
{

	EvReport(QUEUE_ALIAS_DUPLICATE_MAPPING_WARNING,	2,	pAliasFormatName, pFormatName);
}


void AppNotifyQalInvalidMappingFileError(LPCWSTR pMappingFileName) throw()
/*++

Routine Description:
	Called when mapping file was parsed by the xml parser but the mapping format is invalid.
	Report the problem to the event log.
		

Arguments:
	pMappingFileName - Mapping file name.
	
	
Returned value:
	None

--*/
{
	EvReport(QUEUE_ALIAS_INVALID_MAPPING_FILE, 1, pMappingFileName );
}


void AppNotifyQalWin32FileError(LPCWSTR pFileName, DWORD err)throw()
/*++

Routine Description:
	Called when got win32 error when reading queue alias mapping file.
	Report the problem to the event log.

	

Arguments:
	pFileName - Name of the file that had the error.
	err - The error code.

Returned value:
	None

--*/
{
	WCHAR errstr[64];
	swprintf(errstr, L"%x", err);

	EvReport(QUEUE_ALIAS_WIN32_FILE_ERROR, 2, pFileName, errstr	);
	
}



bool AppNotifyQalMappingFound(LPCWSTR pAliasFormatName, LPCWSTR pFormatName)throw()
/*++

Routine Description:
	Called when new mapping from alias to queue found  by qal library.


Arguments:
	pAliasFormatName - Alias name .
	pFormatName - The error code.

Returned value:
	true is return if the mapping is valid and should be inserted into the qal mapping in memory.
	false otherwise.
	
Note:	
	The function implementation converts the queue name and alias to cononical
	url form by replacing L"\" by L'/'. For example the queue name , Http://host\msmq\private$\q  converted to Http://host/msmq/private$/q

--*/
{
	bool fSuccess = FnAbsoluteMsmqUrlCanonization(pFormatName);
	if(!fSuccess)
	{
		EvReport(QUEUE_ALIAS_INVALID_QUEUE_NAME, 2, pAliasFormatName,	pFormatName );
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmacapi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmacapi.h

Abstract:

    Wrappers for QM to AC calls.

Author:

    Nir Ben-Zvi  (nirb)


--*/

#pragma once

#ifndef __QMACAPI__
#define __QMACAPI__

#include "acdef.h"
#include "ex.h"
#include <SmartHandle.h>

enum DeferOnFailureEnum
{
	eDoNotDeferOnFailure=0,
	eDeferOnFailure
};


void 
QmAcFreePacket(
    CPacket * pkt,
	USHORT usClass,
	DeferOnFailureEnum bDeferOnFailure
    );


void
QmAcFreePacket1(
    HANDLE handle,
    const VOID* pCookie,
    USHORT usClass,
	DeferOnFailureEnum bDeferOnFailure
    );


void
QmAcFreePacket2(
    HANDLE handle,
    const VOID* pCookie,
    USHORT usClass,
	DeferOnFailureEnum bDeferOnFailure
    );


void
QmAcPutPacket(
    HANDLE hQueue,
    CPacket * pkt,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcPutRestoredPacket(
    HANDLE hQueue,
    CPacket * pkt,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcPutRemotePacket(
    HANDLE hQueue,
    ULONG ulTag,
    CPacket * pkt,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcPutPacketWithOverlapped(
    HANDLE hQueue,
    CPacket * pkt,
    LPOVERLAPPED lpOverlapped,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcEndGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcArmPacketTimer(
    HANDLE hDevice,
    const VOID* pCookie,
    BOOL fTimeToBeReceived,
    ULONG ulDelay,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcAckingCompleted(
    HANDLE hDevice,
    const VOID* pCookie,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcStorageCompleted(
    HANDLE hDevice,
    ULONG count,
    VOID* const* pCookieList,
    HRESULT result,
    DeferOnFailureEnum DeferOnFailure
    );


void
QmAcCreatePacketCompleted(
    HANDLE    hDevice,
    CPacket * pOriginalDriverPacket,
    CPacket * pNewDriverPacket,
    HRESULT   result,
    USHORT    ack,
    DeferOnFailureEnum DeferOnFailure
    );


HRESULT
QmAcAllocatePacket(
    HANDLE handle,
    ACPoolType pt,
    DWORD dwSize,
    CACPacketPtrs& PacketPtrs,
    BOOL fCheckMachineQuota = TRUE
    );


HRESULT
QmAcGetPacket(
    HANDLE hQueue,
    CACPacketPtrs& PacketPtrs,
    LPOVERLAPPED lpOverlapped
    );


HRESULT
QmAcGetPacketByCookie(
    HANDLE hDriver,
    CACPacketPtrs * pPacketPtrs
    );


HRESULT
QmAcBeginGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    CACPacketPtrs& packetPtrs,
    LPOVERLAPPED lpOverlapped
    );


HRESULT
QmAcSyncBeginGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    CACPacketPtrs& packetPtrs,
    LPOVERLAPPED lpOverlapped
    );


HRESULT
QmAcGetServiceRequest(
    HANDLE hDevice,
    CACRequest* pRequest,
    LPOVERLAPPED lpOverlapped
    );


//
// auto handle to api deferred execution pool reservations.
//
void QmAcInternalUnreserve(int nUnreserve);
struct auto_DeferredPoolReservation_traits {
	static int invalid() { return 0; }
	static void free(int nNumberOfItemsToUnreserve) { QmAcInternalUnreserve(nNumberOfItemsToUnreserve); }
};
typedef auto_resource<int, auto_DeferredPoolReservation_traits> auto_DeferredPoolReservation;



//
// Overlapped wrapper for all the GET PACKET functions that requires an overlapped.
// We use this to Unreserve items in case of failures.
//
class CQmAcWrapOverlapped : public EXOVERLAPPED
{
public:
    CQmAcWrapOverlapped(LPOVERLAPPED pCommandOvl) :
		        EXOVERLAPPED(QmAcCompleteRequest, QmAcCompleteRequest),
        		m_pOriginalOvl((EXOVERLAPPED *)pCommandOvl)
    {
    }
    
	EXOVERLAPPED *m_pOriginalOvl;

	static void	WINAPI QmAcCompleteRequest(EXOVERLAPPED* pov)
	{
		P<CQmAcWrapOverlapped>pQmAcOvl = static_cast<CQmAcWrapOverlapped *>(pov);
		EXOVERLAPPED *pOriginalOvl = pQmAcOvl->m_pOriginalOvl;
		HRESULT hr = pQmAcOvl->GetStatus();

		//
		// Unreserve on failure
		//
		if (FAILED(hr))
		{
			QmAcInternalUnreserve(1);
		}

		//
		// Call the original overlapped routine
		//
		pOriginalOvl->CompleteRequest(hr);
	}

};

//
// Deprecate functions wrapped by qmacapi.cpp
//
#ifndef QMACAPI_CPP
#pragma deprecated(ACFreePacket)
#pragma deprecated(ACFreePacket1)
#pragma deprecated(ACFreePacket2)
#pragma deprecated(ACPutPacket)
#pragma deprecated(ACPutRemotePacket)
#pragma deprecated(ACEndGetPacket2Remote)
#pragma deprecated(ACArmPacketTimer)
#pragma deprecated(ACAckingCompleted)
#pragma deprecated(ACStorageCompleted)
#pragma deprecated(ACCreatePacketCompleted)
#endif  // QMACAPI_CPP

#endif //__QMACAPI__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmglbobj.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    QMGlbObj.cpp

Abstract:

    Declaration of Global Instances of the QM.
    They are put in one place to ensure the order their constructors take place.

Author:

    Lior Moshaiov (LiorM)

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "sessmgr.h"
#include "perf.h"
#include "perfdata.h"
#include "admin.h"
#include "qmnotify.h"

#include "qmglbobj.tmh"

static WCHAR *s_FN=L"qmglbobj";

CSessionMgr     SessionMgr;
CQueueMgr       QueueMgr;
CAdmin          Admin;
CNotify         g_NotificationHandler;


CContextMap g_map_QM_dwQMContext;  //dwQMContext of rpc_xxx routines

#ifdef _WIN64
CContextMap g_map_QM_HLQS;         //HLQS handle for enumeration of private queues from admin, passed inside an MSMQ message as 32 bit value
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmds.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

  qmds.h

Abstract:

    Definition of DS function table.

Author:

    Lior Moshaiov (LiorM)


--*/

#ifndef __QMDS_H__
#define __QMDS_H__

//********************************************************************
//                           A P I
//********************************************************************


void MQDSClientInitializationCheck(void);

void APIENTRY QMLookForOnlineDS(void);

BOOL QMOneTimeInit(VOID);
void ScheduleOnlineInitialization();

#endif // __QMDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmcommnd.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    qmcommnd.h

Abstract:

    qmcommnd declarations

Author:

    Ilan Herbst (ilanh) 2-Jan-2002

--*/

#ifndef _QMCOMMND_H_
#define _QMCOMMND_H_


bool
IsValidAccessMode(
	const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    DWORD dwShareMode
	);


HRESULT
OpenQueueInternal(
    QUEUE_FORMAT*   pQueueFormat,
    DWORD           dwCallingProcessID,
    DWORD           dwDesiredAccess,
    DWORD           dwShareMode,
    LPWSTR*         lplpRemoteQueueName,
    HANDLE*         phQueue,
	bool			fFromDepClient,
    OUT CQueue**    ppLocalQueue
    );


#endif // _QMCOMMND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmds.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    InitFRS.cpp

Abstract:

    Implementation of Routing Decision class.

Author:

    Lior Moshaiov (LiorM)

--*/


#include "stdh.h"
#include "qmds.h"
#include "session.h"
#include "cqmgr.h"
#include "cqueue.h"
#include "_rstrct.h"
#include "qmres.h"
#include "mqdsdef.h"
#include "qmsecutl.h"
#include "qmthrd.h"
#include "qmutil.h"
#include "xact.h"
#include "xactrm.h"
#include "regqueue.h"
#include "_mqrpc.h"
#include "qm2qm.h"
#include "qmrpcsrv.h"
#include <dsgetdc.h>
#include <dsrole.h>
#include <uniansi.h>
#include "safeboot.h"
#include "setup.h"
#include <mqnames.h>
#include "ad.h"

#include "httpAccept.h"
#include "sessmgr.h"
#include "joinstat.h"
#include <mqexception.h>
#include "Qmp.h"
#include "mqsec.h"

#include "qmds.tmh"


extern CQGroup* g_pgroupNotValidated;
extern CSessionMgr       SessionMgr;
extern LPTSTR            g_szMachineName;
extern AP<WCHAR>		 g_szComputerDnsName;
extern CQGroup*          g_pgroupNonactive;
extern DWORD             g_dwOperatingSystem;
extern BOOL              g_fWorkGroupInstallation;

extern void WINAPI TimeToUpdateDsServerList(CTimer* pTimer);

static void WINAPI TimeToLookForOnlineDS(CTimer* pTimer);
static void WINAPI TimeToUpdateDS(CTimer* pTimer);
static void WINAPI TimeToOnlineInitialization(CTimer* pTimer);
static void WINAPI TimeToClientInitializationCheckDeferred(CTimer* pTimer);

static CTimer s_LookForOnlineDSTimer(TimeToLookForOnlineDS);
static CTimer s_UpdateDSTimer(TimeToUpdateDS);
static CTimer s_OnlineInitializationTimer(TimeToOnlineInitialization);
static CTimer s_UpdateCacheTimer(TimeToPublicCacheUpdate);
static CTimer s_UpdateDSSeverListTimer(TimeToUpdateDsServerList);
static CTimer s_DeferredInitTimer(TimeToClientInitializationCheckDeferred);

static LONG s_fLookForOnlineDSTimerScheduled = FALSE;

static WCHAR *s_FN=L"qmds";


/*====================================================

UpdateMachineSecurityCache

Arguments:

Return Value:

=====================================================*/

void
UpdateMachineSecurityCache(
	void
	)
{
    const VOID *pSD;
    DWORD dwSDSize;

    if (! QueueMgr.CanAccessDS())
    {
        LogHR(MQ_ERROR_NO_DS, s_FN, 10);
    	TrERROR(GENERAL, "Failed to update machine security cache. Can't access DS");
    	throw bad_hresult(MQ_ERROR_NO_DS);
    }

    CQMDSSecureableObject DSMacSec(eMACHINE,  QueueMgr.GetQMGuid(), TRUE, TRUE, NULL);

    pSD = DSMacSec.GetSDPtr();
    if (!pSD)
    {
        LogHR(MQ_ERROR, s_FN, 20);
        TrERROR(GENERAL, "Failed to update machine security cache. Failed to retreive security descriptor");
    	throw bad_hresult(MQ_ERROR);

    }

    dwSDSize = GetSecurityDescriptorLength(const_cast<PSECURITY_DESCRIPTOR>(pSD));

    HRESULT hr = SetMachineSecurityCache(pSD, dwSDSize);
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 30);
        TrERROR(GENERAL, "Failed to update machine security cache. Failed to set the new machine security. %!hresult!", hr);
    	throw bad_hresult(hr);
        
    }

    //
    // cache machine account sid in registry.
    //
    PROPID propidSid = PROPID_COM_SID;
    MQPROPVARIANT   PropVarSid;
    PropVarSid.vt = VT_NULL;
    PropVarSid.blob.pBlobData = NULL;
    AP<BYTE> pSid;

    if (g_szComputerDnsName != NULL)
    {
        hr = ADGetObjectProperties(
                        eCOMPUTER,
                        NULL,   // pwcsDomainController
						false,	// fServerName
                        g_szComputerDnsName,
                        1,
                        &propidSid,
                        &PropVarSid
                        );
    }
    else
    {
        hr = MQ_ERROR;
    }
    if (FAILED(hr))
    {
        hr = ADGetObjectProperties(
					eCOMPUTER,
					NULL,   // pwcsDomainController
					false,	// fServerName
					g_szMachineName,
					1,
					&propidSid,
					&PropVarSid
					);
    }
    if (SUCCEEDED(hr))
    {
        pSid = PropVarSid.blob.pBlobData;
        ASSERT(IsValidSid(pSid));

        DWORD  dwSize = GetLengthSid(pSid);
        DWORD  dwType = REG_BINARY;

        LONG rc = SetFalconKeyValue( 
						MACHINE_ACCOUNT_REGNAME,
						&dwType,
						pSid,
						&dwSize
						);
        ASSERT(rc == ERROR_SUCCESS);
        if (rc != ERROR_SUCCESS)
        {
            hr = MQ_ERROR;
        }
        else
        {
			MQSec_UpdateLocalMachineSid(pSid);
        }
    }
    else if (hr == MQ_ERROR_ILLEGAL_PROPID)
    {
        //
        // We queries a MSMQ1.0 server. It can't answer us with this.
        //
        hr = MQ_OK;
    }

	if (FAILED(hr))
	{
        LogHR(hr, s_FN, 40);
        TrERROR(GENERAL, "Failed to update machine security cache.  %!hresult!", hr);
    	throw bad_hresult(hr);
	}
}

static bool CheckQMGuid()
{
    //
    // Check QM Guid consistency
    //
    PROPID propId[1];
    PROPVARIANT var[1];

    propId[0] = PROPID_QM_PATHNAME;
    var[0].vt = VT_NULL;
	
    HRESULT rc = ADGetObjectPropertiesGuid(
						eMACHINE,
						NULL,   // pwcsDomainController
						false,	// fServerName
						QueueMgr.GetQMGuid(),
						1,
						propId,
						var
						);

    if (FAILED(rc))
    {
	    TrERROR(DS, "Failed to get msmqConfiguration object properities Error: 0x%x", rc);
        return false;
    }

    AP<WCHAR> pCleanup = var[0].pwszVal;
    if (wcscmp(var[0].pwszVal, g_szMachineName) == 0)
        return true;

    static BOOL s_fAlreadyFailedHere = FALSE ;
    if (s_fAlreadyFailedHere)
        return false;

    s_fAlreadyFailedHere = TRUE ;

    EvReport(EVENT_ERROR_INCONSISTENT_QM_ID, 1, var[0].pwszVal);

    return false;
}

//+-------------------------------------------
//
//   void  TimeToLookForOnlineDS()
//
//+-------------------------------------------

static
void
WINAPI
TimeToLookForOnlineDS(
    CTimer* pTimer
    )
{
    ASSERT(pTimer == &s_LookForOnlineDSTimer);
    DBG_USED(pTimer);

    if (QueueMgr.IsDSOnline())
    {
        LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, FALSE);
        ASSERT(fAlreadySchedule);
		DBG_USED(fAlreadySchedule);

        //
        // We're already online. Do nothing.
        //
        return ;
    }

    //
    // Here we're called from the timer scheduling thread.
    //
    // SP4 - bug# 2962 : check if access to DS is allowed. This feature is used
    //                   support Administrative offline DS.
    //                       Uri Habusha (urih), 17-Jun-98
    //
    if (!QueueMgr.IsConnected() || !CheckQMGuid())
    {
        LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, TRUE);
        ASSERT(fAlreadySchedule);
		DBG_USED(fAlreadySchedule);

        CQueueMgr::SetDSOnline(FALSE);
        ExSetTimer(&s_LookForOnlineDSTimer, CTimeDuration::FromMilliSeconds(60000));
        return;
    }

    LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, FALSE);
    ASSERT(fAlreadySchedule);
	DBG_USED(fAlreadySchedule);
    CQueueMgr::SetDSOnline(TRUE);
    try
    {
    	QueueMgr.ValidateOpenedQueues();
    	QueueMgr.ValidateMachineProperties();
    }
    catch(const exception&)
    {
    	TrERROR(GENERAL, "Failed to validate open queue while bringing the DS online.");
    	
        CQueueMgr::SetDSOnline(FALSE);
   		LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, TRUE);
        if (!fAlreadySchedule)
        {
        	ExSetTimer(&s_LookForOnlineDSTimer, CTimeDuration::FromMilliSeconds(60000));
        }
        return;
    }
}

/*====================================================

HRESULT  QMLookForOnlineDS()

Description:

Return Value:

=====================================================*/

void APIENTRY QMLookForOnlineDS(void)
{
    //
    // Called from DS to start looking for an online MQIS server.
    //
    if (!QueueMgr.IsDSOnline())
    {
        //
        // I'm already offline so do nothing. There is already
        // a timer for this. (at least it should be).
        //
        return ;
    }

    LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, TRUE);
    if (fAlreadySchedule)
        return;

    CQueueMgr::SetDSOnline(FALSE);
    ExSetTimer(&s_LookForOnlineDSTimer, CTimeDuration::FromMilliSeconds(60000));
}


void QMpRegisterIPNotification();
VOID WINAPI HandleIPAddressListChange(EXOVERLAPPED* pov);

static SOCKET s_Socket = NULL;
EXOVERLAPPED s_pOverlapped(HandleIPAddressListChange, HandleIPAddressListChange);



VOID 
WINAPI 
HandleIPAddressListChange(
	EXOVERLAPPED* //pov
	)
{
	TrTRACE(GENERAL, "HandleIPAddressListChange() invoked.");

#ifdef _DEBUG

	struct hostent* HostEnt = gethostbyname(NULL);

    for(int i = 0; (HostEnt != NULL) && (HostEnt->h_addr_list[i] != NULL); i++)
    {
        TrTRACE(GENERAL, "gethostbyname() IP address %-2d ... [%hs]", i, 
            inet_ntoa(*((in_addr*)HostEnt->h_addr_list[i])));
    }

	char BufOut[1024];
	DWORD BytesRead = 0;

	int Result = WSAIoctl(
					s_Socket,                                 
					SIO_ADDRESS_LIST_QUERY,                         
					NULL,                       
					0,                         
					BufOut,                       
					sizeof(BufOut),                       
					&BytesRead,                     
					NULL,                         
					NULL 
					);
	
	if(Result == SOCKET_ERROR)
	{		
		TrERROR(GENERAL, "WSAIoctl() failed: %d\n", WSAGetLastError());
	}
	else
	{
		SOCKET_ADDRESS_LIST* slist = (SOCKET_ADDRESS_LIST *)BufOut;

	    for(i = 0; i < slist->iAddressCount; i++)
	    {
	        TrTRACE(GENERAL, "WSAioctl() IP address %-2d ... [%hs]\n", i, 
	            inet_ntoa(((SOCKADDR_IN *)slist->Address[i].lpSockaddr)->sin_addr));
	    }
	}

#endif

	QMpRegisterIPNotification();
}



void QMpCreateIPNotificationSocket()
{
	ASSERT(s_Socket == NULL);

	s_Socket = WSASocket(
					AF_INET,
					SOCK_RAW,
					IPPROTO_IP,
					NULL, 
					0,
					WSA_FLAG_OVERLAPPED
					);

	if(s_Socket == INVALID_SOCKET) 
	{
		TrERROR(GENERAL, "WSASocket() failed: %d\n", WSAGetLastError());
		LogIllegalPoint(s_FN, 100);
		throw exception();
	}

	ExAttachHandle((HANDLE)s_Socket);
}



void QMpRegisterIPNotification()
/*++

Routine Description:
    Registers a notification on a change in the IP address list.
	This change usually occurs when a network cable is plugged or unplugged.
	Thus this mechanism is used to notify network connectivity changes.

--*/
{
	ASSERT(s_Socket != NULL);

	DWORD BytesRead = 0;

	int Result = WSAIoctl(
					s_Socket,                                     
					SIO_ADDRESS_LIST_CHANGE,                     
					NULL,                     
					0,                           
					NULL,                    
					0,                         
					&BytesRead,               
					&s_pOverlapped,                         
					NULL 
					);

	if((Result == SOCKET_ERROR) && (WSAGetLastError() != WSA_IO_PENDING))
	{
		TrERROR(GENERAL, "WSAIoctl() failed: %d\n", WSAGetLastError());
		LogIllegalPoint(s_FN, 305);
		throw exception();
	}
}


BOOL
QMOneTimeInit(
    VOID
    )
/*++

Routine Description:
    Start session listener, RPC listener and not active group listener

Arguments:
    None

Returned Value:
    TRUE if initialization succeeded

--*/
{
	//
	// Check if in lockdown state.
	//
	QueueMgr.SetLockdown();

	//
	// Check if we are allowed to create public queues on behalf of the RT
	//
	QueueMgr.SetPublicQueueCreationFlag();

	//
	// Begin to accept incoming sesions
	//
	if(!QueueMgr.GetLockdown())
	{
		SessionMgr.BeginAccept();
		TrTRACE(GENERAL, "QM began to accept incoming sessions");

		//
		// bind multicast address
		//

		bool f = QmpInitMulticastListen();
		if (!f)
		{
			return LogBOOL(FALSE, s_FN, 304);
		}
	}

    //
    // Get packet for nonactive groups
    //
    QMOV_ACGetMsg* pov = new QMOV_ACGetMsg(
								GetNonactiveMessageSucceeded, 
								GetNonactiveMessageFailed
								);
    QmpGetPacketMustSucceed(g_pgroupNonactive->GetGroupHandle(), pov);

    RPC_STATUS status = InitializeRpcServer(QueueMgr.GetLockdown()) ;
    if (status != RPC_S_OK)
    {
        LogRPCStatus(status, s_FN, 63);
        return FALSE ;
    }

    try
    {
        IntializeHttpRpc();
    }
    catch(const exception&)
    {
    	LogIllegalPoint(s_FN, 306);
        return FALSE;
    }

    try
    {
		QMpCreateIPNotificationSocket();
        QMpRegisterIPNotification();
    }
    catch(const exception&)
    {
    	LogIllegalPoint(s_FN, 307);
        return FALSE;
    }

    return TRUE;
}


static bool GuidContained(const CACLSID& a, const GUID& g)
{
	for (DWORD i=0; i < a.cElems; ++i)
	{
		if (a.pElems[i] == g)
			return true;
	}

	return false;
}

static bool GuidListEqual(const CACLSID& a, const CACLSID& b)
{
    if(a.cElems != b.cElems)
        return false;

    for(DWORD i = 0; i < a.cElems; i++) 
    {
        if(!GuidContained(b, a.pElems[i]))
            return false;
    }

    return true;
}

static bool s_fInformedSiteResolutionFailure = false;

static void UpdateMachineSites()
/*++

Routine Description:
    Update the QM list of sites in the Active Directory

Arguments:
    None

Returned Value:
    MQ_OK on successful update

--*/
{
	TrTRACE(GENERAL, "QM Updates machine sites in DS");

    //
    // If not running in AD environemnt, bail out. We do not track
    // machine sites in other environemnts.
    //
    if(ADGetEnterprise() != eAD)
        return;

    //
    // Get the computer sites as seen by Active Directory
    //
    DWORD nSites;
    AP<GUID> pSites;
    HRESULT hr = ADGetComputerSites(0, &nSites, &pSites);


    if (hr == MQDS_INFORMATION_SITE_NOT_RESOLVED)
    {
    	if (!s_fInformedSiteResolutionFailure)
	    {
	        // 
	        // failed to resolved the computer sites, inform the user and continue
	        //
	        EvReport(EVENT_NO_SITE_RESOLUTION);
	        s_fInformedSiteResolutionFailure = true;
	    }
    	return;
    }

    if (FAILED(hr))
    {
    	
        LogHR(hr, s_FN, 653);
        TrERROR(GENERAL, "Failed to resolve the computer sites from AD. %!hresult!", hr);
        throw bad_hresult(hr);
    }

    s_fInformedSiteResolutionFailure = false;

    //
    // Set the first site to registry
    //
    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(GUID);
    LONG rc = SetFalconKeyValue(
                MSMQ_SITEID_REGNAME,
                &dwType,
                pSites.get(),
                &dwSize
                );

    ASSERT(rc == ERROR_SUCCESS);
	DBG_USED(rc);

    //
    // Get current computer sites as registered in msmqConfiguration object
    //
    PROPID aProp[] = {PROPID_QM_SITE_IDS};
    PROPVARIANT aVar[TABLE_SIZE(aProp)] = {{VT_NULL,0,0,0,0}};
   

    hr = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,   // pwcsDomainController
					false,	// fServerName
                    QueueMgr.GetQMGuid(),
                    TABLE_SIZE(aProp),
                    aProp,
                    aVar
                    );

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 675);
        TrERROR(GENERAL, "Failed to resolve the computer sites as registeered in msmqConfiguration object. %!hresult!", hr);
        throw bad_hresult(hr);
    }

    //
    // Set auto pointer to free the list of sites
    //
    AP<GUID> pOldSites = aVar[0].cauuid.pElems;


    //
    // Allocate enough memory for the composed site list
    // and copy the machine sites
    //
    AP<GUID> pNewSites = new GUID[nSites + aVar[0].cauuid.cElems];
    memcpy(pNewSites, pSites, nSites * sizeof(GUID));
    

    //
    // Extract all foreign sites for sites in DS
    // and compose machine + foreign site IDs
    //
    for(DWORD i = 0; i < aVar[0].cauuid.cElems; i++)
    {
        //
        // Find out if this site is foreign 
        //
        // BUGBUG - to improve and call local routing cache
        // instead of accessing the DS
        //      ronith june-00
        //
        PROPID propSite[]= {PROPID_S_FOREIGN};
        MQPROPVARIANT varSite[TABLE_SIZE(propSite)] = {{VT_NULL,0,0,0,0}};
        HRESULT hr1 = ADGetObjectPropertiesGuid(
                            eSITE,
                            NULL,   // pwcsDomainController
							false,	// fServerName
                            &aVar[0].cauuid.pElems[i],
                            TABLE_SIZE(propSite),
                            propSite,
                            varSite
                            );
        if (FAILED(hr1))
        {
            break;
        }

        if (varSite[0].bVal == 1)
        {
            pNewSites[nSites++] = aVar[0].cauuid.pElems[i];
        }
    }

    //
    // Set the properites to update in Active Directory
    //
    PROPID propSite[]= {PROPID_QM_SITE_IDS};
    MQPROPVARIANT varSite[TABLE_SIZE(propSite)] = {{VT_CLSID|VT_VECTOR,0,0,0,0}};
	varSite[0].cauuid.pElems = pNewSites;
	varSite[0].cauuid.cElems = nSites;

    //
    // Compare to the sites in the DS, bail out if equal
    // The order of the GUIDs should not matter as the Active Directory
    // stores them in a different order than we set them below.
    //
    if(GuidListEqual(aVar[0].cauuid, varSite[0].cauuid))
        return;

    //
    // Update this machine sites in DS
    //
    hr = ADSetObjectPropertiesGuid(
                eMACHINE,
                NULL,       // pwcsDomainController
				false,		// fServerName
                QueueMgr.GetQMGuid(),
                TABLE_SIZE(propSite), 
                propSite, 
                varSite
                );

    if(FAILED(hr))
    {
        LogHR(hr, s_FN, 754);
        TrERROR(GENERAL, "Failed to update the machine sites in DS. %!hresult!", hr);
        throw bad_hresult(hr);
    }
}


static void DoUpdateDS()
{
    if(!QueueMgr.IsConnected())
    {
    	TrERROR(GENERAL, "Failed to update the machine sites in DS since the machine is unconected.");
        LogHR(MQ_ERROR, s_FN, 430);
        bad_hresult(MQ_ERROR);
    }

    UpdateMachineSites();
}


static DWORD GetDSUpdateInterval(bool fSuccess)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwUpdateInterval = 0;

    LONG rc = GetFalconKeyValue(
                fSuccess ? MSMQ_SITES_UPDATE_INTERVAL_REGNAME : MSMQ_DSUPDATE_INTERVAL_REGNAME,
                &dwType,
                &dwUpdateInterval,
                &dwSize
                );

    if(rc != ERROR_SUCCESS)
    {
        dwUpdateInterval = fSuccess ? MSMQ_DEFAULT_SITES_UPDATE_INTERVAL : MSMQ_DEFAULT_DSUPDATE_INTERVAL;
    }

    return dwUpdateInterval;
}


static void WINAPI TimeToUpdateDS(CTimer* pTimer)
{
    ASSERT(pTimer == &s_UpdateDSTimer);
    TrTRACE(GENERAL, "QM Updates machine sites in DS");

	bool fSucc = true;
	
	try
	{
    	DoUpdateDS();
	}
	catch(const exception&)
    {
        TrERROR(GENERAL, "Can't update machine information in DS. ");
        fSucc = false;
    }

    //
    // Update the DS information periodically even on successful update.
    // e.g., the machine subnets might get changed, affecting message routing.
    // subnet change does not require machine reboot, thus we need to update
    // machine sites periodically.
    // Zero value disables this periodic update.
    //
    DWORD dwUpdateInterval = GetDSUpdateInterval(fSucc);

    if(dwUpdateInterval == 0)
        return;

    ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(dwUpdateInterval));
}


static BOOL MachineAddressChanged(void)
{
    //
    // TODO: erezh, check if this function is needed anymore.
    //      check if an address has changed.
    //
    return FALSE;
}


static void OnlineInitialization()
/*++

Routine Description:
    Validate the QM ID with the one registered with the active directory.
    Validate all queues and update Active Directory with QM information.

Arguments:
    None

Returned Value:
    None

--*/
{
	HRESULT hr;
	
    if (g_fWorkGroupInstallation)
    {
        CQueueMgr::SetDSOnline(TRUE);
        return;
    }

    //
    //  Check machine parameters
    //
    if(!CheckQMGuid())
    {
        //
        // Failed to access Active Directory, schedule a latter retry
        //
        ExSetTimer(&s_OnlineInitializationTimer, CTimeDuration::FromMilliSeconds(120000));
        return;
    }

    TrTRACE(GENERAL, "Successful Online initialization");

    CQueueMgr::SetDSOnline(TRUE);


    //
    //  Now that we found a MQIS server we can validate all the
    //  opened and not validated queues.
    //  We always, (on servers too), recover before initializing MQIS
    //  so we always must validate.
    //
    try
    {
    	QueueMgr.ValidateOpenedQueues();
    	QueueMgr.ValidateMachineProperties();
        UpdateMachineSecurityCache();

	    DoUpdateDS();

        EvReport(EVENT_INFO_QM_ONLINE_WITH_DS);

	    //
	    //  Update the cache of local public queues.
	    //  Needed for off-line operation in the future.
	    //
	    ExSetTimer(&s_UpdateCacheTimer, CTimeDuration::FromMilliSeconds(10 * 1000));

	    //
	    //  Schedule   TimeToUpdateDsServerList
	    // We do this on servers too, because falcon apps need this info
	    // and because SQL may fail and then Falcon work as client QM.
	    //
	    ExSetTimer(&s_UpdateDSSeverListTimer, CTimeDuration::FromMilliSeconds(60 * 1000));

	    //
	    // Update the DS information periodically even on successful update.
	    // e.g., the machine subnets might get changed, affecting message routing.
	    // subnet change does not require machine reboot, thus we need to update
	    // machine sites periodically.
	    // Zero value disables this periodic update.
	    //
	    DWORD dwUpdateInterval = GetDSUpdateInterval(true);
	    if(dwUpdateInterval != 0)
	    {
	    	ExSetTimer(&s_UpdateDSTimer, CTimeDuration::FromMilliSeconds(dwUpdateInterval));
	    }
	    
	    return;
    }
    catch(const bad_hresult& e)
    {
    	hr = e.error();
    }
    catch(const bad_alloc&)
    {
    	hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    if (hr != MQ_ERROR_NO_DS)
    {
        static HRESULT l_LastResult = MQ_OK;
        if(l_LastResult != hr)
        {
            EvReportWithError(EVENT_ERROR_VALIDATE_MACHINE_PROPS, hr);
            l_LastResult = hr;
        }
    }

    //
    // MQIS server failed while we initialized. Try later.
    //
    TrERROR(GENERAL, "Failed to get online with AD retrying latter. Error: 0x%x", hr); 
    ExSetTimer(&s_OnlineInitializationTimer, CTimeDuration::FromMilliSeconds(10000));
}


static
void
WINAPI
TimeToOnlineInitialization(
    CTimer* /*pTimer*/
    )
/*++

Routine Description:
    The routine calls from the scheduler to Initialize the DS

Arguments:
    Pointer to Timer object

Returned Value:
    None

--*/
{
    OnlineInitialization();
}


static LONG s_Initialized = 0;
/*====================================================

  Function: MQDSClientInitializationCheck
    SP4. Postpone access to DS until it really required.
    When client is started MSMQ doesn't initialize the connection to the server. The DS
    connection is delayed until the application access the DS, open a queue or MSMQ
    receive a message.
    This fix comes to solve the McDonald's problem that causes dial-out each time MSMQ
    is started, even it doesn't execute any MSMQ operation.

  Arguments:
    None.

  Returned Value:
    None

=====================================================*/
void MQDSClientInitializationCheck(void)
{

    if (
        (QueueMgr.IsConnected()) &&
        (InterlockedExchange(&s_Initialized, 1) == 0)
        )
    {
        OnlineInitialization();
    }
}


static
void
WINAPI
TimeToClientInitializationCheckDeferred(
    CTimer* /*pTimer*/
    )
{
    MQDSClientInitializationCheck();
}


void ScheduleOnlineInitialization()
/*++

Routine Description:
    Control online access, either spawn another thread to get online with the
    active directory. Or mark state online and QM ID checkup and queue
    validation will be done on first access to the Active Directory.

Arguments:
    None

Returned Value:
    None

--*/
{
    ASSERT(!QueueMgr.IsDSOnline());

    //
    // SP4 - Bug# 2962 (QM accesses MQIS at start-up)
    // Postpone access to DS until it really required.
    // When MSMQ client is started it doesn't initialize the connection to the server.
    // The DS connection is delayed until the application access the DS, open a queue
    // or MSMQ receive a message.
    //

    //
    // Read Deferred Initalization Mode form Registry. Eiter the QM access
    // immediately the DS, or defer it to first needed access.
    //
    BOOL fDeferredInit = FALSE;
    READ_REG_DWORD(
        fDeferredInit,
        MSMQ_DEFERRED_INIT_REGNAME,
        &fDeferredInit
        );

    if (
        //
        // Deffered initialization is not required, so go ahead and connect to DS
        //
        !fDeferredInit ||
        
        //
        // One of the machine addresses (this might be obsolete)
        //
        MachineAddressChanged() ||
        
        //
        // There are queues that require validation, go and check them up.
        //
        !g_pgroupNotValidated->IsEmpty())
    {
        ExSetTimer(&s_DeferredInitTimer, CTimeDuration::FromMilliSeconds(0));
        return;
    }

    //
    // Set the DS status as online although the DS initialization was postponed
    // until first access. This is done to ensure that the QM tries to access
    // the DS even at the first time before the MSMQ client initialization
    // is completed and not return NO_DS immediately
    //                          Uri Habusha (urih), 17-Jun-98
    //
    CQueueMgr::SetDSOnline(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmcommnd.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qm.cpp

Abstract:

    This module implements QM commands that are issued by the RT using local RPC

Author:

    Lior Moshaiov (LiorM)

--*/

#include "stdh.h"

#include "ds.h"
#include "cqueue.h"
#include "cqmgr.h"
#include "_rstrct.h"
#include "cqpriv.h"
#include "qm2qm.h"
#include "qmrt.h"
#include "_mqini.h"
#include "_mqrpc.h"
#include "qmthrd.h"
#include "license.h"
#include "..\inc\version.h"
#include <mqsec.h>
#include "ad.h"
#include <fn.h>
#include "qmcommnd.h"
#include "qmrtopen.h"

#include "qmcommnd.tmh"

extern CQueueMgr    QueueMgr;


CCriticalSection qmcmd_cs;

static WCHAR *s_FN=L"qmcommnd";

extern CContextMap g_map_QM_dwQMContext;


/*==================================================================
    The routines below are called by RT using local RPC
    They use a critical section to synchronize
    that no more than one call to the QM will be served at a time.
====================================================================*/

#define MQ_VALID_ACCESS (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS | MQ_SEND_ACCESS | MQ_ADMIN_ACCESS)

bool
IsValidAccessMode(
	const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    DWORD dwShareMode
	)
{
	if (((dwAccess & ~MQ_VALID_ACCESS) != 0) ||
		((dwAccess & MQ_VALID_ACCESS) == 0))
	{
		//
		// Ilegal access mode bits are turned on.
		//
		TrERROR(RPC, "Ilegal access mode bits are turned on.");
		ASSERT_BENIGN(("Ilegal access mode bits are turned on.", 0));
		return false;
	}

	if ((dwAccess != MQ_SEND_ACCESS) && (dwAccess & MQ_SEND_ACCESS) )
	{
		//
		// Send and additional access modes were both requested and send access mode is exclusive.
		//
		TrERROR(RPC, "Send and additional access modes were both requested and send access mode is exclusive");
		ASSERT_BENIGN(("Send and additional access modes were both requested and send access mode is exclusive.", 0));
		return false;
	}

	if ((dwShareMode != MQ_DENY_RECEIVE_SHARE) && (dwShareMode != MQ_DENY_NONE))
	{
		//
		// Illegal share mode.
		//
		TrERROR(RPC, "Illegal share mode.");
		ASSERT_BENIGN(("Illegal share mode.", 0));
		return false;
	}
	
	if ((dwAccess & MQ_SEND_ACCESS) && (dwShareMode != MQ_DENY_NONE))
	{
		//
		// Send access uses only MQ_DENY_NONE mode.
		//
		TrERROR(RPC, "Send access uses only MQ_DENY_NONE mode.");
		ASSERT_BENIGN(("Send access uses only MQ_DENY_NONE mode.", 0));
		return false;
	}

	if ((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_MACHINE) && (dwAccess & MQ_SEND_ACCESS) )
	{
		//
		// Send access mode is requested for a machine format name.
		//
		TrERROR(RPC, "Send access mode is requested for a machine format name.");
		ASSERT_BENIGN(("Send access mode is requested for a machine format name.", 0));
		return false;
	}

	return true;
}


/*====================================================

OpenQueueInternal

Arguments:

Return Value:

=====================================================*/
HRESULT
OpenQueueInternal(
    QUEUE_FORMAT*   pQueueFormat,
    DWORD           dwCallingProcessID,
    DWORD           dwDesiredAccess,
    DWORD           dwShareMode,
    LPWSTR*         lplpRemoteQueueName,
    HANDLE*         phQueue,
	bool			fFromDepClient,
    OUT CQueue**    ppLocalQueue
    )
{
    ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DL);

    try
    {
        *phQueue = NULL;
        BOOL fRemoteReadServer = !lplpRemoteQueueName;
        HANDLE hQueue = NULL;
		BOOL fRemoteReturn = FALSE;

        HRESULT hr = QueueMgr.OpenQueue(
                            pQueueFormat,
                            dwCallingProcessID,
                            dwDesiredAccess,
                            dwShareMode,
                            ppLocalQueue,
                            lplpRemoteQueueName,
                            &hQueue,
                            &fRemoteReturn,
                            fRemoteReadServer
                            );

        if(!fRemoteReturn || fFromDepClient)
        {
        	//
        	// For Dep client still use the old mechanism
        	// Qm doesn't impersonate the user and perform 
        	// the open on his behalf. this will need to add delegation
        	// for dep client and will break prev dep clients that doesn't have delegation
        	//
            *phQueue = hQueue;
    		if (FAILED(hr))
    		{
    			TrERROR(GENERAL, "Failed to open a queue. %!hresult!", hr);   
    		}
            return hr;
        }

    	//
    	// The Queue is Remote Queue and we were not called from DepClient.
    	// Qm impersonate the RT user and call the remote Qm to open the remote queue
    	//

		ASSERT(lplpRemoteQueueName != NULL);
		return ImpersonateAndOpenRRQueue(
					pQueueFormat,
					dwCallingProcessID,
					dwDesiredAccess,
					dwShareMode,
					*lplpRemoteQueueName,
					phQueue
					);
    }
    catch(const bad_format_name&)
	{
		return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 29);
	}
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 30);
    }
} // OpenQueueInternal



/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMOpenQueue( 
    handle_t        hBind,	
	ULONG           nMqf,
    QUEUE_FORMAT    mqf[],
    DWORD           dwCallingProcessID,
    DWORD           dwDesiredAccess,
    DWORD           dwShareMode,
    DWORD __RPC_FAR *phQueue
    )
/*++

Routine Description:

    RPC server side of a local MQRT call.

Arguments:


Returned Value:

    Status.

--*/
{
	//
	// Check if local RPC
	//
	if(!mqrpcIsLocalCall(hBind))
	{
		TrERROR(RPC, "Failed to verify Local RPC");
		ASSERT_BENIGN(("Failed to verify Local RPC", 0));
		RpcRaiseException(RPC_S_ACCESS_DENIED);
	}
	
	if (phQueue == NULL)
	{
		TrERROR(RPC, "phQueue should not be NULL");
		ASSERT_BENIGN(("phQueue should not be NULL", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	unsigned long RPCClientPID = mqrpcGetLocalCallPID(hBind);
	if ((dwCallingProcessID == 0) || (RPCClientPID != dwCallingProcessID))
	{
		TrERROR(RPC, "Local RPC PID (%d) is not equal to client parameter (%d)", RPCClientPID, dwCallingProcessID);
		ASSERT_BENIGN(("Local RPC PID is not equal to client parameter", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	
    if(nMqf == 0)
    {
        TrERROR(GENERAL, "Bad MQF count. n=0");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    for(ULONG i = 0; i < nMqf; ++i)
    {
        if(!FnIsValidQueueFormat(&mqf[i]))
        {
            TrERROR(GENERAL, "Bad MQF parameter. n=%d index=%d", nMqf, i);
            return MQ_ERROR_INVALID_PARAMETER;
        }
    }

	if (!IsValidAccessMode(mqf, dwDesiredAccess, dwShareMode))
	{
		TrERROR(RPC, "Ilegal access mode bits are turned on.");
		RpcRaiseException(MQ_ERROR_UNSUPPORTED_ACCESS_MODE);
	}
	
    if (nMqf > 1 || mqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
	    if ((dwDesiredAccess & MQ_SEND_ACCESS) == 0)
	    {
			//
			// receive access mode is requested for a MQF format name.
			//
			TrERROR(RPC, "receive access mode is requested for a MQF/DL format name.");
			ASSERT_BENIGN(("receive access mode is requested for a MQF/DL format name.", 0));
			RpcRaiseException(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION);
	    }

        ASSERT(dwShareMode == 0);

        HANDLE hQueue;
        HRESULT hr;
        try
        {
            hr = QueueMgr.OpenMqf(
                     nMqf,
                     mqf,
                     dwCallingProcessID,
                     &hQueue
                     );
        }
        catch(const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 300);
        }
        catch (const bad_hresult& failure)
        {
            return LogHR(failure.error(), s_FN, 301);
        }
		catch(const bad_format_name&)
		{
			return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 302);
		}
        catch (const exception&)
        {
            ASSERT(("Need to know the real reason for failure here!", 0));
            return LogHR(MQ_ERROR_NO_DS, s_FN, 303);
        }

        ASSERT(phQueue != NULL);
        *phQueue = (DWORD) HANDLE_TO_DWORD(hQueue); // NT handles can be safely cast to 32 bits
        return LogHR(hr, s_FN, 304);
    }

	//
	// ISSUE-2002/01/03-ilanh - Still need to use lpRemoteQueueName.
	// OpenQueueInternal() relies on this pointer for calculating fRemoteReadServer.
	//
	AP<WCHAR> lpRemoteQueueName;
	HANDLE hQueue = 0;
    HRESULT hr = OpenQueueInternal(
					mqf,
					dwCallingProcessID,
					dwDesiredAccess,
					dwShareMode,
					&lpRemoteQueueName,
					&hQueue,
					false,	// fFromDepClient
					NULL 	// ppLocalQueue
					);

	*phQueue = (DWORD) HANDLE_TO_DWORD(hQueue);
	
	return hr;
} // R_QMOpenQueue


/*====================================================

QMCreateObjectInternal

Arguments:

Return Value:

=====================================================*/
/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMCreateObjectInternal( 
    handle_t                hBind,
    DWORD                   dwObjectType,
    LPCWSTR                 lpwcsPathName,
    DWORD                   SDSize,
    unsigned char __RPC_FAR *pSecurityDescriptor,
    DWORD                   cp,
    PROPID __RPC_FAR        aProp[  ],
    PROPVARIANT __RPC_FAR   apVar[  ]
    )
{
    if((SDSize != 0) && (pSecurityDescriptor == NULL))
    {
        TrERROR(GENERAL, "RPC (QMCreateObjectInternal) NULL SD");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    TrWARNING(GENERAL, " QMCreateObjectInternal. object path name : %ls", lpwcsPathName);

    switch (dwObjectType)
    {
        case MQQM_QUEUE:
            rc = g_QPrivate.QMCreatePrivateQueue(lpwcsPathName,
                                                 pSecurityDescriptor,
                                                 cp,
                                                 aProp,
                                                 apVar,
                                                 TRUE
                                                );
            break ;

        case MQQM_QUEUE_LOCAL_PRIVATE:
        {
        	//
            // See CreateDSObject() below for explanations.
            // Same behavior for private queues.
            //
            if (!mqrpcIsLocalCall(hBind))
            {
                //
                // reject calls from remote machines.
                //
                TrERROR(GENERAL, "Remote RPC, rejected");
                return MQ_ERROR_ACCESS_DENIED;
            }

            rc = g_QPrivate.QMCreatePrivateQueue(lpwcsPathName,
                                                 pSecurityDescriptor,
                                                 cp,
                                                 aProp,
                                                 apVar,
                                                 FALSE
                                                );
            break;
        }

        default:
            rc = MQ_ERROR;
            break;
    }

    if(FAILED(rc)) 
    {
    	if(rc == MQ_ERROR_QUEUE_EXISTS)
    	{
    		TrWARNING(GENERAL, "Failed to create %ls. The queue already exists.", lpwcsPathName);
    	}
    	else
    	{
        	TrERROR(GENERAL, "Failed to create %ls. hr = %!hresult!", lpwcsPathName, rc);
    	}

    }

    return rc;
}

/*====================================================

QMCreateDSObjectInternal

Description:
    Create a public queue in Active directory.

Arguments:

Return Value:

=====================================================*/

/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMCreateDSObjectInternal( 
    handle_t                hBind,
    DWORD                   dwObjectType,
    LPCWSTR                 lpwcsPathName,
    DWORD                   SDSize,
    unsigned char __RPC_FAR *pSecurityDescriptor,
    DWORD                   cp,
    PROPID __RPC_FAR        aProp[  ],
    PROPVARIANT __RPC_FAR   apVar[  ],
    GUID                   *pObjGuid
    )
{
    if((SDSize != 0) && (pSecurityDescriptor == NULL))
    {
        TrERROR(GENERAL, "RPC (QMCreateDSObjectInternal) NULL SD");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    if (!mqrpcIsLocalCall(hBind))
    {
        //
        // reject calls from remote machines.
        //
        TrERROR(GENERAL, "Remote RPC, rejected");
        return MQ_ERROR_ACCESS_DENIED;
    }
    
    //
    // Local RPC. That's OK.
    // On Windows, by default, the local msmq service is the one
    // that has the permission to create public queues on local machine.
    // And it does it only for local application, i.e., msmq application
    // running on local machine.
    //

    HRESULT rc;

    TrTRACE(GENERAL, " QMCreateDSObjectInternal. object path name : %ls", lpwcsPathName);
    switch (dwObjectType)
    {
        case MQDS_LOCAL_PUBLIC_QUEUE:
        {
        	//
        	// Check if we should accept this call
        	//
			if (!QueueMgr.GetCreatePublicQueueFlag())
			{
				TrERROR(GENERAL, "Service does not create local public queues on rt behalf");
				return MQ_ERROR_DS_LOCAL_USER;
			}
        	
            //
            // This call goes to the MSMQ DS server without impersonation.
            // So create the default security descriptor here, in order
            // for the caller to have full control on the queue.
            // Note: the "owner" component in the DS object will be the
            // local computer account. so remove owner and group from the
            // security descriptor.
            //
            SECURITY_INFORMATION siToRemove = OWNER_SECURITY_INFORMATION |
                                              GROUP_SECURITY_INFORMATION ;
            P<BYTE> pDefQueueSD = NULL ;

            rc = MQSec_GetDefaultSecDescriptor( 
						MQDS_QUEUE,
						(PSECURITY_DESCRIPTOR*) &pDefQueueSD,
						TRUE, //  fImpersonate
						pSecurityDescriptor,
						siToRemove,
						e_UseDefaultDacl,
						MQSec_GetLocalMachineSid(FALSE, NULL)
						);
            if (FAILED(rc))
            {
                return LogHR(rc, s_FN, 70);
            }

            rc = ADCreateObject(
                        eQUEUE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
                        lpwcsPathName,
                        pDefQueueSD,
                        cp,
                        aProp,
                        apVar,
                        pObjGuid
                        );
        }
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 80);
}


static bool IsValidObjectFormat(const OBJECT_FORMAT* p)
{
    if(p == NULL)
        return false;

    if(p->ObjType != MQQM_QUEUE)
        return false;

    if(p->pQueueFormat == NULL)
        return false;

	return FnIsValidQueueFormat(p->pQueueFormat);
}


/*====================================================

QMSetObjectSecurityInternal

Arguments:

Return Value:

=====================================================*/
/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMSetObjectSecurityInternal( 
    handle_t /*hBind*/,
    OBJECT_FORMAT*          pObjectFormat,
    SECURITY_INFORMATION    SecurityInformation,
    DWORD                   SDSize,
    unsigned char __RPC_FAR *pSecurityDescriptor
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        TrERROR(GENERAL, "RPC Invalid object format");
        return MQ_ERROR_INVALID_PARAMETER;
    }
    if((SDSize != 0) && (pSecurityDescriptor == NULL))
    {
        TrERROR(GENERAL, "RPC (QMSetObjectSecurityInternal) NULL SD");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    TrTRACE(GENERAL, "QMSetObjectSecurityInternal");

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

            rc = g_QPrivate.QMSetPrivateQueueSecrity(
                                pObjectFormat->pQueueFormat,
                                SecurityInformation,
                                pSecurityDescriptor
                                );
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 85);
}


/*====================================================

QMGetObjectSecurityInternal

Arguments:

Return Value:

=====================================================*/
/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMGetObjectSecurityInternal( 
    handle_t /*hBind*/,
    OBJECT_FORMAT*          pObjectFormat,
    SECURITY_INFORMATION    RequestedInformation,
    unsigned char __RPC_FAR *pSecurityDescriptor,
    DWORD                   nLength,
    LPDWORD                 lpnLengthNeeded
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        TrERROR(GENERAL, "RPC Invalid object format");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    TrTRACE(GENERAL, "QMGetObjectSecurityInternal");

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

            rc = g_QPrivate.QMGetPrivateQueueSecrity(
                                pObjectFormat->pQueueFormat,
                                RequestedInformation,
                                pSecurityDescriptor,
                                nLength,
                                lpnLengthNeeded
                                );
            break;

        default:
            rc = MQ_ERROR;
            break;
    }
	
	if(FAILED(rc))
	{
		TrERROR(GENERAL, "Failed to get private queue security descriptor. %!hresult!", rc);
	}

	return rc;
}

/*====================================================

QMDeleteObject

Arguments:

Return Value:

=====================================================*/
/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMDeleteObject( 
    handle_t /*hBind*/,
    OBJECT_FORMAT* pObjectFormat
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        TrERROR(GENERAL, "RPC Invalid object format");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    TrTRACE(GENERAL, "QMDeleteObject");

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

			try
			{
            	rc = g_QPrivate.QMDeletePrivateQueue(pObjectFormat->pQueueFormat);
			    return LogHR(rc, s_FN, 100);
			}
			catch(const bad_alloc&)
			{
			    return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 101);
			}
			catch(const bad_hresult& e)
			{
			    return LogHR(e.error(), s_FN, 102);
			}
            break;

        default:
		    return LogHR(MQ_ERROR, s_FN, 103);
    }
}

/*====================================================

QMGetObjectProperties

Arguments:

Return Value:

=====================================================*/
/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMGetObjectProperties( 
    handle_t /*hBind*/,
    OBJECT_FORMAT*        pObjectFormat,
    DWORD                 cp,
    PROPID __RPC_FAR      aProp[  ],
    PROPVARIANT __RPC_FAR apVar[  ]
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        TrERROR(GENERAL, "RPC Invalid object format");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    TrTRACE(GENERAL, "QMGetObjectProperties");

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

            rc = g_QPrivate.QMGetPrivateQueueProperties(
                    pObjectFormat->pQueueFormat,
                    cp,
                    aProp,
                    apVar
                    );
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 110);
}

/*====================================================

QMSetObjectProperties

Arguments:

Return Value:

=====================================================*/
/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMSetObjectProperties( 
    handle_t /*hBind*/,
    OBJECT_FORMAT*        pObjectFormat,
    DWORD                 cp,
    PROPID __RPC_FAR      aProp[],
    PROPVARIANT __RPC_FAR apVar[]
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        TrERROR(GENERAL, "RPC (QMSetObjectProperties) Invalid object format");
        return MQ_ERROR_INVALID_PARAMETER;
    }
    if((cp != 0) &&
          ((aProp == NULL) || (apVar == NULL))  )
    {
        TrERROR(GENERAL, "RPC (QMSetObjectProperties) NULL arrays");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    TrTRACE(GENERAL, " QMSetObjectProperties.");

    ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

    rc = g_QPrivate.QMSetPrivateQueueProperties(
            pObjectFormat->pQueueFormat,
            cp,
            aProp,
            apVar
            );

    return LogHR(rc, s_FN, 120);
}


static bool IsValidOutObjectFormat(const OBJECT_FORMAT* p)
{
    if(p == NULL)
        return false;

    if(p->ObjType != MQQM_QUEUE)
        return false;

    if(p->pQueueFormat == NULL)
        return false;

    //
    // If type is other than UNKNOWN this will lead to a leak on the server
    //
    if(p->pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_UNKNOWN)
        return false;

    return true;
}

/*====================================================

QMObjectPathToObjectFormat

Arguments:

Return Value:

=====================================================*/
/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMObjectPathToObjectFormat( 
    handle_t /*hBind*/,
    LPCWSTR                 lpwcsPathName,
    OBJECT_FORMAT __RPC_FAR *pObjectFormat
    )
{
    if((lpwcsPathName == NULL) || !IsValidOutObjectFormat(pObjectFormat))
    {
        TrERROR(GENERAL, "RPC Invalid object format out parameter");
        return MQ_ERROR_INVALID_PARAMETER;
    }


    HRESULT rc;
    CS lock(qmcmd_cs);

    TrTRACE(GENERAL, "QMObjectPathToObjectFormat. object path name : %ls", lpwcsPathName);

    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(
                        lpwcsPathName,
                        pObjectFormat->pQueueFormat
                        );
	if(FAILED(rc))
	{
     	TrERROR(GENERAL, "Failed to get queue format from path name for %ls. %!hresult!", lpwcsPathName, rc);
	}

    return rc;
}

/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMAttachProcess( 
    handle_t /*hBind*/,
    DWORD          dwProcessId,
    DWORD          cInSid,
    unsigned char  *pSid_buff,
    LPDWORD        pcReqSid)
{
    if (dwProcessId)
    {
        HANDLE hCallingProcess = OpenProcess(
                                    PROCESS_DUP_HANDLE,
                                    FALSE,
                                    dwProcessId);
        if (hCallingProcess)
        {
            //
            // So we can duplicate handles to the process, no need to
            // mess around with the security descriptor on the calling
            // process side.
            //
            CloseHandle(hCallingProcess);
            return(MQ_OK);
        }
    }

    CAutoCloseHandle hProcToken;
    BOOL bRet;
    DWORD cLen;
    AP<char> tu_buff;
    DWORD cSid;

#define tu ((TOKEN_USER*)(char*)tu_buff)
#define pSid ((PSECURITY_DESCRIPTOR)pSid_buff)

    bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcToken);
    ASSERT(bRet);
    GetTokenInformation(hProcToken, TokenUser, NULL, 0, &cLen);
    tu_buff = new char[cLen];
    bRet = GetTokenInformation(hProcToken, TokenUser, tu, cLen, &cLen);
    ASSERT(bRet);
    cSid = GetLengthSid(tu->User.Sid);
    if (cInSid >= cSid)
    {
        CopySid(cInSid, pSid, tu->User.Sid);
    }
    else
    {
        *pcReqSid = cSid;

        return LogHR(MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL, s_FN, 140);
    }

#undef tu
#undef pSid

    return MQ_OK;
}

//---------------------------------------------------------
//
//  Transaction enlistment RT interface to QM
//  For internal transactions uses RPC context handle
//
//---------------------------------------------------------
extern HRESULT QMDoGetTmWhereabouts(
    DWORD   cbBufSize,
    unsigned char *pbWhereabouts,
    DWORD *pcbWhereabouts);

extern HRESULT QMDoEnlistTransaction(
    XACTUOW* pUow,
    DWORD cbCookie,
    unsigned char *pbCookie);

extern HRESULT QMDoEnlistInternalTransaction(
    XACTUOW *pUow,
    RPC_INT_XACT_HANDLE *phXact);

extern HRESULT QMDoCommitTransaction(
    RPC_INT_XACT_HANDLE *phXact);

extern HRESULT QMDoAbortTransaction(
    RPC_INT_XACT_HANDLE *phXact);

/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMGetTmWhereabouts( 
    /* [in]  */             handle_t /*hBind*/,
    /* [in]  */             DWORD     cbBufSize,
    /* [out] [size_is] */   UCHAR __RPC_FAR *pbWhereabouts,
    /* [out] */             DWORD    *pcbWhereabouts
    )
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoGetTmWhereabouts(cbBufSize, pbWhereabouts, pcbWhereabouts);
    return LogHR(hr2, s_FN, 150);
}


/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMEnlistTransaction( 
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ XACTUOW __RPC_FAR *pUow,
    /* [in] */ DWORD cbCookie,
    /* [size_is][in] */ UCHAR __RPC_FAR *pbCookie
    )
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoEnlistTransaction(pUow, cbCookie, pbCookie);
    return LogHR(hr2, s_FN, 160);
}

/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMEnlistInternalTransaction( 
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ XACTUOW __RPC_FAR *pUow,
    /* [out]*/ RPC_INT_XACT_HANDLE *phXact
    )
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoEnlistInternalTransaction(pUow, phXact);
    return LogHR(hr2, s_FN, 161);
}

/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMCommitTransaction( 
    /* [in, out] */ RPC_INT_XACT_HANDLE *phXact
    )
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoCommitTransaction(phXact);
    return LogHR(hr2, s_FN, 162);
}


/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMAbortTransaction( 
    /* [in, out] */ RPC_INT_XACT_HANDLE *phXact
    )
{
    // CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoAbortTransaction(phXact);
    return LogHR(hr2, s_FN, 163);
}


/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMListInternalQueues( 
    /* [in] */ handle_t /*hBind*/,
    /* [length_is][length_is][size_is][size_is][unique][out][in] */ WCHAR __RPC_FAR *__RPC_FAR * /*ppFormatName*/,
    /* [out][in] */ LPDWORD pdwFormatLen,
    /* [length_is][length_is][size_is][size_is][unique][out][in] */ WCHAR __RPC_FAR *__RPC_FAR * /*ppDisplayName*/,
    /* [out][in] */ LPDWORD pdwDisplayLen
    )
{
	*pdwFormatLen = 0;
	*pdwDisplayLen = 0;

    ASSERT_BENIGN(("QMListInternalQueues is an obsolete RPC interface; safe to ignore", 0));
    return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 164);
}


/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMCorrectOutSequence( 
    /* [in] */ handle_t /*hBind*/,
    /* [in] */ DWORD /*dwSeqID1*/,
    /* [in] */ DWORD /*dwSeqID2*/,
    /* [in] */ ULONG /*ulSeqN*/
    )
{
    ASSERT_BENIGN(("QMCorrectOutSequence is an obsolete RPC interface; safe to ignore", 0));
    return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 165);
}


/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMGetMsmqServiceName( 
    /* [in] */ handle_t /*hBind*/,
    /* [in, out, ptr, string] */ LPWSTR *lplpService
    )
{
    if(lplpService == NULL || *lplpService != NULL)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 165);
    try
	{
		*lplpService = new WCHAR[300];
	}
    catch(const bad_alloc&)
    {
    	TrERROR(GENERAL, "Failed to allocate an array to hold the service name.");
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
	GetFalconServiceName(*lplpService, MAX_PATH);

    return MQ_OK ;

} //QMGetFalconServiceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmmgmt_s_.c ===
#pragma warning(push, 3)
#include <qmmgmt_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmnotify.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    qmnotify.h

Abstract:

	Admin Class definition
		
Author:



--*/


#define NOTIFY_QUEUE_NAME	(L"private$\\notify_queue$")


class CNotify
{
    public:

        CNotify();

        HRESULT Init();


    private:

        //functions
        HRESULT GetNotifyQueueFormat( QUEUE_FORMAT * pQueueFormat);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmperf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    admin.h

Abstract:

    Admin utilities include file (common)

Author:

    Yoel Arnon (yoela)

    Gadi Ittah (t-gadii)

--*/

#ifndef __QMPERF_H__
#define __QMPERF_H__

#include "mqperf.h"
#include "perf.h"

extern CPerf PerfApp;
extern QmCounters *g_pqmCounters;


HRESULT QMPrfInit();

#endif // __ADMIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmnotify.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    qmnotify.cpp

Abstract:

    QM notify mechanism.
	
	in MSMQ 1.0 and 2.0, when an msmq client changes the state of an msmq 
	object on the DS, the DS sends a notification to the object's owner QM.

	Now in MSMQ the DS server has been elimintated in favor of using the AD. 
	therefore, when an msmq client changes the state of an msmq object on 
	the DS, it notifies the local QM about it. the local QM will decide
	whether to sych with the DS or send an msmq notification message to the
	object's owner QM.
	Also, since QMs don't trust each other, the recieving QM accesses the DS 
	at a maximum rate of once per 15 minutes, to avoid being voulnerable to 
	denial of service atacks.

Author:
	Extended by Nir Aides (niraides) 13-Jun-2000

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "qmnotify.h"
#include "pnotify.h"
#include "bupdate.h"
#include "regqueue.h"
#include <mqsec.h>
#include "ad.h"
#include <adnotify.h>
#include <privque.h>
#include <mqprops.h>
#include <mqstl.h>
#include "lqs.h"
#include "cqpriv.h"
#include "fn.h"
#include <_propvar.h>

#include "qmnotify.tmh"

static WCHAR *s_FN=L"qmnotify";

using namespace std;



extern BOOL g_fWorkGroupInstallation;

VOID WINAPI ReceiveNotifications(const CMessageProperty*, const QUEUE_FORMAT*);

#define NOTIFICATION_MSG_TIMEOUT (5 * 60) //5 minutes
#define NOTIFICATION_MSG_PRIORITY DEFAULT_M_PRIORITY

//
// Update from DS will be done in intervals of 15 minutes
// to defend against denial of service attacks.
//
static const CTimeDuration xNotificationUpdateDelay = CTimeDuration::OneSecond().Ticks() * 60 * 15; 

//
// If we recieve more then 'xLQSTresholdMagicNumber' notifications in the time interval, 
// we invoke the general LQS cache update.
//
static const DWORD xLQSTresholdMagicNumber = 100;


//
// The following two strings are used to for marshaling the notification body,
// in a readable xml-like form.
//
// Guid Format expected to be "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
//

#define QM_NOTIFICATION_INPUT_MARSHALLING_FORMAT \
		L"<Notification>" \
			L"<Event>%d</Event>" \
			L"<ObjectGuid>%40[^<]</ObjectGuid>" \
			L"<DomainController>%260[^<]</DomainController>" \
		L"</Notification>"

#define QM_NOTIFICATION_OUTPUT_MARSHALLING_FORMAT \
		L"<Notification>" \
			L"<Event>%d</Event>" \
			L"<ObjectGuid>" GUID_FORMAT L"</ObjectGuid>" \
			L"<DomainController>%s</DomainController>" \
		L"</Notification>"



//
// This class is used to marshal the notification information inside 
// an msmq message
//
class CNotificationBody
{
public:
	CNotificationBody() : 
		m_Event(neNoEvent)
	{
	}

	CNotificationBody(
		ENotificationEvent Event, 
		const GUID& ObjectGuid,
		LPCWSTR DomainController 
		);

	void MarhshalIn(const WCHAR* pBuffer, long Size);

	//
	// returns the estimated buffer size required for MarshalOut()
	//
	long RequiredWideBufferSize();

	WCHAR* MarshalOut(WCHAR* pBuffer, long Size);

	ENotificationEvent Event() const
	{
		return m_Event;
	}

	const GUID& Guid() const
	{
		return m_ObjectGuid;
	}

	const wstring& DomainController() const
	{
		return m_DomainController;
	}

	VOID DomainController(const wstring& str)
	{
		m_DomainController = str;
	}

private:
	ENotificationEvent m_Event;
	GUID m_ObjectGuid;
	wstring m_DomainController;
};



CNotificationBody::CNotificationBody(
	ENotificationEvent Event, 
	const GUID& ObjectGuid,
	LPCWSTR DomainController 
	)
{
	m_Event = Event;
	m_ObjectGuid = ObjectGuid;
	if(DomainController != NULL)
	{
		m_DomainController = wstring(DomainController);
	}
}


void CNotificationBody::MarhshalIn(const WCHAR* pBuffer, long Size)
{
	ASSERT(pBuffer != NULL && Size != 0);
	//
	// Asserts the notification body is alligned for a unicode buffer.
	//
	ASSERT(((INT_PTR)pBuffer & 1) == 0);

	int dwEvent;
	WCHAR szGuid[MAX_PATH];
	WCHAR szDomainController[MAX_PATH];

	int Count = _snwscanf(
					pBuffer, 
					Size,
					QM_NOTIFICATION_INPUT_MARSHALLING_FORMAT, 
					&dwEvent,
					szGuid,
					szDomainController
					);
	
	//
	// Number of fields read, may be 2 if no domain controller was specified in 
	// the message body.
	// 
	if(Count < 2)
	{
		TrERROR(GENERAL, "Failed in CNotificationBody::MarhshalIn().");
		LogIllegalPoint(s_FN, 120);
		throw exception();
	}


	FnParseGuidString(szGuid, &m_ObjectGuid);
	m_DomainController.erase();
	if(Count == 3)
	{
		wstring DomainController = szDomainController;
		m_DomainController = DomainController;
	}
	m_Event = (ENotificationEvent) dwEvent;

}



WCHAR* CNotificationBody::MarshalOut(WCHAR* pBuffer, long Size)
{
	ASSERT(Size >= RequiredWideBufferSize());

	int Count = _snwprintf(
					pBuffer,
					Size,
					QM_NOTIFICATION_OUTPUT_MARSHALLING_FORMAT,
					(int)m_Event,
					GUID_ELEMENTS((&m_ObjectGuid)),
					m_DomainController.c_str()
					);
	if(Count < 0)
	{
		TrERROR(GENERAL, "Buffer too small, in CNotificationBody::MarshalOut().");
		LogIllegalPoint(s_FN, 130);
		throw exception();
	}

	return pBuffer + Count;
}



long CNotificationBody::RequiredWideBufferSize()
{
	return 
		STRLEN(QM_NOTIFICATION_OUTPUT_MARSHALLING_FORMAT) - 
		STRLEN(GUID_FORMAT) + 
		numeric_cast<long>(16 + 36 + m_DomainController.length());
}



RPC_STATUS RPC_ENTRY QmNotifySecurityCallback(
	RPC_IF_HANDLE, 
	void* hBind
	)
{
	TrTRACE(RPC, "QmNotifySecurityCallback starting");
	
	if(!mqrpcIsLocalCall(hBind))
	{
		TrERROR(RPC, "Failed to verify Local RPC");
		ASSERT_BENIGN(("Failed to verify Local RPC", 0));
		return ERROR_ACCESS_DENIED;
	}
	
	TrTRACE(RPC, "QmNotifySecurityCallback passed successfully");
	return RPC_S_OK;
}

HRESULT 
GetRelevantProperties(
	AD_OBJECT Object,
    const GUID& ObjectGuid,
	LPCWSTR DomainController,
	DWORD cProps,
	PROPID* pProps,
	PROPVARIANT* pVars	
	)
{
	ASSERT(pProps[cProps - 1] == PROPID_Q_SECURITY || pProps[cProps - 1] == PROPID_QM_SECURITY);
	
	CAutoCleanPropvarArray AutoCleanVariantArray;
	AutoCleanVariantArray.attachStaticClean(cProps, pVars);

	//
	// ISSUE-2001/05/27-ilanh - notification message don't include fServerName flag
	// so we are passing false for fServerName.
	//
	HRESULT hr = ADGetObjectPropertiesGuid(
					Object,
					DomainController,
					false,	// fServerName
					&ObjectGuid,
					cProps - 1,
					pProps,
					pVars
					);

	if(FAILED(hr))
	{
		TrERROR(GENERAL, "ADGetObjectPropertiesGuid() failed, hr = 0x%x", hr);
		return LogHR(hr, s_FN, 200);
	}

	SECURITY_INFORMATION RequestedInformation = 
							OWNER_SECURITY_INFORMATION |
							GROUP_SECURITY_INFORMATION |
							DACL_SECURITY_INFORMATION  | 
							SACL_SECURITY_INFORMATION;

	//
	// Try to get security information including SACL information.
	// If we fail try again without SACL information.
	//

    MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, TRUE);

	hr = ADGetObjectSecurityGuid(
			Object,
			DomainController, 
			false,	// fServerName
			&ObjectGuid,
			RequestedInformation,
			PROPID_Q_SECURITY,
			pVars + cProps - 1
			);

	MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);

	if(SUCCEEDED(hr))
	{
		AutoCleanVariantArray.detach();
		return hr;
	}

	RequestedInformation &= ~SACL_SECURITY_INFORMATION;

	hr = ADGetObjectSecurityGuid(
			Object,
			DomainController, 
			false,	// fServerName
			&ObjectGuid,
			RequestedInformation,
			PROPID_Q_SECURITY,
			pVars + cProps - 1
			);
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "ADGetObjectPropertiesGuid() failed to get security property, hr = 0x%x", hr);
		return LogHR(hr, s_FN, 230);
	}

	AutoCleanVariantArray.detach();
	return LogHR(hr, s_FN, 240);
}



void 
SyncQueueState(
    const GUID& ObjectGuid,
	LPCWSTR DomainController
	)
{
	//
	// BUGBUG: need to create mechanism to keep list syncronized with 
	// LQSSetProperties(). niraides 06-Jun-00
	//
	PROPID pProps[] = {
	        PROPID_Q_TYPE, 
			PROPID_Q_INSTANCE,			 
			PROPID_Q_BASEPRIORITY,		
			PROPID_Q_JOURNAL,			 
			PROPID_Q_QUOTA,				
			PROPID_Q_JOURNAL_QUOTA,		
			PROPID_Q_CREATE_TIME,		
			PROPID_Q_MODIFY_TIME,		
//			PPROPID_Q_TIMESTAMP,		//does not exist. triggers assertion (ads.cpp 2208)
			PROPID_Q_PATHNAME,				
			PROPID_Q_LABEL, 
			PROPID_Q_AUTHENTICATE,		
			PROPID_Q_PRIV_LEVEL,		
			PROPID_Q_TRANSACTION,		
			PROPID_Q_MULTICAST_ADDRESS,

			//
			// Must be last property
			//
			PROPID_Q_SECURITY			
	};

    const DWORD cProps = TABLE_SIZE(pProps);
	PROPVARIANT pVars[cProps] = {0};
	
	CAutoCleanPropvarArray AutoCleanVariantArray;
	AutoCleanVariantArray.attachStatic(cProps, pVars);

    HRESULT hr = GetRelevantProperties(
					eQUEUE,
					ObjectGuid,
					DomainController,
					cProps,
					pProps,
					pVars	
					);

	if((hr == MQ_ERROR_NO_DS) && (DomainController != NULL))
	{
		//
		// The specified DC was unreachable. try to sync with local DC.
		//
		TrWARNING(GENERAL, "failed to sync with DC = %ls, trying local DC", DomainController);
		hr = GetRelevantProperties(
				eQUEUE,
				ObjectGuid,
				NULL,
				cProps,
				pProps,
				pVars	
				);
	}
	
	if(hr == MQ_ERROR_NO_DS)
	{
		TrERROR(GENERAL, "GetRelevantProperties() Failed, MQ_ERROR_NO_DS");
		throw exception();
	}

	if(hr == MQ_ERROR_QUEUE_NOT_FOUND)
	{
		TrTRACE(GENERAL, "GetRelevantProperties() Failed, MQ_ERROR_QUEUE_NOT_FOUND");
		DeleteCachedQueue(&ObjectGuid);
		return;
	}

	if(FAILED(hr))
	{
		//
		// Don't throw exception to allow processing of more notifications
		//
		TrERROR(GENERAL, "GetRelevantProperties() Failed, hr = 0x%x", hr);
		return;
	}
	
	UpdateCachedQueueProp(&ObjectGuid, cProps, pProps, pVars, time(NULL));
}



void 
SyncMachineState(
    const GUID& ObjectGuid,
	LPCWSTR DomainController
	)
{
	if(ObjectGuid != *CQueueMgr::GetQMGuid())
	{
		TrERROR(GENERAL, "Object guid is not this QM.");
		LogIllegalPoint(s_FN, 260);
		throw exception();
	}

	//
	// BUGBUG: need to create mechanism to keep list syncronized with 
	// CQueueMgr::UpdateMachineProperties(). niraides 06-Jun-00
	//
	PROPID pProps[] = {
            PROPID_QM_QUOTA,
            PROPID_QM_JOURNAL_QUOTA,

			//
			// Must be last property
			//
            PROPID_QM_SECURITY         
 	};

	const DWORD cProps = TABLE_SIZE(pProps);
	PROPVARIANT pVars[cProps] = {0};

	CAutoCleanPropvarArray AutoCleanVariantArray;
	AutoCleanVariantArray.attachStatic(cProps, pVars);

    HRESULT hr = GetRelevantProperties(
					eMACHINE,
					ObjectGuid,
					DomainController,
					cProps,
					pProps,
					pVars	
					);

	if((hr == MQ_ERROR_NO_DS) && (DomainController != NULL))
	{
		//
		// The specified DC was unreachable. try to sync with local DC.
		//
		TrWARNING(GENERAL, "failed to sync with DC = %ls, trying local DC", DomainController);
		hr = GetRelevantProperties(
					eMACHINE,
					ObjectGuid,
					NULL,
					cProps,
					pProps,
					pVars	
					);
	}

	if(hr == MQ_ERROR_NO_DS)
	{
		TrERROR(GENERAL, "GetRelevantProperties() failed, MQ_ERROR_NO_DS");
		LogHR(hr, s_FN, 275);
		throw exception();
	}

	if(FAILED(hr))
	{
		//
		// Don't throw exception to allow processing of more notifications
		//
		TrERROR(GENERAL, "GetRelevantProperties() failed, hr = 0x%x", hr);
		LogHR(hr, s_FN, 290);
		return;
	}
	
	QueueMgr.UpdateMachineProperties(cProps, pProps, pVars);
}



void 
SyncObjectState(
	ENotificationEvent Event,
    const GUID& ObjectGuid,
	LPCWSTR DomainController
	)
{
	if(DomainController != NULL && DomainController[0] == L'\0')
	{
		DomainController = NULL;
	}

	TrTRACE(GENERAL, "sync object, event = %d, guid = %!guid!, DomainController = %ls", Event, &ObjectGuid, DomainController);

	switch(Event)
	{
	case neChangeQueue:
	case neCreateQueue:
	case neDeleteQueue:
        SyncQueueState(ObjectGuid, DomainController);
        break;

	case neChangeMachine:
		SyncMachineState(ObjectGuid, DomainController);
		break;

	default:
		TrERROR(GENERAL, "Unsupported notification event in SyncObjectState().");
		LogIllegalPoint(s_FN, 300);
		throw exception();
	}
}



void 
BuildNotificationMsg(
	ENotificationEvent Event,
	LPCWSTR DomainController,
    const GUID& ObjectGuid,
	AP<BYTE>& Buffer,
	long* pSize
	)
/*++
Routine Description:
	Builds the body of an msmq QM-notification message.

Arguments:
	[out] Buffer - Newly allocated buffer containing the msmq message body
	[out] pSize - Buffer's size

Return Value:

--*/
{
	CNotificationBody Body(Event, ObjectGuid, DomainController);

	long BufferSize = sizeof(CNotificationHeader) + Body.RequiredWideBufferSize() * 2;
    AP<BYTE> TempBuffer = new BYTE[BufferSize];
 
	CNotificationHeader* pHeader = (CNotificationHeader*)TempBuffer.get();

    pHeader->SetVersion(QM_NOTIFICATION_MSG_VERSION);
    pHeader->SetNoOfNotifications(1);

	//
	// Asserts the notification body is alligned for a unicode buffer.
	//
	ASSERT(((INT_PTR)pHeader->GetPtrToData() & 1) == 0);

	WCHAR* pBodyData = (WCHAR*)pHeader->GetPtrToData();
	
	BYTE* pEnd = (BYTE*) Body.MarshalOut(
							pBodyData, 
							Body.RequiredWideBufferSize()
							);

	*pSize = numeric_cast<long>(pEnd - TempBuffer.get());
	Buffer = TempBuffer.detach();
}



void 
SendNotificationMsg(
    const GUID* pDestQMGuid,
	BYTE* pBuffer,
	long Size
	)
{
    CMessageProperty MsgProp;

    MsgProp.wClass=0;
    MsgProp.dwTimeToQueue = NOTIFICATION_MSG_TIMEOUT;
    MsgProp.dwTimeToLive = INFINITE ;
    MsgProp.pMessageID = NULL;
    MsgProp.pCorrelationID = NULL;
    MsgProp.bPriority= NOTIFICATION_MSG_PRIORITY;
    MsgProp.bDelivery= MQMSG_DELIVERY_EXPRESS;
    MsgProp.bAcknowledge= MQMSG_ACKNOWLEDGMENT_NONE;
    MsgProp.bAuditing=MQ_JOURNAL_NONE;
    MsgProp.dwApplicationTag= DEFAULT_M_APPSPECIFIC;
    MsgProp.dwTitleSize=0;
    MsgProp.pTitle=NULL;
    MsgProp.dwBodySize=Size;
    MsgProp.dwAllocBodySize = Size;
    MsgProp.pBody= pBuffer;

	QUEUE_FORMAT QueueFormat;
    QueueFormat.PrivateID(*pDestQMGuid, NOTIFICATION_QUEUE_ID);
    
    HRESULT hr = QmpSendPacket(
					&MsgProp, 
					&QueueFormat, 
					NULL,			  //pqdAdminQueue 
					NULL,			 //pqdResponseQueue 
					FALSE			//fSign
					);
    if (FAILED(hr))
    {
		TrERROR(GENERAL, "Failed call to QmpSendPacket() in SendNotificationMsg().");
		LogHR(hr, s_FN, 310);
		throw exception();
    }
}



void 
R_NotifyQM( 
    /* [in] */ handle_t,
    /* [in] */ enum ENotificationEvent Event,
    /* [unique][in] */ LPCWSTR DomainController,
    /* [in] */ const GUID __RPC_FAR *pDestQMGuid,
    /* [in] */ const GUID __RPC_FAR *pObjectGuid
	)
/*++
Routine Description:
	this RPC routine is invoked by the msmq client who changed an object's 
	state in the DS, to trigger synchronisation of the object's new state 
	by the owner QM.

Arguments:
	Event - The nature of the state change (created, deleted, changed...)
	DomainController - The domain controller on which the state was changed
	pDestQMGuid - id of the QM which is the owner of the object
	pObjectGuid - id of the object whose state should be sync-ed

Return Value:

--*/
{
	ASSERT(!g_fWorkGroupInstallation);

	if(Event > neChangeMachine || Event < neCreateQueue)
	{
		TrERROR(RPC, "Incorrect event type, %d", Event);
		ASSERT_BENIGN(("Incorrect event type", 0));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	if((pObjectGuid == NULL) || (pDestQMGuid == NULL))
	{
		TrERROR(RPC, "NULL guid pointer input");
		ASSERT_BENIGN((pObjectGuid != NULL) && (pDestQMGuid != NULL));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}

	if((*pObjectGuid == GUID_NULL) || (*pDestQMGuid == GUID_NULL))
	{
		TrERROR(RPC, "Invalid guid values (GUID_NULL)");
		ASSERT_BENIGN((*pObjectGuid != GUID_NULL) && (*pDestQMGuid != GUID_NULL));
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}
	
	try
	{
		//
		// If the subject of the notification is local, sync immediately
		//
		if(*pDestQMGuid == *CQueueMgr::GetQMGuid())
		{
			SyncObjectState(Event, *pObjectGuid, DomainController);
			return;
		}

		//
		// Otherwise send Notification message to owner QM
		//
		
		AP<BYTE> Buffer;
		long size;

		BuildNotificationMsg(
			Event,
			DomainController, 
			*pObjectGuid, 
			Buffer,
			&size
			);

		SendNotificationMsg(pDestQMGuid, Buffer.get(), size);
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed NotifyQM().");
		LogIllegalPoint(s_FN, 330);
	}
}



void IntializeQMNotifyRpc(void)
{
	//
	// Limit R_NotifyQM input max size.
	// This will impose a limit on DomainController string.
	//
	const DWORD xNofifyMaxRpcSize = 10 * 1024;	// 10k
    RPC_STATUS status = RpcServerRegisterIf2(
				            qmnotify_v1_0_s_ifspec,
                            NULL,   
                            NULL,
				            RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
				            RPC_C_PROTSEQ_MAX_REQS_DEFAULT ,
				            xNofifyMaxRpcSize,	
				            QmNotifySecurityCallback
				            );
 
    if(status != RPC_S_OK) 
    {
        TrERROR(GENERAL, "Failed to initialize HTTP RPC. Error %x", status);
		LogRPCStatus(status, s_FN, 340);
        throw exception();
    }
}



//
// A "function object" which is used to compare GUID objects
//
struct CFunc_CompareGuids: binary_function<GUID, GUID, bool> 
{
	bool operator()(const GUID& obj1, const GUID& obj2) const
	{
		C_ASSERT(sizeof(obj1) == 16);
		return (memcmp(&obj1, &obj2, sizeof(obj1)) < 0);
	}
};



//
// This class is used to store notifications until a set time interval has 
// passed, and then sync all of them together from the DS.
//
class CNotificationScheduler 
{
public:
	CNotificationScheduler() :
		m_fDoGeneralUpdate(false),
		m_fTimerArmed(false),
		m_LastTimeFired(CTimeInstant::MinValue()),
		m_Timer(TimeToHandleNotifications)
	{
	}

	VOID ScheduleNotification(const CNotificationBody& Body);
	VOID HandleNotifications();

private:
	VOID GeneralUpdate();

public:
	static void WINAPI TimeToHandleNotifications(CTimer* pTimer);

private:
	typedef map<GUID, CNotificationBody, CFunc_CompareGuids> NotificationMap;

private:
	CCriticalSection m_cs;

	bool m_fDoGeneralUpdate;
	bool m_fTimerArmed;
	CTimeInstant m_LastTimeFired;

	CTimer m_Timer;
	NotificationMap m_NotificationMap;
};



void WINAPI CNotificationScheduler::TimeToHandleNotifications(CTimer* pTimer)
{
	CNotificationScheduler* pNotificationScheduler = CONTAINING_RECORD(pTimer, CNotificationScheduler, m_Timer);

	CS Lock(pNotificationScheduler->m_cs);

	pNotificationScheduler->m_fTimerArmed = false;
	pNotificationScheduler->m_LastTimeFired = ExGetCurrentTime();
	pNotificationScheduler->HandleNotifications();
}

	
	
VOID CNotificationScheduler::HandleNotifications()
{
	CS Lock(m_cs);

	try
	{
		if(m_fDoGeneralUpdate)
		{
			GeneralUpdate();
			m_fDoGeneralUpdate = false;
			return;
		}

		NotificationMap::iterator Itr = m_NotificationMap.begin();

		for(;Itr != m_NotificationMap.end();)
		{
			CNotificationBody& Body = Itr->second;

			SyncObjectState(Body.Event(), Body.Guid(), Body.DomainController().c_str());

			Itr = m_NotificationMap.erase(Itr);
		}
	}
	catch(const exception&)
	{
		m_fTimerArmed = true;
	    ExSetTimer(&m_Timer, xNotificationUpdateDelay);
        LogIllegalPoint(s_FN, 360);
	    return;
	}
}



VOID CNotificationScheduler::GeneralUpdate()
{
	SyncMachineState(*CQueueMgr::GetQMGuid(), NULL);

	HRESULT hr = UpdateAllPublicQueuesInCache();

	if(FAILED(hr))
	{
        TrTRACE(GENERAL, "Failed UpdateAllPublicQueuesInCache() with error %d. Will schedule a retry.",hr);
		LogHR(hr, s_FN, 315);
		throw exception();
	}
}



VOID CNotificationScheduler::ScheduleNotification(const CNotificationBody& Body)
{
	CS Lock(m_cs);

	if(m_fDoGeneralUpdate)
	{
		//
		// An Update of all public queues is scheduled. No need to schedule
		// specific updates
		//
		return;
	}

	if(m_NotificationMap.size() > xLQSTresholdMagicNumber)
	{
		//
		// Too many updates schedulled. Issue a general update.
		//
		m_fDoGeneralUpdate = true;
		m_NotificationMap.clear();
		return;
	}

	CNotificationBody& MappedBody = m_NotificationMap[Body.Guid()];

	if((MappedBody.Event() != neNoEvent) && !(MappedBody.DomainController() == Body.DomainController()))
	{
		//
		// Domain controllers conflict, so synch with local domain controller.
		//
		MappedBody = Body;
		MappedBody.DomainController(L"");
	}
	else
	{
		MappedBody = Body;
	}
		
	if(!m_fTimerArmed)
	{
		m_fTimerArmed = true;

		//
		// The following timing calculations ensure timer will go off at a 
		// maximum rate of 15 minutes, and no sooner then 1 minute from 
		// its setting (assuming more notifications are likely to arrive in
		// that minute).
		//
		CTimeInstant GoOffTime = m_LastTimeFired + xNotificationUpdateDelay;
		CTimeInstant NextMinute = ExGetCurrentTime() + CTimeDuration::OneSecond().Ticks() * 60;

		if(GoOffTime < NextMinute)
		{
			GoOffTime = NextMinute; 
		}

		ExSetTimer(&m_Timer, GoOffTime);
	}
}



static CNotificationScheduler g_NotificationScheduler;



void VerifyBody(const CNotificationBody& Body)
{
	CHLQS hLQS;

	switch(Body.Event())
	{
	case neChangeQueue:
	case neCreateQueue:
		break;

	case neDeleteQueue:	
		//
		// Verify that queue is known to QM. No need to delete otherwise.
		//
		if(SUCCEEDED(LQSOpen(&Body.Guid(), &hLQS, NULL)))
			return;

		TrERROR(GENERAL, "Failed VerifyBody(). Queue is unknown to QM.");
		throw exception();

	case neChangeMachine:
		if(Body.Guid() == *CQueueMgr::GetQMGuid())
			return;

		TrERROR(GENERAL, "Failed VerifyBody(). designated QM is not us.");
		throw exception();

	default:
		TrERROR(GENERAL, "Failed VerifyBody(). Bad body.");
		throw exception();
	}
}



//
// -----------------------------------------------------------------------
//

void
HandleQueueNotification(
    LPWSTR pwcsPathName,
    GUID* pguidIdentifier,
    unsigned char  ucOperation,
    DWORD dwNoOfProps,
    PROPID * pProps,
    PROPVARIANT * pVars
    )
{
    GUID gQueue;


    if ((pwcsPathName != NULL) && (ucOperation != DS_UPDATE_CREATE))
    {
         PROPID aProp[1];
         PROPVARIANT aVar[1];
         HRESULT rc;

         aProp[0] = PROPID_Q_INSTANCE;
         aVar[0].vt = VT_CLSID;
         aVar[0].puuid = &gQueue;

         rc = GetCachedQueueProperties(1, aProp, aVar, NULL, pwcsPathName) ;
         pguidIdentifier = aVar[0].puuid;

         if (FAILED(rc))
             return;
    }

    switch (ucOperation)
    {
        case DS_UPDATE_CREATE:
        {
            ASSERT((pguidIdentifier == NULL) && (pwcsPathName != NULL));
            for (DWORD i=0; i< dwNoOfProps; i++)
            {
                if (pProps[i] == PROPID_Q_INSTANCE)
                {
                    pguidIdentifier = pVars[i].puuid;
                    break;
                }
            }
            ASSERT(pguidIdentifier != NULL);
            UpdateCachedQueueProp(pguidIdentifier, dwNoOfProps, pProps, pVars, time(NULL));
            break;
        }

        case DS_UPDATE_SET:
        {
            ASSERT(pguidIdentifier != NULL);
            UpdateCachedQueueProp(pguidIdentifier, dwNoOfProps, pProps, pVars, time(NULL));
            break;
        }

        case DS_UPDATE_DELETE:
            ASSERT(pguidIdentifier != NULL);
			DeleteCachedQueue(pguidIdentifier);
            break;

        default:
            ASSERT(0);
    }
}

void HandleMachineNotification(unsigned char ucOperation,
                               DWORD dwNoOfProps,
                               PROPID * pProps,
                               PROPVARIANT * pVars)
{
    QUEUE_FORMAT QueueFormat;
   

    if (ucOperation == DS_UPDATE_SET)
    {
        QueueMgr.UpdateMachineProperties(dwNoOfProps, pProps, pVars);
    }
}



//
// Constructor
//
CNotify::CNotify()
{
}


/*====================================================

RoutineName
    CNotify::Init()

Arguments:

Return Value:

=====================================================*/
HRESULT CNotify::Init()
{
    TrTRACE(GENERAL, "Entering CNotify::Init");

	try
	{
		if(!g_fWorkGroupInstallation)
		{
			IntializeQMNotifyRpc();
		}
	}
	catch(const exception&)
	{
        TrERROR(GENERAL, "ERROR : CNotify::Init -> Failed call to IntializeQMNotifyRpc()");
    	LogIllegalPoint(s_FN, 370);
        return LogHR(MQ_ERROR, s_FN, 5);
	}

    QUEUE_FORMAT QueueFormat;
    HRESULT hr = GetNotifyQueueFormat(&QueueFormat);
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "ERROR : CNotify::Init -> couldn't get Admin-Queue from registry!!!");
        return LogHR(hr, s_FN, 10);
    }

    hr= QmpOpenAppsReceiveQueue(&QueueFormat, ReceiveNotifications);
    return LogHR(hr, s_FN, 20);
}


/*====================================================

RoutineName
    CNotify::GetNotifyQueueFormat()

Arguments:

Return Value:

=====================================================*/

HRESULT CNotify::GetNotifyQueueFormat( QUEUE_FORMAT * pQueueFormat)
{
    extern LPTSTR  g_szMachineName;

    HRESULT rc;

	std::wstring FormatName = g_szMachineName;
	FormatName += L'\\';
	FormatName += NOTIFY_QUEUE_NAME;

    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(FormatName.c_str(), pQueueFormat);

    if (FAILED(rc))
    {
        //
        // The NOTIFY_QUEUE doesn't exist
        //
        LogHR(rc, s_FN, 30);
        return MQ_ERROR;
    }

    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT));

    return MQ_OK;
}

/*====================================================

ValidateServerPacket

Arguments:

Return Value:

=====================================================*/

static BOOL
ValidateServerPacket(
    const CMessageProperty* pmp,
    const GUID         *pGuidQM
    )
{
    //
    // The sender ID must be marked as QM.
    //
    if ((pmp->pSenderID == NULL) ||
        pmp->ulSenderIDType != MQMSG_SENDERID_TYPE_QM)
    {
        TrERROR(GENERAL, "Sender ID type is not QM (%d)", pmp->ulSenderIDType);
        return FALSE;
    }

    //
    // Server packets must be authenticated.
    //
    if (!pmp->bAuthenticated)
    {
        //
        // BUGBUG -
        // Non-authenticated server packets can be received only if we're
        // running on the server it self. This is because we do not go
        // through the QM in this case.
        // So see if the QM guid that is in the packet is identical to the
        // QM guid of our - the local QM.
        //

        if ((pmp->pSignature == NULL) ||
            memcmp(pmp->pSenderID, pGuidQM, sizeof(GUID)) != 0)
        {
            //
            // This still might happen when receiving first replication
            // messages from a new site. This special case is treated by
            // the MQIS. A special debug message is generated to indicate
            // that the message was accepted after all.
            //
            TrERROR(GENERAL, "Received a non-authenticated server message.");
            return FALSE;
        }

        //
        // Yup, so compute the hash value and then validate the signature.
        //
        CHCryptHash hHash;
        CHCryptKey hPbKey;

        //
        // Packet are signed with the base provider. Always.
        //
        HCRYPTPROV hProvQM = NULL;
        HRESULT hr = MQSec_AcquireCryptoProvider(eBaseProvider, &hProvQM);
        if (FAILED(hr))
        {
            TrERROR(GENERAL, "Failed to Acquire crypto provider, %!hresult!", hr);
            return FALSE;
        }

        ASSERT(hProvQM) ;
        if (!CryptCreateHash(hProvQM, pmp->ulHashAlg, 0, 0, &hHash))
        {
			DWORD gle = GetLastError();
            TrERROR(GENERAL,"Failed to create hash, gle = %!winerr!", gle);
            return FALSE;
        }

        hr = HashMessageProperties(
                hHash,
                pmp,
                NULL,
                NULL
                );
        if (FAILED(hr))
        {
            TrERROR(GENERAL, "Failed to HashMessageProperties, %!hresult!", hr);
            return FALSE;
        }

        if (!CryptGetUserKey(hProvQM, AT_SIGNATURE, &hPbKey))
        {
			DWORD gle = GetLastError();
            TrERROR(GENERAL, "Failed to get user key, gle = %!winerr!", gle);
            return FALSE;
        }

        if (!CryptVerifySignature(
                    hHash,
                    pmp->pSignature,
                    pmp->ulSignatureSize,
                    hPbKey,
                    NULL,
                    0
                    ))
        {
			DWORD gle = GetLastError();
            TrERROR(GENERAL, "Failed to verify signature, gle = %!winerr!", gle);
            return FALSE;
        }

    }

    //
    // See that we indeed got the message from a server.
    //
    HRESULT hr;
    PROPID PropId = PROPID_QM_SERVICE;   //[adsrv] Keeping old - query will process.
    PROPVARIANT PropVar;

    PropVar.vt = VT_UI4;
    // This search request will be recognized and specially simulated by DS
    hr = ADGetObjectPropertiesGuid(
            eMACHINE,
            NULL,   // pwcsDomainController
			false,	// fServerName
            (GUID *)pmp->pSenderID,
            1,
            &PropId,
            &PropVar
            );
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "Failed to get the service type, %!hresult!", hr);
        return FALSE;
    }

    // [adsrv] Not changing it, because query will do its work.
    // It is a special case for the query.

    if ((PropVar.ulVal != SERVICE_PEC) &&
        (PropVar.ulVal != SERVICE_PSC) &&
        (PropVar.ulVal != SERVICE_BSC))
    {
        TrERROR(GENERAL, "Received notification not from a server (%d)", PropVar.ulVal);
        return FALSE;
    }

    return TRUE;
}


VOID
WINAPI
ReceiveNotifications(
    const CMessageProperty* pmp,
    const QUEUE_FORMAT* /*pqf*/
    )
{
	try
    {
		if(g_fWorkGroupInstallation)
		{
			TrERROR(GENERAL, "Notifications message received in workgroup mode.");
			return;
		}

		if ( pmp->wClass != MQMSG_CLASS_NORMAL )
		{
			TrERROR(GENERAL, "ReceiveNotifications: wrong message class");
			return;
		}
	
		DWORD dwTotalSize = pmp->dwBodySize;

		if (dwTotalSize < sizeof(CNotificationHeader))
		{
			TrERROR(GENERAL, "Bad notification message size.");
			return;
		}
		
		CNotificationHeader * pNotificationHeader = (CNotificationHeader *)pmp->pBody;

		if (pNotificationHeader->GetVersion() == QM_NOTIFICATION_MSG_VERSION)
		{
			//
			// New format notification, sent from another QM.
			//

			CNotificationBody Body;
			long BodySize = (dwTotalSize - pNotificationHeader->GetBasicSize()) / 2;
			const WCHAR* pBodyData = (const WCHAR*) pNotificationHeader->GetPtrToData();

			Body.MarhshalIn(pBodyData, BodySize);
			
			VerifyBody(Body);
			g_NotificationScheduler.ScheduleNotification(Body);

			return;
		}

		//
		// Should be an old format signed notification, sent from a DS server.
		//

		if ( pNotificationHeader->GetVersion() != DS_NOTIFICATION_MSG_VERSION)
		{
			TrERROR(GENERAL, "Wrong version number of notification message");
			LogIllegalPoint(s_FN, 140);
			return;
		}

		BOOL fSigned = ValidateServerPacket(pmp, QueueMgr.GetQMGuid());

		if(!fSigned)
		{
			TrERROR(GENERAL, "Failed DS notification validation.");
			LogIllegalPoint(s_FN, 145);
			return;
		}

		DWORD sum = pNotificationHeader->GetBasicSize();
		const unsigned char* ptr = pNotificationHeader->GetPtrToData();
  
		for (unsigned char i = 0; i < pNotificationHeader->GetNoOfNotifications(); i++)
		{
			ASSERT (sum < dwTotalSize);
			P<CDSBaseUpdate> pUpdate = new CDSBaseUpdate;

			DWORD size;

			HRESULT hr = pUpdate->Init(ptr,&size);
			if (FAILED(hr))
			{
				//
				// We don't want to read junked values
				// The notification will be ignored
				//
				TrERROR(GENERAL, "Error -  in parsing a received notification");
				LogHR(hr, s_FN, 150);
				break;
			}
			sum+=size;
			ptr+=size;

			switch ( pUpdate->GetObjectType())
			{
				case MQDS_QUEUE:
					HandleQueueNotification( pUpdate->GetPathName(),
											 pUpdate->GetGuidIdentifier(),
											 pUpdate->GetCommand(),
											 pUpdate->getNumOfProps(),
											 pUpdate->GetProps(),
											 pUpdate->GetVars());
					break;
				case MQDS_MACHINE:
					HandleMachineNotification( pUpdate->GetCommand(),
											   pUpdate->getNumOfProps(),
											   pUpdate->GetProps(),
											   pUpdate->GetVars());

					break;
				default:
					TrERROR(GENERAL, "Notification about unexpected object type");
					break;
			}

		}
    }
	catch(const exception&)
	{
        TrERROR(GENERAL, "Exception thrown inside ReceiveNotifications().");
		LogIllegalPoint(s_FN, 350);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmperf.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmperf.cpp

Abstract:

    qm performance monitor counters handling

Authors:

    Yoel Arnon (yoela)
    Gadi Ittach (t-gadii)

--*/

#include "stdh.h"
#include "qmperf.h"
#include "perfdata.h"

#include "qmperf.tmh"

static WCHAR *s_FN=L"qmperf";


CPerf PerfApp(ObjectArray, dwPerfObjectsCount);


/*====================================================
RoutineName: QMPerfInit

Arguments: None

Return Value: True if successfull. False otherwise.

Initialize the shared memory and put a pointer to it in
pqmCounters.
=====================================================*/
HRESULT QMPrfInit()
{
    HRESULT hr = PerfApp.InitPerf();
    if(FAILED(hr))
        return LogHR(hr, s_FN, 10);

    PerfApp.ValidateObject(PERF_QM_OBJECT);

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    Qmp.h

Abstract:
    QM general function decleration

Author:
    Uri Habusha (urih) 26-Sep-2000

Environment:
    Platform-independent

--*/

#pragma once

#ifndef __QMP_H__
#define __QMP_H__

#include "msgprops.h"

bool 
QmpInitMulticastListen(
    void
    );

SOCKET
QmpCreateSocket(
    bool fQoS
    );

void 
QmpFillQoSBuffer(
    QOS* pQos
    );

HRESULT
QmpSendPacket(
    CMessageProperty* pmp,
    const QUEUE_FORMAT* pqdDstQueue,
    const QUEUE_FORMAT* pqdAdminQueue,
    const QUEUE_FORMAT* pqdResponseQueue,
    BOOL fSign = FALSE
    );

typedef
VOID
(WINAPI *LPRECEIVE_COMPLETION_ROUTINE)(
    const CMessageProperty* pmp,
    const QUEUE_FORMAT* pQueueFormat
    );


HRESULT
QmpOpenAppsReceiveQueue(
    const QUEUE_FORMAT* pQueueFormat,
    LPRECEIVE_COMPLETION_ROUTINE lpReceiveRoutine
    );

void
QmpReportServiceProgress(
    void
    );


void 
QmpStorePacket(
	CBaseHeader* pBase, 
	PVOID pCookie, 
	PVOID pPool, 
	ULONG ulSize
	);


void 
QmpRequeueMustSucceed(
	CQmPacket *pQMPacket
	);


void 
QmpRequeueAndDelete(
	CQmPacket *pQMPacket
	);


bool 
QmpIsDestinationSystemQueue(
	const QUEUE_FORMAT& DestinationQueue
	);


#endif // __QMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmpkt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmpkt.cpp

Abstract:

    Handle packet in QM side

Author:

    Uri Habusha  (urih)


--*/
#include "stdh.h"

#include "qmpkt.h"
#include "phintr.h"
#include "ac.h"
#include "cqmgr.h"
#include "qmsecutl.h"
#include <mqsec.h>
#include <singelton.h>
#include <xml.h>
#include <fn.h>

#include "qmpkt.tmh"

extern BOOL g_fRejectEnhRC2WithLen40 ;

static WCHAR *s_FN=L"qmpkt";

extern HRESULT GetDstQueueObject(
    CQmPacket* pPkt,
    CQueue** ppQueue,
    bool     fInReceive);


void ReportAndThrow(LPCSTR ErrorString)
{
	TrERROR(GENERAL, "Native Packet: %s", ErrorString);
	ASSERT_BENIGN(0);
	throw exception();
}


/*===========================================================

  Routine Name: CQmPacket::CQmPacket

  Description:  CQmPacket constructor

  Arguments:

  Return Value:

=============================================================*/
CQmPacket::CQmPacket(CBaseHeader *pPkt,
					 CPacket *pDriverPkt,
					 bool ValidityCheck /* = FALSE */,
					 bool ValidateSig /* = TRUE*/):
                m_pDriverPacket(pDriverPkt),
			    m_pBasicHeader(pPkt),
                m_pcUserMsg(NULL),
				m_pXactSection(NULL),
                m_pSecuritySection(NULL),
				m_pcMsgProperty(NULL),
				m_pDbgPkt(NULL),
				m_pDestinationMqfHeader(NULL),
				m_pAdminMqfHeader(NULL),
				m_pResponseMqfHeader(NULL),
				m_pMqfSignatureHeader(NULL),
				m_pSrmpEnvelopeHeader(NULL),
				m_pCompoundMessageHeader(NULL),
				m_pEodHeader(NULL),
				m_pEodAckHeader(NULL),
				m_pSoapHeaderSection(NULL),
				m_pSoapBodySection(NULL),
				m_pSenderStreamHeader(NULL),
				m_pSessPkt(NULL)

{
    PCHAR pSection;

	PCHAR PacketEnd = m_pBasicHeader->GetPacketEnd();
	if (ValidityCheck)
	{
		m_pBasicHeader->SectionIsValid(CSingelton<CMessageSizeLimit>::get().Limit(), ValidateSig);
	}

    pSection = m_pBasicHeader->GetNextSection();
	

    if (m_pBasicHeader->GetType() == FALCON_USER_PACKET)
    {
        //
        // User Packet
        //
    	m_pcUserMsg = section_cast<CUserHeader*>(pSection);
		if (ValidityCheck)
		{
			m_pcUserMsg->SectionIsValid(PacketEnd);
		}
		
        pSection = m_pcUserMsg->GetNextSection();
        //
        // Xact Section
        //
        if (m_pcUserMsg->IsOrdered())
        {
            m_pXactSection = section_cast<CXactHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pXactSection->SectionIsValid(PacketEnd);
			}
            pSection = m_pXactSection->GetNextSection();
        }

        //
        // Security Section
        //
        if (m_pcUserMsg->SecurityIsIncluded())
        {
            m_pSecuritySection = section_cast<CSecurityHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pSecuritySection->SectionIsValid(PacketEnd);
			}
            pSection = m_pSecuritySection->GetNextSection();
        }


        //
        // Message propery section
        //
        m_pcMsgProperty = section_cast<CPropertyHeader*>(pSection);
		if (ValidityCheck)
		{
			m_pcMsgProperty->SectionIsValid(PacketEnd);
		}
        pSection = m_pcMsgProperty->GetNextSection();

        //
        // Debug Section
        //
        if (m_pBasicHeader->DebugIsIncluded())
        {
            m_pDbgPkt = section_cast<CDebugSection*>(pSection);
			if(ValidityCheck)
			{
				m_pDbgPkt->SectionIsValid(PacketEnd);
			}
            pSection = m_pDbgPkt->GetNextSection();
        }

        //
        // MQF sections: Destination, Admin, Response, Signature.
        // When MQF is included, the Debug section must be included too,
        // to prevent reporting QMs 1.0/2.0 to append their Debug section.
        //
        if (m_pcUserMsg->MqfIsIncluded())
        {
			if(ValidityCheck && !m_pBasicHeader->DebugIsIncluded())
			{
		        ReportAndThrow("Debug section is not included while MQF included");
			}

            m_pDestinationMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pDestinationMqfHeader->SectionIsValid(PacketEnd);
			}
            pSection = m_pDestinationMqfHeader->GetNextSection();

            m_pAdminMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pAdminMqfHeader->SectionIsValid(PacketEnd);
			}
            pSection = m_pAdminMqfHeader->GetNextSection();

            m_pResponseMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pResponseMqfHeader->SectionIsValid(PacketEnd);
			}
            pSection = m_pResponseMqfHeader->GetNextSection();

			m_pMqfSignatureHeader = section_cast<CMqfSignatureHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pMqfSignatureHeader->SectionIsValid(PacketEnd);
			}
			pSection = m_pMqfSignatureHeader->GetNextSection();
        }
        //
        // SRMP sections: Envelope, CompoundMessage
        //
        if (m_pcUserMsg->SrmpIsIncluded())
        {
            m_pSrmpEnvelopeHeader = section_cast<CSrmpEnvelopeHeader*>(pSection);
            pSection = m_pSrmpEnvelopeHeader->GetNextSection();

            m_pCompoundMessageHeader = section_cast<CCompoundMessageHeader*>(pSection);
            pSection = m_pCompoundMessageHeader->GetNextSection();
        }
        //
        // EOD section
        //
        if (m_pcUserMsg->EodIsIncluded())
        {
            m_pEodHeader = section_cast<CEodHeader*>(pSection);
            pSection = m_pEodHeader->GetNextSection();
        }
        //
        // EOD-ACK section
        //
        if (m_pcUserMsg->EodAckIsIncluded())
        {
            m_pEodAckHeader = section_cast<CEodAckHeader*>(pSection);
            pSection = m_pEodAckHeader->GetNextSection();
        }

		//
		// SOAP sections
		//
		if (m_pcUserMsg->SoapIsIncluded())
		{
			m_pSoapHeaderSection = section_cast<CSoapSection*>(pSection);
            pSection = m_pSoapHeaderSection->GetNextSection();

			m_pSoapBodySection = section_cast<CSoapSection*>(pSection);
            pSection = m_pSoapBodySection->GetNextSection();
		}


		//
        // Sender Stream
		//
		if(m_pcUserMsg->SenderStreamIsIncluded())
		{
			m_pSenderStreamHeader = section_cast<CSenderStreamHeader*>(pSection);
			pSection = m_pSenderStreamHeader->GetNextSection();
		}
		

        //
        // Session Section
        //
        if (m_pBasicHeader->SessionIsIncluded())
        {
            m_pSessPkt = section_cast<CSessionSection*>(pSection);
        }
    }
	if (ValidityCheck)
	{
		PacketIsValid();
	}
}


WCHAR* 
CQmPacket::GetDestinationQueueFromSrmpSection(
	) 
const
/*++
    Description:
	For http messages, the destination queue might be a virtual
	name mapped to a different queue (SFD). In this case, for security reasons,
	we want to put the virtual name and not the real one. We take it from the 
	SrmpEnvelopeHeader section in the message. This is the original destination
	of the message for which an ACK is being sent.

	Return Value:
	The destination queue in an allocated wstring.
--*/
{
	const WCHAR* doc = GetPointerToSrmpEnvelopeHeader(); 
	xwcs_t x_doc(doc, wcslen(doc));

	CAutoXmlNode XmlRootNode;
	XmlParseDocument(x_doc, &XmlRootNode);

	const XmlNode* node = XmlFindNode(XmlRootNode, L"Envelope!Header!path!to");
	ASSERT(node != NULL);
	return (node->m_content).ToStr();
}


bool
CQmPacket::IsSrmpMessageGeneratedByMsmq(
	void
	) 
const
/*++
 	Description:
 		The routine checks if the SRMP packet was sent by MSMQ or external 
 		vendore.
 ++*/
{
	if (!IsSrmpIncluded())
		return false;
	
	const WCHAR* doc = GetPointerToSrmpEnvelopeHeader(); 
	ASSERT(("SRMP envelope section is expected", doc != NULL));
	xwcs_t x_doc(doc, wcslen(doc));

	CAutoXmlNode XmlRootNode;
	XmlParseDocument(x_doc, &XmlRootNode);

	const XmlNode* node = XmlFindNode(XmlRootNode, L"Envelope!Header!Msmq");
	return(node != NULL);
}


/*===========================================================

  Routine Name: CQmPacket::CreateAck

  Description:  Create Ack packet and PUT it in admin queue

  Arguments:

  Return Value:

=============================================================*/
void CQmPacket::CreateAck(USHORT wAckValue)
{
    //
    //  The class must match the user required acknowledgement
    //
    ASSERT(MQCLASS_MATCH_ACKNOWLEDGMENT(wAckValue, GetAckType()));

    //
    // Admin queue may exist on the packet
    //
    QUEUE_FORMAT  AdminQueueFormat;
    BOOL fOldStyleAdminQueue = GetAdminQueue(&AdminQueueFormat);

    if (!fOldStyleAdminQueue)
    {
        return;
    }

    QUEUE_FORMAT DestinationQueueFormat;
    AP<WCHAR> wstrDestinationQueue;
	if(IsSrmpIncluded())
	{
		wstrDestinationQueue = GetDestinationQueueFromSrmpSection();
		DestinationQueueFormat.DirectID(wstrDestinationQueue);
	}
	else
	{
	    //
	    // Old-style destination queue always exists on the packet.
	    //
	    BOOL fOldStyleDestinationQueue = GetDestinationQueue(&DestinationQueueFormat);
	    ASSERT(fOldStyleDestinationQueue);
		DBG_USED(fOldStyleDestinationQueue);
	}

    //
    // Create Message property on stack
    //
    CMessageProperty MsgProperty(this);
    MsgProperty.wClass = wAckValue;
    MsgProperty.bAcknowledge = MQMSG_ACKNOWLEDGMENT_NONE;
    MsgProperty.dwTimeToQueue = INFINITE;
    MsgProperty.dwTimeToLive = INFINITE;
    MsgProperty.pSignature = NULL;  // ACKs are non-authenticated.
    MsgProperty.ulSignatureSize = 0;
    MsgProperty.ulSymmKeysSize = 0;
    MsgProperty.bAuditing = DEFAULT_M_JOURNAL;

    //
    // Update the correlation field to hold the original packet ID
    //
    delete MsgProperty.pCorrelationID;
    MsgProperty.pCorrelationID = (PUCHAR) MsgProperty.pMessageID;
    MsgProperty.pMessageID = NULL;

    if (!MQCLASS_NACK(wAckValue) ||
        (MsgProperty.ulPrivLevel != MQMSG_PRIV_LEVEL_NONE))
    {

        //
        // For ACK message don't include the message body
        // Also, for NACK of encrypted messages, we do not
        // include the body.
        //
        MsgProperty.dwBodySize = 0;
        MsgProperty.dwAllocBodySize = 0;
        MsgProperty.dwBodyType = 0;

		//
		// Set the message as encrypted, otherwise when sending to direct
		// format name, the AC will fail the operation (encryption isn't supported
		// with direct format name.
		//		Uri Habusha, 4-Dec-200 (bug# 6070)
		//
        MsgProperty.bEncrypted = (MsgProperty.ulPrivLevel != MQMSG_PRIV_LEVEL_NONE);
   }
	
    HRESULT hr = QueueMgr.SendPacket(
                     &MsgProperty,
                     &AdminQueueFormat,
                     1,
                     NULL,
                     &DestinationQueueFormat
                     );
    ASSERT(hr != STATUS_RETRY) ;
	DBG_USED(hr);

} // CQmPacket::CreateAck


/*===========================================================

  Routine Name: CQmPacket::GetSymmKey

  Description:  Returns the Symmetric key of the destination

  Arguments:

  Return Value:

=============================================================*/
HRESULT
CQmPacket::GetDestSymmKey(HCRYPTKEY *phSymmKey,
                          BYTE     **ppEncSymmKey,
                          DWORD     *pdwEncSymmKeyLen,
                          PVOID     *ppQMCryptInfo)
{
    ASSERT(IsBodyInc() && !IsEncrypted()) ;
    ASSERT(GetPrivBaseLevel() == MQMSG_PRIV_LEVEL_BODY_BASE);

    enum enumProvider eProvider = eBaseProvider ;
    if (GetPrivLevel() == MQMSG_PRIV_LEVEL_BODY_ENHANCED)
    {
        eProvider = eEnhancedProvider ;
    }
    HCRYPTPROV hProvQM = NULL ;
    HRESULT hr = MQSec_AcquireCryptoProvider( eProvider,
                                             &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    if (!hProvQM)
    {
        // Sorry, the local QM doesn't support encryption.
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 20);
    }

    const GUID *pguidQM = GetDstQMGuid();

    if (*pguidQM == GUID_NULL)
    {
        //
        // The queue was opened when the DS was offline. Therefore the Destination
        // QM is NULL. In such a case we retrive the information from queue object
        //
        CQueue* pQueue;

        //
        // GetDestSymmKey is called only during send
        //
        GetDstQueueObject(this, &pQueue, false);
        pguidQM = pQueue->GetMachineQMGuid();
        pQueue->Release();
        ASSERT(*pguidQM != GUID_NULL);
    }

    // Get the encrypted symmetric key for the destination QM.
    switch(GetEncryptAlg())
    {
    case CALG_RC4:
        hr = GetSendQMSymmKeyRC4(pguidQM,
                                 eProvider,
                                 phSymmKey,
                                 ppEncSymmKey,
                                 pdwEncSymmKeyLen,
                                 (CCacheValue **)ppQMCryptInfo);
        break;
    case CALG_RC2:
        hr = GetSendQMSymmKeyRC2(pguidQM,
                                 eProvider,
                                 phSymmKey,
                                 ppEncSymmKey,
                                 pdwEncSymmKeyLen,
                                 (CCacheValue **)ppQMCryptInfo);
        break;
    default:
        ASSERT(0);
        break;
    }

    return LogHR(hr, s_FN, 30);

}

/*===========================================================

  Routine Name: CQmPacket::Encrypt

  Description:  Encrypt the message body.

  Arguments:

  Return Value:

=============================================================*/
HRESULT
CQmPacket::EncryptExpressPkt(IN HCRYPTKEY hKey,
                             IN BYTE *pbSymmKey,
                             IN DWORD dwSymmKeyLen
                            )
{

    // write the symmetric key in the message packet.
    SetEncryptedSymmetricKey(pbSymmKey, (USHORT)dwSymmKeyLen);

    DWORD dwPacketSize;
    const UCHAR *pPacket = GetPacketBody(&dwPacketSize);
    DWORD dwAllocBodySize = GetAllocBodySize();

    // Encrypt the message body.
    if (!CryptEncrypt(
            hKey,
            NULL,
            TRUE,
            0,
            const_cast<BYTE *>(pPacket),
            &dwPacketSize,
            dwAllocBodySize))
    {
        DWORD gle = GetLastError();
        TrERROR(SECURITY, "Message encryption failed. Error %d", gle);
        LogNTStatus(gle, s_FN, 40);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    // Update the message body size. The message body size may be changed
    // when using a block cypher.
    SetBodySize(dwPacketSize);
    SetEncrypted(TRUE);

    return(MQ_OK);
}


/*===========================================================

  Routine Name: CQmPacket::Dencrypt

  Description:  Dencrypt the message body.

  Arguments:

  Return Value:

=============================================================*/
HRESULT
CQmPacket::Decrypt(void)
{
    if ((GetPrivLevel() == MQMSG_PRIV_LEVEL_NONE) ||
        !IsBodyInc())
    {
        // The message is not encrypted. Get out of here.
        if (IsSecurInc())
        {
            SetEncrypted(FALSE); // NACKs for encrypted messages arrived with
                                 // no message body, but the "encrypted" flag
                                 // is set. So clear here the "encrypted" bit.
        }
        return(MQ_OK);
    }
	if (!IsEncrypted())
	{
        TrERROR(GENERAL, "IsEncrypted != GetPrivLevel");
		throw exception();
	}

    enum enumProvider eProvider = eBaseProvider ;
    HRESULT hrDefault = MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION ;

    if (GetPrivLevel() == MQMSG_PRIV_LEVEL_BODY_ENHANCED)
    {
        eProvider = eEnhancedProvider ;
        hrDefault = MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED ;
    }

    HCRYPTPROV hProvQM = NULL ;
    HRESULT hr = MQSec_AcquireCryptoProvider( eProvider,
                                             &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    if (!hProvQM)
    {
        // Sorry, the QM doesn't support encryption.
        return LogHR(hrDefault, s_FN, 60);
    }

    const GUID *pguidQM = GetSrcQMGuid();
    DWORD dwBodySize;
    const UCHAR *pBody = GetPacketBody(&dwBodySize);
    DWORD dwSymmKeyLen = 0;
    const BYTE *pbSymmKey = GetEncryptedSymmetricKey((PUSHORT)&dwSymmKeyLen);
    HCRYPTKEY hKey = 0;
    R<CCacheValue> pCacheValue;

    BOOL fNewKey = FALSE ;

    // Get the symmetric key either from the key blob from the message packet,
    // or from the cached keys.
    switch(GetEncryptAlg())
    {
    case CALG_RC4:
        hr = GetRecQMSymmKeyRC4( pguidQM,
                                 eProvider,
                                 &hKey,
                                 pbSymmKey,
                                 dwSymmKeyLen,
                                 &pCacheValue.ref() );
        break;
    case CALG_RC2:
        hr = GetRecQMSymmKeyRC2( pguidQM,
                                 eProvider,
                                 &hKey,
                                 pbSymmKey,
                                 dwSymmKeyLen,
                                 &pCacheValue.ref(),
                                 &fNewKey );
        break;
    default:
        return LogHR(MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED, s_FN, 65);
    }

    if (FAILED(hr))
    {
        // We received a corrupted symmetric key, drop the message.
        return LogHR(hr, s_FN, 70);
    }

    BOOL fTry40 = FALSE ;
    AP<BYTE> pTmpBuf = NULL ;

    if (fNewKey                          &&
        (eProvider == eEnhancedProvider) &&
        (GetEncryptAlg() == CALG_RC2)    &&
          !g_fRejectEnhRC2WithLen40)
    {
        //
        // Windows bug 562586.
        // If decryption fail (for RC2 enhanced) then set effective
        // length of key to 40 bits and try again.
        // Save body buffer, to be reused for second decryption.
        // that's need because the body buffer is overwritten in-place by
        // CryptDecrypt, even when it fail.
        //
        fTry40 = TRUE ;
        pTmpBuf = new BYTE[ dwBodySize ] ;
        memcpy(pTmpBuf, pBody, dwBodySize) ;
    }

    // Decrypt the message body.
    if (!CryptDecrypt(
            hKey,
            NULL,
            TRUE,
            0,
            const_cast<BYTE *>(pBody),
            &dwBodySize))
    {
        BOOL fDecrypt = FALSE ;

        if (fTry40)
        {
            //
            // New symmetric key. Set length to 40 bits and try again
            // to decrypt the body. Use the backup of body buffer.
            //
            const DWORD x_dwEffectiveLength = 40 ;

            if (!CryptSetKeyParam( hKey,
                                   KP_EFFECTIVE_KEYLEN,
                                   (BYTE*) &x_dwEffectiveLength,
                                   0 ))
            {
        	    DWORD gle = GetLastError();
			    TrERROR(SECURITY, "Failed to set enhanced RC2 key len to 40 bits, gle = %!winerr!", gle);
                return MQ_ERROR_CANNOT_SET_RC2_TO40 ;
            }

            pBody = GetPacketBody(&dwBodySize);
            memcpy(const_cast<BYTE *>(pBody), pTmpBuf, dwBodySize) ;

            fDecrypt = CryptDecrypt( hKey,
                                     NULL,
                                     TRUE,
                                     0,
                                     const_cast<BYTE *>(pBody),
                                    &dwBodySize) ;
        }

        if (!fDecrypt)
        {
            // We receive a corrupted message.
	    	DWORD gle = GetLastError();
		    TrERROR(SECURITY, "CryptDecrypt() failed, gle = 0x%x", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
    }

    // Update the message body size. The message body size may get modified
    // when using a block cypher.
    SetBodySize(dwBodySize);
    SetEncrypted(FALSE);

    return(MQ_OK);
}

//
// CMessageProperty constructor
//
CMessageProperty::CMessageProperty(CQmPacket* pPkt)
{
    P<OBJECTID> pMessageId = new OBJECTID;
    AP<UCHAR> pCorrelationId = new UCHAR[PROPID_M_CORRELATIONID_SIZE];

    pPkt->GetMessageId(pMessageId);
    pPkt->GetCorrelation(pCorrelationId);

    wClass          = pPkt->GetClass();
    dwTimeToQueue   = INFINITE;
    dwTimeToLive    = INFINITE;
    pMessageID      = pMessageId;
    pCorrelationID  = pCorrelationId;
    bPriority       = (UCHAR)pPkt->GetPriority();
    bDelivery       = (UCHAR)pPkt->GetDeliveryMode();
    bAcknowledge    = pPkt->GetAckType();
    bAuditing       = (UCHAR)pPkt->GetAuditingMode();
    bTrace          = (UCHAR)pPkt->GetTrace();
    dwApplicationTag= pPkt->GetApplicationTag();
    pBody           = pPkt->GetPacketBody(&dwBodySize);
    dwAllocBodySize = pPkt->IsSrmpIncluded() ? dwBodySize : pPkt->GetAllocBodySize();
    dwBodyType      = pPkt->GetBodyType();
    pTitle          = pPkt->GetTitlePtr();
    dwTitleSize     = pPkt->GetTitleLength();
    pMsgExtension   = pPkt->GetMsgExtensionPtr();
    dwMsgExtensionSize = pPkt->GetMsgExtensionSize();
    pSenderID       = pPkt->GetSenderID(&uSenderIDLen);
    ulSenderIDType  = pPkt->GetSenderIDType();
    pSenderCert     = pPkt->GetSenderCert(&ulSenderCertLen);

    USHORT usTemp;
    pSignature      = pPkt->GetSignature(&usTemp);
    ulSignatureSize = usTemp;
    pSymmKeys       = pPkt->GetEncryptedSymmetricKey(&usTemp);
    ulSymmKeysSize  = usTemp;
    bEncrypted      = (UCHAR)pPkt->IsEncrypted();
    ulPrivLevel     = pPkt->GetPrivLevel();
    ulHashAlg       = pPkt->GetHashAlg();
    ulEncryptAlg    = pPkt->GetEncryptAlg();
    bAuthenticated  = (UCHAR)pPkt->IsAuthenticated();
    bConnector      = (UCHAR)pPkt->ConnectorTypeIsIncluded();

	if(pPkt->IsEodAckIncluded())
	{
		pEodAckStreamId = pPkt->GetPointerToEodAckStreamId();
		EodAckStreamIdSizeInBytes = pPkt->GetEodAckStreamIdSizeInBytes();
		EodAckSeqId = pPkt->GetEodAckSeqId();
		EodAckSeqNum = pPkt->GetEodAckSeqNum();
	}
	else
    {
		pEodAckStreamId = NULL;
		EodAckStreamIdSizeInBytes = 0;
		EodAckSeqId = 0;
		EodAckSeqNum = 0;
	}


	if(pPkt->IsSenderStreamIncluded())
	{
		pSenderStream = pPkt->GetSenderStream();
	}
	else
	{
		pSenderStream = NULL;
	}

    if (ulSignatureSize)
    {
        BOOL bPktDefProv;

        pPkt->GetProvInfo(&bPktDefProv, &wszProvName, &ulProvType);
        bDefProv = (UCHAR)bPktDefProv;
    }
    else
    {
        bDefProv = TRUE;
        wszProvName = NULL;
    }

    //
    // store indication that the class was generated from packet
    //
    fCreatedFromPacket = TRUE;

	pMessageId.detach();
	pCorrelationId.detach();
}

//
// CMessageProperty constructor for acking generation
//
CMessageProperty::CMessageProperty(USHORT usClass,
                                   PUCHAR pCorrelationId,
                                   USHORT usPriority,
                                   UCHAR  ucDelivery)
{
    memset(this, 0, sizeof(CMessageProperty));

    if (pCorrelationId)
    {
        pCorrelationID = new UCHAR[PROPID_M_CORRELATIONID_SIZE];
        ASSERT(pCorrelationID);
        memcpy(pCorrelationID, pCorrelationId, PROPID_M_CORRELATIONID_SIZE);
    }

    wClass          = usClass;
    dwTimeToQueue   = INFINITE;
    dwTimeToLive    = INFINITE;
    bPriority       = (UCHAR)usPriority;
    bDelivery       = ucDelivery;

    //
    // store indication that the the memory was allocated
    //
    fCreatedFromPacket = TRUE;
}

// Saves the changed header persistently
HRESULT CQmPacket::Save()
{
    // NYI
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    QmRd.h

Abstract:
    QM, routing decision interface

Author:
    Uri Habusha (urih), 20-May-2000
--*/

#pragma once

#ifndef __QMRD_H__
#define __QMRD_H__

void
QmRdGetSessionForQueue(
	const CQueue* pQueue,
	CTransportBase** ppSession
	);

#endif // __QMRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrepl_s_.c ===
#pragma warning(push, 3)
#include <qmrepl_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrd.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rd.cpp

Abstract:
    QM interface to Routing Decision (Rd) library

Author:
    Uri Habusha (urih)

--*/

#include "stdh.h"
#include <mqexception.h>
#include "mqstl.h"
#include "Tr.h"
#include "ref.h"
#include "Rd.h"
#include "No.h"
#include "qmta.h"
#include "cqueue.h"
#include "sessmgr.h"

#include "QmRd.tmh"

static WCHAR *s_FN=L"qmrd";

using namespace std;

class CTransportBase;

extern CSessionMgr SessionMgr;

#ifdef _DEBUG

static
void
PrintRoutingTable(
    const GUID* pDestId,
    CRouteTable& RouteTable
    )
{
    WCHAR buff[512];
    LPWSTR p = buff;
    DWORD size = STRLEN(buff) - sizeof(WCHAR);

    int n = _snwprintf(p, size , L"Routing Table for " GUID_FORMAT L"\n", GUID_ELEMENTS(pDestId));
    p += n;
    size -= n;

    n =  _snwprintf(p, size, L"\tFirst priority:");
    p += n;
    size -= n;


    CRouteTable::RoutingInfo::iterator it;
    CRouteTable::RoutingInfo* pRoute = RouteTable.GetNextHopFirstPriority();

    for (it = pRoute->begin(); it != pRoute->end(); ++it)
    {
        n = _snwprintf(p, size, L"%s ", (*it)->GetName());
        if (n < 0)
            goto trace;

        p += n;
        size -= n;
    }

    pRoute = RouteTable.GetNextHopSecondPriority();

    if (pRoute->size() == 0)
        goto trace;

    n =  _snwprintf(p, size, L"\n\tSecond priority:");
    if (n < 0)
	{
        goto trace;
	}

    p += n;
    size -= n;


    for (it = pRoute->begin(); it != pRoute->end(); ++it)
    {
        n = _snwprintf(p, size, L"%s ", (*it)->GetName());
        if (n < 0)
            goto trace;

        p += n;
        size -= n;
    }

trace:
    *p = L'\0';
    TrTRACE(ROUTING, "%ls", buff);

}

#endif


static
DWORD
GetForeignMachineAddress(
	const CACLSID& foreignSitesId,
	CAddress address[],
	DWORD addressTableSize
	)
{
    //
    // BUGBUG: need to avoid the possibility that foreign machine belong to more than one site
    //
    ASSERT(foreignSitesId.cElems == 1);

    if (addressTableSize == 0)
        return 0;

    address[0].AddressType = FOREIGN_ADDRESS_TYPE;
    address[0].AddressLength = FOREIGN_ADDRESS_LEN;
    memcpy(address[0].Address, &foreignSitesId.pElems[0], sizeof(GUID));

    return 1;
}


static
DWORD
GetMachineAddress(
	LPCWSTR machineName,
	CAddress address[],
	DWORD addressTableSize
	)
{
	vector<SOCKADDR_IN> sockAddress;

	bool fSucc = NoGetHostByName(machineName, &sockAddress);

	if (!fSucc)
	{
		TrTRACE(ROUTING, "Failed to retrieve computer: %ls address", machineName);
		return 0;
	}

	DWORD maxNoOfAddress = numeric_cast<DWORD>(sockAddress.size());
	
	if (maxNoOfAddress > addressTableSize)
	{
		maxNoOfAddress = addressTableSize;
	}

	for (DWORD i = 0; i < maxNoOfAddress; ++i)
	{
		address[i].AddressType = IP_ADDRESS_TYPE;
		address[i].AddressLength = IP_ADDRESS_LEN;

		*(reinterpret_cast<ULONG*>(&(address[i].Address))) = sockAddress[i].sin_addr.s_addr;
	}

	return maxNoOfAddress;
}


static
CTransportBase*
GetSessionToNextHop(
	const CRouteTable::RoutingInfo* pNextHopTable,
	const CQueue* pQueue,
	CAddress* pAddress,
	const GUID** pGuid,
	DWORD addressTableSize,
	DWORD* pNoOfAddress
	)
{
	*pNoOfAddress = 0;

	const GUID** pTempGuid = pGuid;
	CAddress* pTempAddr = pAddress;

	for(CRouteTable::RoutingInfo::const_iterator it = pNextHopTable->begin(); it != pNextHopTable->end(); ++it)
	{
        DWORD noOfNewAddress;
        const CRouteMachine* pMachine = (*it).get();

        if (pMachine->IsForeign())
        {
            noOfNewAddress = GetForeignMachineAddress(
                                        pMachine->GetSiteIds(),
                                        pTempAddr,
							            addressTableSize
							            );
        }
        else
        {
		    noOfNewAddress = GetMachineAddress(
							            pMachine->GetName(),
							            pTempAddr,
							            addressTableSize
							            );
        }

		if (noOfNewAddress == 0)
			continue;

		for (DWORD i = 0; i < noOfNewAddress; ++i)
		{
			*pTempGuid = &(*it)->GetId();
			++pTempGuid;
		}

		pTempAddr += noOfNewAddress;
		addressTableSize -= noOfNewAddress;
		*pNoOfAddress += noOfNewAddress;
	}

	CTransportBase* pSession;

    //
    // We never get here for Direct queues, so we ask for session without QoS
    //
	SessionMgr.GetSession(
					SESSION_ONE_TRY,
					pQueue,
					*pNoOfAddress,
					pAddress,
					pGuid,
                    false,
					&pSession
					);

	return pSession;
}


static
HRESULT
GetSessionToNextHop(
    CRouteTable& RouteTable,
	const CQueue* pQueue,
	CTransportBase** ppSession
	)
{
	DWORD MachineNo = numeric_cast<DWORD>(RouteTable.GetNextHopFirstPriority()->size() +
					  RouteTable.GetNextHopSecondPriority()->size());

    //
    // BUGBUG: is it a legal assumption that machine don't have more than 10 address
    //                  Uri Habusha, 23-May-2000
    //
	DWORD addressTableSize = MachineNo * 10;
	SP<CAddress> pAddress;
    StackAllocSP(pAddress, sizeof(CAddress) * addressTableSize);

    SP<const GUID*>    pGuid;
    StackAllocSP(pGuid, sizeof(GUID*) * addressTableSize);

	//
	// try first priority
	//
	DWORD noOfFirstPriorityAddress = 0;
	*ppSession = GetSessionToNextHop(
						RouteTable.GetNextHopFirstPriority(),
						pQueue,
						pAddress.get(),
						pGuid.get(),
						addressTableSize,
						&noOfFirstPriorityAddress
						);

	if (*ppSession != NULL)
		return MQ_OK;

	//
	// try Second priority
	//
	DWORD noOfSecondPriorityAddress = 0;
	*ppSession = GetSessionToNextHop(
						RouteTable.GetNextHopSecondPriority(),
						pQueue,
						pAddress.get() + noOfFirstPriorityAddress,
						pGuid.get() + noOfFirstPriorityAddress,
						addressTableSize - noOfFirstPriorityAddress,
						&noOfSecondPriorityAddress
						);

	if (*ppSession != NULL)
		return MQ_OK;


    //
    // We never get here for Direct queues, so we ask for session without QoS
    //
    HRESULT hr = SessionMgr.GetSession(
						SESSION_RETRY,
						pQueue,
						noOfFirstPriorityAddress + noOfSecondPriorityAddress,
						pAddress.get(),
						pGuid.get(),
                        false,
						ppSession);

	return LogHR(hr, s_FN, 14);
}


void
QmRdGetSessionForQueue(
	const CQueue* pQueue,
	CTransportBase** ppSession
	)
{
	*ppSession = NULL;
	const GUID* pDestId = pQueue->GetRoutingMachine();

    TrTRACE(ROUTING, "Computing route to machine " LOG_GUID_FMT, LOG_GUID(pDestId));

    if (pQueue->IsHopCountFailure())
    {
        RdRefresh();
    }

    CRouteTable RouteTable;
    RdGetRoutingTable(*pDestId, RouteTable);

    #ifdef _DEBUG
        PrintRoutingTable(pDestId, RouteTable);
    #endif

    HRESULT hr = GetSessionToNextHop(RouteTable, pQueue, ppSession);
    if(FAILED(hr))
    {
        TrERROR(ROUTING, "Failed to get a session to next hop Error 0x%x", hr);
        throw bad_hresult(hr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmremote.cpp ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    qmremote.cpp

Abstract:

    Remove Read server side.

Author:

    Doron Juster  	(DoronJ)
    Ilan Herbst		(ilanh) 3-Mar-2002

--*/

#include "stdh.h"
#include "qmrt.h"
#include "qm2qm.h"
#include "qmthrd.h"
#include "acdef.h"
#include "acioctl.h"
#include "acapi.h"
#include "cs.h"
#include "phinfo.h"
#include "qmrpcsrv.h"
#include "license.h"
#include <Fn.h>
#include <version.h>
#include "rpcsrv.h"
#include "qmcommnd.h"
#include "rrSrvCommon.h"

#include "qmacapi.h"

#include "qmremote.tmh"

static WCHAR *s_FN=L"qmremote";

//
// Context map and CS for remote read open contexts.
//
static CContextMap g_map_QM_dwpContext;
static CCriticalSection s_csContextMap;

//-------------------------------------------------------
//
//  Structures and macros for the remote reading code
//
//-------------------------------------------------------

//
// CTX_OPENREMOTE_HANDLE_TYPE status constants.
// xStatusOpenOwner - Context created, Open context is the owner for deleting the context from the map.
// xStatusRRSessionOwner - Ownership was transfered to RRSession context, RRSession is the owner for deleting the context from the map. 
// xStatusDeletedFromContextMapByOpen - Context was deleted from the map by the Open context.
// xStatusDeletedFromContextMapByRRSession - Context was deleted from the map by the RRSession.
//
const LONG xStatusOpenOwner = 0;
const LONG xStatusRRSessionOwner = 1;
const LONG xStatusDeletedFromContextMapByOpen = 2;
const LONG xStatusDeletedFromContextMapByRRSession = 3;


struct CTX_OPENREMOTE_HANDLE_TYPE : public CTX_OPENREMOTE_BASE
{
public:
	CTX_OPENREMOTE_HANDLE_TYPE(
		HANDLE hLocalQueue,
		CQueue* pLocalQueue
		) :
		CTX_OPENREMOTE_BASE(hLocalQueue, pLocalQueue),
		m_dwpContextMapped(0),
		m_ContextStatus(xStatusOpenOwner)
	{
		m_eType = CBaseContextType::eOpenRemoteCtx;
	}


	void CancelAllPendingRemoteReads();

	HRESULT 
	CancelPendingRemoteRead(
		DWORD cli_tag
		);

	void 
	RegisterReadRequest(
		ULONG cli_tag, 
		ULONG srv_tag
		);

	void 
	UnregisterReadRequest(
		DWORD cli_tag
		);

	bool 
	FindReadRequest(
		ULONG cli_tag
		);

private:
	~CTX_OPENREMOTE_HANDLE_TYPE()
	{
	    TrTRACE(RPC, "Cleaning OpenRemote context, Queue = %ls, dwpContextMapped = %d, hQueue = 0x%p", m_pLocalQueue->GetQueueName(), m_dwpContextMapped, m_hQueue);
	}
	

public:
	DWORD m_dwpContextMapped;   // dwpContext, mapped to 32 bit
	LONG m_ContextStatus;		// context status: OpenOwner, RRSessionOwner, DeletedByOpen, DeletedByRRSession	

    //
    // This mapping object is kept in the server side of remote reader.
    // It maps between irp in client side (irp of read request in client
    // side) and the irp on server side.
    // Whenever a remote read is pending (on server side), the mapping
    // are updated.
    // If client side closes the queue (or the client thread terminate),
    // a Cancel or Close is performed. The server side uses the mapping
    // to know which irp to cancel in the driver. 
    // The server get the irp from the client on each call.
    // The server cancel all pending remote reads when closing the queue. 
    //

    CCriticalSection m_srv_PendingRemoteReadsCS;
    std::map<ULONG, ULONG> m_PendingRemoteReads;

};


struct REMOTESESSION_CONTEXT_TYPE : public CBaseContextType
{
public:
	~REMOTESESSION_CONTEXT_TYPE()
	{
		if(pOpenRemoteCtx.get() != NULL)
		{
		    TrTRACE(RPC, "Cleaning RemoteSession context, Queue = %ls, , dwpContextMapped = %d, hQueue = 0x%p, pOpenRemoteCtx Ref = %d", pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), pOpenRemoteCtx->m_dwpContextMapped, pOpenRemoteCtx->m_hQueue, pOpenRemoteCtx->GetRef());
		}
	}

public:
	GUID     ClientQMGuid;
	BOOL     fLicensed;
	R<CTX_OPENREMOTE_HANDLE_TYPE> pOpenRemoteCtx;
};


struct REMOTEREAD_CONTEXT_TYPE : public CBaseContextType
{
public:
	~REMOTEREAD_CONTEXT_TYPE()
	{
		ASSERT(pOpenRemoteCtx.get() != NULL);
	    TrTRACE(RPC, "Cleaning RemoteRead context, Queue = %ls, dwpContextMapped = %d, hQueue = 0x%p, pOpenRemoteCtx Ref = %d", pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), pOpenRemoteCtx->m_dwpContextMapped, pOpenRemoteCtx->m_hQueue, pOpenRemoteCtx->GetRef());
	}

	HACCursor32 GetCursor()
	{
		if(pCursor.get() == NULL)
		{ 
			return 0;
		}

		return pCursor->GetCursor();
	}

public:
	//
	// Note that the order is important because the destruction order.
	// class members are destruct in reverse order of their declaration.
	// R<CTX_OPENREMOTE_HANDLE_TYPE> must be declare before R<CRRCursor>.
	// that way pCursor is released first and call ACCloseCursor while the 
	// CTX_OPENREMOTE_HANDLE_TYPE is still alive and hQueue was not closed yet.
	//
	R<CTX_OPENREMOTE_HANDLE_TYPE> pOpenRemoteCtx;
	R<CRRCursor> pCursor;
	ULONG    ulTimeout;
	ULONG    ulAction;
	CBaseHeader*  lpPacket;
	CPacket* lpDriverPacket;
};


static DWORD AddToContextMap(CTX_OPENREMOTE_HANDLE_TYPE* pctx)
{
    CS Lock(s_csContextMap);

	ASSERT(pctx != NULL);

    DWORD dwContext = ADD_TO_CONTEXT_MAP(g_map_QM_dwpContext, pctx);
	pctx->AddRef();

    return dwContext;
}


static void DeleteFromContextMap(CTX_OPENREMOTE_HANDLE_TYPE* pctx)
{
    CS Lock(s_csContextMap);

	ASSERT(pctx != NULL);

    DELETE_FROM_CONTEXT_MAP(g_map_QM_dwpContext, pctx->m_dwpContextMapped);
    pctx->Release();
}



static R<CTX_OPENREMOTE_HANDLE_TYPE> GetFromContextMap(DWORD dwContext)
{
    CS Lock(s_csContextMap);

	CTX_OPENREMOTE_HANDLE_TYPE* pctx = (CTX_OPENREMOTE_HANDLE_TYPE*)
		GET_FROM_CONTEXT_MAP(g_map_QM_dwpContext, dwContext);

	return SafeAddRef(pctx);
}


//-------------------------------------------------------------------
//
//  HRESULT QMGetRemoteQueueName
//
//-------------------------------------------------------------------


/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMGetRemoteQueueName( 
    /* [in] */   handle_t /*hBind*/,
    /* [in] */   DWORD /* pQueue */,
    /* [string][full][out][in] */ LPWSTR __RPC_FAR* /* lplpRemoteQueueName */
    )
{
	//
	// This RPC interface is obsolete.
	// ACCreateCursor will take care of the remote cursor properties internally in the qm.
    //
    ASSERT_BENIGN(("S_QMGetRemoteQueueName is obsolete RPC interface", 0));
	TrERROR(GENERAL, "S_QMGetRemoteQueueName is obsolete RPC interface");
	RpcRaiseException(MQ_ERROR_ILLEGAL_OPERATION);
}

//-------------------------------------------------------------------
//
//   QMOpenRemoteQueue
//
//  Server side of RPC call. Server side of remote-reader.
//  Open a queue for remote-read on behalf of a client machine.
//
//-------------------------------------------------------------------

/* [call_as] */ 
HRESULT 
qmcomm_v1_0_S_QMOpenRemoteQueue( 
    handle_t /*hBind*/,
    PCTX_OPENREMOTE_HANDLE_TYPE *phContext,
    DWORD                       *dwpContext,
    QUEUE_FORMAT* pQueueFormat,
    DWORD /*dwCallingProcessID*/,
    DWORD dwAccess,
    DWORD fExclusiveReceive,
    GUID* pLicGuid,
    DWORD dwOperatingSystem,
    DWORD *pQueue,
    DWORD *phQueue
    )
{
    TrTRACE(RPC, "In R_QMOpenRemoteQueue");

    if((dwpContext == 0) || (phQueue == NULL) || (pQueue == NULL) || (pQueueFormat == NULL))
    {
		TrERROR(RPC, "Invalid inputs: map index or QueueFormat");
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
    }

    if(!FnIsValidQueueFormat(pQueueFormat))
    {
		TrERROR(RPC, "Invalid QueueFormat");
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
    }

	if (!IsValidAccessMode(pQueueFormat, dwAccess, fExclusiveReceive))
	{
		TrERROR(RPC, "Ilegal access mode bits are turned on.");
		RpcRaiseException(MQ_ERROR_UNSUPPORTED_ACCESS_MODE);
	}

    *phContext = NULL;
    *dwpContext = 0;
    *phQueue = NULL;
    *pQueue = 0;

    if (!g_QMLicense.NewConnectionAllowed(!OS_SERVER(dwOperatingSystem), pLicGuid))
    {
		TrERROR(RPC, "New connection is not allowed, pLicGuid = %!guid!", pLicGuid);
		return MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW;
    }

    CQueue *pLocalQueue = NULL;
	HANDLE hQueue;
    HRESULT hr = OpenQueueInternal(
                        pQueueFormat,
                        GetCurrentProcessId(),
                        dwAccess,
                        fExclusiveReceive,
                        NULL,	// lplpRemoteQueueName
                        &hQueue,
						false,	// fFromDepClient
                        &pLocalQueue
                        );

	if(FAILED(hr) || (hQueue == NULL))
	{
		TrERROR(RPC, "Failed to open queue, %!hresult!", hr);
		return hr;
	}

    //
    // Create a context to hold the queue handle.
    //
    R<CTX_OPENREMOTE_HANDLE_TYPE> pctx = new CTX_OPENREMOTE_HANDLE_TYPE(
    											hQueue,
    											pLocalQueue
    											);
																
    DWORD dwContext = AddToContextMap(pctx.get());

    //
    // save mapped values in context for rundown/cleanup
    //
    pctx->m_dwpContextMapped = dwContext;

	TrTRACE(RPC, "New OpenRemote context (ref = %d): Queue = %ls, hQueue = 0x%p, dwpContextMapped = %d", pctx->GetRef(), pLocalQueue->GetQueueName(), hQueue, dwContext);

	//
    // set return values
	// All server data are in same OpenRemote context. 
    // set srv_pQMQueue and srv_hQueue for RPC client
    //
    *pQueue = dwContext;
	*phQueue = dwContext;
    *dwpContext = dwContext;
    *phContext = (PCTX_OPENREMOTE_HANDLE_TYPE) pctx.detach();

    return hr;
}

//-------------------------------------------------------------------
//
//   QMCloseRemoteQueueContext
//
//  Close the context handle create in QMOpenRemoteQueue.
//
//-------------------------------------------------------------------

/* [call_as] */ 
void 
qmcomm_v1_0_S_QMCloseRemoteQueueContext( 
    /* [out][in] */ PCTX_OPENREMOTE_HANDLE_TYPE __RPC_FAR *pphContext
    )
{
    TrTRACE(RPC, "In QMCloseRemoteQueueContext");

    if(*pphContext == 0)
        return;

    PCTX_OPENREMOTE_HANDLE_TYPE_rundown(*pphContext);
    *pphContext = NULL;
}


//---------------------------------------------------------------
//
//  RunDown functions to handle cleanup in case of RPC failure.
//
//---------------------------------------------------------------

void __RPC_USER
 PCTX_OPENREMOTE_HANDLE_TYPE_rundown( PCTX_OPENREMOTE_HANDLE_TYPE phContext)
{
    CTX_OPENREMOTE_HANDLE_TYPE* pContext = (CTX_OPENREMOTE_HANDLE_TYPE *) phContext;

	if (pContext->m_eType != CBaseContextType::eOpenRemoteCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
		return;
	}

	//
	// Protect the race of transfering the ownership of CTX_OPENREMOTE context
	// to RRSession and deleting the CTX_OPENREMOTE context from the context map
	// in PCTX_OPENREMOTE_HANDLE_TYPE_rundown.
	//
	LONG PrevContextStatus = InterlockedCompareExchange(
											&pContext->m_ContextStatus, 
											xStatusDeletedFromContextMapByOpen, 
											xStatusOpenOwner
											);

	if(PrevContextStatus == xStatusOpenOwner)
	{
		//
		// Exchange was done, the context is marked as deleted from the context map
		// and we are responsible for deleting it from the map.
		//
		ASSERT(pContext->m_ContextStatus == xStatusDeletedFromContextMapByOpen);
		DeleteFromContextMap(pContext);
	}
	
    TrWARNING(RPC, "In OPENREMOTE_rundown, ContextStatus = %d, dwpContextMapped = %d", pContext->m_ContextStatus, pContext->m_dwpContextMapped);

	pContext->Release();
}




//-------------------------------------------------------------------
//
//  HRESULT QMCreateRemoteCursor
//
//  Server side of RPC call. Server side of remote-reader.
//  Create a cursor for remote-read, on behalf of a client reader.
//
//-------------------------------------------------------------------

/* [async][call_as] */ 
void
qmcomm_v1_0_S_QMCreateRemoteCursor( 
	/* [in] */ PRPC_ASYNC_STATE   pAsync,
    /* [in] */  handle_t          hBind,
    /* [in] */  struct CACTransferBufferV1 __RPC_FAR *,
    /* [in] */  DWORD             hQueue,
    /* [out] */ DWORD __RPC_FAR * phCursor
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INVALID_HANDLE, __FUNCTION__);
	
	try
	{
		R<CTX_OPENREMOTE_HANDLE_TYPE> pctx = GetFromContextMap(hQueue);
		HANDLE hQueueReal = pctx->m_hQueue;

		SetRpcServerKeepAlive(hBind);

		AsyncComplete.SetHrForCompleteCall(MQ_ERROR_INSUFFICIENT_RESOURCES);		

		R<CRRCursor> pCursor = new CRRCursor;

	    HACCursor32 hCursor = 0;
		HRESULT hr = ACCreateCursor(hQueueReal, &hCursor);
	    ASSERT(hr != STATUS_PENDING);
		*phCursor = (DWORD) hCursor;

		if(SUCCEEDED(hr))
		{
			TrTRACE(RPC, "S_QMCreateRemoteCursor, hQueue = %d, hCursor = %d", hQueue, (DWORD)hCursor);

			pCursor->SetCursor(hQueueReal, hCursor);
			pctx->AddCursorToMap(
					(ULONG) hCursor,
					pCursor
					);
		}

		AsyncComplete.SetHrForCompleteCall(hr);		
	}
	catch(const exception&)
	{
		//
		// We don't want to AbortCall and propogate the exception. this cause RPC to AV
		// So we only abort the call in AsyncComplete dtor
		//
		TrERROR(RPC, "Unknown exception while creating a remote curosor.");
	}
}

//-------------------------------------------------------------------
//
// HRESULT qm2qm_v1_0_R_QMRemoteCloseCursor(
//
//  Server side of RPC call. Server side of remote-reader.
//  Close a remote cursor in local driver.
//
//-------------------------------------------------------------------

/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemoteCloseCursor(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD hQueue,
    /* [in] */ DWORD hCursor
    )
{
    TrTRACE(RPC, "R_QMRemoteCloseCursor, hQueue = %d, hCursor = %d", hQueue, hCursor);

	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INVALID_HANDLE, __FUNCTION__);

	SetRpcServerKeepAlive(hBind);

	try
	{
		R<CTX_OPENREMOTE_HANDLE_TYPE> pctx = GetFromContextMap(hQueue);
		HRESULT hr = pctx->RemoveCursorFromMap(hCursor);

		AsyncComplete.SetHrForCompleteCall(hr);		
	}
	catch(const exception&)
	{
		//
		// We don't want to AbortCall and propogate the exception. this cause RPC to AV
		// So we only abort the call in AsyncComplete dtor
		//
	}
}

//-------------------------------------------------------------------
//
// HRESULT qm2qm_v1_0_R_QMRemotePurgeQueue(
//
//  Server side of RPC call. Server side of remote-reader.
//  Purge local queue.
//
//-------------------------------------------------------------------

/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemotePurgeQueue(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD hQueue
    )
{
	TrTRACE(RPC, "R_QMRemotePurgeQueue, hQueue = %d", hQueue);

	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INVALID_HANDLE, __FUNCTION__);

	SetRpcServerKeepAlive(hBind);

	try
	{
		R<CTX_OPENREMOTE_HANDLE_TYPE> pctx = GetFromContextMap(hQueue);
		HANDLE hQueueReal = pctx->m_hQueue;

		HRESULT hr = ACPurgeQueue(hQueueReal);

		AsyncComplete.SetHrForCompleteCall(hr);		
	}
	catch(const exception&)
	{
		//
		// We don't want to AbortCall and propogate the exception. this cause RPC to AV
		// So we only abort the call in AsyncComplete dtor
		//
	}
}


VOID
qm2qm_v1_0_R_QMRemoteGetVersion(
    handle_t           /*hBind*/,
    UCHAR  __RPC_FAR * pMajor,
    UCHAR  __RPC_FAR * pMinor,
    USHORT __RPC_FAR * pBuildNumber
    )
/*++

Routine Description:

    Return version of this QM. RPC server side.

Arguments:

    hBind        - Binding handle.

    pMajor       - Points to output buffer to receive major version. May be NULL.

    pMinor       - Points to output buffer to receive minor version. May be NULL.

    pBuildNumber - Points to output buffer to receive build number. May be NULL.

Return Value:

    None.

--*/
{
    if (pMajor != NULL)
    {
        (*pMajor) = rmj;
    }

    if (pMinor != NULL)
    {
        (*pMinor) = rmm;
    }

    if (pBuildNumber != NULL)
    {
        (*pBuildNumber) = rup;
    }
} // qm2qm_v1_0_R_QMRemoteGetVersion


HRESULT 
CTX_OPENREMOTE_HANDLE_TYPE::CancelPendingRemoteRead(
	ULONG cli_tag
	)
/*++
Routine Description:
	Cancel specific pending remote reads on the CTX_OPENREMOTE.

	This method is called on the server side to cancel a pending remote
	read request. It is the responsibility of the client side to request
	this cancelation.
	The client side supply its own irp and the server side uses it to
	retreive the server side irp.

Arguments:
	cli_tag - Client irp tag.

Returned Value:
	HRESULT.

--*/
{
    CS lock(m_srv_PendingRemoteReadsCS);

    std::map<ULONG, ULONG>::iterator it = m_PendingRemoteReads.find(cli_tag);
   	if(it == m_PendingRemoteReads.end())
    {
        return LogHR(MQ_ERROR, s_FN, 140);
    }

    HRESULT hr = ACCancelRequest(
			            m_hQueue,
			            MQ_INFORMATION_REMOTE_CANCELED_BY_CLIENT,
			            it->second
			            );

    return LogHR(hr, s_FN, 150);
}


void CTX_OPENREMOTE_HANDLE_TYPE::CancelAllPendingRemoteReads()
/*++
Routine Description:
	Cancel all pending remote reads on the CTX_OPENREMOTE.

Arguments:
	None.

Returned Value:
	None.

--*/
{
    CS lock(m_srv_PendingRemoteReadsCS);

	for(std::map<ULONG, ULONG>::iterator it = m_PendingRemoteReads.begin(); 
		it != m_PendingRemoteReads.end();
		++it
		)
    {
	    HRESULT hr = ACCancelRequest(
				            m_hQueue,
				            MQ_ERROR_OPERATION_CANCELLED,
				            it->second
				            );

		if(FAILED(hr))
		{
			TrERROR(RPC, "Cancel Pending Remote Read failed, cli_tag = %d, %!hresult!", it->first, hr);
		}
    }
}


void 
CTX_OPENREMOTE_HANDLE_TYPE::RegisterReadRequest(
	ULONG cli_tag, 
	ULONG srv_tag
	)
/*++
Routine Description:
	Register Read Request in the pending remote reads on the CTX_OPENREMOTE.

Arguments:
	cli_tag - Client irp tag.
	srv_tag - Server irp tag.

Returned Value:
	None.

--*/
{
	CS lock(m_srv_PendingRemoteReadsCS);

	ASSERT(!FindReadRequest(cli_tag));

    m_PendingRemoteReads[cli_tag] = srv_tag;
}


void 
CTX_OPENREMOTE_HANDLE_TYPE::UnregisterReadRequest(
	ULONG cli_tag
	)
/*++
Routine Description:
	UnRegister Read Request in the pending remote reads on the CTX_OPENREMOTE.

Arguments:
	cli_tag - Client irp tag.

Returned Value:
	None.

--*/
{
    CS lock(m_srv_PendingRemoteReadsCS);

	ASSERT(!m_PendingRemoteReads.empty());

    m_PendingRemoteReads.erase(cli_tag);
}


bool 
CTX_OPENREMOTE_HANDLE_TYPE::FindReadRequest(
	ULONG cli_tag
	)
/*++
Routine Description:
	Check if cli_tag is found in Pending Remote read maps.

Arguments:
	cli_tag - Client irp tag.

Returned Value:
	true if cli_tag was found in the map, false if not.

--*/
{
    CS lock(m_srv_PendingRemoteReadsCS);

    std::map<ULONG, ULONG>::iterator it = m_PendingRemoteReads.find(cli_tag);
   	if(it == m_PendingRemoteReads.end())
    {
        return false;
    }

	return true;
}


/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemoteEndReceive(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
    /* [in] */ handle_t  hBind,
    /* [in, out] */ PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    /* [in] */ DWORD  dwAck 
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INVALID_HANDLE, __FUNCTION__);

    REMOTEREAD_CONTEXT_TYPE* pRemoteReadContext = (REMOTEREAD_CONTEXT_TYPE*) *phContext;

    if(pRemoteReadContext == NULL)
	{
		TrERROR(GENERAL, "invalid context: RemoteRead context is NULL");
		return;
	}

	if (pRemoteReadContext->m_eType != CBaseContextType::eRemoteReadCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
		return;
	}

    SetRpcServerKeepAlive(hBind);

	ASSERT(pRemoteReadContext->pOpenRemoteCtx.get() != NULL);
	ASSERT(pRemoteReadContext->pOpenRemoteCtx->GetRef() >= 1);

	HRESULT hr = QMRemoteEndReceiveInternal(
						pRemoteReadContext->pOpenRemoteCtx->m_hQueue,
						pRemoteReadContext->GetCursor(),
						pRemoteReadContext->ulTimeout,
						pRemoteReadContext->ulAction,
						(REMOTEREADACK) dwAck,
						pRemoteReadContext->lpPacket,
						pRemoteReadContext->lpDriverPacket
						);

	delete pRemoteReadContext;
    *phContext = NULL;

	AsyncComplete.SetHrForCompleteCall(hr);		
}


static
CBaseHeader* 
ConvertPacketToOldFormat(
	CQmPacket& ThisPacket, 
	DWORD& NewSize
	)
/*++
Routine Description:
	Convert an HTTP packet to an ordinay msmq2,msmq1 compatible packet.
	This mainly includes moving the body form the http section to the 
	regular place in the property section .

Arguments:
	CQmPacket& ThisPacket: The old packet to be converted.
	DWORD& NewSize: An out pram, the size of the new packet.

Returned Value:
	A pointer to the new packet.
--*/
	
{
   	DWORD BodySize;
	const UCHAR* pBody = ThisPacket.GetPacketBody(&BodySize);

	//
	// Calculate the size of the new packet.
	//
	CBaseHeader *pHeaderSection = ThisPacket.GetPointerToPacket();
	CPropertyHeader *pPropertySection = pHeaderSection->section_cast<CPropertyHeader*>(ThisPacket.GetPointerToPropertySection());
	
	DWORD OfsetToPropertySection = (UCHAR*)pPropertySection - (UCHAR*)pHeaderSection; 
	DWORD PropertySectionSize = (UCHAR*)pPropertySection->GetNextSection() - (UCHAR*)pPropertySection;
	NewSize = OfsetToPropertySection + PropertySectionSize + BodySize;

	//
	// Allocate a buffer for the new packet.
	//
	AP<CBaseHeader> pBaseHeader = (CBaseHeader*)(new BYTE[NewSize]);

	//
	// Copy the old packet up to the body.
	//
	MoveMemory(pBaseHeader, ThisPacket.GetPointerToPacket(), OfsetToPropertySection + PropertySectionSize);

	//
	// Fix Base header.
	//
	pBaseHeader->SetPacketSize(NewSize);

	//
	// Fix the user header.
	//
	CUserHeader* pUserHeader = pBaseHeader->section_cast<CUserHeader*>(pBaseHeader->GetNextSection());
	pUserHeader->IncludeMqf(false);
	pUserHeader->IncludeSrmp(false);
	pUserHeader->IncludeEod(false);
	pUserHeader->IncludeEodAck(false);
	pUserHeader->IncludeSoap(false);
	pUserHeader->IncludeSenderStream(false);

    //
    // Fix Property Section (set the body in it's new place).
    //

	CPropertyHeader* pPropertyHeader = pBaseHeader->section_cast<CPropertyHeader*>((BYTE*)pBaseHeader.get() + OfsetToPropertySection);
    pPropertyHeader->SetBody(pBody, BodySize, BodySize);

	return pBaseHeader.detach();
}


//---------------------------------------------------------
//
//  HRESULT QMpRemoteStartReceive
//
//---------------------------------------------------------

static
HRESULT
QMpRemoteStartReceive(
    handle_t hBind,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC2 __RPC_FAR *lpRemoteReadDesc2,
    bool fReceiveByLookupId,
    ULONGLONG LookupId,
    bool fOldClient
    )
{
	TrTRACE(RPC, "In QMpRemoteStartReceive");

    //
    // Validate network incomming parameters
    //
    if(lpRemoteReadDesc2 == NULL)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1690);

    REMOTEREADDESC __RPC_FAR *lpRemoteReadDesc = lpRemoteReadDesc2->pRemoteReadDesc;

    if(lpRemoteReadDesc == NULL)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1691);

    if((lpRemoteReadDesc->dwpQueue == 0) || 
       (lpRemoteReadDesc->dwpQueue != lpRemoteReadDesc->hRemoteQueue))
    {
		//
		// Validate that the 2 map indexs are valid and equal.
		// qmcomm_v1_0_S_QMOpenRemoteQueue sets all map indexs to the same value.
		//
		ASSERT_BENIGN(lpRemoteReadDesc->dwpQueue == lpRemoteReadDesc->hRemoteQueue);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1692);
    }
    
    if(fReceiveByLookupId && (lpRemoteReadDesc->ulTimeout != 0))
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1693);

    if(fReceiveByLookupId && (lpRemoteReadDesc->hCursor != 0))
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1694);


    //
    // This is server side of remote read. It may happen that before client
    // perform a read, the server crashed and reboot. In that case,
    // a subsequent read, using the same binding handle in the client side,
    // will reach here, where pQueue is not valid. The try/except will
    // guard against such bad events.  Bug #1921
    //
    HRESULT hr = MQ_ERROR;
	CACPacketPtrs  packetPtrs = {NULL, NULL};


    try
    {
		SetRpcServerKeepAlive(hBind);

		R<CTX_OPENREMOTE_HANDLE_TYPE> pctx = GetFromContextMap(lpRemoteReadDesc->dwpQueue);

		CQueue* pQueue = pctx->m_pLocalQueue.get();
		HANDLE hQueue = pctx->m_hQueue;

		TrTRACE(RPC, "StartReceive: Queue = %ls, hQueue = 0x%p, Action = 0x%x, Timeout = %d, LookupId = %I64d, hCursor = %d, dwRequestID = %d", pctx->m_pLocalQueue->GetQueueName(), pctx->m_hQueue, lpRemoteReadDesc->ulAction, lpRemoteReadDesc->ulTimeout, LookupId, lpRemoteReadDesc->hCursor, lpRemoteReadDesc->dwRequestID);

		if (pQueue->GetSignature() !=  QUEUE_SIGNATURE)
		{
			 TrERROR(RPC, "Exit QMpRemoteStartReceive, Invalid Signature");
			 return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 180);
		}

		OVERLAPPED Overlapped = {0};		
		hr = GetThreadEvent(Overlapped.hEvent);		
		if(FAILED(hr))			
			return hr;

		{
		    CS lock(pctx->m_srv_PendingRemoteReadsCS);

			if(pctx->FindReadRequest(lpRemoteReadDesc->dwRequestID))
			{
				ASSERT_BENIGN(("Client Tag already exist in the map", 0));
				TrERROR(RPC, "Duplicate dwRequestID = %d", lpRemoteReadDesc->dwRequestID);
		        return MQ_ERROR_INVALID_PARAMETER;
			}

			ULONG ulTag;
			CACGet2Remote g2r;

			g2r.Cursor = (HACCursor32) lpRemoteReadDesc->hCursor;
			g2r.Action = lpRemoteReadDesc->ulAction;
			g2r.RequestTimeout = lpRemoteReadDesc->ulTimeout;
			g2r.pTag = &ulTag;
			g2r.fReceiveByLookupId = fReceiveByLookupId;
			g2r.LookupId = LookupId;

			hr = QmAcSyncBeginGetPacket2Remote(
					hQueue,
					g2r,
					packetPtrs,
					&Overlapped 
					);

			//
			//  Register this pending read request.
			//
			pctx->RegisterReadRequest(
						lpRemoteReadDesc->dwRequestID,
						ulTag
						);
		}			

		//
		// Receive by lookup ID should never return status pending
		//
		ASSERT(hr != STATUS_PENDING || !fReceiveByLookupId);

		if (hr == STATUS_PENDING)
		{
			//
			//  Wait for receive completion
			//
			DWORD dwResult;
			dwResult = WaitForSingleObject(Overlapped.hEvent, INFINITE);
			ASSERT(dwResult == WAIT_OBJECT_0);
			if (dwResult != WAIT_OBJECT_0)
			{
				LogNTStatus(GetLastError(), s_FN, 197);
			}

			hr = DWORD_PTR_TO_DWORD(Overlapped.Internal);
			if (FAILED(hr))
			{
				QmAcInternalUnreserve(1); // Unreserve item allocated on the call to QmAcBeginPacket2Remote
			}

		}

		pctx->UnregisterReadRequest(
		          lpRemoteReadDesc->dwRequestID
		          );

		if(hr != MQ_OK)
		{
			//
			// When the client cancel the remote read request the call will be canceled with
			// MQ_INFORMATION_REMOTE_CANCELED_BY_CLIENT.
			// this is the reason we check hr != MQ_OK and not FAILED(hr)
			//
			ASSERT(packetPtrs.pPacket == NULL);
			TrERROR(RPC, "Failed to get packet for remote, hr = %!hresult!", hr);
			return hr;
		}

		//
		// MSMQ 1.0 sees the reserved field as a packet pointer and asserts that is non zero.
		//
	
		lpRemoteReadDesc->Reserved = 1;
		CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(packetPtrs.pPacket) - 1;
		lpRemoteReadDesc->dwArriveTime = pInfo->ArrivalTime();
		lpRemoteReadDesc2->SequentialId = pInfo->SequentialId();

		//
	    // Set the packet signature
	    //
		packetPtrs.pPacket->SetSignature();

		bool fOldClientReadingHttpMessage = false;
		if(fOldClient)
		{
			CQmPacket ThisPacket(packetPtrs.pPacket, packetPtrs.pDriverPacket);
			if(ThisPacket.IsSrmpIncluded())
			{
				//
				// An old client (w2k or nt4) trying to read an http message.
				// Need to convert the message to old format that old clients can read 
				// because in http message the body is in the CompoundMessage section
				// and not in the property section. If this change is not made the old
				// client will not see the message body.
				//
				fOldClientReadingHttpMessage = true;
				DWORD NewSize;
				lpRemoteReadDesc->lpBuffer = (BYTE*)ConvertPacketToOldFormat(ThisPacket, NewSize);
				lpRemoteReadDesc->dwSize = NewSize;
			}				
		}
		if(!fOldClientReadingHttpMessage)
		{
			//
			// XP client or an old client reading a none http message.
			//
			DWORD dwSize = PACKETSIZE(packetPtrs.pPacket);
			lpRemoteReadDesc->dwSize = dwSize;
			lpRemoteReadDesc->lpBuffer = new unsigned char [dwSize];
			MoveMemory(lpRemoteReadDesc->lpBuffer, packetPtrs.pPacket, dwSize);
		}
		

		if ((lpRemoteReadDesc->ulAction & MQ_ACTION_PEEK_MASK) == MQ_ACTION_PEEK_MASK ||
			(lpRemoteReadDesc->ulAction & MQ_LOOKUP_PEEK_MASK) == MQ_LOOKUP_PEEK_MASK)
		{
			//
			// For PEEK we don't need any ack/nack from client side because
			// packet remain in queue anyway.
			// Neverthless we need to free the clone packet we've got.
			//
		    QmAcFreePacket( 
				   packetPtrs.pDriverPacket, 
				   0, 
		   		   eDeferOnFailure
		   		   );

			return MQ_OK;
		}

		//
		//  Prepare a rpc context, in case that EndRecieve will not
		//  be called because of client side crash or net problems.
		//
		REMOTEREAD_CONTEXT_TYPE* pRemoteReadContext = new REMOTEREAD_CONTEXT_TYPE;

		pRemoteReadContext->m_eType = CBaseContextType::eRemoteReadCtx;

		//
		// The assignment AddRef pctx 
		//
		pRemoteReadContext->pOpenRemoteCtx = pctx;
		if(lpRemoteReadDesc->hCursor != 0)
		{
			//
			// Take reference on Cursor object
			//
			pRemoteReadContext->pCursor = pctx->GetCursorFromMap(lpRemoteReadDesc->hCursor);
		}
		pRemoteReadContext->lpPacket = packetPtrs.pPacket;
		pRemoteReadContext->lpDriverPacket = packetPtrs.pDriverPacket;
		pRemoteReadContext->ulTimeout = lpRemoteReadDesc->ulTimeout;
		pRemoteReadContext->ulAction = lpRemoteReadDesc->ulAction;

		*phContext = (PCTX_REMOTEREAD_HANDLE_TYPE) pRemoteReadContext;

		TrTRACE(RPC, "New RemoteRead Context: pOpenRemoteCtx Ref = %d, Queue = %ls, hQueue = 0x%p, dwpContextMapped = %d", pRemoteReadContext->pOpenRemoteCtx->GetRef(), pRemoteReadContext->pOpenRemoteCtx->m_pLocalQueue->GetQueueName(), pRemoteReadContext->pOpenRemoteCtx->m_hQueue, pRemoteReadContext->pOpenRemoteCtx->m_dwpContextMapped);
		return MQ_OK;
	}
	catch(const bad_alloc&)
	{
		hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		hr = MQ_ERROR_INVALID_HANDLE;
	}

	if(packetPtrs.pDriverPacket != NULL)
	{
	    QmAcFreePacket( 
			   packetPtrs.pDriverPacket, 
			   0, 
	   		   eDeferOnFailure
	   		   );
	}

	TrERROR(RPC, "Start Receive failed, dwRequestID = %d, hr = %!hresult!", lpRemoteReadDesc->dwRequestID, hr);
	return hr;

} // QMpRemoteStartReceive

//---------------------------------------------------------
//
//  HRESULT qm2qmV2_v1_0_R_QMRemoteStartReceiveByLookupId
//
//  Server side of RPC for remote reading using lookup ID.
//  Handle MSMQ 3.0 (Whistler) or higher clients.
//
//---------------------------------------------------------

/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemoteStartReceiveByLookupId(
	PRPC_ASYNC_STATE pAsync,
    handle_t hBind,
    ULONGLONG LookupId,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC2 __RPC_FAR *pDesc2
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

    HRESULT hr = QMpRemoteStartReceive(
					   hBind,
					   phContext,
					   pDesc2,
					   true,
					   LookupId,
					   false
					   );

	AsyncComplete.SetHrForCompleteCall(hr);		

} // qm2qm_v1_0_R_QMRemoteStartReceiveByLookupId

//-------------------------------------------------------------------------
//
//  HRESULT qm2qm_v1_0_R_QMRemoteStartReceive
//
//  Server side of RPC for remote reading.
//  Handle MSMQ 1.0 and 2.0 clients.
//
//-------------------------------------------------------------------------

/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemoteStartReceive(
	PRPC_ASYNC_STATE pAsync,
    handle_t hBind,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC __RPC_FAR *pDesc
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

    REMOTEREADDESC2 Desc2;
    Desc2.pRemoteReadDesc = pDesc;
    Desc2.SequentialId = 0;

    HRESULT hr = QMpRemoteStartReceive(
					   hBind,
					   phContext,
					   &Desc2,
					   false,
					   0,
					   true
					   );

	AsyncComplete.SetHrForCompleteCall(hr);		

} // qm2qm_v1_0_R_QMRemoteStartReceive


//-------------------------------------------------------------------------
//
//  HRESULT qm2qm_v1_0_R_QMRemoteStartReceive2
//
//  Server side of RPC for remote reading.
//  Handle MSMQ 3.0 (Whistler) or higher clients.
//
//-------------------------------------------------------------------------

/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemoteStartReceive2(
	PRPC_ASYNC_STATE pAsync,
    handle_t hBind,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC2 __RPC_FAR *pDesc2
    )
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

    HRESULT hr = QMpRemoteStartReceive(
					   hBind,
					   phContext,
					   pDesc2,
					   false,
					   0,
					   false
					   );

	AsyncComplete.SetHrForCompleteCall(hr);		

} // qm2qm_v1_0_R_QMRemoteStartReceive2


//---------------------------------------------------------------
//
//   /* [call_as] */ HRESULT qm2qm_v1_0_R_QMRemoteOpenQueue
//
//  Server side of RPC. Open a session with the queue.
//  This function merely construct the context handle for this
//  Remote-Read session.
//
//---------------------------------------------------------------

/* [call_as] */ 
HRESULT
qm2qm_v1_0_R_QMRemoteOpenQueue(
    /* [in] */ handle_t hBind,
    /* [out] */ PCTX_RRSESSION_HANDLE_TYPE __RPC_FAR *phContext,
    /* [in] */ GUID  *pLicGuid,
    /* [in] */ DWORD dwMQS,
    /* [in] */ DWORD /*hQueue*/,
    /* [in] */ DWORD dwpQueue,
    /* [in] */ DWORD dwpContext
    )
{
	TrTRACE(RPC, "In R_QMRemoteOpenQueue");

	if ((pLicGuid == NULL) || (*pLicGuid == GUID_NULL))
	{
		ASSERT_BENIGN((pLicGuid != NULL) && (*pLicGuid != GUID_NULL));
		TrERROR(RPC, "Invalid License Guid");
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}
	
	if((dwpQueue == 0) || (dwpContext == 0) || (dwpQueue != dwpContext))
	{
		//
		// Validate that the 2 map indexs are valid and equal.
		// qmcomm_v1_0_S_QMOpenRemoteQueue sets all map indexs to the same value.
		//
		ASSERT_BENIGN(dwpContext != 0);
		ASSERT_BENIGN(dwpQueue == dwpContext);
		TrERROR(RPC, "Invalid context map indexes, dwpQueue = %d, dwpContext = %d", dwpQueue, dwpContext);
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
	}
	
	SetRpcServerKeepAlive(hBind);

	//
	// "dwpContext" is the index in the ContextMap of the CTX_OPENREMOTE pointer 
	// allocated by server side QM when called from QMRT interface (in "QMOpenRemoteQueue()").
	//
	R<CTX_OPENREMOTE_HANDLE_TYPE> pctx = GetFromContextMap(dwpContext);

	ASSERT(pctx->m_eType == CBaseContextType::eOpenRemoteCtx);

	try
	{
		P<REMOTESESSION_CONTEXT_TYPE> pRemoteSessionContext = new REMOTESESSION_CONTEXT_TYPE;

		//
		// Protect the race of transfering the ownership of CTX_OPENREMOTE context
		// to RRSession and deleting the CTX_OPENREMOTE context from the context map
		// in PCTX_OPENREMOTE_HANDLE_TYPE_rundown.
		//
		LONG PrevContextStatus = InterlockedCompareExchange(
										&pctx->m_ContextStatus, 
										xStatusRRSessionOwner, 
										xStatusOpenOwner
										);

		if(PrevContextStatus != xStatusOpenOwner)
		{
			//
			// Exchange was not performed.
			// This means CTX_OPENREMOTE context was deleted from context map.
			//
			ASSERT(PrevContextStatus == xStatusDeletedFromContextMapByOpen);
			TrERROR(RPC, "CTX_OPENREMOTE context was deleted by rundown");
			RpcRaiseException(MQ_ERROR_INVALID_HANDLE);
		}

		//
		// Exchange was done
		// ownership of mapped Context was transfered to RRSession context
		//
		ASSERT(pctx->m_ContextStatus == xStatusRRSessionOwner);
	
		pRemoteSessionContext->m_eType = CBaseContextType::eRemoteSessionCtx;
		pRemoteSessionContext->ClientQMGuid = *pLicGuid;
		pRemoteSessionContext->fLicensed = (dwMQS == SERVICE_NONE); //[adsrv] Keeping - RR protocol is ironclade

		//
		// The assignment AddRef pctx 
		//
		pRemoteSessionContext->pOpenRemoteCtx = pctx;

		if (pRemoteSessionContext->fLicensed)
		{
			g_QMLicense.IncrementActiveConnections(pLicGuid, NULL);
		}

		*phContext = (PCTX_RRSESSION_HANDLE_TYPE) pRemoteSessionContext.detach();

		TrTRACE(RPC, "New RemoteSession Context: Ref = %d, Queue = %ls", pctx->GetRef(), pctx->m_pLocalQueue->GetQueueName());

		return MQ_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(RPC, "Failed to allocate RemoteSession context");
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//---------------------------------------------------------------
//
//   QMRemoteCloseQueueInternal
//
//  Server side of RPC. Close the queue and free the rpc context.
//
//---------------------------------------------------------------

static
HRESULT 
QMRemoteCloseQueueInternal(
     IN      handle_t                              hBind,
     IN      bool                                  bSetKeepAlive,
     IN OUT  PCTX_RRSESSION_HANDLE_TYPE __RPC_FAR *phContext 
     )
{
    TrTRACE(RPC, "In QMRemoteCloseQueueInternal");

    if(*phContext == 0)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 3001);

    REMOTESESSION_CONTEXT_TYPE* pRemoteSessionContext =
                             (REMOTESESSION_CONTEXT_TYPE*) *phContext;

	if (pRemoteSessionContext->m_eType != CBaseContextType::eRemoteSessionCtx)
	{
		TrERROR(GENERAL, "Received invalid handle");
		return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 3011);
	}

    if (bSetKeepAlive)
    {
        SetRpcServerKeepAlive(hBind);
    }

    if (pRemoteSessionContext->fLicensed)
    {
        g_QMLicense.DecrementActiveConnections(
                                &(pRemoteSessionContext->ClientQMGuid));
    }

	ASSERT(pRemoteSessionContext->pOpenRemoteCtx.get() != NULL);

    TrTRACE(RPC, "Cleaning CTX_OPENREMOTE_HANDLE_TYPE, dwpContextMapped = %d", pRemoteSessionContext->pOpenRemoteCtx->m_dwpContextMapped);

	//
	// REMOTESESSION_CONTEXT is holding reference to CTX_OPENREMOTE_HANDLE
	// until we delete REMOTESESSION_CONTEXT, CTX_OPENREMOTE_HANDLE can't be deleted.
	//
	CTX_OPENREMOTE_HANDLE_TYPE* pctx = pRemoteSessionContext->pOpenRemoteCtx.get();

	//
	// Cancel all pending remote reads in this session.
	//
	pctx->CancelAllPendingRemoteReads();

	//
	// RRSession must be the owner
	// 
	ASSERT(pctx->m_ContextStatus == xStatusRRSessionOwner);
	pctx->m_ContextStatus = xStatusDeletedFromContextMapByRRSession;
	DeleteFromContextMap(pctx);

    delete pRemoteSessionContext;
    *phContext = NULL;

	return MQ_OK;
}

//---------------------------------------------------------------
//
//   /* [call_as] */ HRESULT qm2qm_v1_0_R_QMRemoteCloseQueue
//
//  Server side of RPC. Close the queue and free the rpc context.
//
//---------------------------------------------------------------

/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemoteCloseQueue(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
	/* [in] */ handle_t hBind,
	/* [in, out] */ PCTX_RRSESSION_HANDLE_TYPE __RPC_FAR *phContext 
	)
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INSUFFICIENT_RESOURCES, __FUNCTION__);

    HRESULT hr = QMRemoteCloseQueueInternal( 
						hBind,
						true,  //  bSetKeepAlive
						phContext 
						);

	AsyncComplete.SetHrForCompleteCall(hr);		
}

//---------------------------------------------------------------
//
//  /* [call_as] */ HRESULT qm2qm_v1_0_R_QMRemoteCancelReceive
//
//  Server side of RPC. Cancel a pending read request
//
//---------------------------------------------------------------

/* [async][call_as] */ 
void
qm2qm_v1_0_R_QMRemoteCancelReceive(
	/* [in] */ PRPC_ASYNC_STATE pAsync,
	/* [in] */ handle_t hBind,
	/* [in] */ DWORD hQueue,
	/* [in] */ DWORD dwpQueue,
	/* [in] */ DWORD Tag
	)
{
	CRpcAsyncServerFinishCall AsyncComplete(pAsync, MQ_ERROR_INVALID_PARAMETER, __FUNCTION__);

    if((dwpQueue == 0) || (hQueue != dwpQueue))
	{
		//
		// Validate that the 2 map indexs are valid and equal.
		// qmcomm_v1_0_S_QMOpenRemoteQueue sets all map indexs to the same value.
		//
		ASSERT_BENIGN(hQueue == dwpQueue);
		TrERROR(GENERAL, "invalid context map index");
		return;
	}

    TrTRACE(RPC, "CancelReceive: dwpQueue = %d, Tag = %d", dwpQueue, Tag);

	AsyncComplete.SetHr(MQ_ERROR_INVALID_HANDLE);		

    SetRpcServerKeepAlive(hBind);

	try
	{
		R<CTX_OPENREMOTE_HANDLE_TYPE> pctx = GetFromContextMap(dwpQueue);
	    HRESULT hr = pctx->CancelPendingRemoteRead(Tag);

		AsyncComplete.SetHrForCompleteCall(hr);		
	}
	catch(const exception&)
	{
		//
		// We don't want to AbortCall and propogate the exception. this cause RPC to AV
		// So we only abort the call in AsyncComplete dtor
		//
	}
}

//---------------------------------------------------------------
//
//  RunDown functions to handle cleanup in case of RPC failure.
//  Calls from client QM to remote QM
//
//---------------------------------------------------------------

void __RPC_USER
PCTX_RRSESSION_HANDLE_TYPE_rundown(PCTX_RRSESSION_HANDLE_TYPE hContext)
{
    TrWARNING(RPC,"In RRSESSION_rundown");

    QMRemoteCloseQueueInternal( 
		NULL,
		false,  //  bSetKeepAlive
		&hContext 
		);
}


void __RPC_USER
PCTX_REMOTEREAD_HANDLE_TYPE_rundown(PCTX_REMOTEREAD_HANDLE_TYPE phContext )
{
	TrWARNING(RPC, "In REMOTEREAD_rundown");
	ASSERT(phContext);

	if (phContext)
	{
		//
		// on rundown we nack the packet and return it to the queue.
		// If the remote client actually read it (network failed after
		// it read) then the packet is duplicated. The rundown prevents
		// loss of packets.
		//
		REMOTEREAD_CONTEXT_TYPE* pRemoteReadContext =
		                      (REMOTEREAD_CONTEXT_TYPE *) phContext;

		if (pRemoteReadContext->m_eType != CBaseContextType::eRemoteReadCtx)
		{
			TrERROR(GENERAL, "Received invalid handle");
			return;
		}

		ASSERT(pRemoteReadContext->pOpenRemoteCtx.get() != NULL);
		ASSERT(pRemoteReadContext->pOpenRemoteCtx->GetRef() >= 1);
		
		HRESULT hr = QMRemoteEndReceiveInternal( 
						pRemoteReadContext->pOpenRemoteCtx->m_hQueue,
						pRemoteReadContext->GetCursor(),
						pRemoteReadContext->ulTimeout,
						pRemoteReadContext->ulAction,
						RR_NACK,
						pRemoteReadContext->lpPacket,
						pRemoteReadContext->lpDriverPacket
						);
		LogHR(hr, s_FN, 220);
		delete pRemoteReadContext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrpcsrv.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    qmrpcsrv.h

Abstract:

Author:

    Doron Juster  (DoronJ)    25-May-1997    Created
    Ilan Herbst   (IlanH)     9-July-2000    Removed mqdssrv-qm dependencies

--*/

#ifndef  __QMRPCSRV_H_
#define  __QMRPCSRV_H_

#define  RPCSRV_START_QM_IP_EP     2103
#define  RPCSRV_START_QM_IP_EP2    2105
#define  MGMT_RPCSRV_START_IP_EP   2107

RPC_STATUS InitializeRpcServer(bool fLockdown);

void SetRpcServerKeepAlive(IN handle_t hBind);

BOOL IsClientDisconnected(IN handle_t hBind);

extern TCHAR   g_wszRpcIpPort[ ];
extern TCHAR   g_wszRpcIpPort2[ ];


#endif  //  __QMRPCSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrpcsrv.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    qmrpcsrv.cpp

Abstract:

    1. Register the QM as rpc server.
    2. Utility functions for rpc processing.

Author:

    Doron Juster  (DoronJ)    25-May-1997    Created

--*/

#include "stdh.h"
#include "winsock.h"
#include "_mqini.h"
#include "_mqrpc.h"
#include "qm2qm.h"
#include "RemoteRead.h"
#include "qmrt.h"
#include "qmrepl.h"
#include "qmmgmt.h"
#include "qmrpcsrv.h"
#include "mgmtrpc.h"
#include "qmutil.h"
#include <uniansi.h>
#include <mqsocket.h>
#include <mqsec.h>
#include <cm.h>

#include <strsafe.h>

#include "qmrpcsrv.tmh"

static WCHAR *s_FN=L"qmrpcsrv";

static RPC_BINDING_VECTOR *g_pBindings ;  // used for rpc dynamic endpoints.

unsigned int g_cMaxCalls = RPC_C_LISTEN_MAX_CALLS_DEFAULT;


#define  MAX_RPC_PORT_LEN  18
const LPWSTR QMREPL_PROTOCOL = L"ncalrpc";
const LPWSTR QMREPL_ENDPOINT = L"QmReplService";

TCHAR   g_wszRpcIpPort[MAX_RPC_PORT_LEN];
TCHAR   g_wszRpcIpPort2[MAX_RPC_PORT_LEN];

static DWORD   s_dwRpcIpPort  = 0;
static DWORD   s_dwRpcIpPort2 = 0;

RPC_STATUS RPC_ENTRY DoNothingSecurityCallback(
	RPC_IF_HANDLE, 
	void*
	)
{	
	TrTRACE(RPC, "DoNothingSecurityCallback starting");
	
	//
	// Nothing to do here...
	//
	TrTRACE(RPC, "DoNothingSecurityCallback passed successfully");
	return RPC_S_OK;
}


bool IsMQDSInstalled()
/*++
Routine Description:
	Check if MQDS is installed.

Arguments:
	None

Returned Value:
	true if MQDS is installed, false otherwise.

--*/
{
	//
	// Reading this registry only at first time.
	//
	static bool s_fInitialized = false;
	static bool s_fIsMQDSInstalled = false;

	if(s_fInitialized)
	{
		return s_fIsMQDSInstalled;
	}

    const RegEntry xRegEntry(MSMQ_REG_SETUP_KEY, MQDSSERVICE_SUBCOMP, 0, RegEntry::Optional, HKEY_LOCAL_MACHINE);
	DWORD MQDSSubcomp = 0;
	CmQueryValue(xRegEntry, &MQDSSubcomp);
	if(MQDSSubcomp != 0)
	{
		s_fIsMQDSInstalled = true;
	}

	s_fInitialized = true;
	
	TrTRACE(GENERAL, "MQDSInstalled = %d", s_fIsMQDSInstalled);
	return s_fIsMQDSInstalled;
}


RPC_STATUS RPC_ENTRY QmReplSecurityCallback(
	RPC_IF_HANDLE, 
	void* hBind
	)
{
	TrTRACE(RPC, "QmReplSecurityCallback starting");

	if (!mqrpcIsLocalCall(hBind))
    {
        TrERROR(RPC, "Failed to verify Remote RPC");
		ASSERT_BENIGN(("Failed to verify Remote RPC", 0));
		return ERROR_ACCESS_DENIED;
    }

    if (!IsMQDSInstalled())
    {
        TrERROR(SECURITY, "MQDS is not installed on the machine");
		ASSERT_BENIGN(("MQDS is not installed", 0));
		return ERROR_ACCESS_DENIED;
    }
    
    TrTRACE(RPC, "QmReplSecurityCallback passed successfully");
    return RPC_S_OK;
}

RPC_STATUS RPC_ENTRY RemoteReadSecurityCallback(
	RPC_IF_HANDLE, 
	void* hBind
	)
{	
	TrTRACE(RPC, "RemoteReadSecurityCallback starting");

	if (!mqrpcIsTcpipTransport(hBind))
    {
        TrERROR(RPC, "Failed to verify Remote RPC");
		ASSERT_BENIGN(("Failed to verify Remote RPC", 0));
		return ERROR_ACCESS_DENIED;
    }
	
	TrTRACE(RPC, "RemoteReadSecurityCallback passed successfully");
	return RPC_S_OK;
}

RPC_STATUS RPC_ENTRY Qm2QmSecurityCallback(
	RPC_IF_HANDLE, 
	void* hBind
	)
{	
	TrTRACE(RPC, "Qm2QmSecurityCallback starting");

	if (!mqrpcIsTcpipTransport(hBind))
    {
        TrERROR(RPC, "Failed to verify Remote RPC");
		ASSERT_BENIGN(("Failed to verify remote RPC", 0));
		return ERROR_ACCESS_DENIED;
    }
	
	TrTRACE(RPC, "Qm2QmSecurityCallback passed successfully");
	return RPC_S_OK;
}


static 
bool 
IsOldRemoteReadAllowed()
/*++

Routine Description:
    Read DenyOldRemoteRead flag from registry

Arguments:
	None

Return Value:
	true if OldRemoteRead allowed
--*/
{
	const RegEntry xRegEntry(MSMQ_SECURITY_REGKEY, MSMQ_DENY_OLD_REMOTE_READ_REGVALUE, MSMQ_DENY_OLD_REMOTE_READ_DEFAULT);
	DWORD dwDenyOldRemoteRead = 0;
	CmQueryValue(xRegEntry, &dwDenyOldRemoteRead);
	return (dwDenyOldRemoteRead == 0);
}


static 
RPC_STATUS
QMRpcServerUseProtseqEpOnSpecificIp(
    unsigned short __RPC_FAR * Protseq,
    unsigned int MaxCalls,
    unsigned short __RPC_FAR * Endpoint,
    in_addr& addr
    )
{	
    WCHAR wzAddress[50] = L"";
    int i = ConvertToWideCharString(
	            inet_ntoa(addr),
	            wzAddress,
	            TABLE_SIZE(wzAddress)
	            );
	if (i == 0)
	{
		DWORD gle = GetLastError();
		TrERROR(RPC, "Failed to convert IP address to UNICODE format. %!winerr!", gle);
	}
	
    RPC_POLICY policy;
    policy.Length = sizeof(policy);
    policy.EndpointFlags = 0;
    policy.NICFlags = 0;

    RPC_STATUS status = RPC_S_OK;
    if (NULL != Endpoint)
    {
        status = I_RpcServerUseProtseqEp2(
                     wzAddress,
                     Protseq,
                     MaxCalls,
                     Endpoint,
                     NULL,
                     &policy
                     );
        TrTRACE(RPC, "I_RpcServerUseProtseqEp2 (%ls, %ls, %ls) returned 0x%x", wzAddress, Protseq, Endpoint, status);
    }
    else
    {
        status = I_RpcServerUseProtseq2(
                     wzAddress,
                     Protseq,
                     MaxCalls,
                     NULL,
                     &policy
                     );
        TrTRACE(RPC, "I_RpcServerUseProtseq2 (%ls, %ls) returned 0x%x", wzAddress, Protseq, status);
    }

    return LogRPCStatus(status, s_FN, 30);
}


static
RPC_STATUS
QMRpcServerUseProtseqEp(
    unsigned short __RPC_FAR * Protseq,
    unsigned int MaxCalls,
    unsigned short __RPC_FAR * Endpoint
    )
{
    if (GetBindingIPAddress() == INADDR_ANY)
    {
        //
        // fix 7123.
        // If we're not cluster, then bind to all addresses.
        // if we bind only to addresses we find at boot, then on ras
        // client (when not dialed) we'll bind to 127.0.0.1.
        // Then after dialling, no one will be able to call us, as we're
        // not bound to real addresses, only to the loopback.
        //
        RPC_STATUS status;

        if (Endpoint)
        {
            status = RpcServerUseProtseqEp( 
							Protseq,
							MaxCalls,
							Endpoint,
							NULL
							);

            TrTRACE(RPC, "non cluster- RpcServerUseProtseqEp(%ls, %ls) returned 0x%x", Protseq, Endpoint, status);
        }
        else
        {
            status = RpcServerUseProtseq( 
							Protseq,
							MaxCalls,
							NULL 
							);

            TrTRACE(RPC, "non cluster- RpcServerUseProtseq(%ls) returned 0x%x", Protseq, status);
        }

        return status;
    }

	//
	// Listen only on IP address that was specified by the user.
	// This enables multiple QMs to listen each to its own addresses.
	//
	if (!IsLocalSystemCluster())
	{
		in_addr addr;
		addr.S_un.S_addr = GetBindingIPAddress();

		return QMRpcServerUseProtseqEpOnSpecificIp(Protseq, MaxCalls, Endpoint, addr);
	}

	//
    // Listen only on IP addresses we get from winsock.
    // This enables multiple QMs to listen each to its
    // own addresses, in a cluster environment. (ShaiK)
	//
    PHOSTENT pHostEntry = gethostbyname(NULL);
    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
        ASSERT(("IP not configured", 0));
        return LogRPCStatus(RPC_S_ACCESS_DENIED, s_FN, 20);
    }

    for ( DWORD ix = 0; pHostEntry->h_addr_list[ix] != NULL; ++ix)
    {
		RPC_STATUS status =QMRpcServerUseProtseqEpOnSpecificIp(
										Protseq, 
										MaxCalls, 
										Endpoint, 
										*(struct in_addr *)(pHostEntry->h_addr_list[ix])
										);    	
        if (RPC_S_OK != status)
        {
            return LogRPCStatus(status, s_FN, 30);
        }
    }

    return RPC_S_OK;
} //QMRpcServerUseProtseqEp


static
RPC_STATUS
QMRpcServerUseProtseq(
    unsigned short __RPC_FAR * Protseq,
    unsigned int MaxCalls
    )
{
    return LogRPCStatus(QMRpcServerUseProtseqEp(Protseq, MaxCalls, NULL), s_FN, 40);

} //QMRpcServerUseProtseq


static
void
ReadRegString(
	WCHAR KeyValue[MAX_REG_DEFAULT_LEN],
	LPCWSTR KeyName,
	LPCWSTR DefaultValue
	)
{
	ASSERT(wcslen(DefaultValue) < MAX_REG_DEFAULT_LEN);

	DWORD  dwSize = MAX_REG_DEFAULT_LEN * sizeof(WCHAR);
	DWORD  dwType = REG_SZ;
							
	LONG res = GetFalconKeyValue(
					KeyName,
					&dwType,
					KeyValue,
					&dwSize,
					DefaultValue
					);
						
	if(res == ERROR_MORE_DATA)									
	{															
		StringCchCopy(KeyValue, MAX_REG_DEFAULT_LEN, DefaultValue);								
	}	
	
	ASSERT(res == ERROR_SUCCESS || res == ERROR_MORE_DATA);
	ASSERT(dwType == REG_SZ);
}

/*====================================================

Function:  QMInitializeLocalRpcServer()

Arguments:

Return Value:

=====================================================*/

RPC_STATUS 
QMInitializeLocalRpcServer( 
	IN LPWSTR lpwszEpRegName,
	IN LPWSTR lpwszDefaultEp,
	IN unsigned int cMaxCalls 
	)
{
	WCHAR wzLocalEp[MAX_REG_DEFAULT_LEN];
	ReadRegString(wzLocalEp, lpwszEpRegName, lpwszDefaultEp);

    AP<WCHAR> pwzEndPoint = 0;
    ComposeRPCEndPointName(wzLocalEp, NULL, &pwzEndPoint);

    RPC_STATUS statusLocal = RpcServerUseProtseqEp(
                                      (TBYTE *) RPC_LOCAL_PROTOCOL,
                                       cMaxCalls,
                                       pwzEndPoint,
                                       NULL
									   );
    TrTRACE(RPC, "RpcServerUseProtseqEp (local, %ls) returned 0x%x", pwzEndPoint, statusLocal);

    return LogRPCStatus(statusLocal, s_FN, 50);
}

/*====================================================

Function:  QMRegisterDynamicEnpoint()

Arguments:

Return Value:

=====================================================*/

DWORD  QMRegisterDynamicEnpoint(
    IN unsigned int  cMaxCalls,
    IN DWORD         dwFirstEP,
    IN BOOL          fRegisterDyn
    )
{
    LPWSTR lpProtocol = RPC_TCPIP_NAME;

    //
    // Register this protocol for dynamic endpoint
    //
    RPC_STATUS  status = RPC_S_OK;
    if (fRegisterDyn)
    {
        status = QMRpcServerUseProtseq(
                   lpProtocol,
                   cMaxCalls
                   );
    }

	if (status == RPC_S_OK)
	{
		//
		// Now register a fix endpoint which will be used for the real
		// interface communnication.
		//
		WCHAR wszEndpoint[34];
		for ( DWORD j = dwFirstEP ; j < dwFirstEP + 1000 ; j = j + 11 )
		{
			HRESULT hr = StringCchPrintf(wszEndpoint, TABLE_SIZE(wszEndpoint), L"%lu", j);
			ASSERT(("Buffer too small", SUCCEEDED(hr)));
			UNREFERENCED_PARAMETER(hr);
			
			status = QMRpcServerUseProtseqEp(
						 lpProtocol,
						 cMaxCalls,
						 wszEndpoint
						 );
			if (status == RPC_S_OK)
			{
				return j;
			}

			LogRPCStatus(status, s_FN, 60);
		}
	}

   TrWARNING(RPC, "DSSRV_RegisterDynamicEnpoint: failed to register %ls", lpProtocol);
   return 0;
}

/*====================================================

Function:  QMInitializeNetworkRpcServer()

Arguments:

Return Value:

=====================================================*/

RPC_STATUS
QMInitializeNetworkRpcServer(
    IN LPWSTR lpwszEp,
    IN DWORD  dwFirstEP,
    IN BOOL   fRegisterDyn,
    IN unsigned int cMaxCalls
    )
{
    //
    // Register the tcp/ip protocol.
    //

    RPC_STATUS  status;
    DWORD dwPort =  QMRegisterDynamicEnpoint(
                         cMaxCalls,
                         dwFirstEP,
                         fRegisterDyn
                         );
    if (dwPort != 0)
    {
		_itow(dwPort, lpwszEp, 10);
		status = RPC_S_OK;
    }
    else
    {
		status = RPC_S_PROTSEQ_NOT_SUPPORTED;
    }

    return LogRPCStatus(status, s_FN, 70);
}

/*====================================================

InitializeRpcServer

Arguments:

Return Value:

=====================================================*/

RPC_STATUS InitializeRpcServer(bool fLockdown)
{
    TrTRACE(RPC, "InitializeRpcServer");

    RPC_STATUS statusLocal = QMInitializeLocalRpcServer(
                                             RPC_LOCAL_EP_REGNAME,
											 RPC_LOCAL_EP,
                                             g_cMaxCalls 
											 );
    if(statusLocal != RPC_S_OK)
    {
    	TrERROR(RPC, "Failed to initialize local RPC interface. Error%d", statusLocal);
        EvReportWithError(EVENT_ERROR_QM_FAILED_RPC_LOCAL, statusLocal);
        return statusLocal;
    }

	if(MQSec_IsDC())
	{
		//
		// Register qmrepl protocol sequence only on DC.
		//
	    RPC_STATUS statusRepl = RpcServerUseProtseqEp(
	                                       QMREPL_PROTOCOL,
	                                       g_cMaxCalls,
	                                       QMREPL_ENDPOINT,
	                                       NULL
										   );
		DBG_USED(statusRepl);

		TrTRACE(RPC, "RpcServerUseProtseqEp (local, %ls) returned 0x%x", QMREPL_ENDPOINT, statusRepl);
	}
	
    AP<WCHAR> pwzEndPoint = 0;
    ComposeRPCEndPointName(QMMGMT_ENDPOINT, NULL, &pwzEndPoint);

    RPC_STATUS statusMgmt = RpcServerUseProtseqEp(
                                           QMMGMT_PROTOCOL,
                                           g_cMaxCalls,
                                           pwzEndPoint,
                                           NULL
										   );
    TrTRACE(RPC, "RpcServerUseProtseqEp (local, %ls) returned 0x%x", pwzEndPoint, statusMgmt);

	if(!fLockdown)
	{
		//
		// Initialize Remote Managment.
		//
		WCHAR RpcMgmtPort[MAX_RPC_PORT_LEN];
		statusMgmt = QMInitializeNetworkRpcServer(
                         RpcMgmtPort,
                         MGMT_RPCSRV_START_IP_EP,
                         TRUE,
                         g_cMaxCalls
                         );

		//
		// Initialize the tcp/ip protocol.
		//
		RPC_STATUS statusIP = QMInitializeNetworkRpcServer(
											 g_wszRpcIpPort,
											 RPCSRV_START_QM_IP_EP,
											 TRUE,
											 g_cMaxCalls 
											 );
		if(statusIP == RPC_S_OK)
		{
			s_dwRpcIpPort = (DWORD) _wtol (g_wszRpcIpPort);
			//
			// Server machine need two tcp endpoints to support rundown.
			// The main endpoint is used for all calls except MQReceive which
			// use the alternate endpoint (EP2).
			//
			statusIP = QMInitializeNetworkRpcServer(
											 g_wszRpcIpPort2,
											 RPCSRV_START_QM_IP_EP2,
											 FALSE,
											 g_cMaxCalls 
											 );
		   if(statusIP == RPC_S_OK)
		   {
			   s_dwRpcIpPort2 = (DWORD) _wtol (g_wszRpcIpPort2);

			   ASSERT(s_dwRpcIpPort);
			   ASSERT(s_dwRpcIpPort2);
		   }
		}


		if (statusIP)
		{
			//
			// Can't use IP protocol. It's Ok if IP can't be used
			// (which probably mean it is not installed).
			//
    		TrERROR(RPC, "Failed to initialize RPC interface with TCP/IP. Error%d", statusLocal);
			EvReportWithError(EVENT_WARN_QM_FAILED_RPC_TCPIP, statusIP);
		}
	}



    RPC_STATUS  status;
    status = RpcServerInqBindings(&g_pBindings);
    if (status == RPC_S_OK)
    {
		status = RpcEpRegister( 
					qmcomm_v1_0_s_ifspec,
					g_pBindings,
					NULL,
					L"Message Queuing - QMRT V1" 
					);
    
		if (status == RPC_S_OK)
		{
			status = RpcEpRegister( 
						qmcomm2_v1_0_s_ifspec,
						g_pBindings,
						NULL,
						L"Message Queuing - QMRT V2" 
						);
    
           if (status == RPC_S_OK)
           {
				if(IsOldRemoteReadAllowed())
				{
					status = RpcEpRegister( 
								qm2qm_v1_0_s_ifspec,
								g_pBindings,
								NULL,
								L"Message Queuing - QM2QM V1" 
								);
				}
				
				if (status == RPC_S_OK)
				{
					status = RpcEpRegister( 
								RemoteRead_v1_0_s_ifspec,
								g_pBindings,
								NULL,
								L"Message Queuing - RemoteRead V1" 
								);
				}
			}
		}

		if (status != RPC_S_OK)
		{
			//
			// can't register endpoints, can't be rpc server
			//
			TrERROR(RPC, "QMRPCSRV: Registering Endpoints, status- 0x%x", status);
			return LogRPCStatus(RPC_S_PROTSEQ_NOT_SUPPORTED, s_FN, 100);
		}
    }


    status = RpcServerRegisterIf2( 
					qmcomm_v1_0_s_ifspec,
					NULL,
					NULL,
					RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
					g_cMaxCalls,
					MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT ,
					DoNothingSecurityCallback
					);
    TrTRACE(RPC, "RpcServerRegisterIf2(rtqm) returned 0x%x", status);

    if (status)
    {
        return LogRPCStatus(status, s_FN, 110);
    }

    status = RpcServerRegisterIf2( 
					qmcomm2_v1_0_s_ifspec,
					NULL,
					NULL,
					RPC_IF_AUTOLISTEN  | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
					g_cMaxCalls,
					MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT ,
					DoNothingSecurityCallback 
					);
    TrTRACE(RPC, "RpcServerRegisterIf2(rtqm2) returned 0x%x", status);

    if (status)
    {
        return LogRPCStatus(status, s_FN, 130);
    }

	if(MQSec_IsDC())
	{
		//
		// Register qmrepl interface only on DC.
		//
	    status = RpcServerRegisterIfEx( 
						qmrepl_v1_0_s_ifspec,
						NULL,
						NULL,
						RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH ,
						g_cMaxCalls,
						QmReplSecurityCallback
						);
	    TrTRACE(RPC, "RpcServerRegisterIfEx(qmrpel) returned 0x%x", status);

	    if(status)
	    {
	       return LogRPCStatus(status, s_FN, 140);
	    }
	}
	
    status = RpcServerRegisterIfEx( 
					qmmgmt_v1_0_s_ifspec,
					NULL,
					NULL,
					RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH ,
					g_cMaxCalls,
					DoNothingSecurityCallback
					);
    TrTRACE(RPC, "RpcServerRegisterIfEx(qmmgmt) returned 0x%x", status);

    if(status)
    {
       return LogRPCStatus(status, s_FN, 150);
    }

	if(IsOldRemoteReadAllowed())
	{
	    status = RpcServerRegisterIfEx( 
						qm2qm_v1_0_s_ifspec,
						NULL,
						NULL,
						RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH ,
						g_cMaxCalls,
						Qm2QmSecurityCallback
						);
		TrTRACE(RPC, "RpcServerRegisterIfEx(qm2qm) returned 0x%x", status);

	    if (status)
	    {
	        return LogRPCStatus(status, s_FN, 160);
	    }
	}
	
    status = RpcServerRegisterIfEx( 
					RemoteRead_v1_0_s_ifspec,
					NULL,
					NULL,
					RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH ,
					g_cMaxCalls,
					RemoteReadSecurityCallback
					);
	TrTRACE(RPC, "RpcServerRegisterIfEx(RemoteRead) returned 0x%x", status);

    if (status)
    {
        return LogRPCStatus(status, s_FN, 163);
    }

    status = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);

    TrTRACE(RPC, "RpcServerRegisterAuthInfo(ntlm) returned 0x%x", status);

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 165);
    }

    //
    // Register kerberos authenticaton. This is needed for LocalSystem
    // services to be able to do remote read.
    // Ignore errors, as this may fail in nt4 domains.
    //
    // Before registering, see if computer sid is cached locally, in
    // registry. If not, it means that we're not in a win2k domain. In that
    // case, do not register Kerberos. This will also happen in a win2k
    // domain, if all msmq servers are msmq1.0. That's fine too, as win2k
    // LocalSystem services will use ntlm when talking with the msmq servers,
    // not Kerberos.
    // Note that Kerbeors registration below will succeed even in a nt4
    // domain, where there is no KDC to grant us any ticket. Instead of being
    // a Don Quichott, fighting lost battles trying to convince others that
    // this is a BUG, I'll just workaround it...
    // How did he say in his mail ? Be Smart !!!...
    //
    DWORD dwSidSize = 0;
    PSID pMachineSid = MQSec_GetLocalMachineSid( 
							FALSE, //   fAllocate
							&dwSidSize 
							);
    if ((pMachineSid == NULL) && (dwSidSize == 0))
    {
        //
        // Do NOT even try Kerberos.
        //
        TrWARNING(RPC, "MQQM: Not listening on Kerberos for remote read.");

        return RPC_S_OK;
    }

    //
    // kerberos needs principal name.
    //
    LPWSTR pwszPrincipalName = NULL;
    status = RpcServerInqDefaultPrincName( 
					RPC_C_AUTHN_GSS_KERBEROS,
					&pwszPrincipalName 
					);
    if (status != RPC_S_OK)
    {
        TrWARNING(RPC, "MQQM: RpcServerInqDefaultPrincName() returned 0x%x", status);

        LogRPCStatus(status, s_FN, 120);
        return RPC_S_OK ;
    }

    TrTRACE(RPC, "MQQM: RpcServerInqDefaultPrincName() returned %ls", pwszPrincipalName);

    status = RpcServerRegisterAuthInfo( 
					pwszPrincipalName,
					RPC_C_AUTHN_GSS_KERBEROS,
					NULL,
					NULL 
					);
    RpcStringFree(&pwszPrincipalName);

    TrTRACE(RPC, "MQQM: RpcServerRegisterAuthInfo(Kerberos) returned 0x%x", status);

    if (status != RPC_S_OK)
    {
       LogRPCStatus(status, s_FN, 180);
    }

    return RPC_S_OK;
}

/*====================================================

Function:  QMGetRTQMServerPort()
           QMGetQMQMServerPort()

Arguments:

Return Value:

=====================================================*/

DWORD  GetQMServerPort( IN DWORD dwPortType )
{
   DWORD dwPort = 0;
   PORTTYPE rrPort = (PORTTYPE) dwPortType;

   if (dwPortType == (DWORD) -1)
   {
      // Error. return null port.
   }
   else if (rrPort == IP_HANDSHAKE)
   {
      dwPort = s_dwRpcIpPort;
   }
   else if (rrPort == IP_READ)
   {
      dwPort = s_dwRpcIpPort2;
   }

   ASSERT((dwPort & 0xffff0000) == 0);

   return dwPort;
}

/* [call_as] */ 
DWORD 
qmcomm_v1_0_S_QMGetRTQMServerPort( 
	/*[in]*/ handle_t /*hBind*/,
    /*[in]*/ DWORD    dwPortType
    )
{
   return  GetQMServerPort(dwPortType);
}

DWORD
qm2qm_v1_0_R_QMGetRemoteQMServerPort(
	/*[in]*/ handle_t /*hBind*/,
    /*[in]*/ DWORD    dwPortType
    )
{
	return  GetQMServerPort(dwPortType);
}

DWORD
RemoteRead_v1_0_S_GetServerPort(
	/*[in]*/ handle_t /*hBind*/
    )
{
	return  GetQMServerPort(IP_HANDSHAKE);
}

//+------------------------------------------------------------------------
//
//  void SetRpcServerKeepAlive()
//  void InitializeKeepAlive()
//
//  This function is called on server side of rpc, on entry to each
//  function. It solves bug 8621. The private rpc api used here will
//  become public in next release.
//
//+------------------------------------------------------------------------

RPC_STATUS RPC_ENTRY
            I_RpcServerTurnOnOffKeepalives( 
					handle_t,
					BOOL,
					ULONG,
					ULONG 
					);
typedef RPC_STATUS
(RPC_ENTRY *I_RpcServerTurnOnOffKeepalives_ROUTINE)( 
					handle_t,
					BOOL,
					ULONG,
					ULONG 
					);

RPC_STATUS
RPC_ENTRY
I_RpcServerIsClientDisconnected(
    handle_t,
    BOOL*
    );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcServerIsClientDisconnected_ROUTINE)(
    handle_t,
    BOOL*
    );

static ULONG s_ulTimeBeforeFirst = 0;
static ULONG s_ulIntervalBetween = 0;

static I_RpcServerTurnOnOffKeepalives_ROUTINE pfnKeep = NULL;
static I_RpcServerIsClientDisconnected_ROUTINE pfnIsClientDisconnected = NULL;


void InitializeKeepAlive()
{
    HMODULE hRpclib = GetModuleHandle(L"rpcrt4.dll");

    if (hRpclib)
    {
        pfnKeep = (I_RpcServerTurnOnOffKeepalives_ROUTINE)
             GetProcAddress(hRpclib, "I_RpcServerTurnOnOffKeepalives");

        pfnIsClientDisconnected = (I_RpcServerIsClientDisconnected_ROUTINE)
             GetProcAddress(hRpclib, "I_RpcServerIsClientDisconnected");
    }

    DWORD  dwType = REG_DWORD;
    DWORD  dwSize = sizeof(DWORD);
	DWORD  dwDefValue = MSMQ_DEFAULT_KEEPALIVE_TIME_TO_FIRST;
    s_ulTimeBeforeFirst = MSMQ_DEFAULT_KEEPALIVE_TIME_TO_FIRST;

    LONG res = GetFalconKeyValue(
					MSMQ_KEEPALIVE_TIME_TO_FIRST_REGNAME,
					&dwType,
					&s_ulTimeBeforeFirst,
					&dwSize,
					(LPCTSTR) &dwDefValue 
					);
    s_ulTimeBeforeFirst *= 1000; // turn to milliseconds

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
	dwDefValue = MSMQ_DEFAULT_KEEPALIVE_INTERVAL;
    s_ulIntervalBetween = MSMQ_DEFAULT_KEEPALIVE_INTERVAL;

    res = GetFalconKeyValue(
				MSMQ_KEEPALIVE_INTERVAL_REGNAME,
				&dwType,
				&s_ulIntervalBetween,
				&dwSize,
				(LPCTSTR) &dwDefValue 
				);
    s_ulIntervalBetween *= 1000; // turn to milliseconds

    if (pfnKeep)
    {
        TrTRACE(RPC, "KeepAlive: first- %lu, interval- %lu", s_ulTimeBeforeFirst, s_ulIntervalBetween);
    }
    else
    {
        TrERROR(RPC, "KeepAlive: failed to find KeepAlive API");
    }

    if (pfnIsClientDisconnected == NULL)
    {
        TrERROR(RPC, "KeepAlive: failed to find I_RpcServerIsClientDisconnected API");
    }

}


void SetRpcServerKeepAlive(IN handle_t    hBind)
{
    if (s_ulTimeBeforeFirst == 0)
    {
        InitializeKeepAlive();
    }

    if (pfnKeep)
    {
        //
        // For the Windows Server 2003 release, this api is "Very" private.
        // It's not included in any header file or library.
        // So we're using GetProcAddress and call the api via pointer.
        //
        (*pfnKeep) ( 
			hBind,
			TRUE,
			s_ulTimeBeforeFirst,
			s_ulIntervalBetween 
			);
    }
}


BOOL IsClientDisconnected(IN handle_t hBind)
{
    ASSERT(s_ulTimeBeforeFirst != 0);

    if (pfnIsClientDisconnected == NULL)
    {
    	return FALSE;
    }

    //
    // For the Windows Server 2003 release, this api is "Very" private.
    // It's not included in any header file or library.
    // So we're using GetProcAddress and call the api via pointer.
    //
	BOOL fClientDisconnected = FALSE;
    RPC_STATUS rc = (*pfnIsClientDisconnected) ( 
							hBind,
							&fClientDisconnected
							);

	if(rc != RPC_S_OK)
	{
        TrERROR(RPC, "I_RpcServerIsClientDisconnected failed, gle = %!winerr!", rc);
		return FALSE;
	}

	return fClientDisconnected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrepls.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    qmrepls.cpp

Abstract:
    Send replication messages on behalf of the replication service on
    NT5.

Author:

    Doron Juster  (DoronJ)    01-Mar-1998    Created

--*/

#include "stdh.h"
#include "_mqrpc.h"
#include "qmrepl.h"
#include "qmp.h"
#include "Fn.h"
#include "cm.h"
#include <mqsec.h>

#include "qmrepls.tmh"

static WCHAR *s_FN=L"qmrepls";

HRESULT
R_QMSendReplMsg(
    /* [in] */ handle_t,
	/* [in] */ QUEUE_FORMAT* pqfDestination,
    /* [in] */ DWORD dwSize,
    /* [size_is][in] */ const unsigned char __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ unsigned char bAckMode,
    /* [in] */ unsigned char bPriority,
    /* [in] */ LPWSTR lpwszAdminResp)
{
    if((pqfDestination == NULL) || (!FnIsValidQueueFormat(pqfDestination))) 
    {
        TrERROR(GENERAL, "Destination QUEUE FORMAT is not valid");
		RpcRaiseException(MQ_ERROR_INVALID_PARAMETER);
    }

	ASSERT(MQSec_IsDC());

    ASSERT((pqfDestination->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
		   (pqfDestination->GetType() == QUEUE_FORMAT_TYPE_DIRECT));

    if (pqfDestination->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
	{
		TrTRACE(GENERAL, "Sending Replication or write request to %ls", pqfDestination->DirectID());
	}

	if (pqfDestination->GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
	{
		OBJECTID ObjectID = pqfDestination->PrivateID();
		TrTRACE(GENERAL, "Sending Notification to %!guid!\\%u", &ObjectID.Lineage, ObjectID.Uniquifier);
	}
		
    CMessageProperty MsgProp;

    MsgProp.wClass=0;
    MsgProp.dwTimeToQueue= dwTimeout;
    MsgProp.dwTimeToLive = dwTimeout;
    MsgProp.pMessageID=NULL;
    MsgProp.pCorrelationID=NULL;
    MsgProp.bPriority= bPriority;
    MsgProp.bDelivery=MQMSG_DELIVERY_EXPRESS;
    MsgProp.bAcknowledge=bAckMode;
    MsgProp.bAuditing=DEFAULT_Q_JOURNAL;
    MsgProp.dwApplicationTag=DEFAULT_M_APPSPECIFIC;
    MsgProp.dwTitleSize=0;
    MsgProp.pTitle=NULL;
    MsgProp.dwBodySize=dwSize;
    MsgProp.dwAllocBodySize = dwSize;
    MsgProp.pBody=pBuffer;

    QUEUE_FORMAT qfAdmin;
    QUEUE_FORMAT qfResp;
    if (lpwszAdminResp != NULL) 
    {
        qfAdmin.DirectID(lpwszAdminResp);
        qfResp.DirectID(lpwszAdminResp);
    }

    HRESULT hr = QmpSendPacket(
                    &MsgProp,
                    pqfDestination,
                    ((lpwszAdminResp != NULL) ? &qfAdmin : NULL),
                    ((lpwszAdminResp != NULL) ? &qfResp : NULL),
                    TRUE
                    );

    return LogHR(hr, s_FN, 20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrtopen.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    qmrtopen.h

Abstract:

    QM Impersonate and Open remote Queue.

Author:

    Ilan Herbst (ilanh) 2-Jan-2002

--*/

#ifndef _QMRTOPEN_H_
#define _QMRTOPEN_H_

#include "_mqrpc.h"


//---------------------------------------------------------
//
//  class CBindHandle
//
//---------------------------------------------------------
class CBindHandle {
public:
    CBindHandle(handle_t h = NULL) : m_h(h) {}
   ~CBindHandle()                   { free(); }

    handle_t* operator &()			{ return &m_h; }
    operator handle_t() const       { return m_h; }
    handle_t detach()               { handle_t h = m_h; m_h = NULL; return h; }

    void free()
    {
		if (m_h != NULL)
		{
			handle_t hBind = detach();
			RPC_STATUS rc = mqrpcUnbindQMService(&hBind, NULL);
			ASSERT(rc == RPC_S_OK);
			DBG_USED(rc);
		}		
    }

private:
    CBindHandle(const CBindHandle&);
    CBindHandle& operator=(const CBindHandle&);

private:
    handle_t m_h;
};


//---------------------------------------------------------
//
//  class CAutoCloseNewRemoteReadCtxAndBind
//
//---------------------------------------------------------
class CAutoCloseNewRemoteReadCtxAndBind {
public:
    CAutoCloseNewRemoteReadCtxAndBind(
    	RemoteReadContextHandleExclusive pctx,
	    handle_t hBind
    	) : 
    	m_pctx(pctx),
    	m_hBind(hBind)
    {
    }
    	
    ~CAutoCloseNewRemoteReadCtxAndBind()                 
   	{
	   	if(m_pctx != NULL)
	   		CloseRRContext(); 
   	}

    RemoteReadContextHandleExclusive GetContext() const { return m_pctx; }

	handle_t GetBind() const 							{ return m_hBind; }

    RemoteReadContextHandleExclusive detach()               
    { 
    	RemoteReadContextHandleExclusive pctx = m_pctx; 
    	m_pctx = NULL;
    	m_hBind.detach();
    	return pctx; 
    }

    void CloseRRContext();

private:
    CAutoCloseNewRemoteReadCtxAndBind(const CAutoCloseNewRemoteReadCtxAndBind&);
    CAutoCloseNewRemoteReadCtxAndBind& operator=(const CAutoCloseNewRemoteReadCtxAndBind&);

private:
    RemoteReadContextHandleExclusive m_pctx;
    CBindHandle	m_hBind;
};


void SetBindTimeout(handle_t hBind);


DWORD
RemoteReadGetServerPort(
	handle_t hBind,
    DWORD /* dwPortType */
    );


HRESULT 
ImpersonateAndOpenRRQueue(
    QUEUE_FORMAT* pQueueFormat,
    DWORD   dwCallingProcessID,
    DWORD   dwDesiredAccess,
    DWORD   dwShareMode,
	LPCWSTR lpwsRemoteQueueName,
    HANDLE*         phQueue
	);

#endif // _QMRTOPEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrt_c_.c ===
#pragma warning(push, 3)
#include <qmrt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrtopen.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:
    qmrtopen.cpp

Abstract:
    QM Impersonate and Open RRQueue.

Author:
    Ilan  Herbst  (ilanh)  2-Jan-2002

--*/

#include "stdh.h"

#include "cqmgr.h"
#include "qmrt.h"
#include "_mqrpc.h"
#include <mqsec.h>
#include "RemoteReadCli.h"
#include "qmrtopen.h"
#include "cm.h"
#include <version.h>
#include <mqexception.h>

#include "qmrtopen.tmh"

static WCHAR *s_FN=L"qmrtopen";

extern CQueueMgr    QueueMgr;
extern DWORD  g_dwOperatingSystem;
extern BOOL g_fPureWorkGroupMachine;


static 
HRESULT 
BindRemoteQMServiceIpHandShake(
	LPWSTR MachineName,
	ULONG* pAuthnLevel,
	GetPort_ROUTINE pfnGetPort,
	handle_t* phRemoteBind
	)
/*++
Routine Description:
	Bind remote QM service IP_HANDSHAKE.

Arguments:
	MachineName - remote machine name.
	phRemoteBind - pointer to the created binding handle.
	pfnGetPort - pointer to GetPort routines.
	phRemoteBind - pointer to the created binding handle.

Returned Value:
	HRESULT

--*/
{
    //
    // Using dynamic endpoints.
    //

	HRESULT hr = mqrpcBindQMService(
					MachineName,
					NULL,
					pAuthnLevel,
					phRemoteBind,
					IP_HANDSHAKE,
					pfnGetPort,
					MSMQ_AUTHN_NEGOTIATE
					);

	if (FAILED(hr))
	{
		TrERROR(RPC, "Failed bind remote QM (IP_HANDSHAKE), RemoteQm = %ls, AuthnLevel = %d, hr = %!HRESULT!", MachineName, *pAuthnLevel, hr);
		return hr;
	}

	TrTRACE(RPC, "AuthnLevel = %d", *pAuthnLevel);

	return hr;
}


static
HRESULT 
QMpOpenRemoteQueue(
    handle_t hBind,
    PCTX_OPENREMOTE_HANDLE_TYPE* pphContext,
    DWORD* pdwpContext,
    const QUEUE_FORMAT* pQueueFormat,    
    DWORD dwAccess,
    DWORD dwShareMode,
    DWORD* pdwpRemoteQueue,
    DWORD* phRemoteQueue
	)
/*++
Routine Description:
	Open remote queue - RPC call to the remote QM (R_OpenRemoteQueue)

Arguments:
    hBind - binding handle.
    pphContext - pointer to OPENREMOTE context.
    pdwpContext - Context mapped in the server.
    pQueueFormat - QueueFormat.   
    dwAccess - Required access.
    dwShareMode - Shared mode.
    pdwpRemoteQueue - Remote queue object mapped in the server.
    phRemoteQueue - Remote queue handle mapped in the server.

Returned Value:
	HRESULT

--*/
{
	RpcTryExcept
	{
	 	HRESULT hr = R_QMOpenRemoteQueue(
			             hBind,
			             pphContext,
			             pdwpContext,
			             const_cast<QUEUE_FORMAT*>(pQueueFormat),
			             0,
			             dwAccess,
			             dwShareMode,
			             const_cast<GUID*>(QueueMgr.GetQMGuid()),
			             g_dwOperatingSystem,
			             pdwpRemoteQueue,
			             phRemoteQueue
			             );
	 	return hr;
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		HRESULT hr = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "R_QMOpenRemoteQueue Failed, %!hresult!", hr);
	        throw bad_hresult(hr);
		}

        TrERROR(RPC, "R_QMOpenRemoteQueue Failed, gle = %!winerr!", hr);
        throw bad_hresult(HRESULT_FROM_WIN32(hr));
    }
	RpcEndExcept
}


static
HRESULT 
QmpIssueOpenNewRemoteQueue(
    handle_t hBind,
    RemoteReadContextHandleExclusive* pphContext,
    const QUEUE_FORMAT* pQueueFormat,    
    DWORD dwAccess,
    DWORD dwShareMode
	)
/*++
Routine Description:
	Open new remote queue - Issue RPC call to the remote QM new RemoteRead interface (R_RemoteQMOpenQueue2)

Arguments:
    hBind - binding handle.
    pphContext - pointer to RemoteReadContextHandleExclusive.
    pQueueFormat - QueueFormat.   
    dwAccess - Required access.
    dwShareMode - Shared mode.

Returned Value:
	HRESULT

--*/
{
	RpcTryExcept
	{
	 	R_OpenQueue(
			hBind,
			const_cast<QUEUE_FORMAT*>(pQueueFormat),
			dwAccess,
			dwShareMode,
			const_cast<GUID*>(QueueMgr.GetQMGuid()),
			IsNonServer(),	// fLicense
			rmj,
			rmm,
			rup,
			g_fPureWorkGroupMachine,
			pphContext
			);
	 	return MQ_OK;
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
		HRESULT hr = RpcExceptionCode();
        PRODUCE_RPC_ERROR_TRACING;
		if(FAILED(hr))
		{
	        TrERROR(RPC, "R_OpenQueue Failed, %!hresult!", hr);
	        return hr;
		}

        TrERROR(RPC, "R_OpenQueue Failed, gle = %!winerr!", hr);
        return HRESULT_FROM_WIN32(hr);
    }
	RpcEndExcept
}


static 
HRESULT 
OpenRemoteQueue(
	LPCWSTR lpwsRemoteQueueName,
    const QUEUE_FORMAT * pQueueFormat,
    DWORD   dwAccess,
    DWORD   dwShareMode,
    DWORD*	pdwpContext, 
    DWORD*	pdwpRemoteQueue, 
    DWORD*	phRemoteQueue,
	CBindHandle& hBind,
	PCTX_OPENREMOTE_HANDLE_TYPE* pphContext
	)
/*++
Routine Description:
	Open remote queue:
	1) creates binding handle to remote qm
	2) call R_OpenRemoteQueueopen.

	The calling function is responsible to unbind the binding handle
	in case of success.

Arguments:
	lpwsRemoteQueueName - Remote Queue Name.
    pQueueFormat - QueueFormat.   
    dwAccess - Required access.
    dwShareMode - Shared mode.
    pdwpContext - Context mapped in the server.
    pdwpRemoteQueue - Remote queue object mapped in the server.
    phRemoteQueue - Remote queue handle mapped in the server.
    hBind - binding handle.
    pphContext - pointer to OPENREMOTE context.

Returned Value:
	HRESULT

--*/
{
	AP<WCHAR> MachineName;
	RemoteQueueNameToMachineName(lpwsRemoteQueueName, MachineName);

	ULONG AuthnLevel = MQSec_RpcAuthnLevel();
	HRESULT hr = MQ_OK;

    for(;;)
	{
	    GetPort_ROUTINE pfnGetPort = R_RemoteQMGetQMQMServerPort;
		hr = BindRemoteQMServiceIpHandShake(MachineName, &AuthnLevel, pfnGetPort, &hBind); 
		if (FAILED(hr))
		{
			TrERROR(RPC, "BindRemoteQMService Failed, hr = %!HRESULT!", hr);
			return hr;
		}

		SetBindTimeout(hBind);

		try
		{
			//
			// Call remote QM to OpenRemoteQueue.
			//
			hr = QMpOpenRemoteQueue(
					hBind,
					pphContext,
					pdwpContext,
					pQueueFormat,
					dwAccess,
					dwShareMode,
					pdwpRemoteQueue,
					phRemoteQueue
					);

			if(FAILED(hr))
			{
				TrERROR(RPC, "R_OpenRemoteQueue Failed, hr = %!HRESULT!", hr);
				return hr;
			}

			TrTRACE(RPC, "R_QMOpenRemoteQueue: dwpContext = %d, hRemoteQueue = %d, dwpRemoteQueue = %d, hr = %!HRESULT!", *pdwpContext, *phRemoteQueue, *pdwpRemoteQueue, hr);
			return hr;
		}
        catch (const bad_hresult& e)
        {
        	hr = e.error();
			if(AuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
			{
				TrERROR(RPC, "R_OpenRemoteQueue with RPC_C_AUTHN_LEVEL_NONE Failed, hr = %!HRESULT!", hr);
				return hr;
			}
		}
        
		//
		// We got RpcException in R_OpenRemoteQueue and AuthnLevel != RPC_C_AUTHN_LEVEL_NONE
		// Retry again with RPC_C_AUTHN_LEVEL_NONE.
		// this will be the case for workgroup client or working opposite workgroup server 
		//

		TrWARNING(RPC, "R_OpenRemoteQueue Failed for AuthnLevel = %d, retrying with RPC_C_AUTHN_LEVEL_NONE, hr = %!HRESULT!", AuthnLevel, hr);

		AuthnLevel = RPC_C_AUTHN_LEVEL_NONE;  

		//
		// Free the binding handle on failure before the retry 
		//
		hBind.free();
    }
}


DWORD
RemoteReadGetServerPort(
	handle_t hBind,
    DWORD /* dwPortType */
    )
{
	return R_GetServerPort(hBind);
}


static bool s_fInitializedDenyWorkgroupServer = false;
static bool s_fClientDenyWorkgroupServer = false;

static bool ClientDenyWorkgroupServer()
/*++

Routine Description:
    Read ClientDenyWorkgroupServer flag from registry

Arguments:
	None

Return Value:
	ClientDenyWorkgroupServer flag from registry
--*/
{
	//
	// Reading this registry only at first time.
	//
	if(s_fInitializedDenyWorkgroupServer)
	{
		return s_fClientDenyWorkgroupServer;
	}

	const RegEntry xRegEntry(MSMQ_SECURITY_REGKEY, MSMQ_NEW_REMOTE_READ_CLIENT_DENY_WORKGROUP_SERVER_REGVALUE, MSMQ_NEW_REMOTE_READ_CLIENT_DENY_WORKGROUP_SERVER_DEFAULT);
	DWORD dwClientDenyWorkgroupServer = 0;
	CmQueryValue(xRegEntry, &dwClientDenyWorkgroupServer);
	s_fClientDenyWorkgroupServer = (dwClientDenyWorkgroupServer != 0);

	s_fInitializedDenyWorkgroupServer = true;

	return s_fClientDenyWorkgroupServer;
}


static
HRESULT 
OpenNewRemoteQueue(
	LPCWSTR lpwsRemoteQueueName,
    const QUEUE_FORMAT * pQueueFormat,
    DWORD   dwAccess,
    DWORD   dwShareMode,
	CBindHandle& hBind,
	RemoteReadContextHandleExclusive* pphContext
	)
/*++
Routine Description:
	Open remote queue:
	1) creates binding handle to remote qm
	2) call R_OpenRemoteQueueopen.

Arguments:
	lpwsRemoteQueueName - Remote Queue Name.
    pQueueFormat - QueueFormat.   
    dwAccess - Required access.
    dwShareMode - Shared mode.
    hBind - binding handle.
    pphContext - pointer to RemoteReadContextHandleExclusive.

Returned Value:
	HRESULT

--*/
{
	AP<WCHAR> MachineName;
	RemoteQueueNameToMachineName(lpwsRemoteQueueName, MachineName);

	//
	// For PureWorkgroup client try with RPC_C_AUTHN_LEVEL_NONE
	//
	ULONG AuthnLevel = g_fPureWorkGroupMachine ? RPC_C_AUTHN_LEVEL_NONE : MQSec_RpcAuthnLevel();

	HRESULT hrPrivacy = MQ_OK;
    for(;;)
	{
	    GetPort_ROUTINE pfnGetPort = RemoteReadGetServerPort;
		HRESULT hr = BindRemoteQMServiceIpHandShake(MachineName, &AuthnLevel, pfnGetPort, &hBind); 
		if (FAILED(hr))
		{
			//
			// Probably the new RemoteRead interface is not supported.
			//
			TrERROR(RPC, "BindRemoteQMService For new RemoteRead interface with RpcAuthnLevel = %d Failed, hr = %!HRESULT!", AuthnLevel, hr);
			return hr;
		}

		SetBindTimeout(hBind);

		//
		// Call remote QM to OpenRemoteQueue with New RemoteRead interface.
		//
		hr = QmpIssueOpenNewRemoteQueue(
				hBind,
				pphContext,
				pQueueFormat,
				dwAccess,
				dwShareMode
				);


		if(SUCCEEDED(hr))
			return hr;

		TrERROR(RPC, "R_OpenQueue Failed, AuthnLevel = %d, hr = %!HRESULT!", AuthnLevel, hr);

		if((AuthnLevel == RPC_C_AUTHN_LEVEL_NONE) || ClientDenyWorkgroupServer())
		{
			if(FAILED(hrPrivacy) && 
			   ((hr == MQ_ERROR_INVALID_HANDLE) || (hr == MQ_ERROR_ACCESS_DENIED)))
			{
				//
				// We failed with RPC_C_AUTHN_LEVEL_PKT_PRIVACY and retried with RPC_C_AUTHN_LEVEL_NONE
				// and failed with either MQ_ERROR_INVALID_HANDLE or MQ_ERROR_ACCESS_DENIED.
				//
				// When we retry with RPC_C_AUTHN_LEVEL_NONE (NONE SECURITY) 
				// We can fail because the server doesn't accept this rpc security level
				// or because Anonymous doesn't have read permissions on the queue.
				// MQ_ERROR_INVALID_HANDLE - RemoteRead server doesn't accept RPC_C_AUTHN_LEVEL_NONE.
				// MQ_ERROR_ACCESS_DENIED - Anonymous doesn't have permissions on the queue.
				//
				// In this case we want to return the RPC_C_AUTHN_LEVEL_PKT_PRIVACY errors
				// and not to overide the PRIVACY error with RPC_C_AUTHN_LEVEL_NONE errors
				// that indicate Anonymous doesn't allowed to open the queue.
				//
				return hrPrivacy;
			}

			return hr;
		}

		
		//
		// R_OpenQueue failed and AuthnLevel != RPC_C_AUTHN_LEVEL_NONE 
		// client is willing to work with workgroup server.
		// Retry again with RPC_C_AUTHN_LEVEL_NONE.
		// this will be the case for domain client working opposite workgroup server or cross forest without trust. 
		//

		TrWARNING(RPC, "R_OpenQueue Failed with ERROR_ACCESS_DENIED for AuthnLevel = %d (domain client vs. workgroup server), retrying with RPC_C_AUTHN_LEVEL_NONE", AuthnLevel);

		hrPrivacy = hr;
		AuthnLevel = RPC_C_AUTHN_LEVEL_NONE;  

		//
		// Free the binding handle on failure before the retry 
		//
		hBind.free();
    }
}


void CAutoCloseNewRemoteReadCtxAndBind::CloseRRContext()
/*++
Routine Description:
	Close the Open Remote Read context (RemoteReadContextHandleExclusive) on the server.
	This routine cleans the created context in the server in case of failure during
	the open operations when CreateNewRRQueueObject failed or throw exception.
	the function also take ownership on the binding handle.

Arguments:
	
Returned Value:
	None.

--*/
{
	ASSERT(m_hBind != NULL);
	ASSERT(m_pctx != NULL);
	
	try
	{
	    //
	    // Initialize the EXOVERLAPPED with RemoteCloseQueue callback routines
	    // And issue the close Remote queue async rpc call.
		//
	    P<CRemoteCloseQueueBase> pRequestRemoteCloseQueueOv = new CNewRemoteCloseQueue(
	    																m_hBind,
																	    m_pctx
																	    );
		//
		// Ownership to free the binding handle was transfered to CNewRemoteCloseQueue class
		//
		m_hBind.detach();
		
		pRequestRemoteCloseQueueOv->IssueCloseQueue();

	    pRequestRemoteCloseQueueOv.detach();
	    return;
	}
	catch(const exception&)
	{
		//
		// Failed to close the handle with the server.
		// Destroy the local handle.
		//
    	RpcSsDestroyClientContext(&m_pctx);
		
		//
		// Note that we don't propagate exceptions from this function.
		// this is not a request from the driver. 
		// it is context cleanup during a failure in the open operation.
		//
		TrERROR(RPC, "Failed to issue RemoteCloseQueue");
	}
}


static
bool 
UseOldRemoteRead()
/*++

Routine Description:
    Read OldRemoteRead flag from registry

Arguments:
	None

Return Value:
	OldRemoteRead flag from registry
--*/
{
	//
	// Reading this registry only at first time.
	//
	static bool s_fInitialized = false;
	static bool s_fOldRemoteRead = false;

	if(s_fInitialized)
	{
		return s_fOldRemoteRead;
	}

	const RegEntry xRegEntry(TEXT("security"), TEXT("OldRemoteRead"), 0);
	DWORD dwOldRemoteRead = 0;
	CmQueryValue(xRegEntry, &dwOldRemoteRead);
	s_fOldRemoteRead = (dwOldRemoteRead != 0);

	s_fInitialized = true;

	return s_fOldRemoteRead;
}


static
HRESULT 
OpenAndCreateNewRRQueue(
	LPCWSTR lpwsRemoteQueueName,
    const QUEUE_FORMAT * pQueueFormat,
    DWORD   dwCallingProcessID,
    DWORD   dwAccess,
    DWORD   dwShareMode,
    HANDLE*	phQueue
	)
/*++
Routine Description:
	Open remote queue:
	1) Open remote queue.
	2) Create local queue proxy for the remote queue.

Arguments:
	lpwsRemoteQueueName - Remote Queue Name.
    pQueueFormat - QueueFormat.   
    dwCallingProcessID - calling process id.
    dwAccess - Required access.
    dwShareMode - Shared mode.
    phQueue - pointer to the local queue handle (proxy).

Returned Value:
	HRESULT

--*/
{
	if(UseOldRemoteRead())
	{
		//
		// Force the use of old remote read interface.
		// Only for EPT_S_NOT_REGISTERED we will fallback to the old interface.
		//
		return HRESULT_FROM_WIN32(EPT_S_NOT_REGISTERED);
	}

	//
	// Try To Open Remote Queue with the new RemoteRead interfaceon behalf of the RT user
	//
	CBindHandle hBind;
	RemoteReadContextHandleExclusive phContext = NULL;
	HRESULT hr = OpenNewRemoteQueue(
					lpwsRemoteQueueName,
	    			pQueueFormat,
	    			dwAccess,
	    			dwShareMode,
				    hBind,
				    &phContext
					);
	if(FAILED(hr))
	{
		return hr;
	}

	ASSERT(phContext != NULL);

	//
	// Create CNewRRQueue
	//
	ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

	CAutoCloseNewRemoteReadCtxAndBind AutoCloseRemoteReadCtxAndBind(phContext, hBind.detach());
	hr = QueueMgr.OpenRRQueue( 
						pQueueFormat,
						dwCallingProcessID,
		    			dwAccess,
		    			dwShareMode,
		    			0,		// srv_hACQueue
		    			0,		// srv_pQMQueue
		    			0,		// dwpContext
						&AutoCloseRemoteReadCtxAndBind,
						hBind,
						phQueue
						);
	if(FAILED(hr))
	{
		TrERROR(RPC, "Fail to OpenRRQueue, hr = %!HRESULT!", hr);
		return hr;
	}

	//
	// CNewRRQueue object took ownership on phContext and hBind
	//
	ASSERT(AutoCloseRemoteReadCtxAndBind.GetContext() == NULL);
	ASSERT(AutoCloseRemoteReadCtxAndBind.GetBind() == NULL);
	
	return hr;

}


HRESULT 
ImpersonateAndOpenRRQueue(
    QUEUE_FORMAT* pQueueFormat,
    DWORD   dwCallingProcessID,
    DWORD   dwDesiredAccess,
    DWORD   dwShareMode,
	LPCWSTR lpwsRemoteQueueName,
    HANDLE*         phQueue
	)
/*++
Routine Description:
	Impersonate the calling user and Open the remote queue on the user behalf

Arguments:
    pQueueFormat - QueueFormat.   
    dwCallingProcessID - calling process id.
    dwAccess - Required access.
    dwShareMode - Shared mode.
	lpwsRemoteQueueName - Remote Queue Name.
    phQueue - pointer to the local queue handle (proxy).

Returned Value:
	HRESULT

--*/
{
	//
	// Impersonate the client - RT user
	// Do not impersonate Anonymous if RpcImpersonateClient fails
	//
    P<CImpersonate> pImpersonate;
	MQSec_GetImpersonationObject(
		FALSE,	// fImpersonateAnonymousOnFailure
		&pImpersonate 
		);
	
	RPC_STATUS dwStatus = pImpersonate->GetImpersonationStatus();
    if (dwStatus != RPC_S_OK)
    {
		TrERROR(RPC, "RpcImpersonateClient() failed, RPC_STATUS = 0x%x", dwStatus);
		return MQ_ERROR_CANNOT_IMPERSONATE_CLIENT;
    }

	TrTRACE(RPC, "QM performs RemoteOpenQueue on the user behalf");
	MQSec_TraceThreadTokenInfo();

	//
	// Open Remote Queue on behalf of the RT user
	//

	//
	// Try To Open Remote Queue with the new RemoteRead interfaceo behalf of the RT user
	// and create the local queue object
	//
	HRESULT hr = OpenAndCreateNewRRQueue(
					lpwsRemoteQueueName,
	    			pQueueFormat,
					dwCallingProcessID,
					dwDesiredAccess,
	    			dwShareMode,
	    			phQueue
					);

	if(hr != HRESULT_FROM_WIN32(EPT_S_NOT_REGISTERED))
	{
		return hr;
	}

	//
	// Failed to use new RemoteRead interface - the new interface is not registered (EPT_S_NOT_REGISTERED)
	// fallback to the old interface.
	//

	DWORD dwpContext = 0;
	DWORD dwpRemoteQueue = 0;
	DWORD hRemoteQueue = 0;
	CBindHandle hBind;
	PCTX_OPENREMOTE_HANDLE_TYPE phContext = NULL;
	hr = OpenRemoteQueue(
				lpwsRemoteQueueName,
    			pQueueFormat,
    			dwDesiredAccess,
    			dwShareMode,
			    &dwpContext, 
			    &dwpRemoteQueue, 
			    &hRemoteQueue,
			    hBind,
			    &phContext
				);
	
	if(FAILED(hr))
	{
		TrERROR(RPC, "OpenRemoteQueue() failed, hr = %!HRESULT!", hr);

		//
		// If msmq is offline, RPC returns EPT_S_NOT_REGISTERED. Changing
		// it to RPC_S_SERVER_UNAVAILABLE.
		//
		if(hr == HRESULT_FROM_WIN32(EPT_S_NOT_REGISTERED))
		{
			hr = MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE;
		}
		return hr;
	}

	//
	// After the Qm OpenRemoteQueue on behalf of the user
	// Stop impersonating the client (RevertToSelf)
	// OpenRRQueue will be done in the service context.
	//
	pImpersonate.free();

	//
	// Create RRQueue
	//
	ASSERT(dwpRemoteQueue != 0);
	ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);
	hr = QueueMgr.OpenRRQueue( 
					pQueueFormat,
					dwCallingProcessID,
					dwDesiredAccess,
					dwShareMode,
					hRemoteQueue,
					dwpRemoteQueue,
					dwpContext,
					NULL,	// pNewRemoteReadContextAndBind	
					hBind,
					phQueue
					);

	R_QMCloseRemoteQueueContext(&phContext);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmrt_s_.c ===
#pragma warning(push, 3)
#pragma warning(push)
#pragma warning(disable:4702)
#include <qmrt_s.c>
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmta.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    qmta.h

Abstract:
    Definition of well known size TA_ADDRESS

Author:
    Uri Habusha (urih), 23-May-2000

--*/

#ifndef __QMTA_H__
#define __QMTA_H__

#include "_ta.h"

class CAddress
{
public:
    USHORT AddressLength;
    USHORT AddressType;
    UCHAR Address[FOREIGN_ADDRESS_LEN];
};

C_ASSERT(FIELD_OFFSET(CAddress, AddressLength) == FIELD_OFFSET(TA_ADDRESS, AddressLength));
C_ASSERT(FIELD_OFFSET(CAddress, AddressType) == FIELD_OFFSET(TA_ADDRESS, AddressType));
C_ASSERT(FIELD_OFFSET(CAddress, Address)  == FIELD_OFFSET(TA_ADDRESS, Address));
C_ASSERT(sizeof(USHORT) + sizeof(USHORT)  == TA_ADDRESS_SIZE);

#endif //__QMTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmsecutl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    qmsecutl.h

    QM security related stuff.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#ifndef _QMSECUTL_H_
#define _QMSECUTL_H_

#ifdef MQUTIL_EXPORT
#undef MQUTIL_EXPORT
#endif
#define MQUTIL_EXPORT DLL_IMPORT

#include <mqcrypt.h>
#include <qmpkt.h>
#include <cqueue.h>
#include "cache.h"
#include "csecobj.h"
#include "authz.h"
#include "autoauthz.h"


// CQMDSSecureableObject -
//      1. Holds the security descriptor of a DS object.
//      2. Provides methods to:
//      2.1 Set and get the security descriptor
//      2.2 Verify various access rights on the object.
class CQMDSSecureableObject : public CSecureableObject
{
public:
    CQMDSSecureableObject(
        AD_OBJECT eObject,
        const GUID *pGuid,
        BOOL fInclSACL,
        BOOL fTryDS,
        LPCWSTR szObjectName);

    CQMDSSecureableObject(
        AD_OBJECT eObject,
        const GUID *pGuid,
        PSECURITY_DESCRIPTOR pSD,
        LPCWSTR szObjectName);

    ~CQMDSSecureableObject();

private:
    HRESULT GetObjectSecurity();
    HRESULT SetObjectSecurity();

private:
    const GUID *m_pObjGuid;
    BOOL m_fInclSACL;
    BOOL m_fTryDS;
    BOOL m_fFreeSD;
};

// CQMSecureablePrivateObject -
//      1. Holds the security descriptor of a QM object.
//      2. Provides methods to:
//      2.1 Set and get the security descriptor
//      2.2 Verify various access rights on the object.
class CQMSecureablePrivateObject : public CSecureableObject
{
public:
    CQMSecureablePrivateObject(AD_OBJECT, ULONG ulID);
    ~CQMSecureablePrivateObject();

private:
    HRESULT GetObjectSecurity();
    HRESULT SetObjectSecurity();

private:
    ULONG m_ulID;
};


class CAuthzClientContext : public CCacheValue
{
public:
    CAUTHZ_CLIENT_CONTEXT_HANDLE m_hAuthzClientContext;

private:
    ~CAuthzClientContext() {}
};

typedef CAuthzClientContext* PCAuthzClientContext;

template<>
inline void AFXAPI DestructElements(PCAuthzClientContext* ppAuthzClientContext, int nCount)
{
    for (; nCount--; ppAuthzClientContext++)
    {
        (*ppAuthzClientContext)->Release();
    }
}


void
GetClientContext(
	PSID pSenderSid,
    USHORT uSenderIdType,
	PCAuthzClientContext* ppAuthzClientContext
	);


HRESULT
QMSecurityInit(
    void
    );

HRESULT
VerifyOpenPermission(
    CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    BOOL fJournalQueue,
    BOOL fLocalQueue
    );

HRESULT
VerifyMgmtPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    );

HRESULT
VerifyMgmtGetPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    );

HRESULT
CheckPrivateQueueCreateAccess(
    void
    );


HRESULT
SetMachineSecurityCache(
    const VOID *pSD,
    DWORD dwSDSize
    );


HRESULT
GetMachineSecurityCache(
    PSECURITY_DESCRIPTOR pSD,
    LPDWORD lpdwSDSize
    );


HRESULT
VerifySendAccessRights(
    CQueue *pQueue,
    PSID pSenderSid,
    USHORT uSenderIdType
    );


HRESULT
VerifySignature(
    CQmPacket * PktPtrs
    );

HRESULT
GetSendQMKeyxPbKey(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider ) ;

HRESULT
GetSendQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    BYTE **ppEncSymmKey,
    DWORD *pdwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    );

HRESULT
GetSendQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    BYTE **ppEncSymmKey,
    DWORD *pdwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    );

HRESULT
GetRecQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo,
    OUT BOOL  *pfNewKey
    );

HRESULT
GetRecQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    );

HRESULT
QMSignGetSecurityChallenge(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR dwUnused, // dwContext
    OUT    BYTE    *pbSignature,
    IN OUT DWORD   *pdwSignatureSize,
    IN     DWORD   dwSignatureMaxSize
    );

void
InitSymmKeys(
    const CTimeDuration& CacheBaseLifetime,
    const CTimeDuration& CacheEnhLifetime,
    DWORD dwSendCacheSize,
    DWORD dwReceiveCacheSize
    );



//
// Structure for cached certificate information.
//
class CERTINFO : public CCacheValue
{
public:
	CERTINFO() : fSelfSign(false)    {}

public:
    CHCryptProv hProv;  // A CSP handle associated with the cert.
    CHCryptKey hPbKey;  // A KEY handle to the public key in the cert.
    P<VOID> pSid;       // The SID of the user that registered the certificate.
	bool fSelfSign;		// flag that indicates if the certificate is self signed
private:
    ~CERTINFO() {}
};



typedef CERTINFO *PCERTINFO;


HRESULT
GetCertInfo(
    CQmPacket *PktPtrs,
    PCERTINFO *ppCertInfo,
	BOOL fNeedSidInfo
    );


NTSTATUS
_GetDestinationFormatName(
	IN QUEUE_FORMAT *pqdDestQueue,
	IN WCHAR        *pwszTargetFormatName,
	IN OUT DWORD    *pdwTargetFormatNameLength,
	OUT WCHAR      **ppAutoDeletePtr,
	OUT WCHAR      **ppwszTargetFormatName
	);


void
InitUserMap(
    CTimeDuration CacheLifetime,
    DWORD dwUserCacheSize
    );


HRESULT
HashMessageProperties(
    IN HCRYPTHASH hHash,
    IN CONST CMessageProperty* pmp,
    IN CONST QUEUE_FORMAT* pqdAdminQueue,
    IN CONST QUEUE_FORMAT* pqdResponseQueue
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmthrd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmthrd.h

Abstract:



Author:

    Uri Habusha (urih)

--*/
#ifndef __QMTHRD_H__
#define __QMTHRD_H__


#include <Ex.h>
#include "Qmp.h"
#include "ac.h"

class CTransportBase;
struct CDebugSection;
struct CSessionSection;


VOID WINAPI PutPacketFailed(EXOVERLAPPED* pov);
VOID WINAPI PutPacketSucceeded(EXOVERLAPPED* pov);

VOID WINAPI PutOrderedPacketFailed(EXOVERLAPPED* pov);
VOID WINAPI PutOrderedPacketSucceeded(EXOVERLAPPED* pov);

VOID WINAPI GetInternalMessageSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetInternalMessageFailed(EXOVERLAPPED* pov);

VOID WINAPI GetMsgSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetMsgFailed(EXOVERLAPPED* pov);

VOID WINAPI GetNonactiveMessageSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetNonactiveMessageFailed(EXOVERLAPPED* pov);

VOID WINAPI GetServiceRequestSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetServiceRequestFailed(EXOVERLAPPED* pov);



//
// QMOV_ACGetRequest
//
struct QMOV_ACGetRequest 
{
    EXOVERLAPPED qmov;
    CACRequest request;

    QMOV_ACGetRequest() :
        qmov(GetServiceRequestSucceeded, GetServiceRequestFailed),
        request(CACRequest::rfAck)
    {
    }

};

//
//   QMOV_ACGetMsg
//
struct QMOV_ACGetMsg
{
    EXOVERLAPPED    qmov;
    HANDLE          hGroup;            // handle to the group from which the packet is gotten
    CTransportBase* pSession;          // Pointer to session object
    CACPacketPtrs   packetPtrs;   // packet pointers

    QMOV_ACGetMsg(
		EXOVERLAPPED::COMPLETION_ROUTINE pSuccess,
        EXOVERLAPPED::COMPLETION_ROUTINE pFailure
        ) :
        qmov(pSuccess, pFailure),
        hGroup(0),
        pSession(0)
    {
        packetPtrs.pPacket = NULL;
        packetPtrs.pDriverPacket = NULL;
    }
};

//
//  QMOV_ACGetInternalMsg
//
struct QMOV_ACGetInternalMsg
{
    EXOVERLAPPED   qmov;
    HANDLE         hQueue;             // Handle to the queue
    CACPacketPtrs  packetPtrs;   // pointers to packet
    LPRECEIVE_COMPLETION_ROUTINE  lpCallbackReceiveRoutine;

    QMOV_ACGetInternalMsg(HANDLE h, LPRECEIVE_COMPLETION_ROUTINE  pCallback) :
        hQueue(h),
        lpCallbackReceiveRoutine(pCallback),
        qmov(GetInternalMessageSucceeded, GetInternalMessageFailed)
    {
        packetPtrs.pPacket = NULL;
        packetPtrs.pDriverPacket = NULL;
    }
};


//
// QMOV_ACPut
//
struct QMOV_ACPut
{
    EXOVERLAPPED   qmov;
    CTransportBase* pSession;          // pointer to session. Used for sending storage ACK
    DWORD_PTR      dwPktStoreAckNo;    // storage Ack No.

    QMOV_ACPut() :
        qmov(PutPacketSucceeded, PutPacketFailed)
    {
    }
};

//
// QMOV_ACPutOrdered
//
class QMOV_ACPutOrdered 
{
public:
    EXOVERLAPPED   qmov;
    CTransportBase* pSession;          // pointer to session. Used for sending storage ACK
    DWORD_PTR      dwPktStoreAckNo;    // storage Ack No.
	HANDLE          hQueue;
    CACPacketPtrs   packetPtrs;   // packet pointers

    QMOV_ACPutOrdered() :
        qmov(PutOrderedPacketSucceeded, PutOrderedPacketFailed)
    {
    }
};


//
// Function decleration
//
void
QmpGetPacketMustSucceed(
    IN HANDLE hGroup,
    IN QMOV_ACGetMsg* pGetOverlapped
    );


HRESULT
CreateAcPutPacketRequest(
    IN CTransportBase* pSession,
    IN DWORD_PTR dwPktStoreAckNo,
    OUT QMOV_ACPut** ppov
    );


HRESULT
CreateAcPutOrderedPacketRequest(
    IN  CQmPacket *pPkt,
    IN  HANDLE  hQueue,
    IN  CTransportBase  *pSession,
    IN  DWORD_PTR dwPktStoreAckNo,
    OUT QMOV_ACPutOrdered** ppAcPutov
    );

#endif //  __QMTHRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\qm\qmsecutl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    qmsecutl.cpp

Abstract:

    Various QM security related functions.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "cqpriv.h"
#include "qmsecutl.h"
#include "regqueue.h"
#include "qmrt.h"
#include <mqsec.h>
#include <_registr.h>
#include <mqcrypt.h>
#include "cache.h"
#include <mqformat.h>
#include "ad.h"
#include "_propvar.h"
#include "VerifySignMqf.h"
#include "cry.h"
#include "mqexception.h"
#include <mqcert.h>
#include "Authz.h"
#include "autoauthz.h"
#include "mqexception.h"
#include "DumpAuthzUtl.h"

#include "qmsecutl.tmh"

extern CQueueMgr QueueMgr;
extern LPTSTR g_szMachineName;

P<SECURITY_DESCRIPTOR> g_MachineSD;
static CCriticalSection s_MachineCS;

static WCHAR *s_FN=L"qmsecutl";

//
// Windows bug 562586. see _mqini.h for more details about these two flags.
//
BOOL g_fSendEnhRC2WithLen40 = FALSE ;
BOOL g_fRejectEnhRC2WithLen40 = FALSE ;

/***************************************************************************

Function:
    SetMachineSecurityCache

Description:
    Store the machine security descriptor in the registry. This is done
    in order to allow creation of private queues also while working
    off line.

***************************************************************************/
HRESULT SetMachineSecurityCache(const VOID *pSD, DWORD dwSDSize)
{
    LONG  rc;
    DWORD dwType = REG_BINARY ;
    DWORD dwSize = dwSDSize ;

    rc = SetFalconKeyValue(
                      MSMQ_DS_SECURITY_CACHE_REGNAME,
                      &dwType,
                      (PVOID) pSD,
                      &dwSize ) ;

	{
		CS lock (s_MachineCS);
		g_MachineSD.free();
	}	
	
    LogNTStatus(rc, s_FN, 10);
    return ((rc == ERROR_SUCCESS) ? MQ_OK : MQ_ERROR);
}


/***************************************************************************

Function:
    GetMachineSecurityCache

Description:
    Retrive the machine security descriptor from the registry. This is done
    in order to allow creation of private queues also while working
    off line.

***************************************************************************/
HRESULT GetMachineSecurityCache(PSECURITY_DESCRIPTOR pSD, LPDWORD lpdwSDSize)
{
    LONG rc;
    DWORD dwType = REG_BINARY;
   
    static DWORD dwLastSize = 0;

	{
		CS lock (s_MachineCS);
		if (g_MachineSD.get() != NULL)
		{
			if (*lpdwSDSize < dwLastSize)
			{
				*lpdwSDSize = dwLastSize;
				return MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
			}
			*lpdwSDSize = dwLastSize;

			memcpy (pSD, g_MachineSD.get(), dwLastSize);
			return MQ_OK;
		}

	    rc = GetFalconKeyValue( MSMQ_DS_SECURITY_CACHE_REGNAME,
	                            &dwType,
	                            (PVOID) pSD,
	                            lpdwSDSize) ;

	    switch (rc)
	    {
	      case ERROR_SUCCESS:
	      	dwLastSize = *lpdwSDSize;
	      	g_MachineSD = (SECURITY_DESCRIPTOR*) new char[dwLastSize];
	      	memcpy (g_MachineSD.get(), pSD, dwLastSize);
	        return MQ_OK;
	       
	      case ERROR_MORE_DATA:
	      	TrWARNING(SECURITY, "The buffer is too small.");
	        return MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;

	      default:
	        TrERROR(SECURITY, "MQ_ERROR");
	        return MQ_ERROR;
	    }
	}
}

/***************************************************************************

Function:
    GetObjectSecurity

Description:
    Get the security descriptor of a DS object. When working on line, the
    security descriptor of the DS objects is retrived from the DS. When
    working off line, it is possible to retrive only the security descriptor
    of the local machine. This is done in order to allow creation of private
    queues also while working off line.

***************************************************************************/
HRESULT
CQMDSSecureableObject::GetObjectSecurity()
{
    m_SD = NULL;

    char SD_buff[512];
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)SD_buff;
    DWORD dwSDSize = sizeof(SD_buff);
    DWORD dwLen = 0;
    HRESULT hr = MQ_ERROR_NO_DS;

    if (m_fTryDS && QueueMgr.CanAccessDS())
    {
        SECURITY_INFORMATION RequestedInformation =
                              OWNER_SECURITY_INFORMATION |
                              GROUP_SECURITY_INFORMATION |
                              DACL_SECURITY_INFORMATION;

        //
        // We need the SACL only if we can generate audits and if the
        // object is a queue object. The QM generates audits only for
        // queues, so we do not need the SACL of objects that are not
        // queue objects.
        //
        if (m_fInclSACL)
        {
            RequestedInformation |= SACL_SECURITY_INFORMATION;
			TrTRACE(SECURITY, "Try to Get Security Descriptor including SACL");

            //
            // Enable SE_SECURITY_NAME since we want to try to get the SACL.
            //
            HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, TRUE);
            LogHR(hr1, s_FN, 197);
        }

        int  cRetries = 0;
        BOOL fDoAgain = FALSE;
        do
        {
           fDoAgain = FALSE;
           if (m_fInclSACL &&
                    ((m_eObject == eQUEUE) ||
                     (m_eObject == eMACHINE)))
           {
               hr = ADQMGetObjectSecurity(
                              m_eObject,
                              m_pObjGuid,
                              RequestedInformation,
                              pSD,
                              dwSDSize,
                              &dwLen,
                              QMSignGetSecurityChallenge
                              );
           }
           else
           {
                PROPID      propId = PROPID_Q_SECURITY;
                PROPVARIANT propVar;

                propVar.vt = VT_NULL;

                if (m_eObject == eQUEUE)
                {
                    propId= PROPID_Q_SECURITY;

                }
                else if (m_eObject == eMACHINE)
                {
                    propId = PROPID_QM_SECURITY;

                }
                else if ((m_eObject == eSITE) || (m_eObject == eFOREIGNSITE))
                {
                    propId = PROPID_S_SECURITY;

                }
                else if (m_eObject == eENTERPRISE)
                {
                    propId = PROPID_E_SECURITY;

                }
                else
                {
                    ASSERT(0);
                }


               hr = ADGetObjectSecurityGuid(
                        m_eObject,
                        NULL,       // pwcsDomainController
						false,	    // fServerName
                        m_pObjGuid,
                        RequestedInformation,
                        propId,
                        &propVar
                        );
               if (SUCCEEDED(hr))
               {
                    ASSERT(!m_SD);
                    pSD = m_SD  = propVar.blob.pBlobData;
                    dwSDSize = propVar.blob.cbSize;
               }


           }

           if (FAILED(hr))
           {
			  TrWARNING(SECURITY, "Failed to get security descriptor, fIncludeSacl = %d, hr = 0x%x", m_fInclSACL, hr);
              if (hr == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
              {
				  //
                  //  Allocate a larger buffer.
                  //

				  TrTRACE(SECURITY, "allocated security descriptor buffer to small need %d chars", dwLen);

				  //
				  // The m_SD buffer might be already allocated, this is theoraticaly.
				  // It might happened if between the first try and the second try
				  // the SECURITY_DESCRIPTOR Size has increased.
				  // If someone on the root has change the queue SECURITY_DESCRIPTOR
				  // between the first and second DS access we will have this ASSERT.
				  // (ilanh, bug 5094)
				  //
				  ASSERT(!m_SD);
			      delete[] m_SD;

                  pSD = m_SD = (PSECURITY_DESCRIPTOR) new char[dwLen];
                  dwSDSize = dwLen;
                  fDoAgain = TRUE;
                  cRetries++ ;
              }
			  else if (hr != MQ_ERROR_NO_DS)
              {
                  //
                  // On Windows, we'll get only the ACCESS_DENIED from
                  // ADS. on MSMQ1.0, we got the PRIVILEGE_NOT_HELD.
                  // So test for both, to be on the safe side.
				  // Now we are getting MQ_ERROR_QUEUE_NOT_FOUND
				  // So we as long as the DS ONLINE we will try again without SACL. ilanh 23-Aug-2000
                  //
                  if (RequestedInformation & SACL_SECURITY_INFORMATION)
                  {
                      ASSERT(m_fInclSACL);
                      //
                      // Try giving up on the SACL.
                      // Remove the SECURITY privilege.
                      //
                      RequestedInformation &= ~SACL_SECURITY_INFORMATION;
                      fDoAgain = TRUE;

                      HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);
                      ASSERT_BENIGN(SUCCEEDED(hr1));
                      LogHR(hr1, s_FN, 186);

					  TrTRACE(SECURITY, "retry: Try to Get Security Descriptor without SACL");
                      m_fInclSACL = FALSE;
                  }
              }
           }
        }
        while (fDoAgain && (cRetries <= 2)) ;

        if (m_fInclSACL)
        {
			HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);
            ASSERT(SUCCEEDED(hr1)) ;
            LogHR(hr1, s_FN, 187);
            if ((m_eObject == eSITE) || (m_eObject == eFOREIGNSITE))
            {
                //
                // Get the site's name for in case we will audit this.
                //
                PROPID PropId = PROPID_S_PATHNAME;
                PROPVARIANT PropVar;

                PropVar.vt = VT_NULL;
                hr = ADGetObjectPropertiesGuid(
                            eSITE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            m_pObjGuid,
                            1,
                            &PropId,
                            &PropVar);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 30);
                }
                m_pwcsObjectName = PropVar.pwszVal;
            }

        }

        if (SUCCEEDED(hr))
        {
            if ((m_eObject == eMACHINE) && QmpIsLocalMachine(m_pObjGuid))
            {
                SetMachineSecurityCache(pSD, dwSDSize);
            }
        }
        else if (m_SD)
        {
           delete[] m_SD;

           ASSERT(pSD == m_SD) ;
           if (pSD == m_SD)
           {
                //
                // Bug 8560.
                // This may happen if first call to Active Directory return
                // with error MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL and then
                // second call fail too, for example, network failed and
                // we are now offline.
                // We didn't reset pSD to its original value, so code below
                // that use pSD can either AV (pSD point to freed memory)
                // or trash valid memory if pointer was recycled by another
                // thread.
                //
                pSD = (PSECURITY_DESCRIPTOR)SD_buff;
                dwSDSize = sizeof(SD_buff);
           }
           m_SD = NULL;
        }
        else
        {
            ASSERT(pSD == (PSECURITY_DESCRIPTOR)SD_buff) ;
        }
    }

    if (hr == MQ_ERROR_NO_DS)
    {
       //
       // MQIS not available. Try local registry.
       //
        if (m_eObject == eQUEUE)
        {
           PROPID aProp;
           PROPVARIANT aVar;

           aProp = PROPID_Q_SECURITY;

           aVar.vt = VT_NULL;

           hr = GetCachedQueueProperties( 1,
                                          &aProp,
                                          &aVar,
                                          m_pObjGuid ) ;
           if (SUCCEEDED(hr))
           {
              m_SD =  aVar.blob.pBlobData ;
           }
        }
        else if ((m_eObject == eMACHINE) &&
                 (QmpIsLocalMachine(m_pObjGuid)))
        {
            // Get the nachine security descriptor from a cached copy in the
            // registry.
            hr = GetMachineSecurityCache(pSD, &dwSDSize);
            if (FAILED(hr))
            {
                if (hr == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
                {
                    m_SD = (PSECURITY_DESCRIPTOR) new char[dwSDSize];
                    hr = GetMachineSecurityCache(m_SD, &dwSDSize);
                }

                if (FAILED(hr))
                {
                    delete[] m_SD;
                    m_SD = NULL;
                    hr = MQ_ERROR_NO_DS;
                }
            }
        }
        else
        {
            hr = MQ_ERROR_NO_DS;
        }
    }

    if (SUCCEEDED(hr) && !m_SD)
    {
        // Allocate a buffer for the security descriptor and copy
        // the security descriptor from stack to the allocated buffer.
        //
        ASSERT(pSD == SD_buff) ;
        dwSDSize = GetSecurityDescriptorLength((PSECURITY_DESCRIPTOR)SD_buff);
        m_SD = (PSECURITY_DESCRIPTOR) new char[dwSDSize];
        memcpy(m_SD, SD_buff, dwSDSize);
    }

    ASSERT(FAILED(hr) || IsValidSecurityDescriptor(m_SD));
    return LogHR(hr, s_FN, 40);
}

/***************************************************************************

Function:
    SetObjectSecurity

Description:
    We do not want to modify the security of any of the DS objects from the
    QM. This function is not implemented and always return MQ_ERROR.

***************************************************************************/
HRESULT
CQMDSSecureableObject::SetObjectSecurity()
{
    return LogHR(MQ_ERROR, s_FN, 50);
}

/***************************************************************************

Function:
    CQMDSSecureableObject

Description:
    The constructor of CQMDSSecureableObject

***************************************************************************/
CQMDSSecureableObject::CQMDSSecureableObject(
    AD_OBJECT eObject,
    const GUID *pGuid,
    BOOL fInclSACL,
    BOOL fTryDS,
    LPCWSTR szObjectName) :
    CSecureableObject(eObject)
{
    m_pObjGuid = pGuid;
    m_pwcsObjectName = const_cast<LPWSTR>(szObjectName);
    m_fInclSACL = fInclSACL && MQSec_CanGenerateAudit() ;
    m_fTryDS = fTryDS;
    m_fFreeSD = TRUE;
    m_hrSD = GetObjectSecurity();
}

/***************************************************************************

Function:
    CQMDSSecureableObject

Description:
    The constructor of CQMDSSecureableObject

***************************************************************************/
CQMDSSecureableObject::CQMDSSecureableObject(
    AD_OBJECT eObject,
    const GUID *pGuid,
    PSECURITY_DESCRIPTOR pSD,
    LPCWSTR szObjectName) :
    CSecureableObject(eObject)
{
    m_pObjGuid = pGuid;
    m_pwcsObjectName = const_cast<LPWSTR>(szObjectName);
    m_fTryDS = FALSE;
    m_fFreeSD = FALSE;
    ASSERT(pSD && IsValidSecurityDescriptor(pSD));
    m_SD = pSD;

    m_hrSD = MQ_OK;
}

/***************************************************************************

Function:
    ~CQMDSSecureableObject

Description:
    The distractor of CQMDSSecureableObject

***************************************************************************/
CQMDSSecureableObject::~CQMDSSecureableObject()
{
    if (m_fFreeSD)
    {
        delete[] (char*)m_SD;
    }
}


/***************************************************************************

Function:
    CQMSecureablePrivateObject

Description:
    The constructor of CQMSecureablePrivateObject

***************************************************************************/
CQMSecureablePrivateObject::CQMSecureablePrivateObject(
    AD_OBJECT eObject,
    ULONG ulID) :
    CSecureableObject(eObject)
{
    ASSERT(m_eObject == eQUEUE);

    m_ulID = ulID;

    m_hrSD = GetObjectSecurity();
}

/***************************************************************************

Function:
    ~CQMSecureablePrivateObject

Description:
    The distractor of CQMSecureablePrivateObject

***************************************************************************/
CQMSecureablePrivateObject::~CQMSecureablePrivateObject()
{
    delete[] (char*)m_SD;
    delete[] m_pwcsObjectName;
}

/***************************************************************************

Function:

    GetObjectSecurity

Description:
    The function retrieves the security descriptor for a given object. The
    buffer for the security descriptor is allocated by the data base manager
    and should be freed when not needed. The function does not validate access
    rights. The calling code sohuld first validate the user's access
    permissions to set the security descriptor of the object.

***************************************************************************/
HRESULT
CQMSecureablePrivateObject::GetObjectSecurity()
{
    ASSERT(m_eObject == eQUEUE);

    m_SD = NULL;
    m_pwcsObjectName = NULL;

    PROPID aPropID[2];
    PROPVARIANT aPropVar[2];

    aPropID[0] = PROPID_Q_PATHNAME;
    aPropVar[0].vt = VT_NULL;

    aPropID[1] = PROPID_Q_SECURITY;
    aPropVar[1].vt = VT_NULL;

    HRESULT hr;
    hr = g_QPrivate.QMGetPrivateQueuePropertiesInternal(m_ulID,
                                                        2,
                                                        aPropID,
                                                        aPropVar);

    if (!SUCCEEDED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }

    //m_pwcsObjectName = new WCHAR[9];
    //wsprintf(m_pwcsObjectName, TEXT("%08x"), m_ulID);

    ASSERT(aPropVar[0].vt == VT_LPWSTR);
    ASSERT(aPropVar[1].vt == VT_BLOB);
    m_pwcsObjectName = aPropVar[0].pwszVal;
    m_SD = (PSECURITY_DESCRIPTOR)aPropVar[1].blob.pBlobData;
    ASSERT(IsValidSecurityDescriptor(m_SD));

    return(MQ_OK);
}

/***************************************************************************

Function:
    SetObjectSecurity

Description:
    Sets the security descriptor of a QM object. The calling code sohuld
    first validate the user's access permissions to set the security
    descriptor of the object.

***************************************************************************/
HRESULT
CQMSecureablePrivateObject::SetObjectSecurity()
{
    PROPID PropID = PROPID_Q_SECURITY;
    PROPVARIANT PropVar;
    PropVar.vt = VT_BLOB;
    PropVar.blob.pBlobData = (BYTE*)m_SD;
    PropVar.blob.cbSize = GetSecurityDescriptorLength(m_SD);

    HRESULT hr;
    hr = g_QPrivate.QMSetPrivateQueuePropertiesInternal(
	                    		m_ulID,
		                	    1,
    		                	&PropID,
	        	            	&PropVar);

    return LogHR(hr, s_FN, 70);
}

/***************************************************************************

Function:
    CheckPrivateQueueCreateAccess

Description:
    Verifies that the user has access rights to create a private queue.

***************************************************************************/
HRESULT
CheckPrivateQueueCreateAccess()
{
    CQMDSSecureableObject DSMacSec(
                            eMACHINE,
                            QueueMgr.GetQMGuid(),
                            TRUE,
                            FALSE,
                            g_szMachineName);

    return LogHR(DSMacSec.AccessCheck(MQSEC_CREATE_QUEUE), s_FN, 80);
}


static
void
CheckClientContextSendAccess(
    PSECURITY_DESCRIPTOR pSD,
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
    )
/*++

Routine Description:
	Check if the client has send access.
	normal termination means access is granted.
	can throw bad_win32_error() if AuthzAccessCheck() fails.
	or bad_hresult() if access is not granted

Arguments:
	pSD - pointer to the security descriptor
	ClientContext - handle to authz client context.

Returned Value:
	None.	
	
--*/
{
	ASSERT(IsValidSecurityDescriptor(pSD));

	AUTHZ_ACCESS_REQUEST Request;

	Request.DesiredAccess = MQSEC_WRITE_MESSAGE;
	Request.ObjectTypeList = NULL;
	Request.ObjectTypeListLength = 0;
	Request.PrincipalSelfSid = NULL;
	Request.OptionalArguments = NULL;

	AUTHZ_ACCESS_REPLY Reply;

	DWORD dwErr;
	Reply.Error = (PDWORD)&dwErr;

	ACCESS_MASK AcessMask;
	Reply.GrantedAccessMask = (PACCESS_MASK) &AcessMask;
	Reply.ResultListLength = 1;
	Reply.SaclEvaluationResults = NULL;

	if(!AuthzAccessCheck(
			0,
			ClientContext,
			&Request,
			NULL,
			pSD,
			NULL,
			0,
			&Reply,
			NULL
			))
	{
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "QM: AuthzAccessCheck() failed, err = 0x%x", gle);
        LogHR(HRESULT_FROM_WIN32(gle), s_FN, 83);

		ASSERT(("AuthzAccessCheck failed", 0));
		throw bad_win32_error(gle);
	}

	if(!(Reply.GrantedAccessMask[0] & MQSEC_WRITE_MESSAGE))
	{
		TrERROR(SECURITY, "QM: AuthzAccessCheck() did not GrantedAccess AuthzAccessCheck(), err = 0x%x", Reply.Error[0]);
        LogHR(HRESULT_FROM_WIN32(Reply.Error[0]), s_FN, 85);

		//
		// There might be sids that exist in the domain but doesn't belong to any group.
		// DnsUpdateProxy user sid is one example.
		// This may happened in corrupt message that corrupt the sid to be such sid.
		//
		ASSERT_BENIGN(!IsAllGranted(
							MQSEC_WRITE_MESSAGE,
							const_cast<PSECURITY_DESCRIPTOR>(pSD)
							));

		DumpAccessCheckFailureInfo(
			MQSEC_WRITE_MESSAGE,
			const_cast<PSECURITY_DESCRIPTOR>(pSD),
			ClientContext
			);
		
		throw bad_hresult(MQ_ERROR_ACCESS_DENIED);
	}
}



HRESULT
VerifySendAccessRights(
    CQueue *pQueue,
    PSID pSenderSid,
    USHORT uSenderIdType
    )
/*++

Routine Description:
	This function perform access check:
	it verify the the sender has access rights to the queue.

Arguments:
    pQueue - (In) pointer to the Queue
	pSenderSid - (In) pointer to the sender sid
	uSenderIdType - (in) sender sid type

Returned Value:
	MQ_OK(0) if access allowed else error code

--*/
{
    ASSERT(pQueue->IsLocalQueue());

	//
    // Get the queue security descriptor.
	//
    R<CQueueSecurityDescriptor> pcSD = pQueue->GetSecurityDescriptor();

    if (pcSD->GetSD() == NULL)
    {
		//
		// The queue is local queue but MSMQ can't retrieve the SD of the queue. This can be happened when the
		// queue is deleted. The QM succeeded to fetch the queue properties but when it tried to fetch the SD
		// the queue object didn't exist anymore. In this case we want to reject the message since the queue
		// doesn't exist any moreand the QM can't verify the send permission
		//
		return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 95);
    }

	//
	// Check first if the queue allow all write permissions. If it does we don't need to go to the DS.
	//
    if(ADGetEnterprise() == eMqis)
	{
		//
		// We are in NT4 environment and Queues are created with everyone permissions and not anonymous permissions
		// need to check if the security descriptor allow everyone to write message.
		//
		if(IsEveryoneGranted(MQSEC_WRITE_MESSAGE, pcSD->GetSD()))			
		{
			TrTRACE(SECURITY, "Access allowed: NT4 environment, Queue %ls allow everyone write message permission", pQueue->GetQueueName());
			return MQ_OK;
		}
	}
    else
    {
		if(IsAllGranted(MQSEC_WRITE_MESSAGE, pcSD->GetSD()))
		{
			//
			// Queue security descriptor allow all to write message.
			//
			TrTRACE(SECURITY, "Access allowed: Queue %ls allow all write message permission", pQueue->GetQueueName());
			return MQ_OK;
		}
    }

    //
    // The queue doesn't have full control permissions - need to access the DS to get the client context.
    //
    R<CAuthzClientContext> pAuthzClientContext;

	try
	{
		GetClientContext(
			pSenderSid,
			uSenderIdType,
			&pAuthzClientContext.ref()
			);
	}
	catch(const bad_win32_error& err)
	{
		TrERROR(SECURITY, "Access denied: GetClientContext failed for queue %ls. Error: %!winerr!", pQueue->GetQueueName(), err.error());
		if (err.error() == ERROR_ACCESS_DENIED)
		{
			//
			// If we got a ACCESS_DENIED error this is probably because we don't have access to the group memberships 
			// of the sending user. Issue an event to suggest to the user how to fix this problem.
			//
			static time_t TimeToIssueEvent = 0;
			if (time(NULL) > TimeToIssueEvent)
			{
				//
				// Issue a new event in 2 hours
				//
				TimeToIssueEvent = time(NULL)+(60*60*2);
				EvReport(EVENT_ERROR_ACCESS_DENIED_TO_GROUP_MEMBERSHIPS, 2, pQueue->GetQueueName(), g_szMachineName);		
			}
		}
		return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 108);
	}

	try
	{
		CheckClientContextSendAccess(
			pcSD->GetSD(),
			pAuthzClientContext->m_hAuthzClientContext
			);
	}
	catch(const bad_api&)
	{
		TrERROR(SECURITY, "Access denied: failed to grant write message permission for Queue %ls", pQueue->GetQueueName());
		return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 97);
	}

	TrTRACE(SECURITY, "Allowed write message permission for Queue %ls", pQueue->GetQueueName());
	return MQ_OK;

}

template<>
inline void AFXAPI DestructElements(PCERTINFO *ppCertInfo, int nCount)
{
    for (; nCount--; ppCertInfo++)
    {
        (*ppCertInfo)->Release();
    }
}

//
// A map from cert digest to cert info.
//
static CCache <GUID, const GUID &, PCERTINFO, PCERTINFO> g_CertInfoMap;


static
bool
IsCertSelfSigned(
	CMQSigCertificate* pCert
	)
/*++

Routine Description:
	This function check if the certificate is self signed

Arguments:
    pCert - pointer to the certificate

Returned Value:
	false if the certificate is not self sign, true otherwise

--*/
{
    //
    // Check if the certificate is self sign.
    //
    HRESULT hr = pCert->IsCertificateValid(
							pCert, // pIssuer
							x_dwCertValidityFlags,
							NULL,  // pTime
							TRUE   // ignore NotBefore.
							);

    if (hr == MQSec_E_CERT_NOT_SIGNED)
    {
		//
		// This error is expected if the certificate is not self sign.
		// the signature validation with the certificate public key has failed.
		// So the certificate is not self sign
		//
        return false;
    }

	//
	// We did not get signature error so it is self sign certificate
	//
	return true;
}



static
HRESULT
GetCertInfo(
	const UCHAR *pCertBlob,
	ULONG        ulCertSize,
	LPCWSTR      wszProvName,
	DWORD        dwProvType,
	BOOL         fNeedSidInfo,
	PCERTINFO   *ppCertInfo
	)
/*++
Routine Description:
	Get certificate info

Arguments:

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    *ppCertInfo = NULL;

    //
    // Create the certificate object.
    //
    R<CMQSigCertificate> pCert;

    HRESULT hr = MQSigCreateCertificate(
					 &pCert.ref(),
					 NULL,
					 const_cast<UCHAR *> (pCertBlob),
					 ulCertSize
					 );

    if (FAILED(hr))
    {
		TrERROR(SECURITY, "MQSigCreateCertificate() failed, hr = 0x%x", hr);
        LogHR(hr, s_FN, 100);
        return MQ_ERROR_INVALID_CERTIFICATE;
    }

    //
    // Compute the certificate digets. The certificate digest is the key
    // for the map and also the key for searchnig the certificate in the
    // DS.
    //

    GUID guidCertDigest;

    hr = pCert->GetCertDigest(&guidCertDigest);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 110);
    }

    BOOL fReTry;

    do
    {
        fReTry = FALSE;

        //
        // Try to retrieve the information from the map.
        //
      	BOOL fFoundInCache;
        {
      		CS lock(g_CertInfoMap.m_cs);
      		fFoundInCache = g_CertInfoMap.Lookup(guidCertDigest, *ppCertInfo);
        }

		if (!fFoundInCache)
        {
            //
            // The map does not contain the required information yet.
            //

            R<CERTINFO> pCertInfo = new CERTINFO;

            //
            // Get a handle to the CSP verification context.
            //
            if (!CryptAcquireContext(
					 &pCertInfo->hProv,
					 NULL,
					 wszProvName,
					 dwProvType,
					 CRYPT_VERIFYCONTEXT
					 ))
            {
				DWORD gle = GetLastError();
				TrERROR(SECURITY, "CryptAcquireContext() failed, gle = %!winerr!", gle);
                LogNTStatus(gle, s_FN, 120);
                return MQ_ERROR_INVALID_CERTIFICATE;
            }

            //
            // Get a handle to the public key in the certificate.
            //
            hr = pCert->GetPublicKey(
							pCertInfo->hProv,
							&pCertInfo->hPbKey
							);

            if (FAILED(hr))
            {
				TrERROR(SECURITY, "pCert->GetPublicKey() failed, hr = 0x%x", hr);
                LogHR(hr, s_FN, 130);
                return MQ_ERROR_INVALID_CERTIFICATE;
            }

			//
			// COMMENT - need to add additional functions to query the DS
			// meanwhile only MQDS_USER, guidCertDigest	is supported
			// ilanh 24.5.00
			//

			//
            // Get the sernder's SID.
            //
            PROPID PropId = PROPID_U_SID;
            PROPVARIANT PropVar;

            PropVar.vt = VT_NULL;
            hr = ADGetObjectPropertiesGuid(
                            eUSER,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &guidCertDigest,
                            1,
                            &PropId,
                            &PropVar
							);

			if(FAILED(hr))
			{
				TrERROR(SECURITY, "Failed to find certificate in DS, %!hresult!", hr);
			}

            if (SUCCEEDED(hr))
            {
                DWORD dwSidLen = PropVar.blob.cbSize;
                pCertInfo->pSid = (PSID)new char[dwSidLen];
                BOOL bRet = CopySid(dwSidLen, pCertInfo->pSid, PropVar.blob.pBlobData);
                delete[] PropVar.blob.pBlobData;

                if(!bRet)
                {
                	ASSERT(("Failed to copy SID", 0));
                	
					DWORD gle = GetLastError();
					TrERROR(SECURITY, "Failed to Copy SID. %!winerr!", gle);
					return HRESULT_FROM_WIN32(gle);
				}

 				ASSERT((pCertInfo->pSid != NULL) && IsValidSid(pCertInfo->pSid));
            }

            //
            // Store the certificate information in the map.
            //
			{
      			CS lock(g_CertInfoMap.m_cs);
	      		fFoundInCache = g_CertInfoMap.Lookup(guidCertDigest, *ppCertInfo);
      			if (!fFoundInCache)
      			{
      				g_CertInfoMap.SetAt(guidCertDigest, pCertInfo.get());
            		*ppCertInfo = pCertInfo.detach();
      			}
            }
        }

        if (fFoundInCache && fNeedSidInfo && (*ppCertInfo)->pSid == NULL)
        {
            //
            // If we need the SID inofrmation, but the cached certificate
            // information does not contain the SID, we should go to the
            // DS once more in order to see whether the certificate was
            // regitered in the DS in the mean time. So we remove the
            // certificate from the cache and do the loop once more.
            // In the second interation, the certificate will not be found
            // in the cache so we'll go to the DS.
            //
  			CS lock(g_CertInfoMap.m_cs);
            g_CertInfoMap.RemoveKey(guidCertDigest);
            (*ppCertInfo)->Release();
            *ppCertInfo = NULL;
            fReTry = TRUE;
        }
    } while(fReTry);

	if((*ppCertInfo)->pSid == NULL)
	{
		//
		// If the certificate was not found in the DS
		// Check if the certificate is self signed
		//
		(*ppCertInfo)->fSelfSign = IsCertSelfSigned(pCert.get());
		TrWARNING(SECURITY, "Certificate was not found in the DS, fSelfSign = %d", (*ppCertInfo)->fSelfSign);
	}

    return MQ_OK;
}


HRESULT
GetCertInfo(
    CQmPacket *PktPtrs,
    PCERTINFO *ppCertInfo,
	BOOL fNeedSidInfo
    )
/*++
Routine Description:
	Get certificate info

Arguments:
	PktPtrs - pointer to the packet
	ppCertInfo - pointer to certinfo class
	fNeedSidInfo - flag for retrieve sid info from the ds

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    ULONG ulCertSize;
    const UCHAR *pCert;

    pCert = PktPtrs->GetSenderCert(&ulCertSize);

    if (!ulCertSize)
    {
        //
        // That's an odd case, the message was sent with a signature, but
        // without a certificate. Someone must have tampered with the message.
        //
		ASSERT(("Dont have Certificate info", ulCertSize != 0));
        return LogHR(MQ_ERROR, s_FN, 140);
    }

    //
    // Get the CSP information from the packet.
    //
    BOOL bDefProv;
    LPCWSTR wszProvName = NULL;
    DWORD dwProvType = 0;

    PktPtrs->GetProvInfo(&bDefProv, &wszProvName, &dwProvType);

    if (bDefProv)
    {
        //
        // We use the default provider.
        //
        wszProvName = MS_DEF_PROV;
        dwProvType = PROV_RSA_FULL;
    }

    HRESULT hr = GetCertInfo(
					 pCert,
					 ulCertSize,
					 wszProvName,
					 dwProvType,
					 fNeedSidInfo,
					 ppCertInfo
					 );

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 150);
    }

    return(MQ_OK);
}


static
HRESULT
VerifySid(
    CQmPacket * PktPtrs,
    PCERTINFO *ppCertInfo
    )
/*++
Routine Description:
    Verify that the sender identity in the massage matches the SID that is
    stored with the certificate in the DS.

Arguments:
	PktPtrs - pointer to the packet
	ppCertInfo - pointer to certinfo class

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{

    //
    // Verify that the sender identity in the massage matches the SID that is
    // stored with the certificate in the DS.
    //
    if (PktPtrs->GetSenderIDType() == MQMSG_SENDERID_TYPE_SID)
    {
        USHORT wSidLen;

        PSID pSid = (PSID)PktPtrs->GetSenderID(&wSidLen);
        if (!pSid ||
            !(*ppCertInfo)->pSid ||
            !EqualSid(pSid, (*ppCertInfo)->pSid))
        {
            //
            // No match, the message is illegal.
            //
            return LogHR(MQ_ERROR, s_FN, 160);
        }
    }

    return(MQ_OK);
}


static
HRESULT
GetCertInfo(
    CQmPacket *PktPtrs,
    PCERTINFO *ppCertInfo
    )
/*++
Routine Description:
	Get certificate info
	and Verify that the sender identity in the massage matches the SID that is
    stored with the certificate in the DS.

Arguments:
	PktPtrs - pointer to the packet
	ppCertInfo - pointer to certinfo class

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
	HRESULT hr = GetCertInfo(
					 PktPtrs,
					 ppCertInfo,
					 PktPtrs->GetSenderIDType() == MQMSG_SENDERID_TYPE_SID
					 );

	if(FAILED(hr))
		return(hr);

    return(VerifySid(PktPtrs, ppCertInfo));
}


PSID
AppGetCertSid(
	const BYTE*  pCertBlob,
	ULONG        ulCertSize,
	bool		 fDefaultProvider,
	LPCWSTR      pwszProvName,
	DWORD        dwProvType
	)
/*++
Routine Description:
	Get user sid that match the given certificate blob

Arguments:
	pCertBlob - Certificate blob.
	ulCertSize - Certificate blob size.
	fDefaultProvider - default provider flag.
	pwszProvName - Provider name.
	dwProvType - provider type.

Returned Value:
	PSID or NULL if we failed to find user sid.

--*/

{
	if (fDefaultProvider)
	{
		//
		// We use the default provider.
		//
		pwszProvName = MS_DEF_PROV;
		dwProvType = PROV_RSA_FULL;
	}

	R<CERTINFO> pCertInfo;
	HRESULT hr = GetCertInfo(
					pCertBlob,
					ulCertSize,
					pwszProvName,
					dwProvType,
					false,  // fNeedSidInfo
					&pCertInfo.ref()
					);

	if(FAILED(hr) || (pCertInfo->pSid == NULL))
	{
		return NULL;
	}

	ASSERT(IsValidSid(pCertInfo->pSid));

	DWORD SidLen = GetLengthSid(pCertInfo->pSid);
	AP<BYTE> pCleanSenderSid = new BYTE[SidLen];
	BOOL fSuccess = CopySid(SidLen, pCleanSenderSid, pCertInfo->pSid);
	if (!fSuccess)
	{
    	ASSERT(("Failed to copy SID", 0));
    	
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "Failed to Copy SID. %!winerr!", gle);		
		return NULL;
	}

	return reinterpret_cast<PSID>(pCleanSenderSid.detach());
}


class QMPBKEYINFO : public CCacheValue
{
public:
    CHCryptKey hKey;

private:
    ~QMPBKEYINFO() {}
};

typedef QMPBKEYINFO *PQMPBKEYINFO;

template<>
inline void AFXAPI DestructElements(PQMPBKEYINFO *ppQmPbKeyInfo, int nCount)
{
    for (; nCount--; ppQmPbKeyInfo++)
    {
        (*ppQmPbKeyInfo)->Release();
    }
}

//
// A map from QM guid to public key.
//
static CCache <GUID, const GUID&, PQMPBKEYINFO, PQMPBKEYINFO> g_MapQmPbKey;

/*************************************************************************

  Function:
    GetQMPbKey

  Parameters -
    pQmGuid - The QM's ID (GUID).
    phQMPbKey - A pointer to a buffer that receives the key handle
    fGoToDs - Always try to retrieve the public key from the DS and update
        the cache.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    The function creates a handle to the public signing key of the QM.

*************************************************************************/
static
HRESULT
GetQMPbKey(
    const GUID *pguidQM,
    PQMPBKEYINFO *ppQmPbKeyInfo,
    BOOL fGoToDs
    )
{
    if (!g_hProvVer)
    {
    	ASSERT(0);
		TrERROR(SECURITY, "Cryptographic provider is not initialized");
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 170);
    }

    if (!fGoToDs)
    {
    	CS lock(g_MapQmPbKey.m_cs);
	    if (g_MapQmPbKey.Lookup(*pguidQM, *ppQmPbKeyInfo))
	    {
	        return MQ_OK;
	    }
    }

    if (!QueueMgr.CanAccessDS())
    {
        return LogHR(MQ_ERROR_NO_DS, s_FN, 180);
    }

    //
    // Get the public key blob.
    //
    PROPID prop = PROPID_QM_SIGN_PK;
    CMQVariant var;

    HRESULT hr = ADGetObjectPropertiesGuid(
			            eMACHINE,
			            NULL,       // pwcsDomainController
						false,	    // fServerName
			            pguidQM,
			            1,
			            &prop,
			            var.CastToStruct()
			            );
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 190);
        return MQ_ERROR_INVALID_OWNER;
    }

    R<QMPBKEYINFO> pQmPbKeyNewInfo = new QMPBKEYINFO;

    //
    // Import the public key blob and get a handle to the public key.
    //
    if (!CryptImportKey(
            g_hProvVer,
            (var.CastToStruct())->blob.pBlobData,
            (var.CastToStruct())->blob.cbSize,
            NULL,
            0,
            &pQmPbKeyNewInfo->hKey))
    {
        DWORD dwErr = GetLastError() ;
        TrERROR(SECURITY, "GetQMPbKey(), fail at CryptImportKey(), err- %lxh", dwErr);

        LogNTStatus(dwErr, s_FN, 200);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

	{
    	CS lock(g_MapQmPbKey.m_cs);
        if (g_MapQmPbKey.Lookup(*pguidQM, *ppQmPbKeyInfo))
        {
            //
            // Remove the key so it'll be destroyed.
            //
            (*ppQmPbKeyInfo)->Release();
            g_MapQmPbKey.RemoveKey(*pguidQM);
        }

        //
        // Update the map
        //
        g_MapQmPbKey.SetAt(*pguidQM, pQmPbKeyNewInfo.get());
	}

    //
    // Pass on the result.
    //
    *ppQmPbKeyInfo = pQmPbKeyNewInfo.detach();
    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//  NTSTATUS  _GetDestinationFormatName()
//
//  Input:
//      pwszTargetFormatName- fix length buffer. Try this one first, to
//          save a "new" allocation.
//      pdwTargetFormatNameLength- on input, length (in characters) of
//          pwszTargetFormatName. On output, length (in bytes) of string,
//          including NULL termination.
//
//  Output string is return in  ppwszTargetFormatName.
//
//+-----------------------------------------------------------------------

NTSTATUS
_GetDestinationFormatName(
	IN QUEUE_FORMAT *pqdDestQueue,
	IN WCHAR        *pwszTargetFormatName,
	IN OUT DWORD    *pdwTargetFormatNameLength,
	OUT WCHAR      **ppAutoDeletePtr,
	OUT WCHAR      **ppwszTargetFormatName
	)
{
    *ppwszTargetFormatName = pwszTargetFormatName;
    ULONG dwTargetFormatNameLengthReq = 0;

    NTSTATUS rc = MQpQueueFormatToFormatName(
					  pqdDestQueue,
					  pwszTargetFormatName,
					  *pdwTargetFormatNameLength,
					  &dwTargetFormatNameLengthReq ,
                      false
					  );

    if (rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
    {
        ASSERT(dwTargetFormatNameLengthReq > *pdwTargetFormatNameLength);
        *ppAutoDeletePtr = new WCHAR[ dwTargetFormatNameLengthReq ];
        *pdwTargetFormatNameLength = dwTargetFormatNameLengthReq;

        rc = MQpQueueFormatToFormatName(
				 pqdDestQueue,
				 *ppAutoDeletePtr,
				 *pdwTargetFormatNameLength,
				 &dwTargetFormatNameLengthReq,
                 false
				 );

        if (FAILED(rc))
        {
            ASSERT(0);
            return LogNTStatus(rc, s_FN, 910);
        }
        *ppwszTargetFormatName = *ppAutoDeletePtr;
    }

    if (SUCCEEDED(rc))
    {
        *pdwTargetFormatNameLength =
                     (1 + wcslen(*ppwszTargetFormatName)) * sizeof(WCHAR);
    }
    else
    {
        *pdwTargetFormatNameLength = 0;
    }

    return LogNTStatus(rc, s_FN, 915);
}

//+------------------------------------------------------------------------
//
//  BOOL  _AcceptOnlyEnhAuthn()
//
//  Return TRUE if local computer is configured to accept only messages
//  with enhanced authentication.
//
//+------------------------------------------------------------------------

static BOOL  _AcceptOnlyEnhAuthn()
{
    static BOOL s_fRegistryRead = FALSE ;
    static BOOL s_fUseOnlyEnhSig = FALSE ;

    if (!s_fRegistryRead)
    {
        DWORD dwVal  = DEFAULT_USE_ONLY_ENH_MSG_AUTHN  ;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        LONG rc = GetFalconKeyValue( USE_ONLY_ENH_MSG_AUTHN_REGNAME,
                                    &dwType,
                                    &dwVal,
                                    &dwSize );
        if ((rc == ERROR_SUCCESS) && (dwVal == 1))
        {
            TrWARNING(SECURITY, "QM: This computer will accept only Enh authentication");

            s_fUseOnlyEnhSig = TRUE ;
        }
        s_fRegistryRead = TRUE ;
    }

    return s_fUseOnlyEnhSig ;
}

//
// Function -
//      HashMessageProperties
//
// Parameters -
//     hHash - A handle to a hash object.
//     pmp - A pointer to the message properties.
//     pRespQueueFormat - The responce queue.
//     pAdminQueueFormat - The admin queue.
//
// Description -
//      The function calculates the hash value for the message properties.
//
HRESULT
HashMessageProperties(
    IN HCRYPTHASH hHash,
    IN CONST CMessageProperty* pmp,
    IN CONST QUEUE_FORMAT* pqdAdminQueue,
    IN CONST QUEUE_FORMAT* pqdResponseQueue
    )
{
    HRESULT hr;

    hr = HashMessageProperties(
            hHash,
            pmp->pCorrelationID,
            PROPID_M_CORRELATIONID_SIZE,
            pmp->dwApplicationTag,
            pmp->pBody,
            pmp->dwBodySize,
            pmp->pTitle,
            pmp->dwTitleSize,
            pqdResponseQueue,
            pqdAdminQueue);

    return(hr);
}


//+------------------------------------
//
//  HRESULT _VerifySignatureEx()
//
//+------------------------------------

static
HRESULT
_VerifySignatureEx(
	IN CQmPacket    *PktPtrs,
	IN HCRYPTPROV    hProv,
	IN HCRYPTKEY     hPbKey,
	IN ULONG         dwBodySize,
	IN const UCHAR  *pBody,
	IN QUEUE_FORMAT *pRespQueueformat,
	IN QUEUE_FORMAT *pAdminQueueformat,
	IN bool fMarkAuth
	)
{
    ASSERT(hProv);
    ASSERT(hPbKey);

    const struct _SecuritySubSectionEx * pSecEx =
                    PktPtrs->GetSubSectionEx(e_SecInfo_User_Signature_ex);

    if (!pSecEx)
    {
        //
        // Ex signature not available. Depending on registry setting, we
        // may reject such messages.
        //
        if (_AcceptOnlyEnhAuthn())
        {
            return LogHR(MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX, s_FN, 916);
        }
        return LogHR(MQ_INFORMATION_ENH_SIG_NOT_FOUND, s_FN, 917);
    }

    //
    // Compute the hash value and then validate the signature.
    //
    DWORD dwErr = 0;
    CHCryptHash hHash;

    if (!CryptCreateHash(hProv, PktPtrs->GetHashAlg(), 0, 0, &hHash))
    {
        dwErr = GetLastError();
        LogNTStatus(dwErr, s_FN, 900);
        TrERROR(SECURITY, "QM: _VerifySignatureEx(), fail at CryptCreateHash(), err- %lxh", dwErr);

        return MQ_ERROR_CANNOT_CREATE_HASH_EX ;
    }

    HRESULT hr = HashMessageProperties(
                    hHash,
                    PktPtrs->GetCorrelation(),
                    PROPID_M_CORRELATIONID_SIZE,
                    PktPtrs->GetApplicationTag(),
                    pBody,
                    dwBodySize,
                    PktPtrs->GetTitlePtr(),
                    PktPtrs->GetTitleLength() * sizeof(WCHAR),
                    pRespQueueformat,
                    pAdminQueueformat
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1010);
    }

    //
    // Get FormatName of target queue.
    //
    QUEUE_FORMAT qdDestQueue;
    BOOL f = PktPtrs->GetDestinationQueue(&qdDestQueue);
    ASSERT(f);
	DBG_USED(f);

    WCHAR  wszTargetFormatNameBuf[256];
    ULONG dwTargetFormatNameLength = sizeof(wszTargetFormatNameBuf) /
                                     sizeof(wszTargetFormatNameBuf[0]);
    WCHAR *pwszTargetFormatName = NULL;
    P<WCHAR> pCleanName = NULL;

    NTSTATUS rc = _GetDestinationFormatName(
						&qdDestQueue,
						wszTargetFormatNameBuf,
						&dwTargetFormatNameLength,
						&pCleanName,
						&pwszTargetFormatName
						);
    if (FAILED(rc))
    {
        return LogNTStatus(rc, s_FN, 920);
    }
    ASSERT(pwszTargetFormatName);

    //
    // Prepare user flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

    sUserFlags.bDelivery  = (UCHAR)  PktPtrs->GetDeliveryMode();
    sUserFlags.bPriority  = (UCHAR)  PktPtrs->GetPriority();
    sUserFlags.bAuditing  = (UCHAR)  PktPtrs->GetAuditingMode();
    sUserFlags.bAck       = (UCHAR)  PktPtrs->GetAckType();
    sUserFlags.usClass    = (USHORT) PktPtrs->GetClass();
    sUserFlags.ulBodyType = (ULONG)  PktPtrs->GetBodyType();

    //
    // Prepare array of properties to hash.
    // (_MsgHashData already include one property).
    //
    DWORD dwStructSize = sizeof(struct _MsgHashData) +
                            (3 * sizeof(struct _MsgPropEntry));
    P<struct _MsgHashData> pHashData =
                        (struct _MsgHashData *) new BYTE[dwStructSize];

    pHashData->cEntries = 3;
    (pHashData->aEntries[0]).dwSize = dwTargetFormatNameLength;
    (pHashData->aEntries[0]).pData = (const BYTE*) pwszTargetFormatName;
    (pHashData->aEntries[1]).dwSize = sizeof(GUID);
    (pHashData->aEntries[1]).pData = (const BYTE*) PktPtrs->GetSrcQMGuid();
    (pHashData->aEntries[2]).dwSize = sizeof(sUserFlags);
    (pHashData->aEntries[2]).pData = (const BYTE*) &sUserFlags;
    LONG iIndex = pHashData->cEntries;

    GUID guidConnector = GUID_NULL;
    const GUID *pConnectorGuid = &guidConnector;

    if (pSecEx->_u._UserSigEx.m_bfConnectorType)
    {
        const GUID *pGuid = PktPtrs->GetConnectorType();
        if (pGuid)
        {
            pConnectorGuid = pGuid;
        }

        (pHashData->aEntries[ iIndex ]).dwSize = sizeof(GUID);
        (pHashData->aEntries[ iIndex ]).pData = (const BYTE*) pConnectorGuid;
        iIndex++;
        pHashData->cEntries = iIndex;
    }

    hr = MQSigHashMessageProperties(hHash, pHashData);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1030);
    }

    //
    // It's time to verify if signature is ok.
    //
    ULONG ulSignatureSize = ((ULONG) pSecEx ->wSubSectionLen) -
                                    sizeof(struct _SecuritySubSectionEx);
    const UCHAR *pSignature = (const UCHAR *) &(pSecEx->aData[0]);

    if (!CryptVerifySignature(
				hHash,
				pSignature,
				ulSignatureSize,
				hPbKey,
				NULL,
				0
				))
    {
        dwErr = GetLastError();
        TrERROR(SECURITY, "fail at CryptVerifySignature(), gle = %!winerr!", dwErr);

        ASSERT_BENIGN(0);
        return MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX;
    }

    TrTRACE(SECURITY, "QM: VerifySignatureEx completed ok");

	//
	// mark the message as authenticated only when needed.
	// Certificate was found in the DS or certificate is not self signed
	//
	if(!fMarkAuth)
	{
        TrTRACE(SECURITY, "QM: The message will not mark as autheticated");
	    return MQ_OK;
	}

	//
	// mark the authentication flag and the level of authentication as SIG20
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIG20);
    return MQ_OK;
}

/***************************************************************************

Function:
    VerifySignature

Description:
    Verify that the signature in the packet fits the message body and the
    public key in certificate.

***************************************************************************/

HRESULT
VerifySignature(CQmPacket * PktPtrs)
{
    HRESULT hr;
    ULONG ulSignatureSize = 0;
    const UCHAR *pSignature;

    ASSERT(!PktPtrs->IsEncrypted());
    PktPtrs->SetAuthenticated(FALSE);
    PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATION_NOT_REQUESTED);


	//
    // Get the signature from the packet.
    //
    pSignature = PktPtrs->GetSignature((USHORT *)&ulSignatureSize);
    if ((!ulSignatureSize) && (PktPtrs->GetSignatureMqfSize() == 0))
    {
		//
        // No signature, nothing to verify.
		//
        return(MQ_OK);
    }

    BOOL fRetry = FALSE;
	bool fMarkAuth = true;

    do
    {
        HCRYPTPROV hProv = NULL;
        HCRYPTKEY hPbKey = NULL;
        R<QMPBKEYINFO> pQmPbKeyInfo;
        R<CERTINFO> pCertInfo;

        switch (PktPtrs->GetSenderIDType())
        {
        case MQMSG_SENDERID_TYPE_QM:
			{
				//
				// Get the QM's public key.
				//
				USHORT uSenderIDLen;

				GUID *pguidQM =((GUID *)PktPtrs->GetSenderID(&uSenderIDLen));
				ASSERT(uSenderIDLen == sizeof(GUID));
				if (uSenderIDLen != sizeof(GUID))
				{
					return LogHR(MQ_ERROR, s_FN, 210);
				}

				hr = GetQMPbKey(pguidQM, &pQmPbKeyInfo.ref(), fRetry);
				if (FAILED(hr))
				{
					if (hr == MQ_ERROR_INVALID_OWNER)
					{
						//
						// The first replication packet of a site is generated by
						// the new site's PSC. This PSC is not yet in the DS of the
						// receiving server. So if we could not find the machine in
						// the DS, we let the signature validation to complete with no
						// error. The packet is not marked as authenticated. The
						// code that receives the replication message recognizes
						// this packet as the first replication packet from a site.
						// It goes to the site object, that should already exist,
						// retrieves the public key of the PSC from the site object
						// and verify the packet signature.
						//
						return(MQ_OK);
					}

					return LogHR(hr, s_FN, 220);
				}
				hProv = g_hProvVer;
				hPbKey = pQmPbKeyInfo->hKey;
			}
			break;

        case MQMSG_SENDERID_TYPE_SID:
        case MQMSG_SENDERID_TYPE_NONE:
            //
            // Get the CSP information for the message certificate.
            //
            hr = GetCertInfo(PktPtrs, &pCertInfo.ref());
			if(SUCCEEDED(hr))
			{
				ASSERT(pCertInfo.get() != NULL);
				hProv = pCertInfo->hProv;
				hPbKey = pCertInfo->hPbKey;
				if((pCertInfo->pSid == NULL) && (pCertInfo->fSelfSign))
				{
					//
					// Certificate was not found in the DS (pSid == NULL)
					// and is self signed certificate.
					// In this case we will not mark the packet as authenticated
					// after verifying the signature.
					//
					fMarkAuth = false;
				}
			}

			break;
			
        default:
			ASSERT_BENIGN(("illegal SenderIdType", 0));
            hr = MQ_ERROR;
            break;
        }

        if (FAILED(hr))
        {
            TrERROR(SECURITY, "VerifySignature: Failed to authenticate a message, error = %x", hr);
            return LogHR(hr, s_FN, 230);
        }

		if(PktPtrs->GetSignatureMqfSize() != 0)
		{
			//
			// SignatureMqf support Mqf formats
			//
			try
			{
				VerifySignatureMqf(
						PktPtrs,
						hProv,
						hPbKey,
						fMarkAuth
						);
				return MQ_OK;
			}
			catch (const bad_CryptoApi& exp)
			{
				TrERROR(SECURITY, "QM: VerifySignature(), bad Crypto Class Api Excption ErrorCode = %x", exp.error());
				DBG_USED(exp);
				return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 232);
			}
			catch (const bad_hresult& exp)
			{
				TrERROR(SECURITY, "QM: VerifySignature(), bad hresult Class Api Excption ErrorCode = %x", exp.error());
				DBG_USED(exp);
				return LogHR(exp.error(), s_FN, 233);
			}
			catch (const bad_alloc&)
			{
				TrERROR(SECURITY, "QM: VerifySignature(), bad_alloc Excption");
				return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 234);
			}
		}

		ULONG dwBodySize;
        const UCHAR *pBody = PktPtrs->GetPacketBody(&dwBodySize);

        QUEUE_FORMAT RespQueueformat;
        QUEUE_FORMAT *pRespQueueformat = NULL;

        if (PktPtrs->GetResponseQueue(&RespQueueformat))
        {
            pRespQueueformat = &RespQueueformat;
        }

        QUEUE_FORMAT AdminQueueformat;
        QUEUE_FORMAT *pAdminQueueformat = NULL;

        if (PktPtrs->GetAdminQueue(&AdminQueueformat))
        {
            pAdminQueueformat = &AdminQueueformat;
        }

        if (PktPtrs->GetSenderIDType() != MQMSG_SENDERID_TYPE_QM)
        {
            hr = _VerifySignatureEx(
						PktPtrs,
						hProv,
						hPbKey,
						dwBodySize,
						pBody,
						pRespQueueformat,
						pAdminQueueformat,
						fMarkAuth
						);

            if (hr == MQ_INFORMATION_ENH_SIG_NOT_FOUND)
            {
                //
                // Enhanced signature not found. validate the msmq1.0
                // signature.
                //
            }
            else
            {
                return LogHR(hr, s_FN, 890);
            }
        }

        //
        // Compute the hash value and then validate the signature.
        //
        CHCryptHash hHash;

        if (!CryptCreateHash(hProv, PktPtrs->GetHashAlg(), 0, 0, &hHash))
        {
			DWORD gle = GetLastError();
			TrERROR(SECURITY, "CryptCreateHash() failed, gle = 0x%x", gle);
            LogNTStatus(gle, s_FN, 235);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        hr = HashMessageProperties(
                    hHash,
                    PktPtrs->GetCorrelation(),
                    PROPID_M_CORRELATIONID_SIZE,
                    PktPtrs->GetApplicationTag(),
                    pBody,
                    dwBodySize,
                    PktPtrs->GetTitlePtr(),
                    PktPtrs->GetTitleLength() * sizeof(WCHAR),
                    pRespQueueformat,
                    pAdminQueueformat
					);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 240);
        }

        if (!CryptVerifySignature(
					hHash,
					pSignature,
					ulSignatureSize,
					hPbKey,
					NULL,
					0
					))
        {
            if (PktPtrs->GetSenderIDType() == MQMSG_SENDERID_TYPE_QM)
            {
                fRetry = !fRetry;
                if (!fRetry)
                {
                    //
                    // When the keys of a PSC are replaced, the new public
                    // key is written in the site object directly on the PEC.
                    // The PEC replicates the change in the site object, so
                    // the signature can be verified according to the site
                    // object, similarly to the case where the QM is not
                    // found in the DS yet (after installing the new PSC).
                    // The packet is not marked as authenticated, so the
                    // code that handles the replication message will try
                    // to verify the signature according to the public key
                    // that is in the site object.
                    //
                    return(MQ_OK);
                }
            }
            else
            {
                return LogHR(MQ_ERROR, s_FN, 250);
            }
        }
        else
        {
            fRetry = FALSE;
        }
    } while (fRetry);

    TrTRACE(SECURITY, "QM: VerifySignature10 completed ok");

	//
	// mark the message as authenticated only when needed.
	// Certificate was found in the DS or certificate is not self signed
	//
	if(!fMarkAuth)
	{
        TrTRACE(SECURITY, "QM: The message will not mark as autheticated");
	    return MQ_OK;
	}

	//
	// All is well, mark the message that it is an authenticated message.
	// mark the authentication flag and the level of authentication as SIG10
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIG10);

    return(MQ_OK);
}

/***************************************************************************

Function:
    QMSecurityInit

Description:
    Initialize the QM security module.

***************************************************************************/

HRESULT
QMSecurityInit()
{
    if(!MQSec_CanGenerateAudit())
    {
        EvReport(EVENT_WARN_QM_CANNOT_GENERATE_AUDITS);
    }

    DWORD dwType = REG_DWORD;
    DWORD dwSize;
    ULONG lError;
    //
    // Initialize symmetric keys map parameters.
    //

    BOOL  fVal ;
    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
                    MSMQ_RC2_SNDEFFECTIVE_40_REGNAME,
					&dwType,
					&fVal,
					&dwSize
					);
    if (lError == ERROR_SUCCESS)
    {
        g_fSendEnhRC2WithLen40 = !!fVal ;

        if (g_fSendEnhRC2WithLen40)
        {
	        TrERROR(SECURITY, "will encrypt with enhanced RC2 symm key but only 40 bits effective key length");
            EvReport(EVENT_USE_RC2_LEN40) ;
        }
    }

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
                     MSMQ_REJECT_RC2_IFENHLEN_40_REGNAME,
					&dwType,
					&fVal,
					&dwSize
					);
    if (lError == ERROR_SUCCESS)
    {
        g_fRejectEnhRC2WithLen40 = !!fVal ;

        if (g_fRejectEnhRC2WithLen40)
        {
	        TrTRACE(SECURITY, "will reject received messages that use enhanced RC2 symm key with 40 bits effective key length");
        }
    }

    DWORD dwCryptKeyBaseExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_KEY_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwCryptKeyBaseExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptKeyBaseExpirationTime = CRYPT_KEY_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    DWORD dwCryptKeyEnhExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_KEY_ENH_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwCryptKeyEnhExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptKeyEnhExpirationTime = CRYPT_KEY_ENH_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    DWORD dwCryptSendKeyCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_SEND_KEY_CACHE_REG_NAME,
					&dwType,
					&dwCryptSendKeyCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptSendKeyCacheSize = CRYPT_SEND_KEY_CACHE_DEFAULT_SIZE;
    }

    DWORD dwCryptReceiveKeyCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_RECEIVE_KEY_CACHE_REG_NAME,
					&dwType,
					&dwCryptReceiveKeyCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptReceiveKeyCacheSize = CRYPT_RECEIVE_KEY_CACHE_DEFAULT_SIZE;
    }

    InitSymmKeys(
        CTimeDuration::FromMilliSeconds(dwCryptKeyBaseExpirationTime),
        CTimeDuration::FromMilliSeconds(dwCryptKeyEnhExpirationTime),
        dwCryptSendKeyCacheSize,
        dwCryptReceiveKeyCacheSize
        );

    //
    // Initialize Certificates map parameters.
    //

    DWORD dwCertInfoCacheExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CERT_INFO_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwCertInfoCacheExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCertInfoCacheExpirationTime = CERT_INFO_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    g_CertInfoMap.m_CacheLifetime = CTimeDuration::FromMilliSeconds(dwCertInfoCacheExpirationTime);

    DWORD dwCertInfoCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CERT_INFO_CACHE_SIZE_REG_NAME,
					&dwType,
					&dwCertInfoCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCertInfoCacheSize = CERT_INFO_CACHE_DEFAULT_SIZE;
    }

    g_CertInfoMap.InitHashTable(dwCertInfoCacheSize);

    //
    // Initialize QM public key map parameters.
    //

    DWORD dwQmPbKeyCacheExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					QM_PB_KEY_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwQmPbKeyCacheExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwQmPbKeyCacheExpirationTime = QM_PB_KEY_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    g_MapQmPbKey.m_CacheLifetime = CTimeDuration::FromMilliSeconds(dwQmPbKeyCacheExpirationTime);

    DWORD dwQmPbKeyCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					QM_PB_KEY_CACHE_SIZE_REG_NAME,
					&dwType,
					&dwQmPbKeyCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwQmPbKeyCacheSize = QM_PB_KEY_CACHE_DEFAULT_SIZE;
    }

    g_MapQmPbKey.InitHashTable(dwQmPbKeyCacheSize);


    //
    // Initialize User Authz context map parameters.
    //

    DWORD dwUserCacheExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					USER_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwUserCacheExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwUserCacheExpirationTime = USER_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    DWORD dwUserCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					USER_CACHE_SIZE_REG_NAME,
					&dwType,
					&dwUserCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwUserCacheSize = USER_CACHE_SIZE_DEFAULT_SIZE;
    }

    InitUserMap(
        CTimeDuration::FromMilliSeconds(dwUserCacheExpirationTime),
        dwUserCacheSize
        );

    return MQ_OK;
}

/***************************************************************************

Function:
    SignProperties

Description:
    Sign the challenge and the properties.

***************************************************************************/

static
HRESULT
SignProperties(
    HCRYPTPROV  hProv,
    BYTE        *pbChallenge,
    DWORD       dwChallengeSize,
    DWORD       cp,
    PROPID      *aPropId,
    PROPVARIANT *aPropVar,
    BYTE        *pbSignature,
    DWORD       *pdwSignatureSize)
{
    //
    // Create a hash object and hash the challenge.
    //
    CHCryptHash hHash;
    if (!CryptCreateHash(hProv, CALG_MD5, NULL, 0, &hHash))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "CryptCreateHash() failed, %!winerr!", gle);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 255);
    }

    if (!CryptHashData(hHash, pbChallenge, dwChallengeSize, 0))
    {
		DWORD gle = GetLastError();
		TrERROR(SECURITY, "CryptHashData() failed, %!winerr!", gle);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 260);
    }

    if (cp)
    {
        //
        // Hash the properties.
        //
        HRESULT hr = HashProperties(hHash, cp, aPropId, aPropVar);
        if (FAILED(hr))
        {
			TrERROR(SECURITY, "HashProperties failed, hr = 0x%x", hr);
            return LogHR(hr, s_FN, 270);
        }
    }

    //
    // Sign it all.
    //
    if (!CryptSignHash(
            hHash,
            AT_SIGNATURE,
            NULL,
            0,
            pbSignature,
            pdwSignatureSize))
    {
        DWORD dwerr = GetLastError();
        if (dwerr == ERROR_MORE_DATA)
        {
			TrERROR(SECURITY, "CryptSignHash() failed, %!winerr!", dwerr);
            return MQ_ERROR_USER_BUFFER_TOO_SMALL;
        }
        else
        {
			TrERROR(SECURITY, "CryptSignHash() failed, %!winerr!", dwerr);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
    }

    return(MQ_OK);
}

HRESULT
QMSignGetSecurityChallenge(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR /*dwContext*/,
    OUT    BYTE    *pbChallengeResponce,
    IN OUT DWORD   *pdwChallengeResponceSize,
    IN     DWORD   dwChallengeResponceMaxSize)
{

    *pdwChallengeResponceSize = dwChallengeResponceMaxSize;

    //
    // challenge is always signed with base provider.
    //
    HCRYPTPROV hProvQM = NULL ;
    HRESULT hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                             &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340) ;
    }

    ASSERT(hProvQM) ;
    hr = SignProperties(
            hProvQM,
            pbChallenge,
            dwChallengeSize,
            0,
            NULL,
            NULL,
            pbChallengeResponce,
            pdwChallengeResponceSize);

    return LogHR(hr, s_FN, 350);
}


/***************************************************************************

Function:
    GetAdminGroupSecurityDescriptor

Description:
    Get local admin group security descriptor, with the right premissions.

Environment:
    Windows NT only

***************************************************************************/
static
PSECURITY_DESCRIPTOR
GetAdminGroupSecurityDescriptor(
    DWORD AccessMask
    )
{
    //
    // Get the SID of the local administrators group.
    //
	PSID pAdminSid = MQSec_GetAdminSid();

    P<SECURITY_DESCRIPTOR> pSD = new SECURITY_DESCRIPTOR;

    //
    // Allocate a DACL for the local administrators group
    //
    DWORD dwDaclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(pAdminSid);
    P<ACL> pDacl = (PACL) new BYTE[dwDaclSize];

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the administrator group.
    //

    if(
        //
        // Construct DACL with administrator
        //
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, AccessMask, pAdminSid) ||

        //
        // Construct Security Descriptor
        //
        !InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION) ||
        !SetSecurityDescriptorOwner(pSD, pAdminSid, FALSE) ||
        !SetSecurityDescriptorGroup(pSD, pAdminSid, FALSE) ||
        !SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE))
    {
        return 0;
    }

    pDacl.detach();
    return pSD.detach();
}


/***************************************************************************

Function:
    FreeAdminGroupSecurityDescriptor

Description:
    Free Security descriptor allocated by GetAdminGroupSecurityDescriptor

Environment:
    Windows NT only

***************************************************************************/
static
void
FreeAdminGroupSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    SECURITY_DESCRIPTOR* pSD = static_cast<SECURITY_DESCRIPTOR*>(pSecurityDescriptor);
    delete ((BYTE*)pSD->Dacl);
    delete pSD;
}


/***************************************************************************

Function:
    MapMachineQueueAccess

Description:
    Converts the access mask passed to MQOpenQueue for a machine queue to the
    access mask that should be used when checking the access rights in the
    security descriptor.

Environment:
    Windows NT only

***************************************************************************/
static
DWORD
MapMachineQueueAccess(
    DWORD dwAccess,
    BOOL fJournalQueue)
{
    DWORD dwDesiredAccess = 0;

    ASSERT(!(dwAccess & MQ_SEND_ACCESS));

    if (dwAccess & MQ_RECEIVE_ACCESS)
    {
        dwDesiredAccess |=
            fJournalQueue ? MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE :
                            MQSEC_RECEIVE_DEADLETTER_MESSAGE;
    }

    if (dwAccess & MQ_PEEK_ACCESS)
    {
        dwDesiredAccess |=
            fJournalQueue ? MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE :
                            MQSEC_PEEK_DEADLETTER_MESSAGE;
    }

    return dwDesiredAccess;
}


/***************************************************************************

Function:
    MapQueueOpenAccess

Description:
    Converts the access mask passed to MQOpenQueue to the access mask that
    should be used when checking the access rights in the security
    descriptor.

Environment:
    Windows NT only

***************************************************************************/
static
DWORD
MapQueueOpenAccess(
    DWORD dwAccess,
    BOOL fJournalQueue)
{
    DWORD dwDesiredAccess = 0;

    if (dwAccess & MQ_RECEIVE_ACCESS)
    {
        dwDesiredAccess |=
            fJournalQueue ? MQSEC_RECEIVE_JOURNAL_MESSAGE :
                            MQSEC_RECEIVE_MESSAGE;
    }

   