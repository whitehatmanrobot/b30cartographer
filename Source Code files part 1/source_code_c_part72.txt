 locks.

long g_cObj = 0 ;
ULONG g_cLock = 0 ;
HMODULE ghModule = NULL;

// Used for error object storage
CWbemErrorCache *g_pErrorCache = NULL;

/*
 * This object is used to protect the global pointer:
 * 
 *	- g_pErrorCache 
 *
 * Note that it is the pointer variables that are protected by 
 * this CS, rather than the addressed objects.
 */
CRITICAL_SECTION g_csErrorCache;

// Used to protect security calls
CRITICAL_SECTION g_csSecurity;

// CLSID for our implementation of IParseDisplayName
// {172BDDF8-CEEA-11d1-8B05-00600806D9B6}
DEFINE_GUID(CLSID_SWbemParseDN, 
0x172bddf8, 0xceea, 0x11d1, 0x8b, 0x5, 0x0, 0x60, 0x8, 0x6, 0xd9, 0xb6);

// Forward defs
static void UnregisterTypeLibrary (unsigned short wVerMajor, unsigned short wVerMinor);

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	_RD(static char *me = "DllMain";)
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
		{
			_RPrint(me, "DLL_PROCESS_DETACH", 0, "");
			DeleteCriticalSection (&g_csErrorCache);
			DeleteCriticalSection (&g_csSecurity);
			CSWbemLocator::Shutdown ();
			CIWbemObjectSinkMethodCache::TidyUp ();
		}
			return TRUE;

		case DLL_THREAD_DETACH:
		{
			_RPrint(me, "DLL_THREAD_DETACH", 0, "");
		}
			return TRUE;

		case DLL_PROCESS_ATTACH:
		{
			_RPrint(me, "DLL_PROCESS_DETACH", 0, "");
			if(ghModule == NULL)
				ghModule = hInstance;

			InitializeCriticalSection (&g_csErrorCache);
			InitializeCriticalSection (&g_csSecurity);
			CIWbemObjectSinkMethodCache::Initialize ();
		}
	        return TRUE;

		case DLL_THREAD_ATTACH:
        {
			_RPrint(me, "DLL_THREAD_ATTACH", 0, "");
        }
			return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;
	CSWbemFactory *pObj = NULL;

	if (CLSID_SWbemLocator == rclsid) 
        pObj=new CSWbemFactory(CSWbemFactory::LOCATOR);
	else if (CLSID_SWbemSink == rclsid)
        pObj=new CSWbemFactory(CSWbemFactory::SINK);
    else if (CLSID_SWbemNamedValueSet == rclsid) 
        pObj=new CSWbemFactory(CSWbemFactory::CONTEXT);
	else if (CLSID_SWbemObjectPath == rclsid)
        pObj=new CSWbemFactory(CSWbemFactory::OBJECTPATH);
	else if (CLSID_SWbemParseDN == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::PARSEDN);
	else if (CLSID_SWbemLastError == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::LASTERROR);
	else if (CLSID_SWbemDateTime == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::DATETIME);
	else if (CLSID_SWbemRefresher == rclsid)
		pObj = new CSWbemFactory(CSWbemFactory::REFRESHER);

    if(NULL == pObj)
        return E_FAIL;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	// It is OK to unload if there are no objects or locks on the
    // class factory.

	HRESULT status = S_FALSE;
	_RD(static char *me = "DllCanUnloadNow";)
	_RPrint(me, "Called", 0, "");

	if (0L==g_cObj && 0L==g_cLock)
	{
		_RPrint(me, "Unloading", 0, "");
		/*
		 * Release the error object on this thread, if any
		 */
		status = S_OK;

		EnterCriticalSection (&g_csErrorCache);

		if (g_pErrorCache)
		{
			delete g_pErrorCache;
			g_pErrorCache = NULL;
		}

		LeaveCriticalSection (&g_csErrorCache);

		CSWbemSecurity::Uninitialize ();
	}

    return status;
}

//***************************************************************************
//
//  STDAPI RegisterProgID
//	STDAPI RegisterCoClass	
//	STDAPI RegisterTypeLibrary
//	STDAPI RegisterDefaultNamespace
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry setup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

STDAPI RegisterProgID (LPCTSTR wcID, LPCTSTR desc, LPCTSTR progid, 
						LPCTSTR descVer, LPCTSTR progidVer)
{
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;

    TCHAR		*szProgID = new TCHAR [_tcslen (WBEMS_RK_SC) + 
					_tcslen (progid) + 1];

	if (!szProgID)
		return E_OUTOFMEMORY;

	TCHAR		*szProgIDVer = new TCHAR [_tcslen (WBEMS_RK_SC) + _tcslen (progidVer) + 1];

	if (!szProgIDVer)
	{
		delete [] szProgID;
		return E_OUTOFMEMORY;
	}

	_tcscpy (szProgID, WBEMS_RK_SC);
	_tcscat (szProgID, progid);
	
	_tcscpy (szProgIDVer, WBEMS_RK_SC);
	_tcscat (szProgIDVer, progidVer);
	
	// Add the ProgID (Version independent)
	if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szProgID, &hKey1))
	{
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)desc, (_tcslen(desc)+1) * sizeof(TCHAR));

		if(ERROR_SUCCESS == RegCreateKey(hKey1,WBEMS_RK_CLSID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)wcID, 
										(_tcslen(wcID)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
			hKey2 = NULL;
		}

		if(ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_CURVER, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)progidVer, 
										(_tcslen(progidVer)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
			hKey2 = NULL;
		}
		RegCloseKey(hKey1);
	}

	// Add the ProgID (Versioned)
	if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szProgIDVer, &hKey1))
	{
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)descVer, (_tcslen(descVer)+1) * sizeof(TCHAR));

		if(ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_CLSID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)wcID, 
										(_tcslen(wcID)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
			hKey2 = NULL;
		}

		RegCloseKey(hKey1);
	}

	delete [] szProgID;
	delete [] szProgIDVer;
	
	return NOERROR;
}

STDAPI RegisterCoClass (REFGUID clsid, LPCTSTR desc, LPCTSTR progid, LPCTSTR progidVer, 
					  LPCTSTR ver, LPCTSTR descVer)
{
	HRESULT		hr = S_OK;
	OLECHAR		wcID[GUIDSIZE];
	OLECHAR		tlID[GUIDSIZE];
	TCHAR		nwcID[GUIDSIZE];
	TCHAR		ntlID[GUIDSIZE];
    TCHAR		szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

	TCHAR *szCLSID = new TCHAR [_tcslen (WBEMS_RK_SCC) + GUIDSIZE + 1];

	if (!szCLSID)
		return E_OUTOFMEMORY;

    // Create the path.
    if(0 ==StringFromGUID2(clsid, wcID, GUIDSIZE))
	{
		delete [] szCLSID;
		return ERROR;
	}

	_tcscpy (szCLSID, WBEMS_RK_SCC);

#ifndef UNICODE
	wcstombs(nwcID, wcID, GUIDSIZE);
#else
	_tcscpy (nwcID, wcID);
#endif

    _tcscat (szCLSID, nwcID);
	
	if (0 == StringFromGUID2 (LIBID_WbemScripting, tlID, GUIDSIZE))
	{
		delete [] szCLSID;
		return ERROR;
	}

#ifndef UNICODE
	wcstombs (ntlID, tlID, GUIDSIZE);	
#else
	_tcscpy (ntlID, tlID);
#endif
	
	if(0 == GetModuleFileName(ghModule, szModule,  MAX_PATH))
	{
		delete [] szCLSID;
		return ERROR;
	}

    // Create entries under CLSID

    if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1))
	{
		// Description (on main key)
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)desc, (_tcslen(desc)+1) * sizeof(TCHAR));

		// Register as inproc server
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_INPROC32 ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
										(_tcslen(szModule)+1) * sizeof(TCHAR));
			RegSetValueEx(hKey2, WBEMS_RK_THRDMODEL, 0, REG_SZ, (BYTE *)WBEMS_RV_APARTMENT, 
                                        (_tcslen(WBEMS_RV_APARTMENT)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
		}

		// Give a link to the type library (useful for statement completion in scripting tools)
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_TYPELIB, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)ntlID, (_tcslen(ntlID)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
		}

		// Register the ProgID
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_PROGID ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)progidVer, 
										(_tcslen(progidVer)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
        }

		// Register the version-independent ProgID

		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_VERPROGID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)progid, 
										(_tcslen(progid)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
        }

		// Register the version
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_VERSION, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)ver, (_tcslen(ver)+1) * sizeof(TCHAR));
			RegCloseKey(hKey2);
        }

		// Register this control as programmable
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_PROGRAMMABLE ,&hKey2))
		{
			RegCloseKey(hKey2);
        }

		RegCloseKey(hKey1);
	}
	else
	{
		delete [] szCLSID;
		return ERROR;
	}

	delete [] szCLSID;


	return RegisterProgID (nwcID, desc, progid, descVer, progidVer);
}

STDAPI RegisterTypeLibrary ()
{
	// AUTOMATION.  register type library
	TCHAR cPath[MAX_PATH+1];
        cPath[MAX_PATH] = 0;
	if(GetModuleFileName(ghModule,cPath,MAX_PATH))
	{
		// Replace final 3 characters "DLL" by "TLB"
		TCHAR *pExt = _tcsrchr (cPath, _T('.'));

		if (pExt && (0 == _tcsicmp (pExt, _T(".DLL"))))
		{
			_tcscpy (pExt + 1, _T("TLB"));
			OLECHAR wPath [MAX_PATH];
#ifndef UNICODE
			mbstowcs (wPath, cPath, MAX_PATH-1);
#else
			_tcsncpy (wPath, cPath, MAX_PATH-1);
#endif
			ITypeLib FAR* ptlib = NULL; 
			SCODE sc = LoadTypeLib(wPath, &ptlib);
			if(sc == 0 && ptlib)
			{
				sc = RegisterTypeLib(ptlib,wPath,NULL);
				ptlib->Release();

				// Unregister the previous library version(s)
				UnregisterTypeLibrary (1, 1);
				UnregisterTypeLibrary (1, 0);
			}
		}
	}
	
	return NOERROR;
}

STDAPI RegisterScriptSettings ()
{
	HKEY hKey;

	if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, WBEMS_RK_SCRIPTING, &hKey))
		return ERROR;

	// Need to know what O/S we are to set up the right registry keys
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	GetVersionEx (&osVersionInfo);
	bool bIsNT = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
	DWORD dwNTMajorVersion = osVersionInfo.dwMajorVersion;
		
	// Default namespace value - exists on all platforms
	RegSetValueEx(hKey, WBEMS_RV_DEFNS, 0, REG_SZ, (BYTE *)WBEMS_DEFNS, 
                                        (_tcslen(WBEMS_DEFNS)+1) * sizeof(TCHAR));

	// Enable for ASP - on NT 4.0 or less only
	if (bIsNT && (dwNTMajorVersion <= 4))
	{
		DWORD	defaultEnableForAsp = 0;
		RegSetValueEx(hKey, WBEMS_RV_ENABLEFORASP, 0, REG_DWORD, (BYTE *)&defaultEnableForAsp,
							sizeof (defaultEnableForAsp));
	}

	// Default impersonation level - NT only
	if (bIsNT)
	{
		DWORD	defaultImpersonationLevel = (DWORD) wbemImpersonationLevelImpersonate;
		RegSetValueEx(hKey, WBEMS_RV_DEFAULTIMPLEVEL, 0, REG_DWORD, (BYTE *)&defaultImpersonationLevel,
							sizeof (defaultImpersonationLevel));
	}

	RegCloseKey(hKey);

	return NOERROR;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
	HRESULT hr;

	if (
		(NOERROR == (hr = RegisterScriptSettings ())) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemLocator, WBEMS_LOC_DESCRIPTION, 
			WBEMS_LOC_PROGID, WBEMS_LOC_PROGIDVER, WBEMS_LOC_VERSION, 
			WBEMS_LOC_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemSink,
			WBEMS_SINK_DESCRIPTION, WBEMS_SINK_PROGID, WBEMS_SINK_PROGIDVER, 
			WBEMS_SINK_VERSION, WBEMS_SINK_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemNamedValueSet,
			WBEMS_CON_DESCRIPTION, WBEMS_CON_PROGID, WBEMS_CON_PROGIDVER, 
			WBEMS_CON_VERSION, WBEMS_CON_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemParseDN,
					WBEMS_PDN_DESCRIPTION, WBEMS_PDN_PROGID, WBEMS_PDN_PROGIDVER, 
			WBEMS_PDN_VERSION, WBEMS_PDN_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemObjectPath,
					WBEMS_OBP_DESCRIPTION, WBEMS_OBP_PROGID, WBEMS_OBP_PROGIDVER, 
			WBEMS_OBP_VERSION, WBEMS_OBP_VERDESC))) &&
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemLastError,
					WBEMS_LER_DESCRIPTION, WBEMS_LER_PROGID, WBEMS_LER_PROGIDVER, 
			WBEMS_LER_VERSION, WBEMS_LER_VERDESC))) && 
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemDateTime,
					WBEMS_DTIME_DESCRIPTION, WBEMS_DTIME_PROGID, WBEMS_DTIME_PROGIDVER, 
			WBEMS_DTIME_VERSION, WBEMS_DTIME_VERDESC))) && 
		(NOERROR == (hr = RegisterCoClass (CLSID_SWbemRefresher,
					WBEMS_REF_DESCRIPTION, WBEMS_REF_PROGID, WBEMS_REF_PROGIDVER, 
			WBEMS_REF_VERSION, WBEMS_REF_VERDESC)))
	   )
				hr = RegisterTypeLibrary ();

	return hr;
}

//***************************************************************************
//
//  STDAPI UnregisterProgID
//	STDAPI UnregisterCoClass	
//	STDAPI UnregisterTypeLibrary
//	STDAPI UnregisterDefaultNamespace
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry cleanup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

void UnregisterProgID (LPCTSTR progid, LPCTSTR progidVer)
{
	HKEY hKey = NULL;

	TCHAR		*szProgID = new TCHAR [_tcslen (WBEMS_RK_SC) + _tcslen (progid) + 1];
	TCHAR		*szProgIDVer = new TCHAR [_tcslen (WBEMS_RK_SC) + _tcslen (progidVer) + 1];

	if (szProgID && szProgIDVer)
	{
		_tcscpy (szProgID, WBEMS_RK_SC);
		_tcscat (szProgID, progid);
		
		_tcscpy (szProgIDVer, WBEMS_RK_SC);
		_tcscat (szProgIDVer, progidVer);


		// Delete the subkeys of the versioned HKCR\ProgID entry
		if (NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szProgIDVer, &hKey))
		{
			RegDeleteKey(hKey, WBEMS_RK_CLSID);
			RegCloseKey(hKey);
		}

		// Delete the versioned HKCR\ProgID entry
		RegDeleteKey (HKEY_LOCAL_MACHINE, szProgIDVer);

		// Delete the subkeys of the HKCR\VersionIndependentProgID entry
		if (NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szProgID, &hKey))
		{
			RegDeleteKey(hKey, WBEMS_RK_CLSID);
			DWORD dwRet = RegDeleteKey(hKey, WBEMS_RK_CURVER);
			RegCloseKey(hKey);
		}

		// Delete the HKCR\VersionIndependentProgID entry
		RegDeleteKey (HKEY_LOCAL_MACHINE, szProgID);
	}

	if (szProgID)
		delete [] szProgID;

	if (szProgIDVer)
		delete [] szProgIDVer;
}


void UnregisterCoClass (REFGUID clsid, LPCTSTR progid, LPCTSTR progidVer)
{
	OLECHAR		wcID[GUIDSIZE];
    TCHAR		nwcID[GUIDSIZE];
    HKEY		hKey = NULL;

	TCHAR		*szCLSID = new TCHAR [_tcslen (WBEMS_RK_SCC) + GUIDSIZE + 1];

	if (szCLSID)
	{
		// Create the path using the CLSID

		if(0 != StringFromGUID2(clsid, wcID, GUIDSIZE))
		{
#ifndef UNICODE
			wcstombs(nwcID, wcID, GUIDSIZE);
#else
			_tcscpy (nwcID, wcID);
#endif
			_tcscpy (szCLSID, WBEMS_RK_SCC);
			_tcscat (szCLSID, nwcID);
		
			// First delete the subkeys of the HKLM\Software\Classes\CLSID\{GUID} entry
			if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey))
			{
				RegDeleteKey(hKey, WBEMS_RK_INPROC32);
				RegDeleteKey(hKey, WBEMS_RK_TYPELIB);
				RegDeleteKey(hKey, WBEMS_RK_PROGID);
				RegDeleteKey(hKey, WBEMS_RK_VERPROGID);
				RegDeleteKey(hKey, WBEMS_RK_VERSION);
				RegDeleteKey(hKey, WBEMS_RK_PROGRAMMABLE);
				RegCloseKey(hKey);
			}

			// Delete the HKLM\Software\Classes\CLSID\{GUID} key
			if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, WBEMS_RK_SCC, &hKey))
			{
				RegDeleteKey(hKey, nwcID);
				RegCloseKey(hKey);
			}
		}

		delete [] szCLSID;
	}

	UnregisterProgID (progid, progidVer);
}

static void UnregisterTypeLibrary (unsigned short wVerMajor, unsigned short wVerMinor)
{
	//	Unregister the type library.  The UnRegTypeLib function is not available in
    //  in some of the older version of the ole dlls and so it must be loaded
    //  dynamically
    HRESULT (STDAPICALLTYPE *pfnUnReg)(REFGUID, WORD,
            WORD , LCID , SYSKIND);

    TCHAR path[ MAX_PATH+20 ];
    GetSystemDirectory(path, MAX_PATH);
    _tcscat(path, _T("\\oleaut32.dll"));

    HMODULE g_hOle32 = LoadLibraryEx(path, NULL, 0);

    if(g_hOle32 != NULL) 
    {
        (FARPROC&)pfnUnReg = GetProcAddress(g_hOle32, "UnRegisterTypeLib");
        if(pfnUnReg) 
            pfnUnReg (LIBID_WbemScripting, wVerMajor, wVerMinor, 0, SYS_WIN32);
        FreeLibrary(g_hOle32);
    }
}

void UnregisterScriptSettings ()
{
	HKEY hKey;
		
	if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, WBEMS_RK_WBEM, &hKey))
	{
		RegDeleteKey(hKey, WBEMS_SK_SCRIPTING);
		RegCloseKey (hKey);
	}
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	UnregisterScriptSettings ();
	UnregisterCoClass (CLSID_SWbemLocator, WBEMS_LOC_PROGID, WBEMS_LOC_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemSink, WBEMS_SINK_PROGID, WBEMS_SINK_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemNamedValueSet, WBEMS_CON_PROGID, WBEMS_CON_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemLastError, WBEMS_LER_PROGID, WBEMS_LER_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemObjectPath, WBEMS_OBP_PROGID, WBEMS_OBP_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemParseDN, WBEMS_PDN_PROGID, WBEMS_PDN_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemDateTime, WBEMS_DTIME_PROGID, WBEMS_DTIME_PROGIDVER);
	UnregisterCoClass (CLSID_SWbemRefresher, WBEMS_REF_PROGID, WBEMS_REF_PROGIDVER);
	UnregisterTypeLibrary (1, 2);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\nvalue.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  NVALUE.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemNamedValue
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemNamedValue::CSWbemNamedValue
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************
// changed due to Bug ID 572567
CSWbemNamedValue::CSWbemNamedValue(
	CSWbemServices *pService, 
	CSWbemNamedValueSet *pCSWbemNamedValueSet, 
	bool bMutable
)
		: m_bMutable (bMutable),
		  m_cRef (1),
		  m_pCSWbemNamedValueSet (pCSWbemNamedValueSet),
		  m_pSWbemServices (pService)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValue, 
						CLSID_SWbemNamedValue, L"SWbemNamedValue");
    
	if (m_pCSWbemNamedValueSet)
		m_pCSWbemNamedValueSet->AddRef ();
	
	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_name = NULL;
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValue::~CSWbemNamedValue
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemNamedValue::~CSWbemNamedValue(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pCSWbemNamedValueSet)
	{
		m_pCSWbemNamedValueSet->Release ();
		m_pCSWbemNamedValueSet = NULL;
	}

	if (m_pSWbemServices)
	{
		m_pSWbemServices->Release ();
		m_pSWbemServices = NULL;
	}

	if(m_name)
	{
		SysFreeString (m_name);
	}
}

//***************************************************************************
// HRESULT CSWbemNamedValue::QueryInterface
// long CSWbemNamedValue::AddRef
// long CSWbemNamedValue::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValue::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemNamedValue==riid)
		*ppv = (ISWbemNamedValue *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemNamedValue::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemNamedValue::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemNamedValue::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValue::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemNamedValue == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValue::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the value
//
//  PARAMETERS:
//
//		pValue		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::get_Value (
	VARIANT *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		VariantClear (pValue);
		IWbemContext *pIWbemContext = m_pCSWbemNamedValueSet->GetIWbemContext ();

		if (pIWbemContext)
		{
			hr = pIWbemContext->GetValue (m_name, 0, pValue);
			pIWbemContext->Release ();
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValue::put_Value
//
//  DESCRIPTION:
//
//  Set the value
//
//  PARAMETERS:
//
//		pVal		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::put_Value (
	VARIANT *pVal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pVal)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else 
	{
		CComPtr<IWbemContext> pIWbemContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.		
		pIWbemContext.Attach(m_pCSWbemNamedValueSet->GetIWbemContext ());

		if (pIWbemContext)
		{
			CWbemPathCracker *pPathCracker = m_pCSWbemNamedValueSet->GetWbemPathCracker ();
			CIMTYPE newCimType = CIM_ILLEGAL;

			if (VT_BYREF & V_VT(pVal))
			{
				// We must dereference all byref's
				VARIANT var;
				VariantInit (&var);

				if (VT_ARRAY & V_VT(pVal))
				{
					var.vt = V_VT(pVal) & ~VT_BYREF;
					hr = SafeArrayCopy (*(pVal->pparray), &(var.parray));
				}
				else
					hr = VariantChangeType(&var, pVal, 0, V_VT(pVal) & ~VT_BYREF);

				if (SUCCEEDED(hr))
				{
					// Here the oldCimType is a "serving suggestion" - if
					// we need a different cimtype to match the new value
					// so be it, even if it's CIM_ILLEGAL
					newCimType = MapVariantTypeToCimType (&var, CIM_ILLEGAL);
					
					bool ok = true;

					// If we have a keylist, must ensure we can set it in the
					// keylist first
					if (pPathCracker)
					{
						if (pPathCracker->SetKey (m_name, (WbemCimtypeEnum) newCimType, var))
							ok = false;
					}
					
					if (ok)
					{
						// Finally set it in the context itself
						hr = pIWbemContext->SetValue (m_name, 0, &var);
					}
					else
						hr = WBEM_E_FAILED;
				}
				
				VariantClear (&var);
			}
			else if ((VT_ERROR == V_VT(pVal)) && (DISP_E_PARAMNOTFOUND == pVal->scode))
			{
				// Treat as NULL assignment
				pVal->vt = VT_NULL;
				
				// NULL assigments not valid for keylists
				if (pPathCracker)
					hr = WBEM_E_FAILED;
				else
				{
					hr = pIWbemContext->SetValue (m_name, 0, pVal);
				}	
			}
			else
			{
				// Here the oldCimType is a "serving suggestion" - if
				// we need a different cimtype to match the new value
				// so be it, even if it's CIM_ILLEGAL
				newCimType = MapVariantTypeToCimType (pVal, CIM_ILLEGAL);
				
				bool ok = true;

				// If we have a keylist, must ensure we can set it in the
				// keylist first
				if (pPathCracker)
				{
					if (pPathCracker->SetKey (m_name, (WbemCimtypeEnum) newCimType, *pVal))
						ok = false;
				}
				
				if (ok)
				{
					// Finally set it in the context itself
					hr = pIWbemContext->SetValue (m_name, 0, pVal);
				}
				else
					hr = WBEM_E_FAILED;
			}

			if (pPathCracker)
				pPathCracker->Release ();
		}
	}		

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValue::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the value name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
		*pName = SysAllocString (m_name);

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  HRESULT CSWbemNamedValue::SetName
//
//  DESCRIPTION:
//
//  Sets the Name of the Named-Value pair
//
//  PARAMETERS:
//
//		strName		Name of the Named-valuepair
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	E_OUTOFMEMORY				out of memory conditions
//
//	Function added for Bug ID 572567
//***************************************************************************
HRESULT CSWbemNamedValue::SetName (
	BSTR strName
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == strName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
		m_name = SysAllocString (strName);

	if(m_name == NULL)
	{
		hr =  E_OUTOFMEMORY;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValue::CNamedValueDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValue::CNamedValueDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Value property) which
	 * supplied an argument.  Since the Value property is of type VARIANT, this may
	 * be legal but undetectable by the standard Dispatch mechanism, because in the
	 * the case that the named value happens to be an array type, it is meaningful to
	 * pass an index (the interpretation is that the index specifies an offset in
	 * the VT_ARRAY|VT_VARIANT structure that represents the named value).
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_NOTACOLLECTION == hr) && (pdispparams->cArgs > 0))
	{
		// Looks promising - get the object to try and resolve this
			
		ISWbemNamedValue *pNamedValue = NULL;

		// This tells us where to expect the array index to appear in the argument list
		UINT indexArg = (DISPATCH_PROPERTYGET & wFlags) ? 0 : 1;
		
		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemNamedValue, (PPVOID) &pNamedValue)))
		{
			// Extract the current named value
			VARIANT vNVal;
			VariantInit (&vNVal);

			if (SUCCEEDED(pNamedValue->get_Value (&vNVal)) && V_ISARRAY(&vNVal))
			{
				VARIANT indexVar;
				VariantInit (&indexVar);

				// Attempt to coerce the index argument into a value suitable for an array index
				if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[indexArg], 0, VT_I4)) 
				{
					long lArrayPropInx = V_I4(&indexVar);

					// Is this a Get? There should be one argument (the array index)
					if (DISPATCH_PROPERTYGET & wFlags)
					{
						if (1 == pdispparams->cArgs)
						{
							// We should have a VT_ARRAY|VT_VARIANT value at this point; extract the
							// VARIANT

							VariantInit (pvarResult);
							hr = SafeArrayGetElement (vNVal.parray, &lArrayPropInx, pvarResult);
						}
						else
							hr = DISP_E_BADPARAMCOUNT;
					}
					else if (DISPATCH_PROPERTYPUT & wFlags) 
					{
						if (2 == pdispparams->cArgs)
						{
							/*
							 * Try to interpret this as an array member set operation. For
							 * this the first argument passed is the new value, and the second
							 * is the array index.
							 */
						
							VARIANT vNewVal;
							VariantInit(&vNewVal);

							if (SUCCEEDED(VariantCopy(&vNewVal, &pdispparams->rgvarg[0])))
							{
								// Check the index is not out of bounds and, if it is, grow
								// the array accordingly
								CheckArrayBounds (vNVal.parray, lArrayPropInx);

								// How do we decide on the type - try to access an array
								// member and use that type
								VARTYPE expectedVarType = VT_ILLEGAL;
								VARIANT dummyVar;
								VariantInit (&dummyVar);
								long lBound;
								SafeArrayGetLBound (vNVal.parray, 1, &lBound);

								if (SUCCEEDED (SafeArrayGetElement (vNVal.parray, &lBound, &dummyVar)))
									expectedVarType = V_VT(&dummyVar);

								VariantClear (&dummyVar);

								if (S_OK == VariantChangeType (&vNewVal, &vNewVal, 0, expectedVarType))
								{
									// Set the value into the relevant index of the named value array
									if (S_OK == (hr = 
										SafeArrayPutElement (vNVal.parray, &lArrayPropInx, &vNewVal)))
									{
										// Set the entire property value
										if (SUCCEEDED (pNamedValue->put_Value (&vNVal)))
											hr = S_OK;
										else
										{
											hr = DISP_E_TYPEMISMATCH;
											if (puArgErr)
												*puArgErr = 0;
										}
									}
								}
								else
								{
									hr = DISP_E_TYPEMISMATCH;
									if (puArgErr)
										*puArgErr = 0;
								}
								
								VariantClear (&vNewVal);
							}
						}
						else 
							hr = DISP_E_BADPARAMCOUNT;
					}
				}
				else
				{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = indexArg;
				}

				VariantClear (&indexVar);
			}	
			VariantClear (&vNVal);
			pNamedValue->Release ();	// Bug ID 572567
		}

	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\nvalue.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  nvalue.h
//
//  alanbos  27-Mar-00   Created.
//
//  General purpose include file.
//
//***************************************************************************

#ifndef _NVALUE_H_
#define _NVALUE_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemNamedValueSetE interface.  
//
//***************************************************************************

class CSWbemNamedValueSet : public ISWbemNamedValueSet,
							public ISWbemInternalContext,
							public IObjectSafety,
							public ISupportErrorInfo,
							public IProvideClassInfo
{
private:
	class CContextDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);
	};

	CSWbemServices			*m_pSWbemServices;
	IWbemContext			*m_pIWbemContext;
	CContextDispatchHelp	m_Dispatch;
	CWbemPathCracker		*m_pCWbemPathCracker;
	bool					m_bMutable;

	void					BuildContextFromKeyList ();
	HRESULT					SetValueIntoContext (BSTR bsName, VARIANT *pVal, ULONG lFlags);
	
protected:
	long            m_cRef;         //Object reference count

public:
    
	CSWbemNamedValueSet (void);
    CSWbemNamedValueSet (CSWbemServices *pService, IWbemContext *pIWbemContext);	
	CSWbemNamedValueSet (CWbemPathCracker *pCWbemPathCracker, bool bMutable = true);	
    ~CSWbemNamedValueSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// ISWbemInternalContext
	STDMETHODIMP GetIWbemContext (IWbemContext **pContext);

	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	VARIANT *pValue,
        /*[in]*/	long lFlags,
		/*[out]*/	ISWbemNamedValue **ppNamedValue
    );        
        
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemNamedValue **ppValue
    );        

    HRESULT STDMETHODCALLTYPE Remove
	(
        /*[in]*/	BSTR Name,
		/*[in]*/	long lFlags
    );

	// ISWbemNamedValueSet methods

	HRESULT STDMETHODCALLTYPE Clone
	(
		/*[out]*/	ISWbemNamedValueSet **pNewCopy
	);

    HRESULT STDMETHODCALLTYPE DeleteAll
	(
	);   
	
	// CSWbemNamedValueSet methods

	HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
	);

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemNamedValue **ppNamedValue
    );

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}
	
	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods
    static IWbemContext	*GetIWbemContext (IDispatch *pDispatch, IServiceProvider *pServiceProvider = NULL);
	static IDispatch *GetSWbemContext(IDispatch *pDispatch, 
									IServiceProvider *pServiceProvider, CSWbemServices *pServices);

	IWbemContext *GetIWbemContext ()
	{
		m_pIWbemContext->AddRef ();
		return m_pIWbemContext;
	}

	CWbemPathCracker *GetWbemPathCracker ()
	{
		CWbemPathCracker *pCWbemPathCracker = NULL;

		if (m_pCWbemPathCracker)
		{
			pCWbemPathCracker = m_pCWbemPathCracker;
			pCWbemPathCracker->AddRef ();
		}

		return pCWbemPathCracker;
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemNamedValue
//
//  DESCRIPTION:
//
//  Implements the ISWbemNamedValue interface.  
//
//***************************************************************************

class CSWbemNamedValue : public ISWbemNamedValue,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
private:
	class CNamedValueDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);

			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};

	CSWbemServices			*m_pSWbemServices;
	CSWbemNamedValueSet		*m_pCSWbemNamedValueSet;
	CNamedValueDispatchHelp	m_Dispatch;
	BSTR					m_name;
	bool					m_bMutable;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemNamedValue (CSWbemServices *pService, CSWbemNamedValueSet *pCSWbemNamedValueSet, 
						 bool bMutable = true);		// Bug ID 572567
    ~CSWbemNamedValue (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemNamedValue methods

	HRESULT STDMETHODCALLTYPE get_Value
	(
		/*[out]*/	VARIANT *value
	);
	
	HRESULT STDMETHODCALLTYPE put_Value
	(
		/*[in]*/	VARIANT *value
	);

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	HRESULT CSWbemNamedValue::SetName (	BSTR strName);		//Bug ID 572567

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\object.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  object.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemObject and CSWbemObjectSet definition.
//
//***************************************************************************

#ifndef _OBJECT_H_
#define _OBJECT_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObject
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectEx interface.  
//
//***************************************************************************

class CSWbemObject : public ISWbemObjectEx, 
					 public IDispatchEx,
					 public ISWbemInternalObject,
					 public IObjectSafety,
					 public ISupportErrorInfo,
					 public IProvideClassInfo
{
friend	CSWbemServices;

private:
	bool					m_isErrorObject;
	CSWbemServices			*m_pSWbemServices;
	IWbemClassObject		*m_pIWbemClassObject;
	CWbemDispatchMgr		*m_pDispatch;
	IServiceProvider		*m_pIServiceProvider;
	IWbemRefresher			*m_pIWbemRefresher;
	bool					m_bCanUseRefresher;

	// If an embedded object, we store the parent site
	CWbemSite				*m_pSite;

	bool					CastToScope (IDispatch *pContext, CComPtr<ISWbemServicesEx> &pISWbemServicesEx);

protected:
	long					m_cRef;         //Object reference count

public:
    
    CSWbemObject(CSWbemServices *pService, IWbemClassObject *pIWbemClassObject,
					CSWbemSecurity *pSecurity = NULL, bool isErrorObject = false);
    virtual ~CSWbemObject(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch should be inline

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

	// IDispatchEx methods should be inline
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id);
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex);
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName);
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
    
	// ISWbemObject methods

	HRESULT STDMETHODCALLTYPE Put_
	(
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectPath **ppObject
    );

	HRESULT STDMETHODCALLTYPE Delete_
	(
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext
    );

	HRESULT STDMETHODCALLTYPE Instances_
	(
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE Subclasses_
	(
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE ExecMethod_ 
	(
        /*[in]*/	BSTR methodName,
        /*[in]*/	/*ISWbemObject*/ IDispatch *pInParams,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObject **ppOutParams
    );

	HRESULT STDMETHODCALLTYPE Associators_
	(
		/*[in]*/	BSTR assocClass,
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR resultRole,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredAssocQualifier,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE References_
	(
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE Clone_
	(
		/*[out]*/	ISWbemObject **ppCopy
    );

    HRESULT STDMETHODCALLTYPE GetObjectText_
	(
        /*[in]*/	long lFlags,
		/*[out]*/	BSTR *pObjectText
    );

    HRESULT STDMETHODCALLTYPE SpawnDerivedClass_
	(
	    /*[in]*/	long lFlags,
		/*[out]*/	ISWbemObject** ppNewClass
    );

    HRESULT STDMETHODCALLTYPE SpawnInstance_
	(
        /*[in]*/	long lFlags,
		/*[out]*/	ISWbemObject** ppNewInstance
    );

    HRESULT STDMETHODCALLTYPE CompareTo_
	(
        /*[in]*/	/*ISWbemObject*/ IDispatch *pCompareTo,
        /*[in]*/	long lFlags,
        /*[out]*/	VARIANT_BOOL *result
    );

    HRESULT STDMETHODCALLTYPE get_Qualifiers_
	(
        /*[out]*/	ISWbemQualifierSet **ppQualifierSet
    );

    HRESULT STDMETHODCALLTYPE get_Properties_
	(
		/*[out]*/	ISWbemPropertySet **ppPropertySet
    );

    HRESULT STDMETHODCALLTYPE get_Methods_
	(
		/*[out]*/	ISWbemMethodSet **ppMethodSet
    );

	HRESULT STDMETHODCALLTYPE get_Derivation_
	(
		/*[out]*/	VARIANT *pClassNames
    );

	HRESULT STDMETHODCALLTYPE get_Path_
	(
		/*[out]*/	ISWbemObjectPath **ppObjectPath
    );

	// Async methods

	HRESULT STDMETHODCALLTYPE PutAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE DeleteAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE InstancesAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE SubclassesAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE AssociatorsAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strAssocClass,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strResultRole,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE ReferencesAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);
        
	HRESULT STDMETHODCALLTYPE ExecMethodAsync_( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strMethodName,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext);


	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISWbemObjectEx methods

	HRESULT STDMETHODCALLTYPE Refresh_ (
		/*[ in ]*/ long iFlags,
        /*[ in ]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet
		);

    HRESULT STDMETHODCALLTYPE get_SystemProperties_
	(
		/*[out]*/	ISWbemPropertySet **ppPropertySet
    );

	HRESULT STDMETHODCALLTYPE GetText_ (
		/*[in]*/ WbemObjectTextFormatEnum iObjectTextFormat,
		/*[in]*/ long iFlags,
		/*[in]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/*[out, retval]*/ BSTR *bsText
		);

	HRESULT STDMETHODCALLTYPE SetFromText_ (
		/*[in]*/ BSTR bsText,
		/*[in]*/ WbemObjectTextFormatEnum iObjectTextFormat,
		/*[in]*/ long iFlags,
		/*[in]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet
		);

	// ISWbemInternalObject methods
	
	HRESULT STDMETHODCALLTYPE GetIWbemClassObject (IWbemClassObject **ppObject);
	HRESULT STDMETHODCALLTYPE SetSite (ISWbemInternalObject *pParentObject, 
									   BSTR propertyName, long index = -1);
	HRESULT STDMETHODCALLTYPE UpdateSite ();
	

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return (m_pDispatch) ? m_pDispatch->GetClassInfo (ppTI) : E_FAIL;
	};

	// Other methods
	static IWbemClassObject	*GetIWbemClassObject (IDispatch *pDispatch);

	IWbemClassObject*	GetIWbemClassObject () 
	{ 
		m_pIWbemClassObject->AddRef ();
		return m_pIWbemClassObject; 
	}

	void SetIWbemClassObject (IWbemClassObject *pIWbemClassObject);

	static void SetSite (IDispatch *pDispatch, 
							ISWbemInternalObject *pSObject, BSTR propertyName, long index = -1);

};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectSet interface.  
//
//***************************************************************************

class CSWbemObjectSet : public ISWbemObjectSet,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	CSWbemServices			*m_pSWbemServices;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity			*m_SecurityInfo;
	bool					m_firstEnumerator;
	bool					m_bIsEmpty;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemObjectSet(CSWbemServices *pService, IEnumWbemClassObject *pIEnumWbemClassObject,
					CSWbemSecurity *pSecurity = NULL);
	CSWbemObjectSet (void);
    ~CSWbemObjectSet(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemObject **ppObject
    );        

	// ISWbemObjectSet methods

	HRESULT STDMETHODCALLTYPE Reset 
	(
	);

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lTimeout,
        /*[out]*/	ISWbemObject **ppObject
    );

	HRESULT STDMETHODCALLTYPE Clone
	(
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE Skip
	(
        /*[in]*/	ULONG lElements,
		/*[in]*/	long lTimeout
    );

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods
	CSWbemServices *GetSWbemServices ()
	{
		return m_pSWbemServices;
	}

	HRESULT CloneObjectSet (CSWbemObjectSet **ppEnum);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\objobjp.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  OBJOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectPath for the ISWbemObjectEx 
//  interface
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObjectObjectPath::CSWbemObjectObjectPath
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObjectObjectPath::CSWbemObjectObjectPath(
	CSWbemServices *pSWbemServices,
	CSWbemObject *pSObject) :
		m_pIWbemClassObject (NULL),
		m_pSWbemServices (pSWbemServices),
		m_pSite (NULL)
{
	InterlockedIncrement(&g_cObj);

	if (pSObject)
	{
		m_pIWbemClassObject = pSObject->GetIWbemClassObject ();
		m_pSite = new CWbemObjectSite (pSObject);
	}

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_pSecurity = new CSWbemObjectObjectPathSecurity (pSWbemServices);

	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");
    m_cRef=0;
}

//***************************************************************************
//
//  CSWbemObjectObjectPath::~CSWbemObjectObjectPath
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemObjectObjectPath::~CSWbemObjectObjectPath(void)
{
	if (m_pSWbemServices)
	{
		m_pSWbemServices->Release ();
		m_pSWbemServices = NULL;
	}

	if (m_pIWbemClassObject)
	{
		m_pIWbemClassObject->Release ();
		m_pIWbemClassObject = NULL;
	}

	if (m_pSite)
	{
		m_pSite->Release ();
		m_pSite = NULL;
	}

	if (m_pSecurity)
	{
		m_pSecurity->Release ();
		m_pSecurity = NULL;
	}

	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemObjectPath::QueryInterface
// long CSWbemObjectPath::AddRef
// long CSWbemObjectPath::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPath::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectPath==riid)
		*ppv = (ISWbemObjectPath *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPath::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPath::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectObjectPath::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPath::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemObjectPath == riid) ? S_OK : S_FALSE;
}

// Methods of ISWbemObjectPath
STDMETHODIMP CSWbemObjectObjectPath::get_RelPath( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{	
	return GetStrVal (value, WBEMS_SP_RELPATH);
}

STDMETHODIMP CSWbemObjectObjectPath::get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{	
	return GetStrVal (value, WBEMS_SP_PATH);
}

STDMETHODIMP CSWbemObjectObjectPath::get_Server( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	return GetStrVal (value, WBEMS_SP_SERVER);
}

STDMETHODIMP CSWbemObjectObjectPath::get_Namespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	return GetStrVal (value, WBEMS_SP_NAMESPACE);
}
        
STDMETHODIMP CSWbemObjectObjectPath::get_Class( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	return GetStrVal (value, WBEMS_SP_CLASS);
}
        
        
STDMETHODIMP CSWbemObjectObjectPath::GetStrVal (
	BSTR *value,
	LPWSTR name)
{
	HRESULT hr = WBEM_E_FAILED ;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = NULL;

		if ( m_pIWbemClassObject )
		{
			VARIANT var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (name, 0, &var, NULL, NULL))
			{
				if (VT_BSTR == var.vt)
				{
					*value = SysAllocString (var.bstrVal);
					hr = WBEM_S_NO_ERROR;
				}
				else if (VT_NULL == var.vt)
				{
					*value = SysAllocString(OLESTR(""));
					hr = WBEM_S_NO_ERROR;
				}
			}

			VariantClear (&var);

			if (NULL == *value)
				*value = SysAllocString (OLESTR(""));

		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_IsClass( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = true;

		if (m_pIWbemClassObject)
		{
			VARIANT var;
			VariantInit (&var);
			BSTR genus = SysAllocString (WBEMS_SP_GENUS);
			
			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (genus, 0, &var, NULL, NULL))
			{
				*value = (var.lVal == WBEM_GENUS_CLASS) ? VARIANT_TRUE : VARIANT_FALSE;
				hr = WBEM_S_NO_ERROR;
			}

			VariantClear (&var);
			SysFreeString (genus);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_IsSingleton( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		BSTR path = NULL;
		*value = false;

		if (WBEM_S_NO_ERROR == get_Path (&path))
		{
			CWbemPathCracker pathCracker (path);
		
			*value = pathCracker.IsSingleton ();
			hr = WBEM_S_NO_ERROR;

			SysFreeString (path);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

        
STDMETHODIMP CSWbemObjectObjectPath::get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		BSTR path = NULL;

		if (WBEM_S_NO_ERROR == get_Path (&path))
		{
			wchar_t *securityStr = NULL;
			wchar_t *localeStr = NULL;
			
			if (m_pSWbemServices)
			{
				CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

				if (pSecurity)
				{
					BSTR bsAuthority = SysAllocString (pSecurity->GetAuthority ());
					enum WbemAuthenticationLevelEnum authnLevel;
					enum WbemImpersonationLevelEnum impLevel;

					if (SUCCEEDED(pSecurity->get_AuthenticationLevel (&authnLevel)) &&
						SUCCEEDED(pSecurity->get_ImpersonationLevel (&impLevel)))
					{
						CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

						if (pPrivilegeSet)
						{
							securityStr = CWbemParseDN::GetSecurityString (true, authnLevel, true, 
										impLevel, *pPrivilegeSet, bsAuthority);
							pPrivilegeSet->Release ();
						}
					}

					SysFreeString (bsAuthority);
					pSecurity->Release ();
				}

				localeStr = CWbemParseDN::GetLocaleString (m_pSWbemServices->GetLocale ());
			}

			size_t len = wcslen (path) + wcslen (WBEMS_PDN_SCHEME) +
							((securityStr) ? wcslen (securityStr) : 0) +
							((localeStr) ? wcslen (localeStr) : 0);

			// If security or locale specified, and we have a path, then need a separator
			if ( (securityStr || localeStr) && (0 < wcslen (path)) )
				len += wcslen (WBEMS_EXCLAMATION);

			OLECHAR *displayName = new OLECHAR [len + 1];
			
			if (displayName)
			{
				wcscpy (displayName, WBEMS_PDN_SCHEME) ;
				
				if (securityStr)
					wcscat (displayName, securityStr);

				if (localeStr)
					wcscat (displayName, localeStr);

				if ( (securityStr || localeStr) && (0 < wcslen (path)) )
					wcscat (displayName, WBEMS_EXCLAMATION);

				wcscat (displayName, path) ;
				displayName [len] = NULL;

				*value = SysAllocString (displayName);
				
				delete [] displayName ;
				hr = WBEM_S_NO_ERROR;
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
			
			if (securityStr)
				delete [] securityStr;

			if (localeStr)
				delete [] localeStr;

			SysFreeString (path);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_ParentNamespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		BSTR path = NULL;
		*value = NULL;

		if (WBEM_S_NO_ERROR == get_Path (&path))
		{
			CWbemPathCracker pathCracker (path);
			CComBSTR bsNsPath;

			if (pathCracker.GetNamespacePath (bsNsPath, true))
			{
				*value = bsNsPath.Detach ();
				hr = WBEM_S_NO_ERROR;
			}
	
			SysFreeString (path);
		}

		if (NULL == *value)
			*value = SysAllocString (OLESTR(""));
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::put_Class( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;

	ResetLastErrors ();

	if ( value && m_pIWbemClassObject )
	{
		VARIANT var;
		VariantInit (&var);
		var.vt = VT_BSTR;
		var.bstrVal = SysAllocString (value);
		BSTR className = SysAllocString (WBEMS_SP_CLASS);
		
		hr = m_pIWbemClassObject->Put (className, 0, &var, NULL);
		
		VariantClear (&var);
		SysFreeString (className);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_Keys(
			/* [out, retval] */ ISWbemNamedValueSet **objKeys)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == objKeys)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*objKeys = NULL;
		BSTR bsPath = NULL;
	
		if (WBEM_S_NO_ERROR == get_Path (&bsPath))
		{
			CWbemPathCracker *pCWbemPathCracker  = new CWbemPathCracker (bsPath);

			if (!pCWbemPathCracker)
				hr = WBEM_E_OUT_OF_MEMORY;
			else
			{
				CSWbemNamedValueSet *pCSWbemNamedValueSet = 
						new CSWbemNamedValueSet (pCWbemPathCracker, false);

				if (!pCSWbemNamedValueSet)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (SUCCEEDED(pCSWbemNamedValueSet->QueryInterface 
									(IID_ISWbemNamedValueSet, (PPVOID) objKeys)))
					hr = WBEM_S_NO_ERROR;
				else
					delete pCSWbemNamedValueSet;
			}
							
			SysFreeString (bsPath);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;

}

STDMETHODIMP CSWbemObjectObjectPath::get_Security_(
			/* [out, retval] */ ISWbemSecurity **objSecurity)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (objSecurity)
	{
		*objSecurity = m_pSecurity;
		m_pSecurity->AddRef ();
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

STDMETHODIMP CSWbemObjectObjectPath::get_Locale( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ResetLastErrors ();

	if ( value )
	{
		if (m_pSWbemServices)
			*value = SysAllocString (m_pSWbemServices->GetLocale ()) ;
		else
			*value = SysAllocString (OLESTR(""));

		t_Result = S_OK ;
	}

	if (FAILED(t_Result))
		m_Dispatch.RaiseException (t_Result);

	return t_Result ;
}        

STDMETHODIMP CSWbemObjectObjectPath::get_Authority( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ResetLastErrors ();

	if ( value )
	{
		if (m_pSecurity)
			*value = SysAllocString (m_pSecurity->GetAuthority ()) ;
		else
			*value = SysAllocString (OLESTR(""));

		t_Result = S_OK ;
	}

	if (FAILED(t_Result))
		m_Dispatch.RaiseException (t_Result);

	return t_Result ;
}        

// CSWbemObjectObjectPathSecurity methods

//***************************************************************************
//
// CSWbemObjectObjectPathSecurity::CSWbemObjectObjectPathSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemObjectObjectPathSecurity::CSWbemObjectObjectPathSecurity (
	CSWbemServices *pSWbemServices
) : m_pPrivilegeSet (NULL),
    m_bsAuthority (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
    m_cRef=1;
	InterlockedIncrement(&g_cObj);

	if (pSWbemServices)
	{
		CSWbemSecurity *pSecurity = pSWbemServices->GetSecurityInfo ();

		if (pSecurity)
		{
			// Set up authn and imp levels
			pSecurity->get_AuthenticationLevel (&m_dwAuthnLevel);
			pSecurity->get_ImpersonationLevel (&m_dwImpLevel);

			// Set up authority
			m_bsAuthority = SysAllocString (pSecurity->GetAuthority ());

			// Set up privileges
			CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

			if (pPrivilegeSet)
			{
				// Note we mark the privilege set as immutable
				m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet, false);
				pPrivilegeSet->Release ();
			}

			pSecurity->Release ();
		}
	}
}

//***************************************************************************
//
// CSWbemObjectObjectPathSecurity::~CSWbemObjectObjectPathSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemObjectObjectPathSecurity::~CSWbemObjectObjectPathSecurity (void)
{
	InterlockedDecrement(&g_cObj);

	if (m_pPrivilegeSet)
	{
		m_pPrivilegeSet->Release ();
		m_pPrivilegeSet = NULL;
	}

	if (m_bsAuthority)
	{
		SysFreeString (m_bsAuthority);
		m_bsAuthority = NULL;
	}
}

//***************************************************************************
// HRESULT CSWbemObjectObjectPathSecurity::QueryInterface
// long CSWbemObjectObjectPathSecurity::AddRef
// long CSWbemObjectObjectPathSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPathSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *) this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPathSecurity::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemObjectObjectPathSecurity::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectObjectPathSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectObjectPathSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemObjectObjectPathSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectObjectPathSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pAuthenticationLevel = m_dwAuthnLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}		

//***************************************************************************
//
//  SCODE CSWbemObjectObjectPathSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectObjectPathSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pImpersonationLevel = m_dwImpLevel;
		hr = WBEM_S_NO_ERROR;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectObjectPathSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectObjectPathSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	else			// Bug ID 566345
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\object.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  OBJECT.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectEx
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObject::CSWbemObject
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObject::CSWbemObject(CSWbemServices *pService, IWbemClassObject *pObject,
						   CSWbemSecurity *pSecurity,
						   bool isErrorObject) :
								m_pSWbemServices (NULL),
								m_pSite (NULL),
								m_pIWbemRefresher (NULL),
								m_bCanUseRefresher (true)
{
	m_cRef=0;
	m_isErrorObject = isErrorObject;
	m_pIWbemClassObject = pObject;
	m_pIWbemClassObject->AddRef ();
	m_pIServiceProvider = NULL;

	if (pService)
	{
		m_pSWbemServices = new CSWbemServices (pService, pSecurity);

		if (m_pSWbemServices)
			m_pSWbemServices->AddRef ();
	}

	m_pDispatch = new CWbemDispatchMgr (m_pSWbemServices, this);

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemObject::~CSWbemObject
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CSWbemObject::~CSWbemObject(void)
{
	InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pIWbemClassObject)
	RELEASEANDNULL(m_pSWbemServices)
	RELEASEANDNULL(m_pSite)
	RELEASEANDNULL(m_pIWbemRefresher)
	DELETEANDNULL(m_pDispatch);
}

//***************************************************************************
// HRESULT CSWbemObject::QueryInterface
// long CSWbemObject::AddRef
// long CSWbemObject::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

	/*
	 * Only acknowledge the last error or object safety
	 * interfaces if we are an error object.
	 */

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObject==riid)
        *ppv = (ISWbemObject *)this;
	else if (IID_ISWbemObjectEx==riid)
        *ppv = (ISWbemObjectEx *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)((ISWbemObjectEx *)this);
	else if (IID_IDispatchEx==riid)
		*ppv = (IDispatchEx *)this;
	else if (IID_ISWbemInternalObject==riid)
		*ppv = (ISWbemInternalObject *) this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;
	else if (m_isErrorObject)
	{
		if (IID_ISWbemLastError==riid)
			*ppv = (ISWbemObject *) this;
		else if (IID_IObjectSafety==riid)
			*ppv = (IObjectSafety *) this;
	}
	else if (IID_IObjectSafety==riid)
	{
		/*
		 * Explicit check because we don't want
		 * this interface hijacked by a custom interface.
		 */
		*ppv = NULL;
	}

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObject::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObject::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

// IDispatch methods should be inline

STDMETHODIMP		CSWbemObject::GetTypeInfoCount(UINT* pctinfo)
	{
	_RD(static char *me = "CSWbemObject::GetTypeInfoCount()";)
	_RPrint(me, "Called", 0, "");
	return  (m_pDispatch ? m_pDispatch->GetTypeInfoCount(pctinfo) : E_FAIL);}
STDMETHODIMP		CSWbemObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
	_RD(static char *me = "CSWbemObject::GetTypeInfo()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetTypeInfo(itinfo, lcid, pptinfo) : E_FAIL);}
STDMETHODIMP		CSWbemObject::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,
						UINT cNames, LCID lcid, DISPID* rgdispid)
	{
	_RD(static char *me = "CSWbemObject::GetIdsOfNames()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetIDsOfNames(riid, rgszNames, cNames,
					  lcid,
					  rgdispid) : E_FAIL);}
STDMETHODIMP		CSWbemObject::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
						WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
								EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
	_RD(static char *me = "CSWbemObject::Invoke()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->Invoke(dispidMember, riid, lcid, wFlags,
		pdispparams, pvarResult, pexcepinfo, puArgErr) : E_FAIL);}

// IDispatchEx methods should be inline
HRESULT STDMETHODCALLTYPE CSWbemObject::GetDispID(
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemObject::GetDispID()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetDispID(bstrName, grfdex, pid) : E_FAIL);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSWbemObject::InvokeEx(
	/* [in] */ DISPID id,
	/* [in] */ LCID lcid,
	/* [in] */ WORD wFlags,
	/* [in] */ DISPPARAMS __RPC_FAR *pdp,
	/* [out] */ VARIANT __RPC_FAR *pvarRes,
	/* [out] */ EXCEPINFO __RPC_FAR *pei,
	/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	HRESULT hr;
	_RD(static char *me = "CSWbemObject::InvokeEx()";)
	_RPrint(me, "Called", (long)id, "id");
	_RPrint(me, "Called", (long)wFlags, "wFlags");


	/*
	 * Store away the service provider so that it can be accessed
	 * by calls that remote to CIMOM
	 */

	if (m_pDispatch)
	{
		m_pIServiceProvider = pspCaller;
		hr = m_pDispatch->InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
		m_pIServiceProvider = NULL;
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemObject::DeleteMemberByName(
	/* [in] */ BSTR bstr,
	/* [in] */ DWORD grfdex)
{
	_RD(static char *me = "CSWbemObject::DeleteMemberByName()";)
	_RPrint(me, "Called", 0, "");
	return m_pDispatch->DeleteMemberByName(bstr, grfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemObject::DeleteMemberByDispID(
	/* [in] */ DISPID id)
{
	_RD(static char *me = "CSWbemObject::DeletememberByDispId()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->DeleteMemberByDispID(id) : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CSWbemObject::GetMemberProperties(
	/* [in] */ DISPID id,
	/* [in] */ DWORD grfdexFetch,
	/* [out] */ DWORD __RPC_FAR *pgrfdex)
{
	_RD(static char *me = "CSWbemObject::GetMemberProperties()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetMemberProperties(id, grfdexFetch, pgrfdex) : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CSWbemObject::GetMemberName(
	/* [in] */ DISPID id,
	/* [out] */ BSTR __RPC_FAR *pbstrName)
{
	_RD(static char *me = "CSWbemObject::GetMemberName()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetMemberName(id, pbstrName) : E_FAIL);
}


/*
 * I don't think this needs implementing
 */
HRESULT STDMETHODCALLTYPE CSWbemObject::GetNextDispID(
	/* [in] */ DWORD grfdex,
	/* [in] */ DISPID id,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemObject::GetNextDispID()";)
	_RPrint(me, "Called", 0, "");

	return S_FALSE;

}

HRESULT STDMETHODCALLTYPE CSWbemObject::GetNameSpaceParent(
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
{
	_RD(static char *me = "CSWbemObject::GetNamespaceParent()";)
	_RPrint(me, "Called", 0, "");
	return (m_pDispatch ? m_pDispatch->GetNameSpaceParent(ppunk) : E_FAIL);
}

//***************************************************************************
// HRESULT CSWbemObject::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return ((IID_ISWbemObject == riid) ||
		    (IID_ISWbemObjectEx == riid)) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  CSWbemObject::GetIWbemClassObject
//
//  DESCRIPTION:
//
//  Return the IWbemClassObject interface corresponding to this
//	scriptable wrapper.
//
//  PARAMETERS:
//		ppObject		holds the IWbemClassObject pointer on return
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::GetIWbemClassObject (IWbemClassObject **ppObject)
{
	HRESULT hr = E_FAIL;

	if (ppObject)
	{
		*ppObject = NULL;
	
		if (m_pIWbemClassObject)
		{
			m_pIWbemClassObject->AddRef ();
			*ppObject = m_pIWbemClassObject;
			hr = S_OK;
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}
	return hr;
}

//***************************************************************************
//
//  CSWbemObject::SetIWbemClassObject
//
//  DESCRIPTION:
//
//  Set a new IWbemClassObject interface inside this scriptable wrapper.
//
//  PARAMETERS:
//		pIWbemClassObject		- the new IWbemClassObject
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

void CSWbemObject::SetIWbemClassObject (
	IWbemClassObject *pIWbemClassObject
)
{
	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();

	m_pIWbemClassObject = pIWbemClassObject;
	
	if (m_pIWbemClassObject)
		m_pIWbemClassObject->AddRef ();
	
	if (m_pDispatch)
		m_pDispatch->SetNewObject (m_pIWbemClassObject);
};

//***************************************************************************
//
//  SCODE CSWbemObject::Put_
//
//  DESCRIPTION:
//
//  Save/commit this class or instance into a namespace
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppObjectPath	Object Path
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Put_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	ISWbemObjectPath **ppObjectPath
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices)
	{
		if (m_pIWbemClassObject)
		{
			// Figure out whether this is a class or instance
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
			{
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);
				IWbemServices	*pIService = m_pSWbemServices->GetIWbemServices ();
				IWbemCallResult *pResult = NULL;
				HRESULT hrCallResult = WBEM_E_FAILED;

				if (pIService)
				{
					CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

					if (pSecurity)
					{
						bool needToResetSecurity = false;
						HANDLE hThreadToken = NULL;

						if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
						{
							if (WBEM_GENUS_CLASS  == var.lVal)
								hrCallResult = pIService->PutClass
										(m_pIWbemClassObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
							else
								hrCallResult = pIService->PutInstance
										(m_pIWbemClassObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
						}

						if (needToResetSecurity)
							pSecurity->ResetSecurity (hThreadToken);

						pSecurity->Release ();
					}

					pIService->Release ();
				}

				/*
				 * Secure the IWbemCallResult interface
				 */

				if (WBEM_S_NO_ERROR == hrCallResult)
				{
					CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

					if (pSecurity)
						pSecurity->SecureInterface (pResult);

					if ((WBEM_S_NO_ERROR == (hrCallResult = pResult->GetCallStatus (INFINITE, &hr))) &&
						(WBEM_S_NO_ERROR == hr))
					{
						if (ppObjectPath)
						{
							ISWbemObjectPath *pObjectPath =
									new CSWbemObjectPath (pSecurity, m_pSWbemServices->GetLocale());

							if (!pObjectPath)
								hr = WBEM_E_OUT_OF_MEMORY;
							else
							{
								pObjectPath->AddRef ();
								pObjectPath->put_Path (m_pSWbemServices->GetPath ());
								
								if (WBEM_GENUS_CLASS == var.lVal)
								{
									VARIANT nameVar;
									VariantInit (&nameVar);

									/*
									 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
									 * the __CLASS property has not yet been set.
									 */

									if ((WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
										&& (VT_BSTR == V_VT(&nameVar)))
									{
										pObjectPath->put_Class (nameVar.bstrVal);
										*ppObjectPath = pObjectPath;
									}
									else
										pObjectPath->Release ();

									VariantClear (&nameVar);
								}
								else
								{
									// Now get the relpath string from the call result
									BSTR resultString = NULL;

									if (WBEM_S_NO_ERROR == pResult->GetResultString (INFINITE, &resultString))
									{
										pObjectPath->put_RelPath (resultString);
										*ppObjectPath = pObjectPath;
										SysFreeString (resultString);
									}
									else
										pObjectPath->Release ();

								}
							}
						}
					}

					if (pSecurity)
						pSecurity->Release ();
				}
				else
					hr = hrCallResult;

				if (pResult)
					pResult->Release ();

				SetWbemError (m_pSWbemServices);

				if (pIContext)
					pIContext->Release ();
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObject::Delete_
//
//  DESCRIPTION:
//
//  Delete this class or instance from the namespace
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Delete_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->Delete (bsPath, lFlags, pContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObject::Instances_
//
//  DESCRIPTION:
//
//  returns instances of this class
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Instances_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	/*[out]*/	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->InstancesOf (bsPath, lFlags, pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Subclasses_
//
//  DESCRIPTION:
//
//  returns subclasses of this class
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Subclasses_ (
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	/*[out]*/	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->SubclassesOf (bsPath, lFlags, pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Associators_
//
//  DESCRIPTION:
//
//  returns associators of this object
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Associators_ (
	BSTR assocClass,
	BSTR resultClass,
	BSTR resultRole,
	BSTR role,
	VARIANT_BOOL classesOnly,
	VARIANT_BOOL schemaOnly,
	BSTR requiredAssocQualifier,
	BSTR requiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->AssociatorsOf (bsPath, assocClass, resultClass,
						resultRole, role, classesOnly, schemaOnly,
						requiredAssocQualifier, requiredQualifier, lFlags, 
						pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::References_
//
//  DESCRIPTION:
//
//  returns references to this object
//
//  PARAMETERS:
//
//		lFlags			Flags
//		pContext		Context
//		ppEnum			Returned enumerator
//
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::References_ (
	BSTR resultClass,
	BSTR role,
	VARIANT_BOOL classesOnly,
	VARIANT_BOOL schemaOnly,
	BSTR requiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		CComBSTR bsPath;
		
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ReferencesTo (bsPath, resultClass,
						role, classesOnly, schemaOnly,
						requiredQualifier, lFlags, pContext, ppEnum);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::ExecMethod_
//
//  DESCRIPTION:
//
//  Executes a method of this class (or instance)
//
//  PARAMETERS:
//
//		bsMethod			The name of the method to call
//		pInParams			The in-parameters
//		lFlags				Flags
//		pContext			Any context information
//		ppOutParams			The out-parameters
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::ExecMethod_ (
	BSTR bsMethod,
	/*ISWbemObject*/ IDispatch *pInParams,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObject **ppOutParams
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ExecMethod (bsPath, bsMethod,
							pInParams, lFlags, pContext, ppOutParams);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Clone_
//
//  DESCRIPTION:
//
//  Clone object
//
//  PARAMETERS:
//		ppCopy		On successful return addresses the copy
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Clone_ (
	ISWbemObject **ppCopy
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppCopy)
		return WBEM_E_INVALID_PARAMETER;

	if (m_pIWbemClassObject)
	{
		IWbemClassObject *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Clone (&pWObject)))
		{
			CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pWObject);

			if (!pObject)
				hr = WBEM_E_OUT_OF_MEMORY;
			else 
			{
				if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
										(PPVOID) ppCopy)))
					delete pObject;
			}

			pWObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::GetObjectText_
//
//  DESCRIPTION:
//
//  Get MOF Description of Object
//
//  PARAMETERS:
//		lFlags			flags
//		pObjectText		on successful return holds MOF text
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::GetObjectText_ (
	long	lFlags,
	BSTR	*pObjectText
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemClassObject)
		hr = m_pIWbemClassObject->GetObjectText (lFlags, pObjectText);

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::SpawnDerivedClass_
//
//  DESCRIPTION:
//
//  Create a subclass of this (class) object
//
//  PARAMETERS:
//		lFlags			Flags
//		ppNewClass		On successful return addresses the subclass
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::SpawnDerivedClass_ (
	long lFlags,
	ISWbemObject **ppNewClass
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNewClass)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemClassObject *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->SpawnDerivedClass (lFlags, &pWObject)))
		{
			CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pWObject);

			if (!pObject)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
										(PPVOID) ppNewClass)))
					delete pObject;

			pWObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::SpawnInstance_
//
//  DESCRIPTION:
//
//  Create an instance of this (class) object
//
//  PARAMETERS:
//		lFlags			Flags
//		ppNewInstance	On successful return addresses the instance
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::SpawnInstance_ (
	long lFlags,
	ISWbemObject **ppNewInstance
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNewInstance)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemClassObject *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->SpawnInstance (lFlags, &pWObject)))
		{
			CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pWObject);

			if (!pObject)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
										(PPVOID) ppNewInstance)))
					delete pObject;

			pWObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::CompareTo_
//
//  DESCRIPTION:
//
//  Compare this object against another
//
//  PARAMETERS:
//		pCompareTo		The object to compare this against
//		lFlags			Flags
//		pResult			On return contains the match status (TRUE/FALSE)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::CompareTo_ (
	/*ISWbemObject*/ IDispatch *pCompareTo,
    long lFlags,
    VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == pCompareTo) || (NULL == pResult))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemClassObject *pObject = CSWbemObject::GetIWbemClassObject (pCompareTo);

		if (NULL != pObject)
		{
			if (SUCCEEDED (hr = m_pIWbemClassObject->CompareTo (lFlags, pObject)))
				*pResult = (WBEM_S_SAME == hr) ? VARIANT_TRUE : VARIANT_FALSE;

			pObject->Release ();
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Qualifiers_
//
//  DESCRIPTION:
//
//  retrieve the qualifier set for this object
//
//  PARAMETERS:
//
//		ppQualSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Qualifiers_ (
	ISWbemQualifierSet **ppQualSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQualSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppQualSet = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemQualifierSet *pQualSet = NULL;

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetQualifierSet (&pQualSet)))
			{
				if (!(*ppQualSet = new CSWbemQualifierSet (pQualSet, this)))
					hr = WBEM_E_OUT_OF_MEMORY;

				pQualSet->Release ();
			}
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Properties_
//
//  DESCRIPTION:
//
//  retrieve the property set for this object
//
//  PARAMETERS:
//
//		ppPropSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Properties_ (
	ISWbemPropertySet **ppPropSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPropSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else		// Bug ID 566345
	{
		*ppPropSet = NULL;

		if (m_pIWbemClassObject)
		{
			if (!(*ppPropSet = new CSWbemPropertySet (m_pSWbemServices, this)))
				hr = WBEM_E_OUT_OF_MEMORY;
			else
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_SystemProperties_
//
//  DESCRIPTION:
//
//  retrieve the system property set for this object
//
//  PARAMETERS:
//
//		ppPropSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_SystemProperties_ (
	ISWbemPropertySet **ppPropSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPropSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else			// Bug ID 566345
	{
		*ppPropSet = NULL;

		if (m_pIWbemClassObject)
		{
			if (!(*ppPropSet = new CSWbemPropertySet (m_pSWbemServices, this, true)))
				hr = WBEM_E_OUT_OF_MEMORY;
			else
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Methods_
//
//  DESCRIPTION:
//
//  retrieve the method set for this object
//
//  PARAMETERS:
//
//		ppMethodSet		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Methods_ (
	ISWbemMethodSet **ppMethodSet
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppMethodSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppMethodSet = NULL;

		if (m_pIWbemClassObject)
		{
			/*
			 * For classes the IWbemClassObject will contain the method
			 * definition, but for instances it will be empty.  In that
			 * case we need to try and get the underlying class.
			 */
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
			{
				if (WBEM_GENUS_CLASS  == var.lVal)
				{
					if (!(*ppMethodSet = new CSWbemMethodSet (m_pSWbemServices, m_pIWbemClassObject)))
						hr = WBEM_E_OUT_OF_MEMORY;
					else
						hr = WBEM_S_NO_ERROR;
				}
				else
				{
					if (m_pSWbemServices)
					{
						// An instance; try to get the class
						VariantClear (&var);

						/*
						 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
						 * the __CLASS property has not yet been set.
						 */

						if ((WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_CLASS, 0, &var, NULL, NULL))
							&& (VT_BSTR == V_VT(&var)))
						{
							IWbemServices *pIService = m_pSWbemServices->GetIWbemServices ();
							IWbemClassObject *pObject = NULL;

							if (pIService)
							{
								// Check privileges are set ok
								CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

								if (pSecurity)
								{
									bool needToResetSecurity = false;
									HANDLE hThreadToken = NULL;

									if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
										hr = pIService->GetObject (var.bstrVal,
												0, NULL, &pObject, NULL);

									if (SUCCEEDED(hr))
									{
										if (!(*ppMethodSet = 
												new CSWbemMethodSet (m_pSWbemServices, pObject)))
											hr = WBEM_E_OUT_OF_MEMORY;

										pObject->Release ();
									}

									if (needToResetSecurity)
										pSecurity->ResetSecurity (hThreadToken);

									pSecurity->Release ();
								}

								pIService->Release ();
							}
						}
					}
				}
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Path_
//
//  DESCRIPTION:
//
//  retrieve the object path for this object
//
//  PARAMETERS:
//
//		ppObjectPath		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Path_ (
	ISWbemObjectPath **ppObjectPath
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObjectPath)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppObjectPath = NULL;

		if (m_pIWbemClassObject)
		{
			CSWbemObjectObjectPath *pObjectPath =
					new CSWbemObjectObjectPath (m_pSWbemServices, this);

			if (!pObjectPath)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pObjectPath->QueryInterface (IID_ISWbemObjectPath,
														(PPVOID) ppObjectPath)))
				delete pObjectPath;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Derivation_
//
//  DESCRIPTION:
//
//  Get the class derivation array.
//
//  PARAMETERS:
//
//		ppNames				Holds the names on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Derivation_ (
    VARIANT *pNames
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pNames)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		if (m_pIWbemClassObject)
		{
			VARIANT var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_DERIVATION, 0, &var, NULL, NULL))
			{
				/* The value should be a VT_BSTR|VT_ARRAY */
				if (((VT_ARRAY | VT_BSTR) == var.vt) && (NULL != var.parray))
				{
					// Make a safearray of VARIANTS from the array of BSTRs
					SAFEARRAYBOUND rgsabound;
					rgsabound.lLbound = 0;

					long lBound = 0, uBound = 0;
					SafeArrayGetUBound (var.parray, 1, &uBound);
					SafeArrayGetLBound (var.parray, 1, &lBound);

					rgsabound.cElements = uBound + 1 - lBound;
					SAFEARRAY *pArray = SafeArrayCreate (VT_VARIANT, 1, &rgsabound);
					BSTR bstrName = NULL;
					VARIANT nameVar;
					VariantInit (&nameVar);

					for (long i = 0; i <= uBound; i++)
					{
						SafeArrayGetElement (var.parray, &i, &bstrName);
						BSTR copy = SysAllocString (bstrName);
						nameVar.vt = VT_BSTR;
						nameVar.bstrVal = copy;
						SafeArrayPutElement (pArray, &i, &nameVar);
						SysFreeString (bstrName);
						VariantClear (&nameVar);
					}

					// Now plug this array into the VARIANT
					pNames->vt = VT_ARRAY | VT_VARIANT;
					pNames->parray = pArray;

					hr = S_OK;
				}
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	else			// Bug ID 566345
	{
		*ppSecurity = NULL;

		if (m_pSWbemServices)
		{
			*ppSecurity = m_pSWbemServices->GetSecurityInfo ();

			if (*ppSecurity)
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObject::Refresh_
//
//  DESCRIPTION:
//
//  Refresh the current object
//
//  PARAMETERS:
//		lFlags				Flags
//		pContext			Operation context
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::Refresh_ (
	long iFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices)
	{
		if (m_pIWbemClassObject)
		{
			CComPtr<IWbemContext>	pIContext;

			//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
			//So we use Attach() instead to prevent the smart pointer from AddRef'ing.		
			pIContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider));

			// Order of preference:
			//	1. IWbemConfigureRefresher::AddObjectByTemplate
			//	2. IWbemServices::GetObject

			CComPtr<IWbemServices>	pIWbemServices;
			pIWbemServices.Attach(m_pSWbemServices->GetIWbemServices());
		
			if (pIWbemServices)
			{
				bool bUseRefresher = false;
				bool bOperationFailed = false;
				// Is this a class or an instance?
				bool bIsClass = false;
				CComVariant var;

				if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
					bIsClass = (WBEM_GENUS_CLASS  == var.lVal);

				/*
				 * IWbemConfigureRefresher cannot handle per-refresh context; if the caller
				 * gave us some context we'll have to drop down to loperf retrieval.
				 *
				 * Similarly the refresher cannot handle classes.
				 */
				if (bIsClass || (!pIContext))
				{
					if (m_bCanUseRefresher)
					{
						// If we don't have one get ourselves a refresher 
						if (NULL == m_pIWbemRefresher)
						{
							m_bCanUseRefresher = false;  // Until proven otherwise

							if (SUCCEEDED(CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, 
										IID_IWbemRefresher, (void**) &m_pIWbemRefresher )))
							{
								IWbemConfigureRefresher *pConfigureRefresher = NULL;

								// Get ourselves a refresher configurator
								if (SUCCEEDED(m_pIWbemRefresher->QueryInterface (IID_IWbemConfigureRefresher, 
													(void**) &pConfigureRefresher)))
								{
									CComPtr<IWbemClassObject>	pNewObject;
									long				lID = 0;

									// Add our object into it; we mask out all flag bits other 
									// than WBEM_FLAG_USE_AMENDED_QUALIFIERS.
									HRESULT hrRef = pConfigureRefresher->AddObjectByTemplate
											(pIWbemServices, m_pIWbemClassObject, 
											 iFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS, 
											 pIContext, &pNewObject, &lID);

									if (SUCCEEDED (hrRef))
									{
										m_bCanUseRefresher = true;	// Now we can use it

										// Swap in our refreshable object
										SetIWbemClassObject (pNewObject);

									}
									else if ((WBEM_E_INVALID_OPERATION != hrRef) &&
											 (WBEM_E_INVALID_PARAMETER != hrRef))
										bOperationFailed = true;	// A real refresh-independent failure

									pConfigureRefresher->Release ();
								}

								// If we can't use the refresher, release it now
								if (!m_bCanUseRefresher)
								{
									m_pIWbemRefresher->Release ();
									m_pIWbemRefresher = NULL;
								}
							}
						}

						bUseRefresher = m_bCanUseRefresher;
					}
				}

				// Having successfully set up a refresher/non-refresher scenario, let's go refresh
				if (!bOperationFailed)
				{
					if (bUseRefresher && m_pIWbemRefresher)
					{
						// Mask out all flags other than WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT 
						hr = m_pIWbemRefresher->Refresh (iFlags & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);
					}
					else
					{
						// Bah - not even a refresher can we use. Just do a GetObject instead
						CComBSTR bsPath;

						if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
						{
							// Fall pack to the low-perf way of doing things
							CComPtr<IWbemClassObject> pNewObject;

							// Mask out the WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT flag
							if (SUCCEEDED(hr = pIWbemServices->GetObject (bsPath, 
													iFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT, 
													pIContext, &pNewObject, NULL)))
							{
								// Swap in the new object
								SetIWbemClassObject (pNewObject);
							}
						}
					}
				}
			}
		}
	}

	SetWbemError (m_pSWbemServices);

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObject::GetText_
//
//  DESCRIPTION:
//
//  Get the object text
//
//  PARAMETERS:
//		iObjectTextFormat		Text format
//		pContext				Context
//		pbsText					On return holds text
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::GetText_ (
	WbemObjectTextFormatEnum iObjectTextFormat,
	long iFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	BSTR *pbsText
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == pbsText)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		*pbsText = NULL;
		CComPtr<IWbemContext>	pIContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.		
		pIContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider));


		CComPtr<IWbemObjectTextSrc> pIWbemObjectTextSrc;
		
		if (SUCCEEDED(CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER, 
						IID_IWbemObjectTextSrc, (PPVOID) &pIWbemObjectTextSrc)))
		{
			hr = pIWbemObjectTextSrc->GetText (iFlags, m_pIWbemClassObject, (ULONG) iObjectTextFormat,
							pIContext, pbsText);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
	
//***************************************************************************
//
//  SCODE CSWbemObject::SetFromText_
//
//  DESCRIPTION:
//
//  Set the object using the supplied text
//
//  PARAMETERS:
//		bsText					The text
//		iObjectTextFormat		Text format
//		pContext				Context
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObject::SetFromText_ (
	BSTR bsText,
	WbemObjectTextFormatEnum iObjectTextFormat,
	long iFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == bsText)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		CComPtr<IWbemContext>	pIContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.
		pIContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider));

		CComPtr<IWbemObjectTextSrc> pIWbemObjectTextSrc;

		if (SUCCEEDED(CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER, 
						IID_IWbemObjectTextSrc, (PPVOID) &pIWbemObjectTextSrc)))
		{
			CComPtr<IWbemClassObject> pIWbemClassObject;

			if (SUCCEEDED(hr = pIWbemObjectTextSrc->CreateFromText (iFlags, bsText, (ULONG) iObjectTextFormat,
							pIContext, &pIWbemClassObject)))
			{
				// Set the new object into our object
				SetIWbemClassObject (pIWbemClassObject);
			}
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemObject::GetIWbemClassObject
//
//  DESCRIPTION:
//
//  Given an IDispatch interface which we hope is also an ISWbemObjectEx
//	interface, return the underlying IWbemClassObject interface.
//
//  PARAMETERS:
//		pDispatch		the IDispatch in question
//
//  RETURN VALUES:
//		The underlying IWbemClassObject interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************
IWbemClassObject	*CSWbemObject::GetIWbemClassObject (
	IDispatch *pDispatch
)
{
	IWbemClassObject *pObject = NULL;
	ISWbemInternalObject *pIObject = NULL;

	if (NULL != pDispatch)
	{
		if (SUCCEEDED (pDispatch->QueryInterface
								(IID_ISWbemInternalObject, (PPVOID) &pIObject)))
		{
			pIObject->GetIWbemClassObject (&pObject);
			pIObject->Release ();
		}
	}

	return pObject;
}

//***************************************************************************
//
//  CSWbemObject::UpdateSite
//
//  DESCRIPTION:
//
//  If this object represents an embedded CIM object property value, then
//  as a result of changes to properties/qualifiers/path on this object it
//	is necessary to update the object in its parent.
//
//	This is to allow the following code to work:
//
//		Object.EmbeddedProperty.SimpleProperty = 3
//
//	i.e. so that the set to the value of SimpleProperty triggers an
//	automatic set of EmbeddedProperty to Object.
//
//  RETURN VALUES:
//		The underlying IWbemClassObject interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::UpdateSite ()
{
	// Update the site if it exists
	if (m_pSite)
		m_pSite->Update ();

	return S_OK;
}

//***************************************************************************
//
//  CSWbemObject::SetSite
//
//  DESCRIPTION:
//
//  Set the site of this object; this is used to anchor an embedded object
//	to a property (possibly indexed, if that property is an array).
//
//  PARAMETERS:
//		pParentObject	The parent of this object
//		propertyName	The property name for this object
//		index			The array index into the property (or -1)
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemObject::SetSite (
	ISWbemInternalObject *pParentObject,
	BSTR propertyName,
	long index
)
{
	if (m_pSite)
	{
		m_pSite->Release ();
		m_pSite = NULL;
	}

	CSWbemProperty *pSProperty = new CSWbemProperty (m_pSWbemServices,
					pParentObject, propertyName);
	m_pSite = new CWbemPropertySite (pSProperty, m_pIWbemClassObject, index);

	if (pSProperty)
		pSProperty->Release ();

	return S_OK;
}

void CSWbemObject::SetSite (IDispatch *pDispatch,
							ISWbemInternalObject *pSObject, BSTR propertyName, long index)
{
	if (NULL != pDispatch)
	{
		ISWbemInternalObject *pObject = NULL;

		if (SUCCEEDED (pDispatch->QueryInterface
								(IID_ISWbemInternalObject, (PPVOID) &pObject)))
		{
			pObject->SetSite (pSObject, propertyName, index);
			pObject->Release ();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\parsedn.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       parsedn.h
//
//	Description :
//				The implementation of IParseDisplayName
//
//***************************************************************************


#ifndef _PARSEDN_H_
#define _PARSEDN_H_

//***************************************************************************
//
//  Class :	CWbemParseDN
//
//  Description :
//			Implements the IParseDisplayName interface, which parses
//			CIM object paths and returns a pointer to the requested object
//
//  Public Methods :
//			IUnknown Methods
//			IParseDisplayName Methods
//			Constructor, Destructor
//			CreateProvider - creates an object of this class
//			
//	Public Data Members :
//
//***************************************************************************

class CWbemParseDN :  public IParseDisplayName
{
private:
	long m_cRef;

	static bool ParseAuthAndImpersonLevel (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				bool &authnSpecified,
				enum WbemAuthenticationLevelEnum *lpeAuthLevel,
				bool &impSpecified,
				enum WbemImpersonationLevelEnum *lpeImpersonLevel,
				CSWbemPrivilegeSet &privilegeSet,
				BSTR &bsAuthority);

	static bool ParseImpersonationLevel (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				enum WbemImpersonationLevelEnum *lpeImpersonLevel);

	static bool ParseAuthenticationLevel (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				enum WbemAuthenticationLevelEnum *lpeAuthLevel);

	static bool	ParsePrivilegeSet (
				LPWSTR lpszInputString,
				ULONG *pchEaten, 
				CSWbemPrivilegeSet &privilegeSet);

	static bool ParseAuthority (
				LPWSTR lpszInputString,
				ULONG *pchEaten, 
				BSTR &bsAuthority);

public:

	//IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	//IParseDisplayName members
    STDMETHODIMP		ParseDisplayName (IBindCtx* pbc,
                                      LPOLESTR szDisplayName,
                                      ULONG* pchEaten,
                                      IMoniker** ppmk);

    CWbemParseDN::CWbemParseDN();
    virtual CWbemParseDN::~CWbemParseDN();

	// Used for parsing the authentication and impersonation levels.
	static bool ParseSecurity (
				LPWSTR lpszInputString, 
				ULONG* pchEaten, 
				bool &authnSpecified,
				enum WbemAuthenticationLevelEnum *lpeAuthLevel,
				bool &impSpecified,
				enum WbemImpersonationLevelEnum *lpeImpersonLevel,
				CSWbemPrivilegeSet &privilegeSet,
				BSTR &bsAuthority);

	// Used for parsing the locale setting.
	static bool ParseLocale (
				LPWSTR lpszInputString,
				ULONG *pchEaten, 
				BSTR &bsLocale);

	// Used to return security specification as a string
	static wchar_t *GetSecurityString (
					bool authnSpecified, 
					enum WbemAuthenticationLevelEnum authnLevel, 
					bool impSpecified, 
					enum WbemImpersonationLevelEnum impLevel,
					CSWbemPrivilegeSet &privilegeSet,
					BSTR &bsAuthority
				 );

	// Used to return locale specification as a string
	static wchar_t *GetLocaleString (
					BSTR bsLocale
				 );
};


#endif //_PARSEDN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\objsink.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  objsink.h
//
//  rogerbo  22-May-98   Created.
//
//  Implementation of IWbemObjectSink for async stuff
//
//***************************************************************************

#ifndef _OBJSINK_H_
#define _OBJSINK_H_

// CIWbemObjectSinkCachedMethodItem is the base class of link list items
// representing cached method calls to IWbemObjectSink.  Whenever we are inside
// an IWbemObjectSink method, and we receive a nested call to IWbemObjectSink,
// we store the parameters to the nested call and redo the call just before the
// original method returns.  It is important to cache all methods on the sink to
// preserve the order that they are seen by the client.  This means that
// if calls to SetStatus come in during a call to Indicate, it must be cached.
// In addition, we cache calls across all instances of IWbemObjectSink.  In
// other words, suppose we have two async requests (request1 and request2).  If
// we are processing an Indicate for request1 and get an Indicate for request2,
// we have to cache the nested Indicate (including the this pointer for the
// IWbemObjectSink), and call the recall the nested Indicate at the end of the
// Indicate for request1.
class CIWbemObjectSinkCachedMethodItem
{
public:
	CIWbemObjectSinkCachedMethodItem(IWbemObjectSink *pSink) : 
					m_pSink (pSink),
					m_pNext (NULL)
	{
		if (m_pSink)
			m_pSink->AddRef();
	}

	virtual ~CIWbemObjectSinkCachedMethodItem()
	{
		if (m_pSink)
			m_pSink->Release();
	}

	// DoCallAgain is to be overridden in derived classes to recall cached
	// methods.
	virtual void DoCallAgain() = 0;

	// This is a pointer to the next cached interface call
	CIWbemObjectSinkCachedMethodItem *m_pNext;

protected:
	// Pointer to the original IWbemObjectSink for the cached call
	IWbemObjectSink *m_pSink;
};

// CIWbemObjectSinkCachedIndicate represents a cached call to Indicate
class CIWbemObjectSinkCachedIndicate : public CIWbemObjectSinkCachedMethodItem
{
public:
	CIWbemObjectSinkCachedIndicate(IWbemObjectSink *pSink, long lObjectCount, IWbemClassObject **apObjArray) 
			: CIWbemObjectSinkCachedMethodItem (pSink)
	{
		_RD(static char *me = "CIWbemObjectSinkCachedIndicate::CIWbemObjectSinkCachedIndicate";)
		_RPrint(me, "", 0, "");

		// Store the original parameters to the Indicate call
		// TODO: What if lObjectCount = 0 ?
		m_lObjectCount = lObjectCount;
		m_apObjArray = new IWbemClassObject*[lObjectCount];

		if (m_apObjArray)
		{
			for(int i=0;i<lObjectCount;i++)
			{
				apObjArray[i]->AddRef();
				m_apObjArray[i] = apObjArray[i];
			}
		}
	}

	~CIWbemObjectSinkCachedIndicate()
	{
		_RD(static char *me = "CIWbemObjectSinkCachedIndicate::~CIWbemObjectSinkCachedIndicate";)
		_RPrint(me, "", 0, "");

		// Free memory used to store original parameters to Indicate
		if (m_apObjArray)
		{
			for(int i=0;i<m_lObjectCount;i++)
			{
				RELEASEANDNULL(m_apObjArray[i])
			}

			delete [] m_apObjArray;
		}
	}

	void DoCallAgain()
	{
		// Recall the Indicate method with the cached parameters
		if (m_pSink && m_apObjArray)
			m_pSink->Indicate(m_lObjectCount, m_apObjArray);
	}

private:
	// Parameters to Indicate that we must store
	long m_lObjectCount;
	IWbemClassObject **m_apObjArray;
};

// CIWbemObjectSinkCachedSetStatus represents a cached call to SetStatus
class CIWbemObjectSinkCachedSetStatus : public CIWbemObjectSinkCachedMethodItem
{
public:
	CIWbemObjectSinkCachedSetStatus(
		IWbemObjectSink *pSink, 
		long lFlags, 
		HRESULT hResult, 
		BSTR strParam, 
		IWbemClassObject *pObjParam)  : 
				CIWbemObjectSinkCachedMethodItem (pSink), 
				m_lFlags (lFlags),
				m_hResult (hResult),
				m_strParam (NULL),
				m_pObjParam (pObjParam)
	{
		_RD(static char *me = "CIWbemObjectSinkCachedSetStatus::CIWbemObjectSinkCachedSetStatus";)
		_RPrint(me, "", 0, "");

		if(strParam)
			m_strParam = SysAllocString(strParam);

		if(m_pObjParam)
			m_pObjParam->AddRef();
	}

	~CIWbemObjectSinkCachedSetStatus()
	{
		_RD(static char *me = "CIWbemObjectSinkCachedSetStatus::~CIWbemObjectSinkCachedSetStatus";)
		_RPrint(me, "", 0, "");

		// Free memory used to store original parameters to SetStatus
		FREEANDNULL(m_strParam)
		RELEASEANDNULL(m_pObjParam)
	}

	void DoCallAgain()
	{
		// Recall the SetStatus method with the cached parameters
		if (m_pSink)
			m_pSink->SetStatus(m_lFlags, m_hResult, m_strParam, m_pObjParam);
	}

private:
	// Parameters to SetStatus that we must store
	long m_lFlags;
	HRESULT m_hResult;
	BSTR m_strParam;
	IWbemClassObject *m_pObjParam;
};

// This is the class that manages all cached calls to IWbemObjectSink.  To
// cache the interface method calls, each interface method should call
// TestOkToRunXXX where XXX is the method name.  If this function returns
// FALSE, it means that we are already inside another method call.  The
// parameters will have been cached, the the method should return immediately.
// At the end of the method, Cleanup should be called so that all cached method
// calls can be recalled.
class CIWbemObjectSinkMethodCache
{
protected:
	// Constructor/destructor are protected since this object should only be
	// created/destroyed by the static methods AddRefForThread/ReleaseForThread
	CIWbemObjectSinkMethodCache() :
		m_fInInterface (FALSE),
		m_pFirst (NULL),
		m_pLast (NULL),
		m_fOverrideTest (FALSE),
		m_fOverrideCleanup (FALSE),
		m_dwRef (1)
	{
		_RD(static char *me = "CIWbemObjectSinkMethodCache::CIWbemObjectSinkMethodCache";)
		_RPrint(me, "", 0, "");
	}

	~CIWbemObjectSinkMethodCache()
	{
		_RD(static char *me = "CIWbemObjectSinkMethodCache::~CIWbemObjectSinkMethodCache";)
		_RPrint(me, "", 0, "");
		_RPrint(me, "m_pFirst: ", long(m_pFirst), "");
		_RPrint(me, "m_pLast: ", long(m_pLast), "");

		// TODO: ASSERT that m_pFirst and m_pLast are NULL.  In other words,
		// as long as Cleanup is called at the end of each interface method,
		// the internal link list should be completely empty.
	}

public:
	// Public Methods

	static void Initialize () {
		sm_dwTlsForInterfaceCache = TlsAlloc();
	}

	static void TidyUp () {
		if (-1 != sm_dwTlsForInterfaceCache)
		{
			TlsFree (sm_dwTlsForInterfaceCache);
			sm_dwTlsForInterfaceCache = -1;
		}
	}

	static void AddRefForThread()
	{
		if(-1 == sm_dwTlsForInterfaceCache)
			return; // We failed the original alloc

		// The Tls value for sm_dwTlsForInterfaceCache is guaranteed to
		// initialize to NULL
		CIWbemObjectSinkMethodCache *pSinkMethodCache = (CIWbemObjectSinkMethodCache *)TlsGetValue(sm_dwTlsForInterfaceCache);
		
		if(NULL == pSinkMethodCache)
			TlsSetValue(sm_dwTlsForInterfaceCache, new CIWbemObjectSinkMethodCache);
		else
			pSinkMethodCache->AddRef();
	}

	static void ReleaseForThread()
	{
		if(-1 == sm_dwTlsForInterfaceCache)
			return; // We failed the original alloc

		CIWbemObjectSinkMethodCache *pSinkMethodCache = (CIWbemObjectSinkMethodCache *)TlsGetValue(sm_dwTlsForInterfaceCache);
		if(NULL != pSinkMethodCache)
		{
			DWORD dwCount = pSinkMethodCache->Release();
			if(dwCount == 0)
			{
				delete pSinkMethodCache;
				TlsSetValue(sm_dwTlsForInterfaceCache, NULL);
			}
		}
	}

	static CIWbemObjectSinkMethodCache *GetThreadsCache()
	{
		if(-1 == sm_dwTlsForInterfaceCache)
			return NULL; // We failed the original alloc
		return (CIWbemObjectSinkMethodCache *)TlsGetValue(sm_dwTlsForInterfaceCache);
	}

protected:
	// TLS slot for Interface Cache pointer
	static DWORD sm_dwTlsForInterfaceCache;

public:
	// Public Instance Methods

	// Call this method at the start of the Indicate method.  If this method
	// returns TRUE, Indicate should return immediately.
	BOOL TestOkToRunIndicate(IWbemObjectSink *pSink, long lObjectCount, IWbemClassObject **apObjArray)
	{
		// If there was a problem allocating the TLS instance of the cache,
		// 'this' might be NULL.  In that case, act as if there was no cache
		if(NULL == this)
			return TRUE;

		// If m_fOverrideTest is TRUE, it means that we are recalling a cached
		// call to Indicate.  We therefore must complete the body of Indicate.
		if(m_fOverrideTest)
		{
			m_fOverrideTest = FALSE;
			return TRUE;
		}

		// If we are already in an interface method, cache this call
		if(m_fInInterface)
		{
			CIWbemObjectSinkCachedIndicate *pItem = new CIWbemObjectSinkCachedIndicate(pSink, lObjectCount, apObjArray);
			// TODO: What if allocation fails?
			if(pItem)
				AddItem(pItem);
			return FALSE;
		}

		// We are not already in another interface method, but we set
		// m_fInInterface to TRUE to prevent nested calls
		m_fInInterface = TRUE;
		return TRUE;
	}

	// Call this method at the start of the SetStatus method.  If this method
	// returns TRUE, SetStatus should return immediately.
	BOOL TestOkToRunSetStatus(IWbemObjectSink *pSink, long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject *pObjParam)
	{
		// If there was a problem allocating the TLS instance of the cache,
		// 'this' might be NULL.  In that case, act as if there was no cache
		if(NULL == this)
			return TRUE;

		// If m_fOverrideTest is TRUE, it means that we are recalling a cached
		// call to SetStatus.  We therefore must complete the body of SetStatus.
		if(m_fOverrideTest)
		{
			m_fOverrideTest = FALSE;
			return TRUE;
		}

		// If we are already in an interface method, cache this call
		if(m_fInInterface)
		{
			CIWbemObjectSinkCachedSetStatus *pItem = new CIWbemObjectSinkCachedSetStatus(pSink, lFlags, hResult, strParam, pObjParam);
			// TODO: What if allocation fails?
			if(pItem)
				AddItem(pItem);
			return FALSE;
		}

		// We are not already in another interface method, but we set
		// m_fInInterface to TRUE to prevent nested calls
		m_fInInterface = TRUE;
		return TRUE;
	}

	// At the end of every IWbemObjectSink method, Cleanup should be called.
	// This will recall any cached method parameters
	void Cleanup()
	{
		// If there was a problem allocating the TLS instance of the cache,
		// 'this' might be NULL.  In that case, act as if there was no cache
		if(NULL == this)
			return;

		// If m_fOverridCleanup is TRUE, we are in an interface method because
		// we are recalling it.  There is nothing more that Cleanup should do
		if(m_fOverrideCleanup)
		{
			m_fOverrideCleanup = FALSE;
			return;
		}

		// While there are any items in the link list, recall the methods.
		// NOTE: It is possible that new items will be added to the end of the
		// link list during DoCallAgain, but when this 'while' loop finishes
		// we will be in a state where all cached methods have been called
		while(m_pFirst)
		{
			// Set override flags so that the interface methods know that they
			// are not receiving a nested call
			m_fOverrideTest = TRUE;
			m_fOverrideCleanup = TRUE;

			// Recall the cached method
			m_pFirst->DoCallAgain();

			// Remove this item from the start of the link list
			CIWbemObjectSinkCachedMethodItem *pItem = m_pFirst;
			m_pFirst = pItem->m_pNext;
			delete pItem;
		}

		// The link list is empty
		m_pLast = NULL;

		// We are about to leave the interface method
		m_fInInterface = FALSE;
	}

protected:

	// Add cached method information to the link list
	void AddItem(CIWbemObjectSinkCachedMethodItem *pItem)
	{
		if(NULL == m_pLast)
		{
			m_pFirst = pItem;
			m_pLast = pItem;
		}
		else
		{
			m_pLast->m_pNext = pItem;
			m_pLast = pItem;
		}
	}

protected:
	// Reference counting of thread local object
	void AddRef()
	{
		m_dwRef++;
	}
	int Release()
	{
		m_dwRef--;
		return m_dwRef;
	}
	DWORD m_dwRef;

protected:
	// Member Variables

	// Flag that specifies if we are currently processing an interface method
	BOOL m_fInInterface;

	// Pointer to the first and last items of the link list of cached methods
	CIWbemObjectSinkCachedMethodItem *m_pFirst;
	CIWbemObjectSinkCachedMethodItem *m_pLast;

	// Flags to tell interface method implementations that they are being called
	// to recall a cached method as opposed to receiving a nested call.
	BOOL m_fOverrideTest;
	BOOL m_fOverrideCleanup;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemObjectSink
//
//  DESCRIPTION:
//
//  Implements the IWbemObjectSink interface.  
//
//***************************************************************************

class CWbemObjectSink : public IWbemObjectSink
{

private:

	CSWbemServices		*m_pServices;
	IUnsecuredApartment *m_pUnsecuredApartment;
	ISWbemPrivateSink	*m_pSWbemSink;
	IDispatch			*m_pContext;
	IWbemObjectSink		*m_pObjectStub;
	BSTR m_bsClassName;
	bool m_putOperation;
	bool m_operationInProgress;
	bool m_setStatusCompletedCalled;

	// Members required for just-in-time initialization of m_pServices
	BSTR m_bsNamespace;
	BSTR m_bsUser;
	BSTR m_bsPassword;
	BSTR m_bsLocale;

	void RemoveObjectSink();
	HRESULT AddObjectSink(IWbemObjectSink *pSink);

protected:
	long            m_cRef;         //Object reference count

public:
	CWbemObjectSink(CSWbemServices *pServices, IDispatch *pSWbemSink, IDispatch *pContext, 
												bool putOperation = false, BSTR bsClassName = NULL);
	~CWbemObjectSink(void);

	static IWbemObjectSink *CreateObjectSink(CWbemObjectSink **pWbemObjectSink, 
											 CSWbemServices *pServices, 
											 IDispatch *pSWbemSink, 
											 IDispatch *pContext, 
											 bool putOperation = false, 
											 BSTR bsClassName = NULL);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  E_NOTIMPL;}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return E_NOTIMPL;}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return E_NOTIMPL;}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return E_NOTIMPL;}
    
	// IWbemObjectSink methods

        HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
        
        HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);

	IWbemObjectSink *GetObjectStub();

	void ReleaseTheStubIfNecessary(HRESULT hResult);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\objobjp.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  objobjp.h
//
//  alanbos  13-Feb-98   Created.
//
//  Implementation of IWbemObjectPathEx for ISWbemObjectEx.
//
//***************************************************************************

#ifndef _OBJOBJP_H_
#define _OBJOBJP_H_

class CSWbemObjectObjectPathSecurity;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectObjectPath
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectPath interface for the 
//	ISWbemObject.Path_ property.  
//
//***************************************************************************

class CSWbemObjectObjectPath : public ISWbemObjectPath,
							   public ISupportErrorInfo,
							   public IProvideClassInfo
{
private:
	class CObjectObjectPathDispatchHelp : public CDispatchHelp
	{
		public:
			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};
	IWbemClassObject				*m_pIWbemClassObject;
	CSWbemServices					*m_pSWbemServices;
	CObjectObjectPathDispatchHelp	m_Dispatch;
	CWbemSite						*m_pSite;
	CSWbemObjectObjectPathSecurity	*m_pSecurity;

	HRESULT STDMETHODCALLTYPE	GetStrVal (BSTR *value, LPWSTR name);

	HRESULT				RaiseReadOnlyException ()
	{
		m_Dispatch.RaiseException (WBEM_E_READ_ONLY);
		return WBEM_E_READ_ONLY;
	}

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemObjectObjectPath(CSWbemServices *pSWbemServices, CSWbemObject *pSObject);
    ~CSWbemObjectObjectPath(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemObjectPath methods

    HRESULT STDMETHODCALLTYPE get_Path( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
        
    HRESULT STDMETHODCALLTYPE put_Path( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_RelPath( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_RelPath( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_DisplayName( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
        
    HRESULT STDMETHODCALLTYPE put_DisplayName( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_Namespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
        
    HRESULT STDMETHODCALLTYPE put_Namespace( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_ParentNamespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE get_Server( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Server( 
        /* [in] */ BSTR __RPC_FAR value)
	{
		return RaiseReadOnlyException ();
	}
    
    HRESULT STDMETHODCALLTYPE get_IsClass( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE SetAsClass()
	{
		return RaiseReadOnlyException ();
	}
   
    HRESULT STDMETHODCALLTYPE get_IsSingleton( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
       HRESULT STDMETHODCALLTYPE SetAsSingleton() 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_Class( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Class( 
        /* [in] */ BSTR __RPC_FAR value) ;

	HRESULT STDMETHODCALLTYPE get_Keys(
		/* [out,retval] */ ISWbemNamedValueSet **objKeys);

	HRESULT STDMETHODCALLTYPE get_Security_(
		/* [out,retval] */ ISWbemSecurity **objKeys);

    HRESULT STDMETHODCALLTYPE get_Locale( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_Locale( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

    HRESULT STDMETHODCALLTYPE get_Authority( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_Authority( 
        /* [in] */ BSTR __RPC_FAR value) 
	{
		return RaiseReadOnlyException ();
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectObjectPathSecurity
//
//  DESCRIPTION:
//
//  Implements the ISWbemSecurity interface for CSWbemObjectObjectPath.  
//
//***************************************************************************

class CSWbemObjectObjectPathSecurity : public ISWbemSecurity,
									   public ISupportErrorInfo,
									   public IProvideClassInfo
{
private:
	CSWbemPrivilegeSet			*m_pPrivilegeSet;
	CDispatchHelp				m_Dispatch;
	WbemImpersonationLevelEnum	m_dwImpLevel;
	WbemAuthenticationLevelEnum	m_dwAuthnLevel;
	BSTR						m_bsAuthority;

	HRESULT				RaiseReadOnlyException ()
	{
		m_Dispatch.RaiseException (WBEM_E_READ_ONLY);
		return WBEM_E_READ_ONLY;
	}

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemObjectObjectPathSecurity (CSWbemServices *pSWbemServices);
	virtual ~CSWbemObjectObjectPathSecurity (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemSecurity methods

	HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
	(
		/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
	(
		/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
	)
	{
		return RaiseReadOnlyException ();
	}

	HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
	(
		/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
	(
		/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
	)
	{
		return RaiseReadOnlyException ();
	}

	HRESULT STDMETHODCALLTYPE get_Privileges 
	(
		/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);
	
	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// Other methods
	CSWbemPrivilegeSet *GetPrivilegeSet ()
	{
		CSWbemPrivilegeSet *pPrivSet = m_pPrivilegeSet;

		if (pPrivSet)
			pPrivSet->AddRef ();

		return pPrivSet;
	}

	BSTR &GetAuthority ()
	{
		return m_bsAuthority;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\parsedn.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  File:  parsedn.cxx
//
//	Description :
//				Parses CIM paths to objects and returns the requested object
//***************************************************************************

#include "precomp.h"

#define CURRENTSTR (lpszInputString + *pchEaten)

#define SKIPWHITESPACE \
	while (*CURRENTSTR && _istspace( *CURRENTSTR ) ) \
			(*pchEaten)++;

#define WBEMS_STR_OWNER		L"O"
#define	WBEMS_STR_GROUP		L"G"
#define WBEMS_STR_DACL		L"D"
#define WBEMS_STR_SACL		L"S"

static void SecureProxy (bool authnSpecified, enum WbemAuthenticationLevelEnum eAuthLevel,
						 bool impSpecified, enum WbemImpersonationLevelEnum eImpersonLevel,
						 ISWbemServices *pService)
{
	// Secure the proxy using the specified security settings (if any)
	CComPtr<ISWbemSecurity> pSecurity;
	
	if (authnSpecified || impSpecified)
	{
		if (SUCCEEDED(pService->get_Security_(&pSecurity)))
		{
			if (authnSpecified)
				pSecurity->put_AuthenticationLevel (eAuthLevel);

			if (impSpecified)
				pSecurity->put_ImpersonationLevel (eImpersonLevel);
		}
	}
}

static void SecureProxy (bool authnSpecified, enum WbemAuthenticationLevelEnum eAuthLevel,
						 bool impSpecified, enum WbemImpersonationLevelEnum eImpersonLevel,
						 ISWbemObject *pObject)
{
	// Secure the proxy using the specified security settings (if any)
	CComPtr<ISWbemSecurity> pSecurity;
	
	if (authnSpecified || impSpecified)
	{
		if (SUCCEEDED(pObject->get_Security_(&pSecurity)))
		{
			if (authnSpecified)
				pSecurity->put_AuthenticationLevel (eAuthLevel);

			if (impSpecified)
				pSecurity->put_ImpersonationLevel (eImpersonLevel);
		}
	}
}

//***************************************************************************
//
//  CWbemParseDN::CWbemParseDN
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemParseDN::CWbemParseDN():
			m_cRef(0)
{
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CWbemParseDN::~CWbemParseDN
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemParseDN::~CWbemParseDN(void)
{
	InterlockedDecrement(&g_cObj);
}			

//***************************************************************************
// HRESULT CWbemParseDN::QueryInterface
// long CWbemParseDN::AddRef
// long CWbemParseDN::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemParseDN::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = (IUnknown *)this;
	else if (IID_IParseDisplayName==riid)
        *ppv = (IParseDisplayName *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CWbemParseDN::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWbemParseDN::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CWbemParseDN::ParseDisplayName
//
//  DESCRIPTION:
//
//  Take a CIM object path and return a suitable ISWbem... object 
//
//  PARAMETERS:
//
//	pCtx					The binding context (not used)
//	szDisplayName			The display name to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//  ppmk					On return will address the moniker pointer
//
//  RETURN VALUES:
//
//  E_FAIL					misery
//
//	Other CreateMoniker codes are returned.
//
//***************************************************************************
STDMETHODIMP CWbemParseDN::ParseDisplayName(
	IBindCtx* pCtx, 
	LPOLESTR szDisplayName, 
	ULONG* pchEaten, 
	IMoniker** ppmk)
{
    HRESULT hr = E_FAIL;
    LPUNKNOWN pUnknown = NULL;
	ULONG lTemp = 0;
	
	enum WbemAuthenticationLevelEnum eAuthLevel;
	enum WbemImpersonationLevelEnum eImpersonLevel;
	bool authnSpecified = false;
	bool impSpecified = false;
	BSTR bsAuthority = NULL;
		
	//Check input parameters
	*ppmk = NULL;
    if (NULL != pchEaten)
        *pchEaten = 0;

	if (NULL == szDisplayName)
		return E_FAIL;

	/*
	 *  moniker :  wmiMoniker 
	 *
	 *	wmiMoniker : ["winmgmts:" | "wmi:"] securitySetting ["[" localeSetting "]"] ["!" objectPath]
	 *					| ["winmgmts:" | "wmi:"] "[" localeSetting "]" ["!" objectPath]
	 *					| ["winmgmts:" | "wmi:"] [objectPath]
	 *					| [nativePath]
	 *
	 *	localeSetting    : "locale" <ows> "=" <ows> localeID
	 *
	 *	localeID        : a value of the form "ms_xxxx" where xxxx is a hex LCID value e.g. "ms_0x409".
	 *
	 *	objectPath     : a valid WMI Object Path
	 *
	 *	securitySetting : "{" <ows> authAndImpersonSettings [<ows> "," <ows> privilegeOverrides]
	 *				| "{" <ows> authAndImpersonSettings [<ows> "," <ows> privilegeOverrides] <ows> "}" <ows>
	 *				| "{" <ows> privilegeOverrides <ows> "}" <ows>
	 *				
	 *
	 *	authAndImpersonSettings : 
	 *			authenticationLevel 
	 *			| impersonationLevel
	 *			| authority 
	 *			| authenticationLevel <ows> "," <ows> impersonationLevel [<ows> "," <ows> authority]
	 *			| authenticationLevel <ows> "," <ows> authority [<ows> "," <ows> impersonationLevel]
	 *			| impersonationLevel <ows> "," <ows> authenticationLevel [<ows> "," <ows> authority]
	 *			| impersonationLevel <ows> "," <ows> authority [<ows> "," <ows> authenticationLevel]
	 *			| authority <ows> "," <ows> impersonationLevel [<ows> "," <ows> authenticationLevel]
	 *			| authority <ows> "," <ows> authenticationLevel [<ows> "," <ows> impersonationLevel]
     *               
	 *
	 *	authority : "authority" <ows> "=" <ows> authorityValue
	 *
	 *	authorityValue :    Any valid WMI authority string e.g. "kerberos:mydomain\server" or "ntlmdomain:mydomain".   Note that backslashes need to be escaped in JScript.
	 *
	 *	authenticationLevel : "authenticationLevel" <ows> "=" <ows> authenticationValue 
	 *
	 *	authenticationValue : "default" | "none" | "connect" | "call" | "pkt" | "pktIntegrity" | "pktPrivacy" 
	 *
	 *	impersonationLevel : "impersonationLevel" <ows> "=" <ows> impersonationValue 
	 *
	 *	impersonationValue : "anonymous" | "identify" | "impersonate" | "delegate"
	 *
	 *	privilegeOverrides : "(" <ows> privileges <ows> ")"
	 *
	 *	privileges : privilege [<ows> "," <ows> privileges <ows>]*
	 *
	 *	privilege : ["!"] privilegeName
	 *
	 *	privilegeName : "CreateToken" | "PrimaryToken" | "LockMemory" | "IncreaseQuota" 
	 *						| "MachineAccount" | "Tcb" | "Security" | "TakeOwnership" 
	 *						| "LoadDriver" | "SystemProfile" | "SystemTime" 
	 *						| "ProfileSingleProcess" | "IncreaseBasePriority" 
	 *						| "CreatePagefile" | "CreatePermanent" | "Backup" | "Restore" 
	 *						| "Shutdown" | "Debug" | "Audit" | "SystemEnvironment" | "ChangeNotify" 
	 *						| "RemoteShutdown"
	 *
	 */

	// It had better start with our scheme name
	bool bCheckContext = false;

	if (0 == _wcsnicmp (szDisplayName, WBEMS_PDN_SCHEME, wcslen (WBEMS_PDN_SCHEME)))
	{
		*pchEaten += wcslen (WBEMS_PDN_SCHEME);
		bCheckContext = (pCtx && (wcslen (szDisplayName) == wcslen (WBEMS_PDN_SCHEME)));
	}
	else
		return E_FAIL;

	// One more check - if it was just the scheme and no more check for extra info in the context
	if (bCheckContext)
	{
		IUnknown *pUnk = NULL;

		if (SUCCEEDED (pCtx->GetObjectParam (L"WmiObject", &pUnk)) && pUnk)
		{
			// Is it an IWbemClassObject?
			IWbemClassObject *pIWbemClassObject = NULL;
			// Or is it an IWbemContext?
			IWbemContext *pIWbemContext = NULL;
			// Or is it an IWbemServices?
			IWbemServices *pIWbemServices = NULL;

			if (SUCCEEDED (pUnk->QueryInterface (IID_IWbemClassObject, (void **) &pIWbemClassObject)))
			{
				CSWbemObject *pSWbemObject = new CSWbemObject (NULL, pIWbemClassObject);

				if (!pSWbemObject)
					hr = E_OUTOFMEMORY;
				else
				{
					CComPtr<ISWbemObjectEx> pISWbemObjectEx;
						
					if (SUCCEEDED (pSWbemObject->QueryInterface (IID_ISWbemObjectEx, (void **) &pISWbemObjectEx)))
						hr = CreatePointerMoniker (pISWbemObjectEx, ppmk);
				}

				pIWbemClassObject->Release ();
			} 
			else if (SUCCEEDED (pUnk->QueryInterface (IID_IWbemContext, (void **) &pIWbemContext)))
			{
				CSWbemNamedValueSet *pSWbemNamedValueSet = new CSWbemNamedValueSet (NULL, pIWbemContext);

				if (!pSWbemNamedValueSet)
					hr = E_OUTOFMEMORY;
				else
				{
					CComPtr<ISWbemNamedValueSet> pISWbemNamedValueSet;
						
					if (SUCCEEDED (pSWbemNamedValueSet->QueryInterface (IID_ISWbemNamedValueSet, 
														(PPVOID)&pISWbemNamedValueSet)))
						hr = CreatePointerMoniker (pISWbemNamedValueSet, ppmk);
				}
					
				pIWbemContext->Release ();
			} 
			else if (SUCCEEDED (pUnk->QueryInterface (IID_IWbemServices, (void **) &pIWbemServices)))
			{
				// In this case we must get passed the object path as well
				CComPtr<IUnknown> pUnkPath;

				if (SUCCEEDED (pCtx->GetObjectParam (L"WmiObjectPath", &pUnkPath)) && pUnkPath)
				{
					CComPtr<ISWbemObjectPath> pISWbemObjectPath;
					
					if (SUCCEEDED (pUnkPath->QueryInterface (IID_ISWbemObjectPath, (void **) &pISWbemObjectPath)))
					{
						// Dig the path out to initialize 
						CComBSTR bsNamespace = NULL;

						pISWbemObjectPath->get_Path (&bsNamespace);

						CSWbemServices *pSWbemServices = new CSWbemServices (pIWbemServices, 
														bsNamespace, (BSTR) NULL, NULL, NULL);

						if (!pSWbemServices)
							hr = E_OUTOFMEMORY;
						else
						{
							CComQIPtr<ISWbemServicesEx>
											pISWbemServicesEx (pSWbemServices);
							
							if (pISWbemServicesEx)
								hr = CreatePointerMoniker (pISWbemServicesEx, ppmk);
						}
					}
				}
				pIWbemServices->Release ();
			}

			pUnk->Release ();
		}

		// If this worked return now - o/w revert to regular parsing
		if (SUCCEEDED (hr))
			return hr;
	}
	
	// Check for the optional security info
	CSWbemPrivilegeSet	privilegeSet;

	if (ParseSecurity(szDisplayName + *pchEaten, &lTemp, authnSpecified, &eAuthLevel, 
										impSpecified, &eImpersonLevel, privilegeSet,
										bsAuthority))
		*pchEaten += lTemp;

	// If no impersonation level was specified, get the default from the registry
	if (!impSpecified)
	{
		eImpersonLevel = CSWbemSecurity::GetDefaultImpersonationLevel ();
		impSpecified = true;
	}

	// Create a locator
	CSWbemLocator *pCSWbemLocator = new CSWbemLocator(&privilegeSet);

	if (!pCSWbemLocator)
		hr = E_OUTOFMEMORY;
	else
	{
		CComQIPtr<ISWbemLocator> pISWbemLocator (pCSWbemLocator);

		if (pISWbemLocator)
		{
			// Parse the locale information (if present)
			lTemp = 0;
			BSTR bsLocale = NULL;

			if (ParseLocale (szDisplayName + *pchEaten, &lTemp, bsLocale))
			{
				*pchEaten += lTemp;

				// Skip over the "!" separator if there is one
				if(*(szDisplayName + *pchEaten) != NULL)
					if (0 == _wcsnicmp (szDisplayName + *pchEaten, WBEMS_EXCLAMATION, wcslen (WBEMS_EXCLAMATION)))
						*pchEaten += wcslen (WBEMS_EXCLAMATION);

				// Now ready to parse the path - check if we have the degenerate cases
				if (0 == wcslen (szDisplayName + *pchEaten))
				{		
					// Need to return connection to default namespace on local machine
					CComPtr<ISWbemServices> pISWbemServices;
					if (SUCCEEDED( hr = pISWbemLocator->ConnectServer (NULL, NULL, NULL, NULL,
								bsLocale, bsAuthority, 0, NULL, &pISWbemServices)) )
					{
						SecureProxy (authnSpecified, eAuthLevel, impSpecified, eImpersonLevel, pISWbemServices);
						hr = CreatePointerMoniker(pISWbemServices, ppmk);
					}
				}
				else
				{
					/*
					 * Check the path to see if we are dealing with a class or an instance.
					 * Note that we construct the parser with a flag indicating that relative
					 * namespace paths are OK (not the default behavior).
					 */
					CWbemPathCracker	pathCracker (szDisplayName + *pchEaten);

					if (CWbemPathCracker::WbemPathType::wbemPathTypeError != pathCracker.GetType ())
					{
						CComBSTR bsNamespacePath, bsServerPath;

						if (pathCracker.GetNamespacePath (bsNamespacePath)
							&& pathCracker.GetServer (bsServerPath))
						{
							// Success - begin by connecting to the namespace.
							CComPtr<ISWbemServices> pISWbemServices;
							
							if (SUCCEEDED( hr = pISWbemLocator->ConnectServer (bsServerPath, 
									bsNamespacePath, NULL, NULL, bsLocale, bsAuthority, 0, NULL, &pISWbemServices)) )
							{
								// Secure the proxy using the specified security settings (if any)
								SecureProxy (authnSpecified, eAuthLevel, impSpecified, eImpersonLevel, pISWbemServices);
							
								// Successful connection - now work out if we have a class or instance
								// component. 
								if (pathCracker.IsClassOrInstance())
								{
									CComPtr<ISWbemObject> pISWbemObject;

									// Now get it
									CComBSTR bsRelPath;
									
									if (pathCracker.GetPathText (bsRelPath, true))
									{
										long lFlags = 0; 

										// Note that when we retrieve the object we will retrieve
										// the localized version if a locale was specified in the moniker
										if ((NULL != bsLocale) && (0 < wcslen (bsLocale)))
											lFlags |= wbemFlagUseAmendedQualifiers;

										if (SUCCEEDED( hr = pISWbemServices->Get (bsRelPath,
														lFlags, NULL, &pISWbemObject)) )
											hr = CreatePointerMoniker (pISWbemObject, ppmk);
									}
								}
								else
								{
									// Just a namespace
									hr = CreatePointerMoniker(pISWbemServices, ppmk);				
								}
							}
						}
						else
							hr = WBEM_E_INVALID_SYNTAX;	// Parse failure - abandon ship
					}
					else
						hr = WBEM_E_INVALID_SYNTAX;	// Parse failure - abandon ship
				}
			}
			else
			{
				// Parse failure
				hr = WBEM_E_INVALID_SYNTAX;
			}

			SysFreeString (bsLocale);
		}
	}

	SysFreeString (bsAuthority);

	if (FAILED (hr))
		*pchEaten = 0;
	else
		*pchEaten = wcslen(szDisplayName);

	return hr;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseSecurity
//
//  DESCRIPTION:
//
//  Take an authentication and impersonlation level string as described by the 
//	non-terminal authAndImpersonLevel and parse it into the authentication
// and impersonation levels
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	authnSpecified			Whether the Moniker specifies a non-default 
//							authn levl
//	lpeAuthLevel			The authentication level parsed. This is one of 
//							enum WbemAuthenticationLevelEnum.
//	impSpecified			Whether the Moniker specifies a non-default imp 
//							level
//	lpeImpersonLevel		The impersonation level parsed. This is one of 
//							enum WbemImpersonationLevelEnum.
//	privilegeSet			On return contains the specified privileges
//	bsAuthority				On return contains the specified authority
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeAuthLevel and 
//							lpeImpersonLevel arguments have valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseSecurity (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	bool &authnSpecified,
	enum WbemAuthenticationLevelEnum *lpeAuthLevel,
	bool &impSpecified,
	enum WbemImpersonationLevelEnum *lpeImpersonLevel,
	CSWbemPrivilegeSet	&privilegeSet,
	BSTR &bsAuthority)
{
	bool status = false;

	// Set the default authentication and impersonation levels. 
	*lpeAuthLevel = wbemAuthenticationLevelNone;
	*lpeImpersonLevel = wbemImpersonationLevelImpersonate;

	// Initialize the number of consumed characters
	*pchEaten = 0;

	// Parse the contents

	if (ParseAuthAndImpersonLevel (lpszInputString, pchEaten, authnSpecified, lpeAuthLevel,
					impSpecified, lpeImpersonLevel, privilegeSet, bsAuthority))
		status = true;
	else
		*pchEaten = 0;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseLocale
//
//  DESCRIPTION:
//
//  Take locale setting string as described by the non-terminal localeSetting 
//	and parse it.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	bsLocale				Reference to BSTR to hold parsed locale setting
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. 
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseLocale (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	BSTR &bsLocale)
{
	bool status = true;

	// Initialize the number of consumed characters
	*pchEaten = 0;

	// The first character should be '[' - if not we are done
	if (0 == _wcsnicmp (lpszInputString, WBEMS_LEFT_SQBRK, wcslen (WBEMS_LEFT_SQBRK)))
	{
		status = false;

		*pchEaten += wcslen (WBEMS_LEFT_SQBRK);

		// Parse the locale setting
		SKIPWHITESPACE

		// The next string should be "locale"
		if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_LOCALE, wcslen(WBEMS_LOCALE)))
		{
			*pchEaten += wcslen (WBEMS_LOCALE);

			SKIPWHITESPACE

			// Next should be "="
			if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_EQUALS, wcslen(WBEMS_EQUALS)))
			{
				*pchEaten += wcslen (WBEMS_EQUALS);

				SKIPWHITESPACE

				// Now we should have a character not equal to "]" (i.e. must specify locale ID string)
				if (0 != _wcsnicmp (lpszInputString + *pchEaten, WBEMS_RIGHT_SQBRK, wcslen (WBEMS_RIGHT_SQBRK)))
				{
					// Consume everything up to the next space or "]"
					LPWSTR cStr = CURRENTSTR;
					ULONG lEaten = 0;	// How many characters we consume
					ULONG lLocale = 0;	// The actual length of the locale ID
					
					while (*(cStr + lEaten))
					{
						if (_istspace(*(cStr + lEaten)))
						{
							lEaten++;

							// Hit white space - now skip until we find the "]"
							SKIPWHITESPACE

							// Now we must have a "]"
							if 	(0 == _wcsnicmp 
									(cStr + lEaten, WBEMS_RIGHT_SQBRK, wcslen (WBEMS_RIGHT_SQBRK)))
							{
								// Success - we are done
								lEaten += wcslen (WBEMS_RIGHT_SQBRK);
							}

							break;
						}
						else if (0 == _wcsnicmp (cStr + lEaten, WBEMS_RIGHT_SQBRK, wcslen (WBEMS_RIGHT_SQBRK)))
						{
							// Hit closing "]" - we are done
							lEaten += wcslen (WBEMS_RIGHT_SQBRK);
							break;
						}
						else	// Consumed a locale character - keep on truckin'
						{
							lLocale++;
							lEaten++;
						}
					}

					// If we terminated correctly, save the locale setting
					if ((lEaten > 1) && (lLocale > 0))
					{
						status = true;

						LPWSTR pLocaleStr = new WCHAR [lLocale + 1];

						if (pLocaleStr)
						{
							wcsncpy (pLocaleStr, lpszInputString + *pchEaten, lLocale);
							pLocaleStr [lLocale] = NULL;
							bsLocale = SysAllocString (pLocaleStr);

							delete [] pLocaleStr;
							*pchEaten += lEaten;
						}
						else
							status = false;
					}
				}
			}
		}
	}

	if (!status)
		*pchEaten = 0;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseAuthAndImpersonLevel
//
//  DESCRIPTION:
//
//  Take an authentication/impersonlation/authority level string as described by the 
//	non-terminal authAndImpersonLevel and parse it into the authentication
//	and impersonation levels and the authority string
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	authnSpecified			Whether the Moniker specifies a non-default 
//							authn levl
//	lpeAuthLevel			The authentication level parsed. This is one of 
//							enum WbemAuthenticationLevelEnum.
//	impSpecified			Whether the Moniker specifies a non-default imp 
//							level
//	lpeImpersonLevel		The impersonation level parsed. This is one of 
//							enum WbemImpersonationLevelEnum.
//	privilegeSet			On return holds the privileges
//	bsAuthority				On retunr holds the authority string (if any)
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeAuthLevel and 
//							lpeImpersonLevel arguments have valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseAuthAndImpersonLevel (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	bool &authnSpecified,
	enum WbemAuthenticationLevelEnum *lpeAuthLevel,
	bool &impSpecified,
	enum WbemImpersonationLevelEnum *lpeImpersonLevel,
	CSWbemPrivilegeSet &privilegeSet,
	BSTR &bsAuthority)
{
	// The first character should be '{'
	if (0 != _wcsnicmp (lpszInputString, WBEMS_LEFT_CURLY, wcslen (WBEMS_LEFT_CURLY)))
		return FALSE;
	else
		*pchEaten += wcslen (WBEMS_LEFT_CURLY);

	bool	authoritySpecified = false;
	bool	privilegeSpecified = false;
	bool	done = false;
	bool	error = false;

	while (!done)
	{
		bool parsingAuthenticationLevel = false;	// Which token are we parsing?
		bool parsingPrivilegeSet = false;
		bool parsingAuthority = false;

		SKIPWHITESPACE
		
		// The next string should be one of "authenticationLevel", "impersonationLevel",
		// "authority", the privilege collection start marker "(", or the security
		// descriptor start marker "<"
		if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_LEVEL, wcslen(WBEMS_AUTH_LEVEL)))
		{
			// Error if we have already parsed this or have parsed privilege set
			if (authnSpecified || privilegeSpecified)
			{
				error = true;
				break;
			}
			else
			{
				parsingAuthenticationLevel = true;
				*pchEaten += wcslen (WBEMS_AUTH_LEVEL);
			}
		}
		else if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_LEVEL, wcslen(WBEMS_IMPERSON_LEVEL)))
		{
			// Error if we have already parsed this or have parsed privilege set
			if (impSpecified || privilegeSpecified)
			{
				error = true;
				break;
			}
			else
				*pchEaten += wcslen (WBEMS_IMPERSON_LEVEL) ;
		}
		else if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTHORITY, wcslen(WBEMS_AUTHORITY)))
		{
			// Error if we have already parsed this or have parsed privilege set
			if (authoritySpecified || privilegeSpecified)
			{
				error = true;
				break;
			}
			else
			{
				parsingAuthority = true;
				*pchEaten += wcslen (WBEMS_AUTHORITY) ;
			}
		}
		else if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_LEFT_PAREN, wcslen(WBEMS_LEFT_PAREN)))
		{
			// Error if we have already done this
			if (privilegeSpecified)
			{
				error = true;
				break;
			}
			else
			{
				parsingPrivilegeSet = true;
				*pchEaten += wcslen (WBEMS_LEFT_PAREN);
			}
		}
		else
		{
			// Unrecognized token or NULL
			error = true;
			break;
		}

		// Getting here means we have something to parse
		SKIPWHITESPACE

		if (parsingPrivilegeSet)
		{
			ULONG chEaten = 0;

			if (ParsePrivilegeSet (lpszInputString + *pchEaten, &chEaten, privilegeSet))
			{
				privilegeSpecified = true;
				*pchEaten += chEaten;

				// If the next token is "}" we are done
				if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_RIGHT_CURLY, wcslen(WBEMS_RIGHT_CURLY)))
				{
					*pchEaten += wcslen (WBEMS_RIGHT_CURLY);
					done = true;
				}
			}
			else
			{
				error = true;
				break;
			}
		}
		else
		{
			// Parsing authentication, impersonation or authority. The next character should be '='
			if(0 != _wcsnicmp(lpszInputString + *pchEaten, WBEMS_EQUALS, wcslen(WBEMS_EQUALS)))
			{
				error = true;
				break;
			}
			else
			{
				*pchEaten += wcslen (WBEMS_EQUALS);
				SKIPWHITESPACE

				if (parsingAuthenticationLevel)
				{
					if (!ParseAuthenticationLevel (lpszInputString, pchEaten, lpeAuthLevel))
					{
						error = true;
						break;
					}
					else
						authnSpecified = true;
				}
				else if (parsingAuthority)
				{
					// Get the authority string
					if (!ParseAuthority (lpszInputString, pchEaten, bsAuthority))
					{
						error = true;
						break;
					}
					else
						authoritySpecified = true;
				}
				else
				{
					// Must be parsing impersonation level
					
					if (!ParseImpersonationLevel (lpszInputString, pchEaten, lpeImpersonLevel))
					{
						error = true;
						break;
					}
					else
						impSpecified = true;
				}

				SKIPWHITESPACE
					
				// The next token should be "}" or ","
				if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_RIGHT_CURLY, wcslen(WBEMS_RIGHT_CURLY)))
				{
					*pchEaten += wcslen (WBEMS_RIGHT_CURLY);
					done = true;
				}
				else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_COMMA, wcslen(WBEMS_COMMA)))
				{
					// If we have parsed all expected tokens this is an error
					if (authnSpecified && impSpecified && authoritySpecified && privilegeSpecified)
					{
						error = true;
						break;
					}
					else
					{
						*pchEaten += wcslen (WBEMS_COMMA);
						// Loop round again for the next token
					}
				}
				else
				{
					// Unrecognized token
					error = true;
					break;
				}
			}
		}
	}

	if (error)
	{
		impSpecified = authnSpecified = false;
		*pchEaten = 0;
		return false;
	}

	return true;		// success
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseImpersonationLevel
//
//  DESCRIPTION:
//
//  Parse the string specification of an impersonation level into a
//	symbolic constant value.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	lpeImpersonLevel		The impersonation level parsed. This is one of 
//							enum WbemImpersonationLevelEnum.
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeImpersonLevel 
//							argument has valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseImpersonationLevel (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	enum WbemImpersonationLevelEnum *lpeImpersonLevel
)
{
	bool status = true;	
	
	if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_ANON, wcslen(WBEMS_IMPERSON_ANON)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelAnonymous;
		*pchEaten += wcslen (WBEMS_IMPERSON_ANON);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_IDENTIFY, wcslen(WBEMS_IMPERSON_IDENTIFY)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelIdentify;
		*pchEaten += wcslen (WBEMS_IMPERSON_IDENTIFY);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_IMPERSON, wcslen(WBEMS_IMPERSON_IMPERSON)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelImpersonate;
		*pchEaten += wcslen (WBEMS_IMPERSON_IMPERSON);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_IMPERSON_DELEGATE, wcslen(WBEMS_IMPERSON_DELEGATE)))
	{
		*lpeImpersonLevel = wbemImpersonationLevelDelegate;
		*pchEaten += wcslen (WBEMS_IMPERSON_DELEGATE);
	}
	else
		status = false;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseAuthenticationLevel
//
//  DESCRIPTION:
//
//  Parse the string specification of an authentication level into a
//	symbolic constant value.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	lpeAuthLevel			The authentication level parsed. This is one of 
//							enum WbemAuthenticationLevelEnum.
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. The lpeAuthLevel 
//							argument has valid data.
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseAuthenticationLevel (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	enum WbemAuthenticationLevelEnum *lpeAuthLevel
)
{
	bool status = true;	
	
	if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_DEFAULT, wcslen(WBEMS_AUTH_DEFAULT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelDefault;
		*pchEaten += wcslen (WBEMS_AUTH_DEFAULT);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_NONE, wcslen(WBEMS_AUTH_NONE)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelNone;
		*pchEaten += wcslen (WBEMS_AUTH_NONE);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_CONNECT, wcslen(WBEMS_AUTH_CONNECT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelConnect;
		*pchEaten += wcslen (WBEMS_AUTH_CONNECT);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_CALL, wcslen(WBEMS_AUTH_CALL)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelCall;
		*pchEaten += wcslen (WBEMS_AUTH_CALL);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_PKT_INT, wcslen(WBEMS_AUTH_PKT_INT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelPktIntegrity;
		*pchEaten += wcslen (WBEMS_AUTH_PKT_INT);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_PKT_PRIV, wcslen(WBEMS_AUTH_PKT_PRIV)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelPktPrivacy;
		*pchEaten += wcslen (WBEMS_AUTH_PKT_PRIV);
	}
	else if(0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_AUTH_PKT, wcslen(WBEMS_AUTH_PKT)))
	{
		*lpeAuthLevel = wbemAuthenticationLevelPkt;
		*pchEaten += wcslen (WBEMS_AUTH_PKT);
	}
	else
		status = false;
	
	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParseAuthority
//
//  DESCRIPTION:
//
//  Take authority setting string as described by the non-terminal localeSetting 
//	and parse it.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	bsAuthority				Reference to BSTR to hold parsed authority string
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. 
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParseAuthority (
	LPWSTR lpszInputString, 
	ULONG* pchEaten, 
	BSTR &bsAuthority)
{
	bool status = false;

	// Now we should have a character not equal to "," or "}" (i.e. must specify authority string)
	if ((0 != _wcsnicmp (lpszInputString + *pchEaten, WBEMS_COMMA, wcslen (WBEMS_COMMA))) &&
		(0 != _wcsnicmp (lpszInputString + *pchEaten, WBEMS_RIGHT_CURLY, wcslen (WBEMS_RIGHT_CURLY))))
	{
		// Consume everything up to the next space, "," or "]"
		LPWSTR cStr = CURRENTSTR;
		ULONG lEaten = 0;		// Number of characters consumed
		ULONG lAuthority = 0;	// Actual length of the authority string
		
		while (*(cStr + lEaten))
		{
			if (_istspace(*(cStr + lEaten)))
			{
				// Hit white space - stop now
				break;
			}
			else if ((0 == _wcsnicmp (cStr + lEaten, WBEMS_RIGHT_CURLY, wcslen (WBEMS_RIGHT_CURLY))) ||
					 (0 == _wcsnicmp (cStr + lEaten, WBEMS_COMMA, wcslen (WBEMS_COMMA))))
			{
				// Hit closing "}" or "," - we are done; unpop the "}" or "," as that will be handled
				// in the calling function
				break;
			}
			else	// Keep on truckin'
			{
				lAuthority++;
				lEaten++;
			}
		}

		// If we terminated correctly, save the locale setting
		if ((lEaten > 1) && (lAuthority > 0))
		{
			status = true;

			LPWSTR pAuthorityStr = new WCHAR [lAuthority + 1];

			if (pAuthorityStr)
			{
				wcsncpy (pAuthorityStr, lpszInputString + *pchEaten, lAuthority);
				pAuthorityStr [lAuthority] = NULL;
				bsAuthority = SysAllocString (pAuthorityStr);

				delete [] pAuthorityStr;
				*pchEaten += lEaten;
			}
			else
				status = false;
		}
	}
	
	if (!status)
		*pchEaten = 0;

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::ParsePrivilegeSet
//
//  DESCRIPTION:
//
//  Parse the string specification of privilege settings.
//
//  PARAMETERS:
//
//	lpszInputString			The string to be parsed
//  pchEaten				On return identifies how much of the DN has been 
//							consumed
//	privilegeSet			The container into which the parsed privileges
//							are stored.
//
//  RETURN VALUES:
//
//  TRUE					Parsing was successful. 
//	FALSE					Parsing failed.
//
//
//***************************************************************************

bool CWbemParseDN::ParsePrivilegeSet (
	LPWSTR lpszInputString,
	ULONG *pchEaten, 
	CSWbemPrivilegeSet &privilegeSet
)
{
	// We have consumed the initial "(".  Now we are looking for
	// a list of privileges, followed by a final ")"

	bool status = true;
	ULONG chEaten = *pchEaten;		// In case we need to roll back
	bool done = false;
	bool firstPrivilege = true;

	SKIPWHITESPACE

	while (!done)
	{
		VARIANT_BOOL bEnabled = VARIANT_TRUE;

		// If not the first privilege we are expecting a ","
		if (!firstPrivilege)
		{
			if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_COMMA, wcslen(WBEMS_COMMA)))
			{
				*pchEaten += wcslen (WBEMS_COMMA);
				SKIPWHITESPACE
			}
			else
			{
				status = false;
				break;
			}
		}

		// Next token may be a "!" to indicate a disabled privilege
		if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_EXCLAMATION, wcslen(WBEMS_EXCLAMATION)))
		{
			*pchEaten += wcslen (WBEMS_EXCLAMATION);
			bEnabled = VARIANT_FALSE;
			SKIPWHITESPACE
		}

		// Next token must be a valid privilege moniker name
		WbemPrivilegeEnum	iPrivilege;

		if (CSWbemPrivilege::GetIdFromMonikerName (lpszInputString + *pchEaten, iPrivilege))
		{
			ISWbemPrivilege *pDummy = NULL;

			if (SUCCEEDED (privilegeSet.Add (iPrivilege, bEnabled, &pDummy)))
			{
				*pchEaten += wcslen (CSWbemPrivilege::GetMonikerNameFromId (iPrivilege));
				pDummy->Release ();
			}
			else
			{
				status = false;
				break;
			}
		}
		else
		{
			// Didn't recognize the privilege name
			status = false;
			break;
		}
		
		SKIPWHITESPACE

		// Finally if we meet a ")" we are truly done with no error
		if (0 == _wcsnicmp(lpszInputString + *pchEaten, WBEMS_RIGHT_PAREN, wcslen(WBEMS_RIGHT_PAREN)))
		{
			*pchEaten += wcslen (WBEMS_RIGHT_PAREN);
			done = true;
			SKIPWHITESPACE
		}

		firstPrivilege = false;
		SKIPWHITESPACE
	}

	if (!status)
	{
		// Misery - blow away any privileges we might have accrued
		*pchEaten = chEaten;
		privilegeSet.DeleteAll ();
	}

	return status;
}

//***************************************************************************
//
//  BOOLEAN CWbemParseDN::GetSecurityString
//
//  DESCRIPTION:
//
//  Take an authentication and impersonlation level and convert it into 
//	a security specifier string.
//
//  PARAMETERS:
//
//	authnSpecified		Whether a nondefault authn levl is specified.
//	authnLevel			The authentication level.
//	impSpecified		Whether a non-default imp level is specified.
//	impLevel			The impersonation level.
//	privilegeSet		Privileges
//	bsAuthority			Authority
//	
//
//  RETURN VALUES:
//		the newly created string (which the caller must free) or NULL
//
//***************************************************************************

wchar_t *CWbemParseDN::GetSecurityString (
	bool authnSpecified, 
	enum WbemAuthenticationLevelEnum authnLevel, 
	bool impSpecified, 
	enum WbemImpersonationLevelEnum impLevel,
	CSWbemPrivilegeSet &privilegeSet,
	BSTR &bsAuthority
)
{
	wchar_t *pResult = NULL;
	long lPrivilegeCount = 0;
	privilegeSet.get_Count (&lPrivilegeCount);
	ULONG lNumDisabled = privilegeSet.GetNumberOfDisabledElements ();
	PrivilegeMap privMap = privilegeSet.GetPrivilegeMap ();
	bool authoritySpecified = ((NULL != bsAuthority) && (0 < wcslen (bsAuthority)));

	// Degenerate case - no security info
	if (!authnSpecified && !impSpecified && (0 == lPrivilegeCount)
		&& !authoritySpecified)
		return NULL;

	// Must have at least these 2 tokens
	size_t len = wcslen (WBEMS_LEFT_CURLY) + wcslen (WBEMS_RIGHT_CURLY);
	
	if (authnSpecified)
	{
		len += wcslen(WBEMS_AUTH_LEVEL) + wcslen (WBEMS_EQUALS);

		switch (authnLevel)
		{
			case wbemAuthenticationLevelDefault:
				len += wcslen (WBEMS_AUTH_DEFAULT);
				break;

			case wbemAuthenticationLevelNone:
				len += wcslen (WBEMS_AUTH_NONE);
				break;

			case wbemAuthenticationLevelConnect:
				len += wcslen (WBEMS_AUTH_CONNECT);
				break;

			case wbemAuthenticationLevelCall:
				len += wcslen (WBEMS_AUTH_CALL);
				break;

			case wbemAuthenticationLevelPkt:
				len += wcslen (WBEMS_AUTH_PKT);
				break;

			case wbemAuthenticationLevelPktIntegrity:
				len += wcslen (WBEMS_AUTH_PKT_INT);
				break;

			case wbemAuthenticationLevelPktPrivacy:
				len += wcslen (WBEMS_AUTH_PKT_PRIV);
				break;

			default:
				return NULL;	// Bad level
		}

		if (impSpecified || authoritySpecified)
			len += wcslen (WBEMS_COMMA);
	}

	if (impSpecified)
	{
		len += wcslen(WBEMS_IMPERSON_LEVEL) + wcslen (WBEMS_EQUALS);

		switch (impLevel)
		{
			case wbemImpersonationLevelAnonymous:
				len += wcslen (WBEMS_IMPERSON_ANON);
				break;

			case wbemImpersonationLevelIdentify:
				len += wcslen (WBEMS_IMPERSON_IDENTIFY);
				break;

			case wbemImpersonationLevelImpersonate:
				len += wcslen (WBEMS_IMPERSON_IMPERSON);
				break;

			case wbemImpersonationLevelDelegate:
				len += wcslen (WBEMS_IMPERSON_DELEGATE);
				break;

			default:
				return NULL;	// Bad level
		}

		if (authoritySpecified)
			len += wcslen (WBEMS_COMMA);
	}

	if (authoritySpecified)
		len += wcslen(WBEMS_AUTHORITY) + wcslen (WBEMS_EQUALS) + wcslen (bsAuthority);

	if (0 < lPrivilegeCount)
	{
		// If imp, authn or authority also specified, we need another separator
		if (authnSpecified || impSpecified || authoritySpecified)
			len += wcslen (WBEMS_COMMA);

		// Need these boundary tokens
		len += wcslen (WBEMS_LEFT_PAREN) + wcslen (WBEMS_RIGHT_PAREN);

		// Need a separator between each privilege
		if (1 < lPrivilegeCount)
			len += (lPrivilegeCount - 1) * wcslen (WBEMS_COMMA);

		// Need to specify false values with "!"
		if (lNumDisabled)
			len += lNumDisabled * wcslen (WBEMS_EXCLAMATION);

		// Now add the privilege strings
		PrivilegeMap::iterator next = privMap.begin ();

		while (next != privMap.end ())
		{
			OLECHAR *sMonikerName = CSWbemPrivilege::GetMonikerNameFromId ((*next).first);
			
			if (sMonikerName)
				len += wcslen (sMonikerName);

			next++;
		}
	}

	pResult = new wchar_t [len + 1];

	if (pResult)
	{
		// Now build the string
		wcscpy (pResult, WBEMS_LEFT_CURLY);
		
		if (authnSpecified)
		{
			wcscat (pResult, WBEMS_AUTH_LEVEL);
			wcscat (pResult, WBEMS_EQUALS);

			switch (authnLevel)
			{
				case wbemAuthenticationLevelDefault:
					wcscat (pResult, WBEMS_AUTH_DEFAULT);
					break;

				case wbemAuthenticationLevelNone:
					wcscat (pResult, WBEMS_AUTH_NONE);
					break;

				case wbemAuthenticationLevelConnect:
					wcscat (pResult, WBEMS_AUTH_CONNECT);
					break;

				case wbemAuthenticationLevelCall:
					wcscat (pResult, WBEMS_AUTH_CALL);
					break;

				case wbemAuthenticationLevelPkt:
					wcscat (pResult, WBEMS_AUTH_PKT);
					break;

				case wbemAuthenticationLevelPktIntegrity:
					wcscat (pResult, WBEMS_AUTH_PKT_INT);
					break;

				case wbemAuthenticationLevelPktPrivacy:
					wcscat (pResult, WBEMS_AUTH_PKT_PRIV);
					break;
			}

			if (impSpecified || authoritySpecified || (0 < lPrivilegeCount))
				wcscat (pResult, WBEMS_COMMA);
		}

		if (impSpecified)
		{
			wcscat (pResult, WBEMS_IMPERSON_LEVEL);
			wcscat (pResult, WBEMS_EQUALS);

			switch (impLevel)
			{
				case wbemImpersonationLevelAnonymous:
					wcscat (pResult, WBEMS_IMPERSON_ANON);
					break;

				case wbemImpersonationLevelIdentify:
					wcscat (pResult, WBEMS_IMPERSON_IDENTIFY);
					break;

				case wbemImpersonationLevelImpersonate:
					wcscat (pResult, WBEMS_IMPERSON_IMPERSON);
					break;

				case wbemImpersonationLevelDelegate:
					wcscat (pResult, WBEMS_IMPERSON_DELEGATE);
					break;

				default:
					return NULL;	// Bad level
			}

			if (authoritySpecified || (0 < lPrivilegeCount))
				wcscat (pResult, WBEMS_COMMA);
		}

		if (authoritySpecified)
		{
			wcscat (pResult, WBEMS_AUTHORITY);
			wcscat (pResult, WBEMS_EQUALS);
			wcscat (pResult, bsAuthority);

			if ((0 < lPrivilegeCount))
				wcscat (pResult, WBEMS_COMMA);
		}

		if (lPrivilegeCount)
		{
			wcscat (pResult, WBEMS_LEFT_PAREN);
			
			// Now add the privilege strings
			PrivilegeMap::iterator next = privMap.begin ();
			bool firstPrivilege = true;

			while (next != privMap.end ())
			{
				if (!firstPrivilege)
					wcscat (pResult, WBEMS_COMMA);

				firstPrivilege = false;
			
				CSWbemPrivilege *pPrivilege = (*next).second;
				VARIANT_BOOL bValue;
				if (SUCCEEDED (pPrivilege->get_IsEnabled (&bValue)) &&
							(VARIANT_FALSE == bValue))
					wcscat (pResult, WBEMS_EXCLAMATION);

				OLECHAR *sMonikerName = CSWbemPrivilege::GetMonikerNameFromId ((*next).first);
				wcscat (pResult, sMonikerName);

				next++;
			}

			wcscat (pResult, WBEMS_RIGHT_PAREN);
		}

		wcscat (pResult, WBEMS_RIGHT_CURLY);
		
		pResult [len] = NULL;
	}

	return pResult;
}


//***************************************************************************
//
//  BOOLEAN CWbemParseDN::GetLocaleString
//
//  DESCRIPTION:
//
//  Take a locale value and convert it into a locale specifier string.
//
//  PARAMETERS:
//
//	bsLocale		The value (if any)
//
//  RETURN VALUES:
//		the newly created string (which the caller must free) or NULL
//
//***************************************************************************

wchar_t *CWbemParseDN::GetLocaleString (
	BSTR bsLocale
)
{
	wchar_t *pResult = NULL;
	
	// Degenerate case - no locale info
	if (!bsLocale || (0 == wcslen (bsLocale)))
		return NULL;

	// Calculate length of string
	size_t len = wcslen (WBEMS_LEFT_SQBRK) + wcslen (WBEMS_LOCALE) +
			wcslen (WBEMS_EQUALS) + wcslen (bsLocale) + wcslen (WBEMS_RIGHT_SQBRK);
	
	pResult = new wchar_t [len + 1];

	if (pResult)
	{
		// Now build the string
		wcscpy (pResult, WBEMS_LEFT_SQBRK);
		wcscat (pResult, WBEMS_LOCALE);
		wcscat (pResult, WBEMS_EQUALS);
		wcscat (pResult, bsLocale);
		wcscat (pResult, WBEMS_RIGHT_SQBRK);
			
		pResult [len] = NULL;
	}

	return pResult;
}


#undef CURRENTSTR
#undef SKIPWHITESPACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\objsink.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  objsink.cpp
//
//  rogerbo  22-May-98   Created.
//
//  Defines the implementation of IWbemObjectSink
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"

DWORD CIWbemObjectSinkMethodCache::sm_dwTlsForInterfaceCache = -1;

CWbemObjectSink::CWbemObjectSink(CSWbemServices *pServices, IDispatch *pSWbemSink, IDispatch *pContext,
								 bool putOperation, BSTR bsClassName) :
				m_pServices (NULL),
				m_pUnsecuredApartment (NULL),
				m_bsNamespace (NULL),
				m_bsUser (NULL),
				m_bsPassword (NULL),
				m_bsLocale (NULL)
{
	_RD(static char *me = "CWbemObjectSink::CWbemObjectSink";)
	_RPrint(me, "Called", 0, "");

	CIWbemObjectSinkMethodCache::AddRefForThread();
	m_cRef = 0;

	m_pObjectStub = NULL;
	m_pSWbemSink = NULL;
	m_putOperation = putOperation;
	m_pContext = pContext;
	m_bsClassName = NULL;

	m_operationInProgress = TRUE;
	m_setStatusCompletedCalled = FALSE;

	if (pSWbemSink)
	{
		ISWbemPrivateSinkLocator *pSinkLocator = NULL;
		HRESULT hr = pSWbemSink->QueryInterface(IID_ISWbemPrivateSinkLocator, (PPVOID)&pSinkLocator);
		if(SUCCEEDED(hr) && pSinkLocator)
		{
			IUnknown *pUnk = NULL;
			hr = pSinkLocator->GetPrivateSink(&pUnk);
			if(SUCCEEDED(hr) && pUnk)
			{
				pUnk->QueryInterface(IID_ISWbemPrivateSink, (PPVOID)&m_pSWbemSink);
				pUnk->Release();
			}
			pSinkLocator->Release();
		}
	}

	if (bsClassName)
		m_bsClassName = SysAllocString(bsClassName);

	/*
	 * Copy the services proxy to ensure independence of security attributes
	 * from the parent CSWbemServices.
	 */
	if (pServices)
	{
		m_pServices = new CSWbemServices (pServices, NULL);

		if (m_pServices)
			m_pServices->AddRef ();

		m_pUnsecuredApartment = pServices->GetCachedUnsecuredApartment ();
	}

	if (m_pContext)
		m_pContext->AddRef();

	InterlockedIncrement(&g_cObj);
}


CWbemObjectSink::~CWbemObjectSink(void) 
{
	_RD(static char *me = "CWbemObjectSink::~CWbemObjectSink";)
	_RPrint(me, "Called", 0, "");

	CIWbemObjectSinkMethodCache::ReleaseForThread();
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pServices)
	RELEASEANDNULL(m_pUnsecuredApartment)
	RELEASEANDNULL(m_pSWbemSink)
	RELEASEANDNULL(m_pContext)
	FREEANDNULL(m_bsClassName)
	FREEANDNULL(m_bsNamespace)
	FREEANDNULL(m_bsUser)
	FREEANDNULL(m_bsPassword)
	FREEANDNULL(m_bsLocale)
}

IWbemObjectSink *CWbemObjectSink::CreateObjectSink (CWbemObjectSink **pWbemObjectSink,
													CSWbemServices *pServices, 
												    IDispatch *pSWbemSink, 
													IDispatch *pContext,
												    bool putOperation, 
													BSTR bsClassName)
{
	IWbemObjectSink *pIWbemObjectSink = NULL;
	CWbemObjectSink *pTmpSink = NULL;

	if (pSWbemSink)
	{
		pTmpSink = new CWbemObjectSink(pServices, pSWbemSink, pContext, putOperation, bsClassName);

		if (pTmpSink)
		{
			pIWbemObjectSink = pTmpSink->GetObjectStub();
			if (pIWbemObjectSink && FAILED(pTmpSink->AddObjectSink(pIWbemObjectSink)))
				pIWbemObjectSink = NULL;

			if (!pIWbemObjectSink)
			{
				delete pTmpSink;
				pTmpSink = NULL;
			}
		}
	}

	*pWbemObjectSink = pTmpSink;
	return pIWbemObjectSink;
}

void CWbemObjectSink::ReleaseTheStubIfNecessary(HRESULT hResult) {

	/*
	 * If we failed locally and SetStatus has not been called
	 * then we need to remove object from list of outstanding sinks
	 */
	if (FAILED(hResult) && !m_setStatusCompletedCalled)
		RemoveObjectSink();

	/* 
	 * SetStatus can be called whilst we were in the async op.
	 * if this happens then SetStatus will not release the sink
	 * but will set a flag (m_setStatusCompletedCalled).  In this
	 * case we will need to release the stub here (the call has completed)
	 * Of course we could have also failed locally (regardless of whether 
	 * SetStatus has been called or not) - in this case we must also 
	 * release the stub.
	 */
	if (m_pObjectStub && (FAILED(hResult) || m_setStatusCompletedCalled)) {
		//  Call to release is same as (delete this !)
		IWbemObjectSink *tmpSink = m_pObjectStub;
		m_pObjectStub = NULL;
		tmpSink->Release();
	} else {
		m_operationInProgress = FALSE;
	}
}

//***************************************************************************
// HRESULT CWbemObjectSink::QueryInterface
// long CWbemObjectSink::AddRef
// long CWbemObjectSink::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemObjectSink::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemObjectSink==riid)
		*ppv = (IWbemObjectSink *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWbemObjectSink::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWbemObjectSink::Release(void)
{
	_RD(static char *me = "CWbemObjectSink::Release";)
    LONG cRef = InterlockedDecrement(&m_cRef);
	_RPrint(me, "After decrement", m_cRef, "RefCount: ");
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

#ifdef __RTEST_RPC_FAILURE
int __Rx = 0;
bool __Rdone = true;
#endif

HRESULT STDMETHODCALLTYPE CWbemObjectSink::Indicate( 
	/* [in] */ long lObjectCount,
	/* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray)
{
	_RD(static char *me = "CWbemObjectSink::Indicate";)
	_RPrint(me, "Called", 0, "");

	// See if we need to cache this method call if we are already in another
	// IWbemObjectSink interface method
	CIWbemObjectSinkMethodCache *pSinkMethodCache = CIWbemObjectSinkMethodCache::GetThreadsCache();
	
	if(pSinkMethodCache && !pSinkMethodCache->TestOkToRunIndicate(this, lObjectCount, apObjArray))
	{
		_RPrint(me, ">>>Re-entrant Indicate call", 0, "");
		return S_OK;
	}

	//------------------------------
	// walk though the classObjects...
	for (int i = 0; i < lObjectCount; i++)
	{
#ifdef __RTEST_RPC_FAILURE
		__Rx++;
#endif
		/*
		 * NB: Although the CSWbemObject constructor has AddRef'd the
		 * apObjArray[i] above, we do not balance this with a Release call
		 * before leaving this function.  According to CIMOM documentation
		 * this is correct behavior if it cannot be gauranteed that the 
		 * objects will not be used after this call has returned.
		 *
		 * Also it appears the case that when calling into the OnObjectReady
		 * function, the ISWbemObject should have a RefCount of 0 to be
		 * garbage collected properly.
		 */

		CSWbemObject *pObject = new CSWbemObject(m_pServices, apObjArray[i]);
		
		if (pObject)
		{
			CComPtr<IDispatch> pObjDisp;

			if (SUCCEEDED(pObject->QueryInterface(IID_IDispatch, (PPVOID)&pObjDisp)))
			{
				if (m_pSWbemSink)
					m_pSWbemSink->OnObjectReady(pObjDisp, m_pContext);

			} else {

                delete pObject;
            }
        }

	} // endfor


#ifdef __RTEST_RPC_FAILURE
	if ((__Rx >= 15) && !__Rdone)
	{
		__Rdone = true;
		return RPC_E_SERVERFAULT;
	}
#endif

	// Recall any cached interface methods if nested calls were received
	if (pSinkMethodCache)
		pSinkMethodCache->Cleanup();

	return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CWbemObjectSink::SetStatus( 
	/* [in] */ long lFlags,
	/* [in] */ HRESULT hResult,
	/* [in] */ BSTR strParam,
	/* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
{
	// See if we need to cache this method call if we are already in another
	// IWbemObjectSink interface method
	CIWbemObjectSinkMethodCache *pSinkMethodCache = CIWbemObjectSinkMethodCache::GetThreadsCache();

	if(pSinkMethodCache && !pSinkMethodCache->TestOkToRunSetStatus(this, lFlags, hResult, strParam, pObjParam))
		return S_OK;

	if (lFlags == WBEM_STATUS_COMPLETE) 
	{
		IDispatch *pCSWbemObjectDisp = NULL;
		IDispatch *pObjectPathDisp = NULL;

		if (pObjParam)
		{
			/*
			 * NB: Although the CSWbemObject constructor has AddRef'd the
			 * pObjParam above, we do not balance this with a Release call
			 * before leaving this function.  According to CIMOM documentation
			 * this is correct behavior if it cannot be gauranteed that the 
			 * objects will not be used after this call has returned.
			 * Also it appears the case that when calling into the OnObjectReady
			 * function, the ISWbemObject should have a RefCount of 0 to be
			 * garbage collected properly.
		 	 */			

			CSWbemObject *pCSWbemObject = new CSWbemObject(m_pServices, pObjParam);

			if (pCSWbemObject)
			{
				if (FAILED(pCSWbemObject->QueryInterface(IID_IDispatch, (PPVOID)&pCSWbemObjectDisp)))
				{
					delete pCSWbemObject;
					pCSWbemObjectDisp = NULL;
				}
			}
		}

		if (m_putOperation && m_pServices)
		{
			CSWbemSecurity *pSecurity = m_pServices->GetSecurityInfo ();
			ISWbemObjectPath *pObjectPath = new CSWbemObjectPath (pSecurity);

			if (pSecurity)
				pSecurity->Release ();

			if (pObjectPath)
			{
				if (SUCCEEDED(pObjectPath->QueryInterface(IID_IDispatch, (PPVOID)&pObjectPathDisp)))
				{
					pObjectPath->put_Path (m_pServices->GetPath ());

					if (m_bsClassName)
						pObjectPath->put_RelPath (m_bsClassName);
					else if (strParam)
						pObjectPath->put_RelPath (strParam);
				}
				else
				{
					delete pObjectPath;
					pObjectPathDisp = NULL;
				}
			}
		}

		RemoveObjectSink();

		// Transform the error code if need be
		if (WBEM_S_ACCESS_DENIED == hResult)
			hResult = wbemErrAccessDenied;
		else if (WBEM_S_OPERATION_CANCELLED == hResult)
			hResult = wbemErrCallCancelled;
		else if (SUCCEEDED(hResult))
			hResult = wbemNoErr;  // Ignore the other success codes for now. 

		if (m_pSWbemSink)
			m_pSWbemSink->OnCompleted((WbemErrorEnum)hResult, pCSWbemObjectDisp, pObjectPathDisp, m_pContext);

		// Release the stub but only if an op is not in progress
		// If an op is in progress, stub will be removed on exit from op
		// If op is in Progress - stash hResult for later
		if (m_pObjectStub && !m_operationInProgress) {
			IWbemObjectSink *tmpStub = m_pObjectStub;
			m_pObjectStub = NULL;
			tmpStub->Release();
		}
		else {
			m_setStatusCompletedCalled = TRUE;
		}

		if (pCSWbemObjectDisp)
			pCSWbemObjectDisp->Release();

		if (pObjectPathDisp)
			pObjectPathDisp->Release();

	} else if (lFlags & WBEM_STATUS_PROGRESS)
	{
		if (m_pSWbemSink)
			m_pSWbemSink->OnProgress(HIWORD(hResult), LOWORD(hResult), strParam, m_pContext);
	}

	// Recall any cached interface methods if nested calls were received
	if (pSinkMethodCache)
		pSinkMethodCache->Cleanup();

	return S_OK;
}

IWbemObjectSink *CWbemObjectSink::GetObjectStub()
{
	HRESULT hr = S_OK;

	if (!m_pObjectStub && m_pUnsecuredApartment)
	{
		// Create the object stub using unsecapp
		IUnknown *pSubstitute = NULL;

		// If we are called before this object has been handed out
		// we'd better protect our ref count
		bool bBumpUpRefCount = false;

		if (0 == m_cRef)
		{
			m_cRef++;
			bBumpUpRefCount = true;
		}

		if (SUCCEEDED (hr = m_pUnsecuredApartment->CreateObjectStub(this, &pSubstitute)))
		{
			// Ensure we QI for IWbemObjectSink
			hr = pSubstitute->QueryInterface (IID_IWbemObjectSink, (PPVOID) &m_pObjectStub);
			if (FAILED(hr))
				m_pObjectStub = NULL;

			// Now we're done with the returned stub
			pSubstitute->Release ();
		}

		if (bBumpUpRefCount)
			m_cRef--;
	}

	return m_pObjectStub;
}

HRESULT CWbemObjectSink::AddObjectSink(IWbemObjectSink *pSink)
{
	HRESULT hr = S_OK;

	if (m_pSWbemSink)
	{
		if(m_pServices)
		{
			CComPtr<IWbemServices> pIWbemServices;
			pIWbemServices.Attach( m_pServices->GetIWbemServices ());

			// Is AddObjectSink assuming these 2 args have been AddRef'd already??
			m_pSWbemSink->AddObjectSink(pSink, pIWbemServices);
		}
	}
	return hr;
}

void CWbemObjectSink::RemoveObjectSink()
{
	if (m_pSWbemSink)
		m_pSWbemSink->RemoveObjectSink(GetObjectStub());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\precomp.h ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  precomp.h
//
//  alanbos  04-Mar-98   Created.
//
//  Master include file.
//
//***************************************************************************

#pragma warning(disable:4786)
#include <stdio.h>
#include <tchar.h>
#include <ctype.h>
#include <objbase.h>
#include <objsafe.h>
#include <ocidl.h>
#include <memory.h>
#include <wbemidl.h>
#include <cominit.h>
#include <map>
#include <vector>
#include <atlbase.h>
#include <wmiutils.h>
#include "wbemdisp.h"
#include "disphlp.h"
#include "cwbemdsp.h"
#include "dispi.h"
#include "site.h"
#include "pxycache.h"
#include "privilege.h"
#include "security.h"
#include "locator.h"
#include "services.h"
#include "object.h"
#include "pathcrak.h"
#include "sobjpath.h"
#include "nvalue.h"
#include "qualifier.h"
#include "property.h"
#include "method.h"
#include "events.h"
#include "sink.h"
#include "util.h"
#include "enumvar.h"
#include "parsedn.h"
#include "classfac.h"
#include "contvar.h"
#include "qualvar.h"
#include "propvar.h"
#include "objobjp.h"
#include "methvar.h"
#include "error.h"
#include "datetime.h"
#include "refresher.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\pathcrak.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  PATHCRAK.CPP
//
//  alanbos  28-Mar-00   Created.
//
//  Defines the implementation of CWbemPathCracker
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CWbemPathCracker::CWbemPathCracker
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemPathCracker::CWbemPathCracker() :
		m_cRef (0),
		m_type (wbemPathTypeWmi)
{
	InterlockedIncrement(&g_cObj);	
	CreateParsers ();
}

//***************************************************************************
//
//  CWbemPathCracker::CWbemPathCracker
//
//  DESCRIPTION:
//
//  Copy Constructor
//
//***************************************************************************

CWbemPathCracker::CWbemPathCracker(CWbemPathCracker & pathCracker) :
		m_cRef (0),
		m_type (wbemPathTypeWmi)
{
	InterlockedIncrement(&g_cObj);	
	CreateParsers ();
	
	CComBSTR bsPath;
	if (pathCracker.GetPathText(bsPath, false, true))
		SetText (bsPath);
}

//***************************************************************************
//
//  CWbemPathCracker::CWbemPathCracker
//
//  DESCRIPTION:
//
//  Constructor
//
//***************************************************************************

CWbemPathCracker::CWbemPathCracker (const CComBSTR & bsPath) :
			m_pIWbemPath (NULL),
			m_cRef (0),
			m_type (wbemPathTypeWmi)
{
	InterlockedIncrement(&g_cObj);	
	CreateParsers ();
	SetText (bsPath);
}

//***************************************************************************
//
//  CWbemPathCracker::~CWbemPathCracker
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemPathCracker::~CWbemPathCracker(void)
{
	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CWbemPathCracker::QueryInterface
// long CWbemPathCracker::AddRef
// long CWbemPathCracker::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemPathCracker::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = (IUnknown*)(this);
	
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWbemPathCracker::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWbemPathCracker::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

void CWbemPathCracker::CreateParsers ()
{
	m_pIWbemPath.Release ();

	CoCreateInstance (CLSID_WbemDefPath, NULL,
					CLSCTX_INPROC_SERVER, IID_IWbemPath, (PPVOID) &m_pIWbemPath);
}

void CWbemPathCracker::SetText (const CComBSTR & bsPath, bool bForceAsNamespace)
{
	WbemPathType type = GetTypeFromText (bsPath);

	switch (type)
	{
		case wbemPathTypeWmi:
		{
			int iCreateFlags = WBEMPATH_CREATE_ACCEPT_ALL;

			// Check if we want single tokens to be interpreted as a namespace (e.g. "root")
			if (bForceAsNamespace)
				iCreateFlags |= WBEMPATH_TREAT_SINGLE_IDENT_AS_NS;

			if (m_pIWbemPath)
			{
				// The path parser should handle this, but doesn't!
				// If we have extracted this path from a V2-style reference
				// property it may be enclosed on "{" and "}". For now we strip
				// these off before parsing.

				if ((1 < bsPath.Length ()) && (L'{' == bsPath[0])
						&& (L'}' == bsPath [bsPath.Length () -1]))
				{
					// Take off the first and last characters
					CComBSTR bsPath2 (bsPath + 1);
					if(bsPath2.Length() > 0)
					{
						bsPath2 [bsPath2.Length() - 1] = NULL;
					}
					
					if (SUCCEEDED(m_pIWbemPath->SetText (iCreateFlags, bsPath2)))
						m_type = type;
				}
				else if (SUCCEEDED(m_pIWbemPath->SetText (iCreateFlags, bsPath)))
					m_type = type;
			}
		}
			break;

		case wbemPathTypeError:
			m_type = type;
			break;
	}
}

//***************************************************************************
//
//  WbemPathType CWbemPathCracker::GetTypeFromText
//
//  DESCRIPTION:
//
//  Get the path type of the supplied string
//
//  PARAMETERS:
//		bsPath		the supplied string
//
//  RETURN VALUES:
//		A WbemPathType
//
//***************************************************************************

CWbemPathCracker::WbemPathType CWbemPathCracker::GetTypeFromText (
	const CComBSTR & bsPath
)
{
	WbemPathType type = wbemPathTypeError;

	// Try parsing it as a WMI path
	CComPtr<IWbemPath> pIWbemPath;

	if (SUCCEEDED(CoCreateInstance (CLSID_WbemDefPath, NULL,
				CLSCTX_INPROC_SERVER, IID_IWbemPath, (PPVOID) &pIWbemPath)))
	{
		if (SUCCEEDED(pIWbemPath->SetText (WBEMPATH_CREATE_ACCEPT_ALL, bsPath)))
			type = wbemPathTypeWmi;
	}

	return type;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetPathText
//
//  DESCRIPTION:
//
//  Get the text of the path
//
//  PARAMETERS:
//		bsPath			the supplied string for holding the path
//		bRelativeOnly	whether we only want the relpath
//		bIncludeServer	whether to include the server
//		bNamespaceOnly	whether we only want the namespace path
//
//  RETURN VALUES:
//		true iff successful
//
//***************************************************************************
 
bool CWbemPathCracker::GetPathText (
	CComBSTR & bsPath,
	bool bRelativeOnly,
	bool bIncludeServer,
	bool bNamespaceOnly
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lFlags = 0;

				if (bIncludeServer)
					lFlags |= WBEMPATH_GET_SERVER_TOO;
				else if (bRelativeOnly)
					lFlags |= WBEMPATH_GET_RELATIVE_ONLY;
				else if (bNamespaceOnly)
					lFlags |= WBEMPATH_GET_NAMESPACE_ONLY;

				// Find out our required buffer size
				ULONG lBuflen = 0;
				m_pIWbemPath->GetText (lFlags, &lBuflen, NULL);

				if (lBuflen)
				{
					LPWSTR pszText = new wchar_t [lBuflen + 1];

					if (pszText)
					{
						pszText [lBuflen] = NULL;

						if (SUCCEEDED(m_pIWbemPath->GetText (lFlags, &lBuflen, pszText)))
						{
							if (bsPath.m_str = SysAllocString (pszText))
								result = true;
						}

						delete [] pszText;
					}
				}
				else
				{
					// No text yet
					if (bsPath.m_str = SysAllocString (L""))
						result = true;
				}
			}
		}
			break;

	}


	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::operator =
//
//  DESCRIPTION:
//
//  Assigment operator
//
//  PARAMETERS:
//		bsPath		the supplied string
//
//  RETURN VALUES:
//		A WbemPathType
//
//***************************************************************************
		
bool CWbemPathCracker::operator = (const CComBSTR & bsPath)
{
	bool result = false;

	// The parsers seem incapable of dealing with empty strings
	if (0 == bsPath.Length ())
	{
		CreateParsers ();
		result = true;
	}
	else
	{
		// Before we blat our object, check it.
		CWbemPathCracker pathCracker (bsPath);

		if (wbemPathTypeError != pathCracker.GetType ())
		{
			SetText (bsPath);
			result = true;
		}
	}

	return result;
}

const CWbemPathCracker & CWbemPathCracker::operator = (CWbemPathCracker & path)
{
	CComBSTR bsPath;

	if (path.GetPathText (bsPath, false, true))
		*this = bsPath;

	return *this;
}

bool CWbemPathCracker::operator += (const CComBSTR & bsObjectPath)
{
	return AddComponent (-1, bsObjectPath);
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetRelativePath
//
//  DESCRIPTION:
//
//  Set the relpath as a string
//
//  PARAMETERS:
//		value		new relpath
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetRelativePath( 
    const CComBSTR & bsRelPath
)
{
	bool result = false;
	
	// Parse the new path
	CWbemPathCracker pathCracker (bsRelPath);

	if (CopyServerAndNamespace (pathCracker))
	{
		*this = pathCracker;

		if (wbemPathTypeError != GetType())
			result = true;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::CopyServerAndNamespace
//
//  DESCRIPTION:
//
//  Copy the server and namespace from this path to the
//	supplied path
//
//	Note that it is assumed that the passed in path has no
//	namespace components.
//
//  PARAMETERS:
//		pIWbemPath		path into which info to be copied
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::CopyServerAndNamespace (
	CWbemPathCracker &pathCracker
)
{
	bool result = false;

	CComBSTR bsServer;

	if (GetServer (bsServer) && pathCracker.SetServer (bsServer))
	{
		pathCracker.ClearNamespace ();
		ULONG lNsCount = 0;

		if (GetNamespaceCount (lNsCount))
		{
			bool ok = true;

			for (ULONG i = 0; (i < lNsCount) && ok; i++)
			{
				// Copy over this component
				CComBSTR bsNamespace;

				ok = GetNamespaceAt (i, bsNamespace) && 
							pathCracker.SetNamespaceAt (i, bsNamespace);
			}

			result = ok;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetNamespaceAt
//
//  DESCRIPTION:
//
//  Copy the server and namespace from this path to the
//	supplied path
//
//	Note that it is assumed that the passed in path has no
//	namespace components.
//
//  PARAMETERS:
//		pIWbemPath		path into which info to be copied
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetNamespaceAt (
	ULONG iIndex,
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lBufLen = 0;
				m_pIWbemPath->GetNamespaceAt (iIndex, &lBufLen, NULL);

				wchar_t *pszText = new wchar_t [lBufLen + 1];

				if (pszText)
				{
					pszText [lBufLen] = NULL;

					if (SUCCEEDED(m_pIWbemPath->GetNamespaceAt (iIndex, &lBufLen, pszText)))
					{
						if (bsPath.m_str = SysAllocString (pszText))
							result = true;
					}

					delete [] pszText;
				}
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::SetNamespaceAt (
	ULONG iIndex,
	const CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				if (SUCCEEDED(m_pIWbemPath->SetNamespaceAt (iIndex, bsPath)))
					result = true;
			}
		}
			break;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetServer
//
//  DESCRIPTION:
//
//  Get the server name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetServer (
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lBufLen = 0;

				m_pIWbemPath->GetServer (&lBufLen, NULL);

				if (lBufLen)
				{
					wchar_t *pszText = new wchar_t [lBufLen + 1];

					if (pszText)
					{
						pszText [lBufLen] = NULL;

						if (SUCCEEDED(m_pIWbemPath->GetServer (&lBufLen, pszText)))
						{
							if (bsPath.m_str = SysAllocString (pszText))
								result = true;
						}

						delete [] pszText;
					}
				}
				else
				{
					// No server component yet
					if (bsPath.m_str = SysAllocString (L""))
						result = true;
				}
			}
		}
			break;

	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetServer
//
//  DESCRIPTION:
//
//  Set the server name as a string
//
//  PARAMETERS:
//		value		new server name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetServer( 
    const CComBSTR & bsPath
)
{
	bool result = false;
	
	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				/*
				 * The observant reader will notice we check for an empty path and
				 * transform it to a NULL. This is to defensively code against behavior
				 * in the parsers which actually treat an empty server path as NOT
				 * being equivalent to NULL. 
				 */

				if (0 < bsPath.Length())
					result = SUCCEEDED(m_pIWbemPath->SetServer (bsPath));
				else
					result = SUCCEEDED(m_pIWbemPath->SetServer (NULL));
			}
		}
			break;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::GetNamespacePath
//
//  DESCRIPTION:
//
//  Get the namespace path (excluding server) as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//		bParentOnly	whether to strip off leaf namespace
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetNamespacePath( 
            CComBSTR & bsPath,
			bool bParentOnly)
{
	bool result = false;

	// Build up the namespace value
	ULONG lNsCount = 0;

	if (GetNamespaceCount (lNsCount))
	{
		if ((bParentOnly && (1 < lNsCount)) || (!bParentOnly && (0 < lNsCount)))
		{
			// Get the full path and remove the server and objectref pieces
			CComBSTR bsNamespacePath;

			if (GetPathText (bsNamespacePath, false, false, true))
			{
				wchar_t *ptrStart = bsNamespacePath;

				if (IsClassOrInstance ())
				{
					// We have an object ref so look for the first ":"
					wchar_t *ptrEnd = wcschr (ptrStart, L':');

					if (ptrEnd)
						*ptrEnd = NULL;
				}

				// Getting here means we have just the namespace path left 
				// in ptrStart. Final step is to possibly remove the last
				// component

				if (bParentOnly)
				{
					wchar_t *ptrEnd = NULL;
					wchar_t *ptrEnd1 = wcsrchr (ptrStart, L'/');
					wchar_t *ptrEnd2 = wcsrchr (ptrStart, L'\\');

					if (ptrEnd1 && ptrEnd2)
						ptrEnd = (ptrEnd1 < ptrEnd2) ? ptrEnd2 : ptrEnd1;
					else if (!ptrEnd1 && ptrEnd2)
						ptrEnd = ptrEnd2;
					else if (ptrEnd1 && !ptrEnd2)
						ptrEnd = ptrEnd1;

					if (ptrEnd)
						*ptrEnd = NULL;
				}

				bsPath.m_str = SysAllocString (ptrStart);
				result = true;
			}
		}
		else
		{
			// Degenerate case - no namespace portion
			bsPath.m_str = SysAllocString (L"");
			result = true;
		}
	}

	return result;
}


bool CWbemPathCracker::IsClassOrInstance ()
{
	return (IsClass () || IsInstance ());
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetNamespacePath
//
//  DESCRIPTION:
//
//  Put the namespace as a string
//
//  PARAMETERS:
//		bsPath		new namespace path
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetNamespacePath (
	const CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CWbemPathCracker newPath;
				newPath.SetText (bsPath, true);

				if(wbemPathTypeError != newPath.GetType ())
				{
					// Copy the namespace info into our current path
					unsigned long lNsCount = 0;

					if (newPath.GetNamespaceCount (lNsCount))
					{
						// Scratch the old namespace part
						ClearNamespace ();

						if (0 < lNsCount)
						{
							// Fill in using the new part
							bool ok = true;

							for (ULONG i = 0; (i <lNsCount) && ok; i++) 
							{
								CComBSTR bsNs;

								if (!(newPath.GetNamespaceAt (i, bsNs)) ||
									FAILED(m_pIWbemPath->SetNamespaceAt (i, bsNs)))
									ok = false;						
							}

							if (ok)
								result = true;
						}
					}
				}
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetNamespaceCount (
	unsigned long & lCount
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				if (SUCCEEDED(m_pIWbemPath->GetNamespaceCount (&lCount)))
					result = true;
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::RemoveNamespace (
	ULONG iIndex
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				if (SUCCEEDED(m_pIWbemPath->RemoveNamespaceAt (iIndex)))
					result = true;
		}
			break;
	}

	return result;
}

void CWbemPathCracker::ClearNamespace()
{
	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				m_pIWbemPath->RemoveAllNamespaces ();
		}
			break;
	}

}

//***************************************************************************
//
//  bool CWbemPathCracker::IsClass
//
//  DESCRIPTION:
//
//  Get whether the path is to a class
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::IsClass ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONGLONG lInfo = 0;

				if (SUCCEEDED(m_pIWbemPath->GetInfo (0 /*WBEMPATH_INFO_IS_CLASS_REF*/, &lInfo)))
					result = (WBEMPATH_INFO_IS_CLASS_REF & lInfo) ? true : false;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::IsSingleton ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONGLONG lInfo = 0;

				if (SUCCEEDED(m_pIWbemPath->GetInfo (0 /*WBEMPATH_INFO_IS_SINGLETON*/, &lInfo)))
					result = (WBEMPATH_INFO_IS_SINGLETON & lInfo) ? true : false;
			}
		}
			break;
	}
					
	return result;
}
 
bool CWbemPathCracker::IsInstance ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONGLONG lInfo = 0;

				if (SUCCEEDED(m_pIWbemPath->GetInfo (0 /*WBEMPATH_INFO_IS_CLASS_REF*/, &lInfo)))
					result = (WBEMPATH_INFO_IS_INST_REF & lInfo) ? true : false;
			}
		}
			break;

	}

	return result;
}       


//***************************************************************************
//
//  bool CWbemPathCracker::SetAsClass
//
//  DESCRIPTION:
//
//  Set the path as a class path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetAsClass()
{
	return ClearKeys ();
}

//***************************************************************************
//
//  bool CWbemPathCracker::SetAsSingleton
//
//  DESCRIPTION:
//
//  Set the path as a singleton instance path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetAsSingleton()
{
	return ClearKeys (false);
}

//***************************************************************************
//
//  SCODE CWbemPathCracker::get_Class
//
//  DESCRIPTION:
//
//  Get the class name from the path
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetClass (
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lBufLen = 0;
				m_pIWbemPath->GetClassName (&lBufLen, NULL);

				if (lBufLen)
				{
					wchar_t *pszText = new wchar_t [lBufLen + 1];

					if (pszText)
					{
						pszText [lBufLen] = NULL;

						if (SUCCEEDED(m_pIWbemPath->GetClassName (&lBufLen, pszText)))
						{
							if (bsPath.m_str = SysAllocString (pszText))
								result = true;
						}
						
						delete [] pszText;
					}
				}
				else
				{
					// No class defined yet
					if (bsPath.m_str = SysAllocString (L""))
						result = true;
				}
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetComponent (
	ULONG iIndex,
	CComBSTR & bsPath
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				ULONG lScopeCount = 0;

				if (SUCCEEDED(m_pIWbemPath->GetScopeCount (&lScopeCount)))
				{
					if (-1 == iIndex)
						iIndex = lScopeCount - 1;

					if (iIndex < lScopeCount)
					{
						ULONG lBufLen = 0;
						m_pIWbemPath->GetScopeAsText (iIndex, &lBufLen, NULL);

						wchar_t *pszText = new wchar_t [lBufLen + 1];

						if (pszText)
						{
							pszText [lBufLen] = NULL;

							if (SUCCEEDED(m_pIWbemPath->GetScopeAsText (iIndex, &lBufLen, pszText)))
							{
								if (bsPath.m_str = SysAllocString (pszText))
									result = true;
							}

							delete [] pszText;	
						}
					}
				}
			}
		}
			break;
	}
			

	return result;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::SetClass
//
//  DESCRIPTION:
//
//  Set the class name in the path
//
//  PARAMETERS:
//		value		new class name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::SetClass( 
    const CComBSTR & bsClass)
{
	bool result = false;
	
	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				if (SUCCEEDED(m_pIWbemPath->SetClassName (bsClass)))
					result = true;
			}
		}
			break;
	}

	return result;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Keys
//
//  DESCRIPTION:
//
//  Get the keys collection from the path
//
//  PARAMETERS:
//		objKeys		pointer to ISWbemNamedValueSet returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetKeys(
	ISWbemNamedValueSet **objKeys
)
{
	bool result = false;

	if (objKeys)
	{
		*objKeys = NULL;
		
		CSWbemNamedValueSet *pCSWbemNamedValueSet = new CSWbemNamedValueSet (this);

		if (pCSWbemNamedValueSet)
		{
			if (SUCCEEDED(pCSWbemNamedValueSet->QueryInterface (IID_ISWbemNamedValueSet,
								(PPVOID) objKeys)))
				result = true;
			else
				delete pCSWbemNamedValueSet;
		}
	}

	return result;
}

bool CWbemPathCracker::SetKey (
	const CComBSTR & bsName,
	WbemCimtypeEnum cimType,
	VARIANT &var
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (SUCCEEDED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					&& SUCCEEDED(pIWbemPathKeyList->SetKey2 (bsName, 0, cimType, &var)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetKeyCount (
	ULONG & iCount
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;
				iCount = 0;

				if (FAILED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					|| SUCCEEDED(pIWbemPathKeyList->GetCount (&iCount)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::RemoveAllKeys ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (FAILED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					|| SUCCEEDED(pIWbemPathKeyList->RemoveAllKeys (0)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::RemoveKey (
	const CComBSTR &bsName
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (FAILED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList))
					|| SUCCEEDED(pIWbemPathKeyList->RemoveKey (bsName, 0)))
						result = true;
			}
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::GetComponentCount (
	ULONG & iCount
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
				result = SUCCEEDED(m_pIWbemPath->GetScopeCount (&iCount));
		}
			break;
	}

	return result;
}

bool CWbemPathCracker::AddComponent (
	ULONG iIndex,
	const CComBSTR & bsComponent
)
{
	bool result = false;
	ULONG lComponentCount = 0;

	if (GetComponentCount (lComponentCount))
	{
		if (-1 == iIndex)
			iIndex = lComponentCount;

		if (iIndex <= lComponentCount)
		{
			switch (GetType ())
			{
				case wbemPathTypeWmi:
				{
					if (m_pIWbemPath)
					{
						if (iIndex < lComponentCount)
						{
							// need to do an insertion - we will have to move
							// all subsequent elements up by one
							for (ULONG i = lComponentCount-1; i >= iIndex; i--)
							{
								ULONG lBufLen = 0;
								m_pIWbemPath->GetScopeAsText (iIndex, &lBufLen, NULL);

								wchar_t *pszText = new wchar_t [lBufLen + 1];

								if (pszText)
								{
									pszText [lBufLen] = NULL;

									if (SUCCEEDED(m_pIWbemPath->GetScopeAsText (i, &lBufLen, pszText)))
										m_pIWbemPath->SetScopeFromText (i + 1, pszText);

									delete [] pszText;
								}
							}

							if (SUCCEEDED(m_pIWbemPath->SetScopeFromText (iIndex, bsComponent)))
								result = true;
						}
						else
						{
							// just add it to the end
							if (SUCCEEDED(m_pIWbemPath->SetScopeFromText (iIndex, bsComponent)))
								result = true;
						}
					}
				}
					break;
			}
		}
	}

	return result;
}

bool CWbemPathCracker::SetComponent (
	ULONG iIndex,
	const CComBSTR & bsComponent
)
{
	bool result = false;
	ULONG lComponentCount = 0;

	if (GetComponentCount (lComponentCount) & (0 < lComponentCount))
	{
		if (-1 == iIndex)
			iIndex = lComponentCount - 1;

		// Is our index in range
		if (iIndex < lComponentCount)
		{
			switch (GetType ())
			{
				case wbemPathTypeWmi:
				{
					if (m_pIWbemPath)
					{
						if (SUCCEEDED(m_pIWbemPath->SetScopeFromText (iIndex, bsComponent)))
							result = true;
					}
				}
					break;
			}
		}
	}

	return result;
}

bool CWbemPathCracker::RemoveComponent (
	ULONG iIndex
)
{
	bool result = false;

	ULONG lComponentCount = 0;

	if (GetComponentCount (lComponentCount) & (0 < lComponentCount))
	{
		if (-1 == iIndex)
			iIndex = lComponentCount - 1;

		// Is our index in range
		if (iIndex < lComponentCount)
		{
			switch (GetType ())
			{
				case wbemPathTypeWmi:
				{
					if (m_pIWbemPath)
					{
						if (SUCCEEDED(m_pIWbemPath->RemoveScope (iIndex)))
							result = true;
					}
				}
					break;
			}
		}
	}

	return result;
}

bool CWbemPathCracker::RemoveAllComponents ()
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				if (SUCCEEDED(m_pIWbemPath->RemoveAllScopes ()))
					result = true;
			}
		}
			break;
	}

	return result;
}
	
//***************************************************************************
//
//  SCODE CSWbemObjectPath::GetParent
//
//  DESCRIPTION:
//
//  Get the parent path
//
//  PARAMETERS:
//		ppISWbemObjectPath	- parent path on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

bool CWbemPathCracker::GetParent( 
	CWbemPathCracker & pathCracker)
{	
	pathCracker = *this;
	
	return pathCracker.SetAsParent ();
}

bool CWbemPathCracker::SetAsParent ()
{
	bool result = false;
	
	ULONG lComponents;

	if (GetComponentCount (lComponents))
	{
		if (0 == lComponents)
		{
			// No components - do we have any Namespaces
			ULONG lNamespaces = 0;

			if (GetNamespaceCount (lNamespaces))
			{
				if (0 == lNamespaces)
				{
					// No namespace - do nothing
					result = true;
				}
				else
					result = RemoveNamespace (lNamespaces-1);
			}
		}
		else
		{
			// Remove the last component
			result = RemoveComponent (-1);
		}
	}
		
	return result;
}

//***************************************************************************
//
//  bool CWbemPathCracker::ClearKeys
//
//  DESCRIPTION:
//
//  Zap the keys from the path parser
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//
//***************************************************************************

bool CWbemPathCracker::ClearKeys (bool bTreatAsClass)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (SUCCEEDED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList)))
				{
					if (SUCCEEDED(pIWbemPathKeyList->RemoveAllKeys (0)))
					{
						if (SUCCEEDED(pIWbemPathKeyList->MakeSingleton ((bTreatAsClass) ? FALSE : TRUE)))
							result = true;
					}
				}
				else
				{
					// If no keys, we assume this is done.
					result = true;
				}
			}
		}
			break;
	}

	return result;
}
     
bool CWbemPathCracker::GetKey (
	ULONG	iIndex,
	CComBSTR &bsName,
	VARIANT	&var,
	WbemCimtypeEnum &cimType
)
{
	bool result = false;

	switch (GetType ())
	{
		case wbemPathTypeWmi:
		{
			if (m_pIWbemPath)
			{
				CComPtr<IWbemPathKeyList> pIWbemPathKeyList;

				if (SUCCEEDED(m_pIWbemPath->GetKeyList (&pIWbemPathKeyList)))
				{
					if (pIWbemPathKeyList)
					{
						ULONG lBufLen = 0;
						ULONG lCimType;
								
						pIWbemPathKeyList->GetKey2 (iIndex, 0, &lBufLen, NULL, &var, &lCimType);

						wchar_t *pszText = new wchar_t [lBufLen + 1];

						if (pszText)
						{
							pszText [lBufLen] = NULL;

							if (SUCCEEDED(pIWbemPathKeyList->GetKey2 (iIndex, 0, &lBufLen, pszText,
															&var, &lCimType)))
							{
								bsName.m_str = SysAllocString (pszText);
								cimType = (WbemCimtypeEnum) lCimType;
								result = true;
							}

							delete [] pszText;
						}
					}
				}
			}
		}
			break;
	}
	
	return result;
}
  
static bool KeyMatch (CComVariant & var1, CComVariant & var2)
{
	bool keyMatch = false;

	if (var1 == var2)
		keyMatch = true;
	else
	{
		// Check for string key values that are case-insensitive
		if ((var1.vt == var2.vt) && (VT_BSTR == var1.vt))
			keyMatch = var1.bstrVal && var2.bstrVal && 
							(0 == _wcsicmp (var1.bstrVal,
										  var2.bstrVal));
	}

	return keyMatch;
}

bool CWbemPathCracker::operator == (const CComBSTR & path)
{
	bool result = false;
	
	CWbemPathCracker otherPath (path);

	if (GetType () == otherPath.GetType ())
	{
		switch (GetType ())
		{
			case wbemPathTypeWmi:
			{
				if (IsClassOrInstance () && otherPath.IsClassOrInstance ())
				{
					// Do we have matching class names?
					CComBSTR thisClass, otherClass;

					if (GetClass (thisClass) && (otherPath.GetClass (otherClass))
							&& (0 == _wcsicmp (thisClass, otherClass)))
					{
						// Are they both singletons?
						if (IsSingleton () == otherPath.IsSingleton ())
						{
							if (IsSingleton ())
							{
								result = true;
							}
							else if (IsClass () && otherPath.IsClass ())
							{
								result = true;
							}
							else if (IsInstance () && otherPath.IsInstance ())
							{
								// Now we need to keymatch
								ULONG thisKeyCount, otherKeyCount;

								if (GetKeyCount (thisKeyCount) && otherPath.GetKeyCount (otherKeyCount)
									&& (thisKeyCount == otherKeyCount))
								{
									if (1 == thisKeyCount)
									{
										// Need to allow defaulted key names
										CComBSTR keyName, otherKeyName;
										CComVariant value, otherValue;
										WbemCimtypeEnum cimType, otherCimType;

										if (GetKey (0, keyName, value, cimType) &&
											otherPath.GetKey (0, otherKeyName, otherValue, otherCimType))
										{
											if ((0 == keyName.Length ()) || (0 == otherKeyName.Length ()) ||
												(0 == _wcsicmp (keyName, otherKeyName)))
												result = KeyMatch (value, otherValue);
										}
									}
									else
									{
										// Both non-singleton instances - have to check
										// key values are the same in some order
										bool ok = true;
																	
										for (DWORD i = 0; ok && (i < thisKeyCount); i++)
										{
											CComBSTR keyName;
											CComVariant value;
											WbemCimtypeEnum cimType;

											if (GetKey (i, keyName, value, cimType) && (0 < keyName.Length ()))
											{
												// Look for a matching key (case-insensitive)
												CComBSTR otherKeyName;
												CComVariant otherValue;
												WbemCimtypeEnum otherCimType;

												for (DWORD j = 0; ok && (j < thisKeyCount); j++)
												{
													if (otherPath.GetKey (j, otherKeyName, otherValue, otherCimType) 
															&& (0 < otherKeyName.Length ()))
													{
														if ((0 == _wcsicmp(keyName, otherKeyName)) && KeyMatch (value, otherValue))
															break;
													}
													else 
														ok = false;
												}

												if (ok && (j < thisKeyCount))
												{
													// Got a match
													continue;
												}
												else
													ok = false;
											}
											else
												ok = false;
										}

										if (ok)
											result = true;		// all keys have matched
									}
								}
							}
						}
					}
				}
			}
				break;

		}
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\pathcrak.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  pathcrak.h
//
//  alanbos  27-Mar-00   Created.
//
//  CWbemPathCracker definition
//
//***************************************************************************

#ifndef _PATHCRAK_H_
#define _PATHCRAK_H_

class CWbemPathCracker : public IUnknown
{
public:
	CWbemPathCracker (const CComBSTR & bsPath);
	CWbemPathCracker (CWbemPathCracker & path);
	CWbemPathCracker (void);
	virtual ~CWbemPathCracker (void);

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	typedef enum {
		wbemPathTypeError = 0,
		wbemPathTypeWmi,
	}	WbemPathType;

	WbemPathType	GetType ()	const 
	{
		return m_type;
	}

	bool		GetParent (CWbemPathCracker & path);	

	bool operator == (const CComBSTR & path);
	const CWbemPathCracker & operator = (CWbemPathCracker & path);

	bool operator = (const CComBSTR & path);

	// Path composition
	bool operator += (const CComBSTR & bsObjectPath);

	// Server
	bool		GetServer (CComBSTR & bsPath);
	bool		SetServer (const CComBSTR & bsPath);

	// Namespace
	bool		GetNamespacePath (CComBSTR & bsPath, bool bParentOnly = false);
	bool		SetNamespacePath (const CComBSTR & bsPath);
	bool		GetNamespaceCount (unsigned long & lCount);

	// Component
	bool		GetComponent (ULONG iIndex, CComBSTR & bsPath);
	bool		GetComponentCount (ULONG & iCount);
	bool		AddComponent (ULONG iIndex, const CComBSTR &bsComponent);
	bool		SetComponent (ULONG iIndex, const CComBSTR &bsComponent);
	bool		RemoveComponent (ULONG iIndex);
	bool		RemoveAllComponents ();

	// Keys
	bool		GetKeys(ISWbemNamedValueSet **objKeys);
	bool		GetKey (ULONG iIndex, CComBSTR & bsName, VARIANT & var, WbemCimtypeEnum &cimType);
	bool		GetKeyCount (ULONG & iCount);
	bool		SetKey (const CComBSTR & bsName, WbemCimtypeEnum cimType, VARIANT & var);
	bool		RemoveKey (const CComBSTR & bsName);
	bool		RemoveAllKeys ();

	// Class & Instance
	bool		IsClassOrInstance ();
	bool		IsClass ();
	bool		IsInstance ();
	bool		IsSingleton ();
	bool		SetAsClass ();
	bool		SetAsSingleton ();

	bool		IsRelative ();
	bool		GetPathText (CComBSTR & bsPath, bool bRelativeOnly = false,
								bool bIncludeServer = false, bool bNamespaceOnly = false);
	bool		SetRelativePath (const CComBSTR & bsPath);

	bool		GetClass (CComBSTR & bsPath);
	bool		SetClass (const CComBSTR &bsPath);


private:
	CComPtr<IWbemPath>	m_pIWbemPath;
	CComBSTR			m_bsNativePath;
	long				m_cRef;
	WbemPathType		m_type;

	void				CreateParsers ();
	void				SetText (const CComBSTR & bsPath, bool bForceAsNamespace = false);

	static WbemPathType		GetTypeFromText (const CComBSTR & bsPath);
	
	bool					CopyServerAndNamespace (CWbemPathCracker &pathCracker);

	bool					GetNamespaceAt (ULONG iIndex, CComBSTR & bsPath);
	bool					SetNamespaceAt (ULONG iIndex, const CComBSTR & bsPath);
	bool					RemoveNamespace (ULONG iIndex);
	void					ClearNamespace ();

	bool					SetAsParent ();
	bool					ClearKeys (bool bTreatAsClass = true);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\privilege.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PRIVILEGE.H
//
//  alanbos  30-Sep-98   Created.
//
//  Define Privilege classes.
//
//***************************************************************************

#ifndef _PRIVILEGE_H_
#define _PRIVILEGE_H_

using namespace std;

class CEnumPrivilegeSet;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPrivilege
//
//  DESCRIPTION:
//
//  Implements the ISWbemPrivilege interface.  
//
//***************************************************************************

class CSWbemPrivilege : public ISWbemPrivilege,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	CDispatchHelp		m_Dispatch;
	LUID				m_Luid;
	bool				m_bIsEnabled;
	WbemPrivilegeEnum	m_privilege;
	
protected:
	long            m_cRef;         //Object reference count

public:
    CSWbemPrivilege (WbemPrivilegeEnum privilege, LUID &luid, bool bIsEnabled);
	virtual ~CSWbemPrivilege (void);

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
	STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
	STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
						  lcid,
						  rgdispid);}
	STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
						pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemPrivilege methods

	HRESULT STDMETHODCALLTYPE get_IsEnabled 
	(
		/* [out] */ VARIANT_BOOL *bIsEnabled
	);

	HRESULT STDMETHODCALLTYPE put_IsEnabled
	(
		/* [in] */ VARIANT_BOOL bIsEnabled
	);

	HRESULT STDMETHODCALLTYPE get_Name 
	(
		/* [out] */ BSTR *bsName
	);

	HRESULT STDMETHODCALLTYPE get_DisplayName 
	(
		/* [out] */ BSTR *bsDisplayName
	);

	HRESULT STDMETHODCALLTYPE get_Identifier 
	(
		/* [out] */ WbemPrivilegeEnum *iPrivilege
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// CSWbemPrivilege methods
	void	GetLUID (PLUID pLuid);

	static	TCHAR	*GetNameFromId (WbemPrivilegeEnum iPrivilege);
	static	OLECHAR *GetMonikerNameFromId (WbemPrivilegeEnum iPrivilege);
	static	bool GetIdFromMonikerName (OLECHAR *name, WbemPrivilegeEnum &iPrivilege);
	static	bool GetIdFromName (BSTR bsName, WbemPrivilegeEnum &iPrivilege);
};

typedef map< WbemPrivilegeEnum,CSWbemPrivilege*,less<int>, CWbemAllocator<CSWbemPrivilege*> > PrivilegeMap;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemPrivilegeSet interface.  
//
//***************************************************************************

class CSWbemPrivilegeSet : public ISWbemPrivilegeSet,
						   public ISupportErrorInfo,
						   public IProvideClassInfo
{
friend CEnumPrivilegeSet;
friend CSWbemSecurity;

private:
	bool			m_bMutable;
	CDispatchHelp	m_Dispatch;
	PrivilegeMap	m_PrivilegeMap;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemPrivilegeSet ();
	CSWbemPrivilegeSet (const CSWbemPrivilegeSet &privSet,
						bool bMutable = true);
	CSWbemPrivilegeSet (ISWbemPrivilegeSet *pISWbemPrivilegeSet);
    virtual ~CSWbemPrivilegeSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	WbemPrivilegeEnum privilege,
        /*[out]*/	ISWbemPrivilege **ppPrivilege
    );        

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[in]*/	long *plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
		/*[in]*/	WbemPrivilegeEnum privilege,
		/*[in]*/	VARIANT_BOOL bIsEnabled,
		/*[out]*/	ISWbemPrivilege **ppPrivilege
	);

	HRESULT STDMETHODCALLTYPE Remove 
	(
		/*[in]*/	WbemPrivilegeEnum privilege
	);

	
    // CSWbemPrivilegeSet methods

    HRESULT STDMETHODCALLTYPE DeleteAll
	(
    );

	HRESULT STDMETHODCALLTYPE AddAsString
	(
		/*[in]*/	BSTR strPrivilege,
		/*[in]*/	VARIANT_BOOL bIsEnabled,
		/*[out]*/	ISWbemPrivilege **ppPrivilege
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods
	ULONG			GetNumberOfDisabledElements ();

	PrivilegeMap	&GetPrivilegeMap ()
	{
		return m_PrivilegeMap;
	}

	void			Reset (CSWbemPrivilegeSet &privSet);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for Privilege collections.  
//
//***************************************************************************

class CEnumPrivilegeSet : public IEnumVARIANT
{
private:
	long					m_cRef;
	CSWbemPrivilegeSet		*m_pPrivilegeSet;
	PrivilegeMap::iterator	m_Iterator;

public:
	CEnumPrivilegeSet (CSWbemPrivilegeSet *pPrivilegeSet);
	CEnumPrivilegeSet (CSWbemPrivilegeSet *pPrivilegeSet, 
				PrivilegeMap::iterator iterator);

	virtual ~CEnumPrivilegeSet (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\property.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  PROPERTY.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemProperty
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemProperty::CSWbemProperty
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemProperty::CSWbemProperty(
	CSWbemServices *pService,
	ISWbemInternalObject *pSWbemObject,
	BSTR name) 
{
	m_Dispatch.SetObj (this, IID_ISWbemProperty, 
					CLSID_SWbemProperty, L"SWbemProperty");
    m_cRef=1;

	m_pSWbemObject = pSWbemObject;
	m_pSWbemObject->AddRef ();
	m_pSWbemObject->GetIWbemClassObject (&m_pIWbemClassObject);

	m_pSite = new CWbemObjectSite (m_pSWbemObject);

	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_name = SysAllocString (name);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemProperty::~CSWbemProperty
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemProperty::~CSWbemProperty(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemObject)
		m_pSWbemObject->Release ();

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_pSite)
		m_pSite->Release ();

	SysFreeString (m_name);
}

//***************************************************************************
// HRESULT CSWbemProperty::QueryInterface
// long CSWbemProperty::AddRef
// long CSWbemProperty::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemProperty::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemProperty==riid)
		*ppv = (ISWbemProperty *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemProperty::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemProperty::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemProperty::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemProperty::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemProperty == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the property value
//
//  PARAMETERS:
//
//		pValue		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Value (
	VARIANT *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		VariantClear (pValue);

		if (m_pIWbemClassObject)
		{
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Get 
						(m_name, 0, &var, NULL, NULL)))
			{
				MapFromCIMOMObject(m_pSWbemServices, &var, 
									m_pSWbemObject, m_name);

				if(var.vt & VT_ARRAY)
				{
					hr = ConvertArrayRev(pValue, &var);
				}
				else
				{
					hr = VariantCopy (pValue, &var);
				}

				VariantClear(&var);
			}		
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::put_Value
//
//  DESCRIPTION:
//
//  Set the property value
//
//  PARAMETERS:
//
//		pVal		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::put_Value (
	VARIANT *pVal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	/*
	 * We can only _change_ the value, not the type.  When dealing with
	 * CIMOM interfaces 2 golden rules must be obeyed.
	 * (1) For instance-level Put's, you can specify the CIMTYPE (provided
	 *     you get it right), but can also specify 0.
	 * (2) For class-level Put's, always specify the CIMTYPE
	 */

	if (m_pIWbemClassObject)
	{
		CIMTYPE cimType = CIM_EMPTY;

		if (SUCCEEDED(hr = m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL)))
		{
			VARIANT vWMI;
			VariantInit (&vWMI);

			if (SUCCEEDED(hr = WmiVariantChangeType(vWMI, pVal, cimType)))
				hr = m_pIWbemClassObject->Put (m_name, 0, &vWMI, cimType);

			VariantClear (&vWMI);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Did we save an embedded object value?  If so make sure the
		// site is correctly set to this property.
		SetSite (pVal, m_pSWbemObject, m_name);

		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}


	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the property name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
		*pName = SysAllocString (m_name);

	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_CIMType
//
//  DESCRIPTION:
//
//  Retrieve the property base CIM type (i.e. without the array type)
//
//  PARAMETERS:
//
//		pType		holds the type on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_CIMType (
	WbemCimtypeEnum *pType
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == pType)
		return WBEM_E_INVALID_PARAMETER;

	if (m_pIWbemClassObject)
	{
		CIMTYPE cimType;
		hr = m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL);
		*pType = (WbemCimtypeEnum)(cimType & ~CIM_FLAG_ARRAY);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_IsArray
//
//  DESCRIPTION:
//
//  Retrieve whether the property is an array type
//
//  PARAMETERS:
//
//		pIsArray		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_IsArray (
	VARIANT_BOOL *pIsArray
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == pIsArray)
		return WBEM_E_INVALID_PARAMETER;

	*pIsArray = FALSE;

	if (m_pIWbemClassObject)
	{
		CIMTYPE	cimType = CIM_EMPTY;
		hr = m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL);
		*pIsArray = (0 != (cimType & CIM_FLAG_ARRAY)) 
				? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_IsLocal
//
//  DESCRIPTION:
//
//  Retrieve the property flavor
//
//  PARAMETERS:
//
//		pFlavor		holds the flavor on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_IsLocal (
	VARIANT_BOOL *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemClassObject)
		{
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Get (m_name, 0, NULL, NULL, &flavor)))
				*pValue = (WBEM_FLAVOR_ORIGIN_LOCAL == (flavor & WBEM_FLAVOR_MASK_ORIGIN)) ?
						VARIANT_TRUE : VARIANT_FALSE;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Origin
//
//  DESCRIPTION:
//
//  Retrieve the property origin
//
//  PARAMETERS:
//
//		pOrigin		holds the origin class on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Origin (
	BSTR *pOrigin
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pOrigin)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		if (m_pIWbemClassObject)
			m_pIWbemClassObject->GetPropertyOrigin (m_name, pOrigin);

		if (NULL == *pOrigin)
			*pOrigin = SysAllocString (OLESTR(""));
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemProperty::get_Qualifiers_
//
//  DESCRIPTION:
//
//  Retrieve the property qualifier set
//
//  PARAMETERS:
//
//		ppQualSet		addresses the qualifier set on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::get_Qualifiers_ (
	ISWbemQualifierSet **ppQualSet	
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQualSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppQualSet = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemQualifierSet *pQualSet = NULL;

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetPropertyQualifierSet 
										(m_name, &pQualSet)))
			{
				if (!(*ppQualSet = new CSWbemQualifierSet (pQualSet, m_pSWbemObject)))
					hr = WBEM_E_OUT_OF_MEMORY;

				pQualSet->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}



//***************************************************************************
//
//  SCODE CSWbemProperty::UpdateEmbedded
//
//  DESCRIPTION:
//
//  Given a variant representing an embedded value, set the value
//	and update the parent object.
//
//  PARAMETERS:
//
//		var		embedded value (VT_UNKNOWN)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

void CSWbemProperty::UpdateEmbedded (VARIANT &vNewVal, long index)
{
	if (m_pIWbemClassObject)
	{
		CIMTYPE cimType = CIM_EMPTY;

		if (-1 == index)
		{
			m_pIWbemClassObject->Get (m_name, 0, NULL, &cimType, NULL);
			m_pIWbemClassObject->Put (m_name, 0, &vNewVal, cimType);
		}
		else
		{
			VARIANT vPropVal;
			VariantInit(&vPropVal);
							
			if (SUCCEEDED (m_pIWbemClassObject->Get (m_name, 0, &vPropVal, &cimType, NULL)) 
					&& ((VT_UNKNOWN|VT_ARRAY) == V_VT(&vPropVal)))
			{

				// Set the value into the relevant index of the property value array
				if (S_OK == SafeArrayPutElement (vPropVal.parray, &index, V_UNKNOWN(&vNewVal)))
				{
					// Set the entire property value
					m_pIWbemClassObject->Put (m_name, 0, &vPropVal, cimType);
				}
			}

			VariantClear (&vPropVal);
		}
	}
}

void CSWbemProperty::UpdateSite ()
{
	// Update the parent site if it exists
	if (m_pSite)
		m_pSite->Update ();
}


//***************************************************************************
//
//  SCODE CSWbemProperty::CPropertyDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemProperty::CPropertyDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	if ((DISPID_VALUE == dispidMember) && (DISP_E_NOTACOLLECTION == hr) && (pdispparams->cArgs > 0))
	{
		/*
		 * We are looking for calls on the default member (the Value property) which
		 * supplied an argument.  Since the Value property is of type VARIANT, this may
		 * be legal but undetectable by the standard Dispatch mechanism, because in the
		 * the case that the property happens to be an array type, it is meaningful to
		 * pass an index (the interpretation is that the index specifies an offset in
		 * the VT_ARRAY|VT_VARIANT structure that represents the property value).
		 */
			
		WbemCimtypeEnum cimtype;
		VARIANT_BOOL isArray = FALSE;
		ISWbemProperty *pProperty = NULL;

		// This tells use where to expect the array index to appear in the argument list
		UINT indexArg = (DISPATCH_PROPERTYGET & wFlags) ? 0 : 1;
		
		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemProperty, (PPVOID) &pProperty)))
		{
			if (SUCCEEDED(pProperty->get_CIMType (&cimtype)) &&
				SUCCEEDED(pProperty->get_IsArray (&isArray)) && (isArray))
			{
				// Extract the current property value
				VARIANT vPropVal;
				VariantInit(&vPropVal);
						
				if (SUCCEEDED (pProperty->get_Value (&vPropVal)) && V_ISARRAY(&vPropVal))
				{
					VARIANT indexVar;
					VariantInit (&indexVar);

					// Attempt to coerce the index argument into a value suitable for an array index
					if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[indexArg], 0, VT_I4)) 
					{
						long lArrayPropInx = V_I4(&indexVar);

						// Is this a Get? There should be one argument (the array index)
						if (DISPATCH_PROPERTYGET & wFlags)
						{
							if (1 == pdispparams->cArgs)
							{
								// We should have a VT_ARRAY|VT_VARIANT value at this point; extract the
								// VARIANT element we require

								VariantInit (pvarResult);
								hr = SafeArrayGetElement (vPropVal.parray, &lArrayPropInx, pvarResult);
							}
							else
								hr = DISP_E_BADPARAMCOUNT;
						}
						else if (DISPATCH_PROPERTYPUT & wFlags) 
						{
							if (2 == pdispparams->cArgs)
							{
								/*
								 * Try to interpret this as an array member set operation. For
								 * this the first argument passed is the new value, and the second
								 * is the array index.
								 */
							
								VARIANT vNewVal;
								VariantInit(&vNewVal);

								if (SUCCEEDED(VariantCopy(&vNewVal, &pdispparams->rgvarg[0])))
								{
									// Coerce the value if necessary (unless it's embedded)
									
									if ((wbemCimtypeObject == cimtype) ||
										(S_OK == VariantChangeType (&vNewVal, &vNewVal, 0, CimTypeToVtType (cimtype))))
									{
										// Check the index is not out of bounds and, if it is, grow
										// the array accordingly
										CheckArrayBounds (vPropVal.parray, lArrayPropInx);

										// Set the value into the relevant index of the property value array
										if (S_OK == (hr = 
											SafeArrayPutElement (vPropVal.parray, &lArrayPropInx, &vNewVal)))
										{
											// Set the entire property value
											if (SUCCEEDED (pProperty->put_Value (&vPropVal)))
											{
												hr = S_OK;
												// Upcast is OK here because m_pObj is really a (CSWbemProperty*)
												CSWbemProperty *pSProperty = (CSWbemProperty *)m_pObj;

												// Did we save an embedded object value?  If so make sure the
												// site is correctly set to this property.
												SetSite (&pdispparams->rgvarg[0], 
															pSProperty->m_pSWbemObject, pSProperty->m_name,
															lArrayPropInx);

												// Propagate the change to the owning site
												pSProperty->UpdateSite ();
											}
											else
											{
												hr = DISP_E_TYPEMISMATCH;
												if (puArgErr)
													*puArgErr = 0;
											}
										}
									}
									else
									{
										hr = DISP_E_TYPEMISMATCH;
										if (puArgErr)
											*puArgErr = 0;
									}
									
									VariantClear (&vNewVal);
								}
							}
							else 
								hr = DISP_E_BADPARAMCOUNT;
						}
					}
					else
					{
							hr = DISP_E_TYPEMISMATCH;
							if (puArgErr)
								*puArgErr = indexArg;
					}

					VariantClear (&indexVar);
				}	

				VariantClear (&vPropVal);
			}

			pProperty->Release ();
		}
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\property.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  property.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemProperty and CSWbemPropertySet definitions.
//
//***************************************************************************

#ifndef _PROPERTY_H_
#define _PROPERTY_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemProperty
//
//  DESCRIPTION:
//
//  Implements the ISWbemProperty interface.  
//
//***************************************************************************

class CSWbemProperty : public ISWbemProperty,
					   public ISupportErrorInfo,
					   public IProvideClassInfo
{
private:
	class CPropertyDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);

			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags
					)
			{
				return false;
			}
	};

friend CPropertyDispatchHelp;

	CSWbemServices*			m_pSWbemServices;
	ISWbemInternalObject*	m_pSWbemObject;
	IWbemClassObject		*m_pIWbemClassObject;
	CPropertyDispatchHelp	m_Dispatch;
	BSTR					m_name;
	CWbemSite				*m_pSite;

	HRESULT					DeleteValuesByHand (
								VARIANT & varMatchingValues,
								long iFlags,
								long iStartIndex,
								long iEndIndex 
								);

	HRESULT					AddValuesByHand (
								VARIANT & varValues,
								long iFlags, 
								long iStartIndex 
								);	

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemProperty (CSWbemServices *pService, ISWbemInternalObject *pObject, 
					BSTR name);
    ~CSWbemProperty (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemProperty methods

	HRESULT STDMETHODCALLTYPE get_Value
	(
		/*[out]*/	VARIANT *value
	);
	
	HRESULT STDMETHODCALLTYPE put_Value
	(
		/*[in]*/	VARIANT *value
	);

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	HRESULT STDMETHODCALLTYPE get_IsLocal
	(
		/*[out]*/	VARIANT_BOOL *local
	);

	HRESULT STDMETHODCALLTYPE get_Origin
	(
		/*[out]*/	BSTR *origin
	);
	
	HRESULT STDMETHODCALLTYPE get_CIMType
	(
		/*[out]*/	WbemCimtypeEnum *cimType
	);
	
	HRESULT STDMETHODCALLTYPE get_Qualifiers_
	(
		/*[out]*/	ISWbemQualifierSet **ppQualSet
	);

	HRESULT STDMETHODCALLTYPE get_IsArray
	(
		/*[out]*/	VARIANT_BOOL *pIsArray
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other Methods
	void	UpdateEmbedded (VARIANT &var, long index);
	void	UpdateSite ();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPropertySet
//
//  DESCRIPTION:
//
//  Implements the ISWbemPropertySet interface.  
//
//***************************************************************************

class CSWbemPropertySet : public ISWbemPropertySet,
						  public ISupportErrorInfo,
						  public IProvideClassInfo
{
private:
	class CPropertySetDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);
	};

	CSWbemServices*				m_pSWbemServices;
	CSWbemObject*				m_pSWbemObject;
	IWbemClassObject*			m_pIWbemClassObject;			
	CPropertySetDispatchHelp	m_Dispatch;
	CWbemSite					*m_pSite;
	bool						m_bSystemProperties;

	
protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemPropertySet (CSWbemServices *pService, CSWbemObject *pObject,
						bool bSystemProperties = false);
    ~CSWbemPropertySet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
        /*[in]*/	BSTR name,
		/*[in]*/	WbemCimtypeEnum cimType,
		/*[in]*/	VARIANT_BOOL isArray,
		/*[in]*/	long lFlags,
		/*[out]*/	ISWbemProperty **ppProperty
	);        
        
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemProperty **ppProperty
    );        

    HRESULT STDMETHODCALLTYPE Remove
	(
        /*[in]*/	BSTR Name,
		/*[in]*/	long lFlags
    );

	// ISWbemPropertySet methods

	HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
    );

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemProperty **ppProperty
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\privilege.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PRIVILEGE.CPP
//
//  alanbos  30-Sep-98   Created.
//
//  Defines the implementation of CSWbemPrivilege
//
//***************************************************************************

#include "precomp.h"

#ifndef _UNICODE
#include <mbstring.h>
#endif

typedef struct PrivilegeDef {
	WbemPrivilegeEnum	privilege;
	TCHAR				*tName;
	OLECHAR				*monikerName;
} PrivilegeDef;

#define WBEMS_MAX_NUM_PRIVILEGE	27

static PrivilegeDef s_privilegeDefMap [WBEMS_MAX_NUM_PRIVILEGE] = {
	{ wbemPrivilegeCreateToken, SE_CREATE_TOKEN_NAME, L"CreateToken" },
	{ wbemPrivilegePrimaryToken, SE_ASSIGNPRIMARYTOKEN_NAME, L"PrimaryToken" },
	{ wbemPrivilegeLockMemory, SE_LOCK_MEMORY_NAME, L"LockMemory" },
	{ wbemPrivilegeIncreaseQuota, SE_INCREASE_QUOTA_NAME, L"IncreaseQuota" },
	{ wbemPrivilegeMachineAccount, SE_MACHINE_ACCOUNT_NAME, L"MachineAccount" },
	{ wbemPrivilegeTcb, SE_TCB_NAME, L"Tcb" },
	{ wbemPrivilegeSecurity, SE_SECURITY_NAME, L"Security" },
	{ wbemPrivilegeTakeOwnership, SE_TAKE_OWNERSHIP_NAME, L"TakeOwnership" },
	{ wbemPrivilegeLoadDriver, SE_LOAD_DRIVER_NAME, L"LoadDriver" },
	{ wbemPrivilegeSystemProfile, SE_SYSTEM_PROFILE_NAME, L"SystemProfile" },
	{ wbemPrivilegeSystemtime, SE_SYSTEMTIME_NAME, L"SystemTime" },
	{ wbemPrivilegeProfileSingleProcess, SE_PROF_SINGLE_PROCESS_NAME, L"ProfileSingleProcess" },
	{ wbemPrivilegeIncreaseBasePriority, SE_INC_BASE_PRIORITY_NAME, L"IncreaseBasePriority" },
	{ wbemPrivilegeCreatePagefile, SE_CREATE_PAGEFILE_NAME, L"CreatePagefile" },
	{ wbemPrivilegeCreatePermanent, SE_CREATE_PERMANENT_NAME, L"CreatePermanent" },
	{ wbemPrivilegeBackup, SE_BACKUP_NAME, L"Backup" },
	{ wbemPrivilegeRestore, SE_RESTORE_NAME, L"Restore" },
	{ wbemPrivilegeShutdown, SE_SHUTDOWN_NAME, L"Shutdown" },
	{ wbemPrivilegeDebug, SE_DEBUG_NAME, L"Debug" },
	{ wbemPrivilegeAudit, SE_AUDIT_NAME, L"Audit" },
	{ wbemPrivilegeSystemEnvironment, SE_SYSTEM_ENVIRONMENT_NAME, L"SystemEnvironment" },
	{ wbemPrivilegeChangeNotify, SE_CHANGE_NOTIFY_NAME, L"ChangeNotify" },
	{ wbemPrivilegeRemoteShutdown, SE_REMOTE_SHUTDOWN_NAME, L"RemoteShutdown" },
	{ wbemPrivilegeUndock, SE_UNDOCK_NAME, L"Undock" },
	{ wbemPrivilegeSyncAgent, SE_SYNC_AGENT_NAME, L"SyncAgent" },
	{ wbemPrivilegeEnableDelegation, SE_ENABLE_DELEGATION_NAME, L"EnableDelegation" },
	{ wbemPrivilegeManageVolume, SE_MANAGE_VOLUME_NAME, L"ManageVolume" }
};

TCHAR *CSWbemPrivilege::GetNameFromId (WbemPrivilegeEnum iPrivilege)
{
	DWORD i = iPrivilege - 1;
	return (WBEMS_MAX_NUM_PRIVILEGE > i) ?
				s_privilegeDefMap [i].tName : NULL;
}

OLECHAR *CSWbemPrivilege::GetMonikerNameFromId (WbemPrivilegeEnum iPrivilege)
{
	DWORD i = iPrivilege - 1;
	return (WBEMS_MAX_NUM_PRIVILEGE > i) ?
				s_privilegeDefMap [i].monikerName : NULL;
}

bool CSWbemPrivilege::GetIdFromMonikerName (OLECHAR *pName, WbemPrivilegeEnum &iPrivilege)
{
	bool status = false;

	if (pName)
	{
		for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
		{
			if (0 == _wcsnicmp (pName, s_privilegeDefMap [i].monikerName,
								wcslen (s_privilegeDefMap [i].monikerName)))
			{
				// Success 
				iPrivilege = s_privilegeDefMap [i].privilege;
				status = true;
				break;
			}
		}
	}

	return status;
}

bool CSWbemPrivilege::GetIdFromName (BSTR bsName, WbemPrivilegeEnum &iPrivilege)
{
	bool status = false;

	if (bsName)
	{
#ifdef _UNICODE
		for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
		{
			if (0 == _wcsicmp (bsName, s_privilegeDefMap [i].tName))
			{
				// Success 
				iPrivilege = s_privilegeDefMap [i].privilege;
				status = true;
				break;
			}
		}
#else
		// Convert bsName to a multibyte string
		size_t mbsNameLen = wcstombs (NULL, bsName, 0);
		char *mbsName = new char [mbsNameLen + 1];

		if (mbsName)
		{
			wcstombs (mbsName, bsName, mbsNameLen);
			mbsName [mbsNameLen] = NULL;

			for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
			{
				if (0 == _mbsicmp ((unsigned char *)mbsName, (unsigned char *)(s_privilegeDefMap [i].tName)))
				{
					// Success 
					iPrivilege = s_privilegeDefMap [i].privilege;
					status = true;
					break;
				}
			}

			delete [] mbsName;
		}
#endif
	}

	return status;
}

//***************************************************************************
//
// CSWbemPrivilege::CSWbemPrivilege
//
// CONSTRUCTOR 
//
//***************************************************************************

CSWbemPrivilege::CSWbemPrivilege (
	WbemPrivilegeEnum iPrivilege,
	LUID &luid, 
	bool bIsEnabled
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilege, 
						CLSID_SWbemPrivilege, L"SWbemPrivilege");
	m_cRef=1;

	m_privilege = iPrivilege;
	m_Luid = luid;
	m_bIsEnabled = bIsEnabled;

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
// CSWbemPrivilege::~CSWbemPrivilege
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemPrivilege::~CSWbemPrivilege (void)
{
	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemPrivilege::QueryInterface
// long CSWbemPrivilege::AddRef
// long CSWbemPrivilege::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilege::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPrivilege==riid)
		*ppv = (ISWbemPrivilege *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPrivilege::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemPrivilege::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPrivilege::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilege::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPrivilege == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_Identifier
//
//  DESCRIPTION:
//
//  Retrieve the privilege identifier 
//
//  PARAMETERS:
//
//		pIsEnabled		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_Identifier (
	WbemPrivilegeEnum *pPrivilege
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pPrivilege = m_privilege;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_IsEnabled
//
//  DESCRIPTION:
//
//  Retrieve the override state
//
//  PARAMETERS:
//
//		pIsEnabled		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_IsEnabled (
	VARIANT_BOOL *pIsEnabled
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pIsEnabled)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pIsEnabled = (m_bIsEnabled) ? VARIANT_TRUE : VARIANT_FALSE;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::put_IsEnabled
//
//  DESCRIPTION:
//
//  Set the override state
//
//  PARAMETERS:
//
//		bIsEnabled		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::put_IsEnabled (
	VARIANT_BOOL bIsEnabled
)
{
	m_bIsEnabled = (bIsEnabled) ? true : false;
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the privilege name
//
//  PARAMETERS:
//
//		pName		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		TCHAR	*tName = GetNameFromId (m_privilege);

		if (tName)
		{
			// Have a valid name - now copy it to a BSTR
			
#ifdef _UNICODE
			if (*pName = SysAllocString (tName))
				hr = WBEM_S_NO_ERROR;
			else
				hr = WBEM_E_OUT_OF_MEMORY;
#else
			size_t tNameLen = strlen (tName);
			OLECHAR *nameW = new OLECHAR [tNameLen + 1];

			if (nameW)
			{
				mbstowcs (nameW, tName, tNameLen);
				nameW [tNameLen] = NULL;
				*pName = SysAllocString (nameW);
				delete [] nameW;
				hr = WBEM_S_NO_ERROR;
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
#endif
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_DisplayName
//
//  DESCRIPTION:
//
//  Retrieve the privilege display name
//
//  PARAMETERS:
//
//		pDisplayName		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_DisplayName (
	BSTR *pDisplayName
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pDisplayName)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		TCHAR	*tName = GetNameFromId (m_privilege);

		if (tName)
		{	
			CSWbemSecurity::LookupPrivilegeDisplayName (tName, pDisplayName);
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


void CSWbemPrivilege::GetLUID (PLUID pLuid)
{
	if (pLuid)
		*pLuid = m_Luid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\propset.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PROPSET.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemPropertySet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemPropertySet::CSWbemPropertySet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemPropertySet::CSWbemPropertySet(
	CSWbemServices *pService, 
	CSWbemObject *pObject,
	bool bSystemProperties) :
		m_bSystemProperties (bSystemProperties)
{
	m_Dispatch.SetObj (this, IID_ISWbemPropertySet, 
					CLSID_SWbemPropertySet, L"SWbemPropertySet");
	m_pSWbemObject = pObject;
	m_pSWbemObject->AddRef ();
	m_pIWbemClassObject = m_pSWbemObject->GetIWbemClassObject ();

	m_pSite = new CWbemObjectSite (m_pSWbemObject);

	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_cRef=1;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemPropertySet::~CSWbemPropertySet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemPropertySet::~CSWbemPropertySet()
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemObject)
		m_pSWbemObject->Release ();

	if (m_pIWbemClassObject)
	{
		m_pIWbemClassObject->EndEnumeration ();
		m_pIWbemClassObject->Release ();
	}

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_pSite)
		m_pSite->Release ();
}

//***************************************************************************
// HRESULT CSWbemPropertySet::QueryInterface
// long CSWbemPropertySet::AddRef
// long CSWbemPropertySet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPropertySet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPropertySet==riid)
		*ppv = (ISWbemPropertySet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPropertySet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemPropertySet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPropertySet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPropertySet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPropertySet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Item
//
//  DESCRIPTION:
//
//  Get a property
//
//  PARAMETERS:
//
//		bsName			The name of the property
//		lFlags			Flags
//		ppProp			On successful return addresses the ISWbemProperty
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemPropertySet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemProperty ** ppProp
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppProp)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppProp = NULL;

		if (m_pIWbemClassObject)
		{
			long flavor = 0; 

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Get (bsName, lFlags, NULL, NULL, &flavor)))
			{
				// First we check if this is a system property.

				if (((WBEM_FLAVOR_ORIGIN_SYSTEM == (flavor & WBEM_FLAVOR_MASK_ORIGIN)) && m_bSystemProperties) ||
					((WBEM_FLAVOR_ORIGIN_SYSTEM != (flavor & WBEM_FLAVOR_MASK_ORIGIN)) && !m_bSystemProperties))
				{
						if (!(*ppProp = new CSWbemProperty (m_pSWbemServices, m_pSWbemObject, bsName)))
							hr = WBEM_E_OUT_OF_MEMORY;
				}
				else
					hr = WBEM_E_NOT_FOUND;
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Add
//
//  DESCRIPTION:
//
//  Add a property.		Note that the property is created with a NULL value.
//						If a non-NULL value is required, SetValue should
//						be called on the returned ISWbemProperty.
//
//  PARAMETERS:
//
//		bsName			The name of the property
//		cimType			The CIMTYPE (only needed for new properties, o/w
//						should be CIM_EMPTY).
//		flavor			Flavor
//
//  RETURN VALUES:
//	
//		The new property (if successful)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::Add (
	BSTR bsName,
	WbemCimtypeEnum cimType,
	VARIANT_BOOL	bIsArray,
	long lFlags,
	ISWbemProperty **ppProp
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppProp) || (NULL == bsName))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppProp = NULL;

		if (m_pIWbemClassObject)
		{
			/*
			 * If we are a system property collection we 
			 * check if the name begins "__"
			 */
			if (!m_bSystemProperties || (0 == _wcsnicmp (L"__", bsName, 2)))
			{
				/*
				 * Create the property with the required cimtype and no value.
				 */

				CIMTYPE cimomType = (CIMTYPE) cimType;

				if (bIsArray)
					cimomType |= CIM_FLAG_ARRAY;

				if (SUCCEEDED(hr = m_pIWbemClassObject->Put (bsName, 0, NULL, cimomType)))
				{
					if (!(*ppProp = new CSWbemProperty (m_pSWbemServices, m_pSWbemObject, bsName)))
						hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}
	
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Remove
//
//  DESCRIPTION:
//
//  Delete a property
//
//  PARAMETERS:
//
//		bsName			The name of the property
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::Remove (
	BSTR bsName,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == bsName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		if (m_pIWbemClassObject)
			hr = m_pIWbemClassObject->Delete (bsName);

		// Translate default reset case to an error
		if (WBEM_S_RESET_TO_DEFAULT == hr)
			hr = wbemErrResetToDefault;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	if (SUCCEEDED(hr) || (wbemErrResetToDefault == hr))
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Begin an enumeration of the properties
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::BeginEnumeration ()
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	/*
	 * Note that we do not expose system properties through this
	 * API via the property set, so we supress them here.
	 */

	if (m_pIWbemClassObject)
	{
		hr = m_pIWbemClassObject->EndEnumeration ();
		hr = m_pIWbemClassObject->BeginEnumeration (m_bSystemProperties ?
						WBEM_FLAG_SYSTEM_ONLY : WBEM_FLAG_NONSYSTEM_ONLY);
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::Next
//
//  DESCRIPTION:
//
//  Get next property in enumeration
//
//  PARAMETERS:
//
//		lFlags		Flags
//		ppProp		Next property (or NULL if end of enumeration)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::Next (
	long lFlags,
	ISWbemProperty ** ppProp
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppProp)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppProp = NULL;

		if (m_pIWbemClassObject)
		{
			BSTR bsName = NULL;
			
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->Next (lFlags, &bsName, NULL, NULL, NULL)))
			{
				if (!(*ppProp = new CSWbemProperty (m_pSWbemServices, m_pSWbemObject, bsName)))
					hr = WBEM_E_OUT_OF_MEMORY;

				SysFreeString (bsName);
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CPropSetEnumVar *pEnum = new CPropSetEnumVar (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemPropertySet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		if (m_pIWbemClassObject)
		{
			if (m_bSystemProperties)
			{
				// Rats - have to enumerate
				SAFEARRAY	*pArray = NULL;

				if (WBEM_S_NO_ERROR == m_pIWbemClassObject->GetNames (NULL,
										WBEM_FLAG_SYSTEM_ONLY, NULL, &pArray))
				{
					long lUBound = 0, lLBound = 0;
					SafeArrayGetUBound (pArray, 1, &lUBound);
					SafeArrayGetLBound (pArray, 1, &lLBound);
					*plCount = lUBound - lLBound + 1;
					SafeArrayDestroy (pArray);
					hr = S_OK;
				}
			}
			else
			{
				// S'easy - just use __PROPERTY_COUNT
				VARIANT var;
				VariantInit (&var);
				BSTR propCount = SysAllocString (OLESTR("__PROPERTY_COUNT"));
				if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (propCount, 0, &var, NULL, NULL))
				{
					*plCount = var.lVal;
					hr = S_OK;
				}

				VariantClear (&var);
				SysFreeString (propCount);
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPropertySet::CPropertySetDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPropertySet::CPropertySetDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Item method) which
	 * are PUTs that supplied an argument.  These are triggered by attempts
	 * to set a value of a property (Item) in the collection.
	 * The first argument should be the new value for the item, and the second
	 * argument should be the name of the item.
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_MEMBERNOTFOUND == hr) && (2 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYPUT == wFlags))
	{
		// Looks promising - get the object to try and resolve this
		ISWbemPropertySet *pPropertySet = NULL;

		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemPropertySet, (PPVOID) &pPropertySet)))
		{
			VARIANT valueVar;
			VariantInit (&valueVar);

			if (SUCCEEDED(VariantCopy(&valueVar, &pdispparams->rgvarg[0])))
			{
				VARIANT nameVar;
				VariantInit (&nameVar);

				if (SUCCEEDED(VariantCopy(&nameVar, &pdispparams->rgvarg[1])))
				{
					// Check name is a BSTR and use it to get the item
					if (VT_BSTR == V_VT(&nameVar))
					{
						ISWbemProperty *pProperty = NULL;

						if (SUCCEEDED (pPropertySet->Item (V_BSTR(&nameVar), 0, &pProperty)))
						{
							// Try and put the value
							if (SUCCEEDED (pProperty->put_Value (&valueVar)))
								hr = S_OK;
							else
							{
								hr = DISP_E_TYPEMISMATCH;
								if (puArgErr)
									*puArgErr = 0;
							}

							pProperty->Release ();
						}
					}
					else
					{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = 1;
					}

					VariantClear (&nameVar);
				}

				VariantClear (&valueVar);
			}

			pPropertySet->Release ();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\propvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PROPVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines implementation of IEnumVARIANT for iterators of ISWbemPropertySet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CPropSetEnumVar::CPropSetEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CPropSetEnumVar::CPropSetEnumVar(CSWbemPropertySet *pPropSet,
								 ULONG initialPos)
{
	m_cRef = 0;
	m_pos = initialPos;
	m_pPropertySet = pPropSet;
	m_pPropertySet->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CPropSetEnumVar::~CPropSetEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CPropSetEnumVar::~CPropSetEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pPropertySet)
		m_pPropertySet->Release ();
}

//***************************************************************************
// HRESULT CPropSetEnumVar::QueryInterface
// long CPropSetEnumVar::AddRef
// long CPropSetEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CPropSetEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CPropSetEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CPropSetEnumVar::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//
//***************************************************************************

HRESULT CPropSetEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//
//  RETURN VALUES:
//
//  S_OK				success (all requested elements returned)
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CPropSetEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pPropertySet)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					HRESULT hRes2;
					ISWbemProperty *pProperty = NULL;
					
					if (SUCCEEDED(hRes2 = m_pPropertySet->Next (0, &pProperty)))
					{
						if (NULL == pProperty)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pProperty;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}
	
	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_OUTOFMEMORY		insufficient memory to complete operation
//
//***************************************************************************

HRESULT CPropSetEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pPropertySet)
		{
			CPropSetEnumVar *pEnum = new CPropSetEnumVar (m_pPropertySet, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CPropSetEnumVar::Skip
//
//  DESCRIPTION:
//
//  Skips some elements in this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CPropSetEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pPropertySet->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}
	
//***************************************************************************
//
//  SCODE CPropSetEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CPropSetEnumVar::SeekCurrentPosition ()
{
	ISWbemProperty *pDummyObject = NULL;
	m_pPropertySet->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pPropertySet->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\pxycache.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PXYCACHE.CPP
//
//  alanbos  22-Sep-98   Created.
//
//  Defines the CSWbemProxyCache class
//
//***************************************************************************

#include "precomp.h"

// Need to try and figure out the domain
static BSTR BuildDomainUser (BSTR bsSimpleUser)
{
	BSTR bsDomainUser = NULL;
	HANDLE hToken = NULL;

	if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, TRUE, &hToken) ||
		OpenProcessToken (GetCurrentProcess (), TOKEN_READ, &hToken))
	{
		// Get the user sid
		TOKEN_USER tu;
		DWORD dwLen = 0;

		GetTokenInformation (hToken, TokenUser, &tu, sizeof(tu), &dwLen);

		if (0 < dwLen)
		{
			BYTE* pTemp = new BYTE[dwLen];

			if (pTemp)
			{
				DWORD dwRealLen = dwLen;

				if (GetTokenInformation (hToken, TokenUser, pTemp, dwRealLen, &dwLen))
				{
					PSID pSid = ((TOKEN_USER*)pTemp)->User.Sid;

					// Do the first lookup to get the buffer sizes required.
					DWORD  dwNameLen = 0;
					DWORD  dwDomainLen = 0;
					LPWSTR pUser = 0;
					LPWSTR pDomain = 0;
					SID_NAME_USE Use;

					LookupAccountSidW (NULL, pSid, pUser, &dwNameLen,
											pDomain, &dwDomainLen, &Use);

					DWORD dwLastErr = GetLastError();

					if (ERROR_INSUFFICIENT_BUFFER == dwLastErr)
					{
						// Allocate the required buffers and look them up again.
						pUser = new WCHAR [dwNameLen + 1];

						if (pUser)
						{
							pDomain = new WCHAR [dwDomainLen + wcslen (bsSimpleUser) + 2];

							if (pDomain)
							{
								if (LookupAccountSidW (NULL, pSid, pUser, &dwNameLen,
													pDomain, &dwDomainLen, &Use))
								{
									// Now get the domain out
									if (pDomain)
									{
										wcscat (pDomain, L"\\");
										wcscat (pDomain, bsSimpleUser);
										bsDomainUser = SysAllocString (pDomain);
									}
								}
								
								delete [] pDomain;
							}

							delete [] pUser;
						}
					}
    			}
				
				delete [] pTemp;
			}
		}
		
		CloseHandle(hToken);
	}

	return bsDomainUser;
}

//***************************************************************************
//
// CSWbemProxyCache::CSWbemProxyCache
//
// CONSTRUCTOR
//		Create a new proxy cache based on the supplied proxy and 
//		authentication parameters.
//
//***************************************************************************

CSWbemProxyCache::CSWbemProxyCache (
	IUnknown *pUnk,
	BSTR bsAuthority,
	BSTR bsUser,
	BSTR bsPassword,
	CWbemLocatorSecurity *pLocatorSecurity) 
{
	InitializeCriticalSection (&m_cs);
	
	EnterCriticalSection (&m_cs);

	InitializeMembers (pUnk);
	
/*
// Don't need this any more - the scenario this was fixing (see SMS Bug DB #53347) works in Whistler
// without this workaround. Also, this is causing Scripting to fail with UPN names since DetermineLoginTypeEx
// below doesn't recognize UPN user names.

	if (CSWbemSecurity::IsNT() && bsUser && (0 < wcslen (bsUser)))
	{
		// On NT make sure we have a valid domain name if one is not specified
		BSTR bsDomain = NULL;
		BSTR bsSimpleUser = NULL;
		BSTR bsPrincipalDummy = NULL;

		if (SUCCEEDED (DetermineLoginTypeEx (bsDomain, bsSimpleUser, bsPrincipalDummy,
											 bsAuthority, bsUser)))
		{
			if (!bsDomain || (0 == wcslen (bsDomain)))
				m_bsUser = BuildDomainUser (bsSimpleUser);
		}

		SysFreeString (bsPrincipalDummy);
        SysFreeString (bsSimpleUser);
		SysFreeString (bsDomain);
	}
*/

	// Unless we've already set this, do it now
	if (!m_bsUser)
		m_bsUser = SysAllocString (bsUser);

	m_bsAuthority = SysAllocString (bsAuthority);
	m_bsPassword = SysAllocString (bsPassword);

	m_bUsingExplicitUserName = m_bsUser && (0 < wcslen (m_bsUser));

	InitializeCache (pUnk, pLocatorSecurity,
			(pLocatorSecurity) && pLocatorSecurity->IsAuthenticationSet (),
			(pLocatorSecurity) && pLocatorSecurity->IsImpersonationSet ());
	
	// No longer need the credentials at this point - zap 'em
	ClearCredentials ();

	LeaveCriticalSection (&m_cs);
}

//***************************************************************************
//
// CSWbemProxyCache::CSWbemProxyCache
//
// CONSTRUCTOR
//		Create a new proxy cache based on the supplied proxy and 
//		authentication parameters.
//
//***************************************************************************

CSWbemProxyCache::CSWbemProxyCache (
	IUnknown *pUnk,
	COAUTHIDENTITY *pCoAuthIdentity,
	BSTR bsPrincipal,
	BSTR bsAuthority) 
{
	InitializeCriticalSection (&m_cs);
	
	EnterCriticalSection (&m_cs);

	InitializeMembers (pUnk);

	if (bsAuthority)
		m_bsAuthority = SysAllocString (bsAuthority);

	if (bsPrincipal)
		m_bsPrincipal = SysAllocString (bsPrincipal);

	if (pCoAuthIdentity)
		WbemAllocAuthIdentity (pCoAuthIdentity->User, pCoAuthIdentity->Password,
								pCoAuthIdentity->Domain, &m_pCoAuthIdentity);
	
	m_bUsingExplicitUserName = m_pCoAuthIdentity && m_pCoAuthIdentity->User &&
								(0 < wcslen (m_pCoAuthIdentity->User));

	InitializeCache (pUnk);
	
	LeaveCriticalSection (&m_cs);
}

CSWbemProxyCache::CSWbemProxyCache (
	IUnknown *pUnk,
	CSWbemSecurity *pSecurity) 
{
	InitializeCriticalSection (&m_cs);
	
	EnterCriticalSection (&m_cs);

	InitializeMembers (pUnk);	

	if (pSecurity)
	{
		m_pCoAuthIdentity = pSecurity->GetCoAuthIdentity ();
		m_bsPrincipal = SysAllocString (pSecurity->GetPrincipal ());
		m_bsAuthority = SysAllocString (pSecurity->GetAuthority ());
		m_bUsingExplicitUserName = pSecurity->IsUsingExplicitUserName ();
	}

	InitializeCache (pUnk, pSecurity);
	LeaveCriticalSection (&m_cs);
}

void CSWbemProxyCache::InitializeMembers (IUnknown *pUnk)
{
	m_cRef = 1;
	m_pCoAuthIdentity = NULL;
	m_bsPrincipal = NULL;
	m_bsAuthority = NULL;
	m_bsUser = NULL;
	m_bsPassword = NULL;
	m_bUsingExplicitUserName = false;
	m_bUseDefaultInfo = true; //DetermineBlanketOptions (pUnk);
}

//***************************************************************************
//
// CSWbemProxyCache::~CSWbemProxyCache
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemProxyCache::~CSWbemProxyCache ()
{
	EnterCriticalSection (&m_cs);

	ClearCredentials ();

	if (m_bsAuthority)
		SysFreeString (m_bsAuthority);

	if (m_bsPrincipal)
		SysFreeString (m_bsPrincipal);

	if (m_pCoAuthIdentity)
	{
		WbemFreeAuthIdentity (m_pCoAuthIdentity);
		m_pCoAuthIdentity = NULL;
	}

	for (int i = 0; i < WBEMS_MAX_AUTHN_LEVEL + 1 - WBEMS_MIN_AUTHN_LEVEL; i++)
		for (int j = 0; j < WBEMS_MAX_IMP_LEVEL + 1 - WBEMS_MIN_IMP_LEVEL; j++)
			if (pUnkArray [i][j])
			{
				pUnkArray [i][j] -> Release ();
				pUnkArray [i] [j] = NULL;
			}
	
	LeaveCriticalSection (&m_cs);
	DeleteCriticalSection (&m_cs);
}

//***************************************************************************
// HRESULT CSWbemProxyCache::QueryInterface
// long CSWbemProxyCache::AddRef
// long CSWbemProxyCache::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemProxyCache::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemProxyCache::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemProxyCache::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  CSWbemProxyCache::SetBlanketOptions
//
//  DESCRIPTION:
//
//  Called from constructor only to set up interaction mode with
//	SetBlanket calls.
//
//***************************************************************************

bool CSWbemProxyCache::DetermineBlanketOptions (IUnknown *pUnk)
{
	bool result = false; 

	if (CSWbemSecurity::IsNT() && (4 < CSWbemSecurity::GetNTMajorVersion ()))
	{
		HANDLE hToken = NULL;

		if (OpenThreadToken (GetCurrentThread(), TOKEN_QUERY, true, &hToken))
		{
			// Certainly a candidate to use default settings for
			// authorization and authentication service on the blanket.
			// Check if we are delegating.

			DWORD dwBytesReturned = 0;
			SECURITY_IMPERSONATION_LEVEL impLevel;

			if (GetTokenInformation(hToken, TokenImpersonationLevel, &impLevel,
							sizeof(SECURITY_IMPERSONATION_LEVEL), &dwBytesReturned) &&
									(SecurityDelegation == impLevel))
			{
				// Looks promising - now check for whether we are using kerberos
				IClientSecurity *pSec;
				DWORD dwAuthnSvc, dwAuthzSvc, dwImp, dwAuth, dwCapabilities;

				if (pUnk && SUCCEEDED(pUnk->QueryInterface(IID_IClientSecurity, (void **) &pSec)))
				{
					if (SUCCEEDED (pSec->QueryBlanket(pUnk, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            &dwAuth, &dwImp,
                                            NULL, &dwCapabilities)))
					{
						if (RPC_C_AUTHN_WINNT != dwAuthnSvc) 
							result = true;
					}

					pSec->Release ();
				}
			}

			CloseHandle (hToken);
		}

	}

	return result;
}

//***************************************************************************
//
//  CSWbemProxyCache::InitializeCache
//
//  DESCRIPTION:
//
//  Called from constructor only to set up cache and initial pUnk..
//
//  PARAMETERS:
//
//		pUnk			"seed" pUnk
//		pSecurity		if specified, is an ISWbemSecurity used to
//						override the intial authn/imp/etc. settings
//
//***************************************************************************

void CSWbemProxyCache::InitializeCache (
	IUnknown *pUnk,
	ISWbemSecurity *pSecurity,
	bool bPropagateAuthentication,
	bool bPropagateImpersonation
)
{
	for (int i = 0; i < WBEMS_MAX_AUTHN_LEVEL + 1 - WBEMS_MIN_AUTHN_LEVEL; i++)
		for (int j = 0; j < WBEMS_MAX_IMP_LEVEL + 1 - WBEMS_MIN_IMP_LEVEL; j++)
			pUnkArray [i] [j] = NULL;

	if (pUnk)
	{
		DWORD dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
		DWORD dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE; 
		
		HRESULT hr = GetAuthImp (pUnk, &dwAuthnLevel, &dwImpLevel);

        if(FAILED(hr)) 
        {
          dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
          dwImpLevel = CSWbemSecurity::GetDefaultImpersonationLevel ();
        }
        
		/*
		 * If we have been passed a "seed" Security object, use the auth/imp
		 * settings of that Seed as our initial setting.  Otherwise 
		 * use the settings supplied in the current proxy.
		 */
		if (pSecurity)
		{
			if (!bPropagateImpersonation || FAILED(pSecurity->get_ImpersonationLevel (&m_dwInitialImpLevel)))
				m_dwInitialImpLevel = (WbemImpersonationLevelEnum) dwImpLevel;
			
			if (!bPropagateAuthentication || FAILED(pSecurity->get_AuthenticationLevel (&m_dwInitialAuthnLevel)))
				m_dwInitialAuthnLevel = (WbemAuthenticationLevelEnum) dwAuthnLevel;

			/*
			 * If settings are identical, use the proxy we have but set the
			 * blanket to ensure user/password/authority are set.
			 */

			if (((WbemImpersonationLevelEnum) dwImpLevel == m_dwInitialImpLevel) &&
				((WbemAuthenticationLevelEnum) dwAuthnLevel == m_dwInitialAuthnLevel))
			{
				SecureProxy (pUnk, m_dwInitialAuthnLevel, m_dwInitialImpLevel);
				
				pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL] 
					  [m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL] = pUnk;
				pUnk->AddRef ();
			}
			else
			{
				// Need to create a new proxy
				IClientSecurity *pCliSec = NULL;

				if (S_OK == pUnk->QueryInterface (IID_IClientSecurity, (PPVOID) &pCliSec))
				{
					IUnknown *pNewUnk = NULL;

					// If successful this AddRef's pUnk
					HRESULT sc = pCliSec->CopyProxy(pUnk, &pNewUnk);

					if (S_OK == sc)
					{
						SecureProxy (pNewUnk, m_dwInitialAuthnLevel, m_dwInitialImpLevel);

						pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL] 
								[m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL] = pNewUnk;
						// NB: pNewUnk already AddRef'd above by CopyProxy
					}

					pCliSec->Release ();
				}
			}
		}
		else
		{
			m_dwInitialAuthnLevel = (WbemAuthenticationLevelEnum) dwAuthnLevel;
			m_dwInitialImpLevel = (WbemImpersonationLevelEnum) dwImpLevel;
			pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL] 
					  [m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL] = pUnk;
			pUnk->AddRef ();
		}
	}
}

//***************************************************************************
//
//  CSWbemProxyCache::GetProxy
//
//  DESCRIPTION:
//
//  Return a proxy from the cache with the desired authentication and
//	impersonation level.
//
//  PARAMETERS:
//
//		authnLevel		required authentication level
//		impLevel		required impersonation level
//		forceResecure	whether to force a resecure of an extant proxy
//
//  RETURN VALUES:
//		Pointer to copied proxy, or NULL.  If not NULL, caller must Release.
//
//***************************************************************************

IUnknown *CSWbemProxyCache::GetProxy (
	WbemAuthenticationLevelEnum authnLevel,
	WbemImpersonationLevelEnum impLevel,
	bool forceResecure)
{
	EnterCriticalSection (&m_cs);

	IUnknown *pUnk = pUnkArray [authnLevel - WBEMS_MIN_AUTHN_LEVEL] 
							   [impLevel - WBEMS_MIN_IMP_LEVEL];

	if (pUnk)
	{
		// Already cached this proxy - reuse
		pUnk->AddRef ();

		// Force a resecure? This is useful if we have just changed the 
		// privileges in the current token and need to stim RPC to pick 
		// them up.	
		if (forceResecure)
			SecureProxy (pUnk, authnLevel, impLevel);
	}
	else
	{
		// Need to create a copy of the proxy; use the first
		// created element as a base

		IUnknown *pUnkFirst = pUnkArray [m_dwInitialAuthnLevel - WBEMS_MIN_AUTHN_LEVEL]
									    [m_dwInitialImpLevel - WBEMS_MIN_IMP_LEVEL];

		if (pUnkFirst)
		{
			// Now copy the proxy
			IClientSecurity *pCliSec = NULL;

			if (S_OK == pUnkFirst->QueryInterface (IID_IClientSecurity, (PPVOID) &pCliSec))
			{
				// If successful this AddRef's pUnk
				HRESULT sc = pCliSec->CopyProxy(pUnkFirst, &pUnk);

				if (S_OK == sc)
				{
					SecureProxy (pUnk, authnLevel, impLevel);

					pUnkArray [authnLevel - WBEMS_MIN_AUTHN_LEVEL] 
							  [impLevel - WBEMS_MIN_IMP_LEVEL] = pUnk;

					// AddRef because we are handing pUnk back
					pUnk->AddRef ();
				}

				pCliSec->Release ();
			}
		}
	}

	LeaveCriticalSection (&m_cs);

	return pUnk;
}

//***************************************************************************
//
//  CSWbemProxyCache::SecureProxy
//
//  DESCRIPTION:
//
//  Secure the given proxy using the provided settings
//
//  PARAMETERS:
//
//		authnLevel		authentication level of proxy
//		impLevel		impersonation level of proxy
//
//  RETURN VALUES:
//		none
//
//***************************************************************************

void CSWbemProxyCache::SecureProxy (
	IUnknown *pUnk,
	WbemAuthenticationLevelEnum authnLevel,
	WbemImpersonationLevelEnum impLevel)
{
	/* 
	 * Due to the vagaries of the IClientSecurity::SetBlanket call,
	 * any COAUTHIDENTITY pointer passed into that call must remain
	 * valid either until SetBlanket is called again or all proxies
	 * on the object are released.  So we need to store any returned
	 * COAUTHIDENTITY so that it remains valid for the lifetime
	 * of this cache.
	 */
		
	EnterCriticalSection (&m_cs);

	if (pUnk)
	{
		/*
		 * Note that our implicit assumption is that we only ever
		 * need one COAUTHIDENTITY per cache.  This is because
		 * the ingredients of the structure (user, password and
		 * authority) are set at cache initialization time and
		 * never change thereafter.
		 */
		if (m_pCoAuthIdentity)
		{
			SetInterfaceSecurityDecrypt (pUnk, m_pCoAuthIdentity, m_bsPrincipal,
									authnLevel, impLevel, GetCapabilities (), 
									m_bUseDefaultInfo);
		}
		else
		{
			// See if we get one
			BSTR bsPrincipal = NULL;
	
			SetInterfaceSecurityEncrypt (pUnk, m_bsAuthority, m_bsUser, m_bsPassword,
					authnLevel, impLevel, GetCapabilities (),
					&m_pCoAuthIdentity, &bsPrincipal, m_bUseDefaultInfo);

			if (bsPrincipal)
			{
				if (m_bsPrincipal)
					SysFreeString (m_bsPrincipal);

				m_bsPrincipal = bsPrincipal;
			}
		}
	}

	LeaveCriticalSection (&m_cs);

	return;
}

//***************************************************************************
//
//  CSWbemProxyCache::GetCapabilities
//
//  DESCRIPTION:
//
//  Return the EOAC capabilities value depending on the OS platform and
//	user credentials (or absence thereof).
//
//  RETURN VALUES:
//
//	The determined capabilities.
//
//***************************************************************************

DWORD CSWbemProxyCache::GetCapabilities ()
{
	/*
	 * For NT5 (and presumably greater) we enable Static
	 * Cloaking on the proxy.  This allows RPC to use the
	 * Privilege settings in the Impersonation token.  
	 *
	 * Note that we use static cloaking so that thread identity
	 * is only used during CoSetProxyBlanket calls; dynamic
	 * cloaking forces it to be used on all calls to the proxy,
	 * so is much less efficient. Since we don't allow different
	 * users to access the same proxy, static cloaking is sufficient.
	 * 
	 * It makes no sense to explicitly supply a User/Password and specify
	 * cloaking, as DCOM authentication of proxy uses either 
	 * an explicit SEC_WINNT_AUTH_IDENTITY (for User & Password)
	 * or the current proxy identity (in the process token or 
	 * impersonation token).  Requesting cloaking implies that the
	 * proxy identity in the impersonation token is to be used, and
	 * therefore that any User/Password is irrelevant (and vice-versa).
	 *
	 * See MSDN documentation on CoSetProxyBlanket for more info.
	 */
	DWORD dwCapabilities = EOAC_NONE;
	
	if (CSWbemSecurity::IsNT () && (4 < CSWbemSecurity::GetNTMajorVersion ()) &&
				!m_bUsingExplicitUserName)
		dwCapabilities |= EOAC_STATIC_CLOAKING;

	return dwCapabilities ;
}

COAUTHIDENTITY *CSWbemProxyCache::GetCoAuthIdentity ()
{
	HRESULT hr = E_FAIL;
	COAUTHIDENTITY *pAuthIdent = NULL;

	if (m_pCoAuthIdentity)
		hr = WbemAllocAuthIdentity (m_pCoAuthIdentity->User, 
					m_pCoAuthIdentity->Password, m_pCoAuthIdentity->Domain, &pAuthIdent);

	return pAuthIdent;
}

void CSWbemProxyCache::ClearCredentials ()
{
	if (m_bsUser)
	{
		_wcsnset (m_bsUser, L'0', wcslen (m_bsUser));
		SysFreeString (m_bsUser);
		m_bsUser = NULL;
	}

	if (m_bsPassword)
	{
		_wcsnset (m_bsPassword, L'0', wcslen (m_bsPassword));
		SysFreeString (m_bsPassword);
		m_bsPassword = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\pxycache.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  pxycache.h
//
//  alanbos  22-Sep-98   Created.
//
//  Definition of proxy cache class
//
//***************************************************************************

#ifndef _PXYCACHE_H_
#define _PXYCACHE_H_

#define WBEMS_MAX_AUTHN_LEVEL	6
#define WBEMS_MIN_AUTHN_LEVEL	0
#define WBEMS_MAX_IMP_LEVEL		4
#define WBEMS_MIN_IMP_LEVEL		1

class CWbemLocatorSecurity;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemProxyCache
//
//  DESCRIPTION:
//
//  A proxy cache for remoted CIMOM interfaces  
//
//***************************************************************************

class CSWbemProxyCache : public IUnknown
{
private:
	long				m_cRef;  //Object reference count
	CRITICAL_SECTION	m_cs;

	// Array of proxies
	IUnknown		*pUnkArray [WBEMS_MAX_AUTHN_LEVEL + 1 - WBEMS_MIN_AUTHN_LEVEL] 
							   [WBEMS_MAX_IMP_LEVEL + 1 - WBEMS_MIN_IMP_LEVEL];

	// Security data
	COAUTHIDENTITY				*m_pCoAuthIdentity;
	BSTR						m_bsPrincipal;
	BSTR						m_bsAuthority;
	BSTR						m_bsUser;
	BSTR						m_bsPassword;
	bool						m_bUseDefaultInfo;
	bool						m_bUsingExplicitUserName;

	WbemAuthenticationLevelEnum	m_dwInitialAuthnLevel;
	WbemImpersonationLevelEnum	m_dwInitialImpLevel;

	void	InitializeCache (IUnknown *pUnk, ISWbemSecurity *pSecurity = NULL,
					bool bPropagateAuthentication = true,
					bool bPropagateImpersonation = true);

	static bool	DetermineBlanketOptions (IUnknown *pUnk);

	DWORD	GetCapabilities ();
	void	ClearCredentials ();
	void	InitializeMembers (IUnknown *pUnk);

public:

	CSWbemProxyCache (IUnknown *pUnk, BSTR bsAuthority, BSTR bsUser,
						BSTR bsPassword, CWbemLocatorSecurity *pSecurity);
	CSWbemProxyCache (IUnknown *pUnk, COAUTHIDENTITY *pCoAuthIdentity,
						BSTR bsPrincipal, BSTR bsAuthority);
	CSWbemProxyCache (IUnknown *pUnk, CSWbemSecurity *pSecurity);
	
	virtual ~CSWbemProxyCache ();

	//Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


	// Other methods
	IUnknown	*GetProxy (WbemAuthenticationLevelEnum authnLevel,
							WbemImpersonationLevelEnum impLevel,
							bool forceResecure = false);

	void	SecureProxy (IUnknown *pUnk,
							WbemAuthenticationLevelEnum authnLevel,
							WbemImpersonationLevelEnum impLevel);

	WbemAuthenticationLevelEnum	GetInitialAuthnLevel () { return m_dwInitialAuthnLevel; }
	WbemImpersonationLevelEnum	GetInitialImpLevel () { return m_dwInitialImpLevel; }

	COAUTHIDENTITY *GetCoAuthIdentity ();
	BSTR			GetAuthority () { return m_bsAuthority; }
	BSTR			GetPrincipal () { return m_bsPrincipal; }
	bool			IsUsingExplicitUserName () { return m_bUsingExplicitUserName; }

	IUnknown *GetInitialProxy ()
	{
		return GetProxy (m_dwInitialAuthnLevel, m_dwInitialImpLevel);
	}
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\propvar.h ===
//***************************************************************************
//
//  propvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CPropSetEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _PROPVAR_H_
#define _PROPVAR_H_

// This class implements the IEnumVARIANT interface

class CPropSetEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemPropertySet	*m_pPropertySet;
	ULONG				m_pos;
		
	bool			SeekCurrentPosition ();

public:
	CPropSetEnumVar (CSWbemPropertySet *pObject, ULONG initialPos = 0);
	~CPropSetEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\qualifier.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  qualifier.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemQualifier and CSWbemQualifierSet definitions.
//
//***************************************************************************

#ifndef _QUALIFIER_H_
#define _QUALIFIER_H_


//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemQualifier
//
//  DESCRIPTION:
//
//  Implements the ISWbemQualifier interface.  
//
//***************************************************************************

class CSWbemQualifier : public ISWbemQualifier,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	class CQualifierDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);

			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags
					)
			{
				return false;
			}
	};

	IWbemQualifierSet		*m_pIWbemQualifierSet;
	CQualifierDispatchHelp	m_Dispatch;
	BSTR					m_name;
	CWbemSite						*m_pSite;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemQualifier (IWbemQualifierSet *pQualSet, BSTR name,
						CWbemSite *pSite = NULL);
    ~CSWbemQualifier (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemQualifier methods

	HRESULT STDMETHODCALLTYPE get_Value
	(
		/*[out]*/	VARIANT *value
	);
	
	HRESULT STDMETHODCALLTYPE put_Value
	(
		/*[in]*/	VARIANT *value
	);

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	HRESULT STDMETHODCALLTYPE get_IsLocal
	(
		/*[out]*/	VARIANT_BOOL *local
	);

	HRESULT STDMETHODCALLTYPE get_PropagatesToSubclass
	(
		/*[out]*/	VARIANT_BOOL *value
	);
	
	HRESULT STDMETHODCALLTYPE put_PropagatesToSubclass
	(
		/*[in]*/	VARIANT_BOOL value
	);

	HRESULT STDMETHODCALLTYPE get_PropagatesToInstance
	(
		/*[out]*/	VARIANT_BOOL *value
	);
	
	HRESULT STDMETHODCALLTYPE put_PropagatesToInstance
	(
		/*[in]*/	VARIANT_BOOL value
	);

	HRESULT STDMETHODCALLTYPE get_IsOverridable
	(
		/*[out]*/	VARIANT_BOOL *value
	);
	
	HRESULT STDMETHODCALLTYPE put_IsOverridable
	(
		/*[in]*/	VARIANT_BOOL value
	);

	HRESULT STDMETHODCALLTYPE get_IsAmended
	(
		/*[out]*/	VARIANT_BOOL *value
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemQualifierSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemQualifierSet interface.  
//
//***************************************************************************

class CSWbemQualifierSet : public ISWbemQualifierSet,
						   public ISupportErrorInfo,
						   public IProvideClassInfo
{
private:
	class CQualifierSetDispatchHelp : public CDispatchHelp
	{
		public:
			HRESULT HandleError (
						DISPID dispidMember,
						unsigned short wFlags,
						DISPPARAMS FAR* pdispparams,
						VARIANT FAR* pvarResult,
						UINT FAR* puArgErr,
						HRESULT hRes
					);
	};

	IWbemQualifierSet				*m_pIWbemQualifierSet;
	CQualifierSetDispatchHelp		m_Dispatch;
	CWbemSite						*m_pSite;

protected:
	long				m_cRef;         //Object reference count

public:
    
    CSWbemQualifierSet (IWbemQualifierSet *pQualSet, 
						ISWbemInternalObject *pObject = NULL);
    ~CSWbemQualifierSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long *plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
        /*[in]*/	BSTR name,
		/*[in]*/	VARIANT *pVal,
		/*[in]*/	VARIANT_BOOL propagatesToSubclasses,
		/*[in]*/	VARIANT_BOOL propagatesToInstances,
		/*[in]*/	VARIANT_BOOL overridable,
        /*[in]*/	long lFlags,
		/*[out]*/	ISWbemQualifier **ppQualifier
	);        
        
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemQualifier **ppQualifier
    );        

    HRESULT STDMETHODCALLTYPE Remove
	(
        /*[in]*/	BSTR Name,
		/*[in]*/	long lFlags
    );

	// ISWbemQualifierSet methods

    HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
    );

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemQualifier **ppQualifier
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\qualifier.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  QUALIFIER.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemQualifier
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemQualifier::CSWbemQualifier
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemQualifier::CSWbemQualifier(IWbemQualifierSet *pIWbemQualifierSet, BSTR name,
								 CWbemSite *pSite) :
					m_pSite (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemQualifier, 
					CLSID_SWbemQualifier, L"SWbemQualifier");
    m_cRef=1;
	m_pIWbemQualifierSet = pIWbemQualifierSet;
	m_pIWbemQualifierSet->AddRef ();

	if (pSite)
	{
		m_pSite = pSite;
		m_pSite->AddRef ();
	}

	m_name = SysAllocString (name);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemQualifier::~CSWbemQualifier
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemQualifier::~CSWbemQualifier(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemQualifierSet)
		m_pIWbemQualifierSet->Release ();

	if (m_pSite)
		m_pSite->Release ();

	SysFreeString (m_name);
}

//***************************************************************************
// HRESULT CSWbemQualifier::QueryInterface
// long CSWbemQualifier::AddRef
// long CSWbemQualifier::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifier::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemQualifier==riid)
		*ppv = (ISWbemQualifier *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemQualifier::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemQualifier::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemQualifier::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifier::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemQualifier == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the qualifier value
//
//  PARAMETERS:
//
//		pValue		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_Value (
	VARIANT *pValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();
	
	if (NULL == pValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else				// Bug ID 566345
	{
		VariantClear (pValue);

		if (m_pIWbemQualifierSet)
		{
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get 
										(m_name, 0, &var, NULL)))
			{	
				if(var.vt & VT_ARRAY)
					hr = ConvertArrayRev(pValue, &var);
				else
					hr = VariantCopy (pValue, &var);
			}

			VariantClear(&var);
		}		
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_Value
//
//  DESCRIPTION:
//
//  Set the qualifier value
//
//  PARAMETERS:
//
//		pVal		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_Value (
	VARIANT *pVal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pVal)
		hr = WBEM_E_INVALID_PARAMETER;
	else			// Bug ID 566345
	{
		/*
		 * We can only change the value, not the flavor.  We have to read the
		 * flavor first to avoid changing it.
		 */
		if (m_pIWbemQualifierSet)
		{
			long flavor = 0;
			VARIANT curValue;
			VariantInit (&curValue);

			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &curValue, &flavor)))
			{
				// Mask out the origin bits from the flavor as those are read-only
				flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

				// Make sure we have a decent qualifier value to use
				if(((VT_ARRAY | VT_VARIANT) == V_VT(pVal)) ||
				   ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVal)))
				{
					VARIANT vTemp;
					VariantInit (&vTemp);

					if (S_OK == ConvertArray(&vTemp, pVal, true, curValue.vt & ~VT_ARRAY))
						hr = m_pIWbemQualifierSet->Put (m_name, &vTemp, flavor);
					
					VariantClear (&vTemp); 
				}
				else if ((VT_DISPATCH == V_VT(pVal)) || ((VT_DISPATCH|VT_BYREF) == V_VT(pVal)))
				{
					// Could be a JScript IDispatchEx array
					VARIANT vTemp;
					VariantInit (&vTemp);

					if (S_OK == ConvertDispatchToArray (&vTemp, pVal, CIM_ILLEGAL, true,
														curValue.vt & ~VT_ARRAY))
						hr = m_pIWbemQualifierSet->Put (m_name, &vTemp, flavor);

					VariantClear (&vTemp);
				}
				else
				{
					// Only certain types, I4, R8, BOOL and BSTR are acceptable qualifier
					// values.  Convert the data if need be

					VARTYPE vtOK = GetAcceptableQualType(V_VT(pVal));

					if(vtOK != V_VT(pVal))
					{
						VARIANT vTemp;
						VariantInit(&vTemp);

						if (S_OK == QualifierVariantChangeType (&vTemp, pVal, vtOK))
							hr = m_pIWbemQualifierSet->Put (m_name, &vTemp, flavor);

						VariantClear(&vTemp);
					}
					else
						hr = m_pIWbemQualifierSet->Put (m_name, pVal, flavor);
				}
			}

			VariantClear (&curValue);
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the qualifier name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;

	ResetLastErrors ();

	if (NULL != pName)
	{
		*pName = SysAllocString (m_name);
		hr = WBEM_S_NO_ERROR;
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_IsLocal
//
//  DESCRIPTION:
//
//  Determine whether the qualifier is local to this object
//
//  PARAMETERS:
//
//		pIsLocal		addresses whether the qualifier is local
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_IsLocal (
	VARIANT_BOOL *pIsLocal
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pIsLocal)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pIsLocal = (WBEM_FLAVOR_ORIGIN_LOCAL == (flavor & WBEM_FLAVOR_MASK_ORIGIN)) ?
						VARIANT_TRUE : VARIANT_FALSE;
	}
			
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_PropagatesToSubclass
//
//  DESCRIPTION:
//
//  Determine whether the qualifier can be propagated to subclasses
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_PropagatesToSubclass (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS & (flavor & WBEM_FLAVOR_MASK_PROPAGATION))
							? VARIANT_TRUE : VARIANT_FALSE;
	}
			
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_PropagatesToSubclass
//
//  DESCRIPTION:
//
//  Set the qualifier propagation to subclass
//
//  PARAMETERS:
//
//		bValue		the new propagation value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_PropagatesToSubclass (
	VARIANT_BOOL bValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	// We have to get the value so we can preserve it
	if (m_pIWbemQualifierSet)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &var, &flavor)))
		{
			// Mask out the origin bits
			flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

			// Switch on or off the subclass propagation bit
			if (bValue)
				flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
			else
				flavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

			hr = m_pIWbemQualifierSet->Put (m_name, &var, flavor);
		}

		VariantClear (&var);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_PropagatesToInstance
//
//  DESCRIPTION:
//
//  Determine whether the qualifier can be propagated to instances
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_PropagatesToInstance (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE & (flavor & WBEM_FLAVOR_MASK_PROPAGATION))
								? VARIANT_TRUE : VARIANT_FALSE;
	}
			
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_PropagatesToInstance
//
//  DESCRIPTION:
//
//  Set the qualifier propagation to subclass
//
//  PARAMETERS:
//
//		bValue		the new propagation value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_PropagatesToInstance (
	VARIANT_BOOL bValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	// We have to get the value so we can preserve it
	if (m_pIWbemQualifierSet)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &var, &flavor)))
		{
			// Mask out the origin bits
			flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

			// Switch on or off the subclass propagation bit
			if (bValue)
				flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
			else
				flavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

			hr = m_pIWbemQualifierSet->Put (m_name, &var, flavor);
		}

		VariantClear (&var);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_IsOverridable
//
//  DESCRIPTION:
//
//  Determine whether the qualifier can be overriden
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_IsOverridable (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_OVERRIDABLE == (flavor & WBEM_FLAVOR_MASK_PERMISSIONS))
								? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::put_IsOverridable
//
//  DESCRIPTION:
//
//  Set the qualifier propagation to subclass
//
//  PARAMETERS:
//
//		bValue		the new propagation value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::put_IsOverridable (
	VARIANT_BOOL bValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	// We have to get the value so we can preserve it
	if (m_pIWbemQualifierSet)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, &var, &flavor)))
		{
			// Mask out the origin bits
			flavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

			// Switch on or off the subclass propagation bit
			if (bValue)
				flavor &= ~WBEM_FLAVOR_NOT_OVERRIDABLE;
			else
				flavor |= WBEM_FLAVOR_NOT_OVERRIDABLE ;

			hr = m_pIWbemQualifierSet->Put (m_name, &var, flavor);
		}

		VariantClear (&var);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::get_IsAmended
//
//  DESCRIPTION:
//
//  Determine whether the qualifier value has been amended
//
//  PARAMETERS:
//
//		pResult		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::get_IsAmended (
	VARIANT_BOOL *pResult
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pResult)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		long flavor = 0;

		if (m_pIWbemQualifierSet)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (m_name, 0, NULL, &flavor)))
				*pResult = (WBEM_FLAVOR_AMENDED == (flavor & WBEM_FLAVOR_MASK_AMENDED))
								? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifier::CQualifierDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifier::CQualifierDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Value property) which
	 * supplied an argument.  Since the Value property is of type VARIANT, this may
	 * be legal but undetectable by the standard Dispatch mechanism, because in the
	 * the case that the qualifier happens to be an array type, it is meaningful to
	 * pass an index (the interpretation is that the index specifies an offset in
	 * the VT_ARRAY|VT_VARIANT structure that represents the property value).
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_NOTACOLLECTION == hr) && (pdispparams->cArgs > 0))
	{
		// Looks promising - get the object to try and resolve this
			
		ISWbemQualifier *pQualifier = NULL;

		// This tells use where to expect the array index to appear in the argument list
		UINT indexArg = (DISPATCH_PROPERTYGET & wFlags) ? 0 : 1;
		
		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemQualifier, (PPVOID) &pQualifier)))
		{
			// Extract the current qualifier value
			VARIANT vQualVal;
			VariantInit (&vQualVal);

			if (SUCCEEDED(pQualifier->get_Value (&vQualVal)) && V_ISARRAY(&vQualVal))
			{
				VARIANT indexVar;
				VariantInit (&indexVar);

				// Attempt to coerce the index argument into a value suitable for an array index
				if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[indexArg], 0, VT_I4)) 
				{
					long lArrayPropInx = V_I4(&indexVar);

					// Is this a Get? There should be one argument (the array index)
					if (DISPATCH_PROPERTYGET & wFlags)
					{
						if (1 == pdispparams->cArgs)
						{
							// We should have a VT_ARRAY|VT_VARIANT value at this point; extract the
							// VARIANT

							VariantInit (pvarResult);
							hr = SafeArrayGetElement (vQualVal.parray, &lArrayPropInx, pvarResult);
						}
						else
							hr = DISP_E_BADPARAMCOUNT;
					}
					else if (DISPATCH_PROPERTYPUT & wFlags) 
					{
						if (2 == pdispparams->cArgs)
						{
							/*
							 * Try to interpret this as an array member set operation. For
							 * this the first argument passed is the new value, and the second
							 * is the array index.
							 */
						
							VARIANT vNewVal;
							VariantInit(&vNewVal);
							
							if (SUCCEEDED(VariantCopy(&vNewVal, &pdispparams->rgvarg[0])))
							{
								// Coerce the value if necessary
								VARTYPE expectedVarType = GetAcceptableQualType (V_VT(&vNewVal));

								if (S_OK == VariantChangeType (&vNewVal, &vNewVal, 0, expectedVarType))
								{
									// Check the index is not out of bounds and, if it is, grow
									// the array accordingly
									CheckArrayBounds (vQualVal.parray, lArrayPropInx);

									// Set the value into the relevant index of the property value array
									if (S_OK == (hr = 
										SafeArrayPutElement (vQualVal.parray, &lArrayPropInx, &vNewVal)))
									{
										// Set the entire property value
										if (SUCCEEDED (pQualifier->put_Value (&vQualVal)))
											hr = S_OK;
										else
										{
											hr = DISP_E_TYPEMISMATCH;
											if (puArgErr)
												*puArgErr = 0;
										}
									}
								}
								else
								{
									hr = DISP_E_TYPEMISMATCH;
									if (puArgErr)
										*puArgErr = 0;
								}
								
								VariantClear (&vNewVal);
							}
						}
						else 
							hr = DISP_E_BADPARAMCOUNT;
					}
				}
				else
				{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = indexArg;
				}

				VariantClear (&indexVar);
			}	

			VariantClear (&vQualVal);
		}

		pQualifier->Release ();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\qualvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  CONTENUM.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IEnumVARIANT for iterators over ISWbemQualifierSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CQualSetEnumVar::CQualSetEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CQualSetEnumVar::CQualSetEnumVar(CSWbemQualifierSet *pQualSet,
								 ULONG initialPos)
{
	m_cRef = 0;
	m_pos = initialPos;
	m_pQualifierSet = pQualSet;
	m_pQualifierSet->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CQualSetEnumVar::~CQualSetEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CQualSetEnumVar::~CQualSetEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pQualifierSet)
		m_pQualifierSet->Release ();
}

//***************************************************************************
// HRESULT CQualSetEnumVar::QueryInterface
// long CQualSetEnumVar::AddRef
// long CQualSetEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CQualSetEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CQualSetEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CQualSetEnumVar::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//
//***************************************************************************

HRESULT CQualSetEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success (all requested elements returned)
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CQualSetEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pQualifierSet)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					HRESULT hRes2;
					ISWbemQualifier *pQualifier = NULL;
					
					if (SUCCEEDED(hRes2 = m_pQualifierSet->Next (0, &pQualifier)))
					{
						if (NULL == pQualifier)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pQualifier;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}
	
	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_OUTOFMEMORY		insufficient memory to complete operation
//
//***************************************************************************

HRESULT CQualSetEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pQualifierSet)
		{
			CQualSetEnumVar *pEnum = new CQualSetEnumVar (m_pQualifierSet, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CQualSetEnumVar::Skip
//
//  DESCRIPTION:
//
//  Skips some elements in this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CQualSetEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pQualifierSet->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}
	
//***************************************************************************
//
//  SCODE CQualSetEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CQualSetEnumVar::SeekCurrentPosition ()
{
	ISWbemQualifier *pDummyObject = NULL;
	m_pQualifierSet->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pQualifierSet->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\qualset.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  QUALSET.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemQualifierSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemQualifierSet::CSWbemQualifierSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemQualifierSet::CSWbemQualifierSet(IWbemQualifierSet *pQualSet,
									   ISWbemInternalObject *pSWbemObject) :
								m_pSite (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemQualifierSet, 
					CLSID_SWbemQualifierSet, L"SWbemQualifierSet");
	m_pIWbemQualifierSet = pQualSet;
	m_pIWbemQualifierSet->AddRef ();

	if (pSWbemObject)
		m_pSite = new CWbemObjectSite (pSWbemObject);

    m_cRef=1;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemQualifierSet::~CSWbemQualifierSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemQualifierSet::~CSWbemQualifierSet()
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemQualifierSet)
	{
		m_pIWbemQualifierSet->EndEnumeration ();
		m_pIWbemQualifierSet->Release ();
	}

	if (m_pSite)
		m_pSite->Release ();
}

//***************************************************************************
// HRESULT CSWbemQualifierSet::QueryInterface
// long CSWbemQualifierSet::AddRef
// long CSWbemQualifierSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifierSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemQualifierSet==riid)
		*ppv = (ISWbemQualifierSet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemQualifierSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemQualifierSet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemQualifierSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemQualifierSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemQualifierSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Item
//
//  DESCRIPTION:
//
//  Get a qualifier
//
//  PARAMETERS:
//
//		bsName			The name of the qualifier
//		lFlags			Flags
//		ppQual			On successful return addresses the ISWbemQualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemQualifier ** ppQual
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQual)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemQualifierSet)
	{
		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Get (bsName, lFlags, NULL, NULL)))
		{
			if (!(*ppQual = new CSWbemQualifier (m_pIWbemQualifierSet, bsName, m_pSite)))
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Add
//
//  DESCRIPTION:
//
//  Put a qualifier
//
//  PARAMETERS:
//
//		bsName			The name of the qualifier
//		pVal			Pointer to new value
//		flavor			Flavor
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Add (
	BSTR bsName,
	VARIANT *pVal,
	VARIANT_BOOL propagatesToSubclasses,
	VARIANT_BOOL propagatesToInstances,
	VARIANT_BOOL overridable,
    long lFlags,
	ISWbemQualifier **ppQualifier
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == pVal) || (NULL == ppQualifier))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemQualifierSet)
	{
		long flavor = 0;

		if (propagatesToSubclasses)
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

		if (propagatesToInstances)
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

		if (!overridable)
			flavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;

		// Make sure we have a decent qualifier value to use
		if(((VT_ARRAY | VT_VARIANT) == V_VT(pVal)) ||
		   ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVal)))
		{
			VARIANT vTemp;
			VariantInit (&vTemp);

			if (S_OK == ConvertArray(&vTemp, pVal, TRUE))
				hr = m_pIWbemQualifierSet->Put (bsName, &vTemp, flavor);
			
			VariantClear(&vTemp);    
		}
		else if ((VT_DISPATCH == V_VT(pVal)) || ((VT_DISPATCH|VT_BYREF) == V_VT(pVal)))
		{
			// Could be a JScript IDispatchEx array
			VARIANT vTemp;
			VariantInit (&vTemp);

			if (S_OK == ConvertDispatchToArray (&vTemp, pVal, CIM_ILLEGAL, true))
				hr = m_pIWbemQualifierSet->Put (bsName, &vTemp, flavor);

			VariantClear (&vTemp);
		}
		else
		{
			// Only certain types, I4, R8, BOOL and BSTR are acceptable qualifier
			// values.  Convert the data if need be

			VARTYPE vtOK = GetAcceptableQualType(pVal->vt);

			if(vtOK != pVal->vt)
			{
				VARIANT vTemp;
				VariantInit(&vTemp);

				if (S_OK == QualifierVariantChangeType (&vTemp, pVal, vtOK))
					hr = m_pIWbemQualifierSet->Put (bsName, &vTemp, flavor);

				VariantClear(&vTemp);
			}
			else
				hr = m_pIWbemQualifierSet->Put (bsName, pVal, flavor);
		}

		if (SUCCEEDED (hr))
		{
			if (!(*ppQualifier = new CSWbemQualifier (m_pIWbemQualifierSet, bsName, m_pSite)))
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Remove
//
//  DESCRIPTION:
//
//  Delete a qualifier
//
//  PARAMETERS:
//
//		bsName			The name of the qualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Remove (
	BSTR bsName,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemQualifierSet)
		hr = m_pIWbemQualifierSet->Delete (bsName);

	// Translate default reset case to an error
	if (WBEM_S_RESET_TO_DEFAULT == hr)
		hr = wbemErrResetToDefault;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	if (SUCCEEDED(hr) || (wbemErrResetToDefault == hr))
	{
		// Propagate the change to the owning site
		if (m_pSite)
			m_pSite->Update ();
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Begin an enumeration of the qualifiers
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::BeginEnumeration (
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemQualifierSet)
	{
		hr = m_pIWbemQualifierSet->EndEnumeration ();
		hr = m_pIWbemQualifierSet->BeginEnumeration (0);
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::Next
//
//  DESCRIPTION:
//
//  Get next qualifier in enumeration
//
//  PARAMETERS:
//
//		lFlags		Flags
//		ppQual		Next qualifier (or NULL if end of enumeration)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::Next (
	long lFlags,
	ISWbemQualifier ** ppQual
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQual)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemQualifierSet)
	{
		BSTR name = NULL;
		
		if (WBEM_S_NO_ERROR == (hr = m_pIWbemQualifierSet->Next (lFlags, &name, NULL, NULL)))
		{
			if (!(*ppQual = new CSWbemQualifier (m_pIWbemQualifierSet, name, m_pSite)))
				hr = WBEM_E_OUT_OF_MEMORY;

			SysFreeString (name);
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CQualSetEnumVar *pEnum = new CQualSetEnumVar (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemQualifierSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses cardinality
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		/*
		 * This is not the most efficient way of obtaining the count,
		 * but it is the only way that is:
		 *	(a) Supported by the underlying interface
		 *	(b) Does not require access to any other interface
		 *	(c) Does not affect the current enumeration position
		 */

		if (m_pIWbemQualifierSet)
		{
			SAFEARRAY	*pArray = NULL;

			if (WBEM_S_NO_ERROR == m_pIWbemQualifierSet->GetNames (0, &pArray))
			{
				long lUBound = 0, lLBound = 0;
				SafeArrayGetUBound (pArray, 1, &lUBound);
				SafeArrayGetLBound (pArray, 1, &lLBound);
				*plCount = lUBound - lLBound + 1;
				SafeArrayDestroy (pArray);
				hr = S_OK;
			}
		}
	}
		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemQualifierSet::CQualifierSetDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemQualifierSet::CQualifierSetDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Item method) which
	 * are PUTs that supplied an argument.  These are triggered by attempts
	 * to set a value of a qualifier (Item) in the collection.
	 * The first argument should be the new value for the item, and the second
	 * argument should be the name of the item.
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_MEMBERNOTFOUND == hr) && (2 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYPUT == wFlags))
	{
		// Looks promising - get the object to try and resolve this
		ISWbemQualifierSet *pQualifierSet = NULL;

		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemQualifierSet, (PPVOID) &pQualifierSet)))
		{
			VARIANT valueVar;
			VariantInit (&valueVar);
			
			if (SUCCEEDED(VariantCopy(&valueVar, &pdispparams->rgvarg[0])))
			{
				VARIANT nameVar;
				VariantInit (&nameVar);
			
				if (SUCCEEDED(VariantCopy(&nameVar, &pdispparams->rgvarg[1])))
				{
					// Check name is a BSTR and use it to get the item
					if (VT_BSTR == V_VT(&nameVar))
					{
						ISWbemQualifier *pQualifier = NULL;

						if (SUCCEEDED (pQualifierSet->Item (V_BSTR(&nameVar), 0, &pQualifier)))
						{
							// Try and put the value
							if (SUCCEEDED (pQualifier->put_Value (&valueVar)))
								hr = S_OK;
							else
							{
								hr = DISP_E_TYPEMISMATCH;
								if (puArgErr)
									*puArgErr = 0;
							}

							pQualifier->Release ();
						}
					}
					else
					{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = 1;
					}

					VariantClear (&nameVar);
				}

				VariantClear (&valueVar);
			}

			pQualifierSet->Release ();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\refresher.h ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  refresher.h
//
//  alanbos  02-Feb-00   Created.
//
//  Refresher helper implementation.
//
//***************************************************************************

#ifndef _REFRESHER_H_
#define _REFRESHER_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemRefreshableItem
//
//  DESCRIPTION:
//
//  Implements the ISWbemRefreshableItem interface.  
//
//***************************************************************************

class CSWbemRefreshableItem : public ISWbemRefreshableItem,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
private:
	CDispatchHelp		m_Dispatch;
	ISWbemRefresher		*m_pISWbemRefresher;
	long				m_iIndex;
	VARIANT_BOOL		m_bIsSet;
	ISWbemObjectEx		*m_pISWbemObjectEx;
	ISWbemObjectSet		*m_pISWbemObjectSet;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemRefreshableItem(ISWbemRefresher *pRefresher, long iIndex,
							IDispatch *pServices, 
							IWbemClassObject *pObject, 
							IWbemHiPerfEnum *pObjectSet);
    virtual ~CSWbemRefreshableItem(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// ISWbemRefreshableItem methods
	HRESULT STDMETHODCALLTYPE get_Index (
		/*[out, retval]*/ long *iIndex
		)
	{
		ResetLastErrors ();
		*iIndex = m_iIndex;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_Refresher (
		/*[out, retval]*/ ISWbemRefresher **objWbemRefresher
		)
	{
		ResetLastErrors ();
		*objWbemRefresher = m_pISWbemRefresher;

		if (m_pISWbemRefresher)
			m_pISWbemRefresher->AddRef();

		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_IsSet (
		/*[out, retval]*/ VARIANT_BOOL *bIsSet
		)
	{
		ResetLastErrors ();
		*bIsSet = m_bIsSet;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_Object (
		/*[out, retval]*/ ISWbemObjectEx **objWbemObject
		)
	{
		ResetLastErrors ();
		*objWbemObject = m_pISWbemObjectEx;

		if (*objWbemObject)
			(*objWbemObject)->AddRef ();

		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE get_ObjectSet (
		/*[out, retval]*/ ISWbemObjectSet **objWbemObjectSet
		)
	{
		ResetLastErrors ();
		*objWbemObjectSet = m_pISWbemObjectSet;

		if (*objWbemObjectSet)
			(*objWbemObjectSet)->AddRef ();

		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE Remove (
		/*[in, optional, defaultvalue(0)]*/ long iFlags
		)
	{
		HRESULT hr = WBEM_E_FAILED;
		ResetLastErrors ();

		if (m_pISWbemRefresher)
			hr = m_pISWbemRefresher->Remove (m_iIndex, 0);

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemRefreshableItem == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// Other methods
	void UnhookRefresher ()
	{
		if (m_pISWbemRefresher)
			m_pISWbemRefresher = NULL;
	}
};

typedef map<long, CSWbemRefreshableItem*, less<long>, CWbemAllocator<CSWbemRefreshableItem*> > RefreshableItemMap;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemRefresher
//
//  DESCRIPTION:
//
//  Implements the ISWbemRefresher interface.  
//
//***************************************************************************
class CEnumRefresher;

class CSWbemRefresher : public ISWbemRefresher,
						 public IObjectSafety,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
friend CEnumRefresher;
private:
	CDispatchHelp		m_Dispatch;
	long				m_iCount;
	VARIANT_BOOL		m_bAutoReconnect;

	IWbemConfigureRefresher	*m_pIWbemConfigureRefresher;
	IWbemRefresher			*m_pIWbemRefresher;

	RefreshableItemMap	m_ObjectMap;

	void				CreateRefresher ();
	void				EraseItem (RefreshableItemMap::iterator iterator);
	
protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemRefresher(void);
    virtual ~CSWbemRefresher(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemRefresher methods

    HRESULT STDMETHODCALLTYPE get__NewEnum (
		/*[out, retval]*/ IUnknown **pUnk
		);

	HRESULT STDMETHODCALLTYPE Item (
		/*[in]*/ long iIndex, 
		/*[out, retval]*/ ISWbemRefreshableItem **objWbemRefreshableItem
		);

	HRESULT STDMETHODCALLTYPE get_Count (
		/*[out, retval]*/ long *iCount
		);

	HRESULT STDMETHODCALLTYPE Add (
		/*[in]*/ ISWbemServicesEx *objWbemServices,
		/*[in]*/ BSTR bsInstancePath,
		/*[in, optional, defaultvalue(0)]*/ long iFlags,
		/*[in, optional, defaultvalue(0)]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/*[out, retval]*/ ISWbemRefreshableItem **objWbemRefreshableItem
		);

	HRESULT STDMETHODCALLTYPE AddEnum (
		/*[in]*/ ISWbemServicesEx *objWbemServices,
		/*[in]*/ BSTR bsClassName,
		/*[in, optional, defaultvalue(0)]*/ long iFlags,
		/*[in, optional, defaultvalue(0)]*/ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/*[out, retval]*/ ISWbemRefreshableItem **objWbemRefreshableItem
		);

	HRESULT STDMETHODCALLTYPE Remove (
		/*[in]*/ long iIndex,
		/*[in, optional, defaultvalue(0)]*/ long iFlags
		);

	HRESULT STDMETHODCALLTYPE Refresh (
		/*[in, optional, defaultvalue(0)]*/ long iFlags
		);
		
	HRESULT STDMETHODCALLTYPE get_AutoReconnect (
		/*[out, retval]*/ VARIANT_BOOL *bAutoReconnect
		)
	{
		ResetLastErrors ();
		*bAutoReconnect = m_bAutoReconnect;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE put_AutoReconnect (
		/*[in]*/ VARIANT_BOOL bAutoReconnect
		)
	{
		ResetLastErrors ();
		m_bAutoReconnect = bAutoReconnect;
		return WBEM_S_NO_ERROR;
	}

	HRESULT STDMETHODCALLTYPE DeleteAll (
		);
    
    // IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemRefresher == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumRefresher
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for ISWbemRefresher
//
//***************************************************************************

class CEnumRefresher : public IEnumVARIANT
{
private:
	long							m_cRef;
	CSWbemRefresher					*m_pCSWbemRefresher;
	RefreshableItemMap::iterator	m_Iterator;

public:
	CEnumRefresher (CSWbemRefresher *pCSWbemRefresher);
	CEnumRefresher (CSWbemRefresher *pCSWbemRefresher,
						RefreshableItemMap::iterator iterator);
	virtual ~CEnumRefresher (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemHiPerfObjectSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectSet interface for IWbemHiPerfEnum
//
//***************************************************************************

class CSWbemHiPerfObjectSet : public ISWbemObjectSet,
					    	  public ISupportErrorInfo,
							  public IProvideClassInfo
{
private:
	CSWbemServices			*m_pSWbemServices;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity			*m_SecurityInfo;
	IWbemHiPerfEnum			*m_pIWbemHiPerfEnum;
	
protected:
	long            m_cRef;         //Object reference count

public:
    
   	CSWbemHiPerfObjectSet(CSWbemServices *pService, IWbemHiPerfEnum *pIWbemHiPerfEnum);
    ~CSWbemHiPerfObjectSet(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);

    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemObject **ppObject
    );        

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemObjectSet == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// Other methods
	HRESULT ReadObjects (unsigned long & iCount , IWbemObjectAccess ***ppIWbemObjectAccess);	// Bug Id 566345
							
	// Other methods
	CSWbemServices *GetSWbemServices ()
	{
		return m_pSWbemServices;
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumVarHiPerf
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for IWbemHiPerfEnum
//
//***************************************************************************

class CEnumVarHiPerf : public IEnumVARIANT
{
private:
	long					m_cRef;
	unsigned long			m_iCount;
	unsigned long			m_iPos;
	IWbemObjectAccess		**m_ppIWbemObjectAccess;
	CSWbemHiPerfObjectSet	*m_pCSWbemHiPerfObjectSet;

public:
	CEnumVarHiPerf (CSWbemHiPerfObjectSet *pCSWbemHiPerfObjectSet);
	virtual ~CEnumVarHiPerf (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);
	
	STDMETHODIMP Reset()
	{
		m_iPos = 0;
		SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());
		return WBEM_S_NO_ERROR;
	}
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};

#endif // _REFRESHER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\qualvar.h ===
//***************************************************************************
//
//  qualvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CQualSetEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _QUALVAR_H_
#define _QUALVAR_H_

// This class implements the IEnumVARIANT interface

class CQualSetEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemQualifierSet	*m_pQualifierSet;
	ULONG				m_pos;
		
	bool			SeekCurrentPosition ();;

public:
	CQualSetEnumVar (CSWbemQualifierSet *pContext, 
					 ULONG initialPos = 0);
	~CQualSetEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\security.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  security.h
//
//  alanbos  25-Sep-98   Created.
//
//  Defines the CSWbemSecurity and subsiduary objects
//
//***************************************************************************

#ifndef _SECURITY_H_
#define _SECURITY_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemLocatorSecurity
//
//  DESCRIPTION:
//
//  Implements the ISWbemSecurity interface for SWbemLocator objects.  
//
//***************************************************************************

class CWbemLocatorSecurity : public ISWbemSecurity,
							 public ISupportErrorInfo,
							 public IProvideClassInfo
{
private:
	CSWbemPrivilegeSet			*m_pPrivilegeSet;
	CDispatchHelp				m_Dispatch;
	bool						m_impLevelSet;
	WbemImpersonationLevelEnum	m_impLevel;
	bool						m_authnLevelSet;
	WbemAuthenticationLevelEnum m_authnLevel;
	
protected:
	long            m_cRef;         //Object reference count

public:
    CWbemLocatorSecurity (CSWbemPrivilegeSet *pPrivilegeSet);
	CWbemLocatorSecurity (CWbemLocatorSecurity *pCWbemLocatorSecurity);
	virtual ~CWbemLocatorSecurity (void);

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
	STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
	STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
						  lcid,
						  rgdispid);}
	STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
						pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemSecurity methods

	HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
	(
		/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
	(
		/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
	(
		/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
	(
		/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE get_Privileges 
	(
		/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// CWbemLocatorSecurity methods
	bool IsImpersonationSet () { return m_impLevelSet; }
	bool IsAuthenticationSet () { return m_authnLevelSet; }
	BOOL SetSecurity (BSTR bsUser, bool &needToResetSecurity, HANDLE &hThreadToken);
	void ResetSecurity (HANDLE hThreadToken);

	CSWbemPrivilegeSet *GetPrivilegeSet ()
	{
		CSWbemPrivilegeSet *pPrivSet = m_pPrivilegeSet;

		if (pPrivSet)
			pPrivSet->AddRef ();

		return pPrivSet;
	}
};
	
//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemSecurity
//
//  DESCRIPTION:
//
//  Implements the ISWbemSecurity interface for non-SWbemLocator objects.  
//
//***************************************************************************

class CSWbemSecurity : public ISWbemSecurity,
					   public ISupportErrorInfo,
					   public ISWbemInternalSecurity,
					   public IProvideClassInfo
{
private:
	CSWbemPrivilegeSet			*m_pPrivilegeSet;
	CDispatchHelp				m_Dispatch;
	CSWbemProxyCache			*m_pProxyCache;
	IUnknown					*m_pCurProxy;

	CSWbemProxyCache	*GetProxyCache ()
	{
		CSWbemProxyCache *pCache = m_pProxyCache;

		if (pCache)
			pCache->AddRef ();

		return pCache;
	}

	// Sundry statics
	static bool			s_bInitialized;
	static bool			s_bIsNT;
	static DWORD		s_dwNTMajorVersion;
	static HINSTANCE	s_hAdvapi;
	static bool			s_bCanRevert;
	static WbemImpersonationLevelEnum s_dwDefaultImpersonationLevel;

	static SECURITY_IMPERSONATION_LEVEL MapImpersonationLevel(WbemImpersonationLevelEnum ImpersonationLevel);

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemSecurity (IUnknown *pUnk,
					BSTR bsAuthority = NULL,
					BSTR bsUser = NULL, BSTR bsPassword = NULL,
					CWbemLocatorSecurity *pSecurity = NULL);
	CSWbemSecurity (IUnknown *pUnk,
					COAUTHIDENTITY *pCoAuthIdentity,
					BSTR bsPrincipal,
					BSTR bsAuthority);
	CSWbemSecurity (CSWbemSecurity *pSecurity);
	CSWbemSecurity (IUnknown *pUnk,
					CSWbemSecurity *pSecurity);
	CSWbemSecurity (IUnknown *pUnk,
					ISWbemInternalSecurity *pSecurity);
    virtual ~CSWbemSecurity (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemSecurity methods

	HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
	(
		/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
	(
		/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
	);

	HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
	(
		/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
	(
		/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
	);

	HRESULT STDMETHODCALLTYPE get_Privileges 
	(
		/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
	);
	
	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	}

	// ISWbemInternalSecurity methods
	HRESULT STDMETHODCALLTYPE GetAuthority (BSTR *bsAuthority);
	HRESULT STDMETHODCALLTYPE GetUPD (BSTR *bsUser, BSTR *bsPassword, BSTR *bsDomain);
	HRESULT STDMETHODCALLTYPE GetPrincipal (BSTR *bsPrincipal);
	
	// CSWbemSecurity methods

	COAUTHIDENTITY *GetCoAuthIdentity () { return (m_pProxyCache ? m_pProxyCache->GetCoAuthIdentity () : NULL); }
	BSTR GetPrincipal () { return (m_pProxyCache ? m_pProxyCache->GetPrincipal (): NULL); }
	BSTR GetAuthority () { return (m_pProxyCache ? m_pProxyCache->GetAuthority (): NULL); }
	bool IsUsingExplicitUserName () { return (m_pProxyCache ? m_pProxyCache->IsUsingExplicitUserName (): false); }

	IUnknown *GetProxy () 
	{
		IUnknown *pProxy = m_pCurProxy;

		if (pProxy)
			pProxy->AddRef ();

		return pProxy;
	}

	CSWbemPrivilegeSet *GetPrivilegeSet ()
	{
		CSWbemPrivilegeSet *pPrivSet = m_pPrivilegeSet;

		if (pPrivSet)
			pPrivSet->AddRef ();

		return pPrivSet;
	}

	void SecureInterface (IUnknown *pUnk);
	void SecureInterfaceRev (IUnknown *pUnk);

	// Sundry Privilege-related functions
	static BOOL AdjustTokenPrivileges (HANDLE hHandle, CSWbemPrivilegeSet *pPrivilegeSet);
	static BOOL LookupPrivilegeValue (LPCTSTR lpName, PLUID pLuid);
	static void LookupPrivilegeDisplayName (LPCTSTR lpName, BSTR *pDisplayName);
	
	BOOL	SetSecurity (bool &needToResetSecurity, HANDLE &hThreadToken);
	void	ResetSecurity (HANDLE hThreadToken);

	// Used to define resources
	static	void Initialize ();
	static	void Uninitialize ();

	// Sundry OS versioning helper routines
	static bool	 IsNT () { return s_bIsNT; }
	static DWORD GetNTMajorVersion () { return s_dwNTMajorVersion; }
	static bool	 CanRevertToSelf () { return s_bCanRevert; }
	static WbemImpersonationLevelEnum GetDefaultImpersonationLevel () 
				{ return s_dwDefaultImpersonationLevel; }
	static bool	 IsImpersonating (bool useDefaultUser, bool useDefaultAuthority);

#ifdef WSCRPDEBUG
	static void PrintPrivileges (HANDLE hToken);
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\refresher.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  REFRESHER.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemRefresher and ISWbemRefreshableItem
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemRefresher::CSWbemRefresher
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemRefreshableItem::CSWbemRefreshableItem(
			ISWbemRefresher *pRefresher, 
			long iIndex,
			IDispatch *pServices,
			IWbemClassObject *pObject, 
			IWbemHiPerfEnum *pObjectSet
)
				: m_pISWbemRefresher (pRefresher),
				  m_iIndex (iIndex),
				  m_bIsSet (VARIANT_FALSE),
				  m_pISWbemObjectEx (NULL),
				  m_pISWbemObjectSet (NULL),
				  m_cRef (0)
{
	m_Dispatch.SetObj (this, IID_ISWbemRefreshableItem, 
					CLSID_SWbemRefreshableItem, L"SWbemRefreshableItem");

	// Note that we do NOT AddRef m_pISWbemRefresher. To do so would create
	// a circular reference between this object and the refresher, since the
	// refresher's map already holds a reference to this object. 
	
	if (pServices)
	{
		CComQIPtr<ISWbemInternalServices>  pISWbemInternalServices (pServices);

		if (pISWbemInternalServices)
		{
			CSWbemServices *pCSWbemServices = new CSWbemServices (pISWbemInternalServices);

			if (pCSWbemServices)
				pCSWbemServices->AddRef ();
			
			if (pObject)
			{
				// Create a new CSWbemObject for ourselves
				CSWbemObject *pCSWbemObject = new CSWbemObject (pCSWbemServices, pObject);

                if (pCSWbemObject){
                    if(FAILED(pCSWbemObject->QueryInterface (IID_ISWbemObjectEx, (void**) &m_pISWbemObjectEx))){
                        delete pCSWbemObject;
                    }
                }
			}

			if (pObjectSet)
			{
				// Create a new CSWbemHiPerfObjectSet for ourselves
				CSWbemHiPerfObjectSet *pCSWbemHiPerfObjectSet = 
							new CSWbemHiPerfObjectSet (pCSWbemServices, pObjectSet);
				
				if (pCSWbemHiPerfObjectSet)
				{
                    if(SUCCEEDED(pCSWbemHiPerfObjectSet->QueryInterface (IID_ISWbemObjectSet, (void**) &m_pISWbemObjectSet))){
                        m_bIsSet = VARIANT_TRUE;
                    } else {
                        delete pCSWbemHiPerfObjectSet;
                    }
				}
			}

			if (pCSWbemServices)
				pCSWbemServices->Release ();
		}
	}

    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemRefreshableItem::~CSWbemRefreshableItem
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemRefreshableItem::~CSWbemRefreshableItem(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pISWbemObjectEx)
	{
		m_pISWbemObjectEx->Release ();
		m_pISWbemObjectEx = NULL;
	}

	if (m_pISWbemObjectSet)
	{
		m_pISWbemObjectSet->Release ();
		m_pISWbemObjectSet = NULL;
	}
}

//***************************************************************************
// HRESULT CSWbemRefreshableItem::QueryInterface
// long CSWbemRefreshableItem::AddRef
// long CSWbemRefreshableItem::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemRefreshableItem::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemRefreshableItem==riid)
		*ppv = (ISWbemRefresher *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemRefreshableItem::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemRefreshableItem::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  CSWbemRefresher::CSWbemRefresher
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemRefresher::CSWbemRefresher()
				: m_iCount (0),
				  m_bAutoReconnect (VARIANT_TRUE),
				  m_pIWbemConfigureRefresher (NULL),
				  m_pIWbemRefresher (NULL),
				  m_cRef (0)
{
	m_Dispatch.SetObj (this, IID_ISWbemRefresher, 
					CLSID_SWbemRefresher, L"SWbemRefresher");
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemRefresher::~CSWbemRefresher
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemRefresher::~CSWbemRefresher(void)
{
    InterlockedDecrement(&g_cObj);

	// Remove all items from the refresher
	DeleteAll ();

	if (m_pIWbemConfigureRefresher)
		m_pIWbemConfigureRefresher->Release ();

	if (m_pIWbemRefresher)
		m_pIWbemRefresher->Release ();
}

//***************************************************************************
// HRESULT CSWbemRefresher::QueryInterface
// long CSWbemRefresher::AddRef
// long CSWbemRefresher::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemRefresher::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemRefresher==riid)
		*ppv = (ISWbemRefresher *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemRefresher::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemRefresher::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumRefresher *pEnumRefresher = new CEnumRefresher (this);

		if (!pEnumRefresher)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnumRefresher->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnumRefresher;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = m_ObjectMap.size ();
		hr = S_OK;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Add
//
//  DESCRIPTION:
//
//  Add a single instance to the refresher  
//
//  PARAMETERS:
//
//		pISWbemServicesEx		the SWbemServicesEx to use
//		bsInstancePath			the relative path of the instance
//		iFlags					flags
//		pSWbemContext			context
//		ppSWbemRefreshableItem	addresses the SWbemRefreshableItem on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Add (
	ISWbemServicesEx *pISWbemServicesEx,
	BSTR bsInstancePath,
	long iFlags,
	IDispatch *pSWbemContext,
	ISWbemRefreshableItem **ppSWbemRefreshableItem
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppSWbemRefreshableItem) || (NULL == pISWbemServicesEx) || (NULL == bsInstancePath))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		// Extract the context
		CComPtr<IWbemContext> pIWbemContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.
		pIWbemContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pSWbemContext));

		// Extract the IWbemServices
		CComPtr<IWbemServices> pIWbemServices;
		pIWbemServices.Attach( CSWbemServices::GetIWbemServices (pISWbemServicesEx));

		if (pIWbemServices)
		{
			// Get our refresher - may need to create on demand	
			if (NULL == m_pIWbemConfigureRefresher)
				CreateRefresher ();

			if (m_pIWbemConfigureRefresher)
			{
				IWbemClassObject *pObject = NULL;
				long iIndex = 0;

				if (SUCCEEDED(hr = m_pIWbemConfigureRefresher->AddObjectByPath (pIWbemServices,
							bsInstancePath, iFlags, pIWbemContext, &pObject, &iIndex)))
				{
					CSWbemRefreshableItem *pRefreshableItem = new
											CSWbemRefreshableItem (this, iIndex,
												pISWbemServicesEx, pObject, NULL);

					if (!pRefreshableItem)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (SUCCEEDED(hr =pRefreshableItem->QueryInterface (IID_ISWbemRefreshableItem, 
										(void**) ppSWbemRefreshableItem)))
					{
						m_ObjectMap [iIndex] = pRefreshableItem;
						pRefreshableItem->AddRef ();
					}
					else
						delete pRefreshableItem;
				}
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::AddEnum
//
//  DESCRIPTION:
//
//  Add a single enum (shallow instance) to the refresher  
//
//  PARAMETERS:
//
//		pISWbemServicesEx		the SWbemServicesEx to use
//		bsClassName				the name of the class
//		iFlags					flags
//		pSWbemContext			context
//		ppSWbemRefreshableItem	addresses the SWbemRefreshableItem on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::AddEnum (
	ISWbemServicesEx *pISWbemServicesEx,
	BSTR bsClassName,
	long iFlags,
	IDispatch *pSWbemContext,
	ISWbemRefreshableItem **ppSWbemRefreshableItem
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppSWbemRefreshableItem) || (NULL == pISWbemServicesEx) 
			|| (NULL == bsClassName))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		// Extract the context
		CComPtr<IWbemContext> pIWbemContext;

		//Can't assign directly because the raw pointer gets AddRef'd twice and we leak,
		//So we use Attach() instead to prevent the smart pointer from AddRef'ing.
		pIWbemContext.Attach(CSWbemNamedValueSet::GetIWbemContext (pSWbemContext));

		// Extract the IWbemServices
		CComPtr<IWbemServices> pIWbemServices;
		pIWbemServices.Attach( CSWbemServices::GetIWbemServices (pISWbemServicesEx));

		if (pIWbemServices)
		{
			// Get our refresher - may need to create on demand	
			if (NULL == m_pIWbemConfigureRefresher)
				CreateRefresher ();

			if (m_pIWbemConfigureRefresher)
			{
				IWbemHiPerfEnum *pIWbemHiPerfEnum = NULL;
				long iIndex = 0;

				if (SUCCEEDED(hr = m_pIWbemConfigureRefresher->AddEnum (pIWbemServices,
							bsClassName, iFlags, pIWbemContext, &pIWbemHiPerfEnum, &iIndex)))
				{
					CSWbemRefreshableItem *pRefreshableItem = new
											CSWbemRefreshableItem (this, iIndex,
												pISWbemServicesEx, NULL, pIWbemHiPerfEnum);

					if (!pRefreshableItem)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (SUCCEEDED(hr =pRefreshableItem->QueryInterface (IID_ISWbemRefreshableItem, 
										(void**) ppSWbemRefreshableItem)))
					{
						m_ObjectMap [iIndex] = pRefreshableItem;
						pRefreshableItem->AddRef ();
					}
					else
						delete pRefreshableItem;
				}
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Remove
//
//  DESCRIPTION:
//
//  Remove object from refresher  
//
//  PARAMETERS:
//
//		iIndex			Index of object to retrieve
//		iFlags			Flags
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Remove (
	long iIndex, 
	long iFlags
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (m_pIWbemConfigureRefresher)
	{
		if (0 != iFlags)
			hr = WBEM_E_INVALID_PARAMETER;
		else
		{
			hr = m_pIWbemConfigureRefresher->Remove (iIndex,
						(VARIANT_TRUE == m_bAutoReconnect) ? 
							WBEM_FLAG_REFRESH_AUTO_RECONNECT : 
							WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);

			if (WBEM_S_FALSE == hr)
				hr = WBEM_E_NOT_FOUND;

			if (SUCCEEDED(hr))
			{
				// Now remove from our collection
				RefreshableItemMap::iterator theIterator = m_ObjectMap.find (iIndex);

				if (theIterator != m_ObjectMap.end ())
					EraseItem (theIterator);
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::DeleteAll
//
//  DESCRIPTION:
//
//  Remove all items from refresher  
//
//  PARAMETERS:
//
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::DeleteAll (
)
{
	ResetLastErrors ();
	RefreshableItemMap::iterator next; 
		
	while ((next = m_ObjectMap.begin ()) != m_ObjectMap.end ())
	{
		CSWbemRefreshableItem *pRefreshableItem = (*next).second;
		long iIndex = 0;

		if (m_pIWbemConfigureRefresher && pRefreshableItem &&
				SUCCEEDED(pRefreshableItem->get_Index (&iIndex)))
		{
			HRESULT hr = m_pIWbemConfigureRefresher->Remove (iIndex,
						(VARIANT_TRUE == m_bAutoReconnect) ? 
							WBEM_FLAG_REFRESH_AUTO_RECONNECT : 
							WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);
		}

		EraseItem (next);
	}
	
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Refresh
//
//  DESCRIPTION:
//
//  Refresh all objects in this refresher.  
//
//  PARAMETERS:
//
//		lFlags			Flags
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Refresh (
	long iFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (0 != iFlags) 
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemRefresher)
	{
		hr = m_pIWbemRefresher->Refresh ((VARIANT_TRUE == m_bAutoReconnect) ? 
						WBEM_FLAG_REFRESH_AUTO_RECONNECT : 
						WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemRefresher::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by index.  
//
//  PARAMETERS:
//
//		iIndex			Index of object to retrieve
//		lFlags			Flags
//		ppSWbemRefreshableItem	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//	WBEM_E_NOT_FOUND			index out of range
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemRefresher::Item (
	long iIndex, 
	ISWbemRefreshableItem **ppSWbemRefreshableItem
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	ResetLastErrors ();

	if (NULL == ppSWbemRefreshableItem)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppSWbemRefreshableItem = NULL;
		RefreshableItemMap::iterator theIterator;
		theIterator = m_ObjectMap.find (iIndex);

		if (theIterator != m_ObjectMap.end ())
		{
			CSWbemRefreshableItem *pRefreshableItem = (*theIterator).second;

			if (SUCCEEDED(pRefreshableItem->QueryInterface 
					(IID_ISWbemRefreshableItem, (PPVOID) ppSWbemRefreshableItem)))
			{
				hr = WBEM_S_NO_ERROR;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  void CSWbemRefresher::CreateRefresher
//
//  DESCRIPTION:
//
//  Create the underlying WMI refresher objects.  
//
//  PARAMETERS:
//
//		none
//
//  RETURN VALUES:
//
//		none
//***************************************************************************

void CSWbemRefresher::CreateRefresher ()
{
	HRESULT hr;

	if (NULL == m_pIWbemRefresher)
	{
		if (SUCCEEDED(hr = CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, 
										IID_IWbemRefresher, (void**) &m_pIWbemRefresher )))
		{
			IWbemConfigureRefresher *pConfigureRefresher = NULL;

			// Get ourselves a refresher configurator
			hr = m_pIWbemRefresher->QueryInterface (IID_IWbemConfigureRefresher, 
													(void**) &m_pIWbemConfigureRefresher);
		}
	}
}

//***************************************************************************
//
//  void CSWbemRefresher::EraseItem
//
//  DESCRIPTION:
//
//  Scrub out an item.  
//
//  PARAMETERS:
//
//		none
//
//  RETURN VALUES:
//
//		none
//***************************************************************************

void CSWbemRefresher::EraseItem (RefreshableItemMap::iterator iterator)
{
	CSWbemRefreshableItem *pRefresherObject = (*iterator).second;

	// Remove from the map
	m_ObjectMap.erase (iterator);

	// Ensure the item is unhooked from the parent. 
	pRefresherObject->UnhookRefresher ();

	// Release the item as it is no longer in the map
	pRefresherObject->Release ();
}

// CEnumRefresher Methods

//***************************************************************************
//
//  CEnumRefresher::CEnumRefresher
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumRefresher::CEnumRefresher(CSWbemRefresher *pRefresher)
{
	m_cRef=0;
	m_pCSWbemRefresher = pRefresher;
	m_pCSWbemRefresher->AddRef ();

	m_Iterator = m_pCSWbemRefresher->m_ObjectMap.begin ();
	InterlockedIncrement(&g_cObj);
}

CEnumRefresher::CEnumRefresher(CSWbemRefresher *pRefresher,
							 RefreshableItemMap::iterator iterator) :
		m_Iterator (iterator)
{
	m_cRef=0;
	m_pCSWbemRefresher = pRefresher;
	m_pCSWbemRefresher->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumRefresher::~CEnumRefresher
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumRefresher::~CEnumRefresher(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pCSWbemRefresher)
		m_pCSWbemRefresher->Release ();
}

//***************************************************************************
// HRESULT CEnumRefresher::QueryInterface
// long CEnumRefresher::AddRef
// long CEnumRefresher::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumRefresher::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumRefresher::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CEnumRefresher::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumRefresher::Reset ()
{
	HRESULT hr = S_FALSE;
	m_Iterator = m_pCSWbemRefresher->m_ObjectMap.begin ();
	return hr;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumRefresher::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pCSWbemRefresher))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pCSWbemRefresher->m_ObjectMap.end ())
			{
				CSWbemRefreshableItem *pCSWbemRefreshableItem = (*m_Iterator).second;
				m_Iterator++;

				ISWbemRefreshableItem *pISWbemRefreshableItem = NULL;

				if (SUCCEEDED(pCSWbemRefreshableItem->QueryInterface 
						(IID_ISWbemRefreshableItem, (PPVOID) &pISWbemRefreshableItem)))
				{
					// Set the object into the variant array; note that pObject
					// has been addref'd as a result of the QI() call above
					pVar[l2].vt = VT_DISPATCH;
					pVar[l2].pdispVal = pISWbemRefreshableItem;
				}
			}
			else
				break;
		}
		if (NULL != pcElementFetched)
			*pcElementFetched = l2;
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumRefresher::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pCSWbemRefresher)
		{
			CEnumRefresher *pEnum = new CEnumRefresher (m_pCSWbemRefresher, m_Iterator);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumRefresher::Skip
//
//  DESCRIPTION:
//
//  Skip specified number of elements
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumRefresher::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pCSWbemRefresher)
	{
		ULONG l2;

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pCSWbemRefresher->m_ObjectMap.end ())
				m_Iterator++;
			else
				break;
		}

		if (l2 == cElements)
			hr = S_OK;
	}

	return hr;
}

// CSWbemHiPerfObjectSet methods

//***************************************************************************
//
//  CSWbemHiPerfObjectSet::CSWbemHiPerfObjectSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemHiPerfObjectSet::CSWbemHiPerfObjectSet(CSWbemServices *pService, 
								 IWbemHiPerfEnum *pIWbemHiPerfEnum)
				: m_SecurityInfo (NULL),
				  m_pSWbemServices (pService),
				  m_pIWbemHiPerfEnum (pIWbemHiPerfEnum),
				  m_cRef (0)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectSet, 
					CLSID_SWbemObjectSet, L"SWbemObjectSet");
    
	if (m_pIWbemHiPerfEnum)
		m_pIWbemHiPerfEnum->AddRef ();

	if (m_pSWbemServices)
	{
		m_pSWbemServices->AddRef ();

		// Use the SWbemServices security object here since
		// IWbemHiPerfEnum is not a remote interface
		CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();
		m_SecurityInfo = new CSWbemSecurity (pSecurity);

		if (pSecurity)
			pSecurity->Release ();
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemHiPerfObjectSet::~CSWbemHiPerfObjectSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemHiPerfObjectSet::~CSWbemHiPerfObjectSet(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_SecurityInfo)
		m_SecurityInfo->Release ();

	if (m_pIWbemHiPerfEnum)
		m_pIWbemHiPerfEnum->Release ();
}

//***************************************************************************
// HRESULT CSWbemHiPerfObjectSet::QueryInterface
// long CSWbemHiPerfObjectSet::AddRef
// long CSWbemHiPerfObjectSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemHiPerfObjectSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectSet==riid)
		*ppv = (ISWbemObjectSet *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemHiPerfObjectSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemHiPerfObjectSet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::ReadObjects
//
//  DESCRIPTION:
//
//  Gets the objects out of the enumerator
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
// Bug Id 566345
HRESULT CSWbemHiPerfObjectSet::ReadObjects (unsigned long & iCount , IWbemObjectAccess ***ppIWbemObjectAccess)
{
	*ppIWbemObjectAccess = NULL;
	iCount = 0;
	HRESULT hr = WBEM_E_FAILED;
	if (m_pIWbemHiPerfEnum)
	{
		// Start by getting the object count
		if (WBEM_E_BUFFER_TOO_SMALL == (hr = m_pIWbemHiPerfEnum->GetObjects (0L, 0L,
						NULL, &iCount)))
		{
			hr = S_OK;
			if(iCount > 0)
			{
				*ppIWbemObjectAccess = new IWbemObjectAccess*[iCount];

				if (*ppIWbemObjectAccess)
				{
					ZeroMemory( *ppIWbemObjectAccess, iCount * sizeof(IWbemObjectAccess*) );
					unsigned long dummy = 0;
					hr = m_pIWbemHiPerfEnum->GetObjects ( 0L, iCount, *ppIWbemObjectAccess, &dummy );
					if(FAILED(hr))
					{
						delete [] (*ppIWbemObjectAccess);
						*ppIWbemObjectAccess = NULL;
						iCount = 0;
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumVarHiPerf	*pEnumVar = new CEnumVarHiPerf (this);

		if (!pEnumVar)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnumVar->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
				delete pEnumVar;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;
	*plCount = 0;

	ResetLastErrors ();

	if (NULL == plCount)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		unsigned long iCount = 0;
		IWbemObjectAccess **ppIWbemObjectAccess = NULL;
		hr = ReadObjects (iCount,&ppIWbemObjectAccess);
		if(SUCCEEDED(hr))		// Bug Id 566345
		{
			*plCount = iCount;
			hr = WBEM_S_NO_ERROR;

			if(ppIWbemObjectAccess)
				delete [] ppIWbemObjectAccess;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.  
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::Item (
	BSTR bsObjectPath,
	long lFlags,
    ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppObject) || (NULL == bsObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		CWbemPathCracker objectPath;

		if (objectPath = bsObjectPath)
		{
			unsigned long iCount = 0;
			IWbemObjectAccess **ppIWbemObjectAccess = NULL;
			hr = ReadObjects (iCount,&ppIWbemObjectAccess);

			if(SUCCEEDED(hr))		// Bug Id 566345
			{
				bool found = false;

				for (unsigned long i = 0; !found && (i < iCount); i++)
				{
					CComPtr<IWbemClassObject> pIWbemClassObject;
					hr = WBEM_E_NOT_FOUND;
					
					// Iterate through the enumerator to try to find the element with the
					// specified path.
					if (SUCCEEDED(ppIWbemObjectAccess [i]->QueryInterface (IID_IWbemClassObject,
										(void**) &pIWbemClassObject)))
					{
						if (CSWbemObjectPath::CompareObjectPaths (pIWbemClassObject, objectPath))
						{
							// Found it - assign to passed interface and break out
							found = true;
							CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, 
											pIWbemClassObject, m_SecurityInfo);

							if (!pObject)
								hr = WBEM_E_OUT_OF_MEMORY;
							else if (FAILED(pObject->QueryInterface (IID_ISWbemObject, 
									(PPVOID) ppObject)))
							{
								hr = WBEM_E_FAILED;
								delete pObject;
							}
						}
					}
				}

				if (found)
					hr = S_OK;

				if (ppIWbemObjectAccess)
					delete [] ppIWbemObjectAccess;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemHiPerfObjectSet::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemHiPerfObjectSet::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;	
	else			// Bug ID 566345
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

// CEnumVarHiPerfHiPerf methods

//***************************************************************************
//
//  CEnumVarHiPerf::CEnumVarHiPerf
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumVarHiPerf::CEnumVarHiPerf(CSWbemHiPerfObjectSet *pCSWbemHiPerfObjectSet) :
			m_cRef (0),
			m_iCount (0),
			m_iPos (0),
			m_ppIWbemObjectAccess (NULL),
			m_pCSWbemHiPerfObjectSet (NULL)
{
	if (pCSWbemHiPerfObjectSet)
	{
		m_pCSWbemHiPerfObjectSet = pCSWbemHiPerfObjectSet;
		m_pCSWbemHiPerfObjectSet->AddRef ();
		HRESULT hr = pCSWbemHiPerfObjectSet->ReadObjects (m_iCount,&m_ppIWbemObjectAccess);	
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumVarHiPerf::~CEnumVarHiPerf
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumVarHiPerf::~CEnumVarHiPerf(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pCSWbemHiPerfObjectSet)
		m_pCSWbemHiPerfObjectSet->Release ();

	if (m_ppIWbemObjectAccess)
		delete [] m_ppIWbemObjectAccess;
}

//***************************************************************************
// HRESULT CEnumVarHiPerf::QueryInterface
// long CEnumVarHiPerf::AddRef
// long CEnumVarHiPerf::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumVarHiPerf::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumVarHiPerf::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumVarHiPerf::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumVarHiPerf::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumVarHiPerf::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			CComPtr<IWbemClassObject> pIWbemClassObject;
			
			if (m_iPos < m_iCount)
			{
				if (SUCCEEDED(hr = m_ppIWbemObjectAccess [m_iPos]->QueryInterface 
									(IID_IWbemClassObject, (void**) &pIWbemClassObject)))
				{
					m_iPos++;

					// Make a new ISWbemObjectEx
					CSWbemObject *pCSWbemObject = new CSWbemObject 
									(m_pCSWbemHiPerfObjectSet->GetSWbemServices (), 
										pIWbemClassObject);

					ISWbemObjectEx *pISWbemObjectEx = NULL;

					if (!pCSWbemObject)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (SUCCEEDED(hr = pCSWbemObject->QueryInterface (IID_ISWbemObjectEx, 
										(PPVOID) &pISWbemObjectEx)))
					{
						// Set the object into the variant array
						pVar[l2].vt = VT_DISPATCH;
						pVar[l2].pdispVal = pISWbemObjectEx;	
					}
					else
					{
						delete pCSWbemObject;
						hr = WBEM_E_FAILED;
					}
				}

				if (FAILED(hr))
						break;
			}
			else
				break; // No more elements
		}

		if (NULL != pcElementFetched)
			*pcElementFetched = l2;

		SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumVarHiPerf::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumVarHiPerf::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;
		CEnumVarHiPerf *pEnumVar = new CEnumVarHiPerf (m_pCSWbemHiPerfObjectSet);

		if (!pEnumVar)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnumVar->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
			delete pEnumVar;

		SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumVarHiPerf::Skip
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumVarHiPerf::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_iPos + cElements > m_iCount)
		m_iPos = m_iCount;
	else 
	{
		m_iPos += cElements;
		hr = S_OK;
	}

	SetWbemError (m_pCSWbemHiPerfObjectSet->GetSWbemServices ());	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\services.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  SERVICES.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemServicesEx
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	IWbemServices *pService,
	BSTR bsNamespacePath,
	BSTR bsAuthority,
	BSTR bsUser,
	BSTR bsPassword,
	CWbemLocatorSecurity *pSecurityInfo,
	BSTR bsLocale)
		: m_SecurityInfo (NULL), 
		  m_pUnsecuredApartment(NULL), 
		  m_bsLocale (NULL),
		  m_cRef (0),
		  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);

	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	m_SecurityInfo = new CSWbemSecurity (pService,
					bsAuthority, bsUser, bsPassword, pSecurityInfo);

	if (bsLocale)
		m_bsLocale = SysAllocString (bsLocale);

	if (bsNamespacePath)
		m_bsNamespacePath = bsNamespacePath;
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	IWbemServices *pService,
	BSTR bsNamespacePath,
	COAUTHIDENTITY *pCoAuthIdentity,
	BSTR bsPrincipal,
	BSTR bsAuthority)
		: m_SecurityInfo (NULL), 
		  m_pUnsecuredApartment(NULL), 
		  m_bsLocale (NULL),
		  m_cRef (0),
		  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);

	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	m_SecurityInfo = new CSWbemSecurity (pService, pCoAuthIdentity,
					bsPrincipal, bsAuthority);

	if (bsNamespacePath)
		m_bsNamespacePath = bsNamespacePath;
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor: used to clone a new CSWbemServices from an exisiting
//	instance.  The security info object is copied from the original instance
//	(which clones the underlying proxy), and the security settings are modified
//	appropriately if an override security instance is also passed in.  This
//	constructor is used when creating a CSWbemObject.
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	CSWbemServices *pService,
	CSWbemSecurity *pSecurity)
		: m_SecurityInfo (NULL), 
		  m_pUnsecuredApartment(NULL), 
		  m_bsLocale (NULL),
		  m_cRef (0),
		  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);
	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	if (pService)
	{
		/*
		 * Make a new security object from the one contained in the original
		 * CSWbemServices.  Note that this will copy the IWbemServices proxy
		 * so we have an independently securable proxy for this new object.
		 */
		CSWbemSecurity *pServiceSecurity = pService->GetSecurityInfo ();

		if (pServiceSecurity)
		{
			m_SecurityInfo = new CSWbemSecurity (pServiceSecurity);
			pServiceSecurity->Release ();
		}

		/*
		 * If an overriding security pointer was passed in, use its' settings to
		 * modify our local security pointer.
		 */
		if (pSecurity)
		{
			IUnknown *pUnk = pSecurity->GetProxy ();

			if (pUnk)
			{
				if (m_SecurityInfo)
					m_SecurityInfo->SecureInterfaceRev (pUnk);

				pUnk->Release ();
			}
		}

		// Copy the locale
		m_bsLocale = SysAllocString (pService->GetLocale ());

		// Copy the path
		m_bsNamespacePath = pService->GetPath ();
	}
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor: used to clone a new CSWbemServices from an exisiting
//	ISWbemInternalServices interface.  The security info object is copied from 
//	the original instance (which clones the underlying proxy).  This
//	constructor is used when creating a CSWbemRefreshableItem.
//
//***************************************************************************

CSWbemServices::CSWbemServices (
	ISWbemInternalServices *pISWbemInternalServices)
	: m_SecurityInfo (NULL), 
	  m_pUnsecuredApartment (NULL), 
	  m_bsLocale (NULL),
	  m_cRef (0),
	  m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);
	m_Dispatch.SetObj ((ISWbemServicesEx *)this, IID_ISWbemServicesEx, 
					CLSID_SWbemServicesEx, L"SWbemServicesEx");
    
	if (pISWbemInternalServices)
	{
		// Copy the locale
		pISWbemInternalServices->GetLocale (&m_bsLocale);

		// Copy the path
		pISWbemInternalServices->GetNamespacePath (&m_bsNamespacePath);

		/*
		 * Make a new security object from the one contained in the original
		 * ISWbemServices.  Note that this will copy the IWbemServices proxy
		 * so we have an independently securable proxy for this new object.
		 */
		ISWbemInternalSecurity *pISWbemInternalSecurity = NULL;
		pISWbemInternalServices->GetISWbemInternalSecurity (&pISWbemInternalSecurity);

		if (pISWbemInternalSecurity)
		{
			CComPtr<IWbemServices>	pIWbemServices;

			if (SUCCEEDED(pISWbemInternalServices->GetIWbemServices (&pIWbemServices)))
			{
				m_SecurityInfo = new CSWbemSecurity (pIWbemServices, 
											pISWbemInternalSecurity);
				pISWbemInternalSecurity->Release ();
			}
		}
	}
}

//***************************************************************************
//
//  CSWbemServices::CSWbemServices
//
//  DESCRIPTION:
//
//  Constructor: used to build a new CSWbemServices from an IWbemServices
//	and a existing CSWbemServices
//
//***************************************************************************

CSWbemServices::CSWbemServices(
	IWbemServices *pIWbemServices,
	CSWbemServices	*pCSWbemServices
	) : m_SecurityInfo (NULL), 
	    m_pUnsecuredApartment(NULL), 
	    m_bsLocale (NULL),
		m_cRef (0),
		m_pIServiceProvider (NULL)
{
	InterlockedIncrement(&g_cObj);

	m_Dispatch.SetObj ((ISWbemServices *)this, IID_ISWbemServices, 
					CLSID_SWbemServices, L"SWbemServices");
    
	if (pIWbemServices) 
	{
		// Make a new security cache based on the proxy passed in, but use the
		// settings from the existing object
		CSWbemSecurity *pSecurity = NULL;
		
		if (pCSWbemServices)
			pSecurity = pCSWbemServices->GetSecurityInfo ();
		
		m_SecurityInfo = new CSWbemSecurity (pIWbemServices, pSecurity);

		if (pSecurity)
			pSecurity->Release ();

		// Copy the locale and path
		if (pCSWbemServices)
		{
			m_bsLocale = SysAllocString (pCSWbemServices->GetLocale ());
			m_bsNamespacePath = pCSWbemServices->GetPath ();
		}
	}
}

//***************************************************************************
//
//  CSWbemServices::~CSWbemServices
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CSWbemServices::~CSWbemServices(void)
{
	RELEASEANDNULL(m_SecurityInfo)
	FREEANDNULL(m_bsLocale)
	RELEASEANDNULL(m_pUnsecuredApartment)

	InterlockedDecrement(&g_cObj);
}

IUnsecuredApartment *CSWbemServices::GetCachedUnsecuredApartment()
{
	// If we have one just return with it.  If not create one. 
	// This is released in the destructor
	if (!m_pUnsecuredApartment) 
	{
		HRESULT hr;
		 hr = CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
												 IID_IUnsecuredApartment, (LPVOID *) &m_pUnsecuredApartment);
		if (FAILED(hr))
			m_pUnsecuredApartment = NULL;
	}

	// AddRef so caller must release
	if (m_pUnsecuredApartment)
		m_pUnsecuredApartment->AddRef ();

	return m_pUnsecuredApartment;
}

//***************************************************************************
// HRESULT CSWbemServices::QueryInterface
// long CSWbemServices::AddRef
// long CSWbemServices::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemServices::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
	*ppv = NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemServices==riid)
		*ppv = (ISWbemServices *)this;
	else if (IID_ISWbemServicesEx==riid)
		*ppv = (ISWbemServicesEx *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)((ISWbemServicesEx *)this);
	else if (IID_IDispatchEx==riid)
		*ppv = (IDispatchEx *)this;
	else if (IID_ISupportErrorInfo==riid)
        *ppv = (ISupportErrorInfo *)this;
	else if (IID_ISWbemInternalServices==riid)
		*ppv = (ISWbemInternalServices *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;
	
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemServices::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemServices::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

// IDispatch methods should be inline

STDMETHODIMP		CSWbemServices::GetTypeInfoCount(UINT* pctinfo)
	{
	_RD(static char *me = "CSWbemServices::GetTypeInfoCount()";)
	_RPrint(me, "Called", 0, "");
	return  m_Dispatch.GetTypeInfoCount(pctinfo);}
STDMETHODIMP		CSWbemServices::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
	_RD(static char *me = "CSWbemServices::GetTypeInfo()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
STDMETHODIMP		CSWbemServices::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,
						UINT cNames, LCID lcid, DISPID* rgdispid)
	{
	_RD(static char *me = "CSWbemServices::GetIdsOfNames()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
					  lcid,
					  rgdispid);}
STDMETHODIMP		CSWbemServices::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
						WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
								EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
	_RD(static char *me = "CSWbemServices::Invoke()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
					pdispparams, pvarResult, pexcepinfo, puArgErr);}

// IDispatchEx methods should be inline
HRESULT STDMETHODCALLTYPE CSWbemServices::GetDispID(
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemServices::GetDispID()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetDispID(bstrName, grfdex, pid);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSWbemServices::InvokeEx(
	/* [in] */ DISPID id,
	/* [in] */ LCID lcid,
	/* [in] */ WORD wFlags,
	/* [in] */ DISPPARAMS __RPC_FAR *pdp,
	/* [out] */ VARIANT __RPC_FAR *pvarRes,
	/* [out] */ EXCEPINFO __RPC_FAR *pei,
	/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	HRESULT hr;
	_RD(static char *me = "CSWbemServices::InvokeEx()";)
	_RPrint(me, "Called", (long)id, "id");
	_RPrint(me, "Called", (long)wFlags, "wFlags");


	m_pIServiceProvider = pspCaller;

	hr = m_Dispatch.InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);

	m_pIServiceProvider = NULL;

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemServices::DeleteMemberByName(
	/* [in] */ BSTR bstr,
	/* [in] */ DWORD grfdex)
{
	_RD(static char *me = "CSWbemServices::DeleteMemberByName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByName(bstr, grfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemServices::DeleteMemberByDispID(
	/* [in] */ DISPID id)
{
	_RD(static char *me = "CSWbemServices::DeletememberByDispId()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByDispID(id);
}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetMemberProperties(
	/* [in] */ DISPID id,
	/* [in] */ DWORD grfdexFetch,
	/* [out] */ DWORD __RPC_FAR *pgrfdex)
{
	_RD(static char *me = "CSWbemServices::GetMemberProperties()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberProperties(id, grfdexFetch, pgrfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetMemberName(
	/* [in] */ DISPID id,
	/* [out] */ BSTR __RPC_FAR *pbstrName)
{
	_RD(static char *me = "CSWbemServices::GetMemberName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberName(id, pbstrName);
}


/*
 * I don't think this needs implementing
 */
HRESULT STDMETHODCALLTYPE CSWbemServices::GetNextDispID(
	/* [in] */ DWORD grfdex,
	/* [in] */ DISPID id,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemServices::GetNextDispID()";)
	_RPrint(me, "Called", 0, "");

	return m_Dispatch.GetNextDispID(grfdex, id, pid);

}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetNameSpaceParent(
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
{
	_RD(static char *me = "CSWbemServices::GetNamespaceParent()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetNameSpaceParent(ppunk);
}


//***************************************************************************
// HRESULT CSWbemServices::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemServices::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return ((IID_ISWbemServices == riid) ||
		    (IID_ISWbemServicesEx == riid)) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemServices::Get
//
//  DESCRIPTION:
//
//  Get an instance or class from a namespace
//
//  PARAMETERS:
//
//		bsObjectPath		Relative object path to class or instance
//		lFlags				Flags
//		pContext			If specified, additional context
//		ppObject			On successful return addresses an
//							ISWbemObject
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::Get (
	BSTR objectPath,
	long lFlags,
    /*ISWbemNamedValueSet*/ IDispatch *pContext,
	ISWbemObject **ppObject
)
{
	_RD(static char *me = "CSWbemServices::Get";)
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IWbemClassObject *pIWbemClassObject = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			_RPrint(me, "Called - context: ", (long)pIContext, "");
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->GetObject (
						(objectPath && (0 < wcslen(objectPath))) ? objectPath : NULL,
						lFlags,
						pIContext,
						&pIWbemClassObject,
						NULL);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				// Create a new CSWbemObject using the IWbemClassObject interface
				// just returned.

				CSWbemObject *pObject = new CSWbemObject (this, pIWbemClassObject);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
												(PPVOID) ppObject)))
					delete pObject;

				pIWbemClassObject->Release ();
			}

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::Delete
//
//  DESCRIPTION:
//
//  Delete an instance or class from a namespace
//
//  PARAMETERS:
//
//		bsObjectPath	Relative path of class or instance
//		pKeyValue		Single key value
//		lFlags			Flags
//		pContext		Any context info
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::Delete (
	BSTR bsObjectPath,
    long lFlags,
    /*ISWbemValueBag*/ IDispatch *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();
	
	if (m_SecurityInfo)
	{
		CWbemPathCracker pathCracker (bsObjectPath);

		if ((CWbemPathCracker::WbemPathType::wbemPathTypeError != pathCracker.GetType ()) &&
			pathCracker.IsClassOrInstance ())
		{
			CComPtr<IWbemServices> pIWbemServices;
			pIWbemServices.Attach( GetIWbemServices ());

			if (pIWbemServices)
			{
				// Get the context
				IWbemContext *pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;

				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				{
					if (pathCracker.IsInstance ())
						hr = pIWbemServices->DeleteInstance (bsObjectPath, lFlags, pIContext, NULL);
					else
						hr = pIWbemServices->DeleteClass (bsObjectPath, lFlags, pIContext, NULL);
				}
				
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			}
		}
		else
			hr = WBEM_E_INVALID_PARAMETER;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::InstancesOf
//
//  DESCRIPTION:
//
//  Create an enumerator for instances
//
//  PARAMETERS:
//
//		bsClass			Underlying class basis for enumeration
//		lFlags			Flags
//		pContext		Any context info
//		ppEnum			On successful return holds the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::InstancesOf	(
	BSTR bsClass,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->CreateInstanceEnum (bsClass, lFlags, pIContext, &pIEnum);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::ExecQuery
//
//  DESCRIPTION:
//
//  Execute a query
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEnum				Returns the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ExecQuery (
	BSTR bsQuery,
	BSTR bsQueryLanguage,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObjectSet **ppEnum)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();
#ifdef __RTEST_RPC_FAILURE
	extern int __Rx;
	extern bool __Rdone;

	__Rx = 0;
	__Rdone = false;
#endif

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			/*
			 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to
			 * guarantee that the returned objects have the __RELPATH
			 * property included.  This is in case anyone calls a
			 * method subsequently on such an object, as the "."
			 * notation requires that the __RELPATH property be present.
			 */
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecQuery
						(bsQueryLanguage, bsQuery,
						lFlags | WBEM_FLAG_ENSURE_LOCATABLE,
						pIContext,
						&pIEnum);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}


	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::AssociatorsOf
//
//  DESCRIPTION:
//
//  Return the associators of a class or instance
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEnum				Returns the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::AssociatorsOf (
	BSTR strObjectPath,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strResultRole,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredAssocQualifier,
	BSTR strRequiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppEnum) || (NULL == strObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			// Format the query string
			BSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));
			BSTR bsQuery = FormatAssociatorsQuery (strObjectPath, strAssocClass, strResultClass, strResultRole,
								strRole, bClassesOnly, bSchemaOnly, strRequiredAssocQualifier, strRequiredQualifier);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			/*
			 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to
			 * guarantee that the returned objects have the __RELPATH
			 * property included.  This is in case anyone calls a
			 * method subsequently on such an object, as the "."
			 * notation requires that the __RELPATH property be present.
			 */
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecQuery
						(bsQueryLanguage, bsQuery,
						lFlags | WBEM_FLAG_ENSURE_LOCATABLE,
						pIContext,
						&pIEnum);

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}


			SetWbemError (this);

			SysFreeString (bsQuery);
			SysFreeString (bsQueryLanguage);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemServices::ReferencesTo
//
//  DESCRIPTION:
//
//  Return the references to a class or instance
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEnum				Returns the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ReferencesTo (
	BSTR strObjectPath,
	BSTR strResultClass,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredQualifier,
	long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
    ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppEnum) || (NULL == strObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			// Format the query string
			BSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));
			BSTR bsQuery = FormatReferencesQuery (strObjectPath, strResultClass, strRole,
							bClassesOnly, bSchemaOnly, strRequiredQualifier);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			/*
			 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to
			 * guarantee that the returned objects have the __RELPATH
			 * property included.  This is in case anyone calls a
			 * method subsequently on such an object, as the "."
			 * notation requires that the __RELPATH property be present.
			 */
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecQuery
						(bsQueryLanguage, bsQuery,
						lFlags | WBEM_FLAG_ENSURE_LOCATABLE,
						pIContext,
						&pIEnum);

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			SetWbemError (this);

			SysFreeString (bsQuery);
			SysFreeString (bsQueryLanguage);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::ExecNotificationQuery
//
//  DESCRIPTION:
//
//  Execute a notification query
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		ppEvents			Returns the events iterator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ExecNotificationQuery (
	BSTR bsQuery,
	BSTR bsQueryLanguage,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemEventSource **ppEvents)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEvents)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecNotificationQuery
						(bsQueryLanguage, bsQuery, lFlags, pIContext, &pIEnum);

			if (SUCCEEDED(hr))
			{
				CSWbemEventSource *pEvents = new CSWbemEventSource (this, pIEnum);

				if (!pEvents)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEvents->QueryInterface (IID_ISWbemEventSource, (PPVOID) ppEvents)))
					delete pEvents;

				pIEnum->Release ();
			}

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::ExecMethod
//
//  DESCRIPTION:
//
//  Execute a method
//
//  PARAMETERS:
//
//		bsObjectPath		Relative path to object
//		bsMethod			The name of the method to call
//		pInParams			The in-parameters
//		lFlags				Flags
//		pContext			Any context information
//		ppOutParams			The out-parameters
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::ExecMethod (
	BSTR bsObjectPath,
	BSTR bsMethod,
	/*ISWbemObject*/ IDispatch *pInParams,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObject **ppOutParams
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IWbemClassObject *pIInParams = CSWbemObject::GetIWbemClassObject (pInParams);
			IWbemClassObject *pIOutParams = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->ExecMethod
						(bsObjectPath, bsMethod, lFlags, pIContext, pIInParams, &pIOutParams, NULL);

			if (SUCCEEDED(hr))
			{
				if (pIOutParams)
				{
					if (ppOutParams)
					{
						CSWbemObject *pObject = new CSWbemObject (this, pIOutParams);

						if (!pObject)
							hr = WBEM_E_OUT_OF_MEMORY;
						else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject,
											(PPVOID) ppOutParams)))
							delete pObject;

					}

					pIOutParams->Release ();
				}
			}

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			if (pIInParams)
				pIInParams->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::SubclassesOf
//
//  DESCRIPTION:
//
//  Create an enumerator for classes
//
//  PARAMETERS:
//
//		bsSuperClass	Underlying class basis for enumeration
//		lFlags			Flags
//		pContext		Any context info
//		ppEnum			On successful return holds the enumerator
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::SubclassesOf	(
	BSTR bsSuperClass,
	long lFlags,
	/*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IEnumWbemClassObject *pIEnum = NULL;

			// Get the context
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;

			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->CreateClassEnum
						(bsSuperClass, lFlags, pIContext, &pIEnum);

			if (SUCCEEDED(hr))
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (this, pIEnum);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIEnum->Release ();
			}

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			SetWbemError (this);

			if (pIContext)
				pIContext->Release ();

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemServices::Put
//
//  DESCRIPTION:
//
//  Save/commit a class or instance into this namespace
//
//  PARAMETERS:
//
//		objWbemObject	Class/Instance to be saved
//		lFlags			Flags
//		pContext		Context
//		ppObjectPath	Object Path
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemServices::Put (
	ISWbemObjectEx *objWbemObject,
    long lFlags,
	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	ISWbemObjectPath **ppObjectPath
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == objWbemObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			IWbemClassObject *pObject = CSWbemObject::GetIWbemClassObject (objWbemObject);
			IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

			if (NULL != pObject)
			{
				// Figure out whether this is a class or instance
				VARIANT var;
				VariantInit (&var);

				if (WBEM_S_NO_ERROR == pObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
				{
					IWbemCallResult *pResult = NULL;
					HRESULT hrCallResult = WBEM_E_FAILED;

					bool needToResetSecurity = false;
					HANDLE hThreadToken = NULL;

					if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					{
						if (WBEM_GENUS_CLASS  == var.lVal)
								hrCallResult = pIWbemServices->PutClass
										(pObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
							else
								hrCallResult = pIWbemServices->PutInstance
										(pObject, lFlags | WBEM_FLAG_RETURN_IMMEDIATELY, pIContext, &pResult);
						if (needToResetSecurity)
							m_SecurityInfo->ResetSecurity (hThreadToken);
					}

					if (WBEM_S_NO_ERROR == hrCallResult)
					{
						//Secure the IWbemCallResult interface
						m_SecurityInfo->SecureInterface (pResult);

						if ((WBEM_S_NO_ERROR == (hrCallResult = pResult->GetCallStatus (INFINITE, &hr))) &&
							(WBEM_S_NO_ERROR == hr))
						{
							if (ppObjectPath)
							{
								ISWbemObjectPath *pObjectPath =	new CSWbemObjectPath (m_SecurityInfo, GetLocale());

								if (!pObjectPath)
									hr = WBEM_E_OUT_OF_MEMORY;
								else
								{
									pObjectPath->AddRef ();
									pObjectPath->put_Path (GetPath ());
									
									if (WBEM_GENUS_CLASS == var.lVal)
									{
										VARIANT nameVar;
										VariantInit (&nameVar);

										/*
										 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
										 * the __CLASS property has not yet been set.
										 */

										if ((WBEM_S_NO_ERROR == pObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
											&& (VT_BSTR == V_VT(&nameVar)))
										{
											pObjectPath->put_Class (nameVar.bstrVal);
											*ppObjectPath = pObjectPath;
                                        					} else {
											pObjectPath->Release();
										}					

										VariantClear (&nameVar);
									}
									else
									{
										// Now get the relpath string from the call result
										BSTR resultString = NULL;

										if (WBEM_S_NO_ERROR == pResult->GetResultString (INFINITE, &resultString))
										{
											pObjectPath->put_RelPath (resultString);
											*ppObjectPath = pObjectPath;
											SysFreeString (resultString);
										} else {
											pObjectPath->Release();
										}
									}
								}
							}
						}
					}
					else
						hr = hrCallResult;

					if (pResult)
						pResult->Release ();
				}

				if (pIContext)
					pIContext->Release ();

				pObject->Release ();

				VariantClear (&var);
			}
		
			SetWbemError (this);
			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemServices::GetIWbemServices
//
//  DESCRIPTION:
//
//  Return the IWbemServices interface corresponding to this
//	scriptable wrapper.
//
//  PARAMETERS:
//		ppServices		holds the IWbemServices pointer on return
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemServices::GetIWbemServices (IWbemServices **ppServices)
{
	HRESULT hr = E_FAIL;

	if (ppServices)
	{
		*ppServices = GetIWbemServices ();
		hr = S_OK;
	}

	return hr;
}

//***************************************************************************
//
//  CSWbemServices::GetIWbemServices
//
//  DESCRIPTION:
//
//  Given an IDispatch interface which we hope is also an ISWbemServicesEx
//	interface, return the underlying IWbemServices interface.
//
//  PARAMETERS:
//		pDispatch		the IDispatch in question
//
//  RETURN VALUES:
//		The underlying IWbemServices interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

IWbemServices	*CSWbemServices::GetIWbemServices (
	IDispatch *pDispatch
)
{
	IWbemServices *pServices = NULL;
	ISWbemInternalServices *pIServices = NULL;

	if (pDispatch)
	{
		if (SUCCEEDED (pDispatch->QueryInterface 
								(IID_ISWbemInternalServices, (PPVOID) &pIServices)))
		{
			pIServices->GetIWbemServices (&pServices);
			pIServices->Release ();
		}
	}

	return pServices;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\security.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  SECURITY.CPP
//
//  alanbos  28-Jun-98   Created.
//
//  Defines the implementation of CSWbemSecurity
//
//***************************************************************************

#include "precomp.h"

// Used to protect security calls
extern CRITICAL_SECTION g_csSecurity;

bool		CSWbemSecurity::s_bInitialized = false;
bool		CSWbemSecurity::s_bIsNT = false;
DWORD		CSWbemSecurity::s_dwNTMajorVersion = 0;
HINSTANCE	CSWbemSecurity::s_hAdvapi = NULL;
bool		CSWbemSecurity::s_bCanRevert = false;
WbemImpersonationLevelEnum	CSWbemSecurity::s_dwDefaultImpersonationLevel 
					= wbemImpersonationLevelIdentify;

// Declarations for function pointers that won't exist on Win9x
BOOL (STDAPICALLTYPE *s_pfnDuplicateTokenEx) (
	HANDLE, 
	DWORD, 
	LPSECURITY_ATTRIBUTES,
	SECURITY_IMPERSONATION_LEVEL, 
	TOKEN_TYPE,
	PHANDLE
) = NULL; 

//***************************************************************************
//
//  SCODE CSWbemSecurity::Initialize
//
//  DESCRIPTION:
//
//  This static function is caused on DLL attachment to the process; it
//	sets up the function pointers for advanced API privilege functions.
//	On Win9x these functions are not supported which is why we need to
//	indirect through GetProcAddress.
//
//***************************************************************************
 
void CSWbemSecurity::Initialize ()
{
	EnterCriticalSection (&g_csSecurity);

	if (!s_bInitialized)
	{
		// Get OS info
		OSVERSIONINFO	osVersionInfo;
		osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

		GetVersionEx (&osVersionInfo);
		s_bIsNT = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
		s_dwNTMajorVersion = osVersionInfo.dwMajorVersion;

		if (s_bIsNT)
		{
			HKEY hKey;

			// Security values are relevant for NT only - for Win9x leave as default
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
					WBEMS_RK_SCRIPTING, 0, KEY_QUERY_VALUE, &hKey))
			{
				DWORD dwDummy = 0;

				// Get revert flag value from registry - NT 4.0 or less only
				if (s_dwNTMajorVersion <= 4)
				{
					DWORD dwEnableForAsp = 0;
					dwDummy = sizeof (dwEnableForAsp);
				
					if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_ENABLEFORASP, 
							NULL, NULL, (BYTE *) &dwEnableForAsp,  &dwDummy))
						s_bCanRevert = (0 != dwEnableForAsp);
				}

				// Get default impersonation level from registry
				DWORD dwImpLevel = 0;
				dwDummy = sizeof (dwImpLevel);
			
				if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_DEFAULTIMPLEVEL, 
							NULL, NULL, (BYTE *) &dwImpLevel,  &dwDummy))
					s_dwDefaultImpersonationLevel = (WbemImpersonationLevelEnum) dwImpLevel;

				RegCloseKey (hKey);
			}

			// Set up security function pointers for NT
			if (!s_hAdvapi)
			{
				TCHAR	dllName [] = _T("\\advapi32.dll");
				LPTSTR  pszSysDir = new TCHAR[ MAX_PATH + _tcslen (dllName) + 1];

				if (pszSysDir)
				{
					pszSysDir[0] = NULL;
					UINT    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);
					
					if(uSize > MAX_PATH) {
						delete[] pszSysDir;
						pszSysDir = new TCHAR[ uSize + _tcslen (dllName) + 1];
        				
						if (pszSysDir)
						{
							pszSysDir[0] = NULL;
							uSize = GetSystemDirectory(pszSysDir, uSize);
						}
					}

					if (pszSysDir)
					{
						_tcscat (pszSysDir, dllName);
						s_hAdvapi = LoadLibraryEx (pszSysDir, NULL, 0);
						
						if (s_hAdvapi)
							(FARPROC&) s_pfnDuplicateTokenEx = GetProcAddress(s_hAdvapi, "DuplicateTokenEx");

						delete [] pszSysDir;
					}
				}
			}
		}

		s_bInitialized = true;
	}
	
	LeaveCriticalSection (&g_csSecurity);
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::Uninitialize
//
//  DESCRIPTION:
//
//  This static function is caused on DLL detachment to the process; it
//	unloads the API loaded by Initialize (above) to obtain function pointers.
//
//***************************************************************************

void CSWbemSecurity::Uninitialize ()
{
	EnterCriticalSection (&g_csSecurity);
	
	if (s_hAdvapi)
	{
		s_pfnDuplicateTokenEx = NULL;
		FreeLibrary (s_hAdvapi);
		s_hAdvapi = NULL;
		s_bInitialized = false;
	}

	LeaveCriticalSection (&g_csSecurity);
}


//***************************************************************************
//
//  SCODE CSWbemSecurity::LookupPrivilegeValue
//
//  DESCRIPTION:
//
//  This static function wraps the Win32 LookupPrivilegeValue function,
//	allowing us to do some OS-dependent stuff.
//
//  PARAMETERS:
//
//		lpName		the privilege name
//		lpLuid		holds the LUID on successful return
//
//  RETURN VALUES:
//
//		true		On NT this means we found the privilege. On Win9x we
//					always return this.
//
//		false		On NT this means the privilege is not recognized.  This
//					is never returned on Win9x.
//
//***************************************************************************
 
BOOL CSWbemSecurity::LookupPrivilegeValue (
	LPCTSTR lpName, 
	PLUID lpLuid
)
{
	// Allows any name to map to 0 LUID on Win9x - this aids script portability
	if (IsNT ())
		return ::LookupPrivilegeValue(NULL, lpName, lpLuid);
	else
		return true;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::LookupPrivilegeDisplayName
//
//  DESCRIPTION:
//
//  This static function wraps the Win32 LookupPrivilegeDisplayName function,
//	allowing us to do some OS-dependent stuff.
//
//  PARAMETERS:
//
//		tName			the privilege name
//		pDisplayName	holds the display name on successful return
//
//***************************************************************************

void CSWbemSecurity::LookupPrivilegeDisplayName (LPCTSTR lpName, BSTR *pDisplayName)
{
	if (pDisplayName)
	{
		// Can't return display name on Win9x (no privilege support)
		if (IsNT ())
		{
			DWORD dwLangID;
			DWORD dwSize = 1;
			TCHAR dummy [1];
					
			// Get size of required buffer
			::LookupPrivilegeDisplayName (NULL, lpName, dummy, &dwSize, &dwLangID);
			LPTSTR dname = new TCHAR[dwSize + 1];

			if (dname)
			{
				if (::LookupPrivilegeDisplayName (_T(""), lpName, dname, &dwSize, &dwLangID))
				{
					// Have a valid name - now copy it to a BSTR
#ifdef _UNICODE 
					*pDisplayName = SysAllocString (dname);
#else
					size_t dnameLen = strlen (dname);
					OLECHAR *nameW = new OLECHAR [dnameLen + 1];

					if (nameW)
					{
						mbstowcs (nameW, dname, dnameLen);
						nameW [dnameLen] = NULL;
						*pDisplayName = SysAllocString (nameW);
						delete [] nameW;
					}
#endif
				}

				delete [] dname;
			}
		}

		// If we failed, just set an empty string
		if (!(*pDisplayName))
			*pDisplayName = SysAllocString (L"");
	}
}

//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM 
//		remoted interface where no previous security has been applied.  
//		It is only used to secure IWbemServices interfaces.
//		Note that the Locator may have security settings so these are
//		transferred if present.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	BSTR bsAuthority ,
	BSTR bsUser, 
	BSTR bsPassword,
	CWbemLocatorSecurity *pLocatorSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
				CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;
		
	m_pProxyCache = new CSWbemProxyCache (pUnk, bsAuthority,
							bsUser, bsPassword, pLocatorSecurity);

	if (m_pProxyCache)
		m_pCurProxy = m_pProxyCache->GetInitialProxy ();

	if (pLocatorSecurity)
	{
		// Clone the privilege set

		CSWbemPrivilegeSet *pPrivilegeSet = pLocatorSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
	}
	else
	{
		// Create a new privilege set
	
		m_pPrivilegeSet = new CSWbemPrivilegeSet;
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM 
//		remoted interface where no previous security has been applied,
//		and where the user credentials are expressed in the form of an
//		encrypted COAUTHIDENTITY plus principal and authority.  
//		It is only used to secure IWbemServices interfaces.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	COAUTHIDENTITY *pCoAuthIdentity,
	BSTR bsPrincipal,
	BSTR bsAuthority) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;
		
	m_pProxyCache = new CSWbemProxyCache (pUnk, pCoAuthIdentity,
							bsPrincipal, bsAuthority);

	if (m_pProxyCache)
		m_pCurProxy = m_pProxyCache->GetInitialProxy ();

	// Create a new privilege set
	m_pPrivilegeSet = new CSWbemPrivilegeSet;

	InterlockedIncrement(&g_cObj);
}
//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM interface
//		non-remoted interface using the security attributes attached to another 
//		(already secured) remoted interface; a non-remoted interface is secured
//		by virtue of securing a new proxy on an underlying remoted interface.  
//		It is used to "secure" an ISWbemObjectEx interface using the security 
//		settings of an IWbemServices interface.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	CSWbemSecurity *pSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;

	// Clone the privilege set
	if (pSecurity)
	{
		CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
		else
		{
			// Create a new one
			m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		}

		m_pProxyCache = pSecurity->GetProxyCache ();
		m_pCurProxy = pSecurity->GetProxy ();
	}

	InterlockedIncrement(&g_cObj);
}

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	ISWbemInternalSecurity *pISWbemInternalSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;

	if (pISWbemInternalSecurity)
	{
		// Clone the privilege set
		ISWbemSecurity *pISWbemSecurity = NULL;

		if (SUCCEEDED(pISWbemInternalSecurity->QueryInterface (IID_ISWbemSecurity,
							(void**) &pISWbemSecurity)))
		{
			ISWbemPrivilegeSet *pISWbemPrivilegeSet = NULL;

			if (SUCCEEDED(pISWbemSecurity->get_Privileges (&pISWbemPrivilegeSet)))
			{
				// Build the privilege set
				m_pPrivilegeSet = new CSWbemPrivilegeSet (pISWbemPrivilegeSet);

				// Build the proxy cache
				BSTR bsAuthority = NULL;
				BSTR bsPrincipal = NULL;
				BSTR bsUser = NULL;
				BSTR bsPassword = NULL;
				BSTR bsDomain = NULL;
				
				pISWbemInternalSecurity->GetAuthority (&bsAuthority);
				pISWbemInternalSecurity->GetPrincipal (&bsPrincipal);
				pISWbemInternalSecurity->GetUPD (&bsUser, &bsPassword, &bsDomain);
				
				COAUTHIDENTITY *pCoAuthIdentity = NULL;

				// Decide if we need a COAUTHIDENTITY
				if ((bsUser && (0 < wcslen (bsUser))) ||
					(bsPassword && (0 < wcslen (bsPassword))) ||
					(bsDomain && (0 < wcslen (bsDomain))))
					WbemAllocAuthIdentity (bsUser, bsPassword, bsDomain, &pCoAuthIdentity);

				m_pProxyCache = new CSWbemProxyCache (pUnk, pCoAuthIdentity,
									bsPrincipal, bsAuthority);

				if (pCoAuthIdentity)
					WbemFreeAuthIdentity (pCoAuthIdentity);

				if (bsAuthority)
					SysFreeString (bsAuthority);

				if (bsPrincipal)
					SysFreeString (bsPrincipal);

				if (bsUser)
					SysFreeString (bsUser);

				if (bsPassword)
					SysFreeString (bsPassword);

				if (bsDomain)
					SysFreeString (bsDomain);

				if (m_pProxyCache)
					m_pCurProxy = m_pProxyCache->GetInitialProxy ();
			}

			pISWbemPrivilegeSet->Release ();
		}

		pISWbemSecurity->Release ();
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
// CSWbemSecurity::CSWbemSecurity
//
// CONSTRUCTOR
//		This form of the constructor is used for securing a new WBEM remoted
//		interface interface using the security attributes attached to another 
//		(already secured) remoted interface.
//		It is used to "secure" an ISWbemObjectSet interface using the security 
//		settings of an IWbemServices interface.
//
//***************************************************************************

CSWbemSecurity::CSWbemSecurity (
	IUnknown *pUnk,
	CSWbemSecurity *pSecurity) :
		m_pPrivilegeSet (NULL),
		m_pProxyCache (NULL),
		m_pCurProxy (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
						CLSID_SWbemSecurity, L"SWbemSecurity");
	m_cRef=1;
	InterlockedIncrement(&g_cObj);

	if (pSecurity)
	{
		// Clone the privilege set
		CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
		
		m_pProxyCache = new CSWbemProxyCache (pUnk, pSecurity);

		if (m_pProxyCache)
			m_pCurProxy = m_pProxyCache->GetInitialProxy ();
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		m_pProxyCache = new CSWbemProxyCache (pUnk, NULL);

		if (m_pProxyCache)
			m_pCurProxy = m_pProxyCache->GetInitialProxy ();
	}
}

//***************************************************************************
//
// CSWbemSecurity::~CSWbemSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemSecurity::~CSWbemSecurity (void)
{
	InterlockedDecrement(&g_cObj);

	if (m_pCurProxy)
		m_pCurProxy->Release ();

	if (m_pProxyCache)
		m_pProxyCache->Release ();

	if (m_pPrivilegeSet)
		m_pPrivilegeSet->Release ();
}

//***************************************************************************
// HRESULT CSWbemSecurity::QueryInterface
// long CSWbemSecurity::AddRef
// long CSWbemSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_ISWbemInternalSecurity==riid)
		*ppv = (ISWbemInternalSecurity *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemSecurity::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemSecurity::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			*pAuthenticationLevel = (WbemAuthenticationLevelEnum) dwAuthnLevel;
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::put_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Set the authentication level
//
//  PARAMETERS:
//
//		authenticationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::put_AuthenticationLevel (
	WbemAuthenticationLevelEnum authenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_AUTHN_LEVEL > authenticationLevel) || 
		(WBEMS_MAX_AUTHN_LEVEL < authenticationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy && m_pProxyCache)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			// Only refressh from cache if settings have changed
			if (authenticationLevel != (WbemAuthenticationLevelEnum) dwAuthnLevel)
			{
				m_pCurProxy->Release ();
				m_pCurProxy = NULL;

				m_pCurProxy = m_pProxyCache->GetProxy 
								(authenticationLevel, (WbemImpersonationLevelEnum) dwImpLevel);
			}
			
			hr = WBEM_S_NO_ERROR;
		}
	}
 	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			*pImpersonationLevel = (WbemImpersonationLevelEnum) dwImpLevel;
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::put_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Set the impersonation level
//
//  PARAMETERS:
//
//		impersonationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::put_ImpersonationLevel (
	WbemImpersonationLevelEnum impersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_IMP_LEVEL > impersonationLevel) || (WBEMS_MAX_IMP_LEVEL < impersonationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pCurProxy && m_pProxyCache)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
		{
			// Only refressh from cache if settings have changed
			if (impersonationLevel != (WbemImpersonationLevelEnum) dwImpLevel)
			{
				m_pCurProxy->Release ();
				m_pCurProxy = NULL;

				m_pCurProxy = m_pProxyCache->GetProxy 
							((WbemAuthenticationLevelEnum) dwAuthnLevel, impersonationLevel);
			}
			
			hr = WBEM_S_NO_ERROR;
		}
	}
 	 		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	else			// Bug ID 566345
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  CSWbemSecurity::SecureInterface
//
//  DESCRIPTION:
//
//  Set the security on the specified interface using the security settings
//	on this interface.
//
//  PARAMETERS:
//
//		pUnk		The interface to secure
//
//  RETURN VALUES:
//		none
//***************************************************************************

void CSWbemSecurity::SecureInterface (IUnknown *pUnk)
{
	if(pUnk)
	{
		if (m_pCurProxy)
		{
			DWORD dwAuthnLevel;
			DWORD dwImpLevel;

			if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
				if (m_pProxyCache)
					m_pProxyCache->SecureProxy (pUnk, 
							(WbemAuthenticationLevelEnum) dwAuthnLevel, 
							(WbemImpersonationLevelEnum) dwImpLevel);
		}
	}
}


//***************************************************************************
//
//  CSWbemSecurity::SecureInterfaceRev
//
//  DESCRIPTION:
//
//  Set the security on this interface using the security settings
//	on the specified interface.
//
//  PARAMETERS:
//
//		pUnk		The interface whose security settings we will 
//					use to set this interface
//
//  RETURN VALUES:
//		none
//***************************************************************************

void CSWbemSecurity::SecureInterfaceRev (IUnknown *pUnk)
{
	if (pUnk)
	{
		DWORD dwAuthnLevel;
		DWORD dwImpLevel;

		if (S_OK == GetAuthImp (pUnk, &dwAuthnLevel, &dwImpLevel))
		{
			if (m_pCurProxy)
			{
				m_pCurProxy->Release ();
				m_pCurProxy = NULL;
			}

			if (m_pProxyCache)
			{
				m_pCurProxy = m_pProxyCache->GetProxy 
						((WbemAuthenticationLevelEnum) dwAuthnLevel, 
						 (WbemImpersonationLevelEnum) dwImpLevel);
			}
		}
	}
}

//***************************************************************************
//
//  CSWbemSecurity::AdjustTokenPrivileges
//
//  DESCRIPTION:
//
//  Adjust the Privileges on the specified token without allowing a future
//	restore of the current settings..
//
//  PARAMETERS:
//
//		hHandle			Handle of the token on which to adjust privileges
//		pPrivilegeSet	Specified privilege adjustments
//
//  RETURN VALUES:
//		none
//***************************************************************************

BOOL CSWbemSecurity::AdjustTokenPrivileges (
	HANDLE hHandle, 
	CSWbemPrivilegeSet *pPrivilegeSet
)
{
    BOOL result = FALSE;
	DWORD lastErr = 0;

	if (pPrivilegeSet)
	{
		pPrivilegeSet->AddRef ();

		long lNumPrivileges = 0;
		pPrivilegeSet->get_Count (&lNumPrivileges);

		if (lNumPrivileges)
		{
			DWORD dwPrivilegeIndex = 0;

			/*
			 * Set up the token privileges array. Note that some jiggery-pokery
			 * is required here because the Privileges field is an [ANYSIZE_ARRAY]
			 * type.
			 */
			TOKEN_PRIVILEGES *pTokenPrivileges = (TOKEN_PRIVILEGES *) 
						new BYTE [sizeof(TOKEN_PRIVILEGES) + (lNumPrivileges * sizeof (LUID_AND_ATTRIBUTES [1]))];

			if (pTokenPrivileges)
			{
				// Get the iterator
				PrivilegeMap::iterator next = pPrivilegeSet->m_PrivilegeMap.begin ();

				while (next != pPrivilegeSet->m_PrivilegeMap.end ())
				{
					CSWbemPrivilege *pPrivilege = (*next).second;
					pPrivilege->AddRef ();
					LUID luid;
					pPrivilege->GetLUID (&luid);
					VARIANT_BOOL vBool;
					pPrivilege->get_IsEnabled (&vBool);

					pTokenPrivileges->Privileges [dwPrivilegeIndex].Luid = luid;

					/*
					 * Note that any setting other than SE_PRIVILEGE_ENABLED
					 * is interpreted by AdjustTokenPrivileges as a DISABLE
					 * request for that Privilege.
					 */
					pTokenPrivileges->Privileges [dwPrivilegeIndex].Attributes
						= (VARIANT_TRUE == vBool) ?
						SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_ENABLED_BY_DEFAULT;

					dwPrivilegeIndex++;
					pPrivilege->Release ();
					next++;
				}

				// Now we should have recorded the number of privileges that were OK

				if (0 < dwPrivilegeIndex)
				{
					pTokenPrivileges->PrivilegeCount = dwPrivilegeIndex;

					result = ::AdjustTokenPrivileges (hHandle, FALSE, pTokenPrivileges, 0, NULL, NULL);
					lastErr = GetLastError ();
				}

				delete [] pTokenPrivileges;
			}
		}

		pPrivilegeSet->Release ();
	}

    return result;
}

template <typename T, typename FT, FT F> class OnDelete 
{
private:
	T Val_;
public:
	OnDelete(T Val):Val_(Val){};
	~OnDelete(){ F(Val_); };
};


BOOL DuplicateTokenSameAcl(HANDLE hSrcToken,
                           SECURITY_IMPERSONATION_LEVEL secImpLevel,
	                      HANDLE * pDupToken)
{
    if (!s_pfnDuplicateTokenEx)
    	return FALSE;
    
	DWORD dwSize = 0;
	BOOL bRet = GetKernelObjectSecurity(hSrcToken,
		                    DACL_SECURITY_INFORMATION, // |GROUP_SECURITY_INFORMATION|OWNER_SECURITY_INFORMATION
		                    NULL,
							0,
							&dwSize);

	if(!bRet && (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	{

		void * pSecDescr = LocalAlloc(LPTR,dwSize);
		if (NULL == pSecDescr)
			return FALSE;
		OnDelete<void *,HLOCAL(*)(HLOCAL),LocalFree> rm(pSecDescr);

		bRet = GetKernelObjectSecurity(hSrcToken,
		                    DACL_SECURITY_INFORMATION, // |GROUP_SECURITY_INFORMATION|OWNER_SECURITY_INFORMATION
		                    pSecDescr,
							dwSize,
							&dwSize);
		if (FALSE == bRet)
			return bRet;

		SECURITY_ATTRIBUTES sa;
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = pSecDescr; 
		sa.bInheritHandle = FALSE; 

		return s_pfnDuplicateTokenEx(hSrcToken, 
			                       TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE, 
			                       &sa,
								   secImpLevel, TokenImpersonation,pDupToken);
		
	}
	return bRet;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::SetSecurity
//
//  DESCRIPTION:
//
//  Set Privileges on the Thread Token.
//
//***************************************************************************

BOOL CSWbemSecurity::SetSecurity (
	bool &needToResetSecurity, 
	HANDLE &hThreadToken
)
{
	BOOL	result = TRUE;		// Default is success
	DWORD lastErr = 0;
	hThreadToken = NULL;			// Default assume we'll modify process token
	needToResetSecurity = false;	// Default assume we changed no privileges

	// Win9x has no security support
	if (IsNT ())
	{
		// Start by checking whether we are being impersonated.  On an NT4
		// box (which has no cloaking, and therefore cannot allow us to
		// pass on this impersonation to Winmgmt) we should RevertToSelf
		// if we have been configured to allow this.  If we haven't been
		// configured to allow this, bail out now.
		if (4 >= GetNTMajorVersion ())
		{
			if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_IMPERSONATE, true, &hThreadToken))
			{
				// We are being impersonated
				if (s_bCanRevert)
				{
					if (result = RevertToSelf())
						needToResetSecurity = true;
				}
				else
				{
					// Error - cannot do this!  Time to bail out
					CloseHandle (hThreadToken);
					hThreadToken = NULL;
					result = FALSE;
				}
			}
		}
		else
		{
#ifdef WSCRPDEBUG
			HANDLE hToken = NULL;

			if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, false, &hToken))
			{
				PrintPrivileges (hToken);
				CloseHandle (hToken);
			}
#endif
		}

		if (result)
		{
			// Now we check if we need to set privileges
			bool bIsUsingExplicitUserName = false;
		
			if (m_pProxyCache)
				bIsUsingExplicitUserName = m_pProxyCache->IsUsingExplicitUserName ();

			/*
			 * Specifying a user only makes sense for remote operations, and we
			 * don't need to mess with privilege for remote operations since
			 * they are set up by server logon anyway.
			 */
			if (!bIsUsingExplicitUserName && m_pPrivilegeSet)
			{
				// Nothing to do unless some privilege overrides have been set
				long lCount = 0;
				m_pPrivilegeSet->get_Count (&lCount);

				if (0 < lCount)
				{
					if (4 < GetNTMajorVersion ())
					{
						/*
						 * On NT5 we try to open the Thread token.  If the client app
						 * is calling into us on an impersonated thread (as IIS may be,
						 * for example), this will succeed.
						 */
						HANDLE hToken;
						SECURITY_IMPERSONATION_LEVEL secImpLevel = SecurityImpersonation;
						
						if (!(result =  OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_READ, true, &hToken)))
						{
							// No thread token - go for the Process token instead
							HANDLE hProcess = GetCurrentProcess ();
							result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_READ, &hToken);
							CloseHandle (hProcess);
							if(result)
							{
								WbemImpersonationLevelEnum tmpSecImpLevel;
								get_ImpersonationLevel(&tmpSecImpLevel);
								secImpLevel = MapImpersonationLevel(tmpSecImpLevel);
							}
						}
						else
						{
							// We are working with a thread token
							hThreadToken = hToken;		

							// Try and get the impersonation level of this token
							DWORD dwReturnLength  = 0;

							BOOL thisRes = GetTokenInformation (hToken, TokenImpersonationLevel, &secImpLevel, 
											sizeof (SECURITY_IMPERSONATION_LEVEL), &dwReturnLength);
						}

						if (result)
						{
							/*
							 * Getting here means we have a valid token, be it process or thread. We
							 * now attempt to duplicate it before Adjusting the Privileges.
							 */
#ifdef WSCRPDEBUG
							PrintPrivileges (hToken);
#endif
							HANDLE hDupToken;

							EnterCriticalSection (&g_csSecurity);

                            result = DuplicateTokenSameAcl(hToken,
                                                    	secImpLevel,
	                                                    &hDupToken);
	                      
							LeaveCriticalSection (&g_csSecurity);
                            
                            if(result) result = CSWbemSecurity::AdjustTokenPrivileges (hDupToken, m_pPrivilegeSet);

							if (result)
							{
								

								// Now use this token on the current thread
								if (SetThreadToken(NULL, hDupToken))
								{
									needToResetSecurity = true;
#ifdef WSCRPDEBUG
									CSWbemSecurity::PrintPrivileges (hDupToken);
#endif

									// Reset the blanket for the benefit of RPC
									DWORD	dwAuthnLevel, dwImpLevel;
									
									if (S_OK == GetAuthImp (m_pCurProxy, &dwAuthnLevel, &dwImpLevel))
									{
										// Force the cache to resecure the proxy
										IUnknown *pNewProxy = m_pProxyCache->GetProxy 
																((WbemAuthenticationLevelEnum) dwAuthnLevel, 
																 (WbemImpersonationLevelEnum) dwImpLevel, true);

										if (pNewProxy)
										{
											if (m_pCurProxy)
												m_pCurProxy->Release ();
											
											m_pCurProxy = pNewProxy;
										}
									}							
								}
								else
								{
									result = FALSE;
								}
								CloseHandle (hDupToken);
							}
							else
							{
								lastErr = GetLastError ();
							}
							
							/*
							 * If we are not using a thread token, close the token now. Otherwise
							 * the handle will be closed in the balanced call to RestorePrivileges ().
							 */
							if (!hThreadToken)
								CloseHandle (hToken);
						}
					}
					else
					{
						// For NT4 we adjust the privileges in the process token
						HANDLE hProcessToken = NULL;
						
						HANDLE hProcess = GetCurrentProcess ();
						result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hProcessToken); 
						CloseHandle (hProcess);
						
						// Adjust privilege on the process
						if (result)
						{
#ifdef WSCRPDEBUG
							CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
							result = CSWbemSecurity::AdjustTokenPrivileges (hProcessToken, m_pPrivilegeSet);
#ifdef WSCRPDEBUG
							CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
							CloseHandle (hProcessToken);
						}
					}
				}
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  SCODE CSWbemSecurity::ResetSecurity
//
//  DESCRIPTION:
//
//  Restore Privileges on the Thread Token.
//
//***************************************************************************

void	CSWbemSecurity::ResetSecurity (
	HANDLE hThreadToken
)
{
	// Win9x has no security palaver
	if (IsNT ())
	{
		/* 
		 * Set the supplied token (which may be NULL) into
		 * the current thread.
		 */
		BOOL result = SetThreadToken (NULL, hThreadToken);
		DWORD error = 0;

		if (!result)
			error = GetLastError ();
			
#ifdef WSCRPDEBUG
		// Print out the current privileges to see what's changed
		HANDLE hToken = NULL;

		if (!OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, false, &hToken))
		{
			// No thread token - go for the Process token instead
			HANDLE hProcess = GetCurrentProcess ();
			OpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
			CloseHandle (hProcess);
		}

		if (hToken)
		{
			PrintPrivileges (hToken);
			CloseHandle (hToken);
		}
#endif	
		if (hThreadToken)
				CloseHandle (hThreadToken);
	}
}

bool CSWbemSecurity::IsImpersonating (bool useDefaultUser, bool useDefaultAuthority)
{
	bool result = false;

	if (useDefaultUser && useDefaultAuthority && CSWbemSecurity::IsNT () && 
				(4 < CSWbemSecurity::GetNTMajorVersion ()))
	{
		// A suitable candidate - find out if we are running on an impersonated thread
		HANDLE hThreadToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, true, &hThreadToken))
		{
			// Check we have an impersonation token
			SECURITY_IMPERSONATION_LEVEL secImpLevel;

			DWORD dwReturnLength  = 0;
			if (GetTokenInformation (hThreadToken, TokenImpersonationLevel, &secImpLevel, 
									sizeof (SECURITY_IMPERSONATION_LEVEL), &dwReturnLength))
				result = ((SecurityImpersonation == secImpLevel) || (SecurityDelegation == secImpLevel));

			CloseHandle (hThreadToken);
		}
	}

	return result;
}

HRESULT CSWbemSecurity::GetAuthority (BSTR *bsAuthority)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pProxyCache)
	{
		*bsAuthority = SysAllocString(m_pProxyCache->GetAuthority ());
		hr = S_OK;
	}

	return hr;
}

HRESULT CSWbemSecurity::GetUPD (BSTR *bsUser, BSTR *bsPassword, BSTR *bsDomain)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pProxyCache)
	{
		COAUTHIDENTITY *pCoAuthIdentity = m_pProxyCache->GetCoAuthIdentity ();

		if (pCoAuthIdentity)
		{
			*bsUser = SysAllocString (pCoAuthIdentity->User);
			*bsPassword = SysAllocString (pCoAuthIdentity->Password);
			*bsDomain = SysAllocString (pCoAuthIdentity->Domain);
			WbemFreeAuthIdentity (pCoAuthIdentity);
		}
		
		hr = S_OK;
	}

	return hr;
}

HRESULT CSWbemSecurity::GetPrincipal (BSTR *bsPrincipal)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pProxyCache)
	{
		*bsPrincipal = SysAllocString(m_pProxyCache->GetPrincipal ());
		hr = S_OK;
	}

	return hr;
}

// CWbemLocatorSecurity methods

//***************************************************************************
//
// CSWbemLocatorSecurity::CSWbemLocatorSecurity
//
// CONSTRUCTOR
//
//***************************************************************************

CWbemLocatorSecurity::CWbemLocatorSecurity (CSWbemPrivilegeSet *pPrivilegeSet) :
	m_cRef (1),
	m_impLevelSet (false),
	m_authnLevelSet (false),
	m_pPrivilegeSet (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	InterlockedIncrement(&g_cObj);

	if (pPrivilegeSet)
		m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
	else
		m_pPrivilegeSet = new CSWbemPrivilegeSet;
}

CWbemLocatorSecurity::CWbemLocatorSecurity (CWbemLocatorSecurity *pCWbemLocatorSecurity) :
	m_cRef (1),
	m_impLevelSet (false),
	m_authnLevelSet (false),
	m_pPrivilegeSet (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	InterlockedIncrement(&g_cObj);

	if (pCWbemLocatorSecurity)
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet (pCWbemLocatorSecurity->m_pPrivilegeSet);
		
		m_impLevelSet = pCWbemLocatorSecurity->m_impLevelSet;
		m_authnLevelSet = pCWbemLocatorSecurity->m_authnLevelSet;
		
		if (m_impLevelSet)
			m_impLevel = pCWbemLocatorSecurity->m_impLevel;

		if (m_authnLevelSet)
			m_authnLevel = pCWbemLocatorSecurity->m_authnLevel;
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet;
		m_impLevelSet = false;
		m_authnLevelSet = false;
	}
}

//***************************************************************************
//
// CWbemLocatorSecurity::CWbemLocatorSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CWbemLocatorSecurity::~CWbemLocatorSecurity (void)
{
	InterlockedDecrement(&g_cObj);

	if (m_pPrivilegeSet)
		m_pPrivilegeSet->Release ();
}

//***************************************************************************
// HRESULT CWbemLocatorSecurity::QueryInterface
// long CWbemLocatorSecurity::AddRef
// long CWbemLocatorSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemLocatorSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWbemLocatorSecurity::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CWbemLocatorSecurity::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemLocatorSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CWbemLocatorSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_authnLevelSet)
	{
		*pAuthenticationLevel = m_authnLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::put_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Set the authentication level
//
//  PARAMETERS:
//
//		authenticationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::put_AuthenticationLevel (
	WbemAuthenticationLevelEnum authenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_AUTHN_LEVEL > authenticationLevel) || 
		(WBEMS_MAX_AUTHN_LEVEL < authenticationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		m_authnLevel = authenticationLevel;
		m_authnLevelSet = true;
		hr = WBEM_S_NO_ERROR;
	}
 	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_impLevelSet)
	{
		*pImpersonationLevel = m_impLevel;
		hr = WBEM_S_NO_ERROR;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::put_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Set the impersonation level
//
//  PARAMETERS:
//
//		impersonationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::put_ImpersonationLevel (
	WbemImpersonationLevelEnum impersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_IMP_LEVEL > impersonationLevel) || (WBEMS_MAX_IMP_LEVEL < impersonationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		m_impLevel = impersonationLevel;
		m_impLevelSet = true;
		hr = WBEM_S_NO_ERROR;
	}
 	 		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemLocatorSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	else			// Bug ID 566345
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::SetSecurity
//
//  DESCRIPTION:
//
//  Set Privileges on the Process Token.
//
//***************************************************************************

BOOL CWbemLocatorSecurity::SetSecurity (
	BSTR bsUser,
	bool &needToResetSecurity,
	HANDLE &hThreadToken
)
{
	BOOL result = TRUE;
	needToResetSecurity = false;
	hThreadToken = NULL;

	/*
	 * NT5 supports the concept of dynamic cloaking, which means
	 * we can set privileges temporarily on a thread (impersonation)
	 * token basis immediately before a call to a remoted proxy.  
	 *
	 * Setting prior to locator.connectserver therefore makes no 
	 * sense for NT5.
	 *
	 * Oh and Win9x has no security support
	 */
	if (CSWbemSecurity::IsNT () && (4 >= CSWbemSecurity::GetNTMajorVersion ()))
	{
		/*
		 * Start by checking whether we are being impersonated.  On an NT4
		 * box (which has no cloaking, and therefore cannot allow us to
		 * pass on this impersonation to Winmgmt) we should RevertToSelf
		 * if we have been configured to allow this.  If we haven't been
		 * configured to allow this, bail out now.
		 */
		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_IMPERSONATE, false, &hThreadToken))
		{
			// We are being impersonated
			if (CSWbemSecurity::CanRevertToSelf ())
			{
				if (result = RevertToSelf())
					needToResetSecurity = true;
			}
			else
			{
				// Error - cannot do this!  Time to bail out
				CloseHandle (hThreadToken);
				hThreadToken = NULL;
				result = FALSE;
			}
		}

		if (result && m_pPrivilegeSet)
		{
			/*
			 * Specifying a user only makes sense for remote operations, and we
			 * don't need to mess with privilege for remote operations since
			 * they are set up by server logon anyway.
			 */
			if (!bsUser || (0 == wcslen(bsUser)))
			{
				// Nothing to do unless some privilege overrides have been set
				long lCount = 0;
				m_pPrivilegeSet->get_Count (&lCount);

				if (0 < lCount)
				{
					/*
					 * For NT4 privilege settings on impersonation tokens are ignored
					 * by DCOM/RPC.  Hence we have to set this on the process token.
					 *
					 * On NT4 we must set the configured privileges on the Process
					 * Token before the first call to RPC (i.e. IWbemLocator::ConnectServer)
					 * if we need to guarantee privilege settings will be communicated to
					 * the server.  
					 *
					 * This is because (a) NT4 does not support cloaking to allow the 
					 * impersonation (i.e. thread) token privilege setting to propagate
					 * on a per-DCOM call basis, (b) changes to Process-token level
					 * privileges _may_ be ignored after the first remote DCOM call due
					 * to RPC caching behavior.
					 *
					 * Note that this is a non-reversible operation, and is highly discouraged
					 * on apps (such as IE and IIS) which host multiple "tasks" since it adjusts
					 * the Privilege set for all of the other threads in the process.
					 */

					HANDLE hProcess = GetCurrentProcess ();
					HANDLE hProcessToken = NULL;
					result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hProcessToken); 
					CloseHandle (hProcess);
					
					if (result)
					{
#ifdef WSCRPDEBUG
						CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
						result = CSWbemSecurity::AdjustTokenPrivileges (hProcessToken, m_pPrivilegeSet);
#ifdef WSCRPDEBUG
						CSWbemSecurity::PrintPrivileges (hProcessToken);
#endif
						CloseHandle (hProcessToken);
					}
				}
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  SCODE CWbemLocatorSecurity::ResetSecurity
//
//  DESCRIPTION:
//
//  Restore Privileges on the Thread Token.
//
//***************************************************************************

void	CWbemLocatorSecurity::ResetSecurity (
	HANDLE hThreadToken
)
{
	// Win9x has no concept of impersonation
	// On NT5 we never set privileges through this class anyway
	if (CSWbemSecurity::IsNT () && (4 >= CSWbemSecurity::GetNTMajorVersion ()) 
				&& hThreadToken)
	{
		/* 
		 * Set the supplied token back into
		 * the current thread.
		 */
		BOOL result = SetThreadToken (NULL, hThreadToken);
		
#ifdef WSCRPDEBUG
		// Print out the current privileges to see what's changed
		HANDLE hToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, false, &hToken))
		{
			// No thread token - go for the Process token instead
			HANDLE hProcess = GetCurrentProcess ();
			OpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
			CloseHandle (hProcess);
		}

		if (hToken)
		{
			CSWbemSecurity::PrintPrivileges (hToken);
			CloseHandle (hToken);
		}
#endif	
		CloseHandle (hThreadToken);
	}
}
//***************************************************************************
//
//  SCODE CSWbemSecurity::MapImpersonationLevel
//
//  DESCRIPTION:
//
//  Function to map enum value of WbemImpersonationLevelEnum to SECURITY_IMPERSONATION_LEVEL
//
//***************************************************************************
SECURITY_IMPERSONATION_LEVEL CSWbemSecurity::MapImpersonationLevel(WbemImpersonationLevelEnum ImpersonationLevel)
{
	SECURITY_IMPERSONATION_LEVEL ret = SecurityAnonymous;
	switch (ImpersonationLevel)
	{
		case wbemImpersonationLevelAnonymous:
			ret = SecurityAnonymous;
			break;
		
		case wbemImpersonationLevelIdentify:
			ret = SecurityIdentification;
			break;
		
		case wbemImpersonationLevelImpersonate:
			ret = SecurityImpersonation;
			break;

		case wbemImpersonationLevelDelegate:
			ret = SecurityDelegation;
			break;

		default:
			break;
	}
	return ret;
}


#ifdef WSCRPDEBUG

//***************************************************************************
//
//  SCODE CSWbemSecurity::PrintPrivileges
//
//  DESCRIPTION:
//
//  Debug logging for privileges and other token info
//
//***************************************************************************

void CSWbemSecurity::PrintPrivileges (HANDLE hToken)
{
	DWORD dwSize = sizeof (TOKEN_PRIVILEGES);
	TOKEN_PRIVILEGES *tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];

	if (!tp)
	{
		return;
	}

	DWORD dwRequiredSize = 0;
	DWORD dwLastError = 0;
	FILE *fDebug = fopen ("C:/temp/wmidsec.txt", "a+");
	fprintf (fDebug, "\n\n***********************************************\n\n");
	bool status = false;

	// Step 0 - get impersonation level
	SECURITY_IMPERSONATION_LEVEL secImpLevel;
	if (GetTokenInformation (hToken, TokenImpersonationLevel, &secImpLevel, 
											sizeof (SECURITY_IMPERSONATION_LEVEL), &dwRequiredSize))
	{
		switch (secImpLevel)
		{
			case SecurityAnonymous:
				fprintf (fDebug, "IMPERSONATION LEVEL: Anonymous\n");
				break;
			
			case SecurityIdentification:
				fprintf (fDebug, "IMPERSONATION LEVEL: Identification\n");
				break;
			
			case SecurityImpersonation:
				fprintf (fDebug, "IMPERSONATION LEVEL: Impersonation\n");
				break;

			case SecurityDelegation:
				fprintf (fDebug, "IMPERSONATION LEVEL: Delegation\n");
				break;

			default:
				fprintf (fDebug, "IMPERSONATION LEVEL: Unknown!\n");
				break;
		}
	
		fflush (fDebug);
	}

	DWORD dwUSize = sizeof (TOKEN_USER);
	TOKEN_USER *tu = (TOKEN_USER *) new BYTE [dwUSize];

	if (!tu)
	{
		delete [] tp;
		fclose (fDebug);
		return;
	}

	// Step 1 - get user info
	if (0 ==  GetTokenInformation (hToken, TokenUser, 
						(LPVOID) tu, dwUSize, &dwRequiredSize))
	{
		delete [] tu;
		dwUSize = dwRequiredSize;
		dwRequiredSize = 0;
		tu = (TOKEN_USER *) new BYTE [dwUSize];

		if (!tu)
		{
			delete [] tp;
			fclose (fDebug);
			return;
		}

		if (!GetTokenInformation (hToken, TokenUser, (LPVOID) tu, dwUSize, 
							&dwRequiredSize))
			dwLastError = GetLastError ();
		else
			status = true;
	}

	if (status)
	{
		// Dig out the user info
		dwRequiredSize = BUFSIZ;
		char *userName = new char [dwRequiredSize];
		char *domainName = new char [dwRequiredSize];

		if (!userName || !domainName)
		{
			delete [] tp;
			delete [] tu;
			delete [] userName;
			delete [] domainName;
			return;
		}

		SID_NAME_USE eUse;

		LookupAccountSid (NULL, (tu->User).Sid, userName, &dwRequiredSize,
								domainName, &dwRequiredSize, &eUse);

		fprintf (fDebug, "USER: [%s\\%s]\n", domainName, userName);
		fflush (fDebug);
		delete [] userName;
		delete [] domainName;
	}
	else
	{
		fprintf (fDebug, " FAILED : %d\n", dwLastError);
		fflush (fDebug);
	}
	
	delete [] tu;
	status = false;
	dwRequiredSize = 0;

	// Step 2 - get privilege info
	if (0 ==  GetTokenInformation (hToken, TokenPrivileges, 
						(LPVOID) tp, dwSize, &dwRequiredSize))
	{
		delete [] tp;
		dwSize = dwRequiredSize;
		dwRequiredSize = 0;

		tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];

		if (!tp)
		{
			fclose (fDebug);
			return;
		}

		if (!GetTokenInformation (hToken, TokenPrivileges, 
						(LPVOID) tp, dwSize, &dwRequiredSize))
		{
			dwLastError = GetLastError ();
		}
		else
			status = true;
	}
	else
		status = true;

	if (status)
	{
		fprintf (fDebug, "PRIVILEGES: [%d]\n", tp->PrivilegeCount);
		fflush (fDebug);
	
		for (DWORD i = 0; i < tp->PrivilegeCount; i++)
		{
			DWORD dwNameSize = 256;
			LPTSTR name = new TCHAR [dwNameSize + 1];

			if (!name)
			{
				delete [] tp;
				fclose (fDebug);
				return;
			}

			DWORD dwRequiredSize = dwNameSize;

			if (LookupPrivilegeName (NULL, &(tp->Privileges [i].Luid), name, &dwRequiredSize))
			{
				BOOL enabDefault = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT);
				BOOL enabled = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED);
				BOOL usedForAccess (tp->Privileges [i].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS);

				fprintf (fDebug, " %s: enabledByDefault=%d enabled=%d usedForAccess=%d\n", 
							name, enabDefault, enabled, usedForAccess);
				fflush (fDebug);
			}
			else
			{
				dwLastError = GetLastError ();
				delete [] name;
				dwNameSize = dwRequiredSize;
				name = new TCHAR [dwRequiredSize];

				if (!name)
				{
					delete [] tp;
					fclose (fDebug);
					return;
				}

				if (LookupPrivilegeName (NULL, &(tp->Privileges [i].Luid), name, &dwRequiredSize))
				{
					BOOL enabDefault = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT);
					BOOL enabled = (tp->Privileges [i].Attributes & SE_PRIVILEGE_ENABLED);
					BOOL usedForAccess (tp->Privileges [i].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS);
					fprintf (fDebug, " %s: enabledByDefault=%d enabled=%d usedForAccess=%d\n", 
							name, enabDefault, enabled, usedForAccess);
					fflush (fDebug);
				}
				else
					dwLastError = GetLastError ();
			}

			delete [] name;
		}
	}
	else
	{
		fprintf (fDebug, " FAILED : %d\n", dwLastError);
		fflush (fDebug);
	}

	delete [] tp;
	fclose (fDebug);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\services.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  services.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemServices definition.
//
//***************************************************************************

#ifndef _SERVICES_H_
#define _SERVICES_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemServices
//
//  DESCRIPTION:
//
//  Implements the IWbemSServices interface.  
//
//***************************************************************************

class CSWbemServices : public ISWbemServicesEx,
					   public IDispatchEx,
					   public ISupportErrorInfo,
					   public ISWbemInternalServices,
					   public IProvideClassInfo
{
private:

	CComBSTR				m_bsNamespacePath;
	BSTR					m_bsLocale;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity*			m_SecurityInfo;
	IServiceProvider		*m_pIServiceProvider;
	IUnsecuredApartment		*m_pUnsecuredApartment;

	static BSTR			BuildPath (BSTR bsClassName, VARIANT *pKeyValue);
	static BSTR			BuildPath (BSTR bsClassName, 
							/*ISWbemNamedValueSet*/ IDispatch *pCompoundKeys);

protected:
	long            m_cRef;         //Object reference count

public:
    
	CSWbemServices (IWbemServices *pIWbemServices, 
					BSTR bsNamespacePath,
					BSTR bsAuthority, BSTR bsUser, BSTR bsPassword,
					CWbemLocatorSecurity *pSecurity = NULL,
					BSTR bsLocale = NULL);

	CSWbemServices (IWbemServices *pIWbemServices,
					BSTR bsNamespacePath,
					COAUTHIDENTITY *pCoAuthIdentity,
					BSTR bsPrincipal,
					BSTR bsAuthority);

	CSWbemServices (CSWbemServices *pService, CSWbemSecurity *pSecurity);

	CSWbemServices (ISWbemInternalServices *pService);

	CSWbemServices (IWbemServices *pIWbemServices, CSWbemServices *pServiceb);

	IUnsecuredApartment *GetCachedUnsecuredApartment();

    ~CSWbemServices(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods should be inline

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

	// IDispatchEx methods should be inline
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id);
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex);
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName);
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
	
    
	// ISWbemInternalServices methods
	STDMETHODIMP GetIWbemServices (IWbemServices **ppService);

	STDMETHODIMP GetNamespacePath (BSTR *bsNamespacePath)
	{
		HRESULT hr = WBEM_E_FAILED;

		if (bsNamespacePath) 
			hr = m_bsNamespacePath.CopyTo (bsNamespacePath);
		
		return hr;
	}

	STDMETHODIMP GetLocale (BSTR *bsLocale)
	{
		HRESULT hr = WBEM_E_FAILED;

		if (bsLocale)
		{
			*bsLocale = SysAllocString (GetLocale ());
			hr = S_OK;
		}

		return hr;
	}

	STDMETHODIMP GetISWbemInternalSecurity (ISWbemInternalSecurity **ppISWbemInternalSecurity)
	{
		HRESULT hr = WBEM_E_FAILED;

		if (ppISWbemInternalSecurity && m_SecurityInfo)
		{
			m_SecurityInfo->QueryInterface (IID_ISWbemInternalSecurity, (void**) ppISWbemInternalSecurity);
			hr = S_OK;
		}

		return hr;
	}
					   
	// ISWbemServices methods

	HRESULT STDMETHODCALLTYPE  Get
	(
        /*[in]*/	BSTR objectPath,
		/*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
	    /*[out]*/	ISWbemObject **ppObject
    );

	HRESULT STDMETHODCALLTYPE Delete
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext
    );

	HRESULT STDMETHODCALLTYPE InstancesOf
	(
        /*[in]*/	BSTR className,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );

	HRESULT STDMETHODCALLTYPE ExecQuery 
	(
        /*[in]*/	BSTR Query,
        /*[in]*/	BSTR QueryLanguage,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
		/*[out]*/	ISWbemObjectSet **ppEnum
    );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery
	(
        /*[in]*/	BSTR Query,
        /*[in]*/	BSTR QueryLanguage,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemEventSource **ppEnum
    );

	HRESULT STDMETHODCALLTYPE AssociatorsOf
	(
		/*[in]*/	BSTR objectPath,
		/*[in]*/	BSTR assocClass,
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR resultRole,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredAssocQualifier,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE ReferencesTo
	(
		/*[in]*/	BSTR objectPath,
		/*[in]*/	BSTR resultClass,
		/*[in]*/	BSTR role,
		/*[in]*/	VARIANT_BOOL classesOnly,
		/*[in]*/	VARIANT_BOOL schemaOnly,
		/*[in]*/	BSTR requiredQualifier,
		/*[in]*/	long lFlags,
		/*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObjectSet **ppEnum
	);

	HRESULT STDMETHODCALLTYPE ExecMethod 
	(
        /*[in]*/	BSTR className,
        /*[in]*/	BSTR methodName,
        /*[in]*/	/*ISWbemObject*/ IDispatch *pInParams,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,
        /*[out]*/	ISWbemObject **ppOutParams
    );

    HRESULT STDMETHODCALLTYPE SubclassesOf
	(
        /*[in]*/	BSTR superclass,
        /*[in]*/	long lFlags,
        /*[in]*/	/*ISWbemNamedValueSet*/ IDispatch *pContext,        
        /*[out]*/	ISWbemObjectSet **ppEnum
    );


	HRESULT STDMETHODCALLTYPE GetAsync
	(
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strObjectPath,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE DeleteAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strObjectPath,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE InstancesOfAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strClass,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE SubclassesOfAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [defaultvalue][optional][in] */ BSTR strSuperclass,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ExecQueryAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR Query,
		/* [defaultvalue][optional][in] */ BSTR QueryLanguage,
		/* [defaultvalue][optional][in] */ long lFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE AssociatorsOfAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strObjectPath,
		/* [defaultvalue][optional][in] */ BSTR strAssocClass,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strResultRole,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ReferencesToAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR objectPath,
		/* [defaultvalue][optional][in] */ BSTR strResultClass,
		/* [defaultvalue][optional][in] */ BSTR strRole,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
		/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
		/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR Query,
		/* [defaultvalue][optional][in] */ BSTR strQueryLanguage,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE ExecMethodAsync
	( 
		/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
		/* [in] */ BSTR strObjectPath,
		/* [in] */ BSTR strMethodName,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
	);
        
	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISWbemServicesEx methods
	
	HRESULT STDMETHODCALLTYPE Put(
		/* [in] */ ISWbemObjectEx *objWbemObject,
       	/* [in] */ long iFlags,
		/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/* [out, retval] */ ISWbemObjectPath **objWbemObjectPath
        );

	HRESULT STDMETHODCALLTYPE PutAsync(
		/* [in] */ ISWbemSink *objWbemSink,
		/* [in] */ ISWbemObjectEx *objWbemObject,
       	/* [in] */ long iFlags,
		/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objWbemNamedValueSet,
		/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objWbemAsyncContext
        );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods

	CSWbemSecurity *GetSecurityInfo ()
	{
		CSWbemSecurity *pInfo = NULL;

		if (m_SecurityInfo)
		{
			pInfo = m_SecurityInfo;
			pInfo->AddRef ();
		}

		return pInfo;
	}

	BSTR GetLocale ()
	{
		return m_bsLocale;
	}

	const CComBSTR & GetPath ()
	{
		return m_bsNamespacePath;
	}

	HRESULT CancelAsyncCall(IWbemObjectSink *sink);

	IWbemServices *GetIWbemServices ()
	{
		IWbemServices *pService = NULL;
		
		if (m_SecurityInfo)
			pService = (IWbemServices *) m_SecurityInfo->GetProxy ();

		return pService;
	}

	static IWbemServices	*GetIWbemServices (IDispatch *pDispatch);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\sink.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  SINK.CPP
//
//  rogerbo  21-May-98   Created.
//
//  Defines the implementation of ISWbemSink
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"
#include <olectl.h>

#define NUM_ON_OBJECT_READY_ARGS			2
#define NUM_ON_CONNECTION_READY_ARGS		2
#define NUM_ON_COMPLETED_ARGS				3
#define NUM_ON_PROGRESS_ARGS				4
#define NUM_ON_OBJECT_PUT_ARGS				2
#define NUM_ON_OBJECT_SECURITY_READY_ARGS	2

#define SINKS_MAX 2


//***************************************************************************
//
//  CSWbemSink::CSWbemSink
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************


CSWbemSink::CSWbemSink()
{
	_RD(static char *me = "CSwbemSink::CSWbemSink";)

	m_pPrivateSink = NULL;
	m_nSinks = 0;
	m_nMaxSinks = SINKS_MAX;
    m_cRef=0;
	m_Dispatch.SetObj(this, IID_ISWbemSink, CLSID_SWbemSink, L"SWbemSink");

	_RPrint(me, "===============================================", 0, "");
	_RPrint(me, "", 0, "");

	// Allocate list of CWbemObjectSink 
	m_rgpCWbemObjectSink = (WbemObjectListEntry *)malloc(m_nMaxSinks * sizeof(WbemObjectListEntry));

	if (m_rgpCWbemObjectSink)
	{
		for(int count = 0; count < m_nMaxSinks; count++)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = NULL;
			m_rgpCWbemObjectSink[count].pServices = NULL;
		}
	}

    // Initialize all the connection points to NULL
	for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
        m_rgpConnPt[count] = NULL;

	// Create our connection point
	if (m_rgpConnPt[0] = new CConnectionPoint(this, DIID_ISWbemSinkEvents))
		m_rgpConnPt[0]->AddRef();

	// Additional connection points could be instantiated here

    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemSink::~CSWbemSink
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemSink::~CSWbemSink(void)
{
	_RD(static char *me = "CSWbemSink::~CSWbemSink";)
	_RPrint(me, "", 0, "");

	if (m_pPrivateSink)
	{
		// Make sure we don't hook back to ourselves any more
		// as this CSWbemSink is about to expire
		m_pPrivateSink->Detach ();

		// Release our hold on the private sink
		m_pPrivateSink->Release ();
		m_pPrivateSink = NULL;
	}

    for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
        if(m_rgpConnPt[count] != NULL)
	        delete m_rgpConnPt[count];

	free(m_rgpCWbemObjectSink);

    InterlockedDecrement(&g_cObj);
	_RPrint(me, "After decrement count is", (long)g_cObj, "");
}

//***************************************************************************
// HRESULT CSWbemSink::QueryInterface
// long CSWbemSink::AddRef
// long CSWbemSink::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSink::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid) 
		*ppv = reinterpret_cast<IUnknown *>(this);
	else if (IID_ISWbemSink==riid)
		*ppv = (ISWbemSink *)this;
	else if (IID_IDispatch==riid) 
		*ppv = (IDispatch *) this;
	else if (IID_IConnectionPointContainer==riid)
		*ppv = (IConnectionPointContainer *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;
	else if (IID_IProvideClassInfo2==riid)
		*ppv = (IProvideClassInfo2 *)this;
//	else if (IID_ISWbemPrivateSink==riid)
//		*ppv = (ISWbemPrivateSink *)(&m_privateSink); // Private I/F counting
	else if (IID_ISWbemPrivateSinkLocator==riid)
		*ppv = (ISWbemPrivateSinkLocator *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemSink::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemSink::Release(void)
{
	_RD(static char *me = "CSWbemSink::Release";)

	/*
	 * If the only refs that are left are those from 
	 * CWbemPrivateSink then initiate a cancel on all 
	 * remaining sinks.  This is because there are no 
	 * client refs to CSWbemSinks left, therefore queries
	 * in progress can be of no use.  First make sure we
	 * do an Unadvise for all the connection points.  
	 */
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0!=cRef)
	{
	    _ASSERT(cRef > 0);
        return cRef;
	}
	else
	{
		// We are about to blow away this SWbemSink, so
		// make sure we clean up any orphaned IWbemObjectSink's
		// by unadvising and cancelling the underlying WMI calls
		if(m_pPrivateSink)
			m_pPrivateSink->Detach();

		if (m_rgpConnPt[0])
		{
			m_rgpConnPt[0]->UnadviseAll();
		}

   		Cancel();
	}

    delete this;
    return 0;
}
		
//***************************************************************************
// HRESULT CSWbemSink::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemSink::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSink == riid) ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::Cancel()
{
	_RD(static char *me = "CSWbemSink::Cancel";)

	ResetLastErrors ();

	if (!m_nSinks)
		return S_OK;

	_RPrint(me, "!!!Cancel called", 0, "");

	/* 
	 * Take a copy of the sinks, this can change under our feet
	 * As the Cancel can cause us to be re-entered.  No need to 
	 * take a copy of m_nMaxSinks as this isn't used when cancels
	 * are occuring.
	 * Make sure we AddRef the sink so that it can't be blown away 
	 * under our feet by a re-entrant call to OnCompleted
	 */
	HRESULT hr = WBEM_E_FAILED;
	int nSinks = m_nSinks;
	WbemObjectListEntry *rgpCWbemObjectSink = 
				(WbemObjectListEntry *)malloc(nSinks * sizeof(WbemObjectListEntry));

	if (!rgpCWbemObjectSink)
		hr = WBEM_E_OUT_OF_MEMORY;
	else
	{
		int actual = 0;
		for (int i = 0; i < m_nMaxSinks; i++)
		{
			if (m_rgpCWbemObjectSink[i].pWbemObjectWrapper)
			{
				m_rgpCWbemObjectSink[i].pWbemObjectWrapper->AddRef();

				if (m_rgpCWbemObjectSink[i].pServices)
					m_rgpCWbemObjectSink[i].pServices->AddRef();

				rgpCWbemObjectSink[actual++] = m_rgpCWbemObjectSink[i];
			}
		}


		/*
		 * Now do the actual cancel  
		 */
		for (i = 0; i < nSinks; i++) {
			if (rgpCWbemObjectSink[i].pWbemObjectWrapper) {
				IWbemObjectSink *pSink = NULL;
				if (SUCCEEDED(rgpCWbemObjectSink[i].pWbemObjectWrapper->QueryInterface
													(IID_IWbemObjectSink, (PPVOID)&pSink)))
				{
					if (rgpCWbemObjectSink[i].pServices)
						rgpCWbemObjectSink[i].pServices->CancelAsyncCall(pSink);

					pSink->Release();
				}
				rgpCWbemObjectSink[i].pWbemObjectWrapper->Release();

				if (rgpCWbemObjectSink[i].pServices)
					rgpCWbemObjectSink[i].pServices->Release();
			}
		}
		free(rgpCWbemObjectSink);
		hr = S_OK;
	}

	return hr;
}

HRESULT CSWbemSink::EnumConnectionPoints(IEnumConnectionPoints** ppEnum)
{
	HRESULT hr = E_FAIL;

	if (!ppEnum)
		hr = E_POINTER;
	else
	{
		CEnumConnectionPoints* pEnum = new CEnumConnectionPoints(reinterpret_cast<IUnknown*>(this), (void**)m_rgpConnPt);

		if (!pEnum)
			hr = E_OUTOFMEMORY;
		else if (FAILED(hr = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum)))
			delete pEnum;
	}

	return hr;
}

HRESULT CSWbemSink::FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP)
{
	HRESULT hr = E_FAIL;

	if(riid == DIID_ISWbemSinkEvents)
	{
		if (!ppCP)
			hr = E_POINTER;
		else if (m_rgpConnPt [0])
			hr = m_rgpConnPt[0]->QueryInterface(IID_IConnectionPoint, (void**)ppCP);
	}
	else
		hr = E_NOINTERFACE;

	return hr;
}

HRESULT CSWbemSink::GetClassInfo(ITypeInfo** pTypeInfo)
{
	HRESULT hr = E_FAIL;

	if (!pTypeInfo)
		hr = E_POINTER;
	else
	{
		CComPtr<ITypeLib> pTypeLib;

		if (SUCCEEDED(LoadRegTypeLib(LIBID_WbemScripting, 1, 0, LANG_NEUTRAL, &pTypeLib)))
			hr = pTypeLib->GetTypeInfoOfGuid(CLSID_SWbemSink, pTypeInfo);
	}

	return hr;
}

HRESULT CSWbemSink::GetGUID(DWORD dwGuidKind, GUID* pGUID)
{
	if(pGUID == NULL)
		return E_INVALIDARG;
	*pGUID = DIID_ISWbemSinkEvents;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::AddObjectSink(
							/* [in] */ IUnknown __RPC_FAR *pSink,
							/* [in] */ IWbemServices __RPC_FAR *pServices)
{
	if(m_nSinks == m_nMaxSinks)
	{
		// Expand the size of the sink list
		void *newList = realloc(m_rgpCWbemObjectSink,(m_nMaxSinks + SINKS_MAX) * sizeof(WbemObjectListEntry));
		if (!newList) //realloc failed
			return E_OUTOFMEMORY;

		m_rgpCWbemObjectSink = (WbemObjectListEntry *)newList;

		// Initialize new bit
		for(int count = m_nMaxSinks; count < (m_nMaxSinks + SINKS_MAX); count++)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = NULL;
			m_rgpCWbemObjectSink[count].pServices = NULL;
		}

		m_nMaxSinks += SINKS_MAX;
	}

	for(int count = 0; count < m_nMaxSinks; count++)
		if(m_rgpCWbemObjectSink[count].pWbemObjectWrapper == NULL)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = pSink;
			m_rgpCWbemObjectSink[count].pServices = pServices;
			break;
		}
	m_nSinks++;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::RemoveObjectSink(/* [in] */ IUnknown __RPC_FAR *pSink)
{
	for(int count = 0; count < m_nMaxSinks; count++)
		if(pSink == m_rgpCWbemObjectSink[count].pWbemObjectWrapper)
		{
			m_rgpCWbemObjectSink[count].pWbemObjectWrapper = NULL;
			m_nSinks--;
		}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::OnObjectReady( 
		/* [in] */ IDispatch __RPC_FAR *pObject,
		/* [in] */ IDispatch __RPC_FAR *pContext)
{ 
	if (m_rgpConnPt[0])
	{
		m_rgpConnPt[0]->OnObjectReady(pObject, pContext); 
	}
	else
	{
		return E_FAIL;
	}

	return 0;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::OnCompleted( 
		/* [in] */ HRESULT hResult,
		/* [in] */ IDispatch __RPC_FAR *path,
		/* [in] */ IDispatch __RPC_FAR *pErrorObject,
		/* [in] */ IDispatch __RPC_FAR *pContext)
{
	if (m_rgpConnPt[0])
	{
		m_rgpConnPt[0]->OnCompleted(hResult, pErrorObject, path, pContext); 
	}
	else
	{
		return E_FAIL;
	}

	return 0;
}
        
HRESULT STDMETHODCALLTYPE CSWbemSink::OnProgress( 
		/* [in] */ long upperBound,
		/* [in] */ long current,
		/* [in] */ BSTR message,
		/* [in] */ IDispatch __RPC_FAR *pContext)
{
	if (m_rgpConnPt[0])
	{
		m_rgpConnPt[0]->OnProgress(upperBound, current, message, pContext); 
	}
	else
	{
		return E_FAIL;
	}

	return 0;
}

HRESULT STDMETHODCALLTYPE CSWbemSink::GetPrivateSink(
		/* [out] */ IUnknown **objWbemPrivateSink)
{
	HRESULT hr = E_FAIL;

	if (objWbemPrivateSink)
	{
		if(!m_pPrivateSink)
		{
			if (m_pPrivateSink = new CSWbemPrivateSink(this))
				m_pPrivateSink->AddRef ();		// Released in destructor
		}

		if (m_pPrivateSink)
			hr = m_pPrivateSink->QueryInterface(IID_IUnknown, (PPVOID)objWbemPrivateSink);
	}
	else
		hr = E_POINTER;

	return hr;
}

// void** rpgCP is used so that this constructor can accept either CConnectionPoint**
// from CSWbemSink::EnumConnectionPoints or IConnectionPoint** from CEnumConnectionPoints::Clone
// This could also be done by overloading the constructor and duplicating some of this code
CEnumConnectionPoints::CEnumConnectionPoints(IUnknown* pUnkRef, void** rgpCP) : m_cRef(0)
{
	m_iCur = 0;
    m_pUnkRef = pUnkRef;

	// m_rgpCP is a pointer to an array of IConnectionPoints or CConnectionPoints
	for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
		((IUnknown*)rgpCP[count])->QueryInterface(IID_IConnectionPoint, (void**)&m_rgpCP[count]);
    InterlockedIncrement(&g_cObj);
}

CEnumConnectionPoints::~CEnumConnectionPoints()
{
	if(m_rgpCP != NULL)
		for(int count = 0; count < NUM_CONNECTION_POINTS; count++)
			m_rgpCP[count]->Release();

    InterlockedDecrement(&g_cObj);
}

ULONG CEnumConnectionPoints::AddRef()
{
	m_pUnkRef->AddRef();
	return ++m_cRef;
}

ULONG CEnumConnectionPoints::Release()
{

	m_pUnkRef->Release();
	LONG cRef = InterlockedDecrement(&m_cRef);
	
	if(cRef != 0)
	{
	    _ASSERT(cRef > 0);
        return cRef;
    }
    
    
    delete this;
    return 0;
}

HRESULT CEnumConnectionPoints::QueryInterface(REFIID riid, void** ppv)
{
	if(riid == IID_IUnknown || riid == IID_IEnumConnectionPoints)
		*ppv = (IEnumConnectionPoints*)this;
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

HRESULT CEnumConnectionPoints::Next(ULONG cConnections, IConnectionPoint** rgpcn, ULONG* pcFetched)
{
	if(rgpcn == NULL)
		return E_POINTER;
	if(pcFetched == NULL && cConnections != 1)
		return E_INVALIDARG;
	if(pcFetched != NULL)
		*pcFetched = 0;

	while(m_iCur < NUM_CONNECTION_POINTS && cConnections > 0)
	{
		*rgpcn = m_rgpCP[m_iCur++];
		if(*rgpcn != NULL)
			(*rgpcn)->AddRef();
		if(pcFetched != NULL)
			(*pcFetched)++;
		cConnections--;
		rgpcn++;
	}
	return S_OK;
}

HRESULT CEnumConnectionPoints::Skip(ULONG cConnections)
{
	if(m_iCur + cConnections >= NUM_CONNECTION_POINTS)
		return S_FALSE;
    m_iCur += cConnections;
    return S_OK;
}

HRESULT CEnumConnectionPoints::Reset()
{
    m_iCur = 0;
    return S_OK;
}

HRESULT CEnumConnectionPoints::Clone(IEnumConnectionPoints** ppEnum)
{
	if(ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;

    // Create the clone
    CEnumConnectionPoints* pNew = new CEnumConnectionPoints(m_pUnkRef, (void**)m_rgpCP);
    if(pNew == NULL)
        return E_OUTOFMEMORY;

    pNew->AddRef();
    pNew->m_iCur = m_iCur;
    *ppEnum = pNew;
    return S_OK;
}

CConnectionPoint::CConnectionPoint(CSWbemSink* pObj, REFIID riid) : 
					m_cRef(0),
					m_rgnCookies(NULL),
					m_rgpUnknown(NULL)
{
    m_iid = riid;
	m_nMaxConnections = CCONNMAX;

	m_rgnCookies = (unsigned *)malloc(m_nMaxConnections * sizeof(unsigned));
	m_rgpUnknown = (IUnknown **)malloc(m_nMaxConnections * sizeof(IUnknown *));

	// Don't need AddRef/Release since we are nested inside CSWbemSink
    m_pObj = pObj;
    for(int count = 0; count < m_nMaxConnections; count++)
        {
			if (m_rgpUnknown)
				m_rgpUnknown[count] = NULL;

			if (m_rgnCookies)
				m_rgnCookies[count] = 0;
        }
    m_cConn = 0;
    m_nCookieNext = 10; // Arbitrary starting cookie value

    InterlockedIncrement(&g_cObj);
}

CConnectionPoint::~CConnectionPoint()
{
	if (m_rgpUnknown)
	{
		for(int count = 0; count < m_nMaxConnections; count++)
			if(m_rgpUnknown[count] != NULL)
			{
				m_rgpUnknown[count]->Release();
				m_rgpUnknown[count] = NULL;
			}

		free(m_rgpUnknown);
	}

	if (m_rgnCookies)
		free(m_rgnCookies);
	
    InterlockedDecrement(&g_cObj);
}

HRESULT CConnectionPoint::QueryInterface(REFIID riid, void** ppv)
{
    if(IID_IUnknown == riid || IID_IConnectionPoint == riid)
        *ppv = (IConnectionPoint*)this;
    else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

ULONG CConnectionPoint::AddRef()
    {
    return ++m_cRef;
    }

ULONG CConnectionPoint::Release()
{

	LONG cRef = InterlockedDecrement(&m_cRef);
	
	if(cRef != 0)
	{
	    _ASSERT(cRef > 0);
        return cRef;
    }
    
    delete this;
    return 0;
}

HRESULT CConnectionPoint::GetConnectionInterface(IID *pIID)
{
	if(pIID == NULL)
		return E_POINTER;
	*pIID = m_iid;
	return S_OK;
}

HRESULT CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
	return m_pObj->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
}

HRESULT CConnectionPoint::Advise(IUnknown* pUnknownSink, DWORD* pdwCookie)
{
	IUnknown* pSink;
	*pdwCookie = 0;
	_RD(static char *me = "CConnectionPoint::Advise";)

	_RPrint(me, "Current connections (before adjustment): ", (long)m_cConn, "");
	if(m_cConn == m_nMaxConnections)
	{
		//return CONNECT_E_ADVISELIMIT;
		// Expand the size of the connection lists
		void *tempMem = realloc(m_rgnCookies, (m_nMaxConnections + CCONNMAX) * sizeof(unsigned));
		if (!tempMem) //realloc failed
			return E_OUTOFMEMORY;
		m_rgnCookies = (unsigned *)tempMem;

		tempMem = realloc(m_rgpUnknown, (m_nMaxConnections + CCONNMAX) * sizeof(IUnknown *));
		if (!tempMem)
			return E_OUTOFMEMORY;
		m_rgpUnknown = (IUnknown **)tempMem;

		// Initialize new bit
		for(int count = m_nMaxConnections; count < (m_nMaxConnections + CCONNMAX); count++)
			{
			m_rgpUnknown[count] = NULL;
			m_rgnCookies[count] = 0;
			}

		m_nMaxConnections += CCONNMAX;
	}

	if(FAILED(pUnknownSink->QueryInterface(m_iid, (void**)&pSink)))
		return CONNECT_E_CANNOTCONNECT;
	for(int count = 0; count < m_nMaxConnections; count++)
		if(m_rgpUnknown[count] == NULL)
		{
			m_rgpUnknown[count] = pSink;
			m_rgnCookies[count] = ++m_nCookieNext;
			*pdwCookie = m_nCookieNext;
			break;
		}
	m_cConn++;

	return NOERROR;
}

HRESULT CConnectionPoint::Unadvise(DWORD dwCookie)
{
	_RD(static char *me = "CConnectionPoint::Unadvise";)

	_RPrint(me, "Current connections (before adjustment): ", (long)m_cConn, "");
	if(dwCookie == 0)
		return E_INVALIDARG;
	for(int count = 0; count < m_nMaxConnections; count++)
		if(dwCookie == m_rgnCookies[count])
		{
			if(m_rgpUnknown[count] != NULL)
			{
				m_rgpUnknown[count]->Release();
				m_rgpUnknown[count] = NULL;
				m_rgnCookies[count] = 0;
			}
			m_cConn--;
			return NOERROR;
		}
	return CONNECT_E_NOCONNECTION;
}

HRESULT CConnectionPoint::EnumConnections(IEnumConnections** ppEnum)
{
	HRESULT hr = E_FAIL;

	if (!ppEnum)
		hr = E_POINTER;
	else
	{
		*ppEnum = NULL;
		CONNECTDATA* pCD = new CONNECTDATA[m_cConn];

		if (!pCD)
			hr = E_OUTOFMEMORY;
		else
		{
			for(int count1 = 0, count2 = 0; count1 < m_nMaxConnections; count1++)
				if(m_rgpUnknown[count1] != NULL)
				{
					pCD[count2].pUnk = (IUnknown*)m_rgpUnknown[count1];
					pCD[count2].dwCookie = m_rgnCookies[count1];
					count2++;
				}
			
			CEnumConnections* pEnum = new CEnumConnections(this, m_cConn, pCD);
			delete [] pCD;

			if (!pEnum)
				hr = E_OUTOFMEMORY;
			else
				hr = pEnum->QueryInterface(IID_IEnumConnections, (void**)ppEnum);
		}
	}

	return hr;
}

void CConnectionPoint::UnadviseAll() {
	_RD(static char *me = "CConnectionPoint::UnadviseAll";)

	_RPrint(me, "Current connections (before adjustment): ", (long)m_cConn, "");
	for(int count = 0; count < m_nMaxConnections; count++) {
		if(m_rgpUnknown[count] != NULL)
		{
			m_rgpUnknown[count]->Release();
			m_rgpUnknown[count] = NULL;
			m_rgnCookies[count] = 0;
			m_cConn--;
		}
	}
	_RPrint(me, "Current connections (after adjustment): ", (long)m_cConn, "");
}

void CConnectionPoint::OnObjectReady( 
		/* [in] */ IDispatch __RPC_FAR *pObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = S_OK;
	LPDISPATCH pdisp = NULL;

	for(int i = 0; i < m_nMaxConnections; i++)
	{
		if(m_rgpUnknown[i])
		{
			if (SUCCEEDED(hr = m_rgpUnknown[i]->QueryInterface(IID_IDispatch, (PPVOID)&pdisp)))
			{
				DISPPARAMS dispparams;
				VARIANTARG args[NUM_ON_OBJECT_READY_ARGS];
				VARIANTARG *pArg = args;

				memset(&dispparams, 0, sizeof dispparams);

				dispparams.cArgs = NUM_ON_OBJECT_READY_ARGS;
				dispparams.rgvarg = args;

				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pAsyncContext;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pObject;

				hr = pdisp->Invoke(WBEMS_DISPID_OBJECT_READY, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
														DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
				pdisp->Release();
			}
		}
	}
}

void CConnectionPoint::OnCompleted( 
		/* [in] */ HRESULT hResult,
		/* [in] */ IDispatch __RPC_FAR *path,
		/* [in] */ IDispatch __RPC_FAR *pErrorObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = S_OK;
	LPDISPATCH pdisp = NULL;

	for(int i = 0; i < m_nMaxConnections; i++)
	{
		if(m_rgpUnknown[i])
		{
			if (SUCCEEDED(hr = m_rgpUnknown[i]->QueryInterface(IID_IDispatch, (PPVOID)&pdisp)))
			{
				VARIANTARG *pArg;

				if (path)
				{
					DISPPARAMS putDispparams;
					VARIANTARG putArgs[NUM_ON_OBJECT_PUT_ARGS];

					memset(&putDispparams, 0, sizeof putDispparams);

					putDispparams.cArgs = NUM_ON_OBJECT_PUT_ARGS;
					putDispparams.rgvarg = pArg = putArgs;

					VariantInit(pArg);
					pArg->vt = VT_DISPATCH;
					pArg->pdispVal = pAsyncContext;

					pArg++;
					VariantInit(pArg);
					pArg->vt = VT_DISPATCH;
					pArg->pdispVal = path;

					hr = pdisp->Invoke(WBEMS_DISPID_OBJECT_PUT, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
													DISPATCH_METHOD, &putDispparams, NULL, NULL, NULL);
				}

				DISPPARAMS dispparams;
				VARIANTARG args[NUM_ON_COMPLETED_ARGS];

				memset(&dispparams, 0, sizeof dispparams);

				dispparams.cArgs = NUM_ON_COMPLETED_ARGS;
				dispparams.rgvarg = pArg = args;

				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pAsyncContext;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = pErrorObject;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_I4;
				pArg->lVal = (long)hResult;

				hr = pdisp->Invoke(WBEMS_DISPID_COMPLETED, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
															DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
				pdisp->Release();
			}
		}
	}
}

void CConnectionPoint::OnProgress( 
		/* [in] */ long upperBound,
		/* [in] */ long current,
		/* [in] */ BSTR message,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = S_OK;
	LPDISPATCH pdisp = NULL;

	for(int i = 0; i < m_nMaxConnections; i++)
	{
		if(m_rgpUnknown[i])
		{
			if (SUCCEEDED(hr = m_rgpUnknown[i]->QueryInterface(IID_IDispatch, (PPVOID)&pdisp)))
			{
				DISPPARAMS dispparams;
				VARIANTARG args[NUM_ON_PROGRESS_ARGS];
				VARIANTARG *pArg = args;

				memset(&dispparams, 0, sizeof dispparams);

				dispparams.cArgs = NUM_ON_PROGRESS_ARGS;
				dispparams.rgvarg = args;

				VariantInit(pArg);
				pArg->vt = VT_DISPATCH;
				pArg->pdispVal = (IDispatch  FAR *)pAsyncContext;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_BSTR;
				pArg->bstrVal = message;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_I4;
				pArg->lVal = current;

				pArg++;
				VariantInit(pArg);
				pArg->vt = VT_I4;
				pArg->lVal = upperBound;

				hr = pdisp->Invoke(WBEMS_DISPID_PROGRESS, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
														DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
				pdisp->Release();
			}
		}
	}
}


CEnumConnections::CEnumConnections(IUnknown* pUnknown, int cConn, CONNECTDATA* pConnData) : m_cRef(0)
{
	m_pUnkRef = pUnknown;
	m_iCur = 0;
	m_cConn = cConn;
	m_rgConnData = new CONNECTDATA[cConn];
	if(m_rgConnData != NULL)
		for(int count = 0; count < cConn; count++)
		{
			m_rgConnData[count] = pConnData[count];
			m_rgConnData[count].pUnk->AddRef();
		}

    InterlockedIncrement(&g_cObj);
}

CEnumConnections::~CEnumConnections()
{
	if(m_rgConnData != NULL)
	{
		for(unsigned count = 0; count < m_cConn; count++)
			m_rgConnData[count].pUnk->Release();
		delete [] m_rgConnData;
	}

    InterlockedDecrement(&g_cObj);
}

HRESULT CEnumConnections::Next(ULONG cConnections, CONNECTDATA* rgpcd, ULONG* pcFetched)
{
	if(pcFetched == NULL && cConnections != 1)
		return E_INVALIDARG;
	if(pcFetched != NULL)
		*pcFetched = 0;
    if(rgpcd == NULL || m_iCur >= m_cConn)
        return S_FALSE;
    unsigned cReturn = 0;
    while(m_iCur < m_cConn && cConnections > 0)
    {
        *rgpcd++ = m_rgConnData[m_iCur];
        m_rgConnData[m_iCur++].pUnk->AddRef();
        cReturn++;
        cConnections--;
    } 
    if(pcFetched != NULL)
        *pcFetched = cReturn;
    return S_OK;
}

HRESULT CEnumConnections::Skip(ULONG cConnections)
{
    if(m_iCur + cConnections >= m_cConn)
        return S_FALSE;
    m_iCur += cConnections;
    return S_OK;
}

HRESULT CEnumConnections::Reset()
{
    m_iCur = 0;
    return S_OK;
}

HRESULT CEnumConnections::Clone(IEnumConnections** ppEnum)
{
	if(ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;

    // Create the clone
    CEnumConnections* pNew = new CEnumConnections(m_pUnkRef, m_cConn, m_rgConnData);
    if(NULL == pNew)
        return E_OUTOFMEMORY;

    pNew->AddRef();
    pNew->m_iCur = m_iCur;
    *ppEnum = pNew;
    return S_OK;
}

HRESULT CEnumConnections::QueryInterface(REFIID riid, void** ppv)
{
    if(IID_IUnknown == riid || IID_IEnumConnections == riid)
        *ppv = (IEnumConnections*)this;
    else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

ULONG CEnumConnections::AddRef()
    {
    return ++m_cRef;
    }

ULONG CEnumConnections::Release()
{

	LONG cRef = InterlockedDecrement(&m_cRef);
	
	if(cRef != 0)
	{
	    _ASSERT(cRef > 0);
        return cRef;
    }
    
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\sobjpath.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  sobjpath.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemObjectPath definition
//
//***************************************************************************

#ifndef _SOBJPATH_H_
#define _SOBJPATH_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Implements the ISWbemObjectPath interface.  
//
//***************************************************************************

class CSWbemObjectPath : public ISWbemObjectPath,
						 public IObjectSafety,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
friend	CSWbemServices;

private:
	class CObjectPathDispatchHelp : public CDispatchHelp
	{
		public:
			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};
	CObjectPathDispatchHelp		m_Dispatch;
	
	class CWbemObjectPathSecurity : public ISWbemSecurity,
									public ISupportErrorInfo,
									public IProvideClassInfo
	{
		private:
			CDispatchHelp				m_Dispatch;
			
		protected:
			long				m_cRef;

		public:
			CWbemObjectPathSecurity (CSWbemSecurity *pSecurity);
			CWbemObjectPathSecurity (ISWbemSecurity *pObjectPathSecurity);
			virtual ~CWbemObjectPathSecurity (void);

			//Non-delegating object IUnknown

			STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
			STDMETHODIMP_(ULONG) AddRef(void);
			STDMETHODIMP_(ULONG) Release(void);

			// IDispatch

			STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
				{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
			STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
				{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
			STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
									UINT cNames, LCID lcid, DISPID* rgdispid)
				{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
								  lcid,
								  rgdispid);}
			STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
									WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
											EXCEPINFO* pexcepinfo, UINT* puArgErr)
				{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
								pdispparams, pvarResult, pexcepinfo, puArgErr);}
		
			// ISWbemSecurity methods

			HRESULT STDMETHODCALLTYPE get_ImpersonationLevel 
			(
				/* [out] */ WbemImpersonationLevelEnum *iImpersonationLevel
			);

			HRESULT STDMETHODCALLTYPE put_ImpersonationLevel 
			(
				/* [in] */ WbemImpersonationLevelEnum iImpersonationLevel
			);

			HRESULT STDMETHODCALLTYPE get_AuthenticationLevel 
			(
				/* [out] */ WbemAuthenticationLevelEnum *iAuthenticationLevel
			);

			HRESULT STDMETHODCALLTYPE put_AuthenticationLevel 
			(
				/* [in] */ WbemAuthenticationLevelEnum iAuthenticationLevel
			);

			HRESULT STDMETHODCALLTYPE get_Privileges 
			(
				/* [out] */ ISWbemPrivilegeSet **objWbemPrivileges
			);

			// ISupportErrorInfo methods
			HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
			(
				/* [in] */ REFIID riid
			);

			// IProvideClassInfo methods
			HRESULT STDMETHODCALLTYPE GetClassInfo
			(
				/* [in,out] */ ITypeInfo **ppTI
			)
			{
				return m_Dispatch.GetClassInfo (ppTI);
			};

			bool								m_authnSpecified;
			bool								m_impSpecified;
			enum WbemAuthenticationLevelEnum	m_authnLevel;
			enum WbemImpersonationLevelEnum		m_impLevel;
			CSWbemPrivilegeSet					*m_pPrivilegeSet;	
	};
	

	CWbemObjectPathSecurity		*m_pSecurity;
	BSTR			m_bsLocale;
	BSTR			m_bsAuthority;

protected:

	long				m_cRef;         //Object reference count
	CWbemPathCracker	*m_pPathCracker;

protected:

public:
    
    CSWbemObjectPath(CSWbemSecurity *pSecurity = NULL, BSTR bsLocale = NULL);
	CSWbemObjectPath(CSWbemObjectPath & wbemObjectPath);
	CSWbemObjectPath(ISWbemObjectPath *pISWbemObjectPath);
    ~CSWbemObjectPath(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemObjectPath methods

    HRESULT STDMETHODCALLTYPE get_Path( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Path( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_RelPath( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_RelPath( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_DisplayName( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_DisplayName( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_Namespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Namespace( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_ParentNamespace( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE get_Server( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Server( 
        /* [in] */ BSTR __RPC_FAR value) ;
    
    HRESULT STDMETHODCALLTYPE get_IsClass( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE SetAsClass() ;
    
    HRESULT STDMETHODCALLTYPE get_IsSingleton( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE SetAsSingleton() ;

    HRESULT STDMETHODCALLTYPE get_Class( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Class( 
        /* [in] */ BSTR __RPC_FAR value) ;
    
    HRESULT STDMETHODCALLTYPE get_Keys( 
		/* [retval][out] */ ISWbemNamedValueSet **objKeys) ;

	HRESULT STDMETHODCALLTYPE get_Security_( 
		/* [retval][out] */ ISWbemSecurity **objSecurity) ;

    HRESULT STDMETHODCALLTYPE get_Locale( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Locale( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_Authority( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;

    HRESULT STDMETHODCALLTYPE put_Authority( 
        /* [in] */ BSTR __RPC_FAR value) ;

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Methods of CSWbemObjectPath
	static	bool	GetObjectPath (IWbemClassObject *pIWbemClassObject, CComBSTR & bsPath);
	static	bool	GetParentPath (IWbemClassObject *pIWbemClassObject, CComBSTR & bsPath);

	static bool		CompareObjectPaths (IWbemClassObject *pIWbemClassObject, CWbemPathCracker & objectPath);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\site.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  site.h
//
//  alanbos  13-Feb-98   Created.
//
//  Defines site information for an object
//
//***************************************************************************

#ifndef _SITE_H_
#define _SITE_H_

class CSWbemObject;
class CSWbemProperty;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemSite
//
//  DESCRIPTION:
//
//  Abstract base class  
//
//***************************************************************************

class CWbemSite 
{
protected:
	CWbemSite () { m_cRef = 1; }

	long	m_cRef;
	
public:
    virtual ~CWbemSite (void) { }

	virtual void Update () = 0;

	ULONG AddRef ();
	ULONG Release ();
    
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemObjectSite
//
//  DESCRIPTION:
//
//  Site class for ISWbemObject
//
//***************************************************************************

class CWbemObjectSite : public CWbemSite
{
private:
	ISWbemInternalObject	*m_pSWbemObject;

public:
	CWbemObjectSite (ISWbemInternalObject *pObject);
	~CWbemObjectSite ();

	// Overriden methods of base class
	void Update ();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemPropertySite
//
//  DESCRIPTION:
//
//  Site class for ISWbemProperty, where the property is non-array valued.
//	Embedded objects that are not in an array use this as their site.
//
//***************************************************************************

class CWbemPropertySite : public CWbemSite
{
private:
	// The property representing the embedded object
	CSWbemProperty		*m_pSWbemProperty;

	// The array index of the property value at which
	// this embedded object occurs (or -1 if not array)
	long				m_index;

	// The embedded object itself
	IWbemClassObject	*m_pIWbemClassObject;

public:
	CWbemPropertySite (CSWbemProperty *pProperty,
						IWbemClassObject *pSourceObject,
						long index = -1);

	~CWbemPropertySite ();

	// Overriden methods of base class
	void Update ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\site.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  SITE.CPP
//
//  alanbos  28-Jun-98   Created.
//
//  Defines the WBEM site implementation
//
//***************************************************************************

#include "precomp.h"

ULONG CWbemSite::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

ULONG CWbemSite::Release()
{

	LONG cRef = InterlockedDecrement(&m_cRef);
	
	if(cRef != 0)
	{
	    _ASSERT(cRef > 0);
        return cRef;
    }
    
    delete this;
    return 0;
}

//***************************************************************************
//
// CWbemObjectSite::CWbemObjectSite
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWbemObjectSite::CWbemObjectSite (ISWbemInternalObject *pObject)
{
	m_pSWbemObject = pObject;

	if (m_pSWbemObject)
		m_pSWbemObject->AddRef ();
}

//***************************************************************************
//
// CWbemObjectSite::~CWbemObjectSite
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWbemObjectSite::~CWbemObjectSite ()
{
	if (m_pSWbemObject)
		m_pSWbemObject->Release ();
}

//***************************************************************************
//
// CWbemObjectSite::Update
//
// DESCRIPTION:
//
// Overriden virtual method to update this site
//
//***************************************************************************

void CWbemObjectSite::Update ()
{
	if (m_pSWbemObject)
		m_pSWbemObject->UpdateSite ();
}

//***************************************************************************
//
// CWbemPropertySite::CWbemPropertySite
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWbemPropertySite::CWbemPropertySite (CSWbemProperty *pProperty,
						IWbemClassObject *pSourceObject,
						long index)
{
	m_pSWbemProperty = pProperty;
	m_pIWbemClassObject = pSourceObject;
	m_index = index;

	if (m_pSWbemProperty)
		m_pSWbemProperty->AddRef ();

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->AddRef ();
}

//***************************************************************************
//
// CWbemPropertySite::~CWbemPropertySite
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWbemPropertySite::~CWbemPropertySite ()
{
	if (m_pSWbemProperty)
		m_pSWbemProperty->Release ();

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();
}

//***************************************************************************
//
// CWbemPropertySite::Update
//
// DESCRIPTION:
//
// Overriden virtual method to update this site
//
//***************************************************************************

void CWbemPropertySite::Update ()
{
	if (m_pSWbemProperty)
	{
		if (m_pIWbemClassObject)
		{
			/*
			 * Case 1 this property site is for an object;
			 * we have an embedded object deal.  We commit the
			 * new embedded object value to its owning property
			 * in the parent object.
			 */
		
			// Get the current value of the source object into a VARIANT:
			VARIANT var;
			VariantInit (&var);
			var.vt = VT_UNKNOWN;
			var.punkVal = m_pIWbemClassObject;
			m_pIWbemClassObject->AddRef ();

			// Set the value in the parent object
			m_pSWbemProperty->UpdateEmbedded (var, m_index);
		
			// Release the value
			VariantClear (&var);
		}
		else
		{
			// Addressed by a qualifier - nothing to do
		}

		// Now delegate further to property to update itself.
		if (m_pSWbemProperty)
			m_pSWbemProperty->UpdateSite ();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\sink.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  sink.h
//
//  rogerbo  21-May-98   Created.
//
//  Include file for CSWbemSink
//
//***************************************************************************

#ifndef _SINK_H_
#define _SINK_H_

const NUM_CONNECTION_POINTS = 1;
const CCONNMAX = 8;


//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemSink
//
//  DESCRIPTION:
//
//  Implements the ISWbemSink interface.  
//
//***************************************************************************

typedef struct _WbemObjectListEntry {
	IUnknown *pWbemObjectWrapper;
	IWbemServices *pServices;
} WbemObjectListEntry;


class CConnectionPoint;
class CWbemObjectSink;

class CSWbemSink : public ISWbemSink, 
				   public IConnectionPointContainer, 
				   public IProvideClassInfo2,
				   public IObjectSafety,
				   public ISupportErrorInfo,
				   public ISWbemPrivateSinkLocator
{
private:

	CDispatchHelp		m_Dispatch;		
	CConnectionPoint* m_rgpConnPt[NUM_CONNECTION_POINTS];
	WbemObjectListEntry *m_rgpCWbemObjectSink;   // One of these per outstanding operation
	int m_nMaxSinks;
	int m_nSinks;

	/* 
	 * Here we need to do per interface reference counting.  If the ref count
	 * of the enclosing object goes to zero, and the ref count of the enclosed
	 * object (this one), is non zero, then we have to instigate a cancel, because
	 * there are still outstanding operations.
	 */
	class CSWbemPrivateSink : public ISWbemPrivateSink {
		private:

		CSWbemSink *m_pSink;
		long m_cRef;

		public:

		CSWbemPrivateSink(CSWbemSink *pSink) : m_pSink(pSink), m_cRef(0) {}
		void Detach() { m_pSink = NULL; }

		long GetRef() { return m_cRef; }

		// IUnknown methods

		STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv) {
										if (IID_ISWbemPrivateSink==riid || IID_IUnknown==riid)
										{
											*ppv = (ISWbemPrivateSink *)(this);
											InterlockedIncrement(&m_cRef);
											return S_OK;
										}
										else if (IID_ISWbemPrivateSink==riid)
										{
											*ppv = (ISWbemPrivateSink *)(this);
											InterlockedIncrement(&m_cRef);
											return S_OK;
										}
										return ResultFromScode(E_NOINTERFACE);
									}

		STDMETHODIMP_(ULONG) AddRef(void) {
										InterlockedIncrement(&m_cRef);
										return m_cRef;
									}

		STDMETHODIMP_(ULONG) Release(void) {
										InterlockedDecrement(&m_cRef);
										if(0 == m_cRef)
										{
											delete this;
											return 0;
										}
									  	return m_cRef; 
									}

		// ISWbemPrivateSink methods

		HRESULT STDMETHODCALLTYPE OnObjectReady( 
				/* [in] */ IDispatch __RPC_FAR *objObject,
				/* [in] */ IDispatch __RPC_FAR *objAsyncContext) 
						{ return m_pSink?m_pSink->OnObjectReady(objObject, objAsyncContext):S_OK; }
			
		HRESULT STDMETHODCALLTYPE OnCompleted( 
				/* [in] */ HRESULT iHResult,
				/* [in] */ IDispatch __RPC_FAR *objPath,
				/* [in] */ IDispatch __RPC_FAR *objErrorObject,
				/* [in] */ IDispatch __RPC_FAR *objAsyncContext)
						{ return m_pSink?m_pSink->OnCompleted(iHResult, objPath, objErrorObject, objAsyncContext):S_OK; }
			
		HRESULT STDMETHODCALLTYPE OnProgress( 
				/* [in] */ long iUpperBound,
				/* [in] */ long iCurrent,
				/* [in] */ BSTR strMessage,
				/* [in] */ IDispatch __RPC_FAR *objAsyncContext)
					{ return m_pSink?m_pSink->OnProgress(iUpperBound, iCurrent, strMessage, objAsyncContext):S_OK; }

		HRESULT STDMETHODCALLTYPE AddObjectSink( 
				/* [in] */ IUnknown __RPC_FAR *objWbemSink,
				/* [in] */ IWbemServices __RPC_FAR *objServices)
					{ return m_pSink?m_pSink->AddObjectSink(objWbemSink, objServices):S_OK; }
			
		HRESULT STDMETHODCALLTYPE RemoveObjectSink( 
				/* [in] */ IUnknown __RPC_FAR *objWbemSink)
					{ return m_pSink?m_pSink->RemoveObjectSink(objWbemSink):S_OK; }

	} *m_pPrivateSink;

protected:

	long            m_cRef;         //Object reference count

public:
    
    CSWbemSink();
    ~CSWbemSink(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}


	// ISWbemSink methods
	HRESULT STDMETHODCALLTYPE Cancel();

	// IConnectionPointContainer methods
	HRESULT __stdcall EnumConnectionPoints(IEnumConnectionPoints** ppEnum);
	HRESULT __stdcall FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP);

	// IProvideClassInfo2 methods
	HRESULT __stdcall GetClassInfo(ITypeInfo** pTypeInfo);
	HRESULT __stdcall GetGUID(DWORD dwGuidKind, GUID* pGUID);

	// ISWbemPrivateSink methods
	HRESULT STDMETHODCALLTYPE OnObjectReady( 
            /* [in] */ IDispatch __RPC_FAR *objObject,
            /* [in] */ IDispatch __RPC_FAR *objAsyncContext);
        
	HRESULT STDMETHODCALLTYPE OnCompleted( 
            /* [in] */ HRESULT iHResult,
            /* [in] */ IDispatch __RPC_FAR *objPath,
            /* [in] */ IDispatch __RPC_FAR *objErrorObject,
            /* [in] */ IDispatch __RPC_FAR *objAsyncContext);
        
	HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ long iUpperBound,
            /* [in] */ long iCurrent,
            /* [in] */ BSTR strMessage,
            /* [in] */ IDispatch __RPC_FAR *objAsyncContext);

	HRESULT STDMETHODCALLTYPE AddObjectSink( 
            /* [in] */ IUnknown __RPC_FAR *objWbemSink,
            /* [in] */ IWbemServices __RPC_FAR *objServices);
        
	HRESULT STDMETHODCALLTYPE RemoveObjectSink( 
            /* [in] */ IUnknown __RPC_FAR *objWbemSink);

	// ISWbemPrivateSinkLocator methods
	HRESULT STDMETHODCALLTYPE GetPrivateSink(
			/* [out] */ IUnknown **objWbemPrivateSink);

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);
};

class CEnumConnectionPoints : public IEnumConnectionPoints
{
public:
	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID iid, void** ppv);

	// IEnumConnectionPoints
	HRESULT __stdcall Next(ULONG cConnections, IConnectionPoint** rgpcn, ULONG* pcFetched); 
	HRESULT __stdcall Skip(ULONG cConnections);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumConnectionPoints** ppEnum);

	CEnumConnectionPoints(IUnknown* pUnkRef, void** rgpCP);
	~CEnumConnectionPoints();

private:
	long m_cRef;
    IUnknown* m_pUnkRef;         // IUnknown for ref counting
    int m_iCur;                  // Current element
    IConnectionPoint* m_rgpCP[NUM_CONNECTION_POINTS];  // Array of connection points
};


class CConnectionPoint : public IConnectionPoint
{
private:

	long m_cRef;
	CSWbemSink* m_pObj;
	IID m_iid;
    int m_cConn;
    int m_nCookieNext;
	int m_nMaxConnections;
	unsigned *m_rgnCookies;
	IUnknown **m_rgpUnknown;

public:

	CConnectionPoint(CSWbemSink* pObj, REFIID refiid);
	~CConnectionPoint();

	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID iid, void** ppv);

	// IConnectionPoint
	HRESULT __stdcall GetConnectionInterface(IID *pIID);
	HRESULT __stdcall GetConnectionPointContainer(IConnectionPointContainer** ppCPC);
	HRESULT __stdcall Advise(IUnknown* pUnknownSink, DWORD* pdwCookie);
	HRESULT __stdcall Unadvise(DWORD dwCookie);
	HRESULT __stdcall EnumConnections(IEnumConnections** ppEnum);

	// Other methods
	void OnObjectReady( 
		/* [in] */ IDispatch __RPC_FAR *pObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext);
	void OnCompleted( 
		/* [in] */ HRESULT hResult,
		/* [in] */ IDispatch __RPC_FAR *path,
		/* [in] */ IDispatch __RPC_FAR *pErrorObject,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext);
	void CConnectionPoint::OnProgress( 
		/* [in] */ long upperBound,
		/* [in] */ long current,
		/* [in] */ BSTR message,
		/* [in] */ IDispatch __RPC_FAR *pAsyncContext);

	void UnadviseAll();

};

class CEnumConnections : public IEnumConnections
{
public:
	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID iid, void** ppv);

	// IEnumConnections
	HRESULT __stdcall Next(ULONG cConnections, CONNECTDATA* rgpcd, ULONG* pcFetched);
	HRESULT __stdcall Skip(ULONG cConnections);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumConnections** ppEnum);

	CEnumConnections(IUnknown* pUnknown, int cConn, CONNECTDATA* pConnData);
	~CEnumConnections();

private:
	long m_cRef;
    IUnknown* m_pUnkRef;       // IUnknown for ref counting
    unsigned m_iCur;           // Current element
    unsigned m_cConn;          // Number of connections
    CONNECTDATA* m_rgConnData; // Source of connections
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\sobjpath.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  SOBJPATH.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectPath
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObjectPath::CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObjectPath::CSWbemObjectPath(CSWbemSecurity *pSecurity, BSTR bsLocale) :
		m_cRef (0),
		m_pSecurity (NULL),
		m_pPathCracker (NULL),
		m_bsAuthority (NULL),
		m_bsLocale (NULL)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");
    
	m_pPathCracker = new CWbemPathCracker();

	if (m_pPathCracker)
		m_pPathCracker->AddRef ();

	if (pSecurity)
		m_bsAuthority = SysAllocString (pSecurity->GetAuthority());
	else
		m_bsAuthority = NULL;  

	m_pSecurity = new CWbemObjectPathSecurity (pSecurity);
	m_bsLocale = SysAllocString (bsLocale);
}


//***************************************************************************
//
//  CSWbemObjectPath::CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Copy Constructor but yields the parent path
//
//***************************************************************************

CSWbemObjectPath::CSWbemObjectPath(CSWbemObjectPath & objectPath) :
		m_cRef (0),
		m_pSecurity (NULL),
		m_pPathCracker (NULL),
		m_bsAuthority (NULL),
		m_bsLocale (NULL)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");

	m_pPathCracker = new CWbemPathCracker();

	if (m_pPathCracker)
		m_pPathCracker->AddRef ();

	objectPath.m_pPathCracker->GetParent (*m_pPathCracker);
	
	m_bsAuthority = SysAllocString (objectPath.m_bsAuthority);
	m_pSecurity = new CWbemObjectPathSecurity (objectPath.m_pSecurity);
	m_bsLocale = SysAllocString (objectPath.m_bsLocale);
}

//***************************************************************************
//
//  CSWbemObjectPath::CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Copy Constructor but yields the parent path
//
//***************************************************************************

CSWbemObjectPath::CSWbemObjectPath(ISWbemObjectPath *pISWbemObjectPath) :
		m_cRef (0),
		m_pSecurity (NULL),
		m_pPathCracker (NULL),
		m_bsAuthority (NULL),
		m_bsLocale (NULL)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemObjectPath, 
					CLSID_SWbemObjectPath, L"SWbemObjectPath");

	m_pPathCracker = new CWbemPathCracker();

	if (m_pPathCracker)
		m_pPathCracker->AddRef ();

    if (pISWbemObjectPath)
	{
		CComPtr<ISWbemSecurity> pISWbemSecurity;

		if (SUCCEEDED(pISWbemObjectPath->get_Security_ (&pISWbemSecurity)))
			m_pSecurity = new CWbemObjectPathSecurity (pISWbemSecurity);

		pISWbemObjectPath->get_Authority(&m_bsAuthority);
		pISWbemObjectPath->get_Locale(&m_bsLocale);
		
		CComBSTR bsOriginalPath;

		if (SUCCEEDED(pISWbemObjectPath->get_Path (&(bsOriginalPath.m_str))))
		{
			CWbemPathCracker pathCracker (bsOriginalPath);
			pathCracker.GetParent (*m_pPathCracker);
		}
	}
}

//***************************************************************************
//
//  CSWbemObjectPath::~CSWbemObjectPath
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemObjectPath::~CSWbemObjectPath(void)
{
	RELEASEANDNULL(m_pSecurity)
	RELEASEANDNULL(m_pPathCracker)
	
	if (m_bsLocale)
	{
		SysFreeString (m_bsLocale);
		m_bsLocale = NULL;
	}

	if (m_bsAuthority)
	{
		SysFreeString (m_bsAuthority);
		m_bsAuthority = NULL;
	}


    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemObjectPath::QueryInterface
// long CSWbemObjectPath::AddRef
// long CSWbemObjectPath::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectPath==riid)
		*ppv = (ISWbemObjectPath *)this;
	else if (IID_IDispatch==riid)
        *ppv= (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0L!=cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectPath::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemObjectPath == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Path
//
//  DESCRIPTION:
//
//  Get the path as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{	
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = NULL;
		CComBSTR bsPath;

		if (m_pPathCracker->GetPathText (bsPath, false, true))
		{
			*value = bsPath.Detach ();
			hr = S_OK;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
      
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Path
//
//  DESCRIPTION:
//
//  Put the path as a string
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Path( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (*m_pPathCracker = value)
		hr = WBEM_S_NO_ERROR;
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_RelPath
//
//  DESCRIPTION:
//
//  Get the relpath as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_RelPath( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		CComBSTR bsRelPath;

		if (m_pPathCracker->GetPathText (bsRelPath, true, false))
		{
			hr = WBEM_S_NO_ERROR;
			*value = bsRelPath.Detach ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_RelPath
//
//  DESCRIPTION:
//
//  Set the relpath as a string
//
//  PARAMETERS:
//		value		new relpath
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_RelPath( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	// Parse the new path
	if (m_pPathCracker->SetRelativePath (value))
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_DisplayName
//
//  DESCRIPTION:
//
//  Get the display name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	
	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pSecurity && m_pSecurity->m_pPrivilegeSet)
	{
		CComBSTR bsPath;
		
		if (m_pPathCracker->GetPathText(bsPath, false, true))
		{
			bool hasLocale = ((NULL != m_bsLocale) && (0 < wcslen (m_bsLocale)));
			bool hasAuthority = ((NULL != m_bsAuthority) && (0 < wcslen (m_bsAuthority)));

			// Add the scheme name and a terminating NULL 
			size_t len = 1 + wcslen ( WBEMS_PDN_SCHEME );

			// Add the WMI path length to the buffer
			len += wcslen (bsPath);

			wchar_t *pwcSecurity = CWbemParseDN::GetSecurityString 
						(m_pSecurity->m_authnSpecified, 
						 m_pSecurity->m_authnLevel, 
						 m_pSecurity->m_impSpecified, 
						 m_pSecurity->m_impLevel,
						 *(m_pSecurity->m_pPrivilegeSet),
						 m_bsAuthority);
			
			// Add the security length
			if (pwcSecurity)
				len += wcslen (pwcSecurity);

			wchar_t *pwcLocale = CWbemParseDN::GetLocaleString (m_bsLocale);

			// Add the locale length
			if (pwcLocale)
				len += wcslen (pwcLocale);

			// If we have a path, and either a locale or security component, add a "!" path prefix
			if ((0 < wcslen (bsPath)) && (pwcSecurity || pwcLocale))
				len += wcslen (WBEMS_EXCLAMATION);

			/*
			 * Now build the string
			 */
			wchar_t *pwcDisplayName = new wchar_t [ len ] ;

			if (!pwcDisplayName)
				hr = WBEM_E_OUT_OF_MEMORY;
			else
			{
				wcscpy ( pwcDisplayName , WBEMS_PDN_SCHEME ) ;

				if (pwcSecurity)
					wcscat ( pwcDisplayName, pwcSecurity );
			
				if (pwcLocale)
					wcscat ( pwcDisplayName, pwcLocale);

				if ((0 < wcslen (bsPath)) && (pwcSecurity || pwcLocale))
					wcscat ( pwcDisplayName, WBEMS_EXCLAMATION );

				if (0 < wcslen (bsPath))
					wcscat ( pwcDisplayName, bsPath) ;

				*value = SysAllocString ( pwcDisplayName ) ;

				hr = WBEM_S_NO_ERROR;
			}

			if (pwcSecurity)
				delete [] pwcSecurity;

			if (pwcLocale)
				delete [] pwcLocale;

			if (pwcDisplayName)
				delete [] pwcDisplayName ;
		}
	}

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_DisplayName
//
//  DESCRIPTION:
//
//  Set the display name as a string
//
//  PARAMETERS:
//		value		new BSTR value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_DisplayName( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (value)
	{
		ULONG chEaten = 0;
		bool bIsWmiPath = false;
		bool bIsNativePath = false;

		if (0 == _wcsnicmp (value , WBEMS_PDN_SCHEME , wcslen (WBEMS_PDN_SCHEME)))
		{
			chEaten += wcslen (WBEMS_PDN_SCHEME);
			bIsWmiPath = true;
		}

		if (0 < chEaten)
		{
			bool authnSpecified = false; 
			bool impSpecified = false;
			enum WbemAuthenticationLevelEnum authnLevel;
			enum WbemImpersonationLevelEnum impLevel;
			CSWbemPrivilegeSet privilegeSet;
			CComBSTR bsAuthority, bsLocale;
		
			if (bIsWmiPath)
			{	
				ULONG lTemp = 0;
			
				if (CWbemParseDN::ParseSecurity (&value [chEaten], &lTemp, authnSpecified,
							&authnLevel, impSpecified, &impLevel, privilegeSet, bsAuthority.m_str))
					chEaten += lTemp;

				lTemp = 0;
				
				if (CWbemParseDN::ParseLocale (&value [chEaten], &lTemp, bsLocale.m_str))
					chEaten += lTemp;
				
				// Skip over the "!" separator if there is one
				if(NULL != value [chEaten])
					if (0 == _wcsnicmp (&value [chEaten], WBEMS_EXCLAMATION, wcslen (WBEMS_EXCLAMATION)))
						chEaten += wcslen (WBEMS_EXCLAMATION);
			}

			// Build the new path with what's left

			CComBSTR bsPath;
			bsPath = value +chEaten;

			if (m_pSecurity && m_pSecurity->m_pPrivilegeSet && (*m_pPathCracker = bsPath))
			{
				m_pSecurity->m_authnSpecified = authnSpecified;
				m_pSecurity->m_impSpecified = impSpecified;
				m_pSecurity->m_authnLevel = authnLevel;
				m_pSecurity->m_impLevel = impLevel;
				m_pSecurity->m_pPrivilegeSet->Reset (privilegeSet);

				SysFreeString (m_bsAuthority);
				m_bsAuthority = SysAllocString (bsAuthority);

				SysFreeString (m_bsLocale);
				m_bsLocale = SysAllocString (bsLocale);

				hr = WBEM_S_NO_ERROR;
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Server
//
//  DESCRIPTION:
//
//  Get the server name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Server( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = NULL;
		CComBSTR bsServer;

		if (m_pPathCracker->GetServer (bsServer))
		{
			*value = bsServer.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Server
//
//  DESCRIPTION:
//
//  Set the server name as a string
//
//  PARAMETERS:
//		value		new server name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Server( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetServer (value))
			hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Namespace
//
//  DESCRIPTION:
//
//  Get the server name as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Namespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		CComBSTR bsNamespace;

		if (m_pPathCracker->GetNamespacePath(bsNamespace))
		{
			*value = bsNamespace.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_ParentNamespace
//
//  DESCRIPTION:
//
//  Get the parent namespace as a string
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_ParentNamespace( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();
	
	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = NULL;

		// Get the full path and lob the end off
		CComBSTR bsNamespacePath;

		if (m_pPathCracker->GetNamespacePath (bsNamespacePath, true))
		{
			*value = bsNamespacePath.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Namespace
//
//  DESCRIPTION:
//
//  Put the namespace as a string
//
//  PARAMETERS:
//		value		new server name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Namespace( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	
	if (m_pPathCracker->SetNamespacePath (value))
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
    
//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_IsClass
//
//  DESCRIPTION:
//
//  Get whether the path is to a class
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_IsClass( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = m_pPathCracker->IsClass ()  ? VARIANT_TRUE : VARIANT_FALSE;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::SetAsClass
//
//  DESCRIPTION:
//
//  Set the path as a class path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::SetAsClass()
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetAsClass ())
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_IsSingleton
//
//  DESCRIPTION:
//
//  Get whether the path is to a singleton
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_IsSingleton( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = m_pPathCracker->IsSingleton () ? VARIANT_TRUE : VARIANT_FALSE;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemObjectPath::SetAsSingleton
//
//  DESCRIPTION:
//
//  Set the path as a singleton instance path
//
//  PARAMETERS:
//		none
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::SetAsSingleton()
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetAsSingleton ())
		hr = WBEM_S_NO_ERROR;
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Class
//
//  DESCRIPTION:
//
//  Get the class name from the path
//
//  PARAMETERS:
//		value		pointer to BSTR value returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Class( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*value = NULL;
		CComBSTR bsPath;

		if (m_pPathCracker->GetClass (bsPath))
		{
			*value = bsPath.Detach ();
			hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Class
//
//  DESCRIPTION:
//
//  Set the class name in the path
//
//  PARAMETERS:
//		value		new class name
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Class( 
            /* [in] */ BSTR __RPC_FAR value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (m_pPathCracker->SetClass (value))
			hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Keys
//
//  DESCRIPTION:
//
//  Get the keys collection from the path
//
//  PARAMETERS:
//		objKeys		pointer to ISWbemNamedValueSet returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Keys(
			/* [out][retval] */ ISWbemNamedValueSet **objKeys)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == objKeys)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pPathCracker->GetKeys (objKeys))
		hr = WBEM_S_NO_ERROR;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
	
//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Security
//
//  DESCRIPTION:
//
//  Get the security info from the path
//
//  PARAMETERS:
//		objKeys		pointer to ISWbemSecurity returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Security_(
			/* [out][retval] */ ISWbemSecurity **objSecurity)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (NULL == objSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pSecurity)
	{
		*objSecurity = m_pSecurity;
		m_pSecurity->AddRef();
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Locale
//
//  DESCRIPTION:
//
//  Get the locale info from the path
//
//  PARAMETERS:
//		value		pointer to locale returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Locale( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = SysAllocString ( m_bsLocale ) ;
		hr = S_OK ;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Locale
//
//  DESCRIPTION:
//
//  Set the locale info into the path
//
//  PARAMETERS:
//		value		new locale value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Locale( 
            /* [in] */ BSTR __RPC_FAR value)
{
	ResetLastErrors ();
	SysFreeString (m_bsLocale);
	m_bsLocale = SysAllocString (value);

	return S_OK ;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::get_Authority
//
//  DESCRIPTION:
//
//  Get the authority info from the path
//
//  PARAMETERS:
//		value		pointer to authority returned
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::get_Authority( 
            /* [retval][out] */ BSTR __RPC_FAR *value)
{
	HRESULT hr = WBEM_E_FAILED ;
	ResetLastErrors ();

	if (NULL == value)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*value = SysAllocString ( m_bsAuthority ) ;
		hr = S_OK ;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectPath::put_Authority
//
//  DESCRIPTION:
//
//  Set the authority info into the path
//
//  PARAMETERS:
//		value		new authority value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::put_Authority( 
            /* [in] */ BSTR __RPC_FAR value)
{
	ResetLastErrors ();
	SysFreeString (m_bsAuthority);
	m_bsAuthority = SysAllocString (value);

	return WBEM_S_NO_ERROR;
}


// CWbemObjectPathSecurity methods

//***************************************************************************
//
// CWbemObjectPathSecurity::CWbemObjectPathSecurity
//
// CONSTRUCTOR
//
//***************************************************************************

CSWbemObjectPath::CWbemObjectPathSecurity::CWbemObjectPathSecurity (
	CSWbemSecurity *pSecurity) :
		m_pPrivilegeSet (NULL),
		m_authnSpecified (false),
		m_impSpecified (false),
		m_cRef (1)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
					CLSID_SWbemSecurity, L"SWbemSecurity");
	
	if (pSecurity)
	{
		CSWbemPrivilegeSet *pPrivilegeSet = pSecurity->GetPrivilegeSet ();

		if (pPrivilegeSet)
		{
			m_pPrivilegeSet = new CSWbemPrivilegeSet (*pPrivilegeSet);
			pPrivilegeSet->Release ();
		}
		else
			m_pPrivilegeSet = new CSWbemPrivilegeSet ();

		pSecurity->get_AuthenticationLevel (&m_authnLevel);
		pSecurity->get_ImpersonationLevel (&m_impLevel);
		m_authnSpecified = true;
		m_impSpecified = true;
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		m_authnSpecified = false;
		m_impSpecified = false;
	}
}

//***************************************************************************
//
// CWbemObjectPathSecurity::CWbemObjectPathSecurity
//
// CONSTRUCTOR
//
//***************************************************************************

CSWbemObjectPath::CWbemObjectPathSecurity::CWbemObjectPathSecurity (
	ISWbemSecurity *pISWbemSecurity) :
		m_pPrivilegeSet (NULL),
		m_authnSpecified (false),
		m_impSpecified (false),
		m_cRef (1)
{
	m_Dispatch.SetObj (this, IID_ISWbemSecurity, 
							CLSID_SWbemSecurity, L"SWbemSecurity");
	
	if (pISWbemSecurity)
	{
		CComPtr<ISWbemPrivilegeSet> pISWbemPrivilegeSet;
		pISWbemSecurity->get_Privileges (&pISWbemPrivilegeSet);
		m_pPrivilegeSet = new CSWbemPrivilegeSet (pISWbemPrivilegeSet);
	
		pISWbemSecurity->get_AuthenticationLevel (&m_authnLevel);
		pISWbemSecurity->get_ImpersonationLevel (&m_impLevel);
		m_authnSpecified = true;
		m_impSpecified = true;
	}
	else
	{
		m_pPrivilegeSet = new CSWbemPrivilegeSet ();
		m_authnSpecified = false;
		m_impSpecified = false;
	}
}

//***************************************************************************
//
// CWbemObjectPathSecurity::~CWbemObjectPathSecurity
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemObjectPath::CWbemObjectPathSecurity::~CWbemObjectPathSecurity ()
{
	RELEASEANDNULL(m_pPrivilegeSet)
}

//***************************************************************************
// HRESULT CWbemObjectPathSecurity::QueryInterface
// long CWbemObjectPathSecurity::AddRef
// long CWbemObjectPathSecurity::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************
STDMETHODIMP CSWbemObjectPath::CWbemObjectPathSecurity::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemSecurity==riid)
		*ppv = (ISWbemSecurity *)this;
	else if (IID_IDispatch==riid)
        *ppv= (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;


    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::CWbemObjectPathSecurity::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSWbemObjectPath::CWbemObjectPathSecurity::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
    {
        _ASSERT(l > 0);
        return l;
    }
    
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectPath::CWbemObjectPathSecurity::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemSecurity == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::get_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Retrieve the authentication level
//
//  PARAMETERS:
//
//		pAuthenticationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::get_AuthenticationLevel (
	WbemAuthenticationLevelEnum *pAuthenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pAuthenticationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_authnSpecified)
	{
		*pAuthenticationLevel = m_authnLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::get_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Retrieve the impersonation level
//
//  PARAMETERS:
//
//		pImpersonationLevel		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::get_ImpersonationLevel (
	WbemImpersonationLevelEnum *pImpersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pImpersonationLevel)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_impSpecified)
	{
		*pImpersonationLevel = m_impLevel;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
			
//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::get_Privileges
//
//  DESCRIPTION:
//
//  Return the Privilege override set
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::get_Privileges	(
	ISWbemPrivilegeSet **ppPrivileges
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppPrivileges)
		hr = WBEM_E_INVALID_PARAMETER;
	else			// Bug ID 566345
	{
		*ppPrivileges = NULL;

		if (m_pPrivilegeSet)
		{
			if (SUCCEEDED (m_pPrivilegeSet->QueryInterface (IID_ISWbemPrivilegeSet,
												(PPVOID) ppPrivileges)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::put_AuthenticationLevel
//
//  DESCRIPTION:
//
//  Set the authentication level
//
//  PARAMETERS:
//
//		authenticationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::put_AuthenticationLevel (
	WbemAuthenticationLevelEnum authenticationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_AUTHN_LEVEL > authenticationLevel) || 
		(WBEMS_MAX_AUTHN_LEVEL < authenticationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		m_authnLevel = authenticationLevel;
		m_authnSpecified = true;
		hr = WBEM_S_NO_ERROR;
	}
 	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemObjectPathSecurity::put_ImpersonationLevel
//
//  DESCRIPTION:
//
//  Set the impersonation level
//
//  PARAMETERS:
//
//		impersonationLevel		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectPath::CWbemObjectPathSecurity::put_ImpersonationLevel (
	WbemImpersonationLevelEnum impersonationLevel
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((WBEMS_MIN_IMP_LEVEL > impersonationLevel) || (WBEMS_MAX_IMP_LEVEL < impersonationLevel))
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		m_impLevel = impersonationLevel;
		m_impSpecified = true;
		hr = WBEM_S_NO_ERROR;
	}
 	 		
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemObjectPath::GetObjectPath
//
//  DESCRIPTION:
//
//  Attempts to extract the __RELPATH system property value from a WBEM object
//	and return it as a BSTR.  Note that if this object is not yet persisted
//	the __RELPATH property will be null or invalid.
//
//  PARAMETERS:
//		pIWbemClassObject		the object in question
//		bsPath					placeholder for the path
//
//  RETURN VALUES:
//		true if retrieved, false o/w
//
//***************************************************************************

bool CSWbemObjectPath::GetObjectPath (
	IWbemClassObject *pIWbemClassObject,
	CComBSTR & bsPath
)
{
	bool result = false;

	if (pIWbemClassObject)
	{
		CComVariant var;

		if (SUCCEEDED(pIWbemClassObject->Get (WBEMS_SP_RELPATH, 0, &var, NULL, NULL))
			&& (VT_BSTR == var.vt) 
			&& (var.bstrVal)
			&& (0 < wcslen (var.bstrVal)))
		{
			bsPath = var.bstrVal;
			result = true;
		}
	}

	return result;
}

//***************************************************************************
//
//  CSWbemObjectPath::GetParentPath
//
//  DESCRIPTION:
//
//  Attempts to extract the path of the parent container for the given object.
//
//  PARAMETERS:
//		pIWbemClassObject		the object in question
//		bsParentPath			placeholder for the path
//
//  RETURN VALUES:
//		true if retrieved, false o/w
//
//***************************************************************************

bool CSWbemObjectPath::GetParentPath (
	IWbemClassObject *pIWbemClassObject,
	CComBSTR & bsParentPath
)
{
	bool result = false;

	if (pIWbemClassObject)
	{
		CComVariant var;

		if (SUCCEEDED(pIWbemClassObject->Get (WBEMS_SP_PATH, 0, &var, NULL, NULL))
					&& (VT_BSTR == var.vt) 
					&& (var.bstrVal)
					&& (0 < wcslen (var.bstrVal)))
		{
			CWbemPathCracker pathCracker (var.bstrVal);

			if (CWbemPathCracker::wbemPathTypeError != pathCracker.GetType ())
			{
				CWbemPathCracker parentPath;

				if (pathCracker.GetParent (parentPath))
					result = parentPath.GetPathText(bsParentPath, false, true, false);
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  CSWbemObjectPath::CompareObjectPaths
//
//  DESCRIPTION:
//
//  Given an IWbemClassObject, determine whether it can "fit" the supplied
//	path
//
//  PARAMETERS:
//		pIWbemClassObject		the object in question
//		objectPath				cracked path
//
//  RETURN VALUES:
//		true if retrieved, false o/w
//
//***************************************************************************

bool CSWbemObjectPath::CompareObjectPaths (
	IWbemClassObject *pIWbemClassObject, 
	CWbemPathCracker & objectPath
)
{
	bool result = false;
	CComVariant var;
	CComBSTR bsPath;
		
	// Depending on what type of path we're trying to match against
	// we get our path info appropriately
	switch (objectPath.GetType ())
	{
		case CWbemPathCracker::WbemPathType::wbemPathTypeWmi:
		{
			if (SUCCEEDED(pIWbemClassObject->Get (WBEMS_SP_RELPATH, 0, &var, NULL, NULL))
				&& (VT_BSTR == var.vt) 
				&& (var.bstrVal)
				&& (0 < wcslen (var.bstrVal)))
			{
				bsPath = var.bstrVal;
				result = (objectPath == bsPath);
			}
		}
			break;

	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\util.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  util.h
//
//  alanbos  13-Feb-98   Created.
//
//  Useful things
//
//***************************************************************************

#ifndef _UTIL_H_
#define _UTIL_H_

HRESULT WmiVariantChangeType (VARIANT &vOut, VARIANT *pvIn, CIMTYPE lCimType);
HRESULT WmiConvertSafeArray (VARIANT &vOut, SAFEARRAY *pArray, CIMTYPE lCimType);
HRESULT WmiConvertDispatchArray (VARIANT &vOut, CComPtr<IDispatch> & pIDispatch, CIMTYPE lCimType);
bool	GetSafeArrayDimensions (SAFEARRAY &sArray, long &lLower, long &lUpper);

HRESULT	ConvertDispatchToArray (VARIANT *pDest, VARIANT *pSrc, CIMTYPE lCimType = CIM_ILLEGAL,
					BOOL bIsQualifier = false, VARTYPE requiredQualifierType = VT_NULL);

HRESULT MapToCIMOMObject (VARIANT *pVal);

HRESULT MapFromCIMOMObject (CSWbemServices *pService, VARIANT *pVal,
									ISWbemInternalObject *pObject = NULL,
									BSTR propertyName = NULL,
									long index = -1);

HRESULT ConvertArray(VARIANT * pDest, VARIANT * pSrc, BOOL bQualTypesOnly = false,
					 VARTYPE requiredVarType = VT_NULL);

HRESULT ConvertArrayRev(VARIANT * pDest, VARIANT * pSrc);

HRESULT ConvertBSTRArray(SAFEARRAY **ppDest, SAFEARRAY *pSrc);

HRESULT QualifierVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, VARTYPE vtNew);

VARTYPE GetAcceptableQualType(VARTYPE vt);

HRESULT BuildStringArray (SAFEARRAY *pArray, VARIANT & var);
HRESULT	SetFromStringArray (SAFEARRAY **ppArray, VARIANT *pVar);

BSTR FormatAssociatorsQuery (BSTR strObjectPath, BSTR strAssocClass,
	BSTR strResultClass, BSTR strResultRole, BSTR strRole, VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly, BSTR strRequiredAssocQualifier, BSTR strRequiredQualifier);

BSTR FormatReferencesQuery (BSTR strObjectPath,	BSTR strResultClass, BSTR strRole,
	VARIANT_BOOL bClassesOnly, VARIANT_BOOL bSchemaOnly, BSTR strRequiredQualifier);

BSTR FormatMultiQuery (SAFEARRAY &pClassList, long iNumElements);

void	CheckArrayBounds (SAFEARRAY *psa, long index);
void	SetSite (VARIANT *pVal, ISWbemInternalObject *pSObject, BSTR propertyName, long index = -1);
void	SetWbemError (CSWbemServices *pService);
void	ResetLastErrors ();
void	SetException (EXCEPINFO *pExcepInfo, HRESULT hr, BSTR m_objectName);
BSTR	MapHresultToWmiDescription (HRESULT hr);
void	MapNulls (DISPPARAMS FAR* pdispparams);

void EnsureGlobalsInitialized ();

// CIM <-> VARIANT type coercion functions
VARTYPE CimTypeToVtType(CIMTYPE lType);
WbemCimtypeEnum GetCIMType (VARIANT &var, CIMTYPE iCIMType, 
								bool bIsArray = false, long lLBound = 0, long lUBound = 0);
bool CanCoerceString (const BSTR & bsValue, WbemCimtypeEnum cimType);
WbemCimtypeEnum MapVariantTypeToCimType (VARIANT *pVal, CIMTYPE cimType = CIM_ILLEGAL);

bool ReadUI64(LPCWSTR wsz, unsigned __int64& rui64);
bool ReadI64(LPCWSTR wsz, __int64& rui64);

bool IsNullOrEmptyVariant (VARIANT & var);
bool RemoveElementFromArray (SAFEARRAY & array, VARTYPE vt, long iIndex);
bool ShiftLeftElement (SAFEARRAY & array, VARTYPE vt, long iIndex);
bool ShiftElementsToRight (SAFEARRAY & array, VARTYPE vt, long iStartIndex, 
						   long iEndIndex, long iShift);																	

bool MatchBSTR (VARIANT & var, BSTR & bstrVal);
bool MatchUI1 (VARIANT & var, unsigned char bVal);
bool MatchI2 (VARIANT & var, short iVal);
bool MatchI4 (VARIANT & var, long lVal);
bool MatchR4 (VARIANT & var, float fltVal);
bool MatchR8 (VARIANT & var, double dblVal);
bool MatchBool (VARIANT & var, VARIANT_BOOL boolVal);
bool MatchValue (VARIANT &var1, VARIANT &var2);

#define WBEMS_PDN_SCHEME		L"WINMGMTS:"
#define WBEMS_LEFT_PAREN		L"("
#define WBEMS_RIGHT_PAREN		L")"
#define	WBEMS_LEFT_CURLY		L"{"
#define	WBEMS_RIGHT_CURLY		L"}"
#define WBEMS_LEFT_SQBRK		L"["
#define WBEMS_RIGHT_SQBRK		L"]"
#define WBEMS_LEFT_ANGLE		L"<"
#define WBEMS_RIGHT_ANGLE		L">"
#define	WBEMS_EQUALS			L"="
#define	WBEMS_COMMA				L","
#define	WBEMS_EXCLAMATION		L"!"
#define	WBEMS_AUTH_LEVEL		L"authenticationLevel"
#define WBEMS_AUTH_DEFAULT		L"default"
#define WBEMS_AUTH_NONE			L"none"
#define WBEMS_AUTH_CONNECT		L"connect"
#define WBEMS_AUTH_CALL			L"call"
#define WBEMS_AUTH_PKT			L"pkt"
#define WBEMS_AUTH_PKT_INT		L"pktIntegrity"
#define WBEMS_AUTH_PKT_PRIV		L"pktPrivacy"
#define	WBEMS_IMPERSON_LEVEL	L"impersonationLevel"
#define WBEMS_IMPERSON_ANON		L"anonymous"
#define WBEMS_IMPERSON_IDENTIFY L"identify"
#define WBEMS_IMPERSON_IMPERSON	L"impersonate"
#define WBEMS_IMPERSON_DELEGATE	L"delegate"
#define WBEMS_LOCALE			L"locale"
#define WBEMS_AUTHORITY			L"authority"
#define WBEMS_RK_SCRIPTING		_T("Software\\Microsoft\\Wbem\\Scripting")
#define WBEMS_RV_DEFNS			_T("Default Namespace")
#define WBEMS_RV_ENABLEFORASP	_T("Enable for ASP")
#define WBEMS_RV_DEFAULTIMPLEVEL _T("Default Impersonation Level")
#define WBEMS_DEFNS				_T("root\\cimv2")


// Strings for queries
#define WBEMS_QUERY_ASSOCOF		OLESTR("associators of ")
#define WBEMS_QUERY_OPENBRACE	OLESTR("{")
#define WBEMS_QUERY_CLOSEBRACE	OLESTR("}")
#define WBEMS_QUERY_WHERE		OLESTR(" where ")
#define WBEMS_QUERY_ASSOCCLASS	OLESTR(" AssocClass ")
#define WBEMS_QUERY_EQUALS		OLESTR("=")
#define WBEMS_QUERY_CLASSDEFS	OLESTR(" ClassDefsOnly ")
#define WBEMS_QUERY_REQASSOCQ	OLESTR(" RequiredAssocQualifier ")
#define WBEMS_QUERY_REQQUAL		OLESTR(" RequiredQualifier ")
#define WBEMS_QUERY_RESCLASS	OLESTR(" ResultClass ")
#define WBEMS_QUERY_RESROLE		OLESTR(" ResultRole ")
#define WBEMS_QUERY_ROLE		OLESTR(" Role ")
#define WBEMS_QUERY_SCHEMAONLY	OLESTR(" SchemaOnly ")
#define WBEMS_QUERY_REFOF		OLESTR("references of ")
#define	WBEMS_QUERY_SELECT		OLESTR("select * from ")
#define WBEMS_QUERY_GO			OLESTR(" go ")

// System properties
#define WBEMS_SP_CLASS				OLESTR("__CLASS")
#define WBEMS_SP_PATH				OLESTR("__PATH")
#define WBEMS_SP_RELPATH			OLESTR("__RELPATH")
#define WBEMS_SP_SERVER				OLESTR("__SERVER")
#define WBEMS_SP_NAMESPACE			OLESTR("__NAMESPACE")
#define WBEMS_SP_GENUS				OLESTR("__GENUS")
#define WBEMS_SP_DERIVATION			OLESTR("__DERIVATION")

// Context variables
#define	WBEMS_CV_GET_EXTENSIONS			OLESTR("__GET_EXTENSIONS")
#define WBEMS_CV_GET_EXT_CLIENT_REQUEST	OLESTR("__GET_EXT_CLIENT_REQUEST")
#define WBEMS_CV_GET_EXT_PROPERTIES		OLESTR("__GET_EXT_PROPERTIES")
#define WBEMS_CV_CLONE_SOURCE_PATH		OLESTR("__CloneSourcePath")
#define WBEMS_CV_OWNER					OLESTR("INCLUDE_OWNER")
#define WBEMS_CV_GROUP					OLESTR("INCLUDE_GROUP")
#define WBEMS_CV_DACL					OLESTR("INCLUDE_DACL")
#define WBEMS_CV_SACL					OLESTR("INCLUDE_SACL")


#define ENGLISH_LOCALE 1033

// Useful cleanup macros
#define RELEASEANDNULL(x) \
if (x) \
{ \
	x->Release (); \
	x = NULL; \
}

#define FREEANDNULL(x) \
if (x) \
{ \
	SysFreeString (x); \
	x = NULL; \
}

#define DELETEANDNULL(x) \
if (x) \
{ \
	delete x; \
	x = NULL; \
}

#ifdef _RDEBUG
extern void _RRPrint(int line, const char *file, const char *func, 
								const char *str, long code, const char *str2); 
#define _RD(a) a
#define _RPrint(a,b,c,d) _RRPrint(__LINE__,__FILE__,a,b,c,d)
#else
#define _RD(a)
#define _RPrint(a,b,c,d)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\util.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  UTIL.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Some useful functions
//
//***************************************************************************

#include "precomp.h"
#include "assert.h"
#include "initguid.h"

#include "dispex.h"

#include <math.h>

extern CWbemErrorCache *g_pErrorCache;
extern CRITICAL_SECTION g_csErrorCache;

typedef struct {
    VARTYPE vtOkForQual;
    VARTYPE vtTest;
} Conversion;

Conversion QualConvertList[] = {
    {VT_I4, VT_I4},
    {VT_I4, VT_UI1},
    {VT_I4, VT_I2},
    {VT_R8, VT_R4},
    {VT_R8, VT_R8},
    {VT_BOOL, VT_BOOL},
    {VT_I4, VT_ERROR},
    {VT_BSTR, VT_CY},
    {VT_BSTR, VT_DATE},
    {VT_BSTR, VT_BSTR}};

//***************************************************************************
//
// GetAcceptableQualType(VARTYPE vt)
//
// DESCRIPTION:
//
// Only certain types are acceptable for qualifiers.  This routine takes a 
// vartype and returns an acceptable conversion type.  Note that if the type is
// already acceptable, then it is returned.
//
//***************************************************************************

VARTYPE GetAcceptableQualType(VARTYPE vt)
{
    int iCnt;    
    VARTYPE vtArrayBit = vt & VT_ARRAY;
    VARTYPE vtSimple = vt & ~(VT_ARRAY | VT_BYREF);
    int iSize = sizeof(QualConvertList) / sizeof(Conversion);
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(vtSimple == QualConvertList[iCnt].vtTest)
            return QualConvertList[iCnt].vtOkForQual | vtArrayBit;
    return VT_ILLEGAL;
}

//***************************************************************************
//
//  SCODE MapFromCIMOMObject
//
//  Description: 
//
//  This function filters out embedded objects that have been passed in
//	from CIMOM, ensuring they are returned to the automation environment
//	as VT_DISPATCH types.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

HRESULT MapFromCIMOMObject(CSWbemServices *pService, 
								VARIANT *pVal,
								ISWbemInternalObject *pSWbemObject,
								BSTR propertyName,
								long index)

{
	HRESULT hr = S_OK;

    if(pVal->vt == VT_UNKNOWN)
    {
		/*
		 * This may be an embedded object. If it is replace by it's
		 * scriptable equivalent. If not leave it be.
		 */
		if (pVal->punkVal)
		{
			CComQIPtr<IWbemClassObject> pIWbemClassObject (pVal->punkVal);

			if (pIWbemClassObject)
			{
				// Yowzer - it's one of ours
				CSWbemObject *pNew = new CSWbemObject (pService, pIWbemClassObject);

				if (pNew)
				{
					CComQIPtr<IDispatch> pIDispatch (reinterpret_cast<IUnknown*>(pNew));

					if (pIDispatch)
					{	
						// Conversion succeeded - replace the punkVal by a pdispVal
						pVal->punkVal->Release ();
						pVal->punkVal = NULL;

						// Transfer the AddRef'd pointer from the QI call above to the Variant
						pVal->pdispVal = pIDispatch.Detach ();	
						pVal->vt = VT_DISPATCH;
					
						if (pSWbemObject)
						{
							// Our newly create CSWbemObject is an embedded object
							// we need to set its site
							pNew->SetSite (pSWbemObject, propertyName, index);
						}
					}
					else
					{
						// This should NEVER happen, but just in case
						delete pNew;
						hr = WBEM_E_FAILED;
					}
				}
				else
					hr = WBEM_E_OUT_OF_MEMORY;
			}
		}

	}
	else if(pVal->vt == (VT_UNKNOWN | VT_ARRAY))
    {
		// got an array of objects.  Replace the object pointers with a wrapper
        // pointer

        SAFEARRAYBOUND aBounds[1];

        long lLBound, lUBound;
        SafeArrayGetLBound(pVal->parray, 1, &lLBound);
        SafeArrayGetUBound(pVal->parray, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        // Update the individual data pieces
        // ================================
		bool ok = true;

        for(long lIndex = lLBound; ok && (lIndex <= lUBound); lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			
			CComPtr<IUnknown> pUnk;

            if (FAILED(SafeArrayGetElement(pVal->parray, &lIndex, &pUnk)) || !pUnk)
			{
				ok = false;
				hr = WBEM_E_FAILED;
			}
			else
			{
				CComQIPtr<IWbemClassObject> pIWbemClassObject (pUnk);

				if (pIWbemClassObject)
				{
					CSWbemObject *pNew = new CSWbemObject (pService, pIWbemClassObject);

					if (pNew)
					{
						CComQIPtr<IDispatch> pIDispatch (reinterpret_cast<IUnknown*>(pNew));

						if (pIDispatch)
						{
							if (FAILED(SafeArrayPutElement(pVal->parray, &lIndex, pIDispatch)))
							{
								hr = WBEM_E_FAILED;
								ok = false;
							}
							else
							{
								pVal->vt = VT_ARRAY | VT_DISPATCH;

								if (pSWbemObject)
								{
									// This element is an embedded object.  We must set it's site.
									pNew->SetSite (pSWbemObject, propertyName, lIndex);
								}
							}
						}
						else
						{
							// This should NEVER happen, but just in case
							delete pNew;
							hr = WBEM_E_FAILED;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
						ok = false;
					}
				}
			}
        }
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT MapToCIMOMObject
//
//  Description: 
//
//  This function filters out embedded objects that have been passed in
//	as VT_DISPATCH (possibly combined with VT_BYREF or VT_ARRAY).  The
//	object is recast inside a VT_UNKNOWN so it can be accepted by CIMOM.
//
//  Parameters:
//
//  pVal		The input variant to check
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT MapToCIMOMObject(
	VARIANT *pVal
)
{
	HRESULT hRes = S_OK;

    if(pVal->vt == VT_DISPATCH || (pVal->vt == (VT_DISPATCH | VT_BYREF)))
    {
		/*
		 * We may have an embedded object. Replace the object pointer with 
		 * a wrapper pointer.
		 */
        IDispatch *pDisp = NULL;
		
		if (V_ISBYREF(pVal) && (pVal->ppdispVal))
			pDisp = *(pVal->ppdispVal);
		else if (VT_DISPATCH == V_VT(pVal))
			pDisp = pVal->pdispVal;
		
		if (pDisp)
		{
			// If successful this will AddRef the returned interface
            IWbemClassObject *pObj = CSWbemObject::GetIWbemClassObject (pDisp);

			if (pObj)
			{
				// Release the dispatch pointer as we are about to remove it from the
				// VARIANT, but only if it wasn't a VT_BYREF (because byrefs don't
				// get AddRef'd by VariantCopy or Released by VariantClear).
				if (!V_ISBYREF(pVal))
					pDisp->Release ();

				pVal->punkVal = pObj;
		        pVal->vt = VT_UNKNOWN;
			}
			else
			{
				/*
				 * Rather than just cast IDispatch* to IUnknown*, we do a QI
				 * with a release just in case the object has per-interface
				 * ref counting.
				 */
				if (SUCCEEDED (hRes = pDisp->QueryInterface (IID_IUnknown, (PPVOID) &(pVal->punkVal))))
				{
					pDisp->Release ();
					pVal->vt = VT_UNKNOWN;
				}
            }
        }
	}
	else if(pVal->vt == (VT_DISPATCH | VT_ARRAY))
    {
		// got an array of embedded objects.  Replace the object pointers with a wrapper
        // pointer

        SAFEARRAYBOUND aBounds[1];

        long lLBound, lUBound;
        SafeArrayGetLBound(pVal->parray, 1, &lLBound);
        SafeArrayGetUBound(pVal->parray, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        // Update the individual data pieces
        // ================================
		long lIndex;

        for (lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			IDispatch * pDisp = NULL;

			if (FAILED (hRes = SafeArrayGetElement(pVal->parray, &lIndex, &pDisp)))
				break;
			
			if (pDisp)
			{
				// If successful this will AddRef the returned interface
				IWbemClassObject *pObj = CSWbemObject::GetIWbemClassObject (pDisp);
				
				if (pObj)
				{
					pDisp->Release ();  // Balances the SafeArrayGetElement call

					// Put it into the new array
					// =========================
					hRes = SafeArrayPutElement(pVal->parray, &lIndex, pObj);
					pObj->Release (); // balances CSWbemObject::GetIWbemClassObject call

					if (FAILED (hRes))
						break;
					else
						pVal->vt = VT_UNKNOWN | VT_ARRAY;
				}
				else
				{
					/*
					 * Rather than just cast IDispatch* to IUnknown*, we do a QI
					 * with a release just in case the object has per-interface
					 * ref counting.
					 */
					IUnknown *pUnk = NULL;

					if (SUCCEEDED (hRes = pDisp->QueryInterface (IID_IUnknown, (PPVOID) &pUnk)))
					{
						pDisp->Release ();  // Balances the SafeArrayGetElement call
						hRes = SafeArrayPutElement(pVal->parray, &lIndex, pUnk);
						pUnk->Release (); // Balances the QI call

						if (FAILED (hRes))
							break;
						else
							pVal->vt = VT_UNKNOWN | VT_ARRAY;
					}
					else
					{
						pDisp->Release ();  // Balances the SafeArrayGetElement call
						break;
					}
				}	
			}
			else
				break;
        }

		if (lUBound < lIndex)
		{
			hRes = WBEM_S_NO_ERROR;
			pVal->vt = VT_UNKNOWN | VT_ARRAY;
		}
	}

	return hRes;
}

//***************************************************************************
//
//  HRESULT SetSite
//
//  Description: 
//
//  This function examines a VARIANT that has been successfully set as the
//	value of a property to determine whether it contains any embedded objects.
//	Any such objects are modified to ensure their site represents the property
//	in question.
//
//  Parameters:
//
//  pVal			The input variant to check
//	pSObject		Owning object of the property
//	propertyName	Take a wild guess
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

void SetSite (VARIANT *pVal, ISWbemInternalObject *pSObject, BSTR propertyName,
						long index)
{
	HRESULT hRes = S_OK;

	if (pVal)
	{
		if(pVal->vt == VT_DISPATCH || (pVal->vt == (VT_DISPATCH | VT_BYREF)))
		{
			// Could  be an embedded object
			IDispatch *pDisp = NULL;
			
			if (VT_DISPATCH == V_VT(pVal))
				pDisp = pVal->pdispVal;
			else if (NULL != pVal->ppdispVal)
				pDisp = *(pVal->ppdispVal);

			if (pDisp)
				CSWbemObject::SetSite (pDisp, pSObject, propertyName, index);
		}
		else if(pVal->vt == (VT_DISPATCH | VT_ARRAY))
		{
			// Could be an array of embedded objects.  

			SAFEARRAYBOUND aBounds[1];

			long lLBound, lUBound;
			SafeArrayGetLBound(pVal->parray, 1, &lLBound);
			SafeArrayGetUBound(pVal->parray, 1, &lUBound);

			aBounds[0].cElements = lUBound - lLBound + 1;
			aBounds[0].lLbound = lLBound;

			// Update the individual data pieces
			// ================================
			long lIndex;

			for (lIndex = lLBound; lIndex <= lUBound; lIndex++)
			{
				// Load the initial data element into a VARIANT
				// ============================================
				IDispatch * pDisp = NULL;

				if (FAILED (hRes = SafeArrayGetElement(pVal->parray, &lIndex, &pDisp)))
					break;
				
				if (pDisp)
				{
					CSWbemObject::SetSite (pDisp, pSObject, propertyName, lIndex);
					pDisp->Release ();	// To balance AddRef from SafeArrayGetElement
				}
				else
					break;
			}
		}
	}
}

//***************************************************************************
//
//  HRESULT ConvertArray
//
//  Description: 
//
//  This function is applied to VARIANT arrays in order to check for certain
//  restrictions imposed by CIMOM (e.g. they must be homogeneous) or perform
//  conversions (certain VARIANT types have to be mapped to acceptable CIMOM
//	types).
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT ConvertArray(VARIANT * pDest, VARIANT * pSrc, BOOL bQualTypesOnly,
					 VARTYPE requiredVarType)
{
	VARTYPE vtPut;
  
	// Now is not (yet) the time to perform SWbemObject->IWbemClassObject conversion
	if (VT_UNKNOWN == requiredVarType)
		requiredVarType = VT_DISPATCH;

	// Treat these imposters just the same...
	if (VT_EMPTY == requiredVarType)
		requiredVarType = VT_NULL;

    if(pSrc == NULL || pDest == NULL)
        return WBEM_E_FAILED;

	if (!(V_VT(pSrc) & VT_ARRAY) || !(V_VT(pSrc) & VT_VARIANT))
		return WBEM_E_FAILED;

	// Extract the source SAFEARRAY (how depends on whether VT_BYREF is set)
	SAFEARRAY *parray = NULL;

	if (VT_BYREF & V_VT(pSrc))
	{
		if (pSrc->pparray)
			parray = *(pSrc->pparray);
	}
	else
		parray = pSrc->parray;


	if (!parray)
		return WBEM_E_FAILED;

    // Determine the size of the source array.  Also make sure that the array 
    // only has one dimension

    unsigned int uDim = SafeArrayGetDim(parray);
    if(uDim != 1)
        return WBEM_E_FAILED;      // Bad array, or too many dimensions
    long ix[2] = {0,0};
    long lLower, lUpper;
    SCODE sc = SafeArrayGetLBound(parray,1,&lLower);
    if(sc != S_OK)
        return sc;
    sc = SafeArrayGetUBound(parray,1,&lUpper);
    if(sc != S_OK)
        return sc;
    int iNumElements = lUpper - lLower +1; 

    if(iNumElements == 0)
	{
		// Degenerate case of an empty array - simply create an empty
		// copy with a VT_VARIANT type for properties
		if (!bQualTypesOnly)
			vtPut = VT_VARIANT;
		else 
		{
			// For qualifiers, we can hope that we've been given a candidate
			// type from an existing value; otherwise we'll just have to make one up.
			vtPut = (VT_NULL != requiredVarType) ? requiredVarType : VT_I4;
		}
	}
	else
	{
		// Use an explicit type if it was supplied
		if (VT_NULL != requiredVarType)
		{
			vtPut = requiredVarType;
		}
		else
		{
			// Try an infer one from the array supplied
			// Make sure all the elements of the source array are of the same type.

			for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
			{
				VARIANT var;
				VariantInit(&var);
                   
				sc = SafeArrayGetElement(parray,ix,&var);
				if(sc != S_OK)
					return sc;
				VARTYPE vt =  var.vt;
				VariantClear(&var);

				if(ix[0] == lLower)
					vtPut = vt;
				else if (vtPut != vt)
				{
					// The vartype is different from that previously encountered.
					// In general this is an error, but it is possible that we may
					// wish to "upcast" to a common vartype in certain circumstances,
					// as the automation controller may return heterogenous arrays.
					// The only cases in which this applies are:
					//
					//	1. VT_UI1, VT_I2, VT_I4 should be upcast to the widest
					//	   occurring type in the array.
					//
					//	2. VT_R4, VT_R8 should be upcast to the widest occuring type
					//     in the array
					//
					//	All other cases are treated as an error.

					bool error = true;

					switch (vtPut)
					{
						case VT_UI1:
							if ((VT_I2 == vt) || (VT_I4 == vt))
							{
								error = false;
								vtPut = vt;
							}
							break;

						case VT_I2:
							if (VT_UI1 == vt)
							{
								error = false;
							}
							else if (VT_I4 == vt)
							{
								error = false;
								vtPut = vt;
							}
							break;

						case VT_I4:
							if ((VT_I2 == vt) || (VT_UI1 == vt))
								error = false;
							break;

						case VT_R4:
							if (VT_R8 == vt)
							{
								error = false;
								vtPut = vt;
							}
							break;

						case VT_R8:
							if (VT_R4 == vt)
								error = false;
							break;
					}

					if (error)
						return WBEM_E_INVALID_PARAMETER;
				}
			}

			// Having made our best guess, we may need to refine it
			// if we are being restricted to qualifier types only
			if(bQualTypesOnly)
				vtPut = GetAcceptableQualType(vtPut);
		}
	}

    // Create a destination array of equal size
    SAFEARRAYBOUND rgsabound[1]; 
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    SAFEARRAY * pDestArray = SafeArrayCreate(vtPut,1,rgsabound);

    for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
    {
        VARIANT var;
        VariantInit(&var);
                   
        sc = SafeArrayGetElement(parray,ix,&var);
        if(sc != S_OK)
		{
			SafeArrayDestroy (pDestArray);
            return sc;
		}

        if(var.vt != vtPut)
        {
            // do the conversion to the acceptable type and put that

            VARIANT vTemp;
            VariantInit(&vTemp);
            LCID lcid = GetSystemDefaultLCID();
            sc = VariantChangeTypeEx(&vTemp, &var, lcid, 0, vtPut);

            if(sc != S_OK)
			{
				SafeArrayDestroy (pDestArray);
                return sc;
			}

            if(vtPut == VT_BSTR || vtPut == VT_UNKNOWN || vtPut == VT_DISPATCH)
                sc = SafeArrayPutElement(pDestArray,ix,(void *)vTemp.bstrVal);
            else
                sc = SafeArrayPutElement(pDestArray,ix,(void *)&vTemp.lVal);

            VariantClear(&vTemp);
        }
        else
        {
            if(vtPut == VT_BSTR || vtPut == VT_UNKNOWN || vtPut == VT_DISPATCH)
                sc = SafeArrayPutElement(pDestArray,ix,(void *)var.bstrVal);
            else
                sc = SafeArrayPutElement(pDestArray,ix,(void *)&var.lVal);
        }

        VariantClear(&var);
    }

    pDest->vt = (VT_ARRAY | vtPut);
    pDest->parray = pDestArray;
    return S_OK;
}

//***************************************************************************
//
//  HRESULT ConvertArrayRev
//
//  Description: 
//
//  This function is applied to outbound VARIANT arrays in order to transform
//	VARIANT arrays so that each member is a VT_VARIANT rather than a simple
//	type (VT_BSTR).  This is done so that certain automation environments
//	(such as VBScript) can correctly interpret array values.
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT ConvertArrayRev(VARIANT *pDest, VARIANT *pSrc)
{
    if(pSrc == NULL || pDest == NULL || (0 == (pSrc->vt & VT_ARRAY)))
        return WBEM_E_FAILED;

    // Determine the size of the source array.  Also make sure that the array 
    // only has one dimension

    unsigned int uDim = SafeArrayGetDim(pSrc->parray);
    if(uDim != 1)
        return WBEM_E_FAILED;      // Bad array, or too many dimensions
    long ix[2] = {0,0};
    long lLower, lUpper;
    SCODE sc = SafeArrayGetLBound(pSrc->parray,1,&lLower);
    if(sc != S_OK)
        return sc;
    sc = SafeArrayGetUBound(pSrc->parray,1,&lUpper);
    if(sc != S_OK)
        return sc;
    int iNumElements = lUpper - lLower +1; 
    
    VARTYPE vtSimple = pSrc->vt & ~VT_ARRAY;
    
    // Create a destination array of equal size

    SAFEARRAYBOUND rgsabound[1]; 
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    SAFEARRAY *pDestArray = SafeArrayCreate(VT_VARIANT,1,rgsabound);

    for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
    {
        VARIANT var;
        VariantInit(&var);
		var.vt = vtSimple;
                   
		switch (var.vt)
		{
			case VT_BSTR:
			{
				BSTR bstrVal = NULL;
				if (S_OK == (sc = SafeArrayGetElement (pSrc->parray, ix, &bstrVal)))
				{
					var.bstrVal = SysAllocString (bstrVal);
					SysFreeString (bstrVal);
				}
			}
				break;

			case VT_DISPATCH:
			{
				IDispatch *pDispatch = NULL;
				if (S_OK == (sc = SafeArrayGetElement (pSrc->parray, ix, &pDispatch)))
					var.pdispVal = pDispatch;
			}
				break;

			case VT_UNKNOWN:
			{
				IUnknown *pUnknown = NULL;
				if (S_OK == (sc = SafeArrayGetElement (pSrc->parray, ix, &pUnknown)))
					var.punkVal = pUnknown;
			}
				break;

			default:
			{
				// Assume simple integer value
				sc = SafeArrayGetElement (pSrc->parray, ix, &(var.lVal));
			}
				break;
		}

		if(sc != S_OK)
            return sc;

		sc = SafeArrayPutElement (pDestArray, ix, &var);
        VariantClear(&var);
    }

    pDest->vt = (VT_ARRAY | VT_VARIANT);
    pDest->parray = pDestArray;
    return S_OK;
}

//***************************************************************************
//
//  HRESULT ConvertBSTRArray
//
//  Description: 
//
//  This function is applied to outbound SAFEARRAY's of BSTRs in order to 
//	transform then into SAFEARRAY's of VARIANTs (each of type VT_BSTR).  This
//	is required by scripting environments (such as VBScript0 which do not
//	support SAFEARRAY of non-VARIANT types.
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT ConvertBSTRArray(SAFEARRAY **ppDest, SAFEARRAY *pSrc)
{
    if(pSrc == NULL || ppDest == NULL)
        return WBEM_E_FAILED;

    // Determine the size of the source array.  Also make sure that the array 
    // only has one dimension

    unsigned int uDim = SafeArrayGetDim(pSrc);
    if(uDim != 1)
        return WBEM_E_FAILED;      // Bad array, or too many dimensions
    long ix[2] = {0,0};
    long lLower, lUpper;
    SCODE sc = SafeArrayGetLBound(pSrc,1,&lLower);
    if(sc != S_OK)
        return sc;
    sc = SafeArrayGetUBound(pSrc,1,&lUpper);
    if(sc != S_OK)
        return sc;
    int iNumElements = lUpper - lLower +1; 
    if(iNumElements == 0)
        return WBEM_E_FAILED;

    // Create a destination array of equal size

    SAFEARRAYBOUND rgsabound[1]; 
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    *ppDest = SafeArrayCreate(VT_VARIANT,1,rgsabound);

    for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) 
    {
        VARIANT var;
        VariantInit(&var);
		var.vt = VT_BSTR;
                   
		BSTR bstrVal = NULL;
		if (S_OK == (sc = SafeArrayGetElement (pSrc, ix, &bstrVal)))
		{
			var.bstrVal = SysAllocString (bstrVal);
			SysFreeString (bstrVal);
		}
		
		if(sc != S_OK)
            return sc;

		sc = SafeArrayPutElement (*ppDest, ix, &var);
        VariantClear(&var);
    }

    return S_OK;
}

//***************************************************************************
//
//  HRESULT QualifierVariantChangeType
//
//  DESCRIPTION:
//
//  Just like VariantChangeType, but deals with arrays as well.
//
//  PARAMETERS:
//
//  VARIANT pvDest      Destination variant
//  VARIANT pvSrc       Source variant (can be the same as pvDest)
//  VARTYPE vtNew       The type to coerce to.
//
//***************************************************************************

HRESULT QualifierVariantChangeType (VARIANT* pvDest, VARIANT* pvSrc, 
                                        VARTYPE vtNew)
{
    HRESULT hres = DISP_E_TYPEMISMATCH;

    if(V_VT(pvSrc) == VT_NULL)
    {
        return VariantCopy(pvDest, pvSrc);
    }

    if (vtNew & VT_ARRAY)
    {
        // It's an array, we have to do our own conversion
        // ===============================================

        if((V_VT(pvSrc) & VT_ARRAY) == 0)
            return DISP_E_TYPEMISMATCH;

		// Create a new array
        SAFEARRAY* psaSrc = V_ARRAY(pvSrc);
        SAFEARRAYBOUND aBounds[1];

        long lLBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);
        long lUBound;
        SafeArrayGetUBound(psaSrc, 1, &lUBound);
        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        SAFEARRAY* psaDest = SafeArrayCreate(vtNew & ~VT_ARRAY, 1, aBounds);
		long lIndex;

		for (lIndex = lLBound; lIndex <= lUBound; lIndex++)
		{
			// Load the initial data element into a VARIANT
			// ============================================
			VARIANT vSrcEl;
			VariantInit (&vSrcEl);
			V_VT(&vSrcEl) = V_VT(pvSrc) & ~VT_ARRAY;
			SafeArrayGetElement(psaSrc, &lIndex, &V_UI1(&vSrcEl));

			// Cast it to the new type
			// =======================
			if (SUCCEEDED (hres = VariantChangeType(&vSrcEl, &vSrcEl, 0, vtNew & ~VT_ARRAY)))
			{
				// Put it into the new array
				// =========================
				if(V_VT(&vSrcEl) == VT_BSTR)
					hres = SafeArrayPutElement(psaDest, &lIndex, V_BSTR(&vSrcEl));
				else
					hres = SafeArrayPutElement(psaDest, &lIndex, &V_UI1(&vSrcEl));
			}

			VariantClear (&vSrcEl);

			if (FAILED(hres)) 
				break;
		}

		if (lUBound < lIndex)
		{
			hres = WBEM_S_NO_ERROR;
			if(pvDest == pvSrc)
				VariantClear(pvSrc);

			V_VT(pvDest) = vtNew;
			V_ARRAY(pvDest) = psaDest;
		}
		else
			SafeArrayDestroy (psaDest);
    }
    else
	    hres = VariantChangeType(pvDest, pvSrc, VARIANT_NOVALUEPROP, vtNew);

	return hres;
}

//***************************************************************************
//
//  void SetWbemError
//
//  DESCRIPTION:
//
//  For remoted WBEM COM interfaces, extra error information may be returned
//	on the thread as an IWbemClassObject.  This routine extracts that object
//	(if found) amd stores it in thread local-storage as an ISWbemObject.  The
//	object can be accessed later using the SWbemLastError coclass.
//
//  PARAMETERS:
//
//  pService		The backpointer to the CSWbemServices (used in case
//						we do property/method access on the error object)
//
//***************************************************************************

void SetWbemError (CSWbemServices *pService)
{
	EnterCriticalSection (&g_csErrorCache);

	if (g_pErrorCache)
		g_pErrorCache->SetCurrentThreadError (pService);

	LeaveCriticalSection (&g_csErrorCache);
}

//***************************************************************************
//
//  void ResetLastErrors
//
//  DESCRIPTION:
//
//  For remoted WBEM COM interfaces, extra error information may be returned
//	on the thread as an IWbemClassObject.  This routine clears that error.  It
//  also clears the ErrorInfo on the thread.  This should be called at the 
//  start of any of the API functions
//
//  PARAMETERS:
//
//***************************************************************************

void ResetLastErrors ()
{

	SetErrorInfo(0, NULL);

	EnterCriticalSection (&g_csErrorCache);

	if (g_pErrorCache)
		g_pErrorCache->ResetCurrentThreadError ();

	LeaveCriticalSection (&g_csErrorCache);
}

//***************************************************************************
//
//  HRESULT SetException
//
//  Description: 
//
//  This function fills in an EXECPINFO structure using the supplied HRESULT
//	and object name.  The former is mapped to the Err.Description property, 
//	and the latter to the Err.Source property.
//
//  Parameters:
//
//  pExcepInfo		pointer to EXCEPINFO to initialize (must not be NULL)
//	hr				HRESULT to map to string
//	bsObjectName	Name of source object that generated the error
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

void SetException (EXCEPINFO *pExcepInfo, HRESULT hr, BSTR bsObjectName)
{
	if (pExcepInfo->bstrDescription)
		SysFreeString (pExcepInfo->bstrDescription);

	pExcepInfo->bstrDescription = MapHresultToWmiDescription (hr);

	if (pExcepInfo->bstrSource)
		SysFreeString (pExcepInfo->bstrSource);

	pExcepInfo->bstrSource = SysAllocString (bsObjectName);
	pExcepInfo->scode = hr;
}

//***************************************************************************
//
//  HRESULT MapHresultToWmiDescription
//
//  Description: 
//
//  Thin wrapper around the IWbemStatusCodeText implementation.  Transforms
//	an HRESULT (which may or may not be a WMI-specific error code) into a
//	localized user-friendly description.
//
//  Parameters:
//
//	  hr				HRESULT to map to string
//
// Return Value:
//    BSTR containing the description (or NULL).
//***************************************************************************

BSTR MapHresultToWmiDescription (HRESULT hr)
{
	BSTR bsMessageText = NULL;

	// Used as our error code translator 
	IWbemStatusCodeText *pErrorCodeTranslator = NULL;

	HRESULT result = CoCreateInstance (CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemStatusCodeText, (LPVOID *) &pErrorCodeTranslator);
	
	if (SUCCEEDED (result))
	{
		HRESULT hrCode = hr;

		// Some WBEM success codes become Scripting error codes.

		if (wbemErrTimedout == hr)
			hrCode = WBEM_S_TIMEDOUT;
		else if (wbemErrResetToDefault == hr)
			hrCode = WBEM_S_RESET_TO_DEFAULT;

		HRESULT sc = pErrorCodeTranslator->GetErrorCodeText(
							hrCode, (LCID) 0, WBEMSTATUS_FORMAT_NO_NEWLINE, &bsMessageText);	

		pErrorCodeTranslator->Release ();		
	}

	return bsMessageText;
}

	
//***************************************************************************
//
//  HRESULT ConvertDispatchToArray
//
//  DESCRIPTION:
//
//  Attempt to convert from an IDispatch value to a CIM array value (property
//	qualifier or context).
//
//  PARAMETERS:
//
//		pDest		Output value
//		pSrc		Input value
//		lCimType	CIM Property type (underlying the array) - defaults to
//					CIM_ILLEGAL for Qualifier & Context value mappings.
//		bIsQual		true iff we are mapping for a qualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT ConvertDispatchToArray (
	VARIANT *pvDest,
	VARIANT *pvSrc,
	CIMTYPE lCimType,
	BOOL bIsQual,
	VARTYPE requiredQualifierType
)
{
	HRESULT hr = WBEM_E_FAILED; // Default error
	IDispatch * pDispatch = NULL;
  
	/*
	 * Extract the IDispatch pointer. NB we assume the VT of pSrc is
	 * VT_DISPATCH (possibly combined with VT_BYREF) for this function to
	 * have been called.
	 */
	if (VT_DISPATCH == V_VT(pvSrc))
		pDispatch = pvSrc->pdispVal;
    else if (pvSrc->ppdispVal)
		pDispatch = *(pvSrc->ppdispVal);
        
	if (NULL == pDispatch)
		return hr;

	// The expected var type of the property
	VARTYPE expectedVarType = VT_ERROR;
	
	if (CIM_ILLEGAL != lCimType)
		expectedVarType = CimTypeToVtType (lCimType);

	CComQIPtr<IDispatchEx> pIDispatchEx (pDispatch);

	/*
	 * We use the IDispatchEx interface to iterate through the properties
	 * of the interface.
	 */
	if (pIDispatchEx)
	{
		/*
		 * Looks promising, but just check if this isn't one of our objects
		 */
		CComQIPtr<ISWbemObject> pISWbemObject (pDispatch);

		if (!pISWbemObject)
		{
			/*
			 * Start by determining how many properties there are so we can create
			 * a suitable array.
			 */
			long propertyCount = 0;
			DISPID dispId = DISPID_STARTENUM;
			DISPPARAMS dispParams;
			dispParams.rgvarg = NULL;
			dispParams.rgdispidNamedArgs = NULL;
			dispParams.cArgs = 0;
			dispParams.cNamedArgs = 0;

			while (S_OK == pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId))
			{
				if ((0 == propertyCount) && (VT_ERROR == expectedVarType))
				{
					/*
					 * If we are setting an array value for a context/qualifier, the
					 * Vartype will not yet be determined - we will use the best
					 * we can from the first array value.
					 */
					VARIANT vPropVal;
					VariantInit (&vPropVal);

					if (SUCCEEDED (pIDispatchEx->InvokeEx (dispId, 0, 
								DISPATCH_PROPERTYGET, &dispParams, &vPropVal, NULL, NULL)))
					{
						if (bIsQual)
							expectedVarType = GetAcceptableQualType(V_VT(&vPropVal));
						else if (VT_DISPATCH == V_VT(&vPropVal))
							expectedVarType = VT_UNKNOWN;
						else
							expectedVarType = V_VT(&vPropVal);
					}

					VariantClear (&vPropVal);
				}

				//We need to check this is a "real" array entry with an index rather than some "dummy" entry
				//for some non-array properties (which can happen with JScript arrays)
				BSTR memberName = NULL;
				wchar_t *stopString=NULL;
				if (SUCCEEDED(pIDispatchEx->GetMemberName (dispId, &memberName)))
				{
					// Check that property name is numeric, only if it is we count it for the array size
					long index = wcstol (memberName, &stopString, 10);
					if ((0 == wcslen (stopString)))
						propertyCount++;
				}
			}
			
			// Create the safearray - note that it may be empty
			SAFEARRAYBOUND rgsaBound;
			rgsaBound.cElements = propertyCount;
			rgsaBound.lLbound = 0;

			SAFEARRAY *pArray = SafeArrayCreate (expectedVarType, 1, &rgsaBound);
				
			if (0 < propertyCount)
			{
				// Enumerate the DISPIDs on this interface
				dispId = DISPID_STARTENUM;
				long nextExpectedIndex = 0;
				HRESULT enumHr;
				wchar_t *stopString = NULL;

				/*
				 * For JScript arrays, the property names are the specified indices of the 
				 * the array; these can be integer indices or they can be strings.  We make
				 * the following requirements of the array indices:
				 *
				 * (1) All of the indices are non-negative integers
				 * (2) The indices start at 0 and are contiguous.
				 */

				while (S_OK == (enumHr = pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId)))
				{
					BSTR memberName = NULL;
					if (SUCCEEDED(pIDispatchEx->GetMemberName (dispId, &memberName)))
					{
					
						// Check that property name is numeric
						long index = wcstol (memberName, &stopString, 10);

						if ((0 != wcslen (stopString)))
						{
							// Failure - cannot convert to integer
							// Since JScript arrays may have additional "members" that are not real array members,
							// depending on different properties that may be accessed on them, we should just
							// ignore non-numeric items - instead of failing the whole thing...
							SysFreeString (memberName);
							memberName = NULL;
							continue;
						}
						SysFreeString (memberName);
						memberName = NULL;
						
						if (index != nextExpectedIndex)
						{
							// Failure - non-contiguous array
							break;
						}

						nextExpectedIndex++;

						// Extract the property
						VARIANT vPropVal;
						VariantInit (&vPropVal);
						HRESULT hrInvoke;
							
						if (SUCCEEDED (hrInvoke = pIDispatchEx->InvokeEx (dispId, 0, 
									DISPATCH_PROPERTYGET, &dispParams, &vPropVal, NULL, NULL)))
						{
							HRESULT hr2 = WBEM_E_FAILED;

							// Take care of embedded objects
							if ((S_OK == MapToCIMOMObject (&vPropVal)) &&
								(S_OK == VariantChangeType (&vPropVal, &vPropVal, 0, expectedVarType)))
							{

								switch (expectedVarType)
								{
									case VT_BSTR:
										hr2 = SafeArrayPutElement (pArray, &index, (void*)vPropVal.bstrVal);
										break;

									case VT_UNKNOWN:
										if (!bIsQual)
											hr2 = SafeArrayPutElement (pArray, &index, (void*)vPropVal.punkVal);
										break;

									default:
										hr2 = SafeArrayPutElement (pArray, &index, (void*)&vPropVal.lVal);
										break;
								}
							}

							VariantClear (&vPropVal);

							if (FAILED(hr2))
								break;
						}
						else
						{
							// Failure - couldn't invoke method
							break;
						}
					} // GetMemberName SUCCEEDED
				} // while loop

				if (S_FALSE == enumHr)
				{
					// Now construct the new property value using our array
					VariantInit (pvDest);
					pvDest->vt = VT_ARRAY | expectedVarType;
					pvDest->parray = pArray;
					hr = S_OK;
				}
				else
				{
					// Something went wrong
					SafeArrayDestroy (pArray);
					hr = WBEM_E_INVALID_PARAMETER;
				}
			}	
			else
			{
				// Degenerate case of an empty array - simply create an empty
				// copy with a VT_VARIANT type for properties
				if (!bIsQual)
					expectedVarType = VT_VARIANT;
				else 
				{
					// For qualifiers, we can hope that we've been given a candidate
					// type from an existing value; otherwise we'll just have to make one up.
					expectedVarType = (VT_NULL != requiredQualifierType) ? requiredQualifierType :
																VT_I4;
				}

				VariantInit (pvDest);
				pvDest->vt = VT_ARRAY | expectedVarType;
				pvDest->parray = pArray;
				hr = S_OK;
			}
		}
	}

	return hr;
}

//***************************************************************************
//
//  void MapNulls
//
//  Description: 
//
//  The passing of a "null" value from script (where "null" in VB/VBS and JS
//	is the keyword null, and is an undefined variable in Perl) may be interpreted
//	by this API as equivalent to a default value for certain method calls.
//
//	This function is used to map VT_NULL dispatch parameters to the VB standard
//	realization of "missing" parameters, i.e. a VT_ERROR value whose scode is
//	DISP_E_PARAMNOTFOUND.
//
//  Parameters:
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

void	MapNulls (DISPPARAMS FAR* pdispparams)
{
	if (pdispparams)
	{
		for (unsigned int i = 0; i < pdispparams->cArgs; i++)
		{
			VARIANTARG &v = pdispparams->rgvarg [i];

			if (VT_NULL == V_VT(&v))
			{
				v.vt = VT_ERROR;
				v.scode = DISP_E_PARAMNOTFOUND;
			}
			else if (((VT_VARIANT|VT_BYREF) == V_VT(&v)) &&
					 (VT_NULL == V_VT(v.pvarVal)))
			{
				v.vt = VT_ERROR;
				v.scode = DISP_E_PARAMNOTFOUND;
			}
		}
	}
}

//***************************************************************************
//
//  BSTR FormatAssociatorsQuery
//
//  Description: 
//
//  Takes the parameters to an AssociatorsOf call and constructs a WQL
//	query string from them.
//
//  Returns:	The constructed WQL query; this must be freed using 
//				SysFreeString by the caller.
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

BSTR FormatAssociatorsQuery 
( 
	BSTR strObjectPath,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strResultRole,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredAssocQualifier,
	BSTR strRequiredQualifier
)
{
	BSTR bsQuery = NULL;

	// Get the length of the string:
	//  associators of {SourceObject} where    
	//  AssocClass = AssocClassName
	//  ClassDefsOnly    
	//  SchemaOnly
	//  RequiredAssocQualifier = QualifierName
	//  RequiredQualifier = QualifierName    
	//  ResultClass = ClassName
	//  ResultRole = PropertyName    
	//  Role = PropertyName

	long queryLength = 1; // Terminating NULL
	queryLength += wcslen (WBEMS_QUERY_ASSOCOF) +
				   wcslen (WBEMS_QUERY_OPENBRACE) +
				   wcslen (WBEMS_QUERY_CLOSEBRACE) +
				   wcslen (strObjectPath);

	bool needWhere = false;

	if ((strAssocClass && (0 < wcslen (strAssocClass))) ||
		(strResultClass && (0 < wcslen (strResultClass))) ||
		(strResultRole && (0 < wcslen (strResultRole))) ||
		(strRole && (0 < wcslen (strRole))) ||
		(VARIANT_FALSE != bClassesOnly) ||
		(VARIANT_FALSE != bSchemaOnly) ||
		(strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier))) ||
		(strRequiredQualifier && (0 < wcslen (strRequiredQualifier))))
	{
		needWhere = true;
		queryLength += wcslen (WBEMS_QUERY_WHERE);
	}

	if (strAssocClass && (0 < wcslen (strAssocClass)))
		queryLength += wcslen (WBEMS_QUERY_ASSOCCLASS) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strAssocClass);

	if (strResultClass && (0 < wcslen (strResultClass)))
		queryLength += wcslen (WBEMS_QUERY_RESCLASS) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strResultClass);

	if (strResultRole && (0 < wcslen (strResultRole)))
		queryLength += wcslen (WBEMS_QUERY_RESROLE) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strResultRole);

	if (strRole && (0 < wcslen (strRole)))
		queryLength += wcslen (WBEMS_QUERY_ROLE) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRole);

	if (VARIANT_FALSE != bClassesOnly)
		queryLength += wcslen (WBEMS_QUERY_CLASSDEFS);

	if (VARIANT_FALSE != bSchemaOnly)
		queryLength += wcslen (WBEMS_QUERY_SCHEMAONLY);

	if (strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier)))
		queryLength += wcslen (WBEMS_QUERY_REQASSOCQ) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRequiredAssocQualifier);

	if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		queryLength += wcslen (WBEMS_QUERY_REQQUAL) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRequiredQualifier);

	// Allocate the string and fill it in
	bsQuery = SysAllocStringLen (WBEMS_QUERY_ASSOCOF, queryLength);
	wcscat (bsQuery, WBEMS_QUERY_OPENBRACE);
	wcscat (bsQuery, strObjectPath);
	wcscat (bsQuery, WBEMS_QUERY_CLOSEBRACE);

	if (needWhere)
	{
		wcscat (bsQuery, WBEMS_QUERY_WHERE);

		if (strAssocClass && (0 < wcslen (strAssocClass)))
		{
			wcscat (bsQuery, WBEMS_QUERY_ASSOCCLASS);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strAssocClass);
		}

		if (strResultClass && (0 < wcslen (strResultClass)))
		{
			wcscat (bsQuery, WBEMS_QUERY_RESCLASS);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strResultClass);
		}
		
		if (strResultRole && (0 < wcslen (strResultRole)))
		{
			wcscat (bsQuery, WBEMS_QUERY_RESROLE);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strResultRole);
		}

		if (strRole && (0 < wcslen (strRole)))
		{
			wcscat (bsQuery, WBEMS_QUERY_ROLE);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRole);
		}

		if (VARIANT_FALSE != bClassesOnly)
			wcscat (bsQuery, WBEMS_QUERY_CLASSDEFS);

		if (VARIANT_FALSE != bSchemaOnly)
			wcscat (bsQuery, WBEMS_QUERY_SCHEMAONLY);

		if (strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier)))
		{
			wcscat (bsQuery, WBEMS_QUERY_REQASSOCQ);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredAssocQualifier);
		}
			
		if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		{
			wcscat (bsQuery, WBEMS_QUERY_REQQUAL);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredQualifier);
		}
	}


	return bsQuery;
}


//***************************************************************************
//
//  BSTR FormatReferencesQuery
//
//  Description: 
//
//  Takes the parameters to an ReferencesOf call and constructs a WQL
//	query string from them.
//
//  Returns:	The constructed WQL query; this must be freed using 
//				SysFreeString by the caller.
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

BSTR FormatReferencesQuery 
( 
	BSTR strObjectPath,
	BSTR strResultClass,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredQualifier
)
{
	BSTR bsQuery = NULL;

	// Get the length of the string:
	//  references of {SourceObject} where    
	//  ClassDefsOnly    
	//  SchemaOnly
	//  RequiredQualifier = QualifierName    
	//  ResultClass = ClassName
	//  Role = PropertyName
	long queryLength = 1; // Terminating NULL
	queryLength += wcslen (WBEMS_QUERY_REFOF) +
				   wcslen (WBEMS_QUERY_OPENBRACE) +
				   wcslen (WBEMS_QUERY_CLOSEBRACE) +
				   wcslen (strObjectPath);

	bool needWhere = false;

	if ((strResultClass && (0 < wcslen (strResultClass))) ||
		(strRole && (0 < wcslen (strRole))) ||
		(VARIANT_FALSE != bClassesOnly) ||
		(VARIANT_FALSE != bSchemaOnly) ||
		(strRequiredQualifier && (0 < wcslen (strRequiredQualifier))))
	{
		needWhere = true;
		queryLength += wcslen (WBEMS_QUERY_WHERE);
	}

	if (strResultClass && (0 < wcslen (strResultClass)))
		queryLength += wcslen (WBEMS_QUERY_RESCLASS) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strResultClass);

	if (strRole && (0 < wcslen (strRole)))
		queryLength += wcslen (WBEMS_QUERY_ROLE) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRole);

	if (VARIANT_FALSE != bClassesOnly)
		queryLength += wcslen (WBEMS_QUERY_CLASSDEFS);

	if (VARIANT_FALSE != bSchemaOnly)
		queryLength += wcslen (WBEMS_QUERY_SCHEMAONLY);

	if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		queryLength += wcslen (WBEMS_QUERY_REQQUAL) +
					   wcslen (WBEMS_QUERY_EQUALS) +
					   wcslen (strRequiredQualifier);

	// Allocate the string and fill it in
	bsQuery = SysAllocStringLen (WBEMS_QUERY_REFOF, queryLength);
	wcscat (bsQuery, WBEMS_QUERY_OPENBRACE);
	wcscat (bsQuery, strObjectPath);
	wcscat (bsQuery, WBEMS_QUERY_CLOSEBRACE);

	if (needWhere)
	{
		wcscat (bsQuery, WBEMS_QUERY_WHERE);

		if (strResultClass && (0 < wcslen (strResultClass)))
		{
			wcscat (bsQuery, WBEMS_QUERY_RESCLASS);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strResultClass);
		}
		
		if (strRole && (0 < wcslen (strRole)))
		{
			wcscat (bsQuery, WBEMS_QUERY_ROLE);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRole);
		}

		if (VARIANT_FALSE != bClassesOnly)
			wcscat (bsQuery, WBEMS_QUERY_CLASSDEFS);

		if (VARIANT_FALSE != bSchemaOnly)
			wcscat (bsQuery, WBEMS_QUERY_SCHEMAONLY);

		if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		{
			wcscat (bsQuery, WBEMS_QUERY_REQQUAL);
			wcscat (bsQuery, WBEMS_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredQualifier);
		}
	}

	return bsQuery;
}

//***************************************************************************
//
//  BSTR FormatMultiQuery
//
//  Description: 
//
//  Takes an array of class names and formats a multi query
//
//  Returns:	The constructed WQL query; this must be freed using 
//				SysFreeString by the caller.
//
//  classArray		SAFEARRAY of class names
//	iNumElements	length of array
//
//***************************************************************************

BSTR FormatMultiQuery ( 
	SAFEARRAY & classArray,
	long		iNumElements
)
{
	BSTR bsQuery = NULL;
	
	long queryLength = 1; // Terminating NULL
	queryLength += (iNumElements * wcslen (WBEMS_QUERY_SELECT)) +
				   ((iNumElements - 1) * wcslen (WBEMS_QUERY_GO));

	// Work out the string lengths
	HRESULT hr = S_OK;

	for (long i = 0; i < iNumElements && hr == S_OK; i++) 
	{
		BSTR bsName = NULL;
                   
		if (SUCCEEDED(hr = SafeArrayGetElement(&classArray, &i, &bsName)))
		{
			queryLength += wcslen (bsName);
			SysFreeString (bsName);
		}
	}

	if (SUCCEEDED(hr))
	{
		// Allocate the string and fill it in
		bsQuery = SysAllocStringLen (WBEMS_QUERY_SELECT, queryLength);

		for (long i = 0; i < iNumElements && hr == S_OK; i++) 
		{
			BSTR bsName = NULL;
                   
			if (SUCCEEDED(hr = SafeArrayGetElement(&classArray, &i, &bsName)))
			{
				if (i > 0)
					wcscat (bsQuery, WBEMS_QUERY_SELECT);

				wcscat (bsQuery, bsName);
				SysFreeString (bsName);

				if (i < iNumElements - 1)
					wcscat (bsQuery, WBEMS_QUERY_GO);
			}
		}
	}

	return bsQuery;
}

//***************************************************************************
//
//  EnsureGlobalsInitialized
//
//  DESCRIPTION:
//
//  Checks whether the g_pErrorCache global pointer is correctly initialized 
//	and, if not, assigns it appropriately.
//
//***************************************************************************

void EnsureGlobalsInitialized ()
{
	// Initialize security
	CSWbemSecurity::Initialize ();
	
	EnterCriticalSection (&g_csErrorCache);

	// Initlialize the error cache if proof be need be
	if ( ! g_pErrorCache )
		g_pErrorCache = new CWbemErrorCache ();
	
	LeaveCriticalSection (&g_csErrorCache);
}

#ifdef _RDEBUG

#undef _RPrint

void _RRPrint(int line, const char *file, const char *func, 
											const char *str, long code, const char *str2) 
{
	FILE *fp = fopen("c:/out.txt", "a");

	fprintf (fp, "%s %s(%d): %s - %s %ld(0x%lx)\n", file, func, line, str, str2, code, code);

	fclose(fp);
}
#endif


//***************************************************************************
//
//  CanCoerceString
//
//  DESCRIPTION:
//
//  Attempts to determine whether the supplied BSTR value can be cast
//	more tightly to the given CIM type.
//
//  PARAMETERS:
//		pVal		the variant in question
//		cimType		the casting CIM type
//
//  RETURN VALUES:
//		TRUE iff the cast is OK.
//
//***************************************************************************

bool CanCoerceString (
	const BSTR & bsValue,
	WbemCimtypeEnum cimType
)
{
	bool result = false;

	switch (cimType)
	{
		case wbemCimtypeReference:
		{
			CSWbemObjectPath objPath;
			result = SUCCEEDED (objPath.put_Path (bsValue));
		}
			break;

		case wbemCimtypeDatetime:
		{
			CSWbemDateTime dateTime;
			result = SUCCEEDED (dateTime.put_Value (bsValue));
		}
			break;

		case wbemCimtypeSint64:	
		{
			__int64 ri64;
			result = ReadI64(bsValue, ri64);
		}
			break;

		case wbemCimtypeUint64:
		{
			unsigned __int64 ri64;
			result = ReadUI64(bsValue, ri64);
		}
			break;

		case wbemCimtypeString:
			result = true;
			break;
	}

	return result;
}

//***************************************************************************
//
//  MapVariantTypeToCimType
//
//  DESCRIPTION:
//
//  Attempts to come up with a decent CIM type for the supplied VARIANT value.
//
//  PARAMETERS:
//		pVal		the variant in question
//		iCimType		preferred cimtype (if appropriate)
//
//  RETURN VALUES:
//		A best match CIM type
//
//***************************************************************************

WbemCimtypeEnum MapVariantTypeToCimType (
	VARIANT *pVal,
	CIMTYPE iCimType)
{
	WbemCimtypeEnum cimType = wbemCimtypeSint32;

	if (pVal)
	{
		VARIANT vTemp;
		VariantInit (&vTemp);

		if ((VT_EMPTY == V_VT(pVal)) || (VT_NULL == V_VT(pVal)))
			cimType = (CIM_ILLEGAL == iCimType) ?
							wbemCimtypeSint32 : (WbemCimtypeEnum) iCimType;
		else if (((VT_ARRAY | VT_VARIANT) == V_VT(pVal)) ||
			     ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVal)))
        {
			// Need to dig out the array type
		    if ((S_OK == ConvertArray(&vTemp, pVal)) &&
            	(S_OK == MapToCIMOMObject(&vTemp)))
			{
				// Check for empty array
				long lLower, lUpper;

				if ((SUCCEEDED(SafeArrayGetLBound(vTemp.parray,1,&lLower))) &&
				    (SUCCEEDED(SafeArrayGetUBound(vTemp.parray,1,&lUpper))))
				{
					if (0 == lUpper - lLower + 1)
					{
						// For an empty array, we use wbemCimtypeSint32 unless
						// we have been supplied a valid override
						cimType = (CIM_ILLEGAL == iCimType) ?
							wbemCimtypeSint32 : (WbemCimtypeEnum) iCimType;
					}
					else
					{
						// Pick something that matches our value and override 
						// as best we can
						cimType = GetCIMType (vTemp, iCimType, true, lLower, lUpper);
					}
				}
			}
		}
		else 
		{
			// Look for an IDispatch that needs to be mapped to an array
			if (((VT_DISPATCH == V_VT(pVal)) || ((VT_DISPATCH|VT_BYREF) == V_VT(pVal))))
			{
				if (S_OK == ConvertDispatchToArray (&vTemp, pVal, cimType & ~CIM_FLAG_ARRAY))
				{
					// Check for empty array
					long lLower, lUpper;

					if ((SUCCEEDED(SafeArrayGetLBound(vTemp.parray,1,&lLower))) &&
						(SUCCEEDED(SafeArrayGetUBound(vTemp.parray,1,&lUpper))))
					{
						if (0 == lUpper - lLower + 1)
							cimType = (CIM_ILLEGAL == iCimType) ?
									wbemCimtypeSint32 : (WbemCimtypeEnum) iCimType;
						else
							cimType = GetCIMType (vTemp, iCimType, true, lLower, lUpper);
					}
				}	
				else
				{
					// Could be a plain old interface pointer for CIM_IUNKNOWN
					if (SUCCEEDED(VariantCopy (&vTemp, pVal)))
					{
						if (S_OK == MapToCIMOMObject(&vTemp))
							cimType = GetCIMType (vTemp, iCimType);
					}
				}
			}
			else
			{
				// The vanilla case
				if (SUCCEEDED(VariantCopy (&vTemp, pVal)))
				{
					if (S_OK == MapToCIMOMObject(&vTemp))
						cimType = GetCIMType (vTemp, iCimType);
				}
			}			
		}

		VariantClear (&vTemp);
	}

	return cimType;
}

//***************************************************************************
//
//  GetCIMType
//
//  DESCRIPTION:
//
//  Attempts to come up with a decent CIM type for the supplied VARIANT,
//	with (optionally) a legal CIMType "serving suggestion" to help resolve 
//	ambiguities.
//
//	Note that this function doesn't deal with empty arrays; that has 
//	already been taken care of by the caller. It also can assume that the
//	array is (VARTYPE) homogeneous, for the same reason.
//
//  PARAMETERS:
//		pVal		the variant in question
//		iCimType	preferred cimtype (if appropriate, else wbemCimtypeIllegal)
//
//  RETURN VALUES:
//		A best match CIM type
//
//***************************************************************************

WbemCimtypeEnum GetCIMType (
	VARIANT & var,
	CIMTYPE iCimType,
	bool bIsArray,
	long lLBound,
	long lUBound
)
{
	WbemCimtypeEnum cimType = wbemCimtypeSint32;

	switch (V_VT(&var) & ~VT_ARRAY)
	{
		/*
		 * Note that prior to this function being called
		 * we will have transformed VT_DISPATCH's to 
		 * VT_UNKNOWN's.
		 */
		case VT_UNKNOWN:
		{
			/*
			 * Could be an embedded object or just a regular
			 * IUnknown.
			 */
			if (bIsArray)
			{
				long ix = 0;
				bool bCanBeServingSuggestion = true;
					
				for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
				{
					CComPtr<IUnknown> pIUnknown;

					if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&pIUnknown)))
					{
						CComQIPtr<IWbemClassObject> pIWbemClassObject (pIUnknown);

						if (!pIWbemClassObject)
							bCanBeServingSuggestion = false;
					}
					else 
						bCanBeServingSuggestion = false;
				}

				if (bCanBeServingSuggestion)
					cimType = wbemCimtypeObject;
			}
			else
			{
				CComQIPtr<IWbemClassObject> pIWbemClassObject (var.punkVal);

				if (pIWbemClassObject)
					cimType = wbemCimtypeObject;
			}
		}
			break;

		case VT_EMPTY:
		case VT_ERROR:
		case VT_NULL:
			if (CIM_ILLEGAL == iCimType)
				cimType = wbemCimtypeSint32;	// Pick something
			else
				cimType = (WbemCimtypeEnum) iCimType;		// Anything goes
			break;

		case VT_VARIANT:
		case VT_DISPATCH:
			// Can't handle these with CIM types
			break;		

		case VT_I2:
		{
			cimType = wbemCimtypeSint16; // default

			switch (iCimType)
			{
				case wbemCimtypeSint32:
				case wbemCimtypeUint32:
				case wbemCimtypeSint64:
				case wbemCimtypeUint64:
				case wbemCimtypeSint16:
				case wbemCimtypeUint16:
				case wbemCimtypeChar16:
					cimType = (WbemCimtypeEnum) iCimType;
					break;
			
				// May be able to use a smaller type but
				// only if the value "fits"
				case wbemCimtypeSint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							short iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0x7F) || (-iVal > 0x80))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.iVal <= 0x7F) && (-var.iVal <= 0x80))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeUint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							short iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0xFF) || (iVal < 0))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.iVal <= 0xFF) && (var.iVal >= 0))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;
			}
		}
			break;

		case VT_I4:
		{
			cimType = wbemCimtypeSint32;	// default

			switch (iCimType)
			{
				case wbemCimtypeSint32:
				case wbemCimtypeUint32:
				case wbemCimtypeSint64:
				case wbemCimtypeUint64:
					cimType = (WbemCimtypeEnum) iCimType;
					break;
			
				// May be able to use a smaller type but
				// only if the value "fits"
				case wbemCimtypeSint16:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0x7FFF) || (-iVal > 0x8000))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0x7FFF) && (-var.lVal <= 0x8000))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeUint16:
				case wbemCimtypeChar16:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0xFFFF) || (iVal < 0))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0xFFFF) && (var.lVal >= 0))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeSint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0x7F) || (-iVal > 0x80))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0x7F) && (-var.lVal <= 0x80))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;

				case wbemCimtypeUint8:
					if (bIsArray)
					{
						long ix = 0;
						bool bCanBeServingSuggestion = true;
							
						for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
						{
							long iVal = 0;

							if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&iVal)))
							{
								if ((iVal > 0xFF) || (iVal < 0))
									bCanBeServingSuggestion = false;
							}
							else 
								bCanBeServingSuggestion = false;
						}

						if (bCanBeServingSuggestion)
							cimType = (WbemCimtypeEnum) iCimType;
					}
					else
					{
						if ((var.lVal <= 0xFF) && (var.lVal >= 0))
							cimType = (WbemCimtypeEnum) iCimType;
					}
					break;
			}
		}
			break;

		case VT_UI1:
			if ((wbemCimtypeSint16 == iCimType) ||
				(wbemCimtypeUint16 == iCimType) ||
				(wbemCimtypeSint8 == iCimType) ||
				(wbemCimtypeUint8 == iCimType) ||
				(wbemCimtypeChar16 == iCimType) ||
				(wbemCimtypeSint32 == iCimType) ||
				(wbemCimtypeUint32 == iCimType) ||
				(wbemCimtypeSint64 == iCimType) ||
				(wbemCimtypeUint64 == iCimType))
				cimType = (WbemCimtypeEnum) iCimType;
			else
				cimType = wbemCimtypeUint8;	
			break;

		case VT_R8:
			if (wbemCimtypeReal64 == iCimType)
				cimType = (WbemCimtypeEnum) iCimType;
			else if (wbemCimtypeReal32 == iCimType)
			{
				if (bIsArray)
				{
					long ix = 0;
					bool bCanBeServingSuggestion = true;
						
					for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
					{
						double dblVal = 0;

						if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&dblVal)))
						{
							if (dblVal != (double)dblVal)
								bCanBeServingSuggestion = false;
						}
						else 
							bCanBeServingSuggestion = false;
					}

					if (bCanBeServingSuggestion)
						cimType = (WbemCimtypeEnum) iCimType;
				}
				else
				{
					if (var.dblVal == (float)(var.dblVal))
						cimType = (WbemCimtypeEnum) iCimType;
				}
			}
			else
				cimType = wbemCimtypeReal64;	
			break;

		case VT_R4:
			if ((wbemCimtypeReal32 == iCimType) ||
				(wbemCimtypeReal64 == iCimType))
				cimType = (WbemCimtypeEnum) iCimType;
			else
				cimType = wbemCimtypeReal32;	
			break;

		case VT_BOOL:
			cimType = wbemCimtypeBoolean;	
			break;

		case VT_CY:
		case VT_DATE:
			cimType = wbemCimtypeString;	// Only sensible choice
			break;

		case VT_BSTR:
		{
			cimType = wbemCimtypeString;	// Unless we get a tighter fit

			if ((wbemCimtypeString == iCimType) ||
				(wbemCimtypeDatetime == iCimType) ||
				(wbemCimtypeReference == iCimType) ||
				(wbemCimtypeUint64 == iCimType) ||
				(wbemCimtypeSint64 == iCimType))
			{
				if (bIsArray)
				{
					long ix = 0;
					bool bCanBeServingSuggestion = true;
					
					for(ix = lLBound; ix <= lUBound && bCanBeServingSuggestion; ix++) 
					{
						BSTR bsValue = NULL;

						if (SUCCEEDED(SafeArrayGetElement(var.parray,&ix,&bsValue)))
							bCanBeServingSuggestion = CanCoerceString (bsValue, (WbemCimtypeEnum) iCimType);
						else 
							bCanBeServingSuggestion = false;
						
						SysFreeString(bsValue);
					}

					if (bCanBeServingSuggestion)
						cimType = (WbemCimtypeEnum) iCimType;
				}
				else
				{
					if (CanCoerceString (var.bstrVal, (WbemCimtypeEnum) iCimType))
						cimType = (WbemCimtypeEnum) iCimType;
				}
			}
		}
			break;
	}
	
	return cimType;
}

//***************************************************************************
//
//  BOOL ReadI64
//
//  DESCRIPTION:
//
//  Reads a signed 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz     String to read from
//      __int64& i64    Destination for the value
//
//***************************************************************************
bool ReadI64(LPCWSTR wsz, __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;
    __int64 ia64max = ((0x7FFFFFFFFFFFFFFF / 0xA) + 0xA);
    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < ia64max && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return false;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return true;
        }
        
        return false;
    }

    ri64 = i64 * nSign;
    return true;
}

//***************************************************************************
//
//  BOOL ReadUI64
//
//  DESCRIPTION:
//
//  Reads an unsigned 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz              String to read from
//      unsigned __int64& i64    Destination for the value
//
//***************************************************************************
bool ReadUI64(LPCWSTR wsz, unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return false;

        pwc++;
    }

    if(*pwc)
    {
        return false;
    }

    rui64 = ui64;
    return true;
}

HRESULT BuildStringArray (
	SAFEARRAY *pArray, 
	VARIANT & var
)
{
	HRESULT hr = WBEM_E_FAILED;
	SAFEARRAYBOUND rgsabound;
	rgsabound.lLbound = 0;
	long lBound = 0, uBound = -1;

	if (pArray)
	{
		SafeArrayGetUBound (pArray, 1, &uBound);
		SafeArrayGetLBound (pArray, 1, &lBound);
	}

	rgsabound.cElements = uBound + 1 - lBound;
	SAFEARRAY *pNewArray = SafeArrayCreate (VT_VARIANT, 1, &rgsabound);

	if (pNewArray)
	{
		BSTR bstrName = NULL;
		VARIANT nameVar;
		VariantInit (&nameVar);
		bool ok = true;

		/*
		 * If the source array is not empty, copy it over to the
		 * new array. Wrap each member in a Variant, and ensure indexing
		 * begins at 0.
		 */
		if (0 < rgsabound.cElements)
		{
			for (long i = 0; (i <= (rgsabound.cElements - 1)) && ok; i++)
			{
				long j = lBound + i;

				if (SUCCEEDED(SafeArrayGetElement (pArray, &j, &bstrName)))
				{
					BSTR copy = SysAllocString (bstrName);

					if (copy)
					{
						nameVar.vt = VT_BSTR;
						nameVar.bstrVal = copy;
						
						if (FAILED(SafeArrayPutElement (pNewArray, &i, &nameVar)))
						{
							ok = false;
							hr = WBEM_E_OUT_OF_MEMORY;
						}

						SysFreeString (bstrName);
						VariantClear (&nameVar);
					}
					else
					{
						ok = false;
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				else 
					ok = false;
			}
		}

		if (ok)
		{
			// Now plug this array into the VARIANT
			var.vt = VT_ARRAY | VT_VARIANT;
			var.parray = pNewArray;
			hr = S_OK;
		}
		else
		{
			if (pNewArray)
				SafeArrayDestroy (pNewArray);
		}
	}
	else
		hr = WBEM_E_OUT_OF_MEMORY;

	return hr;
}

HRESULT SetFromStringArray (
	SAFEARRAY **ppArray,
	VARIANT *pVar
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pVar) || (VT_EMPTY == V_VT(pVar)) || 
				(VT_NULL == V_VT(pVar)))
	{
		if (*ppArray)
		{
			SafeArrayDestroy (*ppArray);
			*ppArray = NULL;
		}

		hr = WBEM_S_NO_ERROR;
	}
	else if (((VT_ARRAY | VT_VARIANT) == V_VT(pVar)) ||
			 ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pVar)))
    {
        VARIANT vTemp;
		VariantInit (&vTemp);

        if (S_OK == ConvertArray(&vTemp, pVar))
		{
			// Is it a string array?
			if (V_VT(&vTemp) == (VT_ARRAY|VT_BSTR))
			{
				// Super - grab it out of the temporary VARIANT 
				if (*ppArray)
					SafeArrayDestroy (*ppArray);
				
				*ppArray = vTemp.parray;
				vTemp.vt = VT_NULL;
				vTemp.parray = NULL;
				hr = WBEM_S_NO_ERROR;
			}
		}

        VariantClear(&vTemp);
    }
	else 
	{
		// Look for an IDispatch that needs to be mapped to an array
		if ((VT_DISPATCH == V_VT(pVar)) 
			|| ((VT_DISPATCH|VT_BYREF) == V_VT(pVar)))
		{
			VARIANT vTemp;
			VariantInit (&vTemp);

			if (S_OK == ConvertDispatchToArray (&vTemp, pVar, wbemCimtypeString))
			{
				// Is it a string array?
				if (V_VT(&vTemp) == (VT_ARRAY|VT_BSTR))
				{
					// Super - grab it out of the temporary VARIANT 
					if (*ppArray)
						SafeArrayDestroy (*ppArray);
					
					*ppArray = vTemp.parray;
					vTemp.vt = VT_NULL;
					vTemp.parray = NULL;
					hr = WBEM_S_NO_ERROR;
				}
			}

			VariantClear (&vTemp);
		}
	}

	return hr;
}



//***************************************************************************
//
//  bool IsNullOrEmptyVariant
//
//  DESCRIPTION:
//
//  Given a VARIANT, check if it is essentially null/empty or has
//  more than one dimension
//
//  PARAMETERS:
//
//		pVar		variant to check
//
//	RETURNS:
//		true if and only if the conversion was possible
//
//***************************************************************************

bool IsNullOrEmptyVariant (VARIANT & var)
{
	bool result = false;

	if ((VT_EMPTY == var.vt) || (VT_NULL == var.vt))
		result = true;
	else if (VT_ARRAY & var.vt)
	{
		// Check if array that it is not empty or NULL 

		if (!(var.parray))
			result = true;
		else
		{
			long lBound, uBound;

			if ((1 != SafeArrayGetDim (var.parray)) ||
				(
				 SUCCEEDED(SafeArrayGetLBound (var.parray, 1, &lBound)) &&
				 SUCCEEDED(SafeArrayGetUBound (var.parray, 1, &uBound)) &&
				 (0 == (uBound - lBound + 1))
				)
				 )
					result = true;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool RemoveElementFromArray
//
//  DESCRIPTION:
//
//  Given a SAFEARRAY and an index, remove the element at that index
//	and shift left all following elements by one.
//
//  PARAMETERS:
//
//		array		the SAFEARRAY in qeustion
//		vt			Variant type of elements in array
//		iIndex		index of element to remove
//
//	RETURNS:
//		true if and only if the conversion was possible
//
//***************************************************************************

bool RemoveElementFromArray (SAFEARRAY & array, VARTYPE vt, long iIndex)
{
	/*
	 * Note: caller must ensure that the array is within bounds and that the
	 * 
	 */

	bool result = false;
	long lBound, uBound;
	
	if ((1== SafeArrayGetDim (&array)) &&
		SUCCEEDED(SafeArrayGetLBound (&array, 1, &lBound)) &&
		SUCCEEDED(SafeArrayGetUBound (&array, 1, &uBound)) &&
		(0 < (uBound - lBound + 1)) && 
		(iIndex <= uBound))
	{
		bool ok = true;

		for (long i = iIndex+1; ok && (i <= uBound); i++)
			ok = ShiftLeftElement (array, vt, i);
			
		// Finally Redim to get rid of the last element
		if (ok)
		{
			SAFEARRAYBOUND	rgsabound;
			rgsabound.lLbound = lBound;
			rgsabound.cElements = uBound - lBound;
			result = SUCCEEDED(SafeArrayRedim (&array, &rgsabound));
		}
		else
			result = false;
	}

	return result;
}

//***************************************************************************
//
//  bool ShiftLeftElement
//
//  DESCRIPTION:
//
//  Given a SAFEARRAY and an index, remove the element at that index
//	and shift left all following elements by one.
//
//  PARAMETERS:
//
//		array		the SAFEARRAY in question
//		vt			Variant type of elements in array
//		iIndex		index of element to remove
//
//	RETURNS:
//		true if and only if the conversion was possible
//
//***************************************************************************

bool ShiftLeftElement (SAFEARRAY & array, VARTYPE vt, long iIndex)
{
	bool result = false;
	long iNewIndex = iIndex - 1;

	switch (vt)
	{
		case VT_BSTR:
		{
			BSTR bstrVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bstrVal)))
			{
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, bstrVal));
				SysFreeString (bstrVal);
			}
		}
			break;

		case VT_UI1:
		{
			unsigned char bVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &bVal));
		}
			break;

		case VT_I2:
		{
			short iVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &iVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &iVal));
		}
			break;

		case VT_I4:
		{
			long lVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &lVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &lVal));
		}
			break;

		case VT_R4:
		{
			float fltVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &fltVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &fltVal));
		}
			break;

		case VT_R8:
		{
			double dblVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &dblVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &dblVal));
		}
			break;

		case VT_BOOL:
		{
			VARIANT_BOOL boolVal;

			if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &boolVal)))
				result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &boolVal));
		}
			break;
	}

	return result;
}

bool ShiftElementsToRight (SAFEARRAY & array, VARTYPE vt, long iStartIndex,	
							long iEndIndex, long iCount)
{
	bool result = true;

	for (long iIndex = iEndIndex; result && (iIndex >= iStartIndex); iIndex--)
	{
		long iNewIndex = iIndex + iCount;

		switch (vt)
		{
			case VT_BSTR:
			{
				BSTR bstrVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bstrVal)))
				{
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, bstrVal));
					SysFreeString (bstrVal);
				}
			}
				break;

			case VT_UI1:
			{
				unsigned char bVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &bVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &bVal));
			}
				break;

			case VT_I2:
			{
				short iVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &iVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &iVal));
			}
				break;

			case VT_I4:
			{
				long lVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &lVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &lVal));
			}
				break;

			case VT_R4:
			{
				float fltVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &fltVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &fltVal));
			}
				break;

			case VT_R8:
			{
				double dblVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &dblVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &dblVal));
			}
				break;

			case VT_BOOL:
			{
				VARIANT_BOOL boolVal;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &boolVal)))
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, &boolVal));
			}
				break;

			case VT_DISPATCH:
			{
				IDispatch *pdispVal = NULL;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &pdispVal)))
				{
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, pdispVal));

					if (pdispVal)
						pdispVal->Release ();
				}
			}
				break;

			case VT_UNKNOWN:
			{
				IUnknown *punkVal = NULL;

				if (SUCCEEDED(SafeArrayGetElement (&array, &iIndex, &punkVal)))
				{
					result = SUCCEEDED(SafeArrayPutElement (&array, &iNewIndex, punkVal));

					if (punkVal)
						punkVal->Release ();
				}
			}
				break;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool MatchBSTR
//
//  DESCRIPTION:
//
//  Given a VARIANT and a BSTR, find out whether the BSTR matches the
//  VARIANT value (either the complete value or a member thereof).
//
//  PARAMETERS:
//
//		var		the VARIANT in question
//		bstrVal	the BSTR in question
//
//	RETURNS:
//		true if and only if the match was made
//
//***************************************************************************

bool MatchBSTR (VARIANT & var, BSTR & bstrVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_BSTR;
	srcVar.bstrVal = SysAllocString (bstrVal);
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	VariantClear (&srcVar);
	return result;
}

//***************************************************************************
//
//  bool MatchUI1
//
//  DESCRIPTION:
//
//  Given a VARIANT and a UI1, find out whether the UI1 matches the
//  VARIANT value (either the complete value or a member thereof).
//
//  PARAMETERS:
//
//		var		the VARIANT in question
//		bstrVal	the BSTR in question
//
//	RETURNS:
//		true if and only if the match was made
//
//***************************************************************************

bool MatchUI1 (VARIANT & var, unsigned char bVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_UI1;
	srcVar.bVal = bVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchBool (VARIANT & var, VARIANT_BOOL boolVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_BOOL;
	srcVar.boolVal = boolVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchI2 (VARIANT & var, short iVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_I2;
	srcVar.iVal = iVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchI4 (VARIANT & var, long lVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_I4;
	srcVar.lVal = lVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchR4 (VARIANT & var, float fltVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_R4;
	srcVar.fltVal = fltVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

bool MatchR8 (VARIANT & var, double dblVal)
{
	bool result = false;
	
	// Coerce into the underlying type of the variant
	VARIANT srcVar, dstVar;
	srcVar.vt = VT_R8;
	srcVar.dblVal = dblVal;
	VariantInit (&dstVar);

	if (SUCCEEDED (VariantChangeType (&dstVar, &srcVar, 0, var.vt & ~VT_ARRAY)))
	{
		result = MatchValue (var, dstVar); 
		VariantClear (&dstVar);
	}

	return result;
}

//***************************************************************************
//
//  bool MatchValue
//
//  DESCRIPTION:
//
//  Given a VARIANT (which may or may not be an array) and a second VARIANT
//	(which is not an array) determine whether the second value matches the
//	first or an element of the first. 
//
//	ASSUMPTIONS
//	
//		1. The two VARIANTS have the same underlying type
//		2. The second VARIANT cannot be an array
//
//  PARAMETERS:
//
//		var		the VARIANT in question
//		bstrVal	the BSTR in question
//
//	RETURNS:
//		true if and only if the match was made
//
//***************************************************************************

bool MatchValue (VARIANT &var1, VARIANT &var2)
{
	bool result = false;
	bool bIsArray = (var1.vt & VT_ARRAY) ? true : false;

	if (bIsArray)
	{
		long lBound, uBound;

		if (var1.parray && (1== SafeArrayGetDim (var1.parray)) &&
			SUCCEEDED(SafeArrayGetLBound (var1.parray, 1, &lBound)) &&
			SUCCEEDED(SafeArrayGetUBound (var1.parray, 1, &uBound)) &&
			(0 < (uBound - lBound + 1)))
		{
			// Break out on first match
			for (long i = lBound; !result && (i <= uBound); i++)
			{
				switch (var1.vt & ~VT_ARRAY)
				{
					case VT_BSTR:
					{
						BSTR bstrVal = NULL;

						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &bstrVal)))
						{
							result = (0 == wcscmp (bstrVal, var2.bstrVal));
							SysFreeString (bstrVal);
						}
					}
						break;

					case VT_UI1:
					{
						unsigned char bVal;

						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &bVal)))
							result = (bVal == var2.bVal);
					}
						break;

					case VT_I2:
					{
						short iVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &iVal)))
							result = (iVal == var2.iVal);
					}
						break;

					case VT_I4:
					{
						long lVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &lVal)))
							result = (lVal == var2.lVal);
					}
						break;

					case VT_R4:
					{
						float fltVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &fltVal)))
							result = (fltVal == var2.fltVal);
					}
						break;

					case VT_R8:
					{
						double dblVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &dblVal)))
							result = (dblVal == var2.dblVal);
					}
						break;

					case VT_BOOL:
					{
						VARIANT_BOOL boolVal;
						
						if (SUCCEEDED(SafeArrayGetElement (var1.parray, &i, &boolVal)))
							result = (boolVal == var2.boolVal);
					}
						break;
				}
			}
		}		
	}
	else
	{
		switch (var1.vt)
		{
			case VT_BSTR:
				result = (0 == wcscmp (var1.bstrVal, var2.bstrVal));
				break;

			case VT_UI1:
				result = (var1.bVal == var2.bVal);
				break;

			case VT_I2:
				result = (var1.iVal == var2.iVal);
				break;

			case VT_I4:
				result = (var1.lVal == var2.lVal);
				break;

			case VT_R4:
				result = (var1.fltVal == var2.fltVal);
				break;

			case VT_R8:
				result = (var1.dblVal == var2.dblVal);
				break;

			case VT_BOOL:
				result = (var1.boolVal == var2.boolVal);
				break;
		}
	
	}

	return result;
}


//***************************************************************************
//
//  HRESULT WmiVariantChangeType
//
//  DESCRIPTION:
//
//  Given a VARIANT value and a desired CIM type, cast the value to a VARIANT
//	which will be accepted when supplied to CIMOM for a property of that type. 
//
//  PARAMETERS:
//
//		vOut		the cast value
//		pvIn		the value to be cast
//		lCimType	the required CIM type
//
//	RETURNS:
//		S_OK if succeeded, WBEM_E_TYPE_MISMATCH if not
//
//***************************************************************************

// NTBUG#21788:  IA64 workaround until compiler version 2210 or greater drop.
HRESULT WmiVariantChangeType (
		VARIANT & vOut,
		VARIANT *pvIn,
		CIMTYPE	lCimType
)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;
	VariantInit (&vOut);
	
	// First we check for a NULL value, as these are easy
	if ((NULL == pvIn) || VT_EMPTY == V_VT(pvIn) || VT_NULL == V_VT(pvIn) ||
			((VT_ERROR == V_VT(pvIn)) && (DISP_E_PARAMNOTFOUND == pvIn->scode)))
	{
	    ZeroMemory( &vOut, sizeof( VARIANT ) );
		vOut.vt = VT_NULL;
		hr = S_OK;
	}
	else
	{
		// The kind of variant we will need to construct
		VARTYPE vtOut = CimTypeToVtType (lCimType);
		
		// The VARTYPE we've been given
		VARTYPE vtIn = V_VT(pvIn);


		if (vtOut == vtIn)
		{
			// Life is easy
			hr = VariantCopy (&vOut, pvIn);
		}
		else
		{
			// Types do not match - we have some work to to
			if (CIM_FLAG_ARRAY & lCimType)
			{
				/*
				 * Check for a regular SAFEARRAY type value first; if that fails
				 * then look for an IDispatch-style array value.
				 */
				if (((VT_ARRAY | VT_VARIANT) == vtIn) ||
					((VT_ARRAY | VT_VARIANT | VT_BYREF) == vtIn))
				{
					SAFEARRAY *parray = (VT_BYREF & vtIn) ? *(pvIn->pparray) : pvIn->parray;

					hr = WmiConvertSafeArray (vOut, parray, lCimType & ~VT_ARRAY);
				}
				else if ((VT_DISPATCH == vtIn) || ((VT_DISPATCH|VT_BYREF) == vtIn))
				{
					CComPtr<IDispatch> pIDispatch = 
							(VT_BYREF & vtIn) ? *(pvIn->ppdispVal) : pvIn->pdispVal;
    
					hr = WmiConvertDispatchArray (vOut, pIDispatch, lCimType & ~VT_ARRAY);
				}
				else if (((VT_ARRAY | VT_DISPATCH) == vtIn) ||
						((VT_ARRAY | VT_DISPATCH | VT_BYREF) == vtIn))
				{
					if (SUCCEEDED(hr = VariantCopy (&vOut, pvIn)))
						hr = MapToCIMOMObject (&vOut);
				}
			}
			else
			{
				switch (lCimType)
				{
					case wbemCimtypeSint8:
						{
							/*
							 * These are represented by
							 * a VT_I2, but we need to be careful about sign
							 * extension from shorter types taking us "out of range".
							 */
							if (SUCCEEDED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
							{
								// Did we get sign extended?
								if ((VT_UI1 == vtIn) || (VT_BOOL == vtIn))
									vOut.lVal &= 0x000000FF;
							}
							else 
							{
								// If we can't change the type, try the one we're given
								hr = VariantCopy (&vOut, pvIn);
							}
						}
						break;

					case wbemCimtypeSint64:
					case wbemCimtypeUint64:
						{
							/*
							 * These types are realized as VT_BSTR in CIM terms, which means
							 * that VariantChangeType will almost always succeed but not
							 * leave us with a valid numeric value. To be consistent with other
							 * numeric types we should round up floating/double
							 * values to the next largest integer (as is done by VariantChangeType
							 * for VT_R8 to numeric conversion).
							 */

							if (VT_R8 == V_VT(pvIn))
							{
//								if (SUCCEEDED(hr = VariantCopy (&vOut, pvIn)))
								{
									vOut.vt = pvIn->vt;
									// Round it up
									vOut.dblVal = (pvIn->dblVal + 0.5) > ceil(pvIn->dblVal) ? 
														ceil(pvIn->dblVal) : 
														ceil(pvIn->dblVal - 0.5);
									
									// Convert to string
									int dec = 0;
									int sign = 0;
									char *pDbl = _fcvt (vOut.dblVal, 0, &dec, &sign);
									
									if (pDbl) 
									{
										size_t len = strlen (pDbl);

										/*
										 * Having rounded up to an integer, we really expect 
										 * there to be no fractional component to the number
										 * returned by _fcvt.
										 */
										if (dec == len)
										{
											/*
											 * Now convert to a wide string - remember the
											 * sign bit!
											 */
											if (0 != sign)
												len += 1;

											wchar_t *pValue = new wchar_t [len + 1];

											if (pValue)
											{
												if (0 != sign)
												{
													pValue [0] = L'-';
													mbstowcs (pValue+1, pDbl, len);
												}
												else
													mbstowcs (pValue, pDbl, len);

												pValue [len] = NULL;

												// Now set it in the variant
												vOut.bstrVal = SysAllocString (pValue);
												vOut.vt = VT_BSTR;

												delete [] pValue;
												hr = S_OK;
											}
										}
									}
								}
							}
							else
								hr = VariantChangeType (&vOut, pvIn, 0, vtOut);
							
							if (FAILED(hr))
							{
								// If we can't change the type, try the one we're given
								hr = VariantCopy (&vOut, pvIn);
							}
						}
						break;

					case wbemCimtypeUint8:
					case wbemCimtypeSint16:
					case wbemCimtypeSint32:
					case wbemCimtypeReal32:
					case wbemCimtypeReal64:
					case wbemCimtypeString:
					case wbemCimtypeDatetime:
					case wbemCimtypeBoolean:
					case wbemCimtypeReference:
						{
							/*
							 * These types have a "prefect" fit to their
							 * corresponding Variant type.
							 */
							if (FAILED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
									hr = VariantCopy (&vOut, pvIn);
						}
						break;
					
					
					case wbemCimtypeUint32:
						{
							if (FAILED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
							{
								/*
								 * Watch for the case where we have been given a VT_R8
								 * in lieu of a "large" unsigned 32-bit integer value.
								 */
								if (VT_R8 == V_VT(pvIn))
								{
									// Is this "really" an integer?
									if (floor (pvIn->dblVal) == ceil(pvIn->dblVal))
									{
										// Fool it by casting to a UI4 - all we need is the bit pattern
										if (SUCCEEDED(hr = VarUI4FromR8 (pvIn->dblVal, (ULONG*)&vOut.lVal)))
											vOut.vt = VT_I4;
									}
								}
							}

							// If no joy thus far, just copy and have done with it
							if (FAILED(hr))
								hr = VariantCopy (&vOut, pvIn);
						}
						break;
					
					case wbemCimtypeChar16:
					case wbemCimtypeUint16:
						{
							/*
							 * These types are represented by
							 * a VT_I4, but we need to be careful about sign
							 * extension taking us "out of range".
							 */
							if (SUCCEEDED(hr = VariantChangeType (&vOut, pvIn, 0, vtOut)))
							{
								// Did we get sign extended from a shorter type?
								if ((VT_I2 == vtIn) || (VT_UI1 == vtIn) || (VT_BOOL == vtIn))
									vOut.lVal &= 0x0000FFFF;
							}
							else
								hr = VariantCopy (&vOut, pvIn);
						}
						break;
						
					case wbemCimtypeObject:
						{
							/* 
							 * We're looking for an embedded object
							 */
							if (SUCCEEDED(hr = VariantCopy (&vOut, pvIn)))
								hr = MapToCIMOMObject (&vOut);
						}
						break;
				}
			}
		}
	}

	return hr;
}


//***************************************************************************
//
//  HRESULT WmiConvertSafeArray
//
//  Description: 
//
//  This function is applied to VARIANT arrays in order to check for certain
//  restrictions imposed by CIMOM (e.g. they must be homogeneous) or perform
//  conversions (certain VARIANT types have to be mapped to acceptable CIMOM
//	types).
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

HRESULT WmiConvertSafeArray(VARIANT &vOut, SAFEARRAY *parray, CIMTYPE lCimType)
{
	HRESULT hr = WBEM_E_FAILED;
	VARTYPE vtPut;		// The underlying type of the target array
	long lLower, lUpper;
  
	if (parray)
	{
		if (GetSafeArrayDimensions (*parray, lLower, lUpper))
		{
			int iNumElements = lUpper - lLower +1; 

			/* 
			 * For empty arrays, it suffices to create a empty array of
			 * VT_VARIANT's. Otherwise we need to build what WMI is expecting.
			 */
			vtPut = (iNumElements == 0) ? VT_VARIANT : CimTypeToVtType (lCimType);	
			
			// Now create a destination array of the required size
			SAFEARRAYBOUND rgsabound[1]; 
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = iNumElements;
			SAFEARRAY * pDestArray = SafeArrayCreate(vtPut, 1, rgsabound);

			if (pDestArray)
			{
				bool ok = true;

				for(long i = lLower; (i <= lUpper) && ok; i++) 
				{
					VARIANT var;
					VariantInit(&var);
                   
					if (SUCCEEDED(SafeArrayGetElement (parray, &i, &var)))
					{
						// do the conversion to the acceptable type and put that
						VARIANT vWMI;
						VariantInit(&vWMI);

						if (SUCCEEDED(hr = WmiVariantChangeType (vWMI, &var, lCimType)))
						{
							if(V_VT(&vWMI) == VT_BSTR || V_VT(&vWMI) == VT_UNKNOWN || V_VT(&vWMI) == VT_DISPATCH)
								ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)vWMI.bstrVal));
							else
								ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)&vWMI.lVal));
						}
						
						VariantClear (&vWMI);
					}
					else
						ok = false;

					VariantClear(&var);
				}

				if (!ok)
				{
					SafeArrayDestroy (pDestArray);
				}
				else
				{
					vOut.vt = (VT_ARRAY | vtPut);
					vOut.parray = pDestArray;
					hr = S_OK;
				}
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

    return hr;
}

//***************************************************************************
//
//  HRESULT WmiConvertDispatchArray
//
//  DESCRIPTION:
//
//  Attempt to convert from an IDispatch value to a CIM array value (property
//	qualifier or context).
//
//  PARAMETERS:
//
//		pDest		Output value
//		pSrc		Input value
//		lCimType	CIM Property type (underlying the array) - defaults to
//					CIM_ILLEGAL for Qualifier & Context value mappings.
//		bIsQual		true iff we are mapping for a qualifier
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT WmiConvertDispatchArray (
	VARIANT &vOut,
	CComPtr<IDispatch> & pIDispatch,
	CIMTYPE lCimType
)
{
	HRESULT hr = WBEM_E_FAILED; // Default error

	if (pIDispatch)
	{
		/*
		 * Looking for an IDispatchEx to iterate through the properties
		 * of the array.
		 */
		CComQIPtr<IDispatchEx> pIDispatchEx (pIDispatch);

		if (pIDispatchEx)
		{
			/*
			 * Looks promising, but just check if this isn't one of our objects
			 */
			CComQIPtr<ISWbemObject> pISWbemObject (pIDispatch);

			if (!pISWbemObject)
			{
				/*
				 * Start by determining how many properties there are so we can create
				 * a suitable array.
				 */
				long iNumElements = 0;
				DISPID dispId = DISPID_STARTENUM;
				
				while (S_OK == pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId))
				{
					//We need to check this is a "real" array entry with an index rather than some "dummy" entry
				    //for some non-array properties (which can happen with JScript arrays)
				    BSTR memberName = NULL;
				    wchar_t *stopString=NULL;
				    if (SUCCEEDED(pIDispatchEx->GetMemberName (dispId, &memberName)))
				    {
					    // Check that property name is numeric, only if it is we count it for the array size
					    long index = wcstol (memberName, &stopString, 10);
					    if ((0 == wcslen (stopString)))
							iNumElements++;
					}
				}

				
				/* 
				 * For empty arrays, it suffices to create a empty array of
				 * VT_VARIANT's. Otherwise we need to build what WMI is expecting.
				 */
				VARTYPE vtPut = (iNumElements == 0) ? VT_VARIANT : CimTypeToVtType (lCimType);	

				// Create the safearray - note that it may be empty
				SAFEARRAYBOUND rgsaBound;
				rgsaBound.cElements = iNumElements;
				rgsaBound.lLbound = 0;

				SAFEARRAY *pDestArray = SafeArrayCreate (vtPut, 1, &rgsaBound);
					
				if (pDestArray)
				{
					bool ok = true;

					if (0 < iNumElements)
					{
						// Enumerate the DISPIDs on this interface
						dispId = DISPID_STARTENUM;
						DISPPARAMS dispParams;
						dispParams.rgvarg = NULL;
						dispParams.rgdispidNamedArgs = NULL;
						dispParams.cArgs = 0;
						dispParams.cNamedArgs = 0;

						long nextExpectedIndex = 0;
						HRESULT enumHr;
						wchar_t *stopString = NULL;

						/*
						 * For JScript arrays, the property names are the specified indices of the 
						 * the array; these can be integer indices or they can be strings.  We make
						 * the following requirements of the array indices:
						 *
						 * (1) All of the indices are non-negative integers
						 * (2) The indices start at 0 and are contiguous.
						 */

						while (ok && SUCCEEDED(enumHr = pIDispatchEx->GetNextDispID (fdexEnumAll, dispId, &dispId)))
						{
							if (S_FALSE == enumHr)
							{
								// We have reached the end
								break;
							}

							CComBSTR memberName;

							if (SUCCEEDED(pIDispatchEx->GetMemberName (dispId, &memberName)))
							{
								// Check that property name is numeric
								long i = wcstol (memberName, &stopString, 10);

								if ((0 != wcslen (stopString)))
								{
									// Failure - cannot convert to integer
									// Since JScript arrays may have additional "members" that are not real array members,
									// depending on different properties that may be accessed on them, we should just
									// ignore non-numeric items - instead of failing the whole thing...
									continue;
								}
								else if (i != nextExpectedIndex)
								{
									// Failure - non-contiguous array
									ok = false;
								}
								else
								{
									nextExpectedIndex++;

									// Extract the property
									VARIANT var;
									VariantInit (&var);
										
									if (SUCCEEDED (pIDispatchEx->InvokeEx (dispId, 0, 
												DISPATCH_PROPERTYGET, &dispParams, &var, NULL, NULL)))
									{
										// do the conversion to the acceptable type and put that
										VARIANT vWMI;
										VariantInit(&vWMI);

										if (SUCCEEDED(hr = WmiVariantChangeType (vWMI, &var, lCimType)))
										{
											if(V_VT(&vWMI) == VT_BSTR || V_VT(&vWMI) == VT_UNKNOWN || V_VT(&vWMI) == VT_DISPATCH)
												ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)vWMI.bstrVal));
											else
												ok = (S_OK == SafeArrayPutElement(pDestArray, &i, (void *)&vWMI.lVal));
										}
										
										VariantClear (&vWMI);
									}
									else
										ok = false;
								}
							}
							else
							{
								// Failure - couldn't invoke method
								ok = false;
							} 
						} 
					}	

					if (ok)
					{
						// Now construct the new property value using our array
						vOut.vt = VT_ARRAY | vtPut;
						vOut.parray = pDestArray;
						hr = S_OK;
					}
					else
						SafeArrayDestroy (pDestArray);
				}
				else
					hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
	}

	return hr;
}

bool GetSafeArrayDimensions (SAFEARRAY &sArray, long &lLower, long &lUpper)
{
	bool result = false;

	// Must be 1-dimensional
	if (1 == SafeArrayGetDim(&sArray))
	{
		if (SUCCEEDED(SafeArrayGetLBound(&sArray,1,&lLower)) &&
			SUCCEEDED(SafeArrayGetUBound(&sArray,1,&lUpper)))
			result = true;
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\precomp.h ===
//***************************************************************************
//
//  (c) 1998 by Microsoft Corporation
//
//  precomp.h
//
//  alanbos  04-Mar-98   Created.
//
//  Master include file.
//
//***************************************************************************

#pragma warning(disable:4786)
#include <stdio.h>
#include <tchar.h>
#include <ctype.h>
#include <objbase.h>
#include <objsafe.h>
#include <ocidl.h>
#include <memory.h>
#include <activscp.h>
#include "classfac.h"
#include "wmihost.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\classfac.h ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  classfac.h
//
//  alanbos  23-Mar-99   Created.
//
//  Class factory for WMI Scripting Host
//
//***************************************************************************

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiScriptingHostFactory
//
//  DESCRIPTION:
//
//  Class factory for the CWmiScriptingHost classes.
//
//***************************************************************************

class CWmiScriptingHostFactory : public IClassFactory
{
protected:
	long			m_cRef;

public:

    CWmiScriptingHostFactory(void);
    ~CWmiScriptingHostFactory(void);
    
	//IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\classfac.cpp ===
//***************************************************************************
//
//  (c) 1998 by Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  alanbos  23-Feb-99   Created.
//
//  Contains the class factory.
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CWmiScriptingHostFactory::CWmiScriptingHostFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWmiScriptingHostFactory::CWmiScriptingHostFactory(void)
{
    m_cRef=0L;
	return;
}

//***************************************************************************
//
// CWmiScriptingHostFactory::~CWmiScriptingHostFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWmiScriptingHostFactory::~CWmiScriptingHostFactory(void)
{
	return;
}

//***************************************************************************
//
// CWmiScriptingHostFactory::QueryInterface
// CWmiScriptingHostFactory::AddRef
// CWmiScriptingHostFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CWmiScriptingHostFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiScriptingHostFactory::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWmiScriptingHostFactory::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHostFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a WMI Scripting Host.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CWmiScriptingHostFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj = NULL;
    HRESULT      hr = E_FAIL;

	*ppvObj=NULL;
    
    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pObj = new CWmiScriptingHost;
	
	if (NULL == pObj)
        return E_OUTOFMEMORY;

    if (FAILED (hr = pObj->QueryInterface(riid, ppvObj)))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHostFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CWmiScriptingHostFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\maindll.cpp ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  23-Mar-99   Created.
//
//  Contains DLL entry points.  
//
//***************************************************************************

#include "precomp.h"
#include "initguid.h"

// Standard registry key/value names
#define WBEMS_RK_SCC		"SOFTWARE\\CLASSES\\CLSID\\"
#define WBEMS_RK_SC			"SOFTWARE\\CLASSES\\"
#define WBEMS_RK_THRDMODEL	"ThreadingModel"
#define WBEMS_RV_APARTMENT	"Apartment"
#define	WBEMS_RK_INPROC32	"InProcServer32"
#define WBEMS_RK_CLSID		"CLSID"

#define GUIDSIZE	128

// Count number of objects and number of locks.
long g_cObj = 0 ;
ULONG g_cLock = 0 ;
HMODULE ghModule = NULL;

// CLSID for our implementation of IActiveScriptingSite
// {838E2F5E-E20E-11d2-B355-00105A1F473A}
DEFINE_GUID(CLSID_WmiActiveScriptingSite, 
0x838e2f5e, 0xe20e, 0x11d2, 0xb3, 0x55, 0x0, 0x10, 0x5a, 0x1f, 0x47, 0x3a);

// forward defines
STDAPI RegisterCoClass (REFGUID clsid, LPCTSTR desc);
void UnregisterCoClass (REFGUID clsid);

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
		{
		}
			return TRUE;

		case DLL_THREAD_DETACH:
		{
		}
			return TRUE;

		case DLL_PROCESS_ATTACH:
		{
			if(ghModule == NULL)
				ghModule = hInstance;
		}
	        return TRUE;

		case DLL_THREAD_ATTACH:
        {
        }
			return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;
	CWmiScriptingHostFactory *pObj = NULL;

	if (CLSID_WmiActiveScriptingSite == rclsid)
        pObj=new CWmiScriptingHostFactory();

    if(NULL == pObj)
        return E_FAIL;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	return (0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//	STDAPI RegisterCoClass	
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry setup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

STDAPI RegisterCoClass (REFGUID clsid, LPCTSTR desc)
{
	OLECHAR		wcID[GUIDSIZE];
	char		nwcID[GUIDSIZE];
    char		szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

	char *szCLSID = new char [strlen (WBEMS_RK_SCC) + GUIDSIZE + 1];

    // Create the path.
    if(0 ==StringFromGUID2(clsid, wcID, GUIDSIZE))
		return ERROR;

	wcstombs(nwcID, wcID, GUIDSIZE);
    lstrcpy (szCLSID, WBEMS_RK_SCC);
	lstrcat (szCLSID, nwcID);
	
	if(0 == GetModuleFileName(ghModule, szModule,  MAX_PATH))
	{
		delete [] szCLSID;
		return ERROR;
	}

    // Create entries under CLSID

    if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1))
	{
		// Description (on main key)
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)desc, (strlen(desc)+1));

		// Register as inproc server
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WBEMS_RK_INPROC32 ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
										(strlen(szModule)+1));
			RegSetValueEx(hKey2, WBEMS_RK_THRDMODEL, 0, REG_SZ, (BYTE *)WBEMS_RV_APARTMENT, 
                                        (strlen(WBEMS_RV_APARTMENT)+1));
			RegCloseKey(hKey2);
		}

		RegCloseKey(hKey1);
	}
	else
	{
		delete [] szCLSID;
		return ERROR;
	}

	delete [] szCLSID;

	return NOERROR;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
	return RegisterCoClass(CLSID_WmiActiveScriptingSite, "WMI Active Scripting Host");
}

//***************************************************************************
//
//	STDAPI UnregisterCoClass	
//
//  DESCRIPTION:
//
//	Helpers for the tiresome business of registry cleanup
//
//  RETURN VALUE:
//
//  ERROR		alas
//  NOERROR     rejoice
//  
//***************************************************************************

void UnregisterCoClass (REFGUID clsid)
{
	OLECHAR		wcID[GUIDSIZE];
    char		nwcID[GUIDSIZE];
    HKEY		hKey = NULL;

	char		*szCLSID = new char [strlen (WBEMS_RK_SCC) + GUIDSIZE + 1];

    // Create the path using the CLSID

    if(0 != StringFromGUID2(clsid, wcID, GUIDSIZE))
	{
		wcstombs(nwcID, wcID, GUIDSIZE);
	    lstrcpy (szCLSID, WBEMS_RK_SCC);
		lstrcat (szCLSID, nwcID);
	
		// First delete the subkeys of the HKLM\Software\Classes\CLSID\{GUID} entry
		if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey))
		{
			RegDeleteKey(hKey, WBEMS_RK_INPROC32);
			RegCloseKey(hKey);
		}

		// Delete the HKLM\Software\Classes\CLSID\{GUID} key
		if(NO_ERROR == RegOpenKey(HKEY_LOCAL_MACHINE, WBEMS_RK_SCC, &hKey))
		{
			RegDeleteKey(hKey, nwcID);
			RegCloseKey(hKey);
		}
	}

	delete [] szCLSID;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	UnregisterCoClass(CLSID_WmiActiveScriptingSite);
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\wmihost.cpp ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  23-Mar-99   Created.
//
//  Contains DLL entry points.  
//
//***************************************************************************

#include "precomp.h"
#include <wbemdisp.h>

#define WMITHIS	L"instance"

//***************************************************************************
//
// CWmiScriptingHost::CWmiScriptingHost
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWmiScriptingHost::CWmiScriptingHost()
{
    m_lRef = 0;
	m_pObject = NULL;

#ifdef TEST
	// Grab an object to play with

	HRESULT hr = CoGetObject (L"winmgmts:{impersonationLevel=impersonate}!Win32_LogicalDisk=\"C:\"",
				NULL,IID_ISWbemObject, (void**)&m_pObject);
#endif
}

//***************************************************************************
//
// CWmiScriptingHost::~CWmiScriptingHost
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWmiScriptingHost::~CWmiScriptingHost()
{
	if (m_pObject)
	{
		m_pObject->Release();
		m_pObject = NULL;
	}
}

//***************************************************************************
//
// CWmiScriptingHost::QueryInterface
// CWmiScriptingHost::AddRef
// CWmiScriptingHost::Release
//
// Purpose: IUnknown method implementations
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IActiveScriptSite)
        *ppv = (IActiveScriptSite*)this;
    else if(riid == IID_IActiveScriptSiteWindow)
        *ppv = (IActiveScriptSiteWindow*)this;
    else
        return E_NOINTERFACE;
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CWmiScriptingHost::AddRef() 
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CWmiScriptingHost::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}
        
//***************************************************************************
//
//  SCODE CWmiScriptingHost::GetLCID
//
//  Description: 
//
//		Retrieves the locale identifier associated with the host's user 
//		interface. The scripting engine uses the identifier to ensure 
//		that error strings and other user-interface elements generated 
//		by the engine appear in the appropriate language. .
//
//  Parameters:
//
//  plcid       
//			Address of a variable that receives the locale identifier 
//			for user-interface elements displayed by the scripting engine
//
// Return Value:
//  HRESULT         E_NOTIMPL - the system-defined locale should be used
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid)
{ 
    return E_NOTIMPL;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::GetItemInfo
//
//  Description: 
//
//		Allows the scripting engine to obtain information about an item 
//		added with the IActiveScript::AddNamedItem method. 
//
//  Parameters:
//
//  pstrName 
//			The name associated with the item, as specified in the 
//			IActiveScript::AddNamedItem method. 
//
//	dwReturnMask 
//			A bit mask specifying what information about the item 
//			should be returned. The scripting engine should request the 
//			minimum amount of information possible because some of 
//			the return parameters (for example,ITypeInfo) can take 
//			considerable time to load or generate. Can be a combination 
//			of the following values: 
//				SCRIPTINFO_IUNKNOWN  Return theIUnknown interface for this item.  
//				SCRIPTINFO_ITYPEINFO  Return theITypeInfo interface for this item.  
//
//	ppunkItem 
//			Address of a variable that receives a pointer to the IUnknown 
//			interface associated with the given item. The scripting engine 
//			can use the IUnknown::QueryInterface method to obtain the IDispatch 
//			interface for the item. This parameter receives NULL if dwReturnMask 
//			does not include the SCRIPTINFO_IUNKNOWN value. Also, it receives NULL 
//			if there is no object associated with the item name; this mechanism is 
//			used to create a simple class when the named item was added with the 
//			SCRIPTITEM_CODEONLY flag set in the IActiveScript::AddNamedItem method. 
//
//	ppTypeInfo 
//			Address of a variable that receives a pointer to theITypeInfo interface 
//			associated with the item. This parameter receives NULL if dwReturnMask 
//			does not include the SCRIPTINFO_ITYPEINFO value, or if type information 
//			is not available for this item. If type information is not available, 
//			the object cannot source events, and name binding must be realized with 
//			the IDispatch::GetIDsOfNames method. Note that the ITypeInfo interface 
//			retrieved describes the item's coclass (TKIND_COCLASS) because the object 
//			may support multiple interfaces and event interfaces. If the item supports 
//			the IProvideMultipleTypeInfo interface, the ITypeInfo interface retrieved 
//			is the same as the index zero ITypeInfo that would be obtained using the 
//			IProvideMultipleTypeInfo::GetInfoOfIndex method. 
//
// Return Value:
//		S_OK					Success.  
//		E_INVALIDARG			An argument was invalid.  
//		E_POINTER				An invalid pointer was specified.  
//		TYPE_E_ELEMENTNOTFOUND  An item of the specified name was not found.  
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTypeInfo)
{ 
	if (NULL == m_pObject)
		return TYPE_E_ELEMENTNOTFOUND;

    if(_wcsicmp(pstrName, WMITHIS))
        return TYPE_E_ELEMENTNOTFOUND;

    if(ppTypeInfo)
        *ppTypeInfo = NULL;
	
    if(ppunkItem)
        *ppunkItem = NULL;
	else
		return E_POINTER;

    if(dwReturnMask & SCRIPTINFO_IUNKNOWN)
        m_pObject->QueryInterface(IID_IUnknown, (void**)ppunkItem);
    
	// TODO - host should support SCRIPTINFO_ITYPEINFO
	// but we'll need scriptable objects to support IProvideClassInfo
	// or just hard code the typelib here

    return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::GetDocVersionString
//
//  Description: 
//
//		Retrieves a host-defined string that uniquely identifies the 
//		current document version. If the related document has changed 
//		outside the scope of ActiveX Scripting (as in the case of an 
//		HTML page being edited with NotePad), the scripting engine can 
//		save this along with its persisted state, forcing a recompile 
//		the next time the script is loaded. 
//
//  Parameters:
//
//  pstrVersionString 
//			Address of the host-defined document version string.  
//
// Return Value:
//		S_OK		Success
//		E_NOTIMPL	The scripting engine should assume that 
//					the script is in sync with the document
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion)
{ 
	return E_NOTIMPL;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnScriptTerminate
//
//  Description: 
//
//		Informs the host that the script has completed execution. The 
//		scripting engine calls this method before the call to the 
//		IActiveScriptSite::OnStateChange method, with the 
//		SCRIPTSTATE_INITIALIZED flag set, is completed. This method can 
//		be used to return completion status and results to the host. Note 
//		that many script languages, which are based on sinking events from 
//		the host, have life spans that are defined by the host. 
//		In this case, this method may never be called. 
//
//  Parameters:
//
//  pvarResult 
//			Address of a variable that contains the script result, 
//			or NULL if the script produced no result. 
//
//	pexcepinfo 
//			Address of an EXCEPINFO structure that contains exception 
//			information generated when the script terminated, or NULL 
//			if no exception was generated. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo)
{ 
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnStateChange
//
//  Description: 
//
//		Informs the host that the scripting engine has changed states. 
//
//  Parameters:
//
//  ssScriptState 
//		Value that indicates the new script state. See the 
//		IActiveScript::GetScriptState method for a description of the states. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState)
{ 
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnScriptError
//
//  Description: 
//
//		Informs the host that an execution error occurred while the engine 
//		was running the script. 
//
//  Parameters:
//
//  pase 
//		Address of the error object's IActiveScriptError interface. 
//		A host can use this interface to obtain information about the 
//		execution error.  
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pase)
{ 
    HRESULT hres;
    EXCEPINFO ei;
    hres = pase->GetExceptionInfo(&ei);
    if(SUCCEEDED(hres))
    {

        printf("\nGot Error from source %S", ei.bstrSource);
        printf("\nDescription is %S", ei.bstrDescription);
        printf("\nThe error code is 0x%x", ei.scode);
        DWORD dwLine, dwCookie;
        long lChar;
        pase->GetSourcePosition(&dwCookie, &dwLine, &lChar);
        printf("\nError occured on line %d, character %d", dwLine, lChar);
    }
    return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnEnterScript
//
//  Description: 
//
//		Informs the host that the scripting engine has begun executing the 
//		script code. The scripting engine must call this method on every 
//		entry or reentry into the scripting engine. For example, if the 
//		script calls an object that then fires an event handled by the 
//		scripting engine, the scripting engine must call 
//		IActiveScriptSite::OnEnterScript before executing the event, and 
//		must call the IActiveScriptSite::OnLeaveScript method after executing 
//		the event but before returning to the object that fired the event. 
//		Calls to this method can be nested. Every call to this method 
//		requires a corresponding call to IActiveScriptSite::OnLeaveScript. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnEnterScript( void)
{ 
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWmiScriptingHost::OnLeaveScript
//
//  Description: 
//
//		Informs the host that the scripting engine has returned from 
//		executing script code. The scripting engine must call this method 
//		before returning control to a calling application that entered the 
//		scripting engine. For example, if the script calls an object that 
//		then fires an event handled by the scripting engine, the scripting 
//		engine must call the IActiveScriptSite::OnEnterScript method before 
//		executing the event, and must call IActiveScriptSite::OnLeaveScript 
//		after executing the event before returning to the object that fired 
//		the event. Calls to this method can be nested. Every call to 
//		IActiveScriptSite::OnEnterScript requires a corresponding call to 
//		this method. 
//
// Return Value:
//		S_OK		Success
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiScriptingHost::OnLeaveScript( void)
{ 
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\wmihost.h ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  wmihost.h
//
//  alanbos  23-Mar-99   Created.
//
//  Defines the WMI Active Scripting Host class.
//
//***************************************************************************

#ifndef _WMIHOST_H_
#define _WMIHOST_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiScriptingHost
//
//  DESCRIPTION:
//
//  The WMI implementation of an Active Scripting Host
//
//***************************************************************************

class CWmiScriptingHost : public IActiveScriptSite
{
protected:
    long m_lRef;
    IDispatch* m_pObject;

public:
    CWmiScriptingHost (); 
    ~CWmiScriptingHost ();

	// IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    
	// IActiveScriptSite methods
    virtual HRESULT STDMETHODCALLTYPE GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid);

    virtual HRESULT STDMETHODCALLTYPE GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);

    virtual HRESULT STDMETHODCALLTYPE GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion);

    virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);

    virtual HRESULT STDMETHODCALLTYPE OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState);

    virtual HRESULT STDMETHODCALLTYPE OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);

    virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void);

    virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\hosttest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	hosttest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\hosttest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9D359E76_E20C_11D2_B355_00105A1F473A__INCLUDED_)
#define AFX_STDAFX_H__9D359E76_E20C_11D2_B355_00105A1F473A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9D359E76_E20C_11D2_B355_00105A1F473A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\test\userprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WBEM method provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IWbemProviderInit *   pInit;
    HRESULT hr;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the Initialize object.
    
    pInit=new CMethodPro();

    if (NULL==pInit)
        return E_OUTOFMEMORY;

    hr=pInit->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pInit;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\test\userprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WBEM Method provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "methprov.h"

HMODULE ghModule;

DEFINE_GUID(CLSID_useridprovider,0x44BB1D18, 0x0FD7, 0x11d3, 0xB3, 0x66, 0x0, 0x10, 0x5a, 0x1f, 0x47, 0x3a);

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
			return TRUE;

		case DLL_THREAD_DETACH:
			return TRUE;

		case DLL_PROCESS_ATTACH:
		{
			if(ghModule == NULL)
				ghModule = hInstance;
		}
	        return TRUE;

		case DLL_THREAD_ATTACH:
        {
        }
			return TRUE;
    }

    return TRUE;
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_useridprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WBEM Method Provider Test";
    char * pModel;
    HKEY hKey1, hKey2;

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    StringFromGUID2(CLSID_useridprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_useridprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\demos\wmihost\hosttest\hosttest.cpp ===
// hosttest.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "objbase.h"
#include "initguid.h"
#include <stdio.h>
#include <activscp.h>


// CLSID for our implementation of IActiveScriptingSite
// {838E2F5E-E20E-11d2-B355-00105A1F473A}
DEFINE_GUID(CLSID_WmiActiveScriptingSite, 
0x838e2f5e, 0xe20e, 0x11d2, 0xb3, 0x55, 0x0, 0x10, 0x5a, 0x1f, 0x47, 0x3a);

WCHAR * ReadScript(char * pFileName);

int main(int argc, char* argv[])
{
	if (2 != argc)
	{
		printf ("Usage: hosttest <scriptfile>\n");
		return 1;
	}

	LPWSTR pScriptText = ReadScript (argv[1]);
		
    HRESULT sc = CoInitialize(0);

	// Get the active script site
	IActiveScriptSite	*pSite = NULL;

	HRESULT hr = CoCreateInstance (CLSID_WmiActiveScriptingSite,NULL,
						CLSCTX_INPROC_SERVER,IID_IActiveScriptSite, (void**) &pSite);

	// Get the scripting engine
	CLSID clsid;
	hr = CLSIDFromProgID (L"JScript", &clsid);
	
	IActiveScript* pScriptEngine = NULL;
    hr =CoCreateInstance (clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**) &pScriptEngine);
    

    IActiveScriptParse* pParse;
    sc = pScriptEngine->QueryInterface(IID_IActiveScriptParse, (void**)&pParse);
    if(FAILED(sc))
        return 1;

    sc = pParse->InitNew();

    // Bind the host to the engine
    sc = pScriptEngine->SetScriptSite(pSite);
    pSite->Release();
    
	// Register the "this" pointer
    sc = pScriptEngine->AddNamedItem(L"instance", 
        SCRIPTITEM_ISVISIBLE | SCRIPTITEM_NOCODE | SCRIPTITEM_GLOBALMEMBERS);
    if(FAILED(sc))
        return 1;

    EXCEPINFO ei;
    sc = pParse->ParseScriptText(
        pScriptText,
        NULL, NULL, NULL, 
        0, 0, 0, NULL, &ei);
    if(FAILED(sc))
        return 1;

    pParse->Release();

    sc = pScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
    if(FAILED(sc))
        return 1;

    pScriptEngine->Release();

    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}

WCHAR * ReadScript(char * pFileName)
{
    FILE *fp;
    BOOL bUnicode = FALSE;
    BOOL bBigEndian = FALSE;

    // Make sure the file exists and can be opened

    fp = fopen(pFileName, "rb");
    if (!fp)
    {
        printf("\nCant open file %s", pFileName);
        return NULL;
    }

    // Determine the size of the file
    // ==============================
    
    fseek(fp, 0, SEEK_END);
    long lSize = ftell(fp); // add a bit extra for ending space and null NULL
    fseek(fp, 0, SEEK_SET);

    // Check for UNICODE source file.
    // ==============================

    BYTE UnicodeSignature[2];
    if (fread(UnicodeSignature, sizeof(BYTE), 2, fp) != 2)
    {
        printf("\nNothing in file %s", pFileName);
        fclose(fp);
        return NULL;
    }

    if (UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE)
    {
        LPWSTR pRet = new WCHAR[lSize/2 +2];
        if(pRet == NULL)
            return NULL;
        fread(pRet, 1, lSize-2, fp);
        fclose(fp);
        return pRet;
    }

    else
    {
        fseek(fp, 0, SEEK_SET);
        LPSTR pTemp = new char[lSize+1];
		memset (pTemp,0,(lSize+1) * sizeof(char));
        LPWSTR pRet = new WCHAR[lSize+1];
		memset (pRet, 0, (lSize + 1) * sizeof (WCHAR));
        if(pRet == NULL || pTemp == NULL)
            return NULL;
        fread(pTemp, 1, lSize, fp);
        fclose(fp);
        mbstowcs(pRet, pTemp, lSize);
        delete pTemp;
        return pRet;

    }

    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\test\userprov\methprov.cpp ===
//***************************************************************************
//
//  METHPROV.CPP
//
//  Module: WBEM Method provider sample code
//
//  Purpose: Defines the CMethodPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"
#include <process.h>
#include <wbemidl.h>
#include <stdio.h>
#include "cominit.h"

//***************************************************************************
//
// CMethodPro::CMethodPro
// CMethodPro::~CMethodPro
//
//***************************************************************************

CMethodPro::CMethodPro()
{
    InterlockedIncrement(&g_cObj);
    return;
   
}

CMethodPro::~CMethodPro(void)
{
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CMethodPro::QueryInterface
// CMethodPro::AddRef
// CMethodPro::Release
//
// Purpose: IUnknown members for CMethodPro object.
//***************************************************************************


STDMETHODIMP CMethodPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IWbemServices == riid || IID_IWbemProviderInit==riid)
       if(riid== IID_IWbemServices){
          *ppv=(IWbemServices*)this;
       }

       if(IID_IUnknown==riid || riid== IID_IWbemProviderInit){
          *ppv=(IWbemProviderInit*)this;
       }
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMethodPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMethodPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*CMethodPro::Initialize                                                *
*                                                                      *
*Purpose: This is the implementation of IWbemProviderInit. The method  *
* is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/
STDMETHODIMP CMethodPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{

   
   m_pWbemSvcs=pNamespace;
   m_pWbemSvcs->AddRef();
   
    //Let CIMOM know your initialized
    //===============================
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}



/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is GetUserID.  It    * 
*         returns the user name and domain name of the thread in which  * 
*         the provider is called.  The mof definition is                *
*                                                                       *
*    [dynamic: ToInstance, provider("UserIDProvider")]class UserID      *
*    {                                                                  *
*         [implemented, static]                                         *
*            void GetUserID(											*
*				[out]string sDomain,									*
*               [out] string sUser,										*
*				[out] string dImpLevel,									*
*				[out] string sPrivileges [],							*
*				[out] boolean bPrivilegesEnabled []);                   *
*    };                                                                 *
*                                                                       *
************************************************************************/

STDMETHODIMP CMethodPro::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pResultSink)
{
    HRESULT hr = WBEM_E_FAILED;  
	
	if (FAILED (WbemCoImpersonateClient ()))
		return WBEM_E_ACCESS_DENIED;

	IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
 
    if(_wcsicmp(MethodName, L"GetUserID"))
        return WBEM_E_INVALID_PARAMETER;

    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"UserID");    
    BSTR DomainOutputArgName = SysAllocString(L"sDomain");
    BSTR UserOutputArgName = SysAllocString(L"sUser");
	BSTR ImpOutputArgName = SysAllocString(L"sImpLevel");
    BSTR PrivOutputArgName = SysAllocString(L"sPrivileges");
    BSTR EnabledOutputArgName = SysAllocString(L"bPrivilegesEnabled");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pWbemSvcs->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		 pResultSink->SetStatus(0,hr, NULL, NULL);
		 return WBEM_S_NO_ERROR;
	}
 
    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

	// Get the user and domain from the thread token

	HANDLE hToken;
	HANDLE hThread = GetCurrentThread ();

	// Open thread token
	if (OpenThreadToken (hThread, TOKEN_QUERY, true, &hToken))
	{
		DWORD dwRequiredSize = 0;
		DWORD dwLastError = 0;
		bool status = false;

		// Step 0 - get impersonation level
		SECURITY_IMPERSONATION_LEVEL secImpLevel;
		if (GetTokenInformation (hToken, TokenImpersonationLevel, &secImpLevel, 
												sizeof (SECURITY_IMPERSONATION_LEVEL), &dwRequiredSize))
		{
			VARIANT var;
			VariantInit (&var);
			var.vt = VT_BSTR;

			switch (secImpLevel)
			{
				case SecurityAnonymous:
					var.bstrVal = SysAllocString (L"Anonymous");
					break;
				
				case SecurityIdentification:
					var.bstrVal = SysAllocString (L"Identification");
					break;
				
				case SecurityImpersonation:
					var.bstrVal = SysAllocString (L"Impersonation");
					break;

				case SecurityDelegation:
					var.bstrVal = SysAllocString (L"Delegation");
					break;

				default:
					var.bstrVal = SysAllocString (L"Unknown");
					break;
			}

			pOutParams->Put(ImpOutputArgName , 0, &var, 0);      
			VariantClear (&var);
		}

		DWORD dwUSize = sizeof (TOKEN_USER);
		TOKEN_USER *tu = (TOKEN_USER *) new BYTE [dwUSize];

		// Step 1 - get user info
		if (0 ==  GetTokenInformation (hToken, TokenUser, 
							(LPVOID) tu, dwUSize, &dwRequiredSize))
		{
			delete [] tu;
			dwUSize = dwRequiredSize;
			dwRequiredSize = 0;
			tu = (TOKEN_USER *) new BYTE [dwUSize];

			if (!GetTokenInformation (hToken, TokenUser, (LPVOID) tu, dwUSize, 
								&dwRequiredSize))
				dwLastError = GetLastError ();
			else
				status = true;
		}

		if (status)
		{
			// Dig out the user info
			dwRequiredSize = BUFSIZ;
			char *userName = new char [dwRequiredSize];
			char *domainName = new char [dwRequiredSize];
			SID_NAME_USE eUse;

			LookupAccountSid (NULL, (tu->User).Sid, userName, &dwRequiredSize,
									domainName, &dwRequiredSize, &eUse);

			VARIANT var;
			VariantInit (&var);
			var.vt = VT_BSTR;

			wchar_t wUserName [BUFSIZ];
			size_t len = mbstowcs( wUserName, userName, strlen (userName));
			wUserName [len] = NULL;
			
			var.bstrVal = SysAllocString (wUserName);
		    pOutParams->Put(UserOutputArgName , 0, &var, 0);      
			
			SysFreeString (var.bstrVal);

			wchar_t wDomainName [BUFSIZ];
			len = mbstowcs( wDomainName, domainName, strlen (domainName));
			wDomainName [len] = NULL;
			var.bstrVal = SysAllocString (wDomainName);
		  	pOutParams->Put(DomainOutputArgName , 0, &var, 0);      

			VariantClear (&var);

			delete [] userName;
			delete [] domainName;
		}
		
		delete [] tu;

		// Step 2 - get privilege info
		status = false;
		dwRequiredSize = 0;

		DWORD dwSize = sizeof (TOKEN_PRIVILEGES);
		TOKEN_PRIVILEGES *tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];
		
		// Step 2 - get privilege info
		if (0 ==  GetTokenInformation (hToken, TokenPrivileges, 
							(LPVOID) tp, dwSize, &dwRequiredSize))
		{
			delete [] tp;
			dwSize = dwRequiredSize;
			dwRequiredSize = 0;

			tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];
			if (!GetTokenInformation (hToken, TokenPrivileges, 
							(LPVOID) tp, dwSize, &dwRequiredSize))
			{
				dwLastError = GetLastError ();
			}
			else
				status = true;
		}
		else
			status = true;

		if (status)
		{
			SAFEARRAYBOUND rgsabound;
			rgsabound.cElements = tp->PrivilegeCount;
			rgsabound.lLbound = 0;

			SAFEARRAY *pPrivArray = SafeArrayCreate (VT_BSTR, 1, &rgsabound);
			SAFEARRAY *pEnabArray = SafeArrayCreate (VT_BOOL, 1, &rgsabound);

			for (ULONG i = 0; i < tp->PrivilegeCount; i++)
			{
				TCHAR name [BUFSIZ];
				WCHAR wName [BUFSIZ];
				DWORD dwRequiredSize = BUFSIZ;

				if (LookupPrivilegeName (NULL, &(tp->Privileges [i].Luid), name, &dwRequiredSize))
				{
					VARIANT_BOOL enabled = (tp->Privileges [i].Attributes & 
									(SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT)) ?
								VARIANT_TRUE : VARIANT_FALSE;

					mbstowcs (wName, name, strlen (name));
					wName [dwRequiredSize] = NULL;
					BSTR bsName = SysAllocString (wName);
					
					SafeArrayPutElement (pPrivArray, (LONG*) &i, bsName);
					SafeArrayPutElement (pEnabArray, (LONG*) &i, &enabled);
				}
			}

			VARIANT var1;
			var1.vt = VT_ARRAY|VT_BSTR;
			var1.parray = pPrivArray;
			pOutParams->Put(PrivOutputArgName , 0, &var1, 0);

			VariantClear (&var1);

			var1.vt = VT_ARRAY|VT_BOOL;
			var1.parray = pEnabArray;
			pOutParams->Put(EnabledOutputArgName , 0, &var1, 0);

			VariantClear (&var1);
		}
	
		delete [] tp;

		CloseHandle (hToken);
	}

	CloseHandle (hThread);

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(DomainOutputArgName);
    SysFreeString(UserOutputArgName);
	SysFreeString(ImpOutputArgName);
	SysFreeString(PrivOutputArgName);
    SysFreeString(EnabledOutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\corepol.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    COREPOL.H

Abstract:

    declspec import/export helpers

History:

--*/

//#define TRACKING 

// If we are building the DLL then define the 
// class as exported otherwise as imported
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including COREPOL.H..." )


#ifdef USE_POLARITY
  #ifdef BUILDING_DLL
//   #pragma message( "Building static library or DLL..." )
   #define POLARITY __declspec( dllexport )
  #else 
//   #pragma message( "Building Provider..." )
   #define POLARITY __declspec( dllimport )
  #endif
 #else
  #define POLARITY
//  #pragma message( "NO Polarity...")
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\brodcast.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  BrodCast.cpp
//
//  Purpose: Logging functions
//
//***************************************************************************

#include "precomp.h"

#include <assertbreak.h>
#include <stdio.h>
#include <stdarg.h>
#include <conio.h>
#include <Math.h>
#include <multiplat.h>

#include <BrodCast.h>      
#include <impersonaterevert.h>
#include <SmartPtr.h>
#include <helper.h>

// a little something to make sure we don't try to access
// instance variables that no longer exist
bool bAlive = false;

// we only need one of these lying around
ProviderLog captainsLog;
// so we'll build in a check...
#ifdef _DEBUG
bool ProviderLog::m_beenInitted = false;
#endif

//
// neccessary for smart deletion
//

class CThreadBase ;
typedef void ( CThreadBase:: * TBC ) ( void ) ;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      ProviderLog ctor
 Description:   provides initial initialization
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
ProviderLog::ProviderLog(void) :

m_lastLookedAtRegistry ( 0 ) ,
m_logLevel ( ProviderLog::None ) 

{
#ifdef _DEBUG
    if (m_beenInitted)
        ASSERT_BREAK(0); // do not instanciate one of these
                         // - use the LogMessage macro defined in the header file!
#endif

	m_maxSize.QuadPart = 65536 ;

	try
	{
		//
		// allocations inside of function will use
		// framedyn!operator new which throws
		// CHeap_Exception 
		//

		IsLoggingOn () ;   
	}
	catch ( CHeap_Exception & he )
	{
		//
		// hitting following, we may have logging disabled 
		// for time when framedyn.dll is loaded
		//
		// although logging is trying dynamically update
		// logging level, path etc so eventually it will
		// self repair when memory is available
		//
		// it is safer than count on undefined path and
		// m_path may be eventually reloaded next time when
		// more memory will be available ...
		//
		// we just must not re-throw here!
		//
	}

#ifdef _DEBUG
    m_beenInitted = true;
#endif

}

ProviderLog::~ProviderLog(void)
{
	bAlive = false ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      IsLoggingOn
 Description:   determine whether logging is enabled, find path if it is
                caches info - it will only look at registry once every three minutes.
                Also enforces file size limit.
 Arguments:     CHString ptr to recieve path (may be NULL)
 Returns:       LogLevel
 Inputs:
 Outputs:
 Caveats:       if return is zero, path is undefined
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
ProviderLog::LogLevel ProviderLog::IsLoggingOn(CHString *pPath /* = NULL */)
{
    union 
    {
        FILETIME fileTime;
        unsigned __int64 now;
    } myTime;

    GetSystemTimeAsFileTime(&myTime.fileTime);

    // if three minutes have elapsed, check again.
    if ((myTime.now - m_lastLookedAtRegistry) > (180 * 10000000))
    {
        BeginWrite();
		OnDeleteObj0 < CThreadBase, TBC, &CThreadBase::EndWrite> SmartEndWrite ( const_cast < ProviderLog* > ( this ) ) ;

		bAlive = false ;

		CRegistry					RegInfo;
		ProviderImpersonationRevert	impSelf(FALSE); // So our registry call works.

		if(RegInfo.Open(HKEY_LOCAL_MACHINE, 
						L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
						KEY_READ) == ERROR_SUCCESS) 
		{
			DWORD flag;

			// see if we can find the flag
			if((RegInfo.GetCurrentKeyValue(L"Logging", flag) == ERROR_SUCCESS) && (flag <= (DWORD)Verbose))
			{
				// we found one & it's true so we'll try to grab the name itself
				if (m_logLevel = (LogLevel)flag)
				{
					// retrieve dir name or use default
					CHString sTemp;
					if ((RegInfo.GetCurrentKeyValue(L"Logging Directory", sTemp) != ERROR_SUCCESS) 
						|| (sTemp.IsEmpty()))
						sTemp = L"C:\\";

					// Expand the environment string
					WCHAR szPath[_MAX_PATH];
					if (FRExpandEnvironmentStrings(sTemp, szPath, _MAX_PATH) != 0)
					{
						sTemp = szPath;
						// append backslash
						if (sTemp[sTemp.GetLength() -1] != '\\')
							sTemp += '\\';
					}
					else
					{
						sTemp = L"C:\\";
					}
					// append file name
					m_path = sTemp + L"FrameWork.log";

					//
					// set time we get data out of registry
					//
					m_lastLookedAtRegistry = myTime.now;

					//
					// make sure live flag is set. It is safe to assume
					// all other member variables are set already and
					// worst case, size of file won't change ...
					//
					bAlive = true ;

					CHString maxSizeStr;
					if (RegInfo.GetCurrentKeyValue(L"Log File Max Size", maxSizeStr) == ERROR_SUCCESS)
					{
						m_maxSize.QuadPart = _wtoi64(maxSizeStr);
						if (m_maxSize.QuadPart <= 0)
							m_maxSize.QuadPart = 65536;
					}
					else
						m_maxSize.QuadPart = 65536;

				}   // if logging on
			} // if reginfo get current key
			else
				m_logLevel = None;
			RegInfo.Close() ;

		} // if reginfo open

	} // if three minutes have elapsed, check again.

    // make sure some other thread doesn't step on our logic
	LogLevel ret = ProviderLog::None ;

    BeginRead();
	OnDeleteObj0 < CThreadBase, TBC, &CThreadBase::EndRead> SmartEndRead ( const_cast < ProviderLog* > ( this ) ) ;

	if ( bAlive )
	{
		if (ret = m_logLevel)
		{
			if ( NULL != pPath )
			{
				*pPath = m_path;
			}
		}
	}

    return ret;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: void LocalLogMessage(char *pszMessageString)
 Description: records message in log file
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void ProviderLog::LocalLogMessage(LPCWSTR pszMessageString, LPCWSTR pszFileName, int lineNo, LogLevel level)
{
#ifdef _DEBUG
    // *shouldn't* be able to get here before the static ctor fires!
    ASSERT_BREAK(m_beenInitted);
#endif

    CHString path;
    LARGE_INTEGER liSize;
    liSize.QuadPart = 0;

    // Doing this call twice avoids the crit section for the most common case.  Actually, for the
    // most common case, it only gets called once anyway.
    if ((level <= IsLoggingOn(NULL)) && (level <= IsLoggingOn(&path)) && !path.IsEmpty())
    {
        BeginWrite();
		OnDeleteObj0 < CThreadBase, TBC, &CThreadBase::EndWrite> SmartEndWrite ( const_cast < ProviderLog* > ( this ) ) ;

		if ( bAlive )
		{
			ProviderImpersonationRevert    impSelf(FALSE); // So the file calls work.

			SmartCloseHandle hFile;

			hFile = ::CreateFileW(
				path,
				GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ,
				NULL,
				OPEN_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL);
	        
			if(hFile != INVALID_HANDLE_VALUE)
			{
				SYSTEMTIME localTime;
				GetLocalTime(&localTime);

				CHString chstrMsg;
				chstrMsg.Format(
					L"%s\t%02d/%02d/%d %02d:%02d:%02d.%03d\tthread:%u\t[%s.%d]\r\n", 
					pszMessageString, 
					localTime.wMonth, 
					localTime.wDay, 
					localTime.wYear, 
					localTime.wHour, 
					localTime.wMinute, 
					localTime.wSecond, 
					localTime.wMilliseconds,
					GetCurrentThreadId(), 
					pszFileName, 
					lineNo);

            	int nLen = ::WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)chstrMsg, -1, NULL, 0, NULL, NULL);

				CSmartBuffer pBuff(nLen);
            	::WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)chstrMsg, -1, (LPSTR)(LPBYTE)pBuff, nLen, NULL, NULL);

				::SetFilePointer(
					hFile,
					0,
					0,
					FILE_END);

				DWORD dwNumBytesWritten = 0L;
				::WriteFile(
					hFile,
					pBuff,
					nLen - 1,
					&dwNumBytesWritten,
					NULL);

				// Save the size
				::GetFileSizeEx(
					hFile,
					&liSize);

				// Close the file in case we need to rename
				hFile = INVALID_HANDLE_VALUE;

				// Check the size against the max
				CheckFileSize(liSize, m_path);
			}        
		}
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      CheckFileSize
 Description:   determines whether the log file has exceeded the alllowable size
                if it has, the old one is renamed after the old old one is deleted

 Arguments:     CRegistry& RegInfo - open registry, full path to file
 Returns:       usually
 Inputs:
 Outputs:
 Caveats:       expects caller to serialize access to this function.
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void ProviderLog::CheckFileSize(LARGE_INTEGER& nowSize, const CHString &path)
{
    // if it's too big
    if (nowSize.QuadPart >= m_maxSize.QuadPart)
    {
        // generate backup file name = framework.lo_
        CHString oldFilePath(path);
        oldFilePath.SetAt(oldFilePath.GetLength() -1, L'_');

        // delete the old backup file - don't care if it fails
#ifdef UNICODE
        _wunlink(oldFilePath);
        _wrename(path, oldFilePath);
#else
        _unlink(bstr_t(oldFilePath));
        rename(bstr_t(path), bstr_t(oldFilePath));
#endif
    }
}

void ProviderLog::LocalLogMessage(LPCWSTR pszFileName, int lineNo, LogLevel level, LPCWSTR pszFormatString,...)
{
    if (level <= IsLoggingOn(NULL))
    {
        va_list argList;
        va_start(argList, pszFormatString);

        CHString sMsg; 
        sMsg.FormatV(pszFormatString, argList);
        va_end(argList);

        LocalLogMessage(sMsg, pszFileName, lineNo, level);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\test\userprov\methprov.h ===
//***************************************************************************
//
//  methprov.h
//
//  Module: WBEM Method Test Provider code
//
//  Purpose: Method Provider Test Header File.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _methprov_H_
#define _methprov_H_

#include "wbemidl.h"

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CMethodPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pWbemSvcs;
        IWbemClassObject* m_pOutClass;
     public:
        CMethodPro();
        ~CMethodPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};


        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        // Supported !!!!

        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**){return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

       
};

typedef CMethodPro *PCMethodPro;

// This class is the class factory for CMethodPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\clsfctry.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  CLSFCTRY.CPP
//
//  Purpose: Implementation of CWbemGlueFactory class
//
//***************************************************************************

#include "precomp.h"
#include <BrodCast.h>
#include <assertbreak.h>

#define DUPLICATE_RELEASE 0

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::CWbemGlueFactory
//
//  Class CTor.  This is the class factory for the Wbem Provider
//  framework.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   This is the backward compatibility constructor.  It
//              uses CLSID_NULL, which it will share with all
//              old-fashioned providers.
//
/////////////////////////////////////////////////////////////////////

CWbemGlueFactory::CWbemGlueFactory()
:   m_lRefCount( 0 )
{
    LogMessage2(L"CWbemGlueFactory::CWbemGlueFactory(NULL) %p", this);

    CWbemProviderGlue::AddToFactoryMap(this, NULL);
    CWbemProviderGlue::IncrementMapCount(this);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::CWbemGlueFactory
//
//  Class CTor.  This is the class factory for the Wbem Provider
//  framework.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   
//
/////////////////////////////////////////////////////////////////////

CWbemGlueFactory::CWbemGlueFactory(PLONG pLong)
:   m_lRefCount( 0 )
{
    LogMessage3(L"CWbemGlueFactory::CWbemGlueFactory(%p) %p", pLong, this);

    CWbemProviderGlue::AddToFactoryMap(this, pLong);
    CWbemProviderGlue::IncrementMapCount(this);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::~CWbemGlueFactory
//
//  Class DTor.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

CWbemGlueFactory::~CWbemGlueFactory(void)
{
    try
    {
        LogMessage2(L"CWbemGlueFactory::~CWbemGlueFactory(%p)", this);
    }
    catch ( ... )
    {
    }

    CWbemProviderGlue::DecrementMapCount(this);
    CWbemProviderGlue::RemoveFromFactoryMap(this);

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::QueryInterface
//
//  COM function called to ask us if we support a particular
//  face type.  If so, we addref ourselves and return the
//  ourselves as an LPVOID.
//
//  Inputs:     REFIID          riid - Interface being queried for.
//
//  Outputs:    LPVOID FAR*     ppvObj - Interface pointer.
//
//  Returns:    None.
//
//  Comments:   The only interfaces we support are IID_IUnknown and
//              IID_IClassFactory.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemGlueFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid) {
        *ppv=this;
    }
    
    if (NULL!=*ppv)    
    {
        AddRef();
        try 
        {
            LogMessage(L"CWbemGlueFactory::QueryInterface");
        }
        catch ( ... )
        {
        }
        return NOERROR;
    }
    else
    {
        try
        {
            LogErrorMessage(L"CWbemGlueFactory::QueryInterface FAILED!");
        }
        catch ( ... )
        {
        }
    }

    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::AddRef
//
//  Increments the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   Requires that a correponding call to Release be
//              performed.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CWbemGlueFactory::AddRef(void)
{
    try
    {
        LogMessage(L"CWbemGlueFactory::AddRef()");
    }
    catch ( ... )
    {
    }

    // InterlockedIncrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.
    return InterlockedIncrement( &m_lRefCount );
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::Release
//
//  Decrements the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CWbemGlueFactory::Release(void)
{
    try
    {
        LogMessage(L"CWbemGlueFactory::Release()");
    }
    catch ( ... )
    {
    }

    // InterlockedDecrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.

    // We want to hold the value locally in case two threads
    // Release at the same time and one gets a final release,
    // and deletes, leaving a potential window in which a thread
    // deletes the object before the other returns and tries to
    // reference the value from within the deleted object.

    ULONG   nRet = InterlockedDecrement( &m_lRefCount );
    
    if( 0 == nRet )
    {
        delete this ;
    }
    else if (nRet > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
        LogErrorMessage(L"Duplicate WbemGlueFactory Release()");
    }

    return nRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::CreateInstance
//
//  Creates an instance of a locator object from which a provider
//  can be instantiated.
//
//  Inputs:     LPUNKNOWN       pUnkOuter - to the controlling IUnknown if we are
//                              being used in an aggregation.
//              REFIID          riid - REFIID identifying the interface the caller
//                              desires to have for the new object.
//
//  Outputs:    PPVOID          ppvObj - in which to store the desired
//                              interface pointer for the new object.
//
//  Returns:    HRESULT  NOERROR if successful, 
//              otherwise E_NOINTERFACE if we cannot support the requested interface.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemGlueFactory::CreateInstance(LPUNKNOWN pUnkOuter , REFIID riid, PPVOID ppvObj)
{
    *ppvObj=NULL;
    HRESULT hr = ResultFromScode(E_OUTOFMEMORY);

    // This object doesn't support aggregation.

    if (NULL!=pUnkOuter)
    {
        return ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    try
    {
        IWbemServices *pObj= new CWbemProviderGlue(CWbemProviderGlue::GetMapCountPtr(this));

        if (pObj)
        {
            hr=pObj->QueryInterface(riid, ppvObj);
        }

        if (SUCCEEDED(hr))
        {
            LogMessage(L"CWbemGlueFactory::CreateInstance() - Succeeded");
        }
        else 
        {
            delete pObj;
            LogMessage2(L"CWbemGlueFactory::CreateInstance() - Failed (%x)", hr);
        }
    }
    catch ( ... )
    {
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::LockServer
//
//  Increment/Decrements the lock count on this DLL.
//
//  Inputs:     BOOL        fLock - Lock/Unlock
//
//  Outputs:    None.
//
//  Returns:    HRESULT - NOERROR at this time.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemGlueFactory::LockServer(BOOL fLock)
{
    try
    {
        if (IsVerboseLoggingEnabled())
        {
            CHString str;
            if (fLock)
            {
                LogMessage(L"CWbemGlueFactory::LockServer(TRUE)");
            }
            else
            {
                LogMessage(L"CWbemGlueFactory::LockServer(FALSE)");
            }
        }
    }
    catch ( ... )
    {
    }
   
    return CoLockObjectExternal((IUnknown *)this, fLock, FALSE); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\genlex.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
    {
        if (!m_pSrcBuf)
            return 0;
        else
            return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
    }

    void Pushback(wchar_t)
    {
        if (m_pSrcBuf)
            --m_pSrcBuf;
    }

    void Reset() { m_pSrcBuf = m_pStart; }
    void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\eventprovider.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  EventProvider.CPP
//
//  Purpose: Implementation of EventProvider class
//
//***************************************************************************

#include "precomp.h"

#ifdef EVENT_PROVIDER_ENABLED

#include <EventProvider.h>

EventProvider::EventProvider( const CHString& name, LPCWSTR pszNameSpace /* = NULL */ )
:Provider(name, pszNameSpace)    
{
    CWbemProviderGlue::FrameworkLoginEventProvider( name, this, pszNameSpace );
}

EventProvider::~EventProvider( void )
{
    // get out of the framework's hair
    CWbemProviderGlue::FrameworkLogoffEventProvider( m_name, LPCWSTR m_strNameSpace );
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   KickoffEvents
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   prep for ProvideEvents, validates flags
//              TODO: begin a new thread, return synchronously.
//
////////////////////////////////////////////////////////////////////////
HRESULT EventProvider::KickoffEvents( MethodContext *pContext, long lFlags /*= 0L*/ )
{
    HRESULT sc = ValidateProvideEventsFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will need
    // it to get WBEMClassObjects for constructing Instances.
    if ( SUCCEEDED(sc) )
    {
        if (ValidateIMOSPointer())
            sc = ProvideEvents( pContext, lFlags );
        else
            sc = WBEM_E_FAILED;
    }

    return sc;
}

// override of the base class' pure virtuals, return WBEM_E_PROVIDER_NOT_CAPABLE
// logic is that an event provider will not want to support them in the general case
HRESULT EventProvider::EnumerateInstances(MethodContext *pMethodContext, long lFlags /* = 0L */)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


// override of the base class' pure virtuals, return WBEM_E_PROVIDER_NOT_CAPABLE
// logic is that an event provider will not want to support them in the general case
HRESULT EventProvider::GetObject(CInstance *pInstance, long lFlags /* = 0L*/ )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

HRESULT EventProvider::ValidateProvideEventsFlags(long lFlags)
{
    // TODO: Fix cast hack, maybe base level fcn is wrong?
    return ValidateFlags(lFlags, (Provider::FlagDefs)0);
}

HRESULT EventProvider::ValidateQueryEventsFlags(long lFlags)
{
    // TODO: Fix cast hack, maybe base level fcn is wrong?
    return ValidateFlags(lFlags, (Provider::FlagDefs)0);
}

#endif //EVENT_PROVIDER_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\fwstrings.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  FWStrings.cpp
//
//  Purpose: Constant string declarations for framework
//
//***************************************************************************

#include "precomp.h"
#include "FWStrings.h"

LPCWSTR IDS_EXECQUERY = L"ExecQueryAsync: ";
LPCWSTR IDS_INVALIDCLASSNAME = L"\tFAILED: Invalid class name";
LPCWSTR IDS_PROVIDERNOTFOUND = L"\tFAILED: Provider Not Found";
LPCWSTR IDS_CREATEINSTANCEENUM = L"CreateInstanceEnumAsync: ";
LPCWSTR IDS_FAILED = L"\tFAILED!";
LPCWSTR IDS_STATUSCODE = L"StatusCode";
LPCWSTR IDS_DESCRIPTION = L"Description";
LPCWSTR IDS_PRIVILEGESNOTHELD = L"PrivilegesNotHeld";
LPCWSTR IDS_PRIVILEGESREQUIRED = L"PrivilegesRequired";
LPCWSTR IDS_WIN32PRIVILEGESSTATUS = L"Win32_PrivilegesStatus";
LPCWSTR IDS_PUTINSTANCEASYNC = L"PutInstanceAsync: ";
LPCWSTR IDS_DELETEINSTANCEASYNC = L"DeleteInstanceAsync: ";
LPCWSTR IDS_COULDNOTPARSE = L"\tFAILED: Could not parse input string";
LPCWSTR IDS_EXECMETHODASYNC = L"ExecMethodAsync: ";
LPCWSTR IDS_GETNAMESPACECONNECTION = L"GetNamespaceConnection: ";
LPCWSTR IDS_FRAMEWORKLOGIN = L"FrameworkLogin: ";
LPCWSTR IDS_FRAMEWORKLOGOFF = L"FrameworkLogoff: ";
LPCWSTR IDS_FRAMEWORKLOGINEVENT = L"FrameworkLoginEventProvider: ";
LPCWSTR IDS_FRAMEWORKLOGOFFEVENT = L"FrameworkLogoffEventProvider: ";
LPCWSTR IDS_GETALLINSTANCES = L"GetAllInstances: ";
LPCWSTR IDS_GETALLINSTANCESASYNC = L"GetAllInstancesAsynch: ";
LPCWSTR IDS_GETALLDERIVEDINSTANCESASYNC = L"GetAllDerivedInstancesAsynch: ";
LPCWSTR IDS_GETALLDERIVEDINSTANCES = L"GetAllDerivedInstances: ";
LPCWSTR IDS_GETALLINSTANCESFROMCIMOM = L"GetInstancesFromCIMOM: ";
LPCWSTR IDS_INSTANCEFROMCIMOM = L"GetInstanceFromCIMOM: ";
LPCWSTR IDS_GETOBJECTASYNC = L"GetObjectAsync: ";
LPCWSTR IDS_CINSTANCEERROR = L"ERROR CInstance(";
LPCWSTR IDS_ERRORTEMPLATE = L"error# %X";
LPCWSTR IDS_NOCLASS = L"No IWBEMClassObject interface";
LPCWSTR IDS_SETCHSTRING = L"SetCHString";
LPCWSTR IDS_GETCHSTRING = L"GetCHString";
LPCWSTR IDS_SETWORD = L"SetWORD";
LPCWSTR IDS_GETWORD = L"GetWORD";
LPCWSTR IDS_SETDWORD = L"SetDWORD";
LPCWSTR IDS_GETDWORD = L"GetDWORD";
LPCWSTR IDS_SETDOUBLE = L"SetDOUBLE";
LPCWSTR IDS_GETDOUBLE = L"GetDOUBLE";
LPCWSTR IDS_SETBYTE = L"SetByte";
LPCWSTR IDS_GETBYTE = L"GetByte";
LPCWSTR IDS_SETBOOL = L"Setbool";
LPCWSTR IDS_GETBOOL = L"Getbool";
LPCWSTR IDS_SETVARIANT = L"SetVariant";
LPCWSTR IDS_GETVARIANT = L"GetVariant";
LPCWSTR IDS_SETDATETIME = L"SetDateTime";
LPCWSTR IDS_GETDATETIME = L"GetDateTime";
LPCWSTR IDS_SETTIMESPAN = L"SetTimeSpan";
LPCWSTR IDS_GETTIMESPAN = L"GetTimeSpan";
LPCWSTR IDS_SETWBEMINT16 = L"SetWBEMINT16";
LPCWSTR IDS_GETWBEMINT16 = L"GetWBEMINT16";
LPCWSTR IDS_CreationClassName = L"CreationClassName";
LPCWSTR IDS_WQL = L"WQL";
LPCWSTR IDS_GETINSTANCESBYQUERY = L"GetInstancesByQuery";
LPCWSTR IDS_GLUEINIT = L"CWbemProviderGlue::Init";
LPCWSTR IDS_GLUEUNINIT = L"CWbemProviderGlue::UnInit";
LPCWSTR IDS_GLUEINITINTERFACE = L"CWbemProviderGlue::Initialize (interface)";
LPCWSTR IDS_GLUEREFCOUNTZERO = L"CWbemProviderGlue refcount at Zero: NOT releasing interfaces, NOT unloading, NOT doing anything except noting that one of our classes has a ref count that is zero.";
LPCWSTR IDS_WBEMSVCUNINITIALIZED = L" ERROR! IWbemServices is uninitialized!";
LPCWSTR IDS_LOGINDISALLOWED = L"    Login Warning - provider with that name already existed, overridden with latest provider login";
LPCWSTR IDS_DLLLOGGED = L"DLL Logged into framework: ";
LPCWSTR IDS_DLLUNLOGGED = L"DLL Logged out of framework: ";
LPCWSTR IDS_CLASS = L"__CLASS";
LPCWSTR IDS_DERIVATION = L"__DERIVATION";
LPCWSTR IDS_NAMESPACE = L"__NAMESPACE";
LPCWSTR IDS_CINSTANCEISNULL = L"CInstance::IsNull";
LPCWSTR IDS_UNKNOWNCLASS = L"unknown class";
LPCWSTR IDS_SetStringArray    = L"SetStringArray";
LPCWSTR IDS_GetStringArray    = L"GetStringArray";
LPCWSTR IDS_GetEmbeddedObject = L"GetEmbeddedObject";
LPCWSTR IDS_SetEmbeddedObject = L"SetEmbeddedObject";
LPCWSTR IDS_InsufficientImpersonationLevel = L"Insufficient Impersonation Level";
LPCWSTR IDS_ImpersonationFailed = L"Impersonation Failed";
LPCWSTR IDS_FillInstanceRefcountFailure = L"ERROR - FillInstance failed on CInstance with refcount > 1";
LPCWSTR IDS_Key = L"Key";
LPCWSTR IDS_Static = L"Static";
LPCWSTR IDS_InParam = L"Invalid input parameter specified";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\createmutexasprocess.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  CreateMutexAsProcess.CPP
//
//  Purpose: Create a mutex NOT using impersonation
//
//***************************************************************************

#include "precomp.h"
#include <brodcast.h>
#include <CreateMutexAsProcess.h>
#include "MultiPlat.h"

#include <cominit.h>

//
//
// precompiled security descriptor
// System and NetworkService has full access
//
// since this is RELATIVE, it will work on both IA32 and Win64
//
DWORD g_PrecSD[] = {
  0x80040001 , 0x00000044 , 0x00000050 , 0x00000000  ,
  0x00000014 , 0x00300002 , 0x00000002 , 0x00140000  ,
  0x001f0001 , 0x00000101 , 0x05000000 , 0x00000012  ,
  0x00140000 , 0x001f0001 , 0x00000101 , 0x05000000  ,
  0x00000014 , 0x00000101 , 0x05000000 , 0x00000014  ,
  0x00000101 , 0x05000000 , 0x00000014 
};

DWORD g_SizeSD = 0;

DWORD g_RuntimeSD	[
						(
							sizeof(SECURITY_DESCRIPTOR_RELATIVE) +
							(2 * (sizeof(SID)+SID_MAX_SUB_AUTHORITIES*sizeof(DWORD))) +
							sizeof(ACL) +
							(3 * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
							(3 * (sizeof(SID)+SID_MAX_SUB_AUTHORITIES*sizeof(DWORD)))
						)/sizeof(DWORD)
					];

typedef 
BOOLEAN ( * fnRtlValidRelativeSecurityDescriptor)(
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

fnRtlValidRelativeSecurityDescriptor RtlValidRelativeSecurityDescriptor;

//
//  Build a SD with owner == This
//                  group == This
//                  DACL
//                  ACE[0]  MUTEX_ALL_ACCESS Owner
//                  ACE[1]  MUTEX_ALL_ACCESS System
///////////////////////////////////////////////////////////////////

BOOL
CreateSD( )
{

	if (!RtlValidRelativeSecurityDescriptor)
	{
		HMODULE hModule = GetModuleHandleW(L"ntdll.dll");
		if (hModule)
		{
            RtlValidRelativeSecurityDescriptor = (fnRtlValidRelativeSecurityDescriptor)GetProcAddress(hModule,"RtlValidRelativeSecurityDescriptor");
			if (!RtlValidRelativeSecurityDescriptor)
			{
				return FALSE;
			}
		}
	}

    HANDLE hToken;
    BOOL bRet;
    
    bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken);
    if (bRet)
    {
        TOKEN_USER * pToken_User;
        DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));
        pToken_User = (TOKEN_USER *)_alloca(dwSize);
        bRet = GetTokenInformation(hToken,TokenUser,pToken_User,dwSize,&dwSize);
        if (bRet)
        {
            SID SystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID 
                            };
        
            SID NetworkSid =	{	SID_REVISION,
									1,
									SECURITY_NT_AUTHORITY,
									SECURITY_NETWORK_SERVICE_RID 
								};
        
            PSID pSIDUser = pToken_User->User.Sid;
            dwSize = GetLengthSid(pSIDUser);
            DWORD dwSids = 3; // Owner and System and NetworkService
            DWORD ACLLength = (ULONG) sizeof(ACL) +
                              (dwSids * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + dwSize + sizeof(SystemSid) + sizeof(NetworkSid);

            DWORD dwSizeSD = sizeof(SECURITY_DESCRIPTOR_RELATIVE) + dwSize + dwSize + ACLLength;
            SECURITY_DESCRIPTOR_RELATIVE * pLocalSD = (SECURITY_DESCRIPTOR_RELATIVE *)_alloca(dwSizeSD); 
            
            memset(pLocalSD,0,sizeof(SECURITY_DESCRIPTOR_RELATIVE));
            pLocalSD->Revision = SECURITY_DESCRIPTOR_REVISION;
            pLocalSD->Control = SE_DACL_PRESENT|SE_SELF_RELATIVE;
            
            //SetSecurityDescriptorOwner(pLocalSD,pSIDUser,FALSE);
            memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE),pSIDUser,dwSize);
            pLocalSD->Owner = (DWORD)sizeof(SECURITY_DESCRIPTOR_RELATIVE);
            
            //SetSecurityDescriptorGroup(pLocalSD,pSIDUser,FALSE);
            memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize,pSIDUser,dwSize);
            pLocalSD->Group = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize);


            PACL pDacl = (PACL)_alloca(ACLLength);

            bRet = InitializeAcl( pDacl,
                                  ACLLength,
                                  ACL_REVISION);
            if (bRet)
            {
                bRet = AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,MUTEX_ALL_ACCESS,&SystemSid);
                if (bRet)
                {
					bRet = AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,MUTEX_ALL_ACCESS,&NetworkSid);
					if (bRet)
					{
						bRet = AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,MUTEX_ALL_ACCESS,pSIDUser);
						
						if (bRet)
						{
							//bRet = SetSecurityDescriptorDacl(pLocalSD,TRUE,pDacl,FALSE);
							memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize,pDacl,ACLLength);	                
							pLocalSD->Dacl = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize);

							if (RtlValidRelativeSecurityDescriptor(pLocalSD,
															   dwSizeSD,
															   OWNER_SECURITY_INFORMATION|
															   GROUP_SECURITY_INFORMATION|
															   DACL_SECURITY_INFORMATION))
							{
								g_SizeSD = dwSizeSD;
								memcpy(g_RuntimeSD,pLocalSD,dwSizeSD);
							}
							else
							{
								bRet = FALSE;
							}
						}
					}
				}
            }
        }
        
        CloseHandle(hToken);
    }

    return bRet;
};

CreateMutexAsProcess::CreateMutexAsProcess(const WCHAR *cszMutexName) : m_hMutex ( NULL )
{
	BOOL	bCreatedAndWaited = FALSE;
	BOOL	bImpersonated	= TRUE;
	BOOL	bReverted		= FALSE;
	BOOL	bProceed		= FALSE;
	HANDLE hThreadToken = INVALID_HANDLE_VALUE;

	// The mutex will need to be opened in the process's context.  If two impersonated
	// threads need the mutex, we can't have the second one get an access denied when
	// opening the mutex.

	if ( OpenThreadToken (
			GetCurrentThread(),
			TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
			TRUE,
			&hThreadToken
		)
	) 
	{
		if ( RevertToSelf() )
		{
			bReverted = TRUE;
		}
		else
		{
			LogMessage2 ( L"Failed to revert to self: (%d)", GetLastError() );

			#if DBG == 1
			// for testing purpose I will let process break
			::DebugBreak();
			#endif
		}
	}
	else
	{
		DWORD dwError = ::GetLastError ();

		LogMessage2 ( L"Failed to open thread token: (%d)", dwError );

		if ( ERROR_ACCESS_DENIED == dwError )
		{
			// we failed to open thread token on behalf of process
			// we are running as NETWORK SERVICE so it would be "by design"

#if DBG == 1
// for testing purpose I will let process break
::DebugBreak();
#endif
		}
		else if ( ERROR_NO_TOKEN == dwError || ERROR_NO_IMPERSONATION_TOKEN == dwError )
		{
			bImpersonated = FALSE;
		}
	}

	if ( ( bImpersonated && bReverted ) || ! bImpersonated )
	{
		m_hMutex = OpenMutexW(MUTEX_ALL_ACCESS,FALSE,cszMutexName);
		if (NULL == m_hMutex)
		{
			SECURITY_ATTRIBUTES sa;

			if (0 == g_SizeSD)
			{
				if (CreateSD())
				{
					sa.nLength = g_SizeSD; 
					sa.lpSecurityDescriptor = (LPVOID)g_RuntimeSD; 
					sa.bInheritHandle = FALSE;	        
				}
				else
				{
					sa.nLength = sizeof(g_PrecSD);
					sa.lpSecurityDescriptor = (LPVOID)g_PrecSD;
					sa.bInheritHandle = FALSE;	        
				}	         
			}
			else
			{
				sa.nLength = g_SizeSD; 
				sa.lpSecurityDescriptor = (LPVOID)g_RuntimeSD; 
				sa.bInheritHandle = FALSE;	        	    
			}

			m_hMutex = CreateMutexW(&sa, FALSE, cszMutexName);
		}

		if ( m_hMutex != NULL )
		{
			if ( bImpersonated )
			{
				if ( ImpersonateLoggedOnUser ( hThreadToken ) )
				{
					bProceed = TRUE;
				}
				else
				{
					LogErrorMessage2 ( L"Failed to return to impersonation (%d)", GetLastError() );

					#if DBG == 1
					// for testing purpose I will let process break
					::DebugBreak();
					#endif
				}
			}
			else
			{
				bProceed = TRUE;
			}

			if ( bProceed )
			{
				DWORD dwWaitResult = WAIT_OBJECT_0;
				dwWaitResult = WaitForSingleObject(m_hMutex, INFINITE);

				if ( dwWaitResult == WAIT_OBJECT_0 )
				{
					bCreatedAndWaited = TRUE;
				}
				else
				{
					#if DBG == 1
					// for testing purpose I will let process break
					::DebugBreak();
					#endif
				}
			}
		}
		else
		{
			LogErrorMessage2 ( L"Failed to open mutex: %s", cszMutexName );

			if ( bImpersonated )
			{
				if ( !ImpersonateLoggedOnUser ( hThreadToken ) )
				{
					LogErrorMessage2 ( L"Failed to return to impersonation (%d)", GetLastError() );

					#if DBG == 1
					// for testing purpose I will let process break
					::DebugBreak();
					#endif
				}
			}

			#if DBG == 1
			// for testing purpose I will let process break
			::DebugBreak();
			#endif
		}
	}

	if ( ! bCreatedAndWaited )
	{
		if ( hThreadToken != INVALID_HANDLE_VALUE )
		{
			CloseHandle(hThreadToken);
			hThreadToken = INVALID_HANDLE_VALUE;
		}

		if (m_hMutex)
		{
			ReleaseMutex(m_hMutex);
			CloseHandle(m_hMutex);
			m_hMutex = NULL;
		}

		// we need to throw here to avoid concurrent access
		throw CFramework_Exception( L"CreateMutexAsProcess failed", HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ;
	}
}

CreateMutexAsProcess::~CreateMutexAsProcess()
{
    if (m_hMutex)
    {
        ReleaseMutex(m_hMutex);
        CloseHandle(m_hMutex);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\fwstrings.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  FWStrings.h
//
//  Purpose: Constant string declarations for framework
//
//***************************************************************************

#ifndef FWStrings_BEEN_COMPILED_ALREADY
#define FWStrings_BEEN_COMPILED_ALREADY

extern LPCWSTR IDS_EXECQUERY;
extern LPCWSTR IDS_INVALIDCLASSNAME;
extern LPCWSTR IDS_PROVIDERNOTFOUND;
extern LPCWSTR IDS_CREATEINSTANCEENUM;
extern LPCWSTR IDS_FAILED;
extern LPCWSTR IDS_STATUSCODE;
extern LPCWSTR IDS_DESCRIPTION;
extern LPCWSTR IDS_PRIVILEGESNOTHELD;
extern LPCWSTR IDS_PRIVILEGESREQUIRED;
extern LPCWSTR IDS_WIN32PRIVILEGESSTATUS;
extern LPCWSTR IDS_PUTINSTANCEASYNC;
extern LPCWSTR IDS_DELETEINSTANCEASYNC;
extern LPCWSTR IDS_COULDNOTPARSE;
extern LPCWSTR IDS_EXECMETHODASYNC;
extern LPCWSTR IDS_GETNAMESPACECONNECTION;
extern LPCWSTR IDS_FRAMEWORKLOGIN;
extern LPCWSTR IDS_FRAMEWORKLOGOFF;
extern LPCWSTR IDS_FRAMEWORKLOGINEVENT;
extern LPCWSTR IDS_FRAMEWORKLOGOFFEVENT;
extern LPCWSTR IDS_GETALLINSTANCES;
extern LPCWSTR IDS_GETALLINSTANCESASYNC;
extern LPCWSTR IDS_GETALLDERIVEDINSTANCESASYNC;
extern LPCWSTR IDS_GETALLDERIVEDINSTANCES;
extern LPCWSTR IDS_GETALLINSTANCESFROMCIMOM;
extern LPCWSTR IDS_INSTANCEFROMCIMOM;
extern LPCWSTR IDS_GETOBJECTASYNC;
extern LPCWSTR IDS_CINSTANCEERROR;
extern LPCWSTR IDS_ERRORTEMPLATE;
extern LPCWSTR IDS_NOCLASS;
extern LPCWSTR IDS_SETCHSTRING;
extern LPCWSTR IDS_GETCHSTRING;
extern LPCWSTR IDS_SETWORD;
extern LPCWSTR IDS_GETWORD;
extern LPCWSTR IDS_SETDWORD;
extern LPCWSTR IDS_GETDWORD;
extern LPCWSTR IDS_SETDOUBLE;
extern LPCWSTR IDS_GETDOUBLE;
extern LPCWSTR IDS_SETBYTE;
extern LPCWSTR IDS_GETBYTE;
extern LPCWSTR IDS_SETBOOL;
extern LPCWSTR IDS_GETBOOL;
extern LPCWSTR IDS_SETVARIANT;
extern LPCWSTR IDS_GETVARIANT;
extern LPCWSTR IDS_SETDATETIME;
extern LPCWSTR IDS_GETDATETIME;
extern LPCWSTR IDS_SETTIMESPAN;
extern LPCWSTR IDS_GETTIMESPAN;
extern LPCWSTR IDS_SETWBEMINT16;
extern LPCWSTR IDS_GETWBEMINT16;
extern LPCWSTR IDS_CreationClassName;
extern LPCWSTR IDS_WQL;
extern LPCWSTR IDS_GETINSTANCESBYQUERY;
extern LPCWSTR IDS_GLUEINIT;
extern LPCWSTR IDS_GLUEUNINIT;
extern LPCWSTR IDS_GLUEINITINTERFACE;
extern LPCWSTR IDS_GLUEREFCOUNTZERO;
extern LPCWSTR IDS_WBEMSVCUNINITIALIZED;
extern LPCWSTR IDS_LOGINDISALLOWED;
extern LPCWSTR IDS_DLLLOGGED;
extern LPCWSTR IDS_DLLUNLOGGED;
extern LPCWSTR IDS_CLASS;
extern LPCWSTR IDS_DERIVATION;
extern LPCWSTR IDS_NAMESPACE;
extern LPCWSTR IDS_CINSTANCEISNULL;
extern LPCWSTR IDS_UNKNOWNCLASS;
extern LPCWSTR IDS_SetStringArray;   
extern LPCWSTR IDS_GetStringArray;   
extern LPCWSTR IDS_GetEmbeddedObject;
extern LPCWSTR IDS_SetEmbeddedObject;
extern LPCWSTR IDS_InsufficientImpersonationLevel;
extern LPCWSTR IDS_ImpersonationFailed;
extern LPCWSTR IDS_FillInstanceRefcountFailure;
extern LPCWSTR IDS_Key;
extern LPCWSTR IDS_Static;
extern LPCWSTR IDS_InParam;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\genlex.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include "precomp.h"

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    PVOID pTmp = HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,m_nCurBufSize * 2);
                    if (pTmp == 0) return 0; // out of memory
                    m_pTokenBuf = (wchar_t *)pTmp;
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\frquery.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  FRQuery.cpp
//
//  Purpose: Query functions
//
//***************************************************************************

#include "precomp.h"
#include <analyser.h>
#include <assertbreak.h>
#include <comdef.h>
#include <FWStrings.h>
#include <vector>
#include <smartptr.h>
#include <brodcast.h>
#include <utils.h>
#include "multiplat.h"

#include <helper.h>

CFrameworkQuery::CFrameworkQuery()
{
    m_pLevel1RPNExpression = NULL;
    m_QueryType = eUnknown;
    m_bKeysOnly = false;
    m_IClass = NULL;
    m_lFlags = 0;

}

CFrameworkQuery::~CFrameworkQuery()
{
    if (m_pLevel1RPNExpression)
    {
        delete m_pLevel1RPNExpression;
    }

    if (m_IClass)
    {
        m_IClass->Release();
    }
}

HRESULT CFrameworkQuery::Init(

    const BSTR bstrQueryFormat,
    const BSTR bstrQuery,
    long lFlags,
    CHString &sNamespace
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Clear out any old values
    Reset();

    // Start setting our values
    m_lFlags = lFlags;
    m_bstrtClassName = L"";
    m_QueryType = eWQLCommand;
    m_sNamespace = sNamespace;

    // Check for the obvious
    if (_wcsicmp(bstrQueryFormat, IDS_WQL) != 0)
    {
        hRes = WBEM_E_INVALID_QUERY_TYPE;
        LogErrorMessage2(L"Invalid query type: %s", bstrQueryFormat);
    }

    if (hRes == WBEM_S_NO_ERROR)
    {
        // Construct the lex source
        // ========================
        CTextLexSource LexSource(bstrQuery);

        // Use the lex source to set up for parser
        // =======================================
        SQL1_Parser QueryParser(&LexSource);

        int ParseRetValue = QueryParser.Parse(&m_pLevel1RPNExpression);
        if( SQL1_Parser::SUCCESS == ParseRetValue)
        {
            // Store some common values
            m_bstrtClassName = m_pLevel1RPNExpression->bsClassName;
            m_sQuery = bstrQuery;

            // Build the Requested Properies Array (m_csaPropertiesRequired)
            if (m_pLevel1RPNExpression->nNumberOfProperties > 0)
            {
                // Populate the m_csaPropertiesRequired array with all the required properties
                CHString sPropertyName;

                // First add the elements of the Select clause
                for (DWORD x=0; x < m_pLevel1RPNExpression->nNumberOfProperties; x++)
                {
                    sPropertyName = m_pLevel1RPNExpression->pbsRequestedPropertyNames[x];
                    sPropertyName.MakeUpper();

                    if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                    {
                        m_csaPropertiesRequired.Add(sPropertyName);
                    }
                }

                // Then add the elements of the where clause
                for (x=0; x < m_pLevel1RPNExpression->nNumTokens; x++)
                {
                    if (m_pLevel1RPNExpression->pArrayOfTokens[x].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION)
                    {
                        sPropertyName = m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName;
                        sPropertyName.MakeUpper();

                        if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                        {
                            m_csaPropertiesRequired.Add(sPropertyName);
                        }

                        if (m_pLevel1RPNExpression->pArrayOfTokens[x].pPropName2 != NULL)
                        {
                            sPropertyName = m_pLevel1RPNExpression->pArrayOfTokens[x].pPropName2;
                            sPropertyName.MakeUpper();

                            if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                            {
                                m_csaPropertiesRequired.Add(sPropertyName);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            ASSERT_BREAK(FALSE);
            m_pLevel1RPNExpression = NULL;
            LogErrorMessage2(L"Can't parse query: %s", bstrQuery);
            hRes = WBEM_E_INVALID_QUERY;
        }
    }

    return hRes;
}

HRESULT CFrameworkQuery::Init(

    ParsedObjectPath *pParsedObjectPath,
    IWbemContext *pCtx,
    LPCWSTR lpwszClassName,
    CHString &sNamespace
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    variant_t vValue;

    // Clear out any old values
    Reset();

    // Start setting our values
    m_bstrtClassName = lpwszClassName;
    m_QueryType = eContextObject;
    m_lFlags = 0;
    m_sNamespace = sNamespace;

    // Check to see if get extensions are being used
    if ( (pCtx != NULL) &&
         (SUCCEEDED(pCtx->GetValue( L"__GET_EXTENSIONS", 0, &vValue))) &&
         (V_VT(&vValue) == VT_BOOL) &&
         (V_BOOL(&vValue) == VARIANT_TRUE) )
    {
        vValue.Clear();
        bool bKeysRequired = false;

        // Ok, did they ask for KeysOnly?
        // __GET_EXT_PROPERTIES and __GET_EXT_KEYS_ONLY are mutually exclusive.  If they
        // specified KeysOnly, we'll go with that.
        if ( (SUCCEEDED(pCtx->GetValue( L"__GET_EXT_KEYS_ONLY", 0, &vValue))) &&
             (V_VT(&vValue) == VT_BOOL) &&
             (V_BOOL(&vValue) == VARIANT_TRUE) )
        {
            LogMessage(L"Recognized __GET_EXT_KEYS_ONLY");
            m_bKeysOnly = true;
            bKeysRequired = true;
        }
        else
        {
            vValue.Clear();

            if ( (SUCCEEDED(pCtx->GetValue( L"__GET_EXT_PROPERTIES", 0, &vValue))) &&
                 (V_VT(&vValue) == (VT_ARRAY | VT_BSTR) ) &&
                 ( SafeArrayGetDim ( V_ARRAY(&vValue) ) == 1 ) )
            {
                LogMessage(L"Recognized __GET_EXT_PROPERTIES");

                // Ok, they sent us an arry of properties.  Add them to m_csaPropertiesRequired.
                LONG lDimension = 1 ;
                LONG lLowerBound ;
                SafeArrayGetLBound ( V_ARRAY(&vValue) , lDimension , & lLowerBound ) ;
                LONG lUpperBound ;
                SafeArrayGetUBound ( V_ARRAY(&vValue) , lDimension , & lUpperBound ) ;
                CHString sPropertyName;

                for ( long lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex ++ )
                {
                    BSTR bstrElement ;
                    HRESULT t_Result = SafeArrayGetElement ( V_ARRAY(&vValue), &lIndex , & bstrElement ) ;
                    if ( (t_Result == S_OK) &&
                         (bstrElement != NULL) )
                    {
						OnDelete<BSTR,VOID(*)(BSTR),SysFreeString> smartbstrElement(bstrElement);

						sPropertyName = bstrElement;
                        sPropertyName.MakeUpper();
                        
                        if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                        {
                            m_csaPropertiesRequired.Add(sPropertyName);
                        }
                    }
                }

                if ( (IsInList(m_csaPropertiesRequired, L"__RELPATH") != -1) ||
                     (IsInList(m_csaPropertiesRequired, L"__PATH") != -1) )
                {
                    bKeysRequired = true;
                }
            }
        }

        // If they specified KeysOnly or __RELPATH or __Path, we need to add the key properties
        // to the list.
        if (bKeysRequired)
        {
            if ((pParsedObjectPath != NULL) && (pParsedObjectPath->m_dwNumKeys > 0) && (pParsedObjectPath->m_paKeys[0]->m_pName != NULL))
            {
                CHString sPropertyName;
                for (DWORD x=0; x < pParsedObjectPath->m_dwNumKeys; x++)
                {
                    sPropertyName = pParsedObjectPath->m_paKeys[x]->m_pName;
                    sPropertyName.MakeUpper();

                    if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                    {
                        m_csaPropertiesRequired.Add(sPropertyName);
                    }
                }

                m_AddKeys = false;
            }
            else if ( (pParsedObjectPath != NULL) && (pParsedObjectPath->m_bSingletonObj) )
            {
                m_AddKeys = false;
            }
            else
            {
                // If they didn't give us a pParsedObjectPath or if the object path doesn't contain
                // the key property name, best we can do is add relpath. Hopefully they'll call 
                // init2, and it will add the rest.
                if (IsInList(m_csaPropertiesRequired, L"__RELPATH") == -1)
                {
                    m_csaPropertiesRequired.Add(L"__RELPATH");
                }
            }
        }
    }

    return hr;
}

// ===================================================================================================

// Finds out if a particular field was requested by the query.  Only
// meaningful if we are in ExecQueryAsync and the query has been
// sucessfully parsed.
bool CFrameworkQuery::IsPropertyRequired(
                                         
    LPCWSTR propName
)
{
    bool bRet = AllPropertiesAreRequired();

    if (!bRet)
    {
        CHString sPropName(propName);
        sPropName.MakeUpper();

        bRet = (IsInList(m_csaPropertiesRequired, sPropName) != -1);
    }

    return bRet;
}

// Given a property name, it will return all the values
// that the query requests in a CHStringArray.
// Select * from win32_directory where drive = "C:" GetValuesForProp(L"Drive") -> C:
// Where Drive = "C:" or Drive = "D:" GetValuesForProp(L"Drive") -> C:, D:
// Where Path = "\DOS" GetValuesForProp(L"Drive") -> (empty)
// Where Drive <> "C:" GetValuesForProp(L"Drive") -> (empty)

HRESULT CFrameworkQuery::GetValuesForProp(
                                          
    LPCWSTR wszPropName, 
    CHStringArray& achNames
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (wszPropName && (m_pLevel1RPNExpression != NULL))
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, achNames);
        
        if (SUCCEEDED(hr))
        {
            // If this is a reference property, we need to normalize the names to a common form
            // so the removal of duplicates works correctly.
            if (IsReference(wszPropName))
            {
                // Get the current computer name
                CHString sOutPath, sComputerName;
                DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                FRGetComputerName(sComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
                sComputerName.ReleaseBuffer();
                
                if (sComputerName.IsEmpty())
                {
                    sComputerName = L"DEFAULT";
                }

                DWORD dwRet = e_OK;

                // Normalize the path names.  Try leaving the property names alone
                for (int x = 0; x < achNames.GetSize(); x++)
                {
                    // If we failed to parse the path, or if the namespace isn't our namespace, delete
                    // the entry.
                    dwRet = NormalizePath(achNames[x], sComputerName, GetNamespace(), 0, sOutPath);

                    if (dwRet == e_OK)
                    {
                        achNames[x] = sOutPath;
                    }
                    else if (dwRet == e_NullName)
                    {
                        break;
                    }
                    else
                    {
                        achNames.RemoveAt(x);
                        x--;
                    }
                }

                // If the key property names of any of the values were null, we have to set them all
                // to null.
                if (dwRet == e_NullName)
                {
                    // Normalize the path names
                    for (int x = 0; x < achNames.GetSize(); x++)
                    {
                        // If we failed to parse the path, or if the namespace isn't our namespace, delete
                        // the entry.
                        dwRet = NormalizePath(achNames[x], sComputerName, GetNamespace(), NORMALIZE_NULL, sOutPath);

                        if (dwRet == e_OK)
                        {
                            achNames[x] = sOutPath;
                        }
                        else
                        {
                            achNames.RemoveAt(x);
                            x--;
                        }
                    }
                }
            }
            
            // Remove duplicates
            for (int x = 1; x < achNames.GetSize(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (achNames[y].CompareNoCase(achNames[x]) == 0)
                    {
                        achNames.RemoveAt(x);
                        x--;
                    }
                }
            }
        }
        else
        {
            achNames.RemoveAll();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }

        }
        
    }
    else
    {
        ASSERT_BREAK(FALSE);

        achNames.RemoveAll();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// Here's an overloaded version in case client wants to pass in a vector of _bstr_t's
HRESULT CFrameworkQuery::GetValuesForProp(

    LPCWSTR wszPropName, 
    std::vector<_bstr_t>& vectorNames
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (wszPropName && (m_pLevel1RPNExpression != NULL) )
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, vectorNames);
        
        if (SUCCEEDED(hr))
        {
            // If this is a reference property, we need to normalize the names to a common form
            // so the removal of duplicates works correctly.
            if (IsReference(wszPropName))
            {
                // Get the current computer name
                CHString sOutPath, sComputerName;
                DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                FRGetComputerName(sComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
                sComputerName.ReleaseBuffer();
                
                if (sComputerName.IsEmpty())
                {
                    sComputerName = L"DEFAULT";
                }
                
                DWORD dwRet = e_OK;

                // Normalize the path names.  Try leaving the property names alone
                for (int x = 0; x < vectorNames.size(); x++)
                {
                    // If we failed to parse the path, or if the namespace isn't our namespace, delete
                    // the entry.
                    dwRet = NormalizePath(vectorNames[x], sComputerName, GetNamespace(), 0, sOutPath);

                    if (dwRet == e_OK)
                    {
                        vectorNames[x] = sOutPath;
                    }
                    else if (dwRet == e_NullName)
                    {
                        break;
                    }
                    else
                    {
                        vectorNames.erase(vectorNames.begin() + x);
                        x--;
                    }
                }

                // If the key property names of any of the values were null, we have to set them all
                // to null.
                if (dwRet == e_NullName)
                {
                    for (int x = 0; x < vectorNames.size(); x++)
                    {
                        // If we failed to parse the path, or if the namespace isn't our namespace, delete
                        // the entry.
                        dwRet = NormalizePath(vectorNames[x], sComputerName, GetNamespace(), NORMALIZE_NULL, sOutPath);

                        if (dwRet == e_OK)
                        {
                            vectorNames[x] = sOutPath;
                        }
                        else
                        {
                            vectorNames.erase(vectorNames.begin() + x);
                            x--;
                        }
                    }
                }
            }
            
            // Remove duplicates
            for (int x = 1; x < vectorNames.size(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (_wcsicmp(vectorNames[y], vectorNames[x]) == 0)
                    {
                        vectorNames.erase(vectorNames.begin() + x);
                        x--;
                    }
                }
            }
        }
        else
        {
            vectorNames.clear();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        ASSERT_BREAK(FALSE);

        vectorNames.clear();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// Returns a list of all the properties specified in the select statement.
// If * is specified as one of the fields, it is returned in the same way as all
// other properties.
void CFrameworkQuery::GetRequiredProperties(

    CHStringArray &saProperties
)
{
    saProperties.RemoveAll();

    saProperties.Copy(m_csaPropertiesRequired);
}

// Initializes the KeysOnly data member.  Should never be called by users.
void CFrameworkQuery::Init2(
                            
    IWbemClassObject *IClass
)
{
    // Store IClass object for use in GetValuesForProp
    m_IClass = IClass;
    m_IClass->AddRef();

    // If KeysOnly get set somewhere else, or if we already know all properties are requried
    // there's no point in looking for non-key properties.
    if (!m_bKeysOnly && !AllPropertiesAreRequired())
    {
        // First, we are going to correctly set the m_bKeysOnly member
        IWbemQualifierSetPtr pQualSet;

        HRESULT hr;
        DWORD dwSize = m_csaPropertiesRequired.GetSize();

        m_bKeysOnly = true;

        for (DWORD x=0; x < dwSize; x++)
        {
            if (m_csaPropertiesRequired[x].Left(2) != L"__")
            {
                // If we fail here, it could be due to an invalid property name specified in the query.
                if (SUCCEEDED(hr = IClass->GetPropertyQualifierSet( m_csaPropertiesRequired[x] , &pQualSet)))
                {
                    hr = pQualSet->Get( L"Key", 0, NULL, NULL);
                    if (hr == WBEM_E_NOT_FOUND)
                    {
                        m_bKeysOnly = false;
                        break;
                    } 
                    else if (FAILED(hr))
                    {
                        LogErrorMessage3(L"Can't Get 'key' on %s(%x)", (LPCWSTR)m_csaPropertiesRequired[x], hr);
                        ASSERT_BREAK(FALSE);
                    }
                }
                else
                {
                    if (hr == WBEM_E_NOT_FOUND)
                    {
                        // This just means there are properties in the per-property list that don't exist
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        LogErrorMessage3(L"Can't get property GetPropertyQualifierSet on %s(%x)", (LPCWSTR)m_csaPropertiesRequired[x], hr);
                        ASSERT_BREAK(FALSE);
                    }
                }
            }
        }
    }

    // Second, if they specified a property list, and one of the properties was __path or __relpath, 
    // then we need to add the name of the actual key properties to the list.  Unless we added them
    // somewhere else.
    if ( m_AddKeys &&
        !AllPropertiesAreRequired() &&
         ( (IsInList(m_csaPropertiesRequired, L"__RELPATH") != -1) ||
           (IsInList(m_csaPropertiesRequired, L"__PATH") != -1) ) )
    {
        SAFEARRAY *pKeyNames = NULL;
        HRESULT hr;

        // Get the keys for the class
        if (SUCCEEDED(hr = IClass->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pKeyNames)))
        {
			OnDelete<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayDestroy> smartpKeyNames(pKeyNames);

            BSTR bstrName = NULL ;
            CHString sKeyName;
            LONG lLBound, lUBound;

            SafeArrayGetLBound(pKeyNames, 1, &lLBound);
            SafeArrayGetUBound(pKeyNames, 1, &lUBound);

            // Walk the key properties, and add any properties that 
            // are not already in the list
            for (long i = lLBound; i <= lUBound; i++)
            {
                if (SUCCEEDED(SafeArrayGetElement( pKeyNames, &i, &bstrName )))
                {
					OnDeleteIf<BSTR,VOID(*)(BSTR),SysFreeString> smartbstrName(bstrName);

					sKeyName = bstrName;
                    sKeyName.MakeUpper();

                    if (IsInList(m_csaPropertiesRequired, sKeyName) == -1)
                    {
                        m_csaPropertiesRequired.Add(sKeyName);
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
        else
        {
            LogErrorMessage2(L"Failed to Get keys", hr);
        }
    }
}

const CHString &CFrameworkQuery::GetQuery()
{
    if (m_QueryType == eContextObject)
    {
        if (m_sQuery.IsEmpty())
        {
            if (AllPropertiesAreRequired())
            {
                bstr_t t_Str ( GetQueryClassName() , FALSE) ;

                m_sQuery.Format(L"SELECT * FROM %s", (LPCWSTR)t_Str );
            }
            else if (KeysOnly())
            {
                bstr_t t_Str ( GetQueryClassName() , FALSE) ;

                m_sQuery.Format(L"SELECT __RELPATH FROM %s", (LPCWSTR)t_Str );
            }
            else
            {
                m_sQuery = L"SELECT " + m_csaPropertiesRequired[0];

                for (DWORD x=1; x < m_csaPropertiesRequired.GetSize(); x++)
                {
                    m_sQuery += L", ";
                    m_sQuery += m_csaPropertiesRequired[x];
                }
                m_sQuery += L" FROM ";

                bstr_t t_Str ( GetQueryClassName() , FALSE) ;

                m_sQuery += t_Str ;
            }
        }
    }

    return m_sQuery;
}

/*****************************************************************************
 *
 *  FUNCTION    : IsInList
 *
 *  DESCRIPTION : Checks to see if a specified element is in the list
 *
 *  INPUTS      : Array to scan, and element
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : -1 if not in list, else zero based element number
 *
 *  COMMENTS    : This routine does a CASE SENSITIVE compare
 *
 *****************************************************************************/
DWORD CFrameworkQuery::IsInList(
                                
    const CHStringArray &csaArray, 
    LPCWSTR pwszValue
)
{
    DWORD dwSize = csaArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        // Note this is a CASE SENSITIVE compare
        if (wcscmp(csaArray[x], pwszValue) == 0)
        {
            return x;
        }
    }

    return -1;
}

/*****************************************************************************
 *
 *  FUNCTION    : Reset
 *
 *  DESCRIPTION : Zeros out class data members
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
void CFrameworkQuery::Reset(void)
{
    // Clear out any old values
    m_sQuery.Empty();
    m_sQueryFormat.Empty();
    m_bKeysOnly = false;
    m_AddKeys = true;
    m_csaPropertiesRequired.RemoveAll();
    if (m_pLevel1RPNExpression)
    {
        delete m_pLevel1RPNExpression;
        m_pLevel1RPNExpression = NULL;
    }
    if (m_IClass)
    {
        m_IClass->Release();
        m_IClass = NULL;
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : IsReference
 *
 *  DESCRIPTION : Determines whether the specified property is a reference
 *                property.
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
BOOL CFrameworkQuery::IsReference(
                                  
    LPCWSTR lpwszPropertyName
)
{
    BOOL bRet = FALSE;

    if (m_IClass != NULL)
    {
        CIMTYPE ctCimType;
        if (SUCCEEDED(m_IClass->Get(lpwszPropertyName, 0, NULL, &ctCimType, NULL)))
        {
            bRet = ctCimType == CIM_REFERENCE;
        }
    }

    return bRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetNamespace
 *
 *  DESCRIPTION : Determines whether the specified property is a reference
 *                property.
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
const CHString &CFrameworkQuery::GetNamespace()
{ 
    return m_sNamespace; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\frqueryex.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  FRQueryEx.cpp
//
//  Purpose: Extended query support functions
//
//***************************************************************************

#include "precomp.h"
#include <smartptr.h>
#include <analyser.h>
#include <FRQueryEx.h>
#include <assertbreak.h>
#include <utils.h>
#include "multiplat.h"

CFrameworkQueryEx::CFrameworkQueryEx()
{
}

CFrameworkQueryEx::~CFrameworkQueryEx()
{
}

// See comments in header
BOOL CFrameworkQueryEx::Is3TokenOR(LPCWSTR wszProp1, LPCWSTR wszProp2, VARIANT &vVar1, VARIANT &vVar2)
{
    BOOL bRet = FALSE;

    if ((m_pLevel1RPNExpression != NULL) &&
        (m_pLevel1RPNExpression->nNumTokens == 3) &&

        (m_pLevel1RPNExpression->pArrayOfTokens[2].nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_OR) &&

        (m_pLevel1RPNExpression->pArrayOfTokens[0].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION) &&
        (m_pLevel1RPNExpression->pArrayOfTokens[1].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION) &&

        (m_pLevel1RPNExpression->pArrayOfTokens[0].nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL) &&
        (m_pLevel1RPNExpression->pArrayOfTokens[1].nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)

        )

    {
        if (
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[0].pPropertyName, wszProp1) == 0) &&
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[1].pPropertyName, wszProp2) == 0))
        {
            VariantClear(&vVar1);
            VariantClear(&vVar2);

            if (FAILED(VariantCopy(&vVar1, &m_pLevel1RPNExpression->pArrayOfTokens[0].vConstValue)) ||
                FAILED(VariantCopy(&vVar2, &m_pLevel1RPNExpression->pArrayOfTokens[1].vConstValue)) )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            bRet = TRUE;
        }
        else if (
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[0].pPropertyName, wszProp2) == 0) &&
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[1].pPropertyName, wszProp1) == 0))
        {
            VariantClear(&vVar1);
            VariantClear(&vVar2);

            if (FAILED(VariantCopy(&vVar1, &m_pLevel1RPNExpression->pArrayOfTokens[1].vConstValue)) ||
                FAILED(VariantCopy(&vVar2, &m_pLevel1RPNExpression->pArrayOfTokens[0].vConstValue)) )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            bRet = TRUE;
        }
    }

    return bRet;

}

// See comments in header
BOOL CFrameworkQueryEx::IsNTokenAnd(CHStringArray &sarr, CHPtrArray &sPtrArr)
{
    BOOL bRet = FALSE;

    if (m_pLevel1RPNExpression != NULL)
    {
        // Walk all the tokens
        for (DWORD x = 0; x < m_pLevel1RPNExpression->nNumTokens; x++)
        {
            // If this is an expression token, and the expression is of type '='
            if ((m_pLevel1RPNExpression->pArrayOfTokens[x].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION) &&
                       (m_pLevel1RPNExpression->pArrayOfTokens[x].nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL))
            {
                // convert the property name to upper case.  This facilitates checking
                // to see if it is already in the list.
                _wcsupr(m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName);

                // Check to see if we have already seen this property.
                if (IsInList(sarr, m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName) == -1)
                {
                    // Add the name to the list
                    sarr.Add(m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName);

                    // Create a new variant for the value and add it to the list
                    LPVOID pValue = new variant_t(m_pLevel1RPNExpression->pArrayOfTokens[x].vConstValue);

                    try
                    {
                        sPtrArr.Add(pValue);
                    }
                    catch ( ... )
                    {
                        delete pValue;
                        sarr.RemoveAll();

                        DWORD dwSize = sPtrArr.GetSize();

                        for (x = 0; x < dwSize; x++)
                        {
                            delete sPtrArr[x];
                        }
                        sPtrArr.RemoveAll();

                        throw ;
                    }
                    bRet = TRUE;
                }
                else
                {
                    // Already in list
                    bRet = FALSE;
                    break;
                }

            }

            // It wasn't an expression token, if it's not AND, we've failed.
            else if (m_pLevel1RPNExpression->pArrayOfTokens[x].nTokenType != SQL_LEVEL_1_TOKEN::TOKEN_AND)
            {
                bRet = FALSE;
                break;
            }

        }

        // If this didn't work, let's clean the CHPtrArray and CHStringArray
        if (!bRet)
        {
            sarr.RemoveAll();
            DWORD dwSize = sPtrArr.GetSize();

            for (x = 0; x < dwSize; x++)
            {
                delete sPtrArr[x];
            }
            sPtrArr.RemoveAll();
        }
    }

    return bRet;
}

// see comments in header
HRESULT CFrameworkQueryEx::GetValuesForProp(LPCWSTR wszPropName, std::vector<int>& vectorValues)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_pLevel1RPNExpression != NULL)
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, vectorValues);

        if (SUCCEEDED(hr))
        {
            // Remove duplicates
            for (int x = 1; x < vectorValues.size(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (vectorValues[y] == vectorValues[x])
                    {
                        vectorValues.erase(vectorValues.begin() + x);
                        x--;
                    }
                }
            }
        }
        else
        {
            vectorValues.clear();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        ASSERT_BREAK(FALSE);

        vectorValues.clear();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// see comments in header
HRESULT CFrameworkQueryEx::GetValuesForProp(LPCWSTR wszPropName, std::vector<_variant_t>& vectorValues)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (wszPropName && (m_pLevel1RPNExpression != NULL))
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, vectorValues);

        if (SUCCEEDED(hr))
        {
            // If this is a reference property, we need to normalize the names to a common form
            // so the removal of duplicates works correctly.
            if (IsReference(wszPropName))
            {
                // Get the current computer name
                CHString sOutPath, sComputerName;
                DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;

                FRGetComputerName(sComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
                sComputerName.ReleaseBuffer();

                if (sComputerName.IsEmpty())
                {
                    sComputerName = L"DEFAULT";
                }

                DWORD dwRet = e_OK;

                // Normalize the path names.  Try leaving the property names alone
                for (int x = 0; x < vectorValues.size(); x++)
                {
                    // If we failed to parse the path, or if the namespace isn't our namespace, delete
                    // the entry.
                    if ( (V_VT(&vectorValues[x]) == VT_BSTR) &&
                         (dwRet = NormalizePath(V_BSTR(&vectorValues[x]), sComputerName, GetNamespace(), 0, sOutPath)) == e_OK)
                    {
                        vectorValues[x] = sOutPath;
                    }
                    else if (dwRet == e_NullName)
                    {
                        break;
                    }
                    else
                    {
                        vectorValues.erase(vectorValues.begin() + x);
                        x--;
                    }
                }

                // If the key property names of any of the values were null, we have to set them all
                // to null.
                if (dwRet == e_NullName)
                {
                    for (int x = 0; x < vectorValues.size(); x++)
                    {
                        // If we failed to parse the path, or if the namespace isn't our namespace, delete
                        // the entry.
                        if ( (V_VT(&vectorValues[x]) == VT_BSTR) &&
                             (dwRet = NormalizePath(V_BSTR(&vectorValues[x]), sComputerName, GetNamespace(), NORMALIZE_NULL, sOutPath)) == e_OK)
                        {
                            vectorValues[x] = sOutPath;
                        }
                        else
                        {
                            vectorValues.erase(vectorValues.begin() + x);
                            x--;
                        }
                    }
                }
            }

            // Remove duplicates
            for (int x = 1; x < vectorValues.size(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (vectorValues[y] == vectorValues[x])
                    {
                        vectorValues.erase(vectorValues.begin() + x);
                        x--;
                    }
                }
            }
        }
        else
        {
            vectorValues.clear();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        ASSERT_BREAK(FALSE);

        vectorValues.clear();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// See comments in header
void CFrameworkQueryEx::GetPropertyBitMask(const CHPtrArray &Properties, LPVOID pBits)
{
    if (AllPropertiesAreRequired())
    {
        SetAllBits(pBits, Properties.GetSize());
    }
    else
    {
        ZeroAllBits(pBits, Properties.GetSize());
        CHString sProperty;

        for (DWORD x=0; x < Properties.GetSize(); x++)
        {
            sProperty = (WCHAR *)Properties[x];
            sProperty.MakeUpper();

            if (IsInList(m_csaPropertiesRequired, sProperty) != -1)
            {
                SetBit(pBits, x);
            }
        }
    }
}

HRESULT CFrameworkQueryEx::InitEx(

        const BSTR bstrQueryFormat,
        const BSTR bstrQuery,
        long lFlags,
        CHString &sNamespace
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // parse the query using the parsing interface
    IWbemQueryPtr pQueryInterface(CLSID_WbemQuery);

    hr = pQueryInterface->Parse(bstrQueryFormat, bstrQuery, 0);

    if (SUCCEEDED(hr))
    {
        ULONG uFeatureCount = WMIQ_LF_LAST;
        ULONG uFeatures[WMIQ_LF_LAST];

        hr = pQueryInterface->TestLanguageFeatures(0, &uFeatureCount, uFeatures);

        if (SUCCEEDED(hr))
        {
            if (uFeatures[0] == WMIQ_LF1_BASIC_SELECT)
            {
                // if this is a nova compatible select statement
                hr = Init(bstrQueryFormat, bstrQuery, lFlags, sNamespace);
            }
            else if (uFeatures[0] == WMIQ_LF18_ASSOCIATONS)  // add others?
            {
                // Save the detailed query
                m_sQueryEx = bstrQuery;

                // create select statement from class name
                SWbemAssocQueryInf aqfBuff;
                hr = pQueryInterface->GetQueryInfo(WMIQ_ANALYSIS_ASSOC_QUERY, WMIQ_ASSOCQ_ASSOCIATORS, sizeof(aqfBuff), &aqfBuff);

                if (SUCCEEDED(hr))
                {
                    CHString sQuery;

                    // I don't know how to tell if this is an associators or a reference
                    if (true)
                    {
                        sQuery.Format(L"Select * from %s", aqfBuff.m_pszAssocClass);
                    }

                    // Store the more basic query
                    hr = Init(bstrQueryFormat, bstrQuery, lFlags, sNamespace);
                }
            }
            else
            {
                hr = WBEM_E_INVALID_QUERY;
            }
        }
    }

    return hr;
}

bool CFrameworkQueryEx::IsExtended()
{
    return !m_sQueryEx.IsEmpty();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\instance.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  Instance.CPP
//
//  Purpose: Implementation of CInstance class
//
//***************************************************************************

#include "precomp.h"

#include <BrodCast.h>
#include <assertbreak.h>
#include <stopwatch.h>
#include "FWStrings.h"

#define DEPRECATED 1

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance ctor
//
//
//
//  Inputs:     IWbemClassObject* - the class we want to wrap
//              MethodContext*    - since the context is shared, this will be addreffed
//  Outputs:
//
//  Return:
//
//  Comments:   pointers should not be NULL
//
////////////////////////////////////////////////////////////////////////
CInstance::CInstance(IWbemClassObject* piClassObject, MethodContext* pMethodContext)
:   m_nRefCount( 1 )
{
    ASSERT_BREAK(piClassObject  != NULL);
    ASSERT_BREAK(pMethodContext != NULL);

    // Both these values will be released in the destructor, so they both oughta
    // be AddRefed.  Note that they are

    m_piClassObject  = piClassObject;
    if ( NULL != piClassObject )
    {   // this, however, is a copy
        m_piClassObject->AddRef();
    }

    m_pMethodContext = pMethodContext;
    if (pMethodContext)
    {   // this, however, is a copy
        m_pMethodContext->AddRef();
    }
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance Dtor
//
//
//
//  Inputs:
//
//  Outputs:
//
//  Return:
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
CInstance::~CInstance()
{

    if ( NULL != m_piClassObject )
    {
        m_piClassObject->Release();
    }

    if ( NULL != m_pMethodContext )
    {
        m_pMethodContext->Release();
    }
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance::AddRef
//
//  Increments our reference count.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     New Reference Count.
//
//  Comments:   We may want to go to an Interlocked Inc/Dec model at
//              some point if Thread Safety on these objects becomes
//              an issue.
//
////////////////////////////////////////////////////////////////////////

LONG CInstance::AddRef( void )
{
    return InterlockedIncrement(&m_nRefCount);
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance::Release
//
//  Decrements our reference count.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     New Reference Count.
//
//  Comments:   Deletes the object when the ref count hits 0.  We may
//              want to go to an Interlocked Inc/Dec model at some
//              point if Thread Safety on these objects becomes an issue.
//
////////////////////////////////////////////////////////////////////////

LONG CInstance::Release( void )
{
    LONG   nRet = InterlockedDecrement(&m_nRefCount);

    ASSERT_BREAK(nRet >= 0);

    if ( 0 == nRet )
    {
        delete this;
    }
    else if (nRet < 0)
    {
        // Duplicate release.  Let's try to dump the stack
        DWORD t_stack[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#ifdef _X86_
        DWORD *dwEBP;

        _asm {
            mov dwEBP, ebp
        }

        dwEBP += 1;
        memcpy(&t_stack, dwEBP, sizeof(t_stack));
#endif

        CHString sMsg;
        sMsg.Format(L"Duplicate release: %08x %08x %08x %08x %08x %08x %08x %08x "
                                       L"%08x %08x %08x %08x %08x %08x %08x %08x "
                                       L"%08x %08x %08x %08x %08x %08x %08x %08x "
                                       L"%08x %08x %08x %08x %08x %08x %08x %08x ",
                    t_stack[0], t_stack[1], t_stack[2], t_stack[3], 
                    t_stack[4], t_stack[5], t_stack[6], t_stack[7],
                    t_stack[8], t_stack[9], t_stack[10], t_stack[11], 
                    t_stack[12], t_stack[13], t_stack[14], t_stack[15], 
                    t_stack[16], t_stack[17], t_stack[18], t_stack[19], 
                    t_stack[20], t_stack[21], t_stack[22], t_stack[23], 
                    t_stack[24], t_stack[25], t_stack[26], t_stack[27], 
                    t_stack[28], t_stack[29], t_stack[30], t_stack[31]
        );

        LogErrorMessage(sMsg);
    }

    return nRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Commit
//
//              returns this CInstance to CIMOM
//              will stuff it into the cache someday
//  Inputs:
//
//  Outputs:
//
//  Return:
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
HRESULT CInstance::Commit(void)
{
    return m_pMethodContext->Commit( this );
}

IWbemClassObject*   CInstance::GetClassObjectInterface()
{
    m_piClassObject->AddRef();

    return m_piClassObject;
}


// reference counting //

// string support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set
//
//
//
//  Inputs:     Name of property to set
//              string to be set
//
//  Outputs:
//
//  Return:     false if you try to set a property that is not a string type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetWCHARSplat( LPCWSTR name, LPCWSTR pStr)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v(pStr);

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETCHSTRING, name, hr);
        }
    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
	        LogError(IDS_NOCLASS, IDS_SETCHSTRING);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set
//
//
//
//  Inputs:     Name of property to set to VT_NULL
//
//  Outputs:
//
//  Return:     false if you try to set a property that is not a string type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetNull(LPCWSTR name)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        v.vt = VT_NULL ;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETCHSTRING, name, hr);
        }
    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETCHSTRING);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetStringArray
//
//
//
//  Inputs:     Name of property to set
//              string to be set
//
//  Outputs:
//
//  Return:     false if you try to set a property that is not a string array type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetStringArray(LPCWSTR name, const SAFEARRAY &strArray)
{

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        SAFEARRAY *t_SafeArray = NULL;
        HRESULT hr = SafeArrayCopy ( ( SAFEARRAY * ) & strArray , &t_SafeArray );

        if ( SUCCEEDED ( hr ) )
        {
            // Variant_t handles the VariantInit/VariantClear
            variant_t v;

            v.vt = VT_BSTR | VT_ARRAY ;
            v.parray = t_SafeArray ;

            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
            HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

            ASSERT_BREAK(SUCCEEDED(hr));

            bRet = (bool)SUCCEEDED(hr);

            if (!bRet)
            {
				dwLastErr = (hr);
                LogError(IDS_FAILED, IDS_SetStringArray, name, hr);
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SetStringArray);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SetStringArray);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (CHString)
//
//
//
//  Inputs:     Name of property to retrieve
//              CHString buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a string compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetCHString(LPCWSTR name, CHString& str) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_BSTR || v.vt == VT_NULL);
        
        ASSERT_BREAK(bSuccess);
        
        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                str = v.bstrVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETCHSTRING, name, hr);
        }
    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETCHSTRING);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetStringArray
//
//
//
//  Inputs:     Name of property to retrieve
//              SAFEARRAY *& strArray
//  Outputs:
//
//  Return:     false if you try to get a property that is not a string array compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetStringArray(LPCWSTR name,  SAFEARRAY *& strArray) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == (VT_BSTR|VT_ARRAY) || 
                            v.vt == VT_NULL);
        
        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == (VT_BSTR|VT_ARRAY)) && (v.parray != NULL ))
            {
                if ( SUCCEEDED ( SafeArrayCopy ( v.parray , ( SAFEARRAY ** ) &strArray ) ) )
                {
                    bRet = true ;
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GetStringArray, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GetStringArray);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GetStringArray);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

bool CInstance::GetWCHAR(LPCWSTR name,  WCHAR **pW) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_BSTR || v.vt == VT_NULL);
        
        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                size_t uLength = wcslen(v.bstrVal) + 1;
                
                *pW = (WCHAR *)malloc((uLength)*sizeof(WCHAR));
                if (*pW == NULL)
                {
                    VariantClear(&v);
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                StringCchCopyW( *pW, uLength, v.bstrVal );
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETCHSTRING, name, hr);
        }

    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETCHSTRING);
		}

    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

// WORD support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (WORD)
//
//
//
//  Inputs:     Name of property to set
//              WORD to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a WORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetWORD(LPCWSTR name,  WORD w)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name);
    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_I4;
        v.lVal = (long)w;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        VariantClear(&v);
        if (!bRet)
        {
			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETWORD, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (WORD)
//
//
//
//  Inputs:     Name of property to retrieve
//              WORD buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a WORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetWORD(LPCWSTR name,  WORD& w) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        CIMTYPE  vtType;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, &vtType, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && CIM_UINT16 == vtType;

        ASSERT_BREAK(bSuccess);
        
        if (SUCCEEDED(hr))
        {
            // the CIM type is important here
            if( (v.vt == VT_I4) && (CIM_UINT16 == vtType) )
            {
                w = (WORD)v.lVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETWORD, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

// DWORD support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (DWORD)
//
//
//
//  Inputs:     Name of property to set
//              DWORD to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a DWORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetDWORD(LPCWSTR name, DWORD d)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_I4;
        v.lVal = (long)d;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
		
		if (!bRet)
		{
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETDWORD, name, hr);
		}

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETDWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETDWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (DWORD)
//
//
//
//  Inputs:     Name of property to retrieve
//              DWORD buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a DWORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetDWORD(LPCWSTR name,  DWORD& d) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_I4 || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_I4)
            {
                d = (DWORD)v.lVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETDWORD, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETDWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETDWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

// DOUBLE support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (DOUBLE)
//
//
//
//  Inputs:     Name of property to set
//              DOUBLE to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a DOUBLE compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetDOUBLE(LPCWSTR name,  DOUBLE dub)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        V_R8(&v) = dub;
        V_VT(&v) = VT_R8;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        VariantClear(&v);

		if (!bRet)
		{
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETDOUBLE, name, hr);
		}
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETDOUBLE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETDOUBLE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (DOUBLE)
//
//
//
//  Inputs:     Name of property to retrieve
//              DOUBLE buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a DOUBLE compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetDOUBLE(LPCWSTR name,  DOUBLE& dub) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_R8 || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_R8)
            {
                dub = V_R8(&v);
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETDOUBLE, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETDOUBLE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETDOUBLE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (Byte)
//
//
//
//  Inputs:     Name of property to set
//              BYTE to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a BYTE compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetByte(LPCWSTR name,  BYTE b)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_UI1;
        v.bVal = (long)b ;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETBYTE, name, hr);
        }

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETBYTE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETBYTE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetEmbeddedObject
//
//
//
//  Inputs:     Name of property to set
//              CInstance to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a IUnknown compatible type
//
//  Comments:   CInstance is not released - responsibility of caller
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetEmbeddedObject(LPCWSTR name,  CInstance& cInstance )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        IWbemClassObject *t_ClassObject = cInstance.GetClassObjectInterface();
        if ( t_ClassObject )
        {
            variant_t v;

            v.vt   = VT_UNKNOWN;
            v.punkVal = t_ClassObject;

            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
            HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

            ASSERT_BREAK(SUCCEEDED(hr));
            bRet = (bool)SUCCEEDED(hr);

            if (!bRet)
            {
 				dwLastErr = (hr);
                LogError(IDS_FAILED, IDS_SetEmbeddedObject, name, hr);
            }
        }
		else
		{
			dwLastErr = (WBEM_E_FAILED);
		}
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SetEmbeddedObject);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SetEmbeddedObject);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (Byte)
//
//
//
//  Inputs:     Name of property to retrieve
//              BYTE buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a DWORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetByte(LPCWSTR name,  BYTE& b) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        CIMTYPE  vtType;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, &vtType, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && ((vtType == CIM_SINT8) || (vtType == CIM_UINT8));

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
          if( (v.vt == VT_UI1) && ( (vtType == CIM_SINT8) || (vtType == CIM_UINT8) ) )
            {
                b = v.bVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETBYTE, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETBYTE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETBYTE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetEmbeddedObject
//
//
//
//  Inputs:     Name of property to retrieve
//              reference to buffer hold pointer to new instance
//  Outputs:
//
//  Return:     false if you try to get a property that is not a object compatible type
//
//  Comments:   Creates CInstance, user is responsible for release
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetEmbeddedObject (LPCWSTR name, CInstance** pInstance,  MethodContext*  pMethodContext) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(m_piClassObject && (pInstance != NULL));

    if (m_piClassObject && name && (pInstance != NULL))
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_UNKNOWN || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_UNKNOWN)
            {
                IUnknown *t_Unknown = v.punkVal ;
                if ( t_Unknown )
                {
                    IWbemClassObject *t_Object = NULL;
                    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
                    HRESULT t_Result = t_Unknown->QueryInterface ( IID_IWbemClassObject , (void**) &t_Object ) ;
                    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

                    if ( SUCCEEDED ( t_Result ) )
                    {
                        *pInstance = new CInstance(t_Object, pMethodContext);
                        if (pInstance == NULL)
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        bRet = true ;
                    }
					else
					{
						dwLastErr = (t_Result);
					}

                }
				else
				{
					dwLastErr = (WBEM_S_NO_MORE_DATA);
				}
            }
			else
			{
				if (bSuccess)
				{
					dwLastErr = (WBEM_S_NO_MORE_DATA);
				}
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GetEmbeddedObject, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GetEmbeddedObject);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GetEmbeddedObject);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

// bool support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (bool)
//
//
//
//  Inputs:     Name of property to set
//              bool to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a bool compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::Setbool(LPCWSTR name,  bool b)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_BOOL;
        if (b)
        {
           v.boolVal = VARIANT_TRUE;
        }
        else
        {
           v.boolVal = VARIANT_FALSE;
        }

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));
        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETBOOL, name, hr);
        }

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETBOOL);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETBOOL);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (bool)
//
//
//
//  Inputs:     Name of property to retrieve
//              bool buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a bool compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::Getbool(LPCWSTR name,  bool&  b) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (v.vt == VT_BOOL || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_BOOL)
            {
                if (v.boolVal)
                {
                    b = true;
                }
                else
                {
                    b = false;
                }
                bRet = true;
                ASSERT_BREAK((v.boolVal == VARIANT_TRUE) || (v.boolVal == VARIANT_FALSE));
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETBOOL, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETBOOL);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETBOOL);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetVariant
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              const VARIANT&  variant - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied variant type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetVariant( LPCWSTR name,  const VARIANT& variant )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        HRESULT hr;

        // I realize the (VARIANT*) cast is ugly, as it is a const,
        // HOWEVER, somewhere nobody seems to understand why we would
        // possibly want to keep things const.  I could copy the VARIANT,
        // but that requires the same cast, so under duress, and to reduce
        // redundant code, I'm casting here.  Did I mention EXTREME
        // DURESS?

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        hr = m_piClassObject->Put(name, 0, (VARIANT*) &variant, NULL );
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETVARIANT, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETVARIANT);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETVARIANT);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetVariant
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              VARIANT&        variant - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied variant type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetVariant( LPCWSTR name,  VARIANT& variant ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &variant, NULL, NULL );
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETVARIANT, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETVARIANT);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETVARIANT);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetDateTime
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMTime& wbemtime - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied time type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetDateTime( LPCWSTR name,  const WBEMTime& wbemtime )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name && (wbemtime.IsOk()))
    {
		//GetDMTF may throw so get htis before modifying variant_t
		BSTR bstrTmp = wbemtime.GetDMTF(true);

        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        // Time is stored as a BSTR
        v.vt = VT_BSTR;
        v.bstrVal = bstrTmp;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr  = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETDATETIME, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETDATETIME);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETDATETIME);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetDateTime
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              WBEMTime&       wbemtime - Value to obtain from Name.
//
//  Outputs:
//
//  Return:     false if the supplied variant type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetDateTime( LPCWSTR name, WBEMTime& wbemtime ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        //
        // Get the name as a BSTR and pass it into the
        // wbemtime, which handles the conversion internally
        // like a good little class.
        //

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (v.vt == VT_BSTR || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                wbemtime = v.bstrVal;
                bRet = wbemtime.IsOk();

				if (!bRet)
				{
					dwLastErr = (WBEM_E_TYPE_MISMATCH);
				}
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETDATETIME, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETDATETIME);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETDATETIME);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetTimeSpan
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMTimeSpan& wbemtimespan - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied timespan type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::SetTimeSpan( LPCWSTR name,  const WBEMTimeSpan& wbemtimespan )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name && (wbemtimespan.IsOk()))
    {
		//GetBSTR may throw so get this before modifying variant_t
		BSTR bstrTmp = wbemtimespan.GetBSTR();

        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        // Time is stored as a BSTR
        v.vt = VT_BSTR;
        v.bstrVal = bstrTmp;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr  = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETTIMESPAN, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETTIMESPAN);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETTIMESPAN);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetTimeSpan
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              WBEMTimeSpan&   wbemtimespan - Value to obtain from Name.
//
//  Outputs:
//
//  Return:     false if the supplied timespan type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::GetTimeSpan( LPCWSTR name, WBEMTimeSpan& wbemtimespan ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        //
        // Get the name as a BSTR and pass it into the
        // wbemtimespan, which handles the conversion
        // internally like a good little class.
        //

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (v.vt == VT_BSTR || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                wbemtimespan = v.bstrVal;
                bRet = wbemtimespan.IsOk();
                // This is freed by the VariantClear
                //                      SysFreeString(v.bstrVal);

				if (!bRet)
				{
					dwLastErr = (WBEM_E_TYPE_MISMATCH);
				}
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETTIMESPAN, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETTIMESPAN);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETTIMESPAN);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetWBEMINT64
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMINT64&    wbemint64 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint64 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::SetWBEMINT64( LPCWSTR name,  const WBEMINT64& wbemint64 )
{
    // For right now, this is just a CHString.
    return SetWCHARSplat( name, wbemint64 );
}

bool CInstance::SetWBEMINT64( LPCWSTR name, const LONGLONG i64Value )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    WCHAR szBuff[33];

    _i64tow(i64Value, szBuff, 10);

    return SetWCHARSplat(name, szBuff);
}

bool CInstance::SetWBEMINT64( LPCWSTR name, const ULONGLONG i64Value )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    WCHAR szBuff[33];

    _ui64tow(i64Value, szBuff, 10);

    return SetWCHARSplat(name, szBuff);
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetWBEMINT64
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              WBEMINT64&          wbemint64 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint64 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::GetWBEMINT64( LPCWSTR name,  WBEMINT64& wbemint64 ) const
{
    // For right now, this is just a CHString.
    return GetCHString( name, wbemint64 );
}

bool CInstance::GetWBEMINT64( LPCWSTR name, LONGLONG& i64Value) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    CHString    s;
    bool        b = GetWBEMINT64(name, s);

	if (b)
		i64Value = _wtoi64(s);

    return b;
}

bool CInstance::GetWBEMINT64( LPCWSTR name, ULONGLONG& i64Value) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    CHString    s;
    bool        b = GetWBEMINT64(name, s);

	if (b)
		i64Value = _wtoi64(s);

    return b;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetWBEMINT16
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMINT16&    wbemint16 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint16 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::SetWBEMINT16( LPCWSTR name,  const WBEMINT16& wbemint16 )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_I2;
        v.iVal = wbemint16;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETWBEMINT16, name, hr);
        }

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETWBEMINT16);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETWBEMINT16);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetWBEMINT16
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              WBEMINT16&          wbemint16 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint16 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::GetWBEMINT16( LPCWSTR name,  WBEMINT16& wbemint16 ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        CIMTYPE  vtType;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, &vtType, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (CIM_SINT16 == vtType) && ((v.vt == VT_I2) || (v.vt == VT_NULL));

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((vtType == CIM_SINT16) && (v.vt == VT_I2))
            {
                wbemint16 = v.iVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETWBEMINT16, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETWBEMINT16);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETWBEMINT16);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   IsNull (LPCWSTR)
//
//  Inputs:     Name of property to check
//
//  Outputs:
//
//  Return:     true if VT_NULL or (VT_BSTR and *bstr == NULL)
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::IsNull(LPCWSTR name) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = true;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        if (SUCCEEDED(hr))
        {
            if (( v.vt != VT_NULL ) &&
                ( (v.vt != VT_BSTR) || (v.bstrVal != NULL) ))
            {
                bRet = false;
            }
            else
            {
                bRet = true;
            }
        }
        else
        {
            ASSERT_BREAK(0);
            LogError(IDS_FAILED, IDS_CINSTANCEISNULL, name, hr);
        }
    }
    else
    {
        ASSERT_BREAK(0);

        if (m_piClassObject)
		{
			LogError(IDS_InParam, IDS_CINSTANCEISNULL);
		}
		else
		{
			LogError(IDS_NOCLASS, IDS_CINSTANCEISNULL);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetStatus (LPCWSTR, bool&,VARTYPE &)
//
//
//
//  Inputs:     Name of property to check
//
//  Outputs:
//
//  Return:     true if succeeded, false otherwise
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetStatus (LPCWSTR name, bool &a_Exists , VARTYPE &a_VarType ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool t_Status = true ;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        if (SUCCEEDED(hr))
        {
            a_Exists = true ;
            a_VarType = v.vt ;
        }
        else
        {
            a_Exists = false ;
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
		}

        t_Status = false ;
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return t_Status ;
}

////////////////////////////////////////////////////////////////////////
MethodContext* CInstance::GetMethodContext() const
{
    return m_pMethodContext;
}

////////////////////////////////////////////////////////////////////////
void CInstance::LogError(LPCWSTR errorStr, LPCWSTR pFunctionName, LPCWSTR pArgs /*= NULL*/, HRESULT hError /*= -1*/) const
{
    if (IsErrorLoggingEnabled())
    {
        CHString className(IDS_UNKNOWNCLASS);
        // GetCHString("__NAME", className);
        // okay, I'm NOT going through GetCHString to get this
        // why? what happens if it fails? it tries to call this function...
        // can you say "stack overflow?"
        if (m_piClassObject)
        {
            // Variant_t handles the VariantInit/VariantClear
            variant_t v;

            HRESULT hr = m_piClassObject->Get(IDS_CLASS, 0, &v, NULL, NULL);

            ASSERT_BREAK((SUCCEEDED(hr)) && ((v.vt == VT_NULL) || (v.vt == VT_BSTR)));
            if (SUCCEEDED(hr))
            {
                if (    v.bstrVal   !=  NULL
                    &&  v.vt        !=  VT_NULL )
                {
                    className = v.bstrVal;
                }
            }
        }

        // intent is that the error string look like:
        //      ERROR CInstance(Win32_UnlogicalDisk)::SetDoohicky(argVal) thing broke! error code: 0xFF1234
        if (hError != -1)
        {
			if (pArgs == NULL)
			{
				LogErrorMessage6(L"%s%s)::%s %s error# %X", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, errorStr, hError);
			}
			else
			{
				LogErrorMessage7(L"%s%s)::%s(%s) %s error# %X", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, pArgs, errorStr, hError);
			}
        }
        else
        {
			if (pArgs == NULL)
			{
				LogErrorMessage5(L"%s%s)::%s %s", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, errorStr);
			}
			else
			{
				LogErrorMessage6(L"%s%s)::%s(%s) %s", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, pArgs, errorStr);
			}
        }
    }
}


bool CInstance::SetCHString(LPCWSTR name,  const CHString& str)
{
    return SetWCHARSplat(name, str);
}

bool CInstance::SetCHString(LPCWSTR name, LPCWSTR str)
{
    return SetWCHARSplat(name, str);
}

bool CInstance::SetCharSplat(LPCWSTR name,  LPCWSTR pStr)
{
    return SetWCHARSplat(name, pStr);
}

bool CInstance::SetCHString(LPCWSTR name, LPCSTR str)
{
    return SetWCHARSplat(name, CHString(str));
}

bool CInstance::SetCharSplat( LPCWSTR name,  LPCSTR pStr)
{
    return SetWCHARSplat(name, CHString(pStr));
}

bool CInstance::SetCharSplat(LPCWSTR name,  DWORD dwResID)
{
    ASSERT_BREAK(DEPRECATED);
	SetLastError(WBEM_E_NOT_SUPPORTED);

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\multiplat.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  MultiPlat.h
//
//  Purpose: Support routines for multiplatform support
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _MultiPlat_H_Included
#define _MultiPlat_H_Included

HMODULE FRGetModuleHandle(LPCWSTR wszModule);
DWORD FRGetModuleFileName(HMODULE hModule, LPWSTR lpwcsFileName, DWORD dwSize);
HINSTANCE FRLoadLibrary(LPCWSTR lpwcsLibFileName);
BOOL FRGetComputerName(LPWSTR lpwcsBuffer, LPDWORD nSize);
HANDLE FRCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitOwner, LPCWSTR lpwstrName);
DWORD FRExpandEnvironmentStrings(LPCWSTR wszSource, WCHAR *wszDest, DWORD dwSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\multiplat.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  MultiPlat.CPP
//
//  Purpose: Support routines for multiplatform support
//
//***************************************************************************

#include "precomp.h"
#include "multiplat.h"
#include "ImpersonateRevert.h"

#include <cnvmacros.h>

// smart pointers
#include <autoptr.h>

HMODULE FRGetModuleHandle(LPCWSTR wszModule)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return GetModuleHandleW(wszModule);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *szModule = NULL ;
        WCSTOANSISTRING(wszModule, szModule , t_ConversionFailure );
        if ( ! t_ConversionFailure )
        {
            if (szModule != NULL)
            {
                return GetModuleHandleA(szModule);
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }
    return 0; // To get rid of 64-bit compilation warning
}

DWORD FRGetModuleFileName(HMODULE hModule, LPWSTR lpwcsFileName, DWORD dwSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return GetModuleFileNameW(hModule, lpwcsFileName, dwSize);
    }
    else
    {
        char lpFileName[_MAX_PATH];

        DWORD dwRet = GetModuleFileNameA(hModule, lpFileName, dwSize);

        // If the call worked, convert the output string
        if (dwRet != 0)
        {
            bool t_ConversionFailure = false ;
            WCHAR *pName = NULL;
            ANSISTRINGTOWCS(lpFileName, pName, t_ConversionFailure );
            if ( ! t_ConversionFailure )
            {
                if ( pName ) 
                {
                    StringCchCopyW( lpwcsFileName, dwSize, pName );
                }   
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                return 0;
            }
        }

        return dwRet;

    }
}

HINSTANCE FRLoadLibrary(LPCWSTR lpwcsLibFileName)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return LoadLibraryW(lpwcsLibFileName);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *lpLibFileName = NULL ;
        WCSTOANSISTRING(lpwcsLibFileName, lpLibFileName, t_ConversionFailure );
        if ( ! t_ConversionFailure )
        {
            if (lpLibFileName != NULL)
            {
                return LoadLibraryA(lpLibFileName);
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }
    return 0; // To get rid of compilation warning
}

BOOL FRGetComputerName(LPWSTR lpwcsBuffer, LPDWORD nSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
		BOOL bResult = FALSE;
        if ( ( bResult = GetComputerNameW(lpwcsBuffer, nSize) ) == FALSE )
		{
			DWORD dwError = ::GetLastError ();
			if ( ERROR_ACCESS_DENIED == dwError )
			{
				// The GetComputer will need to be called in the process's context.
				ProviderImpersonationRevert ir;

				if ( ir.Reverted () )
				{
					bResult = GetComputerNameW(lpwcsBuffer, nSize);
				}
				else
				{
					// I was not impersonated or revert failed
					// that means call GetComputerName failed with process credentials already
					// or will fail as I'm not reverted

					::SetLastError ( dwError );
				}
			}
		}

		return bResult;
    }
    else
    {
        char  lpBuffer[_MAX_PATH];
        DWORD dwSize = *nSize;
        BOOL  bRet = GetComputerNameA(lpBuffer, nSize);

        // If the call worked
        if (bRet)
        {
            bool t_ConversionFailure = false ;
            WCHAR *pName = NULL ;
            ANSISTRINGTOWCS(lpBuffer, pName , t_ConversionFailure );
            if ( ! t_ConversionFailure )
            {
                if ( pName )
                {
                    StringCchCopyW( lpwcsBuffer, dwSize, pName );
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                return FALSE ;
            }
        }

        return bRet;

    }
}

HANDLE FRCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitOwner, LPCWSTR lpwstrName)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return CreateMutexW(lpMutexAttributes, bInitOwner, lpwstrName);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *lpName = NULL ;
        WCSTOANSISTRING(lpwstrName, lpName, t_ConversionFailure );
        if ( ! t_ConversionFailure ) 
        {
            if (lpName != NULL)
            {
                return CreateMutexA(lpMutexAttributes, bInitOwner, lpName);
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }
    return NULL; // To get rid of compilation warning
}

DWORD FRExpandEnvironmentStrings(LPCWSTR wszSource, WCHAR *wszDest, DWORD dwSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return ExpandEnvironmentStringsW(wszSource, wszDest, dwSize);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *szSource = NULL ;
        WCSTOANSISTRING(wszSource, szSource, t_ConversionFailure );
        if ( ! t_ConversionFailure ) 
        {
            if (szSource != NULL)
            {
                char *szDest = new char[dwSize];
                if (szDest != NULL)
                {
					wmilib::auto_buffer < char > smartszDest ( szDest ) ;

                    DWORD dwRet;
                        dwRet = ExpandEnvironmentStringsA(szSource, szDest, dwSize);

                    if ((dwRet <= dwSize) && (dwRet != 0))
                    {
                        bool t_ConversionFailure = false ;
                        WCHAR *pName = NULL;
                        ANSISTRINGTOWCS(szDest, pName, t_ConversionFailure );
                        if ( ! t_ConversionFailure )
                        {
                            if ( pName ) 
                            {
                                StringCchCopyW( wszDest, dwSize, pName );
                            }   
                            else
                            {
                                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                            }
                        }
                        else
                        {
                            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                            return 0;
                        }
                    }
                    return dwRet;

                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }

    return NULL; // To get rid of compilation warning
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\methodcontext.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  MethodContext.cpp
//
//  Purpose: Internal and External Method context classes
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <stopwatch.h>
#include <smartptr.h>

//
// neccessary for smart deletion
//

class CThreadBase ;
typedef void ( CThreadBase:: * TBC ) ( void ) ;

MethodContext::MethodContext(IWbemContext   __RPC_FAR *piContext, CWbemProviderGlue *pGlue):
m_pStatusObject(NULL),
m_pContext(NULL)
{
#ifdef PROVIDER_INSTRUMENTATION
    pStopWatch = NULL;
#endif

    m_pGlue = pGlue;

    if (piContext)
    {
        piContext->AddRef();
    }
    m_pContext = piContext;
}

MethodContext::~MethodContext()
{
    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::WinMgmtTimer);
    if (m_pContext)
    {
        m_pContext->Release();
    }

    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::FrameworkTimer);

    if (m_pStatusObject)
    {
        m_pStatusObject->Release();
    }
}

// might be NULL
IWbemContext __RPC_FAR *MethodContext::GetIWBEMContext()
{
    IWbemContext __RPC_FAR *pContext = NULL;

    BeginWrite();

	if (pContext = m_pContext)
	{
		m_pContext->AddRef();
	}
    EndWrite();

    return pContext;
}

LONG MethodContext::AddRef(void)
{
    return CThreadBase::AddRef();
}

LONG MethodContext::Release(void)
{
    return CThreadBase::Release();
}

CWbemProviderGlue *MethodContext::GetProviderGlue()
{
    return m_pGlue;
}

// returns false if the object has already been set
bool MethodContext::SetStatusObject(IWbemClassObject __RPC_FAR *pObj)
{
    BeginWrite();

    bool bRet;
    if (bRet = (m_pStatusObject == NULL))
    {
        m_pStatusObject = pObj;
        pObj->AddRef();
    }
    EndWrite();
    ASSERT_BREAK(bRet);
    return bRet;
}


IWbemClassObject __RPC_FAR *MethodContext::GetStatusObject()
{
    IWbemClassObject __RPC_FAR *pOut = NULL;

    BeginWrite();

    if (pOut = m_pStatusObject)
    {
        pOut->AddRef();
    }
    EndWrite();
    return pOut;
}

// Not meaningful unless we are at a ExternalMethodContext object
void MethodContext::QueryPostProcess(void)
{
}

//------------------------------------------------------------------------------------------
ExternalMethodContext::ExternalMethodContext(IWbemObjectSink __RPC_FAR *pResponseHandler,
                                             IWbemContext    __RPC_FAR *pContext,
                                             CWbemProviderGlue *pGlue,
                                             void                      *pReserved
                                              ) : MethodContext(pContext, pGlue)
{

    pResponseHandler->AddRef();
    m_pResponseHandler = pResponseHandler;
    m_pReserved   = pReserved ;
}

LONG ExternalMethodContext::AddRef(void)
{
    m_pResponseHandler->AddRef();
    return MethodContext::AddRef();
}

LONG ExternalMethodContext::Release(void)
{
    m_pResponseHandler->Release();
    return MethodContext::Release();
}

HRESULT ExternalMethodContext::Commit(CInstance *pInstance)
{
    HRESULT hRes = WBEM_E_FAILED;
    IWbemClassObjectPtr p (pInstance->GetClassObjectInterface(), false);
    IWbemClassObject *p2 = (IWbemClassObject *)p;
    
    if (p != NULL)
    {
        PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::WinMgmtTimer);
        hRes = m_pResponseHandler->Indicate(1, &p2);
        PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::ProviderTimer);
    }
    
    return hRes;
}

// Call this function to let cimom know that it will have to re-process
// the instances after it gets them back.  Otherwise it assumes that
// the query has been fully processed by the provider.  Most (all?) providers
// should call this function.
void ExternalMethodContext::QueryPostProcess(void)
{
    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::WinMgmtTimer);
    m_pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, 0, NULL, NULL);
    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::FrameworkTimer);
}

//------------------------------------------------------------------------------------------
InternalMethodContext::InternalMethodContext( TRefPointerCollection<CInstance> *pList ,
                                             IWbemContext    __RPC_FAR *pContext,
                                             CWbemProviderGlue *pGlue) : MethodContext(pContext, pGlue)
{
    // A NULL List only means we really won't be doing anything when we
    // are told to commit.  Otherwise, we will store an instance pointer
    // in the supplied list.

    if ( NULL != pList )
    {
        pList->AddRef();
    }

    m_pInstances = pList;
}

InternalMethodContext::~InternalMethodContext( void )
{
}

LONG InternalMethodContext::AddRef(void)
{
    if ( NULL != m_pInstances )
    {
        m_pInstances->AddRef();
    }

    return MethodContext::AddRef();
}

LONG InternalMethodContext::Release(void)
{
    if ( NULL != m_pInstances )
    {
        m_pInstances->Release();
    }

    return MethodContext::Release();
}


HRESULT InternalMethodContext::Commit(CInstance *pInstance)
{
    HRESULT hr = WBEM_S_NO_ERROR;
   
   if ( NULL != m_pInstances )
    {
      if (!m_pInstances->Add(pInstance)) {
         hr = WBEM_E_FAILED;
      }
    }

   return hr;
}

//========================================================================

InternalMethodContextAsynch::InternalMethodContextAsynch(Provider *pThat,
                                LPProviderInstanceCallback pCallback,
                                IWbemContext __RPC_FAR *pContext,
                                MethodContext *pUsersContext,
                                void *pUserData
                                )  : MethodContext(pContext, pUsersContext->GetProviderGlue())
{
    ASSERT_BREAK(pThat != NULL);
    ASSERT_BREAK(pCallback != NULL);
    
    m_pThat     = pThat;
    m_pCallback = pCallback;
    m_pUserData = pUserData;
    m_pUsersContext = pUsersContext;

    if ( NULL != m_pThat )
    {
        m_pThat->AddRef();
    }

    if (NULL != m_pUsersContext)
    {
        m_pUsersContext->AddRef();
    }
}

InternalMethodContextAsynch::~InternalMethodContextAsynch()
{
}

HRESULT InternalMethodContextAsynch::Commit(CInstance *pInstance)
{
    return (*m_pCallback)(m_pThat, pInstance, m_pUsersContext, m_pUserData);
}

LONG InternalMethodContextAsynch::AddRef(void)
{
    if ( NULL != m_pThat )
    {
        m_pThat->AddRef();
    }

    if (NULL != m_pUsersContext)
    {
        m_pUsersContext->AddRef();
    }

    return MethodContext::AddRef();
}

LONG InternalMethodContextAsynch::Release(void)
{
    if ( NULL != m_pThat )
    {
        m_pThat->Release();
    }

    if (NULL != m_pUsersContext)
    {
        m_pUsersContext->Release();
    }

    return MethodContext::Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\objpath.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include <autoptr.h>

//
// This inline is to substitute the following macro
//
// #define Macro_CloneLPWSTR(x) \
//     (x ? wcscpy(new wchar_t[wcslen(x) + 1], x) : 0)
//

inline LPWSTR Inline_CloneLPCWSTR( LPCWSTR lpwszToBeCloned )
{
    if ( NULL == lpwszToBeCloned )
    {
        return NULL;
    }

    size_t  uLength = wcslen( lpwszToBeCloned ) + 1;
    wchar_t *pNew = new wchar_t[ uLength ];
    
    if ( NULL == pNew )
    {
        return NULL;
    }

    StringCchCopyW( pNew, uLength, lpwszToBeCloned );

    return pNew;
}

ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
        m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    delete m_pServer;
    for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        delete m_paNamespaces[dwIx];
    delete m_paNamespaces;
    delete m_pClass;

    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        delete m_paKeys[dwIx];
    delete m_paKeys;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    delete [] m_pClass;
    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Inline_CloneLPCWSTR(wszClassName);
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces++] = Inline_CloneLPCWSTR(wszNamespace);

    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        if ( VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue ) == E_OUTOFMEMORY )
		{
			throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                size_t uLength = wcslen ( wszKeyName ) + 1;
                
                m_paKeys [ dwIndex ]->m_pName = new wchar_t[ uLength ];
                if ( NULL == m_paKeys [ dwIndex ]->m_pName )
                {
				    throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                }
                
                StringCchCopyW ( m_paKeys [ dwIndex ]->m_pName, uLength, wszKeyName );
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            if ( VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ), ( VARIANT * ) pvValue ) == E_OUTOFMEMORY )
			{
				throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                size_t uLength = wcslen ( wszKeyName ) + 1;
                
                m_paKeys [ 0 ]->m_pName = new wchar_t [ uLength ] ;
                if ( NULL == m_paKeys [ 0 ]->m_pName )
                {
				    throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                }
                
                StringCchCopyW ( m_paKeys [ 0 ]->m_pName, uLength, wszKeyName ) ;

                if ( VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ), ( VARIANT * ) pvValue ) == E_OUTOFMEMORY )
				{
					throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Inline_CloneLPCWSTR(wszKeyName);
    VariantInit(&m_vValue);
    if ( VariantCopy(&m_vValue, (VARIANT*)pvValue) == E_OUTOFMEMORY )
	{
		throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}
}

KeyRef::~KeyRef()
{
    delete m_pName;
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];
    
    StringCchCopyW( wszPath, nSpace, pInput->m_pClass );

    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
            {
                StringCchCatW(wszPath, nSpace, L".");
            }
        }
        else
        {
            StringCchCatW(wszPath, nSpace, L",");
        }
        
        if(pKey->m_pName)
        {
            StringCchCatW(wszPath, nSpace, pKey->m_pName);
        }
        
        StringCchCatW(wszPath, nSpace, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            StringCchCatW(wszPath, nSpace, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    StringCchCatW(wszPath, nSpace, L"\\");
                }
                str[0] = *pwc;
                StringCchCatW(wszPath, nSpace, str);
                pwc++;
            }

            StringCchCatW(wszPath, nSpace, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            StringCchPrintfW(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), 
                             L"%d", V_I4(&pKey->m_vValue));
            StringCchCatW(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            StringCchPrintfW(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), 
                             L"%u", V_UI4(&pKey->m_vValue));
            StringCchCatW(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            StringCchPrintfW(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), 
                             L"%hd", V_I2(&pKey->m_vValue));
            StringCchCatW(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            StringCchPrintfW(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), 
                             L"%hu", V_UI2(&pKey->m_vValue));
            StringCchCatW(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            StringCchPrintfW(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), 
                             L"%d", V_I1(&pKey->m_vValue));
            StringCchCatW(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            StringCchPrintfW(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), 
                             L"%u", V_UI1(&pKey->m_vValue));
            StringCchCatW(wszPath, nSpace, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        StringCchCatW(wszPath, nSpace, L"=@");

    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

	m_pOutput = new ParsedObjectPath;
	wmilib::auto_ptr < ParsedObjectPath > smartOutput ( m_pOutput ) ;
       CNullMe<ParsedObjectPath> NullMe(m_pOutput);

	// Parse the server name (if there is one) manually
	// ================================================

	if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
			(pRawPath[0] == '/' && pRawPath[1] == '/'))
	{
		const WCHAR* pwcStart = pRawPath + 2;

		// Find the next backslash --- it's the end of the server name
		// ===========================================================

		const WCHAR* pwcEnd = pwcStart;
		while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
		{
			pwcEnd++;
		}

		if (*pwcEnd == L'\0')
		{
			// If we have already exhausted the object path string,
			// a lone server name was all there was.
			// ====================================================

			if (m_eFlags != e_ParserAcceptAll)
			{
				return SyntaxError;
			}
			else    // A lone server name is legal.
			{
				size_t uLength = wcslen(pwcStart)+1;
				
				m_pOutput->m_pServer = new WCHAR[uLength];
				StringCchCopyW(m_pOutput->m_pServer, uLength, pwcStart);

				NullMe.dismiss();
				*pOutput = smartOutput.release();
				
				return NoError;
			}
		}

		if (pwcEnd == pwcStart)
		{
			// No name at all.
			// ===============
			return SyntaxError;
		}

		m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
		wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
		m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

		pRawPath = pwcEnd;
	}

	// Point the lexer at the source.
	// ==============================

	CTextLexSource src(pRawPath);
	m_pLexer = new CGenLexer(OPath_LexTable, &src);

	// Go.
	// ===

	int nRes = begin_parse();
	if (nRes)
	{
		return nRes;
	}

	if (m_nCurrentToken != OPATH_TOK_EOF)
	{
		return SyntaxError;
	}

	if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
	{
		if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
		{
			return SyntaxError;
		}
		else
		{
			// Local namespace --- set server to "."
			// =====================================
			m_pOutput->m_pServer = new WCHAR[2];
			StringCchCopyW(m_pOutput->m_pServer, 2, L".");
		}
	}

	// Sort the key refs lexically. If there is only
	// one key, there is nothing to sort anyway.
	// =============================================

	if (m_pOutput->m_dwNumKeys > 1)
	{
		BOOL bChanges = TRUE;
		while (bChanges)
		{
			bChanges = FALSE;
			for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
			{
				if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
					m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
				{
					KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
					m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
					m_pOutput->m_paKeys[dwIx + 1] = pTmp;
					bChanges = TRUE;
				}
			}
		}
	}


	// Add in key refs.
	// ================
    NullMe.dismiss();
    *pOutput = smartOutput.release();


    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Inline_CloneLPCWSTR(m_pLexer->GetTokenText());
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Inline_CloneLPCWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Inline_CloneLPCWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef;
        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());

		if ( ! V_BSTR(&m_pTmpKeyRef->m_vValue) )
		{
			throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        StringCchPrintfA(buf, sizeof(buf)/sizeof(buf[0]), "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        StringCchPrintfA(buf, sizeof(buf)/sizeof(buf[0]), "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Inline_CloneLPCWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        size_t uLength = wcslen(m_pClass) + 1;
        LPWSTR pTmp = new wchar_t[uLength];
        StringCchCopyW(pTmp, uLength, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            StringCchCatW(pRetVal, nSpace, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                StringCchCatW(pRetVal, nSpace, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                StringCchPrintfW(Tmp, sizeof(Tmp)/sizeof(Tmp[0]), L"%d", nVal);
                StringCchCatW(pRetVal, nSpace, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                StringCchPrintfW(Tmp, sizeof(Tmp)/sizeof(Tmp[0]), L"%d", nVal);
                StringCchCatW(pRetVal, nSpace, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                StringCchPrintfW(Tmp, sizeof(Tmp)/sizeof(Tmp[0]), L"%d", nVal);
                StringCchCatW(pRetVal, nSpace, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                StringCchPrintfW(Tmp, sizeof(Tmp)/sizeof(Tmp[0]), L"%d", (nVal?1:0));
                StringCchCatW(pRetVal, nSpace, Tmp);
                break;

            default:
                StringCchCatW(pRetVal, nSpace, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            StringCchCopyW(pRetVal, nSpace, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) StringCchCatW(wszOut, nSpace + 1, L"\\");
        StringCchCatW(wszOut, nSpace + 1, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) StringCchCatW(wszOut, nSpace + 1, L"\\");
        StringCchCatW(wszOut, nSpace + 1, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    size_t uLength = wcslen(wszNamespace) + 1;
    LPWSTR wszCopy = new wchar_t[uLength];
    StringCchCopyW(wszCopy, uLength, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;

    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\opathlex.cpp ===
/*++



Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\objpath.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <opathlex.h>
#include <Polarity.h>

#define DELETE_ME

struct POLARITY KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
};

template <typename T>
class CNullMe
{
private:
	    T * & p_;
	    bool dismiss_;
public:
	     CNullMe(T * & p):p_(p),dismiss_(false){};
	     void dismiss(){ dismiss_ = true; };
	     ~CNullMe(){ if (!dismiss_) p_ = NULL; };
}; 

struct POLARITY ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class POLARITY CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\opathlex.h ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    OPATHLEX.H

Abstract:

    Object Path DFA Tokens

History:

--*/

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\precomp.h ===
#include <fwcommon.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\stllock.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  StlLock.cpp
//
//  Purpose: implements the STL lockit class to avoid linking to msvcprt.dll
//
//***************************************************************************

#include "precomp.h"
#include <stllock.h>

__declspec(dllexport) CCritSec g_cs;

std::_Lockit::_Lockit()
{
    g_cs.Enter();
}

std::_Lockit::~_Lockit()
{
    g_cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\sources.inc ===
############################################################################
#
#   Copyright  Microsoft Corporation.  All rights reserved.
#
############################################################################

WMIUNICODE=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

FRAMEDYN_INC=$(SDK)\FrameDyn\Include

TARGETPATH=obj
TARGETTYPE=DYNLINK

PRECOMPILED_OBJ=preframe.obj

TARGETLIBS= \
	$(COMMON_NEWTHROW_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
\
#FOR CloseProfileUserMapping...
\
	$(SDK_LIB_PATH)\kernl32p.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\Secur32.lib \

INCLUDES=$(INCLUDES); \
	$(COMMON_NEWTHROW_INC); \
	$(WMIIDL_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(FRAMEDYN_PRIVATE); \
	$(FRAMEDYN_INC);\
\
#FOR CloseProfileUserMapping...
\
	$(BASE_INC_PATH);

SOURCES= \
	..\stllock.cpp \
	..\brodcast.cpp \
	..\clsfctry.cpp \
	..\createmutexasprocess.cpp \
	..\EventProvider.cpp \
	..\FRQuery.cpp \
	..\FRQueryEx.cpp \
	..\FWStrings.cpp \
	..\Instance.cpp \
	..\MethodContext.cpp \
	..\MultiPlat.cpp \
	..\Provider.cpp \
	..\RunDLL.cpp \
	..\ThreadBase.cpp \
	..\Wbemglue.cpp \
	..\objpath.cpp \
	..\genlex.cpp \
	..\opathlex.cpp \
	..\winmsgevent.cpp

C_DEFINES=$(C_DEFINES) /DUSE_POLARITY /DBUILDING_DLL /D_WINDLL /D_WIN32_DCOM /DFRAMEWORK_ALLOW_DEPRECATED=0
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
USE_RTTI=1
USE_STL=1
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup

DLLDEF=$(O)\$(TARGETNAME).def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\rundll.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  RunDll.cpp
//
//  Purpose: Allow framework to be used to run a command
//
//***************************************************************************

#include "precomp.h"
#include "multiplat.h"

// This routine is meant to be called from RUNDLL32.EXE
extern "C" {
__declspec(dllexport) VOID CALLBACK
DoCmd(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{

    DWORD dwRet = ERROR_INVALID_FUNCTION;
    BOOL bRet = FALSE;

    DWORD dwFlags = 0L ;
	DWORD dwReserved = 0L ;

	CHString CmdLine ( lpszCmdLine ) ;
	CHString Buff ;
	CHString Args ;

    // Parse the passed in command line to figure out what command we
    // are being asked to run.

	DWORD dwIndex = CmdLine.Find ( L" " ) ;
    Buff = CmdLine.Left ( dwIndex ) ;
	Args = CmdLine.Mid ( dwIndex + 1 ) ;

	CHString sFlags ;
	CHString sReserved ;

	// Parse out the parameters for this command
	dwIndex = Args.Find ( L" " ) ;
	if ( dwIndex )
	{
		sFlags = Args.Left ( dwIndex ) ;
		sReserved = Args.Mid ( dwIndex + 1 ) ;
	}
	else
	{
		sFlags = Args ;
	}

	dwFlags = _wtoi ( sFlags ) ;
	dwReserved = _wtoi ( sReserved ) ;

    // Find out which command
    if ( Buff.CompareNoCase ( L"ExitWindowsEx" ) == 0 ) 
    {
        // Clear the error (it appears ExitWindowsEx doesn't always clear old data)
        SetLastError(0);

        bRet = ExitWindowsEx(dwFlags, dwReserved);
        dwRet = GetLastError();
    }
    else if ( Buff.CompareNoCase ( L"InitiateSystemShutdown" ) == 0 ) 
    {
        // Parse out the parameters for this command
        bool bRebootAfterShutdown = false;
        bool bForceShutDown = false;

        // Clear the error (it appears ExitWindowsEx doesn't always clear old data)
        SetLastError(0);

        if(dwFlags & EWX_REBOOT)
        {
			bRebootAfterShutdown = true;
        }
		if( dwFlags & EWX_FORCE)
		{
            bForceShutDown = true;
        }

        WCHAR wstrComputerName[MAX_COMPUTERNAME_LENGTH + 1] = { '\0' };
        DWORD dwSize;

        if(FRGetComputerName(wstrComputerName, &dwSize))
        {

            bRet = InitiateSystemShutdown(
                wstrComputerName, 
                NULL, 
                0 /* dwTimeout */, 
                (bForceShutDown)? TRUE:FALSE, 
                (bRebootAfterShutdown)? TRUE:FALSE );

            dwRet = GetLastError();
        }
        else
        {
            dwRet = GetLastError();
        }
    }

    // NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 
    //
    // We are aborting out at this point, since RunDLL32 in its finite wisdom doesn't allow
    // for the setting of the dos error level (who designs this stuff?).
    if (!bRet)
    {
        ExitProcess(dwRet);
    }
}
} //extern
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\provider.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  Provider.CPP
//
//  Purpose: Implementation of Provider class
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <objpath.h>
#include <cominit.h>
#include <brodcast.h>
#include <createmutexasprocess.h>
#include <stopwatch.h>
#include <SmartPtr.h>
#include <frqueryex.h>
#include "FWStrings.h"
#include "MultiPlat.h"

#include <helper.h>

// Must instantiate static members
CHString Provider::s_strComputerName;

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider ctor
//
//  
//
//  Inputs:     name of this provider
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   suggest that derived classes implement their provider's ctor thusly:
//
//                  MyProvider::MyProvider(const CHString& setName) : 
//                      Provider(setName)
//
//  that way, a *further* derived class can specify its own name
//  
//
////////////////////////////////////////////////////////////////////////
Provider::Provider( LPCWSTR a_setName, LPCWSTR a_pszNameSpace /*=NULL*/ )
:   CThreadBase(),
    m_pIMosProvider( NULL ),
    m_piClassObject( NULL ),
    m_name( a_setName ),
    m_strNameSpace( a_pszNameSpace )
{
    // Initialize the computer name, then register with the framework.

    InitComputerName();

    CWbemProviderGlue::FrameworkLogin( a_setName, this, a_pszNameSpace );

}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider dtor
//
//  
//
//  Inputs:     none.
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   cleans up our pointer to the IMosProvider
//
////////////////////////////////////////////////////////////////////////
Provider::~Provider( void )
{
    // get out of the framework's hair
    CWbemProviderGlue::FrameworkLogoff( (LPCWSTR)m_name, (LPCWSTR)m_strNameSpace );
    
    // we can't release the interfaces here because CIMOM has a habit
    // of shutting down when it still has interface pointers open.
    /********************
    // Release the pointer returned to us by GetNamespaceConnection(), which 
    // will return us an AddRefed pointer.

    if ( NULL != m_pIMosProvider )
    {
        m_pIMosProvider->Release();
    }

    // The class object is returned to us by IMOSProvider::GetObject, so
    // we should try to release it here when we're done with it.

    if ( NULL != m_piClassObject )
    {
        m_piClassObject->Release();
    }
    ******************************/
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider::InitComputerName
//
//  Initializes our static computer name variable.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Because the idea behind creating providers is that
//              a single static instance is instantiated, this function
//              will most likely be called as part of DLL loading, we'll
//              introduce some thread safety here using a named mutex
//              but won't worry too much about it other than that.
//
////////////////////////////////////////////////////////////////////////
void Provider::InitComputerName( void )
{
    // For performance, check if the value is empty.  Only if it
    // is, should we then bother with going through a thread-safe
    // static initialization.  Because we are using a named mutex,
    // multiple threads will get the same kernel object, and will
    // be stop-gapped by the OS as they each acquire the mutex
    // in turn.

    if ( s_strComputerName.IsEmpty() )
    {
        CreateMutexAsProcess createMutexAsProcess(WBEMPROVIDERSTATICMUTEX);

        // Double check in case there was a conflict and somebody else
        // got here first.

        if ( s_strComputerName.IsEmpty() )
        {
            DWORD   dwBuffSize = MAX_COMPUTERNAME_LENGTH + 1;

            // Make sure the string buffer will be big enough to handle the
            // value.

            LPWSTR  pszBuffer = s_strComputerName.GetBuffer( dwBuffSize );

            if ( NULL != pszBuffer )
            {
                // Now grab the computer name and release the buffer, forcing
                // it to reallocate itself to the new length.

                if (!FRGetComputerName( pszBuffer, &dwBuffSize )) {
                    StringCchCopyW( pszBuffer, MAX_COMPUTERNAME_LENGTH + 1, L"DEFAULT" );
                }
                s_strComputerName.ReleaseBuffer();
            }   // IF NULL != pszBuffer

        }   // IF strComputerName.IsEmpty()

    }   // IF strComputerName.IsEmpty()

}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Flush
//
//  flushes out all unnecessary memory usage
//  inlcuding the (unimplemented) cache
//  and the class object we clone from
//
//  Inputs:     nope
//
//  Outputs:    
//
//  Return:     the eternal void
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
void Provider::Flush()
{
    // TODO: implement cache flush
    BeginWrite();

    if (m_piClassObject)
    {
        m_piClassObject->Release();
        m_piClassObject = NULL;
    }

    if ( NULL != m_pIMosProvider )
    {
        m_pIMosProvider->Release();
        m_pIMosProvider = NULL;
    }
    EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ValidateIMOSPointer
//
//  Verifies in a threadsafe manner, that our IWBEMServices pointer
//  is okay.
//
//  Inputs:     None.
//
//  Outputs:    
//
//  Return:     TRUE/FALSE      success/failure
//
//  Comments:   Requires that our NameSpace be valid.
//
////////////////////////////////////////////////////////////////////////

BOOL Provider::ValidateIMOSPointer( )
{
    return TRUE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CreateNewInstance
//
//  
//
//  Inputs:     MethodContext* - context that this instance belongs to
//
//  Outputs:    
//
//  Return:     CInstance*
//
//  Comments:   caller is responsible for memory
//
////////////////////////////////////////////////////////////////////////
CInstance* Provider::CreateNewInstance( MethodContext*  pMethodContext )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CInstance* pNewInstance = NULL;
    IWbemClassObjectPtr pClassObject (GetClassObjectInterface(pMethodContext), false);

    IWbemClassObjectPtr piClone;
    hr = pClassObject->SpawnInstance(0, &piClone);
    if (SUCCEEDED(hr))
    {
        // The Instance is responsible for its own AddRef/Releasing
        pNewInstance = new CInstance(piClone, pMethodContext);

        if (pNewInstance == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }
    else
    {
        throw CFramework_Exception(L"SpawnInstance failed", hr);
    }

    
    return pNewInstance;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Commit
//
//  sends instance to CIMOM
//
//  Inputs:     CInstance* pInstance - the instance to pass off to cimom, 
//              bool bCache - should we cache this puppy? (unimplemented)
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   do not reference pointer once committed, it may not exist any more!
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::Commit(CInstance* pInstance, bool bCache /* = false*/)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // allow derived classes to fill out extra info.
//    GetExtendedProperties(pInstance);
    hRes = pInstance->Commit();

    // TODO: Implement cache
    // if !bCache...

    // We're done with pInstance, so...
    pInstance->Release();

   return hRes;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ExecuteQuery
//
//  
//
//  Inputs:     IWbemContext __RPC_FAR *    pCtx,
//
//  Outputs:    
//
//  Return:     HRESULT
//
//  Comments:   Calls a provider's ExecQuery function, or returns
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::ExecuteQuery( MethodContext* pContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = ValidateQueryFlags(lFlags);
    
    // Make sure we've got Managed Object Services avaliable, as we will need
    // it to get WBEMClassObjects for constructing Instances.
    
    if ( SUCCEEDED(hr) && ValidateIMOSPointer( ) )
    {
        // Check to see if this is an extended query
        CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
        if (pQuery2->IsExtended())
        {
            // It is an extended query.  Does the provider support them?
            if (FAILED(ValidateQueryFlags(WBEM_FLAG_FORWARD_ONLY)))
            {
                // We have an extended query, but the provider doesn't support it
                hr = WBEM_E_INVALID_QUERY;
            }
        }

        if (SUCCEEDED(hr))
        {    
            // Tell cimom he's got work to do on the instances when we send
            // them back.
            pContext->QueryPostProcess();
        
            // If the client hasn't overridden the class, we get back 
            // WBEM_E_PROVIDER_NOT_CAPABLE.  In that case, call the enumerate, and let
            // CIMOM do the work
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
            hr = ExecQuery(pContext, pQuery, lFlags);
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
        
            if (hr == WBEM_E_PROVIDER_NOT_CAPABLE) 
            {
                // Get the instances
                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
                hr = CreateInstanceEnum(pContext, lFlags);
                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
            }
        }
        else
        {
            hr = WBEM_E_INVALID_QUERY;
        }
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CreateInstanceEnum
//
//  
//
//  Inputs:     IWbemContext __RPC_FAR *    pCtx,
//              IWbemObjectSink __RPC_FAR * pResponseHandler
//  Outputs:    
//
//  Return:     
//
//  Comments:   enumerate all instances of this class
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::CreateInstanceEnum( MethodContext*    pContext, long lFlags /*= 0L*/ )
{
    HRESULT sc = ValidateEnumerationFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will need
    // it to get WBEMClassObjects for constructing Instances.

    if ( SUCCEEDED(sc) && ValidateIMOSPointer( ) )
    {
        PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
        sc = EnumerateInstances( pContext, lFlags );
        PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
    }

    return sc;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   PutInstance
//
//  CIMOM wants us to put this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::PutInstance(const CInstance& newInstance, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   PutInstance
//
//  CIMOM wants us to put this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::PutInstance( IWbemClassObject __RPC_FAR *pInst,
                             long lFlags,
                             MethodContext* pContext )
{
    HRESULT scode = ValidatePutInstanceFlags(lFlags);

    // No need to AddRef()/Release() pInst here, since we're just
    // passing it into the CInstance object, which should take
    // care of that for us internally.

    if (SUCCEEDED(scode))
    {
        CInstancePtr   pInstance (new CInstance( pInst, pContext ), false);

        if ( NULL != pInstance )
        {
            scode = PutInstance(*pInstance, lFlags);
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return scode;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   DeleteInstance
//
//  CIMOM wants us to delete this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::DeleteInstance(const CInstance& newInstance, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   DeleteInstance
//
//  CIMOM wants us to put this instance.
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::DeleteInstance( ParsedObjectPath* pParsedObjectPath,
                                  long lFlags,
                                  MethodContext* pContext )
{
    HRESULT sc = ValidateDeletionFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will 
    // need it in order to create a brand new instance.

    if ( SUCCEEDED(sc) && ValidateIMOSPointer( ) )
    {
        CInstancePtr   pInstance (CreateNewInstance( pContext ), false);

        // Load up the instance keys
        if ( SetKeyFromParsedObjectPath( pInstance, pParsedObjectPath ) )
        {
            sc = DeleteInstance(*pInstance, lFlags);
        }
        else
        {
            sc = WBEM_E_INVALID_OBJECT_PATH;
        }

    }

    return sc;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ExecMethod
//
//  CIMOM wants us to execute this method on this instance
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::ExecMethod(const CInstance& pInstance, 
                             BSTR bstrMethodName, 
                             CInstance *pInParams, 
                             CInstance *pOutParams, 
                             long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   ExecMethod
//
//  CIMOM wants us to Execute this method on this instance
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::ExecMethod( ParsedObjectPath *pParsedObjectPath,
                              BSTR bstrMethodName,
                              long lFlags,
                              CInstance *pInParams,
                              CInstance *pOutParams,
                              MethodContext *pContext )
{
    HRESULT sc = ValidateMethodFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will 
    // need it in order to create a brand new instance.

    if ( SUCCEEDED(sc) && ValidateIMOSPointer( ) )
    {

        CInstancePtr   pInstance(CreateNewInstance( pContext ), false);

        if ( SetKeyFromParsedObjectPath( pInstance, pParsedObjectPath ) ) 
        {
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
            sc = ExecMethod(*pInstance, bstrMethodName, pInParams, pOutParams, lFlags);
            PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
        }
        else
        {
            sc = WBEM_E_INVALID_OBJECT_PATH;
        }

    }

    return sc;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetObject
//
//  called by the framework in response to a GetObject from CIMOM
//
//  Inputs:     ParsedObjectPath*       pParsedObjectPath - All the news
//                                      thats fit to print. 
//              IWbemContext __RPC_FAR* pCtx
//              IWbemObjectSink __RPC_FAR*pResponseHandler
//
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   
//
////////////////////////////////////////////////////////////////////////
HRESULT Provider::GetObject(  ParsedObjectPath *pParsedObjectPath,
                              MethodContext *pContext, 
                              long lFlags /*= 0L*/ )
{
    HRESULT hr = ValidateGetObjFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will 
    // need it in order to create a brand new instance.

    if ( SUCCEEDED(hr) && ValidateIMOSPointer( ) )
    {
        CInstancePtr pInstance (CreateNewInstance( pContext ), false);

        // Load up the instance keys
        if ( SetKeyFromParsedObjectPath( pInstance, pParsedObjectPath ) )
        {
            // Look for per-property gets
            IWbemContextPtr pWbemContext (pContext->GetIWBEMContext(), false);

            CFrameworkQueryEx CQuery;
            hr = CQuery.Init(pParsedObjectPath, pWbemContext, GetProviderName(), m_strNameSpace);

            // Note that 'SUCCEEDED' DOESN'T mean that we have per-property gets.  It
            // just means that the query object was successfully initialized.
            if (SUCCEEDED(hr))
            {
                // Fill in key properties on query object
                IWbemClassObjectPtr pWbemClassObject(pInstance->GetClassObjectInterface(), false);
                CQuery.Init2(pWbemClassObject);

                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::ProviderTimer);
                hr = GetObject(pInstance, lFlags, CQuery);
                PROVIDER_INSTRUMENTATION_START(pContext, StopWatch::FrameworkTimer);
            }
        }
        else
        {
            hr = WBEM_E_INVALID_OBJECT_PATH;
        }

        if (SUCCEEDED(hr))
        {
            // Account for the possibility that we have a SUCCESS code back from GetObject.
            HRESULT hRes = pInstance->Commit();
            hr = __max((ULONG)hRes, (ULONG)hr);
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider::GetInstancePath
//
//  Attempts to build an instance path for the supplied CInstance pointer.
//
//  Inputs:     const CInstance*    pInstance - Instance to build path for.
//
//  Outputs:    CHString&           strPath - Path from instance.
//
//  Return:     BOOL                Success/Failure.
//
//  Comments:   This function was created to help support the internal
//              short circuit we performed for obtaining local WBEM
//              Provider objects.  In this instance, we will use our
//              computer system name, namespace and instance relative
//              path to munge together a full WBEM Object Path.  This
//              is because only CIMOM objects will have this value set
//              and when we perform our short circuit, we cut CIMOM
//              out of the loop, so our instances don't have full
//              object paths.  This mostly helps out our association
//              logic, although a weakness of this solution is that
//              if the path that gets stored by CIMOM changes, we
//              will then need to change this function.
//
////////////////////////////////////////////////////////////////////////
bool Provider::GetLocalInstancePath( const CInstance *pInstance, 
                                     CHString& strPath )
{
    bool        fReturn = false;
    CHString    strRelativePath;

    if (pInstance && pInstance->GetCHString( L"__RELPATH", strRelativePath ) )
    {
        // We may want to use the OBJPath classes to piece this
        // together for us at a later time.

        strPath = MakeLocalPath(strRelativePath);

        fReturn = true;
    }

    return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Provider::MakeLocalPath
//
//  Builds a full instance path from a relative path
//
//  Inputs:     const CHString &strRelPath - Relative path
//
//  Outputs:    
//
//  Return:     CHString&           strPath - Path 
//
//  Comments:   Consider using GetLocalInstance path before using 
//             this function.
//
////////////////////////////////////////////////////////////////////////
CHString Provider::MakeLocalPath( const CHString &strRelPath )
{

    ASSERT_BREAK( (strRelPath.Find(L':') == -1) || ((strRelPath.Find(L'=') != -1) && (strRelPath.Find(L':') >= strRelPath.Find(L'=')) ));
    
    CHString sBase;
    
    sBase.Format(L"\\\\%s\\%s:%s", 
        (LPCWSTR)s_strComputerName, 
        m_strNameSpace.IsEmpty() ? DEFAULT_NAMESPACE: (LPCWSTR) m_strNameSpace, 
        (LPCWSTR)strRelPath);

    return sBase;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetKeyFromParsedObjectPath
//
//  called by the DeleteInstance and GetObject in order to load a
//  CInstance* with the key values in an object path.
//
//  Inputs:     CInstance*              pInstance - Instance to store
//                                      key values in.
//              ParsedObjectPath*       pParsedObjectPath - All the news
//                                      thats fit to print. 
//
//
//  Outputs:    
//
//  Return:     BOOL                Success/Failure
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

BOOL Provider::SetKeyFromParsedObjectPath( CInstance *pInstance, 
                                           ParsedObjectPath *pParsedPath )
{
    BOOL    fReturn = TRUE;
    SAFEARRAY *pNames = NULL;
    long lLBound, lUBound;
    
    // populate instance - This exact same routine is in wbemglue.cpp.  Changes here should be
    // reflected there (or someone should move these two somewhere else. instance.cpp?).
    for (DWORD i = 0; fReturn && i < (pParsedPath->m_dwNumKeys); i++)
    {
        if (pParsedPath->m_paKeys[i])
        {
            // If a name was specified in the form class.keyname=value
            if (pParsedPath->m_paKeys[i]->m_pName != NULL) 
            {
                fReturn = pInstance->SetVariant(pParsedPath->m_paKeys[i]->m_pName, pParsedPath->m_paKeys[i]->m_vValue);
            } 
            else 
            {
                // There is a special case that you can say class=value
                fReturn = FALSE;
                
                // only one key allowed in the format.  Check the names on the path
                if (pParsedPath->m_dwNumKeys == 1) 
                {
                    
                    // Get the names from the object
                    if (m_piClassObject->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pNames) == WBEM_S_NO_ERROR) 
                    {
						OnDelete<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayDestroy> smartpNames(pNames);

                        BSTR t_bstrName = NULL ;
                        
                        SafeArrayGetLBound(pNames, 1, &lLBound);
                        SafeArrayGetUBound(pNames, 1, &lUBound);
                    
                        // Only one key?
                        if ((lUBound - lLBound) == 0) 
                        {                            
                            // Get the name of the key field and set it
							if (SUCCEEDED(SafeArrayGetElement( pNames, &lUBound, &t_bstrName )))
							{
								OnDeleteIf<BSTR,VOID(*)(BSTR),SysFreeString> smartt_bstrName(t_bstrName);
	                            fReturn = pInstance->SetVariant( t_bstrName, pParsedPath->m_paKeys[i]->m_vValue);
							}
                        }
                    }
                }
                ASSERT_BREAK(fReturn); // somebody lied about the number of keys or the datatype was wrong
            }
        }
        else
        {
            ASSERT_BREAK(0); // somebody lied about the number of keys!
            fReturn = FALSE;
        }
    }
    
    return fReturn;
}

// sets the CreationClassName to the name of this provider
bool Provider::SetCreationClassName(CInstance* pInstance)
{
    if (pInstance)
    {
        return pInstance->SetCHString(IDS_CreationClassName, m_name);
    }
    else
    {
        return false;
    }
}


// flag validation - returns WBEM_E_UNSUPPORTED parameter if 
// lFlags contains any flags not found in lAcceptableFlags
HRESULT Provider::ValidateFlags(long lFlags, FlagDefs lAcceptableFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // invert the acceptable flags, which then are the UNacceptable flags
    if (lFlags & ~((long)lAcceptableFlags))
        hr = WBEM_E_UNSUPPORTED_PARAMETER;
    else
        hr = WBEM_S_NO_ERROR;

    return hr;
}
// base level validation routines
// you can override these in order to support a flag
// that is unknown to the base class
HRESULT Provider::ValidateEnumerationFlags(long lFlags)
{
    return ValidateFlags(lFlags, EnumerationFlags);
}
HRESULT Provider::ValidateGetObjFlags(long lFlags)
{
    return ValidateFlags(lFlags, GetObjFlags);
}
HRESULT Provider::ValidateMethodFlags(long lFlags)
{
    return ValidateFlags(lFlags, MethodFlags);
}
HRESULT Provider::ValidateQueryFlags(long lFlags)
{
    return ValidateFlags(lFlags, QueryFlags);
}
HRESULT Provider::ValidateDeletionFlags(long lFlags)
{
    return ValidateFlags(lFlags, DeletionFlags);
}
HRESULT Provider::ValidatePutInstanceFlags(long lFlags)
{
    return ValidateFlags(lFlags, PutInstanceFlags);
}

IWbemClassObject* Provider::GetClassObjectInterface(MethodContext *pMethodContext)
{
    IWbemClassObject *pObject = NULL;

    if (ValidateIMOSPointer())
    {
        BeginWrite();
		FrameDynOnDeleteObjVoid < Provider, void ( CThreadBase:: * ) ( void ), &CThreadBase::EndWrite > SmartEndWrite ( const_cast < Provider* > ( this ) ) ;

        if ( NULL == m_piClassObject )
        {
			//calling back into winmgmt - no critsec!
			SmartEndWrite.Exec ( ) ;

            IWbemContextPtr pWbemContext;

            if ( NULL != pMethodContext )
            {
                pWbemContext.Attach(pMethodContext->GetIWBEMContext());
            }

            IWbemServicesPtr pServices(CWbemProviderGlue::GetNamespaceConnection( m_strNameSpace, pMethodContext ), false);
			if ( NULL != static_cast < IWbemServices* > ( pServices ) )
			{
				HRESULT hr = pServices->GetObject( bstr_t( m_name ), 0L, pWbemContext, &pObject, NULL);

				BeginWrite();
				SmartEndWrite.ReSetExecFlag () ;

				if (SUCCEEDED(hr))
				{
					if (m_piClassObject == NULL)
					{
						m_piClassObject = pObject;
						pObject->AddRef();
					}
					else
					{
						if (pObject)
						{
							pObject->Release();
							pObject = NULL;
						}

						pObject = m_piClassObject;
						pObject->AddRef();
					}
				}
				else
				{
					if (pObject)
					{
						pObject->Release();
						pObject = NULL;
					}

					// belt & suspenders check. Won't hurt.
					m_piClassObject = NULL;

					throw CFramework_Exception(L"SpawnInstance failed", hr);
				}
			}
			else
			{
				throw CFramework_Exception(L"GetNamespaceConnection failed");
			}
        }
        else
        {
            pObject = m_piClassObject;
            pObject->AddRef();
        }
    }

    return pObject;
}

// If a provider wants to process queries, they should override this
HRESULT Provider::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

// find and create all instances of your class
HRESULT Provider::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

// you will be given an object with the key properties filled in.
// you need to fill in all of the rest of the properties
HRESULT Provider::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

// You will be given an object with the key properties filled in.
// You can either fill in all the properties, or check the Query object
// to see what properties are required.
HRESULT Provider::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query)
{
    // If we are here, the provider didn't override this method.  Fall back to the older
    // call.
   return GetObject(pInstance, lFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\threadbase.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  ThreadBase.CPP
//
//  Purpose: Implementation of CThreadBase class
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::CThreadBase
//
//  Class Constructor.
//
//  Inputs:     THREAD_SAFETY_MECHANISM etsm - Thread Safety Mechanism.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

CThreadBase::CThreadBase( THREAD_SAFETY_MECHANISM etsm /*=etsmSerialized*/ )
:   m_lRefCount( 1 ),   // Our initial ref count is always 1
    m_etsm( etsm )
{
    InitializeCriticalSection( &m_cs ); // Void function, so it best work.
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::~CThreadBase
//
//  Class Destructor.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

CThreadBase::~CThreadBase( void )
{
    DeleteCriticalSection( &m_cs );
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::OnFinalRelease
//
//  Virtual function called by Release() when our RefCount reaches 0.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Override if you want, but always call down to the base
//              implementation and let it call delete on 'this'.
//
////////////////////////////////////////////////////////////////////////

void CThreadBase::OnFinalRelease( void )
{
    delete this;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::AddRef
//
//  Increases our Reference count by one.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Uses Lock(), Unlock() to protect the data.  We may want
//              to change the function to use InterlockedIncrement().
//
////////////////////////////////////////////////////////////////////////

LONG CThreadBase::AddRef( void )
{
    
    LONG nRet = InterlockedIncrement(&m_lRefCount);

    return nRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CThreadBase::Release
//
//  Decreases our Reference count by one.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   Uses Lock(), Unlock() to protect the data.  We may want
//              to use InterlockedDecrement();
//
////////////////////////////////////////////////////////////////////////

LONG CThreadBase::Release( void )
{
    LONG nRet;
    
    BOOL    fFinalRelease = ( (nRet = InterlockedDecrement(&m_lRefCount)) == 0 );

    ASSERT_BREAK(nRet >= 0);

    if ( fFinalRelease )
    {
        OnFinalRelease();
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\wbemglue.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  WBEMGLUE.CPP
//
//  Purpose: Implementation of CWbemProviderGlue class
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <eventProvider.h>
#include <FRQueryEx.h>
#include <cnvmacros.h>
#include <BrodCast.h>
#include <cominit.h>
#include <StopWatch.h>
#include <comdef.h>
#include <SmartPtr.h>
#include <lmcons.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <Secext.h>
#include "FWStrings.h"
#include "MultiPlat.h"
#include <AutoImpRevert.h>
#include <lockwrap.h>

#include <winbasep.h>

#include <helper.h>

typedef FrameDynOnDelete < CRITICAL_SECTION *, VOID ( * ) ( LPCRITICAL_SECTION ), LeaveCriticalSection >	LeaveCriticalSectionScope;
typedef WaitException < CRITICAL_SECTION *, VOID ( * ) ( LPCRITICAL_SECTION ), EnterCriticalSection, 1000 >	EnterCriticalSectionWait;


class CWbemGlueImpersonation
{
	CWbemGlueImpersonation ( const CWbemGlueImpersonation& ) {}

	HRESULT m_hr;

	public:

	CWbemGlueImpersonation () : m_hr ( E_FAIL )
	{
		m_hr = CWbemProviderGlue::CheckImpersonationLevel ();
	}

	~CWbemGlueImpersonation ()
	{
		if SUCCEEDED ( m_hr )
		{
			WbemCoRevertToSelf ();
		}
	}

	HRESULT IsImpersonated () const
	{
		return m_hr;
	}
};

#define GLUETIMEOUT WBEM_INFINITE //(3 * 60 * 1000)

// Used in ASSERT_BREAK to give meaningful messages
#define DEPRECATED 1
#define MEMORY_EXHAUSTED 0
#define FRAMEWORK_EXCEPTION 0
#define UNSPECIFIED_EXCEPTION 0
#define STRUCTURED_EXCEPTION 0
#define DUPLICATE_RELEASE 0
#define IMPERSONATION_REVERTED 0
#define UNNECESSARY_CWBEMPROVIDERGLUE_INSTANCE 0

// Initialize Statics
STRING2LPVOID       CWbemProviderGlue::s_providersmap;
CCritSec            CWbemProviderGlue::s_csFactoryMap;
PTR2PLONG           CWbemProviderGlue::s_factorymap;
CCritSec            CWbemProviderGlue::s_csProviderMap;
CCritSec            CWbemProviderGlue::m_csStatusObject;
IWbemClassObject    *CWbemProviderGlue::m_pStatusObject = NULL;
BOOL                CWbemProviderGlue::s_bInitted = FALSE;
DWORD               CWbemProviderGlue::s_dwPlatform = 0;
DWORD               CWbemProviderGlue::s_dwMajorVersion = 0;
WCHAR               CWbemProviderGlue::s_wstrCSDVersion[_MAX_PATH] = {0};

long                CWbemProviderGlue::s_lObjects = 0;

// Static Provider we use to initialize, uninitialize our static
// data.  We should be able to assume at Construct/Destruct time that
// we (the DLL) are being loaded/unloaded.
// later on -- we should, but we can't.  Current model is that we
// uninitialize when the last DLL that we service has called DLLLogoff,
// which had better be in response to "DllCanUnloadNow"

CWbemProviderGlue   g_wbemprovider;


/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::CWbemProviderGlue
//
//  Class CTor.  Uses static initialization functon to get static data
//  ready if this is the first instance of our object.
//
//  Inputs:     None
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

CWbemProviderGlue::CWbemProviderGlue()
:   m_strNamespace(),
m_lRefCount(0),
m_pCount(NULL),
m_pServices(NULL)
{
    Init();
}

CWbemProviderGlue::CWbemProviderGlue(PLONG pCount)
:   m_strNamespace(),
m_lRefCount(0),
m_pCount(pCount),
m_pServices(NULL)
{
    CWbemProviderGlue::IncrementMapCount(pCount);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::~CWbemProviderGlue
//
//  Class DTor.
//
//  Inputs:     None
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

CWbemProviderGlue::~CWbemProviderGlue()
{
    // Note that the item we are destructing here was not added in
    // the constructor, but in Initialize().
    if (m_pServices)
    {
        m_pServices->Release();
    }

    if (m_pCount != NULL)  // Indicates the static instance
    {
        if (DecrementMapCount(m_pCount) == 0)
        {
            FlushAll();
        }
    }
    else
    {
        UnInit();
    }
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::Init
//
//  Static initialization function for initializing critical sections
//  and such for making our static data thread-safe.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   Because we are protecting static data, we are using
//              a named mutex.  Construction and Destruction of object
//              instances should call these functions.
//
/////////////////////////////////////////////////////////////////////

void CWbemProviderGlue::Init( void )
{
    LogMessage(IDS_GLUEINIT);

    if (!s_bInitted)
    {
        // Note that we *have* to use the ansi version at this point,
        // since this is where we decide whether to use the ansi functions
        // or the unicode ones.
        OSVERSIONINFOA OsVersionInfoA;

        OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
        GetVersionExA(&OsVersionInfoA);

        s_dwPlatform = OsVersionInfoA.dwPlatformId;
        s_dwMajorVersion = OsVersionInfoA.dwMajorVersion;

        if (OsVersionInfoA.szCSDVersion == NULL)
        {
            s_wstrCSDVersion[0] = L'\0';
        }
        else
        {
            bool t_ConversionFailure = false ;
            WCHAR *wcsBuffer = NULL ;
            ANSISTRINGTOWCS(OsVersionInfoA.szCSDVersion, wcsBuffer, t_ConversionFailure );
            if ( ! t_ConversionFailure )
            {
                if ( wcsBuffer )
                {
                    StringCchCopyW(s_wstrCSDVersion, _MAX_PATH, wcsBuffer);
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
// Should do something here since we know version is not initialised.
            }
        }

        s_bInitted = TRUE;
    }
    else
    {
        ASSERT_BREAK(UNNECESSARY_CWBEMPROVIDERGLUE_INSTANCE);
    }
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::UnInit
//
//  Static cleanup function for cleaning up critical sections
//  and such for making our static data thread-safe.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   Because we are protecting static data, we are using
//              a named mutex.  Construction and Destruction of object
//              instances should call these functions.
//
/////////////////////////////////////////////////////////////////////

void CWbemProviderGlue::UnInit( void )
{
	try
	{
		LogMessage(IDS_GLUEUNINIT);
	}
	catch ( ... )
	{
	}
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetStaticMutex
//
//  Creates and returns an instance of the named mutex used to
//  protect our static initialization functions.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   The mutex, although it is named, makes the process
//              id part of the name, guaranteeing that it is still
//              unique across processes.
//
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::QueryInterface
//
//  COM function called to ask us if we support a particular
//  face type.  If so, we addref ourselves and return the
//  ourselves as an LPVOID.
//
//  Inputs:     REFIID          riid - Interface being queried for.
//
//  Outputs:    LPVOID FAR*     ppvObj - Interface pointer.
//
//  Returns:    None.
//
//  Comments:   The only interfaces we support are IID_IUnknown and
//              IID_IWbemServices.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemProviderGlue::QueryInterface( REFIID riid, LPVOID FAR *ppvObj )
{
    LogMessage(L"CWbemProviderGlue::QueryInterface");

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IWbemServices *) this;
    }
    else if (IsEqualIID(riid, IID_IWbemServices))
    {
        *ppvObj = (IWbemServices *) this;
    }
    else if (IsEqualIID(riid, IID_IWbemProviderInit))
    {
        *ppvObj = (IWbemProviderInit *) this;
    }
    else
    {
        try
        {
            *ppvObj = NULL ;
            if (IsVerboseLoggingEnabled())
            {
                WCHAR      wcID[128];
                StringFromGUID2(riid, wcID, 128);

                LogMessage2(L"CWbemProviderGlue::QueryInterface - unsupported interface (%s)", wcID);
            }
        }
        catch ( ... )
        {
        }

        return ResultFromScode(E_NOINTERFACE) ;
    }

    AddRef() ;

    return NOERROR ;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddRef
//
//  Increments the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   Requires that a correponding call to Release be
//              performed.
//
/////////////////////////////////////////////////////////////////////

ULONG CWbemProviderGlue::AddRef( void )
{
    CSetStructuredExceptionHandler t_ExceptionHandler;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            // this will be an approximation because another thread could come through...
            LogMessage2(L"CWbemProviderGlue::AddRef, count is (approx) %d", m_lRefCount +1);
        };
    }
    catch ( ... )
    {
    }

    // InterlockedIncrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.

    return InterlockedIncrement( &m_lRefCount );
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::Intialize
//
//  Inputs:     Many.
//
//  Outputs:    None.
//
//  Returns:
//
//  Comments:   any global initializations, esp those that call CIMOM should go here.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::Initialize(
                                      /* [in] */ LPWSTR pszUser,
                                      /* [in] */ LONG lFlags,
                                      /* [in] */ LPWSTR pszNamespace,
                                      /* [in] */ LPWSTR pszLocale,
                                      /* [in] */ IWbemServices __RPC_FAR *pNamespace,
                                      /* [in] */ IWbemContext __RPC_FAR *pCtx,
                                      /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    CSetStructuredExceptionHandler t_ExceptionHandler;
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s(%s)", IDS_GLUEINITINTERFACE, pszNamespace);
        }
    }
    catch ( ... )
    {
    }

    if ( (NULL != pszNamespace) && (NULL != pNamespace) )
    {
        try
        {
            // this may come back to bite me
            // CIMOM promises that this will only be called on one thread, once per object
            // and that no queries will be issued until after initialize is called.
            // therefore - I don't need a critical section, here -
            m_strNamespace = pszNamespace;
            m_strNamespace.MakeUpper();

            pNamespace->AddRef();
            m_pServices = pNamespace;
        }
        catch ( CFramework_Exception e_FR )
        {
            ASSERT_BREAK(FRAMEWORK_EXCEPTION);
            hr = WBEM_E_PROVIDER_FAILURE;
        }
        catch ( CHeap_Exception e_HE )
        {
            ASSERT_BREAK(MEMORY_EXHAUSTED);
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        catch(CStructured_Exception e_SE)
        {
            ASSERT_BREAK(STRUCTURED_EXCEPTION);
            hr = WBEM_E_PROVIDER_FAILURE;
        }
        catch ( ... )
        {
            ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
            hr = WBEM_E_PROVIDER_FAILURE;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if (pInitSink)
    {
        pInitSink->SetStatus(hr, 0);
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::Release
//
//  Decrements the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

ULONG CWbemProviderGlue::Release()
{
    // InterlockedDecrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.

    // We want to hold the value locally in case two threads
    // Release at the same time and one gets a final release,
    // and deletes, leaving a potential window in which a thread
    // deletes the object before the other returns and tries to
    // reference the value from within the deleted object.

    CSetStructuredExceptionHandler t_ExceptionHandler;
    ULONG   nRet = InterlockedDecrement( &m_lRefCount );

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage2(L"CWbemProviderGlue::Release, count is (approx) %d", m_lRefCount);
        }
    }
    catch ( ... )
    {
    }

    if( 0 == nRet )
    {
        try
        {
            LogMessage(IDS_GLUEREFCOUNTZERO);
        }
        catch ( ... )
        {
        }
        delete this;
    } else if (nRet > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
    }

    return nRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FlushAll
//
//  Inputs:     voidness
//
//  Outputs:    more voidness
//
//  Returns:    see above
//
//  Comments:   flushes caches, calls all of the provider's flushes.
//              no need to flush event providers map, flush will be
//              called on the provider pointer
//
/////////////////////////////////////////////////////////////////////
void CWbemProviderGlue::FlushAll(void)
{
    PROVIDERPTRS::iterator      setIter;

    // We DEFINITELY want to protect the Map while this is running!
    EnterCriticalSectionWait	ecs ( &s_csProviderMap );
	LeaveCriticalSectionScope	lcs ( &s_csProviderMap );

    try
    {
        // pProvider doesn't get addref'ed, so doesn't need to be released
        Provider *pProvider = NULL;

		EnterCriticalSectionWait	ecs1 ( &m_csFlushPtrs );
		LeaveCriticalSectionScope	lcs1 ( &m_csFlushPtrs );

        for (setIter = m_FlushPtrs.begin(); setIter != m_FlushPtrs.end(); setIter++)
        {
            pProvider = (Provider*) *setIter;
            if ( pProvider != NULL )
            {
                // If one provider poops out, try the others.
                try
                {
                    pProvider->Flush();
                }
                catch ( ... )
                {
                }
            }
        }

        m_FlushPtrs.clear();
    }
    catch ( ... )
    {
		// we should not be here
		// do not re-throw (called from destructor)
    }

	lcs.Exec ();

    if (m_pStatusObject)
    {
		EnterCriticalSectionWait	ecs1 ( &m_csStatusObject );
		LeaveCriticalSectionScope	lcs1 ( &m_csStatusObject );

        if (m_pStatusObject)
        {
            m_pStatusObject->Release();
            m_pStatusObject = NULL;
        }
    }
}

// SetStatusObject
// sets the properties in the extended status object so that it can be returned when
// the glue layer calls SetStatus at the end of the method invocation.
// will return false if the status object has already been filled.
// (first one in wins)
bool CWbemProviderGlue::SetStatusObject(

    MethodContext *pContext,
    LPCWSTR pNamespace,
    LPCWSTR pDescription,
    HRESULT hr,
    const SAFEARRAY *pPrivilegesNotHeld,/* = NULL */
    const SAFEARRAY *pPrivilegesRequired/* = NULL */
)
{
    bool bRet = false;

    ASSERT_BREAK(pContext != NULL);
    if (pContext)
    {
        IWbemClassObjectPtr pObj ( GetStatusObject(pContext, pNamespace), false );

        if (pObj != NULL)
        {
            // Variant_t handles the VariantInit/VariantClear
            variant_t v;

            pContext->SetStatusObject(pObj);

            // set hresult ("StatusCode")
            v.vt   = VT_I4;
            v.lVal = (long)hr;
            pObj->Put(IDS_STATUSCODE, 0, &v, NULL);
            v.Clear();

            // set description
            if (pDescription)
            {
                v = pDescription;

                if (v.bstrVal != NULL)
                {
                    bRet = SUCCEEDED(pObj->Put(IDS_DESCRIPTION, 0, &v, NULL));
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                v.Clear();
            }

            // privileges properties
            if (pPrivilegesNotHeld)
            {
                SAFEARRAY *pSafeArray = NULL;
                // blithy casting away the const...
                if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)pPrivilegesNotHeld, &pSafeArray ) ) )
                {
                    v.vt = VT_BSTR | VT_ARRAY;
                    v.parray = pSafeArray;
                    pObj->Put(IDS_PRIVILEGESNOTHELD, 0, &v, NULL);
                    v.Clear();
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

            if (pPrivilegesRequired)
            {
                SAFEARRAY *pSafeArray = NULL;
                // blithy casting away the const...
                if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)pPrivilegesRequired, &pSafeArray ) ) )
                {
                    v.vt = VT_BSTR | VT_ARRAY;
                    v.parray = pSafeArray;
                    pObj->Put(IDS_PRIVILEGESREQUIRED, 0, &v, NULL);
                    v.Clear();
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
    }

    return bRet;
}

IWbemClassObject *CWbemProviderGlue::GetStatusObject(

    MethodContext *pContext,
    LPCWSTR pNamespace
)
{
    ASSERT_BREAK(pContext != NULL);
    IWbemClassObject *pStatusObj = NULL;

    if (pContext != NULL)
    {
        // first time in, we cache the class object
        if (!m_pStatusObject)
        {
            m_csStatusObject.Enter();

            // check again - someone might have snuck in!
            if (!m_pStatusObject)
            {
                IWbemServicesPtr pSrvc;
                IWbemContextPtr pWbemContext (pContext->GetIWBEMContext(), false);

                pSrvc.Attach ( GetNamespaceConnection( pNamespace, pContext ) ) ;
                if ( pSrvc )
                {
                    // not checking return code, error object should be NULL on error
                    pSrvc->GetObject( bstr_t( IDS_WIN32PRIVILEGESSTATUS ), 0, pWbemContext, &m_pStatusObject, NULL );
                }

            }
            m_csStatusObject.Leave();
        }

        if (m_pStatusObject)
            m_pStatusObject->SpawnInstance(0, &pStatusObj);
    }
    else
    {
        LogErrorMessage(L"NULL parameter to GetStatusObject");
    }

    return pStatusObj;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::ExecQueryAsync
//
//  Place holder for the ExecQuery function.
//
//  Inputs:     const BSTR  QueryFormat - Query Format String
//              const BSTR  Query - The actual query
//              long        lFlags - Additional flags.
//              IWbemContext __RPC_FAR *pCtx - Context we were called in.
//              IWbemObjectSink FAR *pResponseHandler - Response Handler
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::ExecQueryAsync(

    const BSTR QueryFormat,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
        StopWatch stopWatch(CHString(IDS_EXECQUERY) + CHString(Query));
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_EXECQUERY, Query);
        }

        // Now create an External Method Context object and go to town
        ExternalMethodContextPtr  pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

#ifdef PROVIDER_INSTRUMENTATION
        pContext->pStopWatch = &stopWatch;
#endif

        if (pContext != NULL)
        {
            CFrameworkQueryEx CQuery;
//            hr = CQuery.InitEx(QueryFormat, Query, lFlags, m_strNamespace);
            hr = CQuery.Init(QueryFormat, Query, lFlags, m_strNamespace);
            if (SUCCEEDED(hr))
            {
                // Find the class name for the query
                bstr_t bstrClass (CQuery.GetQueryClassName(), false);
                if ((WCHAR *)bstrClass != NULL)
                {
                    // Search for the class name in our map of providers, we know which
                    // namespace we are when we get constructed.
                    // pProvider doesn't get addref'ed, so doesn't need to be released.
                    Provider *pProvider = SearchMapForProvider( bstrClass, m_strNamespace );
                    if ( NULL != pProvider )
                    {

                        // Initialize the CQuery.m_keysonly variable.  Note that we CAN'T do this as part
                        // of Init, because we need the pProvider pointer.  And we can do the init
                        // down here, because we need the bstrClass that we get from Init.  And we can't
                        // do this as part of CQuery.KeysOnly because you can't get the IWbemClassObject
                        // from there.
                        IWbemClassObjectPtr IClass(pProvider->GetClassObjectInterface(pContext), false);
                        if (IClass != NULL)
                        {
                            CQuery.Init2(IClass);

                            // Impersonate connected user
							CWbemGlueImpersonation impersonate;
                            if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                            {
                                // Set up to call FlushAll
                                AddFlushPtr(pProvider);

                                WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                                WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                                DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                                GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                                // Everything is in place, run the query
                                hr = pProvider->ExecuteQuery( pContext, CQuery, lFlags );

                                dwLen = UNLEN + DNLEN + 1 + 1;

                                GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                                if (wcscmp(wszName, wszName2) != 0)
                                {
                                    ASSERT_BREAK(IMPERSONATION_REVERTED);
                                    LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                        wszName2, wszName, Query);
                                }
                            }
                        }
                        else
                        {
                            // we don't know WHY we couldn't get the interface,
                            // generic error it is...
                            hr = WBEM_E_FAILED;
                        }

                    }
                    else
                    {
                        LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, (LPCWSTR)bstrClass);
                        hr = WBEM_E_INVALID_CLASS;
                    }
                }
                else
                {
                    LogErrorMessage(IDS_INVALIDCLASSNAME);
                    hr = WBEM_E_INVALID_CLASS;
                }
            }

            pStatusObject.Attach(pContext->GetStatusObject());
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_EXECQUERY, Query);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_EXECQUERY, Query, hr);
        }
    }
    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // We must call SetStatus so CIMOM doesn't lose any threads.
    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER))
    {
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject);
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif
        hr = WBEM_S_NO_ERROR;
    }

    Release();

#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::CreateInstanceEnumAsync
//
//  Locates the provider for the specified class name and
//  calls its CreateInstanceEnum function.
//
//  Inputs:     const BSTR      Class - Name of provider
//              long            lFlags - Enumeration flags.
//              IWbemContext __RPC_FAR  *pCtxt - Context pointer
//              IWbemObjectSink __RPC_FAR  *pResponseHandler - Response
//                                          handler.
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::CreateInstanceEnumAsync(

    const BSTR a_bstrClass,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
    StopWatch stopWatch(CHString(IDS_CREATEINSTANCEENUM) + CHString(Class));
    stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT hr = WBEM_E_INVALID_CLASS;
    IWbemClassObjectPtr pStatusObject;
    bool bSendStatus = true;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_CREATEINSTANCEENUM, a_bstrClass);
        }

        // Check for per-property gets
        CFrameworkQueryEx CQuery;
        hr = CQuery.Init(NULL, pCtx, a_bstrClass, m_strNamespace);

        // Note that we AREN'T calling Init2, which means if they specified "__RELPATH"
        // as their property, we won't expand that out to the key names.  However, since
        // we are going to call ExecQuery, and it reprocesses the query and DOES call
        // Init2, this isn't an issue.
//        CQuery.Init2(pWbemClassObject);

        // If they are doing per-property gets, then turn this into a query.
        if (SUCCEEDED(hr))
        {
            if (CQuery.AllPropertiesAreRequired())
            {
                // Search for the class name in our map of providers, we know which
                // namespace we are when we get constructed.
                // pProvider doesn't get addref'ed, so no release necessary
                Provider *pProvider = SearchMapForProvider( a_bstrClass, m_strNamespace );

                if ( NULL != pProvider )
                {
                    // Now create an External Method Context object and go to town
                    ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

                    if ( NULL != pContext )
                    {
						CWbemGlueImpersonation impersonate;
                        if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                        {
                            // Set up to call FlushAll
                            AddFlushPtr(pProvider);

                            WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                            WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                            DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                            GetUserNameEx(NameSamCompatible, wszName, &dwLen);

#ifdef PROVIDER_INSTRUMENTATION
                            pContext->pStopWatch = &stopWatch;
#endif
                            hr = pProvider->CreateInstanceEnum( pContext, lFlags );

                            dwLen = UNLEN + DNLEN + 1 + 1;

                            GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                            if (wcscmp(wszName, wszName2) != 0)
                            {
                                ASSERT_BREAK(IMPERSONATION_REVERTED);
                                LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                    wszName2, wszName, a_bstrClass);
                            }
                        }
                        pStatusObject.Attach(pContext->GetStatusObject());
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
                else
                {
                    LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, a_bstrClass);
					hr = WBEM_E_INVALID_CLASS;
                    bSendStatus = false;
                }
            }
            else
            {
                bstr_t bstrtQuery = CQuery.GetQuery();

                hr =
                    ExecQueryAsync(
                        L"WQL",
                        bstrtQuery,
                        lFlags,
                        pCtx,
                        pResponseHandler);

                // Since execquery sent whatever status is necessary
                bSendStatus = false;
            }

        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_CREATEINSTANCEENUM, a_bstrClass);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_CREATEINSTANCEENUM, a_bstrClass, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && bSendStatus)
    {

#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif

        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );

#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif

        hr = WBEM_S_NO_ERROR;
    }

    Release();
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif
    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetObjectAsync
//
//  Parses the supplied object path and hands the request off
//  to the appropriate provider.
//
//  Inputs:     const BSTR      ObjPath - Object Path containing
//                              keys to required object.
//              long            lFlags - Get Object flags.
//              IWbemContext __RPC_FAR  *pCtxt - Context pointer
//              IWbemObjectSink __RPC_FAR  *pResponseHandler - Response
//                                          handler.
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::GetObjectAsync(

   const BSTR ObjectPath,
   long lFlags,
   IWbemContext __RPC_FAR *pCtx,
   IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
        StopWatch stopWatch(CHString(IDS_GETOBJECTASYNC) + CHString(ObjectPath));
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT              hr = WBEM_E_FAILED;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;
    ParsedObjectPath    *pParsedPath = NULL;
    CObjectPathParser    objpathParser;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_GETOBJECTASYNC, ObjectPath);
        }

        // Parse the object path passed to us by CIMOM
        // ==========================================
        int nStatus = objpathParser.Parse( ObjectPath,  &pParsedPath );

        if ( 0 == nStatus )
        {

            // Now try to find the provider based on the class name
            // pProvider doesn't get addref'ed, so no release necessary
            Provider *pProvider = SearchMapForProvider( pParsedPath->m_pClass, m_strNamespace );

            // If we got a provider, let it handle itself like a grown-up provider
            // should.

            if ( NULL != pProvider )
            {
                // Now create an External Method Context object and go to town

                ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

                if ( NULL != pContext )
                {
#ifdef PROVIDER_INSTRUMENTATION
                    pContext->pStopWatch = &stopWatch;
#endif
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->GetObject( pParsedPath, pContext, lFlags );
                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                wszName2, wszName, ObjectPath);
                        }
                    }

                    pStatusObject.Attach(pContext->GetStatusObject());
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

            }
            else
            {
                LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, pParsedPath->m_pClass);
                hr = WBEM_E_INVALID_CLASS;
                bLocalError = true;
            }

        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_GETOBJECTASYNC, ObjectPath);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_GETOBJECTASYNC, ObjectPath, hr);
        }

    }
    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Start(StopWatch::FrameworkTimer);
#endif
        hr = WBEM_S_NO_ERROR;
    }

    // Clean up the Parsed Path
    if (pParsedPath)
    {
        objpathParser.Free( pParsedPath );
    }

    Release();
#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif
    return hr;

}

/////////////////////////////////////////////////////////////////////
//
//   Function:   CWbemProviderGlue::PutInstanceAsync
//
//   Locates the provider for the specified class name and
//   calls its CreateInstanceEnum function.
//
//   Inputs:     IWbemClassObject __RPC_FAR *pInst - Instance whose
//                                           values to use.
//               long                        lFlags - PutInstance flags.
//               IWbemContext __RPC_FAR *pCtxt - Context pointer
//               IWbemObjectSink __RPC_FAR *pResponseHandler - Response
//                                           handler.
//
//   Outputs:    None.
//
//   Returns:    SCCODE      - COM Status.
//
//   Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::PutInstanceAsync(

    IWbemClassObject __RPC_FAR *pInst,
    long                     lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

    HRESULT  hr = WBEM_E_INVALID_CLASS;
    variant_t vClass;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        // Set up to get the class name of the instance being passed to us
        // ask the framework if it has this class registered for support
        // ===============================================================

        // Get the class name
        pInst->Get( IDS_CLASS, 0, &vClass, NULL, NULL );

        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_PUTINSTANCEASYNC, vClass.bstrVal);
        }

        // pProvider doesn't get addref'ed, so no release necessary
        Provider *pProvider = SearchMapForProvider( vClass.bstrVal, m_strNamespace );

        // If we got a provider, let it handle itself like a grown-up provider
        // should.
        if ( NULL != pProvider )
        {
            // Now create an External Method Context object and go to town
            ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

            if ( NULL != pContext )
            {
                IWbemClassObjectPtr  pInstPostProcess;
                if (SUCCEEDED(hr = PreProcessPutInstanceParms(pInst, &pInstPostProcess, pCtx)))
                {
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->PutInstance( pInstPostProcess, lFlags, pContext );

                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                wszName2, wszName, vClass.bstrVal);
                        }
                    }
                }
                pStatusObject.Attach(pContext->GetStatusObject());
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, vClass.bstrVal);
			hr = WBEM_E_INVALID_CLASS;
            bLocalError = true;
        }


        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_PUTINSTANCEASYNC, vClass.bstrVal);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_PUTINSTANCEASYNC, vClass.bstrVal, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );
        hr = WBEM_S_NO_ERROR;
    }

    Release();
    return hr;

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::PreProcessPutInstanceParms()
//
//  IF __PUT_EXT_PROPERTIES is specified, will parse out the intended properties
//  and set to NULL those props that are not explicitly being put.
//
//  Inputs:  [IN] IWbemClassObject __RPC_FAR *pInstIn - Instance whose values to use.
//           [OUT] IWbemClassObject __RPC_FAR **pInstOut - processed instance
//           IWbemContext __RPC_FAR *pCtxt - Context pointer
//
//  Outputs:    None.
//
//  Returns:    WBEM_S_NO_ERROR if the only extension specified is __PUT_EXT_PROPERTIES
//                      or if no extensions are specified
//              WBEM_E_UNSUPPORTED_PUT_EXTENSION if any other flag is set.
//              WBEM_E_SEVERE_SCREWUP if some other darn thing happened.
//
//  Comments:   You may get a different IWbemObject out than you put in
//              it's your responsibility to release it.
//              On error - pInstOut is undefined.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::PreProcessPutInstanceParms(

    IWbemClassObject __RPC_FAR *pInstIn,
    IWbemClassObject __RPC_FAR **pInstOut,
    IWbemContext __RPC_FAR *pCtx
)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    // Variant_t handles the VariantInit/VariantClear
    variant_t vValue;

    if (
            pCtx != NULL &&
            SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXTENSIONS", 0, &vValue)) &&
            V_VT(&vValue) == VT_BOOL &&
            V_BOOL(&vValue) == VARIANT_TRUE
       )
    {
        // easy checks first, are there unsupported parms?
        vValue.Clear();
        if (SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXT_STRICT_NULLS", 0, &vValue))
            && (V_VT(&vValue)   == VT_BOOL)
            && (V_BOOL(&vValue) == VARIANT_TRUE))
                hr = WBEM_E_UNSUPPORTED_PUT_EXTENSION;
        else
        {
            vValue.Clear();
            if (SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXT_ATOMIC", 0, &vValue))
                && (V_VT(&vValue)   == VT_BOOL)
                && (V_BOOL(&vValue) == VARIANT_TRUE))
                    hr = WBEM_E_UNSUPPORTED_PUT_EXTENSION;
        }

        vValue.Clear();
        if ((SUCCEEDED(hr) || (hr != WBEM_E_UNSUPPORTED_PUT_EXTENSION))
            && SUCCEEDED(hr = pCtx->GetValue( L"__PUT_EXT_PROPERTIES", 0, &vValue)))
        {
            if (V_VT(&vValue) == (VT_BSTR|VT_ARRAY))
                hr = NullOutUnsetProperties(pInstIn, pInstOut, vValue);
            else
                hr = WBEM_E_INVALID_PARAMETER;
        }
        else if (hr == WBEM_E_NOT_FOUND)
        {
            // well, if we've never heard of it, it MUST be wrong...
            hr = WBEM_E_UNSUPPORTED_PUT_EXTENSION;
        }
    }
    else if (hr == WBEM_E_NOT_FOUND)
    {
        // no extensions - no problems.
        // out interface is same as in interface
        hr = WBEM_S_NO_ERROR;
        *pInstOut = pInstIn;
        (*pInstOut)->AddRef();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::NullOutUnsetProperties
//
//  returns a copy of the input class, any properties whose names are listed
//  in the variant are set to NULL in the output class
//
//
//  Inputs:  IWbemClassObject __RPC_FAR *pInst - Instance whose
//                                          values to NULL
//              VARIANT                     contains names to not NULL out.
//
//  Outputs:    None.
//
//  Returns:    the ubiquitous HRESULT
//
//  Comments:   Assumes you've done your homework and the Variant
//              is a BSTR Array containing property names.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::NullOutUnsetProperties(

    IWbemClassObject __RPC_FAR *pInstIn,
    IWbemClassObject __RPC_FAR **pInstOut,
    const VARIANT& vValue
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // get ourselves a copy to work with
    CInstancePtr pInstance;

    // Variant_t handles the VariantInit/VariantClear
    variant_t vName;
    variant_t vNameSpace;

    hRes = pInstIn->Get(IDS_CLASS, 0, &vName, NULL, NULL);

    if (SUCCEEDED(hRes))
    {
        hRes = pInstIn->Get(L"__NAMESPACE", 0, &vNameSpace, NULL, NULL);
    }

    if (SUCCEEDED(hRes) && SUCCEEDED( hRes = GetEmptyInstance(vName.bstrVal, &pInstance, vNameSpace.bstrVal)))
    {
        // and off we go...
        SAFEARRAY *pNames = vValue.parray;
        long nBiggestName;
        if (SUCCEEDED(hRes = SafeArrayGetUBound(pNames, 1, &nBiggestName)))
        {
            BSTR t_bstrName = NULL ;
            *pInstOut = pInstance->GetClassObjectInterface();

            variant_t value;

            // wander through the names, for every one we find
            // copy the property value to the out pointer
            for (long i = 0; i <= nBiggestName; i++)
            {
                if (SUCCEEDED(SafeArrayGetElement( pNames, &i, &t_bstrName )))
                {
					OnDeleteIf<BSTR,VOID(*)(BSTR),SysFreeString> smartt_bstrName(t_bstrName);

                    pInstIn->Get( t_bstrName, 0, &value, NULL, NULL);
                    (*pInstOut)->Put( t_bstrName, 0, &value, 0);
				}
            }

            // and, oh what the heck - let's copy the keys, too...
            SAFEARRAY *pKeyNames = NULL;
            if (SUCCEEDED(hRes = pInstIn->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pKeyNames)))
            {
				OnDelete<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayDestroy> smartpKeyNames(pKeyNames);

                SafeArrayGetUBound(pKeyNames, 1, &nBiggestName);
                for (i = 0; i <= nBiggestName; i++)
                {
					if (SUCCEEDED(SafeArrayGetElement( pKeyNames, &i, &t_bstrName )))
					{
						OnDeleteIf<BSTR,VOID(*)(BSTR),SysFreeString> smartt_bstrName(t_bstrName);

                        pInstIn->Get( t_bstrName, 0, &value, NULL, NULL );
                        (*pInstOut)->Put( t_bstrName, 0, &value, 0 );
                    }
                }
            }
        }
        else
        {
            // failed to get array upper bound!
            hRes = WBEM_E_FAILED;
        }
    }

    return hRes;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::DeleteInstanceAsync
//
//  Locates the provider for the specified class name and
//  calls its DeleteInstance function.
//
//  Inputs:  IWbemClassObject __RPC_FAR *pInst - Instance whose
//                                          values to use.
//              long                        lFlags - PutInstance flags.
//              IWbemContext __RPC_FAR *pCtxt - Context pointer
//              IWbemObjectSink __RPC_FAR *pResponseHandler - Response
//                                          handler.
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////
HRESULT CWbemProviderGlue::DeleteInstanceAsync(

    const BSTR        ObjectPath,
    long              lFlags,
    IWbemContext      __RPC_FAR *pCtx,
    IWbemObjectSink   __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

    HRESULT             hr = WBEM_E_FAILED;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;

    ParsedObjectPath *pParsedPath = NULL;
    CObjectPathParser   objpathParser;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage3(L"%s%s", IDS_DELETEINSTANCEASYNC, ObjectPath);
        }

        // Parse the object path passed to us by CIMOM
        // ==========================================
        int nStatus = objpathParser.Parse( ObjectPath,  &pParsedPath );

        if ( 0 == nStatus )
        {
            // Now try to find the provider based on the class name
            // pProvider doesn't get addref'ed, so no release necessary
            Provider *pProvider = SearchMapForProvider( pParsedPath->m_pClass, m_strNamespace );

            // If we got a provider, let it handle itself like a grown-up provider
            // should.

            if ( NULL != pProvider )
            {
                // Now create an External Method Context object and go to town

                ExternalMethodContextPtr pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);

                if ( NULL != pContext )
                {
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->DeleteInstance( pParsedPath, lFlags, pContext );

                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage4(L"Warning! User name at exit (%s) != user name at entry (%s) for %s",
                                wszName2, wszName, ObjectPath);
                        }
                    }
                    pStatusObject.Attach(pContext->GetStatusObject());
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

            }
            else
            {
                hr = WBEM_E_INVALID_CLASS;
                LogErrorMessage4(L"%s (%s:%s)", IDS_PROVIDERNOTFOUND, (LPCWSTR)m_strNamespace, pParsedPath->m_pClass);
                bLocalError = true;
            }

        }
        else
        {
            LogErrorMessage3(L"%s (%s)", IDS_COULDNOTPARSE, ObjectPath);
            bLocalError = true;
        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage3(L"%s%s - Succeeded", IDS_DELETEINSTANCEASYNC, ObjectPath);
            else
                LogMessage4(L"%s%s - FAILED (%x)", IDS_DELETEINSTANCEASYNC, ObjectPath, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject);
        hr = WBEM_S_NO_ERROR;
    }

    // Clean up the Parsed Path
    if (pParsedPath)
    {
        objpathParser.Free( pParsedPath );
    }

    Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::ExecMethodAsync
//
//  Locates the provider for the specified class name and
//  calls its ExecMethod function.
//
//  Inputs:
// const BSTR ObjectPath,  - Object path on which to execute the method
// const BSTR MethodName,  - Name of the method to execute
// long lFlags,      - Any flags
// IWbemContext __RPC_FAR *pCtx,
// IWbemClassObject __RPC_FAR *pInParams,  - Pointer to IWbemClassObject
//                                           that contains parms
// IWbemObjectSink __RPC_FAR *pResponseHandler)
//
//  Outputs:    None.
//
//  Returns:    SCCODE      - COM Status.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

HRESULT CWbemProviderGlue::ExecMethodAsync(

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
    // make sure we don't disappear while running
    AddRef();

    CSetStructuredExceptionHandler t_ExceptionHandler;

#ifdef PROVIDER_INSTRUMENTATION
    StopWatch stopWatch(CHString(IDS_EXECMETHODASYNC) + CHString(ObjectPath) + CHString(MethodName));
    stopWatch.Start(StopWatch::FrameworkTimer);
#endif

    HRESULT             hr = WBEM_E_FAILED;
    bool bLocalError = false;
    IWbemClassObjectPtr pStatusObject;

    ParsedObjectPath *pParsedPath = NULL;
    CObjectPathParser   objpathParser;

    try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage4(L"%s%s.%s", IDS_EXECMETHODASYNC, ObjectPath, MethodName);
        }

        // Parse the object path passed to us by CIMOM
        // ==========================================
        int nStatus = objpathParser.Parse( ObjectPath,  &pParsedPath );

        if ( 0 == nStatus )
        {
            // Now try to find the provider based on the class name
            // pProvider doesn't get addref'ed, so no release necessary
            Provider *pProvider = SearchMapForProvider( pParsedPath->m_pClass, m_strNamespace );

            // If we got a provider, let it handle itself like a grown-up provider
            // should.

            if ( NULL != pProvider )
            {
                IWbemClassObjectPtr pOutClass;
                IWbemClassObjectPtr pOutParams;
                CInstancePtr COutParam;
                CInstancePtr CInParam;
                hr = WBEM_S_NO_ERROR;

                 // Now create an External Method Context object and go to town
                ExternalMethodContextPtr  pContext (new ExternalMethodContext( pResponseHandler, pCtx, this ), false);
#ifdef PROVIDER_INSTRUMENTATION
                pContext->pStopWatch = &stopWatch;
#endif

                // Check for out of memory
                if (NULL == pContext)
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                // add check to ensure that we do not call a static method
                // on an instance of a class.
                if (SUCCEEDED(hr) && pParsedPath->IsInstance())
                {
                    IWbemClassObjectPtr pObj(pProvider->GetClassObjectInterface(pContext), false);
                    if (pObj)
                    {
                        IWbemQualifierSetPtr pSet;
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                        if (SUCCEEDED(pObj->GetMethodQualifierSet(MethodName, &pSet)))
                        {
                        // disallow an instance to invoke a static method
#ifdef PROVIDER_INSTRUMENTATION
                            stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                            if (SUCCEEDED(pSet->Get( IDS_Static, 0, NULL, NULL)))
                                hr = WBEM_E_INVALID_METHOD;
#ifdef PROVIDER_INSTRUMENTATION
                                stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                        }
                    }
                }

                // If there are in params, convert them to a cinstance.
                if (SUCCEEDED(hr) && (NULL != pInParams) )
                {
                    CInParam.Attach(new CInstance(pInParams, pContext));

                    if (NULL == CInParam)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }

                // Get the output class for the method
                if (SUCCEEDED(hr))
                {
                    IWbemClassObjectPtr pObj(pProvider->GetClassObjectInterface(pContext), false);
                    if (pObj != NULL)
                    {
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                    hr = pObj->GetMethod(MethodName, 0, NULL, &pOutClass);
#ifdef PROVIDER_INSTRUMENTATION
                    stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                    }
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }
                }

                // If there is no output class, pOutClass is null (by design).  So, if there was no error
                // and we got an pOutClass, get an instance and wrap it in a CInstance
                if (SUCCEEDED(hr) && (pOutClass != NULL))
                {
#ifdef PROVIDER_INSTRUMENTATION
                    stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
                    hr = pOutClass->SpawnInstance(0, &pOutParams);
#ifdef PROVIDER_INSTRUMENTATION
                    stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                    if (SUCCEEDED(hr))
                    {
                        COutParam.Attach(new CInstance(pOutParams, pContext));

                        // Out of memory
                        if (NULL == COutParam)
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                }

                if ( SUCCEEDED(hr) )
                {
					CWbemGlueImpersonation impersonate;
                    if SUCCEEDED ( hr = impersonate.IsImpersonated () )
                    {
                        // Set up to call FlushAll
                        AddFlushPtr(pProvider);

                        WCHAR wszName[UNLEN + DNLEN + 1 + 1] = {0};
                        WCHAR wszName2[UNLEN + DNLEN + 1 + 1] = {0};  // domain + \ + name + null
                        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName, &dwLen);

                        hr = pProvider->ExecMethod( pParsedPath, MethodName, lFlags, CInParam, COutParam, pContext );

                        dwLen = UNLEN + DNLEN + 1 + 1;

                        GetUserNameEx(NameSamCompatible, wszName2, &dwLen);

                        if (wcscmp(wszName, wszName2) != 0)
                        {
                            ASSERT_BREAK(IMPERSONATION_REVERTED);
                            LogErrorMessage5(L"Warning! User name at exit (%s) != user name at entry (%s) for %s.%s",
                                wszName2, wszName, ObjectPath, MethodName);
                        }
                    }
                }

                // If there is an output object
                if (COutParam != NULL)
                {

                    // Only send back an output object if the method succeeded
                    if (SUCCEEDED(hr))
                    {

                        // Send the object back
                        IWbemClassObjectPtr pObj(COutParam->GetClassObjectInterface(), false);
                        IWbemClassObject *pObj2 = (IWbemClassObject *)pObj;
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif

                        pResponseHandler->Indicate( 1, &pObj2);
#ifdef PROVIDER_INSTRUMENTATION
                        stopWatch.Start(StopWatch::FrameworkTimer);
#endif
                    }
                }

                pStatusObject.Attach(pContext->GetStatusObject());

            }
            else
            {
                LogErrorMessage3(L"%s (%s)", IDS_PROVIDERNOTFOUND, pParsedPath->m_pClass);
                hr = WBEM_E_INVALID_CLASS;
                bLocalError = true;
            }

        }
        else
        {
            LogErrorMessage3(L"%s (%s)", IDS_COULDNOTPARSE, ObjectPath);
            bLocalError = true;
        }

        if (IsVerboseLoggingEnabled())
        {
            if (SUCCEEDED(hr))
                LogMessage4(L"%s%s.%s - Succeeded", IDS_EXECMETHODASYNC, ObjectPath, MethodName);
            else
                LogMessage5(L"%s%s.%s - FAILED (%x)", IDS_EXECMETHODASYNC, ObjectPath, MethodName, hr);
        }
    }

    catch ( CFramework_Exception e_FR )
    {
        ASSERT_BREAK(FRAMEWORK_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( CHeap_Exception e_HE )
    {
        ASSERT_BREAK(MEMORY_EXHAUSTED);
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(CStructured_Exception e_SE)
    {
        ASSERT_BREAK(STRUCTURED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }
    catch ( ... )
    {
        ASSERT_BREAK(UNSPECIFIED_EXCEPTION);
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    if ((hr != WBEM_E_INVALID_CLASS) && (hr != WBEM_E_UNSUPPORTED_PARAMETER) && !bLocalError)
    {
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::WinMgmtTimer);
#endif
        pResponseHandler->SetStatus( 0, hr, NULL, pStatusObject );
#ifdef PROVIDER_INSTRUMENTATION
        stopWatch.Start(StopWatch::FrameworkTimer);
#endif
        hr = WBEM_S_NO_ERROR;
    }

    // Clean up the Parsed Path
    if (pParsedPath)
    {
        objpathParser.Free( pParsedPath );
    }

    Release();

#ifdef PROVIDER_INSTRUMENTATION
    stopWatch.Stop();
    stopWatch.LogResults();
#endif

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetNamespaceConnection
//
//  Establishes a connection to the supplied namespace by first
//  assigning a default if needed, then searching our map, and if
//  that fails, then actually connecting.
//
//  Inputs:     const BSTR  NameSpace - NameSpace of provider
//
//  Outputs:    None.
//
//  Returns:    IWbemServices *pointer to IWbemServices corresponding
//                              to the connected namespace.
//
//  Comments:   Default Namespace is Root\\Default
//
//
/////////////////////////////////////////////////////////////////////

IWbemServices *CWbemProviderGlue::GetNamespaceConnection(

    LPCWSTR pwszNameSpace
)
{
    ASSERT_BREAK(DEPRECATED);

    bstr_t  bstrNamespace(pwszNameSpace);

    // Root\CimV2 is the default name space
    if (    NULL    ==  pwszNameSpace
        ||  L'\0'   ==  *pwszNameSpace )
    {
        bstrNamespace = DEFAULT_NAMESPACE;
    }

    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s%s", IDS_GETNAMESPACECONNECTION, (LPCWSTR)bstrNamespace);
    }

    IWbemLocatorPtr pIWbemLocator;
    IWbemServices *pWbemServices = NULL;

    HRESULT hRes = CoCreateInstance (

        CLSID_WbemLocator, //CLSID_WbemAdministrativeLocator,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_IUnknown,
        ( void ** ) &pIWbemLocator
        ) ;

    if (SUCCEEDED(hRes))
    {
        hRes = pIWbemLocator->ConnectServer(bstrNamespace,  // Namespace
            NULL,          // Userid
            NULL,           // PW
            NULL,           // Locale
            0,              // flags
            NULL,           // Authority
            NULL,           // Context
            &pWbemServices
            );

        if (SUCCEEDED(hRes))
        {
        }
        else
        {
            LogErrorMessage3(L"Failed to Connectserver to namespace %s (%x)", (LPCWSTR)bstrNamespace, hRes);
        }
    }
    else
    {
        LogErrorMessage2(L"Failed to get locator (%x)", hRes);
    }

    return pWbemServices;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLogin
//
//  Static entry point for providers to login to the framework,
//  providing us with info for our map, and allowing us to return
//  an IWbemServices pointer for the base provider class to
//  manipulate to its heart's content.
//
//  Inputs:     LPCWSTR&       strName - Name of object for map.
//              Provider *pProvider - Pointer Name Maps to.
//              LPCWSTR          pszNameSpace - NameSpace of provider
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   None.
//
//
/////////////////////////////////////////////////////////////////////
void CWbemProviderGlue::FrameworkLogin(

    LPCWSTR      a_szName,
    Provider     *a_pProvider,
    LPCWSTR      a_pszNameSpace
)
{
    if (IsVerboseLoggingEnabled())
    {
        if (a_pszNameSpace != NULL)
        {
            LogMessage4(L"%s%s:%s", IDS_FRAMEWORKLOGIN, a_pszNameSpace, a_szName);
        }
        else
        {
            LogMessage4(L"%s%s:%s", IDS_FRAMEWORKLOGIN, DEFAULT_NAMESPACE, a_szName);
        }
    }

    // AddProviderToMap, searches the Map for a match first.
    // If one is found, it does not perform the actual add.
    // Check that the pointers are the same.  If they're
    // different, this is what happened.

    // pProvider doesn't get addref'ed, so no release necessary
    Provider *t_pTestProvider = AddProviderToMap( a_szName, a_pszNameSpace, a_pProvider );

    if ( t_pTestProvider != a_pProvider )
    {
        // this should never happen
        // a provider should login only once at construction and out at destruction
        // this should coincide with DLLs being loaded and unloaded.
        LogErrorMessage4(L"%s (%s:%s)", IDS_LOGINDISALLOWED, a_pszNameSpace, a_szName);
        ASSERT_BREAK( FALSE );
    }

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLogoff
//
//  Static entry point for providers to log out of the framework,
//  this should be called from the provider's dtor so that we release
//  all of our pointers so they don't dangle.
//
//  Inputs:     LPCWSTR&       strName - Name of object for map.
//              LPCWSTR          pszNameSpace - NameSpace of provider
//
//  Outputs:    None.
//
//  Returns:    usually.
//
//  Comments:   We don't bother removing entries from the namespace map.
//
//
/////////////////////////////////////////////////////////////////////
void CWbemProviderGlue::FrameworkLogoff(

    LPCWSTR a_pszName,
    LPCWSTR a_pszNamespace
)
{
    STRING2LPVOID::iterator      mapIter;

	try
	{
		if (IsVerboseLoggingEnabled())
		{
			LogMessage3(L"%s%s", IDS_FRAMEWORKLOGOFF, a_pszName);
		}

		BOOL bDone = FALSE;
		CHString    strQualifiedName;

		do
		{
			try
			{
				strQualifiedName = a_pszName;
				bDone = TRUE;
			}
			catch ( CHeap_Exception e_HE )
			{
				// resources could be eventually back
				::Sleep ( 1000 );
			}
		}
		while ( !bDone );
		bDone = FALSE;

		// If our NameSpace is non-NULL (we use DEFAULT_NAMESPACE then), AND it
		// is not DEFAULT_NAMESPACE, concat the namespace to the provider name
		// so we can differentiate providers across namespaces.

		if (    (a_pszNamespace != NULL) && (a_pszNamespace[0] != L'\0')
			&&  0   !=  _wcsicmp(a_pszNamespace, DEFAULT_NAMESPACE ) )
		{
			do
			{
				try
				{
					strQualifiedName += a_pszNamespace;
					bDone = TRUE;
				}
				catch ( CHeap_Exception e_HE )
				{
					// resources could be eventually back
					::Sleep ( 1000 );
				}
			}
			while ( !bDone );
			bDone = FALSE;
		}

		// Convert characters to upper case before searching for
		// them in the map.  Since we convert to upper case when
		// we store the map associations, this effectively makes
		// us case-insensitive.

		strQualifiedName.MakeUpper();

		EnterCriticalSectionWait	ecs ( &s_csProviderMap );
		LeaveCriticalSectionScope	lcs ( &s_csProviderMap );

        if( ( mapIter = s_providersmap.find( strQualifiedName ) ) != s_providersmap.end() )
            s_providersmap.erase(mapIter);
        else
            ASSERT_BREAK(0 /* did not find provider to log off!*/);
    }
    catch ( ... )
    {
		// we should not be here
		// do not re-throw (called from destructor)
    }
}


/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllInstances
//
//  Static entry point for providers to obtain instance lists from
//  other providers.
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get list for.
//              TRefPointerCollection<CInstance> *pList - List to fill.
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllInstances(

    LPCWSTR                               pszClassName,
    TRefPointerCollection<CInstance>      *pList,
    LPCWSTR                               pszNamespace,   /* = NULL*/
    MethodContext                         *pMethodContext        /* = NULL*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    if (pszClassName)
    {
        CHString sQuery;

        sQuery.Format(L"SELECT * FROM %s where __CLASS = \"%s\"", pszClassName, pszClassName);
        hr = GetInstancesByQuery( sQuery, pList, pMethodContext, pszNamespace);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllInstancesAsynch
//
//  Static entry point for providers to obtain instances from
//  other providers. Note that this is not, strictly speaking,
//  an asynchronous implementation - it does HELP the asynch calls
//  in that it does not build a big list and that the callback allows
//  the provider to respond asynchronously
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get instances from.
//
//              Provider *      this is the "this" pointer for the requester
//              LPProviderInstanceCallback callback function to eat the instances provided
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//              this puppy shares a lot of code with GetAllInstances, but I
//              can't find a clean way to combine them.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllInstancesAsynch(

    LPCWSTR pszClassName,
    Provider *pRequester,
    LPProviderInstanceCallback pCallback,
    LPCWSTR pszNamespace,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (pszClassName)
    {
        CHString sQuery;
        sQuery.Format(L"SELECT * FROM %s where __CLASS = \"%s\"", pszClassName, pszClassName);
        hr = GetInstancesByQueryAsynch( sQuery, pRequester, pCallback, pszNamespace, pMethodContext, pUserData);

        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllDerivedInstances
//
//  Static entry point for providers to obtain instance lists from
//  other providers. This one will return all instances derived from
//  the base class passed in.
//
//  Inputs:     LPCWSTR          pszBaseClassName - Name of base class
//                              to get list for.
//              TRefPointerCollection<CInstance> *pList - List to fill.
//              LPCWSTR          pszNamespace - Namespace of provider.
//              MethodContext *pMethodContext, // must not be NULL
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllDerivedInstances(

    LPCWSTR pszBaseClassName,
    TRefPointerCollection<CInstance> *pList,
    MethodContext *pMethodContext,
    LPCWSTR pszNamespace
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (pszBaseClassName)
    {
        CHString sQuery;
        sQuery.Format(L"SELECT * FROM %s", pszBaseClassName);
        hr = GetInstancesByQuery( sQuery, pList, pMethodContext, pszNamespace);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetAllDerivedInstancesAsynch
//
//  Static entry point for providers to obtain instances from
//  other providers. Note that this is not, strictly speaking,
//  an asynchronous implementation - it does HELP the asynch calls
//  in that it does not build a big list and that the callback allows
//  the provider to respond asynchronously
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get instances from.
//
//              Provider*       this is the "this" pointer for the requester
//              LPProviderInstanceCallback callback function to eat the instances provided
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//              this puppy shares a lot of code with GetAllInstances, but I
//              can't find a clean way to combine them.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetAllDerivedInstancesAsynch(

    LPCWSTR pszProviderName,
    Provider *pRequester,
    LPProviderInstanceCallback pCallback,
    LPCWSTR pszNamespace,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (pszProviderName)
    {
        CHString sQuery;
        sQuery.Format(L"SELECT * FROM %s", pszProviderName);
        hr = GetInstancesByQueryAsynch( sQuery, pRequester, pCallback, pszNamespace, pMethodContext, pUserData);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstancesByQuery
//
//  Static entry point for providers to obtain instance lists from
//  other providers. This one will return all instances matching a query.
//
//  Inputs:     LPCWSTR          Query to execute "Select * from win32_foo where bar = "baz""
//              TRefPointerCollection<CInstance> *pList - List to fill.
//              MethodContext *pMethodContext, // must not be NULL
//              LPCWSTR          pointer to namespace - may be NULL (means default -- root\cimv2)
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstancesByQuery( LPCWSTR query,
                                               TRefPointerCollection<CInstance> *pList,
                                               MethodContext *pMethodContext,
                                               LPCWSTR   pszNamespace    /* = NULL*/)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s (%s)", IDS_GETINSTANCESBYQUERY, query);
    }

    HRESULT hr = WBEM_E_FAILED;

    if ( (query != NULL) &&
         (pList != NULL) &&
         (pMethodContext != NULL) )
    {
        IEnumWbemClassObjectPtr pEnum;

        IWbemContextPtr pWbemContext;
        if (pMethodContext)
        {
            pWbemContext.Attach(pMethodContext->GetIWBEMContext());
        }

        IWbemServicesPtr piService;

        // get a service interface
        if (pszNamespace == NULL || pszNamespace[0] == L'\0')
        {
            piService.Attach(GetNamespaceConnection(NULL, pMethodContext));
        }
        else
        {
            piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext));
        }

        if ( piService != NULL)
        {
            {
                // Assures that impersonation goes
                // back to the way it was before the
                // call to CIMOM.
                CAutoImpRevert air;
                DWORD dwImpErr = air.LastError();
                if(dwImpErr == ERROR_SUCCESS)
                {
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                    hr = piService->ExecQuery(bstr_t(IDS_WQL), bstr_t(query), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, pWbemContext, &pEnum);
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                }
                else
                {
                    LogErrorMessage2(L"Failed to open current thread token for checking impersonation, with error %d", dwImpErr);
                    hr = WBEM_E_FAILED;
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                IWbemClassObjectPtr pObj;
                ULONG nReturned;

                // author's apology:
                //      we loop through, using Next() to get each instance
                //      we bail when we get WBEM_S_FALSE because that's the end of the enumeration
                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                for (hr = pEnum->Next(GLUETIMEOUT, 1, &pObj, &nReturned);
                    (SUCCEEDED(hr) && (hr != WBEM_S_FALSE) && (hr != WBEM_S_TIMEDOUT) ) ;
                    hr = pEnum->Next(GLUETIMEOUT, 1, &pObj, &nReturned))
                {
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                    if (pObj != NULL && nReturned)
                    {
                        CInstancePtr pInstance(new CInstance(pObj, pMethodContext), false);

                        if (pInstance != NULL)
                        {
                            // Check to see if adding to the list succeeds
                            if (!pList->Add(pInstance))
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

                    }
                }

                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

                // the Next will return WBEM_S_FALSE when it is done.  However, that
                // means that THIS function had no error.
                if (hr == WBEM_S_FALSE)
                {
                    hr = WBEM_S_NO_ERROR;
                }
                // fencepost check - the last error might have been access denied
                // but it's okay if we got any instances at all
                else if (hr == WBEM_E_ACCESS_DENIED)
                    if (pList->GetSize() > 0)
                        hr = WBEM_S_NO_ERROR;


            }   // IF SUCCEEDED
        }
        else
            LogErrorMessage(IDS_FAILED);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetInstancesByQuery");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    if (IsVerboseLoggingEnabled())
    {
        if (SUCCEEDED(hr))
        {
            LogMessage3(L"%s (%s) - Succeeded", IDS_GETINSTANCESBYQUERY, query);
        }
        else
        {
            LogMessage4(L"%s (%s) - FAILED (%x)", IDS_GETINSTANCESBYQUERY, query, hr);
        }
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::IsDerivedFrom
//
//  Static entry point for providers to obtain derivation information
//
//  Inputs:     LPCWSTR          pszBaseClassName - Name of base class
//              LPCWSTR          pszDerivedClassName - Name of class we're testing
//              MethodContext   *pMethodContext
//
//  Outputs:    None.
//
//  Returns:    true iff pszDerivedClassName is derived from pszBaseClassName
//
//  Comments:   This function cannot short circuit, because a derived class may be external
//
/////////////////////////////////////////////////////////////////////

bool CWbemProviderGlue::IsDerivedFrom(

    LPCWSTR pszBaseClassName,
    LPCWSTR pszDerivedClassName,
    MethodContext *pMethodContext,
    LPCWSTR   pszNamespace    /* = NULL*/
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    bool bRet = false;

    if ( (pszBaseClassName != NULL) &&
         (pszDerivedClassName != NULL) &&
         (pMethodContext != NULL) )
    {
        IWbemServicesPtr piService;

        // get a service interface
        piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext ));

        // find the derived class object
        if (piService != NULL)
        {
            IWbemClassObjectPtr pObj;
            IWbemContextPtr pWbemContext;
            if (pMethodContext)
            {
                pWbemContext.Attach(pMethodContext->GetIWBEMContext());
            }

            PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
            HRESULT hr = piService->GetObject( bstr_t( pszDerivedClassName ), 0, pWbemContext, &pObj, NULL);
            PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

            if (SUCCEEDED(hr) && (pObj != NULL))
            {
                // Variant_t handles the VariantInit/VariantClear
                variant_t v;

                if (SUCCEEDED(pObj->Get((unsigned short *)IDS_DERIVATION, 0, &v, NULL, NULL)))
                {
                    BSTR bstrTemp = NULL;
                    SAFEARRAY *psa = V_ARRAY(&v);
                    LONG uBound;
                    SafeArrayGetUBound(psa, 1, &uBound);

                    // if base class is in the list in the derivation, we're true!
                    for (LONG i = 0; !bRet && (i <= uBound); i++)
                    {
						if (SUCCEEDED(SafeArrayGetElement( psa, &i, &bstrTemp )))
						{
							OnDeleteIf<BSTR,VOID(*)(BSTR),SysFreeString> smartbstrTemp(bstrTemp);
                            bRet = (_wcsicmp(pszBaseClassName, bstrTemp) == 0);
						}
                    }
                }
            }
        }
    }
    else
    {
        LogErrorMessage(L"NULL parameter to IsDerivedFrom");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetEmptyInstance
//
//  Static entry point for providers to obtain a single empty instance
//  of a provider object.
//
//  Inputs:     LPCWSTR          pszProviderName - Name of provider to
//                              get list for.
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    CInstance       **ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////
//      DEPRECATED
HRESULT WINAPI CWbemProviderGlue::GetEmptyInstance(

    LPCWSTR       pszClassName,
    CInstance **ppInstance,
    LPCWSTR       pszNamespace
)
{
    ASSERT_BREAK(DEPRECATED);

    HRESULT      hr = WBEM_E_INVALID_CLASS;

    if ( (pszClassName != NULL) &&
         (ppInstance != NULL) )
    {
        // Search for the class name in our map of providers, we know which
        // namespace we are when we get constructed.

        // pProvider doesn't get addref'ed, so no release is necessary
        Provider *pProvider = SearchMapForProvider( pszClassName, pszNamespace );

        if ( NULL != pProvider )
        {
            // Now create an Internal Method Context object, since this function
            // only gets called internal to our DLL.  Using a NULL for the
            // list pointer, essentially creates a dummy context so we can
            // do our commit dance as painlessly as possible.

            InternalMethodContextPtr pContext (new InternalMethodContext( NULL, NULL, NULL ), false);

            if ( NULL != pContext )
            {
                // Assume things will go wrong like a good liitle paranoiac
                hr = WBEM_E_FAILED;

                // Before asking for a new instance, we MUST verify that the
                // provider has a valid IMOS pointer.  If it does'nt, CreateNewInstance
                // may GPF (this is a safety check we must do because of our
                // little short circuit.

                // We don't do short circuits anymore.
//                if ( pProvider->ValidateIMOSPointer() )
                {
                    // Set the error code appropriately depending on whether or
                    // not the Instance gets created correctly.

                    // The instance returned will have been AddRefed, so it will
                    // be up to the caller to Release() it.

                    if ( ( *ppInstance = pProvider->CreateNewInstance( pContext ) ) != NULL )
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
		else
		{
			hr = WBEM_E_INVALID_CLASS;
		}
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetEmptyInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetEmptyInstance
//
//  Static entry point for providers to obtain a single empty instance
//  of a provider object.  This alternate form makes a call back
//  into WINMGMT.
//
//  Inputs:     MethodContext    *Context object for this call
//              LPCWSTR          pszProviderName - Name of provider to
//                               get instance of.
//              LPCWSTR          pszNamespace - Namespace of class.
//
//  Outputs:    CInstance       **ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetEmptyInstance(

    MethodContext   *pMethodContext,
    LPCWSTR         pszProviderName,
    CInstance       **ppOutInstance,
    LPCWSTR         a_pszNamespace
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT hr = WBEM_E_FAILED;

    if ( (pMethodContext != NULL) &&
         (pszProviderName != NULL) &&
         (ppOutInstance != NULL) )
    {

        CInstancePtr pClassInstance;

        hr = GetInstanceFromCIMOM(pszProviderName, a_pszNamespace, pMethodContext, &pClassInstance);

        if (SUCCEEDED(hr))
        {
            IWbemClassObjectPtr pClassObject(pClassInstance->GetClassObjectInterface(), false);
            if (pClassObject != NULL)
            {
                IWbemClassObjectPtr pObj;
                hr = pClassObject->SpawnInstance(0, &pObj);

                if (SUCCEEDED(hr))
                {
                    *ppOutInstance = new CInstance(pObj, pMethodContext);
                    if (*ppOutInstance == NULL)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
            }
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetEmptyInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FillInstance
//
//  Static entry point for providers to pass us an instance with
//  key data filled out, which we will use to locate the correct
//  provider and ask it to fill out completely.
//
//  Inputs:     CInstance        *pInstance - Instance to fill out.
//              LPCWSTR          pszNamespace - Namespace for provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////
//        DEPRECATED!
HRESULT WINAPI CWbemProviderGlue::FillInstance(

    CInstance *pInstance,
    LPCWSTR   pszNamespace /*= NULL*/
)
{
    ASSERT_BREAK(DEPRECATED);

    HRESULT      hr = WBEM_E_FAILED;

    if (pInstance != NULL)
    {
        // Check that we have an instance pointer, then pull out the
        // class name and name space.  From there we can find the
        // appropriate provider and ask it to get the object.

        if ( NULL != pInstance )
        {
            CHString strProviderName;
            pInstance->GetCHString( IDS_CLASS, strProviderName );

            // Search for the class name in our map of providers, we know which
            // namespace we are when we get constructed.

            // pProvider is not addref'ed, so no release is necessary
            Provider *pProvider = SearchMapForProvider( strProviderName, pszNamespace );

            if ( NULL != pProvider )
            {
                // Pass the pInstance off to the provider and let it take care
                // of obtaining the correct values.

                hr = pProvider->GetObject( pInstance );
            }
            else
            {
                hr = WBEM_E_INVALID_CLASS;
            }
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to FillInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FillInstance
//
//  Static entry point for providers to pass us an instance with
//  key data filled out, use to make a call back into winmgmt.
//
//  Inputs:     MethodContext *Context object for this call
//              CInstance     *pInstance - Instance to fill out.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::FillInstance(

    MethodContext *pMethodContext,
    CInstance     *pInstance
)
{
    ASSERT_BREAK(DEPRECATED);

    HRESULT      hr = WBEM_E_FAILED;

    if ( (pMethodContext != NULL) &&
         (pInstance != NULL) )
    {
        // Check that we have an instance pointer, then pull out the path
        // and send it to cimom.
        CHString strPathName;

        pInstance->GetCHString( L"__RELPATH", strPathName );
        hr = GetInstanceByPath(strPathName, &pInstance, pMethodContext);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to FillInstance");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstanceKeysByPath
//
//  Static entry point for providers to pass us an instance path
//  to retrieve.  This class uses per-property gets to request
//  only the keys on the object we are retrieving.
//
//  Inputs:     pszInstancePath Object path to retrieve
//              CInstance     *pInstance - Instance to fill out.
//              MethodContext *Context object for this call
//
//  Outputs:    None
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstanceKeysByPath(

    LPCWSTR           pszInstancePath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( (pMethodContext != NULL) &&
         (pszInstancePath != NULL) &&
         (ppInstance != NULL) )
    {

        IWbemContextPtr pWbemContext(pMethodContext->GetIWBEMContext(), false);

        // We need to have a real context object, not an internal method context
        if (pWbemContext != NULL)
        {
            VARIANT vValue;
            V_VT(&vValue) = VT_BOOL;
            V_BOOL(&vValue) = VARIANT_TRUE;

            // Set the appropriate properties on the context object
            if ( (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue))) &&
                 (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_KEYS_ONLY", 0L, &vValue))) &&
                 (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_CLIENT_REQUEST", 0L, &vValue))))
            {
                LogMessage2(L"GetInstanceKeysByPath: %s", pszInstancePath);
                hr = GetInstanceByPath(pszInstancePath, ppInstance, pMethodContext);

                V_BOOL(&vValue) = VARIANT_FALSE;
                pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue);
            }
        }
        else
        {
            ASSERT_BREAK(FALSE);
            LogErrorMessage(L"Can't use InternalMethodContext to GetInstanceKeysByPath");
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstancePropertiesByPath
//
//  Static entry point for providers to pass us an instance path
//  to retrieve.  This class uses per-property gets to request
//  only the properties specified in the array.
//
//  Inputs:     pszInstancePath Object path to retrieve
//              CInstance     *pInstance - Instance to fill out.
//              MethodContext *Context object for this call
//              csaProperties Properties to request
//
//  Outputs:    None
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstancePropertiesByPath(

    LPCWSTR           pszInstancePath,
    CInstance **ppInstance,
    MethodContext *pMethodContext,
    CHStringArray &csaProperties
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( (pMethodContext != NULL) &&
         (pszInstancePath != NULL) &&
         (ppInstance != NULL) )
    {

        IWbemContextPtr pWbemContext(pMethodContext->GetIWBEMContext(), false);

        // We need to have a real context object, not an internal method context
        if (pWbemContext != NULL)
        {
            variant_t vValue;
            V_VT(&vValue) = VT_BOOL;
            V_BOOL(&vValue) = VARIANT_TRUE;

            // First set the value that says we are using Get extensions
            if ((SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue))) &&
                (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_CLIENT_REQUEST", 0L, &vValue))) )
            {
                // Delete any unneeded properties
                pWbemContext->DeleteValue(L"__GET_EXT_KEYS_ONLY", 0L);

                // Now build the array of properties
                SAFEARRAYBOUND rgsabound [ 1 ] ;

                rgsabound[0].cElements = csaProperties.GetSize() ;
                rgsabound[0].lLbound = 0 ;
                V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;
                if ( V_ARRAY(&vValue) )
                {
                    V_VT(&vValue) = VT_BSTR | VT_ARRAY;

                    for (long x=0; x < csaProperties.GetSize(); x++)
                    {
                        bstr_t bstrProp = csaProperties[x];

                        SafeArrayPutElement(
                            V_ARRAY(&vValue),
                            &x,
                            (LPVOID) (BSTR) bstrProp);
                    }

                    // Put the array into the context object
                    if (SUCCEEDED(hr = pWbemContext->SetValue(L"__GET_EXT_PROPERTIES", 0L, &vValue)))
                    {
                        LogMessage2(L"GetInstancePropertiesByPath: %s", pszInstancePath);
                        // Make the call
                        hr = GetInstanceByPath(pszInstancePath, ppInstance, pMethodContext);

                        vValue.Clear();
                        V_VT(&vValue) = VT_BOOL;
                        V_BOOL(&vValue) = VARIANT_FALSE;
                        pWbemContext->SetValue(L"__GET_EXTENSIONS", 0L, &vValue);
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
        else
        {
            ASSERT_BREAK(FALSE);
            LogErrorMessage(L"Can't use InternalMethodContext to GetInstanceKeysByPath");
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstanceByPath
//
//  Static entry point for providers to obtain a single empty instance
//  of a provider object.
//
//  Inputs:     LPCWSTR          pszInstancePath - Path to Object.  This
//                              MUST be a full path,
//              MethodContext   *pMethodContext - Method Context containing
//                              (hopefully) the WbemContext we need
//                              to propogate.
//
//  Outputs:    CInstance**     ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//
//  Comments:   This is an internal entry point, allowing providers
//              to short circuit having to go through WBEM to access
//              data from other providers.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstanceByPath(

    LPCWSTR           pszInstancePath,
    CInstance **ppInstance,
    MethodContext *pMethodContext /* = NULL */
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

    HRESULT      hr = WBEM_E_FAILED;

    if ( (pszInstancePath != NULL) &&
         (ppInstance != NULL) )
    {
        CHString strComputerName;
        GetComputerName( strComputerName );

		DWORD dwError = ::GetLastError ();
        if ( ERROR_SUCCESS != dwError )
		{
			// For this revision, we DO NOT support getting paths that are not local.
			// This is because if the machine name is anything other than the local
			// one, we run the risk of freezing while CIMOM goes out and tries to find
			// the machine (up to around 5 minutes according to his Levness.

			ParsedObjectPath *pParsedPath = NULL;
			CObjectPathParser    objpathParser;

			// Parse the object path passed to us by CIMOM
			// ==========================================
			int nStatus = objpathParser.Parse( pszInstancePath,  &pParsedPath );

			if ( 0 == nStatus )
			{
				//
				// smart free for pParsedPath
				//
				OnDeleteObjIf < ParsedObjectPath*, CObjectPathParser, void ( CObjectPathParser:: * ) ( ParsedObjectPath* ) , &CObjectPathParser::Free > SmartFree ( &objpathParser, pParsedPath ) ;

				// Machine names MUST match.  Null indicates no machine name specified.

				if (( pParsedPath->m_pServer == NULL) ||
					( strComputerName.CompareNoCase( pParsedPath->m_pServer ) == 0 ) ||
					( wcscmp(pParsedPath->m_pServer, L".") == 0 )
					)
				{
					// Now try to find the provider based on the class name
					CHString strNamespace;

					// Pull out the name space parts, and concatenate them using a '\\'
					// character.  e.g. root\default.

					for ( DWORD dwCtr = 0; dwCtr < pParsedPath->m_dwNumNamespaces; dwCtr++ )
					{
						if ( dwCtr != 0 )
						{
							strNamespace += L"\\";
						}

						strNamespace += pParsedPath->m_paNamespaces[dwCtr];
					}

					// We need to propogate the Wbem Context if we are going out
					// to CIMOM!

					IWbemContextPtr pWbemContext;
					CWbemProviderGlue *pGlue = NULL;

					if ( NULL != pMethodContext )
					{
						pWbemContext.Attach(pMethodContext->GetIWBEMContext());
						pGlue = pMethodContext->GetProviderGlue();
					}
					else
					{
						ASSERT_BREAK(DEPRECATED);
					}

					InternalMethodContextPtr pInternalContext (
											new InternalMethodContext(
													NULL,
													pWbemContext,
													pGlue), false);

					if ( NULL != pInternalContext )
					{
						hr = GetInstanceFromCIMOM( pszInstancePath, strNamespace, pInternalContext, ppInstance );
					}
					else
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;

					}

				}   // IF Machine Names MATCH
				else
				{
					hr = WBEM_E_INVALID_PARAMETER;  // INVALID MACHINE NAME
				}

			}   // IF nStatus == 0
			else
			{
				hr = WBEM_E_INVALID_OBJECT_PATH;
			}
		}
		else
		{
			// this could be access denied from GetComputeName
			if ( ERROR_ACCESS_DENIED == dwError )
			{
				hr = WBEM_E_ACCESS_DENIED;
			}
			else
			{
				// it is WBEM_E_FAILED
			}
		}
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetInstanceByPath");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstanceFromCIMOM
//
//  Static entry point for providers to obtain a single instance
//  of a WBEM Object. obtaining said object from CIMOM.
//
//  Inputs:     LPCWSTR          pszInstancePath - Path to Object.  This
//                              MUST be a full path,
//              LPCWSTR          pszNameSpace - NameSpace of Object.
//              MethodContext *pMethodContext - Method Context
//
//  Outputs:    CInstance **ppInstance - Pointer to store new
//                              pInstance in.  Must be Released by
//                              caller.
//
//  Returns:    HRESULT         hr - Status code.
//              will return WBEM_E_INVALID_NAMESPACE if it's not a namespace we support
//                  (might otherwise be valid, but not so far as WE are concerned).
//
//  Comments:   This is an internal entry point, allowing providers
//              that failed the short circuit to be propogated
//              by calling into CIMOM.
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstanceFromCIMOM(

    LPCWSTR          pszInstancePath,
    LPCWSTR          pszNamespace,
    MethodContext *pMethodContext,
    CInstance **ppInstance
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
    HRESULT             hr = WBEM_E_FAILED;

    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s (%s)", IDS_INSTANCEFROMCIMOM, pszInstancePath);
    }

    // We need to propogate the Wbem Context (if any) that was passed to
    // us by CIMOM.
    IWbemContextPtr pWbemContext;

    if ( NULL != pMethodContext )
    {
        pWbemContext.Attach(pMethodContext->GetIWBEMContext());
    }
    else
    {
        ASSERT_BREAK(DEPRECATED);
    }

    // If we failed to find the provider, try using CIMOM to do our
    // dirty work for us.

    IWbemServicesPtr    piService;
    IWbemClassObjectPtr piObject;

    // get a service interface
    if ( (pszNamespace == NULL) || (pszNamespace[0] == L'\0' ))
    {
        piService.Attach(GetNamespaceConnection(NULL, pMethodContext));
    }
    else
    {
        piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext ));
    }

    if ( NULL != piService )
    {

        // No go out to CIMOM to get the object, if this succeeds, new an
        // instance and store everything internally.
        {
            // Assures that impersonation goes
            // back to the way it was before the
            // call to CIMOM.
            CAutoImpRevert air;
            DWORD dwImpErr = air.LastError();

            if(dwImpErr == ERROR_SUCCESS)
            {
                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                hr = piService->GetObject( bstr_t(pszInstancePath), 0, pWbemContext, &piObject, NULL );
                PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
            }
            else
            {
                LogErrorMessage2(L"Failed to open current thread token for checking impersonation, with error %d", dwImpErr);
                hr = WBEM_E_FAILED;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            *ppInstance = new CInstance( piObject, pMethodContext );
            if (*ppInstance == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

        }
    }
    else
    {
        LogErrorMessage(IDS_FAILED);
        hr = WBEM_E_INVALID_NAMESPACE;
    }

    if (IsVerboseLoggingEnabled())
    {
        if (SUCCEEDED(hr))
        {
            LogMessage3(L"%s (%s) - Succeeded", IDS_INSTANCEFROMCIMOM, pszInstancePath);
        }
        else
        {
            LogMessage4(L"%s (%s) - FAILED (%x)", IDS_INSTANCEFROMCIMOM, pszInstancePath, hr);
        }
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::SearchMapForProvider
//
//  Searches our Provider map for a match against the supplied
//  provider name/NameSpace combination
//
//  Inputs:     const LPCWSTR& strName - Provider Name to find.
//              const LPCWSTR& strNamespace - Provider's Namespace
//
//  Outputs:    None.
//
//  Returns:    Provider *pointer to a provider that was given to
//                        us by a call to FrameworkLogin.
//
//  Comments:   None.
//
//
/////////////////////////////////////////////////////////////////////

Provider *CWbemProviderGlue::SearchMapForProvider(

    LPCWSTR a_pszProviderName,
    LPCWSTR a_pszNamespace
)
{
    Provider *pProvider   =   NULL;
    STRING2LPVOID::iterator      mapIter;

    // If our NameSpace is non-NULL (we use DEFAULT_NAMEPSACE then), AND it
    // is not DEFAULT_NAMESPACE, concat the namespace to the provider name
    // so we can differentiate providers across namespaces.

    CHString strQualifiedName( a_pszProviderName );
    CHString strLocNamespace( a_pszNamespace );

    if (    !strLocNamespace.IsEmpty()
        &&  0   !=  strLocNamespace.CompareNoCase( DEFAULT_NAMESPACE ) )
    {

        // Convert the / characters to \ for comparison
        WCHAR *pszBuff;
        pszBuff = strLocNamespace.GetBuffer(0);
        while ((pszBuff = wcschr(pszBuff, '/')) != NULL)
        {
            *pszBuff = '\\';
        }
        strLocNamespace.ReleaseBuffer();

        strQualifiedName += strLocNamespace;
    }

    // Convert characters to upper case before searching for
    // them in the map.  Since we convert to upper case when
    // we store the map associations, this effectively makes
    // us case-insensitive.

    strQualifiedName.MakeUpper();

    // Protect the map while we're inside this

    LockProviderMap();
	OnDelete0 < void (__stdcall *)(void), CWbemProviderGlue::UnlockProviderMap> SmartUnlockProviderMap ;

    if( ( mapIter = s_providersmap.find( strQualifiedName ) ) != s_providersmap.end() )
    {
        pProvider = (Provider*) (*mapIter).second;
    }

    return pProvider;

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddProviderToMap
//
//  Adds a provider to our map.  Searches the map first, and if it's
//  not in it, adds it to the map.
//
//  Inputs:     const LPCWSTR strName - Provider Name to Add.
//              const LPCWSTR strNamespace - Namespace for provider.
//              Provider *pProvider - Provider to add to map.
//
//  Outputs:    None.
//
//  Returns:    Provider *pointer to a provider in the map (may
//                              be different from the supplied one)
//
//  Comments:   None.
//
//
/////////////////////////////////////////////////////////////////////

Provider *CWbemProviderGlue::AddProviderToMap(

    LPCWSTR a_szProviderName,
    LPCWSTR a_pszNamespace,
    Provider *a_pProvider
)
{
    STRING2LPVOID::iterator      mapIter;

    // If our NameSpace is non-NULL (we use DEFAULT_NAMEPSACE then), AND it
    // is not DEFAULT_NAMESPACE, concat the namespace to the provider name
    // so we can differentiate providers across namespaces.

    CHString    strQualifiedName( a_szProviderName );

    if ( ( a_pszNamespace != NULL) && (a_pszNamespace[0] != L'\0')
        &&  (0   !=  _wcsicmp(a_pszNamespace, DEFAULT_NAMESPACE )) )
    {
        strQualifiedName += a_pszNamespace;
    }

    // Convert characters to upper case before searching for
    // them in the map.  Since we convert to upper case when
    // we store the map associations, this effectively makes
    // us case-insensitive.

    strQualifiedName.MakeUpper();

    // Protect the map while we're inside this

    Provider *pReturnProvider = NULL;
    LockProviderMap();
	OnDelete0 < void (__stdcall *)(void), CWbemProviderGlue::UnlockProviderMap> SmartUnlockProviderMap ;

    // First check if we've already got a provider.
    if( ( mapIter = s_providersmap.find( strQualifiedName ) ) != s_providersmap.end() )
    {
        pReturnProvider = (Provider*) (*mapIter).second;
		
		//delete it, we're gonna update it shortly
		s_providersmap.erase(mapIter);
    }

    if ( NULL == pReturnProvider )
    {
        pReturnProvider = a_pProvider;
    }

	//add in the newly logged in provider
    s_providersmap[strQualifiedName] = (LPVOID) a_pProvider;

    return pReturnProvider;

}



void CWbemProviderGlue::GetComputerName( CHString& strComputerName )
{
    // Fill the supplied CHString with the local machine name
    DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;

    FRGetComputerName(strComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
    strComputerName.ReleaseBuffer();

    if (strComputerName.IsEmpty())
    {
        strComputerName = L"DEFAULT";
    }
}

BOOL CWbemProviderGlue::FrameworkLoginDLL(LPCWSTR a_pszName)
{
    return CWbemProviderGlue::FrameworkLoginDLL(a_pszName, NULL);
}

BOOL CWbemProviderGlue::FrameworkLogoffDLL(LPCWSTR a_pszNname)
{
      return CWbemProviderGlue::FrameworkLogoffDLL(a_pszNname, NULL);
}

void CWbemProviderGlue::IncrementObjectCount(void)
{
    InterlockedIncrement(&s_lObjects);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage2(L"CWbemProviderGlue::IncrementObjectCount. Count is (approx) %d", s_lObjects);
    }
}

LONG CWbemProviderGlue::DecrementObjectCount(void)
{
    LONG lRet = InterlockedDecrement(&s_lObjects);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage2(L"CWbemProviderGlue::DecrementObjectCount. Count is (approx) %d", s_lObjects);
    }

    return lRet;
}

// checks impersonation level
// impersonates client if allowed
HRESULT WINAPI CWbemProviderGlue::CheckImpersonationLevel()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        HRESULT hRes = WbemCoImpersonateClient();
        if (SUCCEEDED(hRes)) // From cominit.cpp - needed for nt3.51
        {
            // Now, let's check the impersonation level.  First, get the thread token
            HANDLE hThreadTok;
            DWORD dwImp, dwBytesReturned;

            if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hThreadTok
                ))
            {
                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN)
                {
                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    // If we failed to get the thread token for any other reason, log an error.
                    LogErrorMessage2(L"Impersonation failure - OpenThreadToken failed (0x%x)", dwLastError);
                    hr = WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                // We really do have a thread token, so let's retrieve its level

                if (GetTokenInformation(
                    hThreadTok,
                    TokenImpersonationLevel,
                    &dwImp,
                    sizeof(DWORD),
                    &dwBytesReturned
                    ))
                {
                    // Is the impersonation level Impersonate?
                    if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation))
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hr = WBEM_E_ACCESS_DENIED;
                        LogErrorMessage3(L"%s Level(%d)", IDS_ImpersonationFailed, dwImp);
                    }
                }
                else
                {
                    hr = WBEM_E_FAILED;
                    LogErrorMessage3(L"%s Token(%d)", IDS_ImpersonationFailed, GetLastError());
                }

                // Done with this handle
                CloseHandle(hThreadTok);
            }

			if (FAILED(hr))
			{
				WbemCoRevertToSelf();
			}
        }
        else if (hRes == E_NOTIMPL)
        {
            // On 3.51 or vanilla 95, this call is not implemented, we should work anyway
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            LogErrorMessage3(L"%s CoImpersonate(%d)", IDS_ImpersonationFailed, hRes);
        }
    }
    else
    {
        // let win9X in...
        hr = WBEM_S_NO_ERROR;
    }

    if (IsVerboseLoggingEnabled())
    {
        WCHAR wszName[UNLEN + DNLEN + 1 + 1];  // domain + \ + name + null
        DWORD dwLen = UNLEN + DNLEN + 1 + 1;

        if (GetUserNameEx(NameSamCompatible, wszName, &dwLen))
        {
            LogMessage2(L"Impersonation running as: %s", wszName);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetInstancesByQueryAsynch
//
//  Static entry point for providers to obtain instances from
//  other providers. Note that this is not, strictly speaking,
//  an asynchronous implementation - it does HELP the asynch calls
//  in that it does not build a big list and that the callback allows
//  the provider to respond asynchronously
//
//  Inputs:     LPCWSTR          Query to execute "Select * from win32_foo where bar = "baz""
//              Provider *      this is the "this" pointer for the requester
//              LPProviderInstanceCallback callback function to eat the instances provided
//              LPCWSTR          pszNamespace - Namespace of provider.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         hr - Status code.
//
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CWbemProviderGlue::GetInstancesByQueryAsynch(

    LPCWSTR query,
    Provider *pRequester,
    LPProviderInstanceCallback pCallback,
    LPCWSTR pszNamespace,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
    if (IsVerboseLoggingEnabled())
    {
        LogMessage2(L"GetInstancesByQueryAsynch (%s)", query);
    }

    HRESULT         hr = WBEM_E_FAILED;

    if ( (query != NULL) &&
         (pRequester != NULL) &&
         (pCallback != NULL) &&
         (pMethodContext != NULL) )
    {

        // We need to propogate the WBEM context...ESPECIALLY...if we are going out
        // to CIMOM.

        IWbemContextPtr pWbemContext;
        if (pMethodContext)
        {
            pWbemContext.Attach(pMethodContext->GetIWBEMContext());
        }
        else
        {
            ASSERT_BREAK(DEPRECATED);
        }

        // Now create an Internal Method Context object, since this function
        // only gets called internal to our DLLs
        InternalMethodContextAsynchPtr pInternalContext (new InternalMethodContextAsynch(pRequester,
                                                                                        pCallback,
                                                                                        pWbemContext,
                                                                                        pMethodContext,
                                                                                        pUserData), false);

        if ( NULL != pInternalContext )
        {
            // using CIMOM to do our dirty work for us.
            IWbemServicesPtr  piService;

            // get a service interface
            if (pszNamespace == NULL || pszNamespace[0] == L'\0')
            {
                piService.Attach(GetNamespaceConnection(NULL, pMethodContext));
            }
            else
            {
                piService.Attach(GetNamespaceConnection( pszNamespace, pMethodContext ));
            }

            if ( NULL != piService )
            {
                IEnumWbemClassObjectPtr pEnum;
                {
                    // Assures that impersonation goes
                    // back to the way it was before the
                    // call to CIMOM.
                    CAutoImpRevert air;
                    DWORD dwImpErr = air.LastError();

                    if(dwImpErr == ERROR_SUCCESS)
                    {
                        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                        hr = piService->ExecQuery(bstr_t(IDS_WQL),
                            bstr_t(query),
                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            pWbemContext,
                            &pEnum);
                        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                    }
                    else
                    {
                        LogErrorMessage2(L"Failed to open current thread token for checking impersonation, with error %d", dwImpErr);
                        hr = WBEM_E_FAILED;
                    }
                }

                if ( SUCCEEDED( hr ) )
                {
                    IWbemClassObjectPtr pObj;
                    ULONG nReturned;

                    // we retrieve all instances of this class and it's children.  Note that
                    // the next returns WBEM_S_FALSE at the end which PASSES the SUCCEEDED()
                    // test, but fails the pObj test.
                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::WinMgmtTimer);
                    while (SUCCEEDED(hr) && SUCCEEDED(hr = pEnum->Next(GLUETIMEOUT, 1, &pObj, &nReturned)) && (pObj != NULL))
                    {
                        PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);
                        CInstancePtr pInstance(new CInstance(pObj, pMethodContext), false);
                        if (pInstance != NULL)
                        {
                            // For reasons quite beyond me, InternalContext::Commit doesn't
                            // release, but external does.  Note that the smartptr is doing
                            // the release here.
                            hr = pInternalContext->Commit(pInstance);
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }

                    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::FrameworkTimer);

                    // the Next will return WBEM_S_FALSE when it is done.  However, that
                    // means that THIS function had no error.
                    if (hr == WBEM_S_FALSE)
                    {
                        hr = WBEM_S_NO_ERROR;
                    }

                }   // IF SUCCEEDED
            }
            else
            {
                LogErrorMessage(IDS_FAILED);
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
        LogErrorMessage(L"NULL parameter to GetInstancesByQueryAsynch");
        ASSERT_BREAK(WBEM_E_INVALID_PARAMETER);
    }

    if (IsVerboseLoggingEnabled())
    {
        if (SUCCEEDED(hr))
        {
            LogMessage2(L"GetInstancesByQueryAsynch (%s) - Succeeded", query);
        }
        else
        {
            LogMessage3(L"GetInstancesByQueryAsynch (%s) - FAILED (%x)", query, hr);
        }
    }

    PROVIDER_INSTRUMENTATION_START(pMethodContext, StopWatch::ProviderTimer);

    return hr;
}

IWbemServices *CWbemProviderGlue::InternalGetNamespaceConnection(

    LPCWSTR pwszNameSpace
)
{
    IWbemServices *pWbemServices = NULL;

    bstr_t  bstrNamespace;

    // Root\CimV2 is the default name space
    if ( NULL    !=  pwszNameSpace &&  L'\0'   !=  *pwszNameSpace )
    {
        bstrNamespace = pwszNameSpace;
    }
    else
    {
        ASSERT_BREAK(DEPRECATED);
        bstrNamespace = DEFAULT_NAMESPACE;
    }

    if (IsVerboseLoggingEnabled())
    {
        LogMessage3(L"%s%s", IDS_GETNAMESPACECONNECTION, (LPCWSTR)bstrNamespace);
    }

    _wcsupr(bstrNamespace);

    // If we are looking for the namespace our class is in, we already
    // got an IWbemServices pointer for this from Initialize
    if (m_strNamespace.Compare(bstrNamespace) == 0)
    {
        pWbemServices = m_pServices;
        pWbemServices->AddRef();
    }
    else
    {
        IWbemLocatorPtr pIWbemLocator;

        HRESULT hRes = CoCreateInstance (

            CLSID_WbemLocator, //CLSID_WbemAdministrativeLocator,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
            IID_IUnknown,
            ( void ** ) &pIWbemLocator
            ) ;

        if (SUCCEEDED(hRes))
        {
            hRes = pIWbemLocator->ConnectServer(bstrNamespace,  // Namespace
                NULL,          // Userid
                NULL,           // PW
                NULL,           // Locale
                0,              // flags
                NULL,           // Authority
                NULL,           // Context
                &pWbemServices
                );

            if (FAILED(hRes))
            {
                LogErrorMessage3(L"Failed to Connectserver to namespace %s (%x)",
                    (LPCWSTR)bstrNamespace, hRes);
            }
        }
        else
        {
            LogErrorMessage2(L"Failed to get locator (%x)", hRes);
        }
    }

    return pWbemServices;
}

IWbemServices *WINAPI CWbemProviderGlue::GetNamespaceConnection( LPCWSTR wszNameSpace, MethodContext *pMethodContext )
{
    IWbemServices *pServices = NULL;
    CWbemProviderGlue *pGlue = NULL;

    if ( pMethodContext && (pGlue = pMethodContext->GetProviderGlue()) )
    {
        pServices = pGlue->InternalGetNamespaceConnection(wszNameSpace);
    }
    else
    {
        pServices = GetNamespaceConnection(wszNameSpace);
    }

    return pServices;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLoginDLL
//
//  Static entry point for providers to register their DLL with
//  the framework.  This PLONG must be the same one used in
//  FrameworkLogoffDll and as the parameter to the CWbemGlueFactory
//  constructor.
//
/////////////////////////////////////////////////////////////////////

BOOL CWbemProviderGlue::FrameworkLoginDLL(LPCWSTR pszName, PLONG plRefCount)
{
    BOOL bRet = TRUE;
    LogMessage3(L"%s%s", IDS_DLLLOGGED, pszName);

    // If this *is* null, that means we are using the backword compatibility
    // version of FrameworkLoginDLL, which uses CWbemProviderGlue::s_lObjects
    // which has already been initialized.
    if (plRefCount != NULL)
    {
        *plRefCount = 0;
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::FrameworkLogoffDLL
//
//  Static entry point for providers to determine whether they
//  should return TRUE to DllCanUnloadNow.  This PLONG must be the
//  same one used in FrameworkLoginDLL and as the parameter to the
//  CWbemGlueFactory constructor.
//
/////////////////////////////////////////////////////////////////////

BOOL CWbemProviderGlue::FrameworkLogoffDLL(LPCWSTR pszName, PLONG plRefCount)
{
    BOOL bRet = TRUE;

    LogMessage3(L"%s%s", IDS_DLLUNLOGGED, pszName);

    // If this *is* null, that means we are using the backword compatibility
    // version of FrameworkLoginDLL
    if (plRefCount != NULL)
    {
        bRet = *plRefCount == 0;
    }
    else
    {
        bRet = CWbemProviderGlue::s_lObjects == 0;
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddToFactoryMap
//
//  Adds a new CWbemGlueFactory to the s_factorymap map.
//
/////////////////////////////////////////////////////////////////////

VOID CWbemProviderGlue::AddToFactoryMap(const CWbemGlueFactory *pGlue, PLONG plRefCount)
{
    LockFactoryMap();
	OnDelete0 < void (__stdcall *)(void), CWbemProviderGlue::UnlockFactoryMap> SmartUnlockFactoryMap ;

    // If this *is* null, that means we are using the backword compatibility
    // version of FrameworkLoginDLL
    if (plRefCount != NULL)
    {
        CWbemProviderGlue::s_factorymap[pGlue] = plRefCount;
    }
    else
    {
        CWbemProviderGlue::s_factorymap[pGlue] = &CWbemProviderGlue::s_lObjects;
    }
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::RemoveFromFactoryMap
//
//  Removes a CWbemGlueFactory from the s_factorymap map.
//
/////////////////////////////////////////////////////////////////////

VOID CWbemProviderGlue::RemoveFromFactoryMap(const CWbemGlueFactory *pGlue)
{
	EnterCriticalSectionWait	ecs ( &s_csFactoryMap );
	LeaveCriticalSectionScope	lcs ( &s_csFactoryMap );

    try
    {
        bool bFound = false;
        PTR2PLONG::iterator mapIter;

        mapIter = s_factorymap.find(pGlue);

        if ( mapIter != s_factorymap.end() )
        {
            s_factorymap.erase(mapIter);
        }
        else
        {
            LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
        }
    }
    catch( ... )
    {
		// we should not be here
		// do not re-throw (called from destructor)
    }
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::IncrementMapCount
//
//  Increments the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::IncrementMapCount(const CWbemGlueFactory *pGlue)
{
    LONG lRet = -1;
    LockFactoryMap();
	OnDelete0 < void (__stdcall *)(void), CWbemProviderGlue::UnlockFactoryMap> SmartUnlockFactoryMap ;

    PTR2PLONG::iterator mapIter;
    mapIter = CWbemProviderGlue::s_factorymap.find( pGlue );

    if (mapIter != CWbemProviderGlue::s_factorymap.end())
    {
        lRet = InterlockedIncrement((*mapIter).second);
    }
    else
    {
        // This is very bad.  This should have been created
        // at CWbemGlueFactory constructor time.
        LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
    }

	return lRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::IncrementMapCount
//
//  Increments the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::IncrementMapCount(PLONG pCount)
{
    return InterlockedIncrement(pCount);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::DecrementMapCount
//
//  Decrements the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::DecrementMapCount(const CWbemGlueFactory *pGlue)
{
    LONG lRet = -1;

	EnterCriticalSectionWait	ecs ( &s_csFactoryMap );
	LeaveCriticalSectionScope	lcs ( &s_csFactoryMap );

    try
    {
        // Find the matching CWbemGlueFactory in the CWbemGlueFactory<->refcount map
        PTR2PLONG::iterator mapIter;
        mapIter = CWbemProviderGlue::s_factorymap.find( pGlue );

        if (mapIter != CWbemProviderGlue::s_factorymap.end())
        {
            lRet = InterlockedDecrement((*mapIter).second);

            if (lRet < 0)
            {
                LogErrorMessage2(L"RefCount < 0 for glue %p", pGlue);
                ASSERT_BREAK(DUPLICATE_RELEASE);
            }
        }
        else
        {
            LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
        }
    }
    catch ( ... )
    {
		// we should not be here
		// do not re-throw (called from destructor)
    }

    return lRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::DecrementMapCount
//
//  Decrements the refcount on a DLL
//
/////////////////////////////////////////////////////////////////////

LONG CWbemProviderGlue::DecrementMapCount(PLONG pCount)
{
    LONG lRet = InterlockedDecrement(pCount);

	try
	{
		if (lRet < 0)
		{
			LogErrorMessage2(L"RefCount < 0 for %p", pCount);
			ASSERT_BREAK(DUPLICATE_RELEASE);
		}
	}
	catch ( ... )
	{
		// we should not be here
		// do not re-throw (called from destructor)
	}

    return lRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::GetMapCountPtr
//
//  Returns the pointer to the plong for this glue factory
//
/////////////////////////////////////////////////////////////////////

PLONG CWbemProviderGlue::GetMapCountPtr(const CWbemGlueFactory *pGlue)
{
    PLONG pRet = NULL;
    LockFactoryMap();
	OnDelete0 < void (__stdcall *)(void), CWbemProviderGlue::UnlockFactoryMap> SmartUnlockFactoryMap ;

    // Find the matching CWbemGlueFactory in the CWbemGlueFactory<->refcount map
    PTR2PLONG::iterator mapIter;
    mapIter = CWbemProviderGlue::s_factorymap.find( pGlue );

    if (mapIter != CWbemProviderGlue::s_factorymap.end())
    {
        pRet = mapIter->second;
    }
    else
    {
        LogErrorMessage2(L"Can't find factory in map: %p", pGlue);
    }

	return pRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemProviderGlue::AddFlushPtr
//
//  Add the this pointer to a provider to the list of providers
//  that need to be flushed.
//
/////////////////////////////////////////////////////////////////////

void CWbemProviderGlue::AddFlushPtr(LPVOID pVoid)
{
    CLockWrapper lockwrap(m_csFlushPtrs);

    m_FlushPtrs.insert(pVoid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\winmsgevent.cpp ===
//=================================================================
//
// WinMsgEvent.cpp -- 
//
// Copyright  Microsoft Corporation.  All rights reserved.
//
//=================================================================

#include "precomp.h"
#include <lockwrap.h>
#include "WinMsgEvent.h"
					
// initialize class globals
CCritSec							CWinMsgEvent::mg_csMapLock ;
CCritSec							CWinMsgEvent::mg_csWindowLock ;
CAutoEvent							CWinMsgEvent::mg_aeCreateWindow ;
CWinMsgEvent::Sink_Map				CWinMsgEvent::mg_oSinkMap ;
HANDLE								CWinMsgEvent::mg_hThreadPumpHandle = NULL;
HWND								CWinMsgEvent::mg_hWnd = NULL;

#define EVENT_MAP_LOCK_ CLockWrapper t_oAcs( mg_csMapLock ) ;
#define WINDOW_LOCK_ CLockWrapper t_oAcs( mg_csWindowLock ) ;
 
// per object call
CWinMsgEvent::CWinMsgEvent()
{}

// per object call
CWinMsgEvent::~CWinMsgEvent()
{
	UnRegisterAllMessages() ;

	// clear the WM_ENDSESSION handler
	if( mg_oSinkMap.end() == mg_oSinkMap.find( WM_ENDSESSION ) )
	{
        // Note: If WM_ENDSESSION was never IN the map, this 
        // call will return zero (failed).  However, it won't
        // do anything bad, so just ignore it.
		SetConsoleCtrlHandler( &CtrlHandlerRoutine, FALSE ) ;
	}
}


// per object call
void CWinMsgEvent::RegisterForMessage(
		
IN UINT a_message
) 
{	
	BOOL t_bFound = FALSE ;
	BOOL t_bCreateWindow = FALSE ;

	{	EVENT_MAP_LOCK_

		if( mg_oSinkMap.empty() )
		{
			t_bCreateWindow = TRUE ;
		}
		else // lookup for message/object duplicate
		{		
            CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
			t_SinkIter = mg_oSinkMap.find( a_message ) ;
			
			while( t_SinkIter != mg_oSinkMap.end() )
			{				
				if( a_message == t_SinkIter->first )
				{
					if( this == t_SinkIter->second )
					{
						t_bFound = TRUE ;
						break ;
					}
					++t_SinkIter ;
				}
				else
				{
					break ;
				}
			}
		}

		if( !t_bFound )
		{		
			// Set up a handler to simulate this message
			// as we won't get it running under local system account.
			if( WM_ENDSESSION == a_message && 
				mg_oSinkMap.end() == mg_oSinkMap.find( WM_ENDSESSION ) )
			{
				SetConsoleCtrlHandler( &CtrlHandlerRoutine, TRUE ) ;
			}

			// map the desired message for this object instance 
			mg_oSinkMap.insert( 

				pair<UINT const, CWinMsgEvent*>
				( a_message,
				  this ) ) ; 			
		}
	}

	if( t_bCreateWindow )
	{
		CreateMsgProvider() ;
	}
}

// per object call
bool CWinMsgEvent::UnRegisterMessage(
		
IN UINT a_message
) 
{
	bool t_bRet = false ;
	BOOL t_bDestroyWindow = FALSE ;

	{	EVENT_MAP_LOCK_

        CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
		t_SinkIter = mg_oSinkMap.find( a_message ) ;
					 
		while( t_SinkIter != mg_oSinkMap.end() )
		{
			if( a_message == t_SinkIter->first )
			{
				if( this == t_SinkIter->second )
				{
					t_SinkIter = mg_oSinkMap.erase( t_SinkIter ) ;				
					t_bRet = true ;
					break;
				}
				else
				{
					t_SinkIter++;
				}
			}
			else
			{
				break ;
			}
		}

		if( mg_oSinkMap.empty() )
		{
			t_bDestroyWindow = TRUE ;
		}
	}

	if( t_bDestroyWindow )
	{
		DestroyMsgWindow() ;
	}

	return t_bRet ;
}

// per object call
void CWinMsgEvent::UnRegisterAllMessages() 
{
	BOOL t_bDestroyWindow = FALSE ;

	{	// Used for scoping the lock

        EVENT_MAP_LOCK_

        CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
		t_SinkIter = mg_oSinkMap.begin() ;

		while( t_SinkIter != mg_oSinkMap.end() )
		{
			if( this == t_SinkIter->second )
			{
				t_SinkIter = mg_oSinkMap.erase( t_SinkIter ) ;
			}
            else
            {
                t_SinkIter++;
            }
		}

    	if( mg_oSinkMap.empty() )
        {
            t_bDestroyWindow = TRUE;
        }		
	}

	if( t_bDestroyWindow )
	{
		DestroyMsgWindow() ;
	}
}


// global private
void CWinMsgEvent::CreateMsgProvider()
{	
	WINDOW_LOCK_

	if( NULL == mg_hThreadPumpHandle )
	{
		DWORD t_dwThreadID ;

		// Create a thread that will spin off a windowed msg pump
		mg_hThreadPumpHandle = CreateThread(
							  NULL,						// pointer to security attributes
							  0L,						// initial thread stack size
							  dwThreadProc,				// pointer to thread function
							  0L,						// argument for new thread
							  0L,						// creation flags
							  &t_dwThreadID ) ;

		// wait for async window create
		mg_aeCreateWindow.Wait( INFINITE );
		
		if( !mg_hWnd )
		{
			CloseHandle( mg_hThreadPumpHandle ) ;
			mg_hThreadPumpHandle = NULL ;
		}
	}
}

//
void CWinMsgEvent::DestroyMsgWindow() 
{
	WINDOW_LOCK_

	HANDLE	t_hThreadPumpHandle = mg_hThreadPumpHandle ;
	HWND	t_hWnd				= mg_hWnd ;
	
	// clear globals
	mg_hThreadPumpHandle	= NULL ;
	mg_hWnd					= NULL ;

	if( t_hWnd )
	{
		SendMessage( t_hWnd, WM_CLOSE, 0, 0 ) ;
	}
	
	if( t_hThreadPumpHandle )
	{
		WaitForSingleObject( 
			
			t_hThreadPumpHandle,
			20000
		);

		CloseHandle( t_hThreadPumpHandle ) ;
	}
}

BOOL WINAPI CWinMsgEvent::CtrlHandlerRoutine(DWORD dwCtrlType)
{
	HWND	t_hWnd		= NULL ;
	UINT	t_message	= 0 ;
	WPARAM	t_wParam	= 0 ;
	LPARAM	t_lParam	= 0 ; 
	
	// simulate the message
	if( CTRL_LOGOFF_EVENT == dwCtrlType )
	{
		t_message	= WM_ENDSESSION ;
		t_wParam	= TRUE ;				// session ending
		t_lParam	= ENDSESSION_LOGOFF ;	// Logoff event
	}
	else if( CTRL_SHUTDOWN_EVENT == dwCtrlType )
	{
		t_message	= WM_ENDSESSION ;
		t_wParam	= TRUE ;	// session ending
		t_lParam	= 0 ;		// Shutdown event
	}
	
	if( t_message )
	{
		//
		MsgWndProc( t_hWnd, 
					t_message,
					t_wParam,
					t_lParam ) ;
	}

    return FALSE;       // Pass event on to next handler.
}

// worker thread pump, global private
DWORD WINAPI CWinMsgEvent::dwThreadProc( LPVOID a_lpParameter )
{
	DWORD t_dwRet = FALSE ;
	
	if( CreateMsgWindow() )
	{
		WindowsDispatch() ;

		t_dwRet = TRUE ;
	}
		
	UnregisterClass( MSGWINDOWNAME, GetModuleHandle(NULL) ) ;

	return t_dwRet ;
}

// global private
HWND CWinMsgEvent::CreateMsgWindow()
{
	DWORD t_Err = 0;
	HMODULE t_hMod = GetModuleHandle(NULL);
	
	if (t_hMod != NULL)
	{
		WNDCLASS wndclass ;
		wndclass.style			= 0 ;
		wndclass.lpfnWndProc	= MsgWndProc ;
		wndclass.cbClsExtra		= 0 ;
		wndclass.cbWndExtra		= 0 ;
		wndclass.hInstance		= t_hMod ;
		wndclass.hIcon			= NULL ;
		wndclass.hCursor		= NULL ;
		wndclass.hbrBackground	= NULL ;
		wndclass.lpszMenuName	= NULL ;
		wndclass.lpszClassName	= MSGWINDOWNAME ;

		RegisterClass( &wndclass ) ;
    
		mg_hWnd = CreateWindowEx( WS_EX_TOPMOST,
						MSGWINDOWNAME,
						TEXT("WinMsgEventProv"),
						WS_OVERLAPPED,
						CW_USEDEFAULT,
						CW_USEDEFAULT,
						CW_USEDEFAULT,
						CW_USEDEFAULT,
						NULL, 
						NULL,
						t_hMod,
						NULL ) ;
	}
	else
	{
		t_Err = GetLastError();
	}

	mg_aeCreateWindow.Signal();
	return mg_hWnd ;
}

// global private
void CWinMsgEvent::WindowsDispatch()
{
	BOOL t_GetMessage ;
	MSG	 t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( &t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( &t_lpMsg ) ;
		DispatchMessage ( &t_lpMsg ) ;
	}
}

// global private
LRESULT CALLBACK CWinMsgEvent::MsgWndProc(

IN HWND a_hWnd,
IN UINT a_message,
IN WPARAM a_wParam,
IN LPARAM a_lParam
)
{
	LRESULT			t_lResult = TRUE ;
	E_ReturnAction	t_eReturnAction = e_DefProc ;

	switch ( a_message ) 
	{
		default:
		{	
			// Run through the message map 
			// If registered requestor(s) are found dispatch it...  

			EVENT_MAP_LOCK_

            CWinMsgEvent::Sink_Map::iterator	t_SinkIter ;
			t_SinkIter = mg_oSinkMap.find( a_message ) ;

			while( t_SinkIter != mg_oSinkMap.end() )
			{				
				if( a_message == t_SinkIter->first )
				{
					// signal
					t_SinkIter->second->WinMsgEvent(

										a_hWnd,
										a_message,
										a_wParam,
										a_lParam,
										t_eReturnAction,
										t_lResult ) ;	
					++t_SinkIter ;
				}
				else
				{
					break ;
				}
			}
			// special return processing --- 
			//
			// The default is to defer to DefWindowProc.
			// However, multiple sinks can exist for a message. 
			// Each may require special return processing.
			//
			// Example: WM_POWERBROADCAST submessage PBT_APMQUERYSUSPEND requires
			// the returning of TRUE to indicate interest in additional Power
			// Event messages. This a passive request ( asking for additional info )
			// but another sink registered for this message may have a different opinion.
			// Trivial perhaps, but other message processing may be different; placing
			// the requestor at odds with the intent of another. 

			// Behavior here: All sinks are called with the
			// updated t_eReturnAction from the last sink call. 
			// If a sink suspects it would have to act diffently based on specific
			// knowledge of message usage the sink will have to instead spin off
			// its own window to handle the special return and not make use of this
			// generalized class.
			// 			
			if( e_DefProc == t_eReturnAction )
			{
                t_lResult = DefWindowProc( a_hWnd, a_message, a_wParam, a_lParam ) ;
            }
			break ;
		}

        case WM_CLOSE:
        {
            if ( mg_hWnd != NULL)
            {
                t_lResult = 0;
            }
            else
            {
                t_lResult = DefWindowProc( a_hWnd, a_message, a_wParam, a_lParam ) ;
            }
            break;
        }
		
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd, WM_QUIT, 0, 0 ) ;
            t_lResult = 0;
		}
		break ;
    }

    return t_lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\dyd\makefile.inc ===
#
# Build private framedydp.lib.  It contains all the private lockit for providers
#

$(O)\framedydp.def: ..\framedyd.src
    @echo Creating $@ from $?
    $(C_PREPROCESSOR_NAME) /DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\framedydp.lib: $(O)\framedydp.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\framedydp.def
$(LIBRARY_OBJS)
<<NOKEEP

#$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\framedyd.lib : $(O)\framedyd.lib
#    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\eventprovider.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  EventProvider.H
//
//  Purpose: Definition of EventProvider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _EVENT_PROVIDER_COMPILED_
#define _EVENT_PROVIDER_COMPILED_

#ifdef EVENT_PROVIDER_ENABLED

#include "Provider.h"

// class EventProvider
//      Encapsulation of the IWbemEventProvider interfaces
class EventProvider : public Provider
{
public:
    EventProvider( const CHString& setName, LPCWSTR pszNameSpace = NULL );
    ~EventProvider( void );

    virtual HRESULT ProvideEvents(MethodContext *pContext, long lFlags = 0L  ) =0;
    // functions much like EnumerateInstances in Provider
    // use CreateNewInstance to create event instance
    // use Commit to send it on its merry way

    // overrides of the base class' pure virtuals, return WBEM_E_PROVIDER_NOT_CAPABLE
    // logic is that an event provider will not want to support them in the general case
    virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
    virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    // entry point for the framework's use.  Do not override.
    HRESULT KickoffEvents( MethodContext *pContext, long lFlags  =0L );

protected:  
    // flag validation
    virtual HRESULT ValidateProvideEventsFlags(long lFlags);
    virtual HRESULT ValidateQueryEventsFlags(long lFlags);

private:

};

#endif //EVENT_PROVIDER_ENABLED

#endif //_EVENT_PROVIDER_COMPILED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\dyn\makefile.inc ===
#
# Build private framedydp.lib.  It contains all the private lockit for providers
#

$(O)\framedynp.def: ..\framedyn.src
    @echo Creating $@ from $?
    $(C_PREPROCESSOR_NAME) /DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\framedynp.lib: $(O)\framedynp.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\framedynp.def
$(LIBRARY_OBJS)
<<NOKEEP

#$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\framedyn.lib : $(O)\framedyn.lib
#    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\fwcommon.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  FWcommon.h
//
//  Purpose: Definition of EventProvider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#define FRAMEWORK_ALLOW_DEPRECATED 0

// ALWAYS INCLUDE THIS FILE FIRST!

#ifndef _FW_COMMON_H_
#define _FW_COMMON_H_

// move warnings to level four
#pragma warning(4 : 4275 4800 4786 4251)
//	C4275: non DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier'
//	C4800: forcing bool variable to one or zero, possible performance loss
//	C4786: 'identifier' : identifier was truncated to 'number' characters in the debug information
//	C4251: 'identifier' : class 'type' needs to have dll-interface to export class 'type2'


#include "windows.h"

// This function gets macro'ed to GetObjectW and GetObjectA based on the
// contents of UNICODE.  However, we USE a function called GetObject.  For
// single binary support, we can't have this being macro'ed.  If the actual
// win32 api GetObject is needed, call the GetObjectW or GetObjectA directly.
#undef GetObject
#include <wbemidl.h>
#include <wmiutils.h>

// If USE_POLARITY not defined, some Framedyn.dll symbols may not resolve correctly
// It's a declspec(dllimport/dllexport) issue.
#ifndef USE_POLARITY

// For most users, this is the correct setting for POLARITY.
#define USE_POLARITY

#endif

// Required since TCHAR.H defines _ttoi64 -> atoi64, which requires oldnames.lib, which
// we don't use.
#define atoi64 _atoi64

#include <Polarity.h>


#ifndef EXPORT_LOCKIT

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP

#else

#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP

#endif

#include <stllock.h>
extern POLARITY CCritSec g_cs;

#include "utillib.h"
#include "ThrdBase.h"
#include "RefPtrCo.h"
#include "MethodCo.h"
#include "FRQuery.h"
#include "wbemglue.h"
#include "instance.h"

class CFramework_Exception
{
private:

	CHString m_sErrorText;
    HRESULT m_hr;

public:

	CFramework_Exception ( LPCWSTR lpwszErrorText, HRESULT hr) : m_hr ( hr ) , m_sErrorText ( lpwszErrorText) {}
	CFramework_Exception ( LPCWSTR lpwszErrorText) : m_hr ( WBEM_S_NO_ERROR ) , m_sErrorText ( lpwszErrorText) {}
	~CFramework_Exception () {}

	HRESULT GetHRESULT() { return m_hr ; }
	CHString &GetErrorText() { return m_sErrorText; }
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\frquery.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  FRQuery.h
//
//  Purpose: query support classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FRAMEWORK_QUERY_H_
#define _FRAMEWORK_QUERY_H_
#include <stdio.h>
#include <sql_1.h>
#include <comdef.h>
#include <vector>

class POLARITY CFrameworkQuery
{
public:
    CFrameworkQuery();
    ~CFrameworkQuery();

    // Finds out if a particular field was requested by the query in either
    // the Select statement, or the Where statement.  Only meaningful if we
    // are in ExecQueryAsync and the query has been sucessfully parsed.
    bool IsPropertyRequired(LPCWSTR propName);

    // Gets the class name from the query.  Only meaningful if we are
    // in ExecQueryAsync and the query has been sucessfully parsed.  It
    // is the responsibility of the caller to SysFreeString the returned
    // string.
    BSTR GetQueryClassName(void) { return SysAllocString(m_bstrtClassName); }

    // Given a property name, it will return all the values
    // that the query requests in a CHStringArray.
    // Select * from win32_directory where drive = "C:" GetValuesForProp(L"Drive") -> C:
    // Where Drive = "C:" or Drive = "D:" GetValuesForProp(L"Drive") -> C:, D:
    // Where Path = "\DOS" GetValuesForProp(L"Drive") -> (empty)
    // Where Drive <> "C:" GetValuesForProp(L"Drive") -> (empty)
    // Where Drive = "C:" or (Drive = "D:" and Mounted = true) GetValuesForProp(L"Drive") -> C:, D:
    HRESULT GetValuesForProp(LPCWSTR wszPropName, CHStringArray& achNames);

    // Here's an overloaded version in case client wants to pass in a vector of _bstr_t's
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<_bstr_t>& vectorNames);

    // Returns a list of all the properties specified in the Select clause, plus.
    // all the the properties from the Where clauses.  If the returned array is empty, all
    // properties are required.
    void GetRequiredProperties(CHStringArray &saProperties);

    // Boolean indicating if all properties are being requested.
    bool AllPropertiesAreRequired(void) { return (m_csaPropertiesRequired.GetSize() == 0); }

    // Boolean indicating if only the key properties are required.
    bool KeysOnly(void) { return m_bKeysOnly; }

    // Accessor function to retrieve wql query
    const CHString &GetQuery() ;

    // Moves the values into the member variables.  Should never be called by users.
    HRESULT Init(
        
        const BSTR bstrQueryFormat, 
        const BSTR bstrQuery, 
        long lFlags,
        CHString &sNamespace
    );

    // Moves the values into the member variables.  Should never be called by users.
    HRESULT Init(

        ParsedObjectPath *pParsedObjectPath, 
        IWbemContext *pCtx, 
        LPCWSTR lpwszClassName,
        CHString &sNamespace
    );

    // Initializes the KeysOnly data member.  Should never be called by users.
    void Init2(IWbemClassObject *IClass);


protected:

    /*****************************************************************************/
    /* The rest of these data members and functions are intended for Microsoft   */
    /* internal use only. Use by third parties is unsupported and unrecommended. */
    /*****************************************************************************/

    SQL_LEVEL_1_RPN_EXPRESSION *m_pLevel1RPNExpression;
    CHStringArray m_csaPropertiesRequired;
    enum QueryTypes{eUnknown, eWQLCommand, eContextObject} m_QueryType;

    DWORD IsInList(const CHStringArray &csaArray, LPCWSTR pwszValue);

    BOOL IsReference(LPCWSTR lpwszPropertyName);
    const CHString &GetNamespace();

private:

    CHString m_sNamespace;
    long m_lFlags;
    IWbemClassObject *m_IClass;
    CHString m_sQueryFormat;

    void Reset(void);
    bool m_bKeysOnly;
    bool m_AddKeys;
    CHString m_sQuery;
    bstr_t m_bstrtClassName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\instance.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  Instance.h
//
//  Purpose: Definition of CInstance class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INSTANCE_H_
#define _INSTANCE_H_

#define WBEMINT64 CHString
#define WBEMINT16 short

///////////////////////////////////////////
//
// CLASS CInstance
//
// base instance class
// encapsulation of IWbemClassObject
///////////////////////////////////////////
class
__declspec(uuid("3402945E-D19A-11d2-B35E-00104BC97924"))
POLARITY CInstance
{
    public:
        CInstance(IWbemClassObject *piClassObject, MethodContext *pMethodContext);
        virtual ~CInstance();

        // AddRef/Release
        LONG   AddRef( void );
        LONG   Release( void );

        // Get and Set for various data types
        bool SetNull(LPCWSTR name );
        bool SetStringArray(LPCWSTR name, const SAFEARRAY &strArray);
        bool SetWORD(LPCWSTR name,  WORD w);
        bool SetDWORD(LPCWSTR name,  DWORD d);
        bool Setbool(LPCWSTR name,  bool  b);
        bool SetVariant(LPCWSTR name,  const VARIANT& variant );
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        bool SetCharSplat(LPCWSTR name,  DWORD dwResID);
#endif
        bool SetCharSplat(LPCWSTR name,  LPCWSTR pStr);
        bool SetCharSplat( LPCWSTR name,  LPCSTR pStr);
        bool SetWCHARSplat(LPCWSTR name,  LPCWSTR pStr);
        bool SetDateTime(LPCWSTR name,  const WBEMTime& wbemtime );
        bool SetTimeSpan(LPCWSTR name,  const WBEMTimeSpan& wbemtimespan );
        bool SetWBEMINT64(LPCWSTR name, const WBEMINT64& wbemint64 );
        bool SetWBEMINT64(LPCWSTR name, const LONGLONG i64Value );
        bool SetWBEMINT64( LPCWSTR name, const ULONGLONG i64Value );
        bool SetWBEMINT16(LPCWSTR name, const WBEMINT16& wbemint16 );
        bool SetByte(LPCWSTR name, BYTE b );
        bool SetEmbeddedObject (LPCWSTR name, CInstance& cInstance ) ;
        bool SetDOUBLE(LPCWSTR name, DOUBLE dub );
        bool SetCHString(LPCWSTR name, LPCWSTR str);
        bool SetCHString(LPCWSTR name,  const CHString& str);
        bool SetCHString(LPCWSTR name, LPCSTR str);

        bool GetStringArray(LPCWSTR name,  SAFEARRAY *& strArray)     const;
        bool GetCHString(LPCWSTR name, CHString& str) const;
        bool GetWCHAR(LPCWSTR name,  WCHAR **pW) const;
        bool GetWORD(LPCWSTR name,  WORD& w) const;
        bool GetDWORD(LPCWSTR name,  DWORD& d) const;
        bool Getbool(LPCWSTR name,  bool&  b) const;
        bool GetVariant(LPCWSTR name, VARIANT& variant ) const;
        bool GetDateTime(LPCWSTR name,  WBEMTime& wbemtime ) const;
        bool GetTimeSpan(LPCWSTR name,  WBEMTimeSpan& wbemtimespan ) const;
        bool GetWBEMINT64(LPCWSTR name, WBEMINT64& wbemint64 ) const;
        bool GetWBEMINT64(LPCWSTR name, LONGLONG& i64Value ) const;
        bool GetWBEMINT64( LPCWSTR name, ULONGLONG& i64Value) const;
        bool GetWBEMINT16(LPCWSTR name, WBEMINT16& wbemint16 ) const;
        bool GetByte(LPCWSTR name, BYTE& b ) const;
        bool GetEmbeddedObject(LPCWSTR name, CInstance** pInstance,  MethodContext *pMethodContext) const;
        bool GetDOUBLE(LPCWSTR name, DOUBLE& dub) const;
        bool IsNull(LPCWSTR name) const;
        bool GetStatus(LPCWSTR name, bool &a_Exists , VARTYPE &a_VarType ) const ;

        HRESULT Commit(void);
        IWbemClassObject *GetClassObjectInterface();
        MethodContext *GetMethodContext() const;

    protected:
        // All items in this section intended for Microsoft internal use only
        // use by third parties is unsupported and unrecommended
        void LogError(LPCWSTR errorStr, LPCWSTR pFunctionName, LPCWSTR pArgs = NULL, HRESULT hError = -1) const;

        IWbemClassObject *m_piClassObject;
        MethodContext*   m_pMethodContext;
        LONG             m_nRefCount;

        friend class CWbemProviderGlue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\methodco.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  MethodCo.h
//
//  Purpose: declaration of MethodContext class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _METHOD_CONTEXT_H__
#define _METHOD_CONTEXT_H__

//#include "ThrdBase.h"
//#include "refptrco.h"

#ifdef PROVIDER_INSTRUMENTATION
    #include <stopwatch.h>
#endif

class CInstance;
class Provider;
class MethodContext;
class CWbemProviderGlue;
class InternalMethodContextAsynch;

typedef HRESULT (WINAPI *LPProviderInstanceCallback)(Provider *pProvider, CInstance *pInstance, MethodContext *pContext, void *pUserData);

//////////////////////////////////////////////////////
//
//  STRUCT MethodContext
//
// a little something to make sure we can keep our threads from getting tangled
// idea is that there is one MethodContext for each request from CIMOM or another provider
// pointers are passed around.
//////////////////////////////////////////////////////
class POLARITY MethodContext : public CThreadBase
{
public:
    friend InternalMethodContextAsynch;
    friend CWbemProviderGlue;

    MethodContext(IWbemContext   __RPC_FAR *piContext, CWbemProviderGlue *pGlue);
    ~MethodContext();
    
    virtual HRESULT Commit(CInstance *pInstance) = 0;
    virtual IWbemContext __RPC_FAR *GetIWBEMContext();
    
    LONG AddRef(void);
    LONG Release(void);
    virtual void QueryPostProcess(void);
        
    bool SetStatusObject(IWbemClassObject *pObj);
    IWbemClassObject __RPC_FAR *GetStatusObject();

#ifdef PROVIDER_INSTRUMENTATION
    StopWatch *pStopWatch;
#endif
    
private:
    CWbemProviderGlue* GetProviderGlue();
    CWbemProviderGlue   *m_pGlue;
    IWbemContext        __RPC_FAR *m_pContext;
    IWbemClassObject    __RPC_FAR *m_pStatusObject;

};

// for queries and suchlike that originate in CIMOM
class 
__declspec(uuid("9113D3B4-D114-11d2-B35D-00104BC97924")) 
ExternalMethodContext  : public MethodContext
{
public:
    ExternalMethodContext(IWbemObjectSink __RPC_FAR *pResponseHandler,
                          IWbemContext    __RPC_FAR *pContext,
                          CWbemProviderGlue *pGlue,
                          void                      *pReserved = NULL
                          );
    
    HRESULT Commit(CInstance *pInstance);
    virtual void QueryPostProcess(void);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    IWbemObjectSink __RPC_FAR *m_pResponseHandler;
    void                      *m_pReserved;
};

// for queries and suchlike that come from within.
// contains a list of objects returned. 
class 
__declspec(uuid("6AF4B074-D121-11d2-B35D-00104BC97924"))
InternalMethodContext : public MethodContext
{
public:
    InternalMethodContext(TRefPointerCollection<CInstance> *pList ,
                          IWbemContext    __RPC_FAR *pContext,
                          CWbemProviderGlue *pGlue);
    ~InternalMethodContext();
    
    HRESULT Commit(CInstance *pInstance);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    TRefPointerCollection<CInstance> *m_pInstances;
};

// for queries and suchlike that come from within.
// "Asynch" is a bit of a misnomer - but it does help support
// asynchronous calls, in that each instance committed is routed
// to a callback function supplied by the requester
class 
__declspec(uuid("D98A82E8-D121-11d2-B35D-00104BC97924"))
InternalMethodContextAsynch : public MethodContext
{
public:
    InternalMethodContextAsynch(Provider *pThat,
                                LPProviderInstanceCallback pCallback,
                                IWbemContext __RPC_FAR *pContext,
                                MethodContext *pUsersContext,
                                void *pUserData);
    ~InternalMethodContextAsynch();
    
    HRESULT Commit(CInstance *pInstance);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    Provider *m_pThat;
    LPProviderInstanceCallback m_pCallback;
    void *m_pUserData;
    MethodContext *m_pUsersContext;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\stllock.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  stllock.h
//
//  Purpose: Critical section class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _STLLOCK_H_
#define _STLLOCK_H_

class CCritSec : public CRITICAL_SECTION
{
public:
    CCritSec() 
    {
        InitializeCriticalSection(this);
    }
    ~CCritSec()
    {
        DeleteCriticalSection(this);
    }
    void Enter()
    {
        EnterCriticalSection(this);
    }
    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\provider.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  Provider.h
//
//  Purpose: declaration of Provider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_H__
#define _PROVIDER_H__

/////////////////////////////////////////////////////
// INSTANCE Provider
//
// pure virtual base class for providers
// holds instances
// gathers information and instantiates instances
/////////////////////////////////////////////////////
class POLARITY Provider : public CThreadBase
{
    // CWbemProviderGlue needs to access some protected/private methods
    // which we don't want to publish to just anyone.

    friend class CWbemProviderGlue;

    public:
        Provider( LPCWSTR a_pszName, LPCWSTR a_pszNameSpace = NULL );
        ~Provider();

    protected:
        /* Override These Methods To Implement Your Provider */
        
        // This is the entrypoint for changes.
        // You are handed a changed instance.
        // If you can make the changes - do so.
        // If you cannot return an appropriate error code (WBEM_E_XXXXXXX)
        // base object returns WBEM_E_PROVIDER_NOT_CAPABLE
        virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);

        // entrypoint to delete an instance
        // examine the instance passed in, determine whether you can delete it
        virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

        // execute a method
        virtual HRESULT ExecMethod(const CInstance& cInstance, 
                                   const BSTR bstrMethodName, 
                                   CInstance *pInParams, 
                                   CInstance *pOutParams, 
                                   long lFlags = 0L);

        // find and create all instances of your class
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

        // you will be given an object with the key properties filled in
        // you need to fill in all of the rest of the properties, or
        // return WBEM_E_NOT_FOUND if the object doesn't exist.
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);

        // You will be given an object with the key properties filled in.
        // You can either fill in all the properties, or check the Query object
        // to see what properties are required.  If you don't implement this method, the
        // GetObject(CInstance, long) method will be called instead.
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query);

        // If a provider wants to process queries, they should override this
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                                  CFrameworkQuery& cQuery, 
                                  long lFlags = 0L);

        // flushes cache
        // only override if you allocate memory that could be flushed
        virtual void Flush(void);

        /* Helpers - Use These, Do Not Override */

        // allocate a new instance & return pointer to it
        // the memory is your responsibility to Release()
        // UNLESS you pass it off to Provider::Commit
        CInstance *CreateNewInstance(MethodContext *pMethodContext);

        // used to send your new instance back to the framework
        // set bCache to true to cache object 
        // !! caching is NOT IMPLEMENTED in this release !!
        // do not delete or release the pointer once committed.
        HRESULT Commit(CInstance *pInstance, bool bCache = false);

        // Helper function for building a WBEM Object Path for a local Instance
        bool GetLocalInstancePath( const CInstance *pInstance, CHString& strPath );

        //   Builds a full instance path from a relative path
        CHString MakeLocalPath( const CHString &strRelPath );

        // Returns the computer name as a CHString.  Save yourself the os call,
        // since we've got it hanging around anyway.
        const CHString &GetLocalComputerName() {return s_strComputerName;}
        const CHString &GetNamespace() {return m_strNameSpace;}

        // sets the CreationClassName property to the name of this provider
        bool SetCreationClassName(CInstance *pInstance);

        // accesses the name of the provider
        const CHString &GetProviderName() {return m_name;}

        // Flag validation constants
        enum FlagDefs
        {
            EnumerationFlags = (WBEM_FLAG_DIRECT_READ | WBEM_FLAG_SEND_STATUS),
            GetObjFlags = (WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ),
            MethodFlags = WBEM_FLAG_SEND_STATUS,
            DeletionFlags = WBEM_FLAG_SEND_STATUS,
            PutInstanceFlags = (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_SEND_STATUS),
            QueryFlags = WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ
        };

        // returns WBEM_E_UNSUPPORTED_PARAMETER or WBEM_S_NO_ERROR
        HRESULT ValidateFlags(long lFlags, FlagDefs lAcceptableFlags);

        // you can override the following to support flags 
        // above and beyond those listed in FlagDefs above
        virtual HRESULT ValidateEnumerationFlags(long lFlags);
        virtual HRESULT ValidateGetObjFlags(long lFlags);
        virtual HRESULT ValidateMethodFlags(long lFlags);
        virtual HRESULT ValidateQueryFlags(long lFlags);
        virtual HRESULT ValidateDeletionFlags(long lFlags);
        virtual HRESULT ValidatePutInstanceFlags(long lFlags);
        
    private:

        IWbemServices       *m_pIMosProvider;    // provides instances
        CHString            m_name;             // name of this provider
        CHString            m_strNameSpace;     // name of this provider's namespace
        IWbemClassObject    *m_piClassObject;    // holds class object from which others are cloned.

        static CHString     s_strComputerName;  // Holds the computer name for building
                                                // instance paths.
        
        BOOL ValidateIMOSPointer( void );       // This function ensures that our IMOS
                                                // pointer is available, and is called
                                                // by the framework entrypoint functions

        /* Interfaces For Use by the Framework         */
        HRESULT GetObject(  ParsedObjectPath *pParsedObjectPath, 
                            MethodContext *pContext, long lFlags = 0L );

        HRESULT ExecuteQuery( MethodContext *pContext, 
                              CFrameworkQuery &pQuery, 
                              long lFlags = 0L);

        HRESULT CreateInstanceEnum( MethodContext *pContext, long lFlags = 0L );

        HRESULT PutInstance( IWbemClassObject __RPC_FAR *pInst,
                             long lFlags,
                             MethodContext *pContext );

        HRESULT DeleteInstance( ParsedObjectPath *pParsedObjectPath,
                                long lFlags,
                                MethodContext *pContext );

        HRESULT ExecMethod( ParsedObjectPath *pParsedObjectPath,
                            BSTR bstrMethodName,
                            long lFlags,
                            CInstance *pInParams,
                            CInstance *pOutParams,
                            MethodContext *pContext );

        // Static helper function called by constructor to make sure the
        // computer name variable is properly initialized.
        static void WINAPI InitComputerName( void );

        // Sets an instance key from a parsed object path.
        BOOL SetKeyFromParsedObjectPath( CInstance *pInstance, 
                                         ParsedObjectPath *pParsedObjectPath );

        IWbemClassObject *GetClassObjectInterface(MethodContext *pMethodContext);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\thrdbase.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  ThrdBase.h
//
//  Purpose: Definition of ThreadBase class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __THREADBASE_H__
#define __THREADBASE_H__

class POLARITY CThreadBase
{
public:

	enum THREAD_SAFETY_MECHANISM
	{
		etsmFirst		= 0,
		etsmSerialized	= 0,
		etsmPriorityRead,
		etsmPriorityWrite,
		etsmLast
	};

	// Construction/Destruction
	CThreadBase( THREAD_SAFETY_MECHANISM etsm = etsmSerialized );
	virtual ~CThreadBase();

	// Thread Safe Ref/Counting functions
	LONG	AddRef( void );
	LONG	Release( void );

	// Provide Readable Read/Write accessors should
	// we not want to serialize at a later date.  Note
	// that timeouts have no meaning unless we're
	// doing a non-serialized implementation.

	BOOL	BeginRead( DWORD dwTimeOut = INFINITE );
	void	EndRead( void );

	BOOL	BeginWrite( DWORD dwTimeOut = INFINITE );
	void	EndWrite( void );

protected:

	virtual void	OnFinalRelease( void );

	// Thread Safety functions


private:

	CRITICAL_SECTION		m_cs;
	LONG					m_lRefCount;
	THREAD_SAFETY_MECHANISM	m_etsm;

	// Private thread safety functions.  We can maybe promote
	// these to protected if we see a need to later, however
	// for right now, everyone should specify if they mean
	// to read or write when they wish to access data that
	// may change.

	void	Lock( void );
	void	Unlock( void );

};

inline BOOL CThreadBase::BeginRead( DWORD dwTimeout /*=INFINITE*/ )
{
	EnterCriticalSection( &m_cs );
	return TRUE;
}

inline void CThreadBase::EndRead( void )
{
	LeaveCriticalSection( &m_cs );
}

inline BOOL CThreadBase::BeginWrite( DWORD dwTimeout /*=INFINITE*/ )
{
	EnterCriticalSection( &m_cs );
	return TRUE;
}

inline void CThreadBase::EndWrite( void )
{
	LeaveCriticalSection( &m_cs );
}

inline void CThreadBase::Lock( void )
{
	EnterCriticalSection( &m_cs );
}

inline void CThreadBase::Unlock( void )
{
	LeaveCriticalSection( &m_cs );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\refptrco.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  RefPtrCo.h
//
//  Purpose: definition of TRefPointerCollection template
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRCOLLECTION_H__
#define __REFPTRCOLLECTION_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTRCOLLECTION_POSITION;
#define	REFPTRCOLLECTION_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPointerCollection : public CThreadBase
{
public:

	// Construction/Destruction
	TRefPointerCollection();
	~TRefPointerCollection();
    TRefPointerCollection(const TRefPointerCollection& trpc);

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );

	BOOL		BeginEnum( REFPTRCOLLECTION_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTRCOLLECTION_POSITION& pos );
	void		EndEnum( void );

	void		Empty( void );
    int         GetSize( void ) const;

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPointerCollection<TYPED_PTR>& Copy( const TRefPointerCollection<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::TRefPointerCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection( void )
:	CThreadBase(),
	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::~CRefPointerCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::~TRefPointerCollection( void )
{
	Empty();
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::CRefPointerCollection
//              Copy constructor
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection(
    const TRefPointerCollection& trpc)
{
    Copy(trpc);	
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		// Get write access
		if ( BeginWrite() )
		{
            try
            {
			    // If Add succeeds, the pointer will be released when it
			    // is removed.

			    ptr->AddRef();

			    if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
			    {
				    fReturn = TRUE;
			    }
			    else
			    {
				    ptr->Release();	// Add failed, so Release the AddRef
			    }
            }
            catch ( ... )
            {
    	        EndWrite() ;
                throw;
            }

			EndWrite();	// Release the BeginWrite()
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTRCOLLECTION_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::BeginEnum( REFPTRCOLLECTION_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	if ( BeginRead() )
	{
		pos = REFPTRCOLLECTION_START;
		fReturn = TRUE;
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	Ends Read Access granted by calling BeginEnum().
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::EndEnum( void )
{
	EndRead();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetNext
//
//	Uses the REFPTRCOLLECTION_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPointerCollection<TYPED_PTR>::GetNext( REFPTRCOLLECTION_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( BeginRead() )
	{
		if ( ++pos < (DWORD) m_ptrArray.GetSize() )
		{
			ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

			if ( NULL != ptr )
			{
				ptr->AddRef();
			}
		}

		EndRead();
	}

	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

	BeginWrite();

    try
    {

	    int	nSize	=	m_ptrArray.GetSize();

	    // Only empty it if it is not empty
	    if ( nSize > 0 )
	    {
		    TYPED_PTR*	ptr		=	NULL;

		    for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		    {
			    ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			    if ( NULL != ptr )
			    {
				    ptr->Release();	// AddRef we did when we added it
			    }
		    }

		    // Now dump the array
		    m_ptrArray.RemoveAll();

	    }	// IF nSize > 0

    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPointerCollection<TYPED_PTR>& TRefPointerCollection<TYPED_PTR>::Copy( const TRefPointerCollection<TYPED_PTR>& collection )
{
	// By default this is an infinite wait, so it best come back
	BeginWrite();

    try
    {

	    // Dump out the array
	    Empty();

	    int	nSize = collection.m_ptrArray.GetSize();

	    for ( int nCount = 0; nCount < nSize; nCount++ )
	    {
		    TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		    // Add will automatically AddRef the pointer again.
		    Add( ptr );
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite();

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetSize
//
//	Inputs:		None.
//
//	Outputs:	Number of elements in the collection
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
int TRefPointerCollection<TYPED_PTR>::GetSize(void) const
{
    return m_ptrArray.GetSize();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\brodcast.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  BrodCast.h
//
//  Purpose: Logging functions
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef BRODCAST_IS_INCLUDED
#define BRODCAST_IS_INCLUDED

#include <time.h>
#include <CRegCls.h>

//#define MAX_STRING_SIZE 4096

class POLARITY ProviderLog;
extern POLARITY ProviderLog captainsLog;

// Needed to add L to the __FILE__
#define __T2(x)      L ## x
#define _T2(x)       __T2(x)

// macros to make calling easier
// first two versions of LogMessage spots in the file & line number for you
#define LogMessage(pszMessageString)        captainsLog.LocalLogMessage(pszMessageString, _T2(__FILE__), __LINE__, ProviderLog::Verbose)
#define LogMessage2(pszMessageString, p1)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1)
#define LogMessage3(pszMessageString, p1, p2)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2)
#define LogMessage4(pszMessageString, p1, p2, p3)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3)
#define LogMessage5(pszMessageString, p1, p2, p3, p4)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4)
#define LogMessage6(pszMessageString, p1, p2, p3, p4, p5)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4, p5)
#define LogMessage7(pszMessageString, p1, p2, p3, p4, p5, p6)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4, p5, p6)
#define LogMessage8(pszMessageString, p1, p2, p3, p4, p5, p6, p7)    captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::Verbose, pszMessageString, p1, p2, p3, p4, p5, p6, p7)

#define LogErrorMessage(pszMessageString)   captainsLog.LocalLogMessage(pszMessageString, _T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly)
#define LogErrorMessage2(pszMessageString, p1)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1)
#define LogErrorMessage3(pszMessageString, p1, p2)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2)
#define LogErrorMessage4(pszMessageString, p1, p2, p3)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3)
#define LogErrorMessage5(pszMessageString, p1, p2, p3, p4)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4)
#define LogErrorMessage6(pszMessageString, p1, p2, p3, p4, p5)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4, p5)
#define LogErrorMessage7(pszMessageString, p1, p2, p3, p4, p5, p6)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4, p5, p6)
#define LogErrorMessage8(pszMessageString, p1, p2, p3, p4, p5, p6, p7)   captainsLog.LocalLogMessage(_T2(__FILE__), __LINE__, ProviderLog::ErrorsOnly, pszMessageString, p1, p2, p3, p4, p5, p6, p7)

#define LogMessageEx(pszMessageString, pszFileName, nLineNo)        captainsLog.LocalLogMessage(pszMessageString, pszFileName, nLineNo, ProviderLog::Verbose) 
#define LogErrorMessageEx(pszMessageString, pszFileName, nLineNo)   captainsLog.LocalLogMessage(pszMessageString, pszFileName, nLineNo, ProviderLog::ErrorsOnly) 

#define IsVerboseLoggingEnabled()                                   ((BOOL)(ProviderLog::Verbose == captainsLog.IsLoggingOn(NULL)))     
#define IsErrorLoggingEnabled()                                     ((BOOL)captainsLog.IsLoggingOn(NULL))


// provide basic logging functionality
// serialize access to the log file, etc.
// intent is that usage is through the macros above
// don't bother instanciating one of these puppies.

class POLARITY ProviderLog : protected CThreadBase
{
public:
    enum LogLevel{None, ErrorsOnly, Verbose };

    ProviderLog();
    ~ProviderLog();

    // Broadcast functions
    void LocalLogMessage(LPCWSTR pszMessageString, LPCWSTR pszFileName, int lineNo, LogLevel level);
    void LocalLogMessage(LPCWSTR pszFileName, int lineNo, LogLevel level, LPCWSTR pszFormatString,...);
    // void POLARITY LocalLogMessage(OLECHAR *pwszFormatString,...);

    LogLevel IsLoggingOn(CHString* pPath = NULL);

private:
    void CheckFileSize(LARGE_INTEGER& nowSize, const CHString &path);

    // note - do not use these directly, use the IsLoggingOn method
    unsigned __int64 m_lastLookedAtRegistry; // what time we last looked in the registry to see if logging is enabled
    LogLevel m_logLevel;             // 0 == no logging; 1 == logging; 2 == verbose logging
    LARGE_INTEGER    m_maxSize;      // Maximum size of log file before rollover
    CHString m_path;                 // complete path of log file

    static bool m_beenInitted;       // catch someone instanciating one of these...
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\include\wbemglue.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  WBEMGLUE.H
//
//  Purpose: Implementation of WBEM Glue classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WbemGlue_H_Included
#define _WbemGlue_H_Included

#undef PURE
#define PURE {return (ULONG)E_NOTIMPL;}
typedef LPVOID *PPVOID;

#include <wbemidl.h>
#include <map>
#include <set>
#include <provider.h>

#define DEFAULT_NAMESPACE       L"Root\\CimV2"

typedef std::map<CHString, LPVOID> STRING2LPVOID;
typedef std::map<LPCVOID, PLONG> PTR2PLONG;
typedef std::set<LPVOID> PROVIDERPTRS;

class CWbemGlueFactory;
class CWbemGlueImpersonation;

class POLARITY CWbemProviderGlue : public IWbemServices, public IWbemProviderInit
{

	friend class CWbemGlueImpersonation;

	public:
    // Public Static functions
    // these are for use by implementors of Framework based providers

    static HRESULT WINAPI GetAllInstances( LPCWSTR pszClassName, 
                                           TRefPointerCollection<CInstance> *pList, 
                                           LPCWSTR pszNamespace, 
                                           MethodContext *pMethodContext );

    static HRESULT WINAPI GetAllInstancesAsynch( LPCWSTR pszClassName, 
                                                 Provider *pRequester, 
                                                 LPProviderInstanceCallback pCallback, 
                                                 LPCWSTR pszNamespace, 
                                                 MethodContext *pMethodContext, 
                                                 void *pUserData );

    static HRESULT WINAPI GetAllDerivedInstancesAsynch( LPCWSTR pszBaseClassName, 
                                                        Provider *pRequester, 
                                                        LPProviderInstanceCallback pCallback, 
                                                        LPCWSTR pszNamespace, 
                                                        MethodContext *pMethodContext, 
                                                        void *pUserData );

    static HRESULT WINAPI GetAllDerivedInstances( LPCWSTR pszBaseClassName, 
                                                  TRefPointerCollection<CInstance> *pList, 
                                                  MethodContext *pMethodContext, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                                  LPCWSTR pszNamespace = NULL);
#else
                                                  LPCWSTR pszNamespace);
#endif

    static HRESULT WINAPI GetInstanceByPath( LPCWSTR pszObjectPath, 
                                             CInstance **ppInstance, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                             MethodContext *pMethodContext = NULL );
#else
                                             MethodContext *pMethodContext);
#endif

    static HRESULT WINAPI GetInstanceKeysByPath( LPCWSTR pszInstancePath,
                                                 CInstance **ppInstance,
                                                 MethodContext *pMethodContext);

    static HRESULT WINAPI GetInstancePropertiesByPath( LPCWSTR pszInstancePath,
                                                 CInstance **ppInstance,
                                                 MethodContext *pMethodContext,
                                                 CHStringArray &csaProperties);

    static HRESULT WINAPI GetInstancesByQuery( LPCWSTR query, 
                                               TRefPointerCollection<CInstance> *pList, 
                                               MethodContext *pMethodContext,  
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                               LPCWSTR pszNamespace = NULL);
#else
                                               LPCWSTR pszNamespace);
#endif

    static HRESULT WINAPI GetInstancesByQueryAsynch( LPCWSTR query, 
                                                     Provider *pRequester, 
                                                     LPProviderInstanceCallback pCallback, 
                                                     LPCWSTR pszNamespace, 
                                                     MethodContext *pMethodContext, 
                                                     void *pUserData );

#ifdef FRAMEWORK_ALLOW_DEPRECATED
    // This version of GetEmptyInstance is deprecated.  Use the next one.
    static HRESULT WINAPI GetEmptyInstance( LPCWSTR pszClassName, 
                                            CInstance **ppInstance, 
                                            LPCWSTR pszNamespace = NULL);
#endif

    static HRESULT WINAPI GetEmptyInstance( MethodContext *pMethodContext, 
                                            LPCWSTR pszClassName, 
                                            CInstance **ppInstance, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                            LPCWSTR pszNamespace = NULL);
#else
                                            LPCWSTR pszNamespace);
#endif

    // Both of these FillInstance calls are deprecated.  Use GetInstanceByPath, or the even
    // more performant functions GetInstanceKeysByPath or GetInstancePropertiesByPath.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
    static HRESULT WINAPI FillInstance( CInstance *pInstance, 
                                        LPCWSTR pszNamespace = NULL );

    static HRESULT WINAPI FillInstance( MethodContext *pMethodContext, 
                                        CInstance *pInstance );
#endif

    // determine whether one class is derived from another
    static bool  WINAPI IsDerivedFrom( LPCWSTR pszBaseClassName, 
                                       LPCWSTR pszDerivedClassName, 
                                       MethodContext *pMethodContext, 
#ifdef FRAMEWORK_ALLOW_DEPRECATED
                                       LPCWSTR pszNamespace = NULL );
#else
                                       LPCWSTR pszNamespace);
#endif

    // logging in and out of framework
    // each framework based DLL must log in and out with these functions

     // Deprecated in favor of the version that takes a PLONG.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
    static BOOL WINAPI FrameworkLoginDLL(LPCWSTR name);
    static BOOL WINAPI FrameworkLogoffDLL(LPCWSTR name);
#endif

    // You must pass the *same* PLONG to all three of FrameworkLoginDLL, 
    // FrameworkLogoffDLL, and the CWbemGlueFactory constructor.
    static BOOL WINAPI FrameworkLoginDLL(LPCWSTR name, PLONG plRefCount);
    static BOOL WINAPI FrameworkLogoffDLL(LPCWSTR name, PLONG plRefCount);

    static bool WINAPI SetStatusObject(MethodContext *pContext, LPCWSTR pNamespace, 
                                        LPCWSTR pDescription, HRESULT hr, 
                                        const SAFEARRAY *pPrivilegesNotHeld = NULL,
                                        const SAFEARRAY *pPrivilegesRequired = NULL);

    ////////////////////////////////////////////////////////////////////////////////////
    // note: the following public functions are necessary to allow COM communication  //
    //       with CIMOM.  Provider Implementors will not need to call these.          //
    ////////////////////////////////////////////////////////////////////////////////////

#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR *ppvObj) ;
    STDMETHOD_(ULONG, AddRef)(THIS) ;
    STDMETHOD_(ULONG, Release)(THIS) ;
#endif
    
   virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
    );

    STDMETHOD(CreateInstanceEnumAsync)(THIS_
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(GetObjectAsync)( THIS_
            const BSTR ObjectPath, 
            long lFlags, 
            IWbemContext __RPC_FAR *pCtx, 
            IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(ExecQueryAsync)(THIS_
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(PutInstanceAsync)( THIS_
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );
    
    STDMETHOD(DeleteInstanceAsync)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    );

    STDMETHOD(ExecMethodAsync)( const BSTR, 
                                const BSTR, 
                                long, 
                                IWbemContext*, 
                                IWbemClassObject*,
                                IWbemObjectSink*
    );


 // Unsupported service methods
 // ===========================

    STDMETHOD(OpenNamespace)(THIS_
            const BSTR Namespace, 
            long lFlags,  
            IWbemContext __RPC_FAR *pCtx,
            IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace, 
            IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
    )
        { return E_NOTIMPL; }
    

    STDMETHOD(PutClass)(IWbemClassObject __RPC_FAR *pObject, 
                        long lFlags, 
                        IWbemContext __RPC_FAR *pCtx, 
                        IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
         {return E_NOTIMPL;}

    STDMETHOD(DeleteClass)(  
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
         {return E_NOTIMPL;}

    STDMETHOD(CreateClassEnum)(
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
         {return E_NOTIMPL;}

    STDMETHOD(CreateClassEnumAsync)(
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
         {return E_NOTIMPL;}

    STDMETHOD(PutInstance)(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(DeleteInstance)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )
         {return E_NOTIMPL;}

    STDMETHOD(CancelAsyncRequest)(THIS_ long lAsyncRequestHandle
    )
         {return E_NOTIMPL;}

    STDMETHOD(CancelAsyncCall)(IWbemObjectSink __RPC_FAR *pSink
    )
         {return E_NOTIMPL;}

    STDMETHOD(CreateInstanceEnum)(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
         {return E_NOTIMPL;}
  
    STDMETHOD(ExecQuery)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
         {return E_NOTIMPL;}

    STDMETHOD(QueryObjectSink)(long lFlags, 
                               IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
    )
         {return E_NOTIMPL;}


    STDMETHOD(GetObject)( const BSTR ObjectPath, 
                          long lFlags, 
                          IWbemContext __RPC_FAR *pCtx, 
                          IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject, 
                          IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
    )

         {return E_NOTIMPL;}

    STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    )
       {return E_NOTIMPL;}
        
        
    STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
    )
       {return E_NOTIMPL;}
        
    STDMETHOD(ExecMethod)(const BSTR, 
                          const BSTR, 
                          long, 
                          IWbemContext*, 
                          IWbemClassObject*,
                          IWbemClassObject**, 
                          IWbemCallResult**
    )
       {return E_NOTIMPL;}

    CWbemProviderGlue();
    CWbemProviderGlue(PLONG pCount);
    ~CWbemProviderGlue(); // Destructor

    // used by the provider base class - you probably will never need to call this directly
    static IWbemServices *WINAPI GetNamespaceConnection( LPCWSTR NameSpace );
    static IWbemServices *WINAPI GetNamespaceConnection( LPCWSTR NameSpace, MethodContext *pMethodContext );

    // each provider class must log in and out with these in their constructors and destructors
    // this is done for you in the Provider base class
    static void WINAPI FrameworkLogin( LPCWSTR a_pszName, 
                                       Provider *a_pProvider, 
                                       LPCWSTR a_pszNameSpace );

    static void WINAPI FrameworkLogoff( LPCWSTR a_pszName, 
                                        LPCWSTR a_pszNameSpace );

    static void WINAPI IncrementObjectCount(void);

    static LONG WINAPI DecrementObjectCount(void);

    static DWORD WINAPI GetOSMajorVersion() { return s_dwMajorVersion; }

    static DWORD WINAPI GetPlatform() { return s_dwPlatform; }

    static LPCWSTR WINAPI GetCSDVersion() { return s_wstrCSDVersion; }

 private:

    IWbemServices *WINAPI InternalGetNamespaceConnection( LPCWSTR NameSpace );

    static HRESULT WINAPI GetInstanceFromCIMOM( LPCWSTR pszObjectPath,
                                        LPCWSTR pszNameSpace,
                                        MethodContext *pMethodContext,
                                        CInstance **ppInstance );   

    void FlushAll(void);

    static Provider *WINAPI SearchMapForProvider( LPCWSTR a_pszProviderName, 
                                                  LPCWSTR a_pszNamespace );

    static Provider *WINAPI AddProviderToMap( LPCWSTR a_pszProviderName, 
                                              LPCWSTR a_strNamespace, 
                                              Provider *a_pProvider );

    static void WINAPI LockProviderMap( void );

    static void WINAPI UnlockProviderMap( void );

    static void WINAPI LockFactoryMap( void );

    static void WINAPI UnlockFactoryMap( void );

    static IWbemClassObject *WINAPI GetStatusObject( MethodContext *pContext, 
                                                     LPCWSTR pNamespace);
    static void WINAPI Init( void );

    static void WINAPI UnInit( void );

    static void WINAPI GetComputerName( CHString& strComputerName );
    
    static HRESULT WINAPI CheckImpersonationLevel();

    HRESULT PreProcessPutInstanceParms(IWbemClassObject __RPC_FAR *pInstIn, 
                                       IWbemClassObject __RPC_FAR **pInstOut, 
                                       IWbemContext __RPC_FAR *pCtx);    

    HRESULT NullOutUnsetProperties(IWbemClassObject __RPC_FAR *pInstIn, 
                                   IWbemClassObject __RPC_FAR **pInstOut, 
                                   const VARIANT& vValue);

    void AddFlushPtr(LPVOID pVoid);

    long    m_lRefCount; 
    CHString    m_strNamespace;
    IWbemServices *m_pServices;
    static long s_lObjects; // number of objects out there - class factories & WbemGlues
    PLONG m_pCount;
    PROVIDERPTRS m_FlushPtrs;
    CCritSec         m_csFlushPtrs;

    static STRING2LPVOID    s_providersmap;
    static CCritSec s_csProviderMap;
    static CCritSec m_csStatusObject;
    static BOOL s_bInitted;
    static DWORD s_dwPlatform;
    static DWORD s_dwMajorVersion;
    static WCHAR s_wstrCSDVersion[_MAX_PATH];
    static IWbemClassObject *m_pStatusObject;
    static PTR2PLONG        s_factorymap;
    static CCritSec         s_csFactoryMap;

protected:
    friend CWbemGlueFactory;

    static LONG IncrementMapCount(const CWbemGlueFactory *pGlue);
    static LONG IncrementMapCount(PLONG pCount);
    static LONG DecrementMapCount(const CWbemGlueFactory *pGlue);
    static LONG DecrementMapCount(PLONG pCount);
    static PLONG GetMapCountPtr(const CWbemGlueFactory *pGlue);
    static VOID AddToFactoryMap(const CWbemGlueFactory *pGlue, PLONG pdwRefCount);
    static VOID RemoveFromFactoryMap(const CWbemGlueFactory *pGlue);
};

inline void CWbemProviderGlue::LockProviderMap( void )
{
    EnterCriticalSection( &s_csProviderMap );
}

inline void CWbemProviderGlue::UnlockProviderMap( void )
{
    LeaveCriticalSection( &s_csProviderMap );
}

inline void CWbemProviderGlue::LockFactoryMap( void )
{
    EnterCriticalSection( &s_csFactoryMap );
}

inline void CWbemProviderGlue::UnlockFactoryMap( void )
{
    LeaveCriticalSection( &s_csFactoryMap );
}

class POLARITY CWbemGlueFactory : public IClassFactory
{
 protected:
    long m_lRefCount;

 public:
     // Deprecated in favor of the constructor that takes a PLONG.  This
     // must be the same PLONG that is passed to FrameworkLoginDLL &
     // FrameworkLogoffDLL.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        CWbemGlueFactory(void);
#endif
        CWbemGlueFactory(PLONG plRefCount);
        ~CWbemGlueFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CWbemGlueFactory *PCWbemGlueFactory;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\impersonaterevert.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  ImpersonateRevert.h
//
//  Purpose: revert impersonated thread token 
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __IMPERSONATE_REVERT__
#define __IMPERSONATE_REVERT__


class ProviderImpersonationRevert
{
	HANDLE hThreadToken;

	BOOL bImpersonated;
	BOOL bReverted;

	public:

	ProviderImpersonationRevert ( BOOL bThreadCall = TRUE ) :
		hThreadToken ( INVALID_HANDLE_VALUE ),
		bImpersonated ( TRUE ),
		bReverted ( FALSE )
	{
		BOOL bDone = TRUE;
		BOOL bThreadCall_Local = bThreadCall;

		do
		{
			bDone = TRUE;

			if ( OpenThreadToken	(
										GetCurrentThread(),
										TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
										bThreadCall_Local,
										&hThreadToken
									)
			   ) 
			{
				if ( RevertToSelf() )
				{
					bReverted = TRUE;
				}
				else
				{
					#if DBG == 1
					// for testing purpose I will let process break
					::DebugBreak();
					#endif
				}
			}
			else
			{
				DWORD dwError = ::GetLastError ();
				if ( ERROR_ACCESS_DENIED == dwError )
				{
					if ( bThreadCall_Local )
					{
						#if DBG == 1
						// for testing purpose I will let process break
						::DebugBreak();
						#endif
					}
					else
					{
						bThreadCall_Local = TRUE;
						bDone = FALSE;
					}
				}
				else if ( ERROR_NO_TOKEN == dwError || ERROR_NO_IMPERSONATION_TOKEN == dwError )
				{
					bImpersonated = FALSE;
				}
			}
		}
		while ( ! bDone );
	}

	~ProviderImpersonationRevert ()
	{
		// impersonate back (if not already)
		Impersonate ();

		if ( hThreadToken != INVALID_HANDLE_VALUE )
		{
			CloseHandle(hThreadToken);
			hThreadToken = INVALID_HANDLE_VALUE;
		}
	}

	BOOL Reverted ()
	{
		return ( bImpersonated && bReverted );
	}

	BOOL Impersonate ()
	{
		if ( Reverted () )
		{
			if ( ! ImpersonateLoggedOnUser ( hThreadToken ) )
			{
				#if DBG == 1
				// for testing purpose I will let process break
				::DebugBreak();
				#endif

				// we need to throw here to avoid running as process
				throw CFramework_Exception( L"ImpersonateLoggedOnUser failed", HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ;

			}
			else
			{
				bReverted = FALSE;
			}
		}

		return !bReverted;
	}
};

#endif	__IMPERSONATE_REVERT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\lockwrap.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  LockWrap.h
//
//  Purpose: Wrapper class for critical sections
//
//***************************************************************************

#include "stllock.h"

#if _MSC_VER > 1000
#pragma once
#endif

// You use this class by passing via the constructor the name of the 
// critical section you want to lock.  When the CLockWrapper goes
// out of scope it will unlock itself.
class CLockWrapper
{
public:
    CLockWrapper(CCritSec &cs)
    {
	    m_pCS = &cs;

	    m_pCS->Enter();
    }

    ~CLockWrapper()
    {
        m_pCS->Leave();
    }

protected:
    CCritSec *m_pCS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\frqueryex.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  FRQueryEx.h
//
//  Purpose: Extended and non-published query support classes
//
//***************************************************************************

#pragma once

#define SetBit( p, offset ) \
            *((BYTE*)p + ((unsigned int)offset / 8)) |= (1 << ((unsigned int)offset % 8) )

#define IsBitSet( p, offset )   \
            *((BYTE*)p + ((unsigned int)offset / 8)) & (1 << ((unsigned int)offset % 8) )

#define SetAllBits( p, maxBits )    \
            memset( p , 0xff, ((unsigned int)maxBits / 8) + 1 )

#define ZeroAllBits( p, maxBits )   \
            memset( p , 0x00, ((unsigned int)maxBits / 8) + 1 )

class POLARITY CFrameworkQueryEx : public CFrameworkQuery
{
protected:
    CHString m_sQueryEx;

public:
    CFrameworkQueryEx();
    ~CFrameworkQueryEx();

// Note: call VariantInit on the variants before calling this function.

// This method is a quick and dirty implementation.  It is needed to allow for optimization of
// a specific type of query that is generated by cimon during a specific type of assocation queries.
// If the association is between two instances of the same class (like Directory To SubDirectory),
// cimom generates a query of the form WHERE (Antecedent = 'D:\foo' or Dependent = 'D:\foo').  The normal
// GetValuesForProp can't handle this.
//
// First this routine checks the query to see if it is an OR query between
// exactly two expressions.  The expressions must be = operators (ie not >, <=, etc).
// If so, then it checks the property names of the two expressions against the two passed in property names.
// If they both match, it sends back the values in the variants, and returns TRUE;
//
// So, these queries all return FALSE for a call like this (L"x", L"y", vVar1, vVar2):
// "Select * from foo"
// "Select * from foo where x=5",
// "Select * from foo where x=5 and y = 7"
// "Select * from foo where x = 5 or x = 6 or x = 7"
// "Select * from foo where x = 5 or y < 8"
// "Select * from foo where x = 5 or z = 9"

// These will return TRUE for the same call
// "Select * from foo where x = 5 or y = 6
// "Select * from foo where y = 6 or x = 5"
// "Select * from foo where (y = 6 or x = 5)"
    BOOL Is3TokenOR(LPCWSTR wszProp1, LPCWSTR wszProp2, VARIANT &vVar1, VARIANT &vVar2);


/*****************************************************************************
 *
 *  FUNCTION    : IsNTokenAnd
 *
 *  DESCRIPTION : Checks to see if the query is of the form:
 *                propname1 = value1 [and propname2 = value2 [and etc]]]
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : CHStringArray - Outputs the propnames
 *                CHPtrArray    - Outputs array of variant_t*
 *
 *  RETURNS     : TRUE if the query is of the correct form, else FALSE
 *
 *  COMMENTS    :
 *
 *  The only joining operator recognized is AND.  'OR' and 'NOT' will both
 *  cause the function to return FALSE.  Because of the operation of the
 *  parsing class, parenthesis will get simplified out if all joining operators
 *  are AND, so ((propname1 = value1) and propname2 = value2) should also work.
 *
 *  The properties must be doing equality comparisons (=) to their values (ie not
 *  >, < >=, etc).  If they are not, this function returns FALSE.
 *
 *  Lastly, property names cannot repeat, or else this function returns FALSE.
 *
 *  Both the CHStringArray and the CHPtrArray must be empty before calling this
 *  function.  Further, the elements CHPtrArray MUST BE FREED BY THE CALLER.
 *
 *  As a note, the property names returned in sarr will all be uppercase.
 *
 *  Also note, queries of the form propname1 = value1 will return true.
 *
 *****************************************************************************/

    BOOL IsNTokenAnd(CHStringArray &sarr, CHPtrArray &sPtrArr);


    // Like CFrameworkQuery::GetValuesForProp except uses variant_t's.
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<_variant_t>& vectorValues);

    // Like CFrameworkQuery::GetValuesForProp except uses ints
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<int>& vectorValues);

/*****************************************************************************
 *
 *  FUNCTION    : GetPropertyBitMask
 *
 *  DESCRIPTION : Checks an array of property names, and sets a bitmask to
 *                show which properties are required.
 *
 *  INPUTS      : Array to scan
 *
 *  OUTPUTS     : Array of bits.
 *
 *  RETURNS     :
 *
 *  COMMENTS    : We must populate the elements in the where clause, otherwise
 *                winmgmt will postprocess away all our instances.
 *
 *****************************************************************************/
    void GetPropertyBitMask(const CHPtrArray &Properties, LPVOID pBits);

    virtual HRESULT InitEx(

            const BSTR bstrQueryFormat, 
            const BSTR bstrQuery, 
            long lFlags,
            CHString &sNamespace
    );

    virtual bool IsExtended();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\smartptr.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  SmartPtr.h
//
//  Purpose: Declare smartpointer typedefs
//
//***************************************************************************

#pragma once
#include <io.h>

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemQuery, __uuidof(IWbemQuery));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment, __uuidof(IUnsecuredApartment));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));
//_COM_SMARTPTR_TYPEDEF(IWbemBackupRestore, __uuidof(IWbemBackupRestore));
_COM_SMARTPTR_TYPEDEF(IWbemRefresher, __uuidof(IWbemRefresher));
_COM_SMARTPTR_TYPEDEF(IWbemHiPerfEnum, __uuidof(IWbemHiPerfEnum));
_COM_SMARTPTR_TYPEDEF(IWbemConfigureRefresher, __uuidof(IWbemConfigureRefresher));
_COM_SMARTPTR_TYPEDEF(IMofCompiler, __uuidof(IMofCompiler));
_COM_SMARTPTR_TYPEDEF(ExternalMethodContext, __uuidof(ExternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContext, __uuidof(InternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContextAsynch, __uuidof(InternalMethodContextAsynch));
_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class SmartCloseHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHandle(HANDLE h):m_h(h){}
   ~SmartCloseHandle(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class Smart_findclose
{

private:
	intptr_t m_h;

public:
	Smart_findclose():m_h(0){}
	Smart_findclose(intptr_t h):m_h(h){}
   ~Smart_findclose(){if (m_h!=0) _findclose(m_h);}
	intptr_t operator =(intptr_t h) {if (m_h) _findclose(m_h); m_h=h; return h;}
	operator intptr_t() const {return m_h;}
	intptr_t* operator &() {if (m_h) _findclose(m_h); m_h = 0; return &m_h;}
};

class SmartFindClose
{

private:
	HANDLE m_h;

public:
	SmartFindClose():m_h(INVALID_HANDLE_VALUE){}
	SmartFindClose(HANDLE h):m_h(h){}
   ~SmartFindClose(){if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class SmartCloseServiceHandle
{

private:
	SC_HANDLE m_h;

public:
	SmartCloseServiceHandle():m_h(NULL){}
	SmartCloseServiceHandle(SC_HANDLE h):m_h(h){}
   ~SmartCloseServiceHandle(){if (m_h!=NULL) CloseServiceHandle(m_h);}
	SC_HANDLE operator =(SC_HANDLE h) {if (m_h!=NULL) CloseServiceHandle(m_h); m_h=h; return h;}
	operator SC_HANDLE() const {return m_h;}
	SC_HANDLE* operator &() {if (m_h!=NULL) CloseServiceHandle(m_h); m_h = NULL; return &m_h;}
};

class CSmartCreatedDC
{
public:
    CSmartCreatedDC(HDC hdc) { m_hdc = hdc;}
	operator HDC() const {return m_hdc;}
    ~CSmartCreatedDC() 
    { 
        if (m_hdc)
            DeleteDC(m_hdc); 
    }

protected:
    HDC m_hdc;
};

class CSmartBuffer
{
private:
	LPBYTE m_pBuffer;

public:
	CSmartBuffer() : m_pBuffer(NULL) {}
	CSmartBuffer(LPBYTE pBuffer) : m_pBuffer(pBuffer) {}
    CSmartBuffer(DWORD dwSize)
    {
        m_pBuffer = new BYTE[dwSize];
        if (m_pBuffer == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    ~CSmartBuffer()
    {
        Free();
    }

	LPBYTE operator =(LPBYTE pBuffer) 
    {
        Free();
            
        m_pBuffer = pBuffer; 
        
        return m_pBuffer;
    }
	
    operator LPBYTE() const { return m_pBuffer; }
	
    LPBYTE* operator &()
    {
        Free();

        m_pBuffer = NULL;
        
        return &m_pBuffer;
    }

protected:
    void Free()
    {
        if (m_pBuffer != NULL) 
        {
            delete [] m_pBuffer;
        }
    }
};

template <typename O, typename FT, FT F> class FrameDynOnDeleteObjVoid
{
	private:
	O*		Obj_;
	BOOL	bExec;

	public:
	FrameDynOnDeleteObjVoid ( O* Val ): Obj_ ( Val ), bExec ( FALSE )
	{
	};

	void Exec ( BOOL bSetExecFlag = TRUE )
	{
		(Obj_->*F)();

		if ( bSetExecFlag )
		{
			bExec = TRUE;
		}
	}

	void SetExecFlag ( BOOL bSetExecFlag = TRUE )
	{
		bExec = bSetExecFlag ;
	}

	void ReSetExecFlag ( )
	{
		SetExecFlag ( FALSE ) ;
	}

	~FrameDynOnDeleteObjVoid ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

template <typename T, typename FT, FT F> class FrameDynOnDelete
{
	private:
	T		Val_;
	BOOL	bExec;

	public:
	FrameDynOnDelete ( T Val ): Val_ ( Val ), bExec ( FALSE )
	{
	};

	void Exec ( )
	{
		F(Val_);
		bExec = TRUE;
	}

	~FrameDynOnDelete ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

#ifndef	__WAITEX__
#define	__WAITEX__

template < typename T, typename FT, FT F, int iTime >
class WaitException
{
	public:
	WaitException ( T Val_ )
	{
		BOOL bResult = FALSE;
		while ( ! bResult )
		{
			try
			{
				F ( Val_ );
				bResult = TRUE;
			}
			catch ( ... )
			{
			}

			if ( ! bResult )
			{
				::Sleep ( iTime );
			}
		}
	}
};

#endif	__WAITEX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\createmutexasprocess.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  CreateMutexAsProcess.h
//
//  Purpose: Create a mutex NOT using impersonation
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CREATE_PROCESS_AS_MUTEX_
#define _CREATE_PROCESS_AS_MUTEX_

///////////////////////////////////////////////////////////////////
//  Creates a specified mutex under the process account context.
//
//  Uses construction/destruction semantics - just declare one
//	on the stack, scoped around the area where you are making 
//	calls that could cause the deadlock;
//////////////////////////////////////////////////////////////////
class POLARITY CreateMutexAsProcess
{
public:
	CreateMutexAsProcess(const WCHAR *cszMutexName);
	~CreateMutexAsProcess();
private:
	HANDLE m_hMutex;
};

//  This Mutex should be instanciated around any calls to 
//  LookupAccountSid, LookupAccountName, 
//
#define SECURITYAPIMUTEXNAME L"Cimom NT Security API protector"

// Used by provider.cpp
#define WBEMPROVIDERSTATICMUTEX L"WBEMPROVIDERSTATICMUTEX"

// Used by all perfmon routines.
#define WBEMPERFORMANCEDATAMUTEX L"WbemPerformanceDataMutex"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\stopwatch.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  StopWatch.h
//
//  Purpose: Timing functions
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _STOPWATCH_COMPILED_ALREADY_
#define _STOPWATCH_COMPILED_ALREADY_

#include <wchar.h>
#include <stdio.h>

#ifdef PROVIDER_INSTRUMENTATION

    #define PROVIDER_INSTRUMENTATION_START(pmc, timer) \
        if ( pmc && pmc->pStopWatch) \
            pmc->pStopWatch->Start(timer);

    #define PROVIDER_INSTRUMENTATION_START2(pStopWatch, timer) \
        if (pStopWatch) \
            pStopWatch->Start(timer);


class POLARITY StopWatch
{
public:
    // those types of timers we have.
    // note that any new timers must be added before NTimers
    enum Timers {NullTimer = -1, FrameworkTimer =0, ProviderTimer, AtomicTimer, WinMgmtTimer, NTimers};

    StopWatch(const CHString& reason);

    // start a particular timer, stopping the previous one
    void Start(Timers timer);
    // call this only at the very end
    void Stop();
    
    __int64 GetTime(Timers timer);

    void LogResults();

private:
    // something to spit to the log to identify this run
    CHString m_reason;

    // track the times we're timing
    // elapsed times in array
    __int64  m_times[NTimers];
    // the one we're currently tracking
    Timers m_currentTimer;
    // the start time for the one we're currently tracking
    LARGE_INTEGER  m_startTime;
};

inline StopWatch::StopWatch(const CHString& reason)
{
    m_reason = reason;
    m_currentTimer = NullTimer;
    ZeroMemory(m_times, sizeof(m_times));
}

inline void StopWatch::Start(Timers timer)
{
    LARGE_INTEGER count;
    QueryPerformanceCounter(&count);

    if (m_currentTimer != NullTimer)
        m_times[m_currentTimer] += count.QuadPart - m_startTime.QuadPart;

    m_currentTimer = timer;
    m_startTime = count;
}
inline void StopWatch::Stop()
{
    Start(NullTimer);
}
inline __int64 StopWatch::GetTime(Timers timer)
{
    return m_times[timer];
}

inline void StopWatch::LogResults()
{
	FILE *fpLogFile;

	fpLogFile = _wfopen( L"C:\\StopWatch.log", L"a+" );

	if(fpLogFile) 
	{
		WCHAR datebuffer [9];
		WCHAR timebuffer [9];
		_wstrdate( datebuffer );
		_wstrtime( timebuffer );

        LARGE_INTEGER omega;
        QueryPerformanceFrequency(&omega);

//		_ftprintf(fpLogFile, L"%s\n\t%-8s %-8s\n", m_reason, datebuffer, timebuffer);
		fwprintf(fpLogFile, L"%s\n ", m_reason);
        fwprintf(fpLogFile, L"Framework\tProvider\tWinmgmt \tAtomic\n %I64u\t%I64u\t%I64u\t%I64u\n",
            GetTime(FrameworkTimer), GetTime(ProviderTimer), GetTime(WinMgmtTimer), omega);

        fclose(fpLogFile);
	}
}

#else

    #define PROVIDER_INSTRUMENTATION_START(pmc, timer)
    #define PROVIDER_INSTRUMENTATION_START2(pStopWatch, timer)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\psstools\utillib\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\framedyn\private\winmsgevent.h ===
//=================================================================
//
// WinMsgEvent.h -- 
//
// Copyright  Microsoft Corporation.  All rights reserved.
//
//=================================================================

#ifndef _WBEM_MESSAGE_EVENT_FORWARDER_H
#define _WBEM_MESSAGE_EVENT_FORWARDER_H

using namespace std;
#define MSGWINDOWNAME TEXT("WinMsgEventProvider") 

//
class POLARITY CAutoEvent 
{
	HANDLE	m_hEvent ;
public:	
	CAutoEvent()	{ m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ); };
    ~CAutoEvent()	{ CloseHandle( m_hEvent ); };

	DWORD Wait( DWORD a_dwMillSec ) { return WaitForSingleObject( m_hEvent, a_dwMillSec ); };
    BOOL Signal()					{ return SetEvent( m_hEvent ); }; 
};

//
class POLARITY CWinMsgEvent 
{
private:

	static	CCritSec			mg_csMapLock ;
	static	CCritSec			mg_csWindowLock ;
	static	CAutoEvent			mg_aeCreateWindow ; 
	typedef std::multimap<UINT, CWinMsgEvent*> Sink_Map ;
	static	Sink_Map			mg_oSinkMap ;
	
	static  HANDLE				mg_hThreadPumpHandle ;
	static	HWND				mg_hWnd ;		 

	static void HandleEvent( DWORD a_dwPowerEvent, DWORD a_dwData ) ;
		
	static void CreateMsgProvider() ;
	static HWND CreateMsgWindow() ;
	static void DestroyMsgWindow() ;
	static void WindowsDispatch() ;
	
	static LRESULT CALLBACK MsgWndProc(

				IN HWND a_hWnd,
				IN UINT a_message,
				IN WPARAM a_wParam,
				IN LPARAM a_lParam ) ;
		
	static DWORD WINAPI dwThreadProc( LPVOID lpParameter );
	static BOOL WINAPI CtrlHandlerRoutine( DWORD dwCtrlType ) ;

protected:

	void RegisterForMessage(
		
		IN UINT a_message
		) ;

	bool UnRegisterMessage(
		
		IN UINT a_message
		) ;

	void UnRegisterAllMessages() ;


public:

    CWinMsgEvent () ;
    ~CWinMsgEvent () ;

	enum E_ReturnAction {
		e_DefProc,			// call DefWindowProc
		e_ReturnResult		// return msg with WinMsgEvent() LRESULT  
	};

	virtual void WinMsgEvent(
		
		IN	HWND a_hWnd,
        IN	UINT a_message,
        IN	WPARAM a_wParam,
        IN	LPARAM	a_lParam,
		OUT E_ReturnAction &eRetAction,
		OUT LRESULT &a_lResult
		) = 0 ;
};


#endif // _WBEM_MESSAGE_EVENT_FORWARDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\psstools\utillib\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//
#define _WIN32_DCOM


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\psstools\utillib\utillib.h ===
// **************************************************************************

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// File:  utillib.h
//
// Description:
//    Set of sample routines
//
// History:
//
// **************************************************************************

#define MAXITOA  19
#define FWPRINTF myFWPrintf
#define CLASSPROP L"__CLASS"
#define SERVERPROP L"__SERVER"
#define PATHPROP L"__PATH"
#define NAMESPACEPROP L"__NAMESPACE"
#define SYSTEMCLASS L"__SystemClass"
#define RELPATHPROP L"__RELPATH"
#define NAMEPROP L"Name"
#define CIMTYPEQUAL L"CIMTYPE"
#define KEYQUAL L"key"
#define SYSTEMPREFIX L"__"
#define CVTFAILED L"WideCharToMultiByte failed\n"
#define RELEASE(a) if (a) { (a)->Release(); (a)=NULL;}
#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop  (this size stolen from cvt.h in c runtime library) */
#define PAGESIZE 4096
#define ERROR_MODE_PRINTFIELDS 0
#define ERROR_MODE_PRINTMOF 1
#define UNREFERENCED(x)

#include <comdef.h>

_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));

char *cvt(WCHAR *x, char **y);
double difftime(struct _timeb finish, struct _timeb start);
int myFWPrintf(FILE *f, WCHAR *fmt, ...);
const WCHAR *TypeToString(VARIANT *p);
const WCHAR *TypeToString(VARTYPE v);
const WCHAR *TypeToString(CIMTYPE v);
WCHAR *ValueToString(CIMTYPE dwType, VARIANT *pValue, WCHAR **pbuf, WCHAR *fnHandler(VARIANT *pv) = NULL);
BSTR WbemErrorString(SCODE sc);
void PrintErrorAndExit(char *pszFailureReason, SCODE sc, DWORD dwMode);
void PrintErrorAndAsk(char *pszFailureReason, SCODE sc, DWORD dwMode);
void PrintError(char *pszFailureReason, SCODE sc, DWORD dwMode);

class MyString {
private:
   WCHAR *pwszString;

public:
   MyString::MyString() {pwszString = (WCHAR *)calloc(1, sizeof(WCHAR));}
   MyString::~MyString() {free(pwszString);}
   WCHAR *GetString() {return pwszString;}
   void Empty() {free(pwszString);pwszString = (WCHAR *)calloc(1, sizeof(WCHAR));}
   WCHAR *GetCloneString()
   {
      WCHAR *buf = NULL;
	  if (pwszString)
	  {
		  buf = (WCHAR *)malloc((wcslen(pwszString) + 1) * sizeof(WCHAR));
		  if (buf)
			wcscpy(buf, pwszString);
	  }
      return buf;
   }
   const MyString& operator+=(const WCHAR *arg1) 
      {
         size_t iHave;
         size_t iNeed;
         if (arg1)
         {
             iHave = wcslen(pwszString);
             iNeed = wcslen(arg1);
             WCHAR* pTmp = (WCHAR *)realloc(pwszString, (iHave + iNeed + 1) * sizeof(WCHAR));
             
             if (pTmp)
             {
                pwszString = pTmp;             
                wcscat(&pwszString[iHave], arg1);
             }
         }
         return *this;
      }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\psstools\utillib\wbemsec.h ===
//***************************************************************************

//

//  WBEMSEC.H

//

//  Purpose: Provides prototypes for some security helper functions.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _WBEMSEC_H_
#define _WBEMSEC_H_

HRESULT InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel);
SCODE GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel);
HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel);

#endif // _WBEMSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\commonfuncs.h ===
#pragma once

HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName);
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk);
BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl);
HRESULT SetVSInstallDirectory(IDispatch * pEnv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\psstools\utillib\wbemsec.cpp ===
//***************************************************************************

//

//  WBEMSEC.CPP

//

//  Purpose: Provides some security helper functions.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//#undef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
#include "precomp.h"
#include <wbemidl.h>
#include "wbemsec.h"

//***************************************************************************
//
//  InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel)
//
//  DESCRIPTION:
//
//  Initialize DCOM security.  The authentication level is typically
//  RPC_C_AUTHN_LEVEL_CONNECT,  and the impersonation level is typically
// RPC_C_IMP_LEVEL_IMPERSONATE.  When using asynchronous call backs, an
// authentication level of RPC_C_AUTHN_LEVEL_NONE is useful
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

HRESULT InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel)
{
    // Initialize security
    // ===================

    return CoInitializeSecurity(NULL, -1, NULL, NULL,
        dwAuthLevel, dwImpLevel,
        NULL, EOAC_NONE, 0);
}

//***************************************************************************
//
//  bool bIsNT
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

bool bIsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}


//***************************************************************************
//
//  SCODE ParseAuthorityUserArgs
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  ConnType            Returned with the connection type, ie wbem, ntlm
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE ParseAuthorityUserArgs(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User)
{

    // Determine the connection type by examining the Authority string

    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return E_INVALIDARG;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(Authority && wcslen(Authority) > 11)
    {
        if(pSlashInUser)
            return E_INVALIDARG;

        AuthArg = SysAllocString(Authority + 11);
        if(User) UserArg = SysAllocString(User);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        INT_PTR iDomLen = min(MAX_PATH-1, pSlashInUser-User);
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);

    return S_OK;
}


//***************************************************************************
//
//  SCODE GetAuthImp
//
//  DESCRIPTION:
//
//  Gets the authentication and impersonation levels for a current interface.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//  pdwAuthLevel    Set to the authentication level
//  pdwImpLevel    Set to the impersonation level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel)
{

    if(pFrom == NULL || pdwAuthLevel == NULL || pdwImpLevel == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc,
                                            NULL,
                                            pdwAuthLevel, pdwImpLevel,
                                            NULL, &dwCapabilities);

        // Special case of going to a win9x share level box

        if (sc == 0x800706d2)
        {
            *pdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
            *pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            sc = S_OK;
        }
        pFromSec->Release();
    }
    return sc;
}
//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  NOTE that setting the security blanket on the interface is not recommended.
//  The clients should typically just call CoInitializeSecurity( NULL, -1, NULL, NULL, 
//											RPC_C_AUTHN_LEVEL_DEFAULT, 
//											RPC_C_IMP_LEVEL_IMPERSONATE, 
//											NULL, 
//											EOAC_NONE, 
//											NULL );
//  before calling out to WMI.
//
//
//  PARAMETERS:
//
//  pInterface         Interface to be set
//  pDomain           Input, domain
//  pUser                Input, user name
//  pPassword        Input, password.
//  pFrom               Input, if not NULL, then the authentication level of this interface
//                           is used
//  bAuthArg          If pFrom is NULL, then this is the authentication level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser,
                             LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel)
{

    SCODE sc;
    if(pInterface == NULL)
        return E_INVALIDARG;

    // If we are lowering the security, no need to deal with the identification info

    if(dwAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
        return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);

    // If we are doing trivial case, just pass in a null authentication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) &&
        (pUser == NULL || wcslen(pUser) < 1) &&
        (pPassword == NULL || wcslen(pPassword) < 1))
            return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, NULL, EOAC_NONE);

    // If user, or Authority was passed in, the we need to create an authority argument for the login

    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL;
    sc = ParseAuthorityUserArgs(AuthArg, UserArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
    if(bIsNT())
    {
        if(UserArg)
        {
            authident.UserLength = (ULONG)wcslen(UserArg);
            authident.User = (LPWSTR)UserArg;
        }
        if(AuthArg)
        {
            authident.DomainLength = (ULONG)wcslen(AuthArg);
            authident.Domain = (LPWSTR)AuthArg;
        }
        if(pPassword)
        {
            authident.PasswordLength = (ULONG)wcslen(pPassword);
            authident.Password = (LPWSTR)pPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {
        char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

        // Fill in the indentity structure

        if(UserArg)
        {
            wcstombs(szUser, UserArg, MAX_PATH);
            authident.UserLength = (ULONG)strlen(szUser);
            authident.User = (LPWSTR)szUser;
        }
        if(AuthArg)
        {
            wcstombs(szAuthority, AuthArg, MAX_PATH);
            authident.DomainLength = (ULONG)strlen(szAuthority);
            authident.Domain = (LPWSTR)szAuthority;
        }
        if(pPassword)
        {
            wcstombs(szPassword, pPassword, MAX_PATH);
            authident.PasswordLength = (ULONG)strlen(szPassword);
            authident.Password = (LPWSTR)szPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    }
    sc = CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, &authident, EOAC_NONE);

    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\psstools\utillib\utils.cpp ===
// **************************************************************************

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// File:  utils.cpp
//
// Description:
//    Set of sample routines
//
// History:
//
// **************************************************************************

//#pragma warning(disable:4201)  // nonstandard extension nameless struct (used in windows.h)
//#pragma warning(disable:4514)  // unreferenced inline function has been removed (used in windows.h)

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>
#include <sys\timeb.h>
#include "utillib.h"

//*****************************************************************************
// Function:   WbemErrorString
// Purpose:    Turns sc into a text string
//*****************************************************************************
BSTR WbemErrorString(SCODE sc)
{
    IWbemStatusCodeTextPtr pStatus;
    BSTR bstr = NULL;

    SCODE mysc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

    if (mysc == S_OK)
    {
        mysc = pStatus->GetErrorCodeText(sc, 0, 0, &bstr);
        if (mysc == S_OK)
        {
        }
        else
        {
            WCHAR szBuffer2[MAXITOA];
            WCHAR szBuffer[sizeof(szBuffer2) + 4];

            _ltow(sc, szBuffer2, 16);
            wcscpy(szBuffer, L"0x");
            wcscat(szBuffer, szBuffer2);
            bstr = SysAllocString(szBuffer);
        }
    }

    return bstr;
}

//***************************************************************************
// Function:  PrintError
// Purpose:   Formats and prints the error message
//***************************************************************************
void PrintError(char *pszFailureReason, SCODE psc, DWORD dwMode)
{
    VARIANT varString;
    SCODE sc;
    IWbemClassObject *pErrorObject = NULL;
    IErrorInfo* pEI = NULL;

    fprintf(stdout, "%s\n", pszFailureReason);
    fprintf(stdout, "FunctionReturn: %S(0x%08lx)\n", WbemErrorString(psc), psc);

    if (GetErrorInfo(0, &pEI) == S_OK)
    {
        pEI->QueryInterface(IID_IWbemClassObject, (void**)&pErrorObject);
        pEI->Release();
    }

    if (pErrorObject != NULL)
    {
        VariantInit(&varString);

        if (dwMode == ERROR_MODE_PRINTFIELDS)
        {
            if (pErrorObject->InheritsFrom(L"__NotifyStatus") != WBEM_NO_ERROR)
            {
                fprintf(stdout, "Unrecognized Error Object type\n");
            }
            else if (pErrorObject->InheritsFrom(L"__ExtendedStatus") == WBEM_NO_ERROR)
            {
                sc = pErrorObject->Get(L"Description", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get Description: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"Description: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);

                pErrorObject->Get(L"Operation", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get Operation: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"Operation: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);

                pErrorObject->Get(L"ParameterInfo", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get ParameterInfo: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"ParameterInfo: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);

                pErrorObject->Get(L"ProviderName", 0L, &varString, NULL, NULL);
                if (sc != S_OK)
                {
                    fprintf(stdout, "Can't get ProviderName: %d\n", sc);
                }
                else if (V_VT(&varString) == VT_BSTR)
                {
                    FWPRINTF(stdout, L"ProviderName: %wS\n", V_BSTR(&varString));
                }
                VariantClear(&varString);
            }
        }
        else
        {
            BSTR bstrObjectText = NULL;
            if (SUCCEEDED(pErrorObject->GetObjectText(0, &bstrObjectText)))
            {
                fprintf(stdout, "%wS", bstrObjectText);
                SysFreeString(bstrObjectText);
            }
        }

        RELEASE(pErrorObject);
    }
}

//***************************************************************************
// Function:  PrintErrorAndExit
// Purpose:   Formats an error message & exits program
//***************************************************************************
void PrintErrorAndExit(char *pszFailureReason, SCODE sc, DWORD dwMode)
{
    PrintError(pszFailureReason, sc, dwMode);

    // Clean up and exit
    OleUninitialize();
    printf("Abnormal Termination\n");
    exit(1);
};

//***************************************************************************
// Function:  PrintErrorAndAsk
// Purpose:   Prints the error message and prompts to continue
//***************************************************************************
void PrintErrorAndAsk(char *pszFailureReason, SCODE sc, DWORD dwMode)
{
    int c;

    PrintError(pszFailureReason, sc, dwMode);
    printf("Continue (Y/N)? ");

    c = getchar();
    while (getchar() != '\n')
    {
    }

    if ((c != 'Y') && (c != 'y'))
    {
        // Clean up and exit
        OleUninitialize();
        exit(1);
    }
};

//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a variant, returns a pointer to a string that is the variant type
//*****************************************************************************
const WCHAR *TypeToString(VARIANT *p)
{
    return TypeToString(p->vt);
}

//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a VARTYPE, returns a pointer to a string that is the variant type
//*****************************************************************************
const WCHAR *TypeToString(VARTYPE v)
{
    const static WCHAR *pVT_NULL  = L"VT_NULL";
    const static WCHAR *pVT_EMTPY = L"VT_EMPTY";
    const static WCHAR *pVT_I1    = L"VT_I1";
    const static WCHAR *pVT_UI1   = L"VT_UI1";
    const static WCHAR *pVT_I2    = L"VT_I2";
    const static WCHAR *pVT_UI2   = L"VT_UI2";
    const static WCHAR *pVT_I4    = L"VT_I4";
    const static WCHAR *pVT_UI4   = L"VT_UI4";
    const static WCHAR *pVT_I8    = L"VT_I8";
    const static WCHAR *pVT_UI8   = L"VT_UI8";
    const static WCHAR *pVT_R4    = L"VT_R4";
    const static WCHAR *pVT_R8    = L"VT_R8";
    const static WCHAR *pVT_BOOL  = L"VT_BOOL";
    const static WCHAR *pVT_BSTR  = L"VT_BSTR";
    const static WCHAR *pVT_DISPATCH = L"VT_DISPATCH";
    const static WCHAR *pVT_UNKNOWN = L"VT_UNKNOWN";
    const static WCHAR *pVT_I1_ARRAY = L"VT_I1 | VT_ARRAY";
    const static WCHAR *pVT_UI1_ARRAY  = L"VT_UI1 | VT_ARRAY";
    const static WCHAR *pVT_I2_ARRAY   = L"VT_I2 | VT_ARRAY";
    const static WCHAR *pVT_UI2_ARRAY  = L"VT_UI2 | VT_ARRAY";
    const static WCHAR *pVT_I4_ARRAY   = L"VT_I4 | VT_ARRAY";
    const static WCHAR *pVT_UI4_ARRAY  = L"VT_UI4 | VT_ARRAY";
    const static WCHAR *pVT_I8_ARRAY   = L"VT_I8 | VT_ARRAY";
    const static WCHAR *pVT_UI8_ARRAY  = L"VT_UI8 | VT_ARRAY";
    const static WCHAR *pVT_R4_ARRAY   = L"VT_R4 | VT_ARRAY";
    const static WCHAR *pVT_R8_ARRAY   = L"VT_R8 | VT_ARRAY";
    const static WCHAR *pVT_BOOL_ARRAY = L"VT_BOOL | VT_ARRAY";
    const static WCHAR *pVT_BSTR_ARRAY = L"VT_BSTR | VT_ARRAY";
    const static WCHAR *pVT_DISPATCH_ARRAY = L"VT_DISPATCH | VT_ARRAY";
    const static WCHAR *pVT_UNKNOWN_ARRAY = L"VT_UNKNOWN | VT_ARRAY";

    const WCHAR *pRetVal;

    switch (v)
    {
    case VT_NULL: pRetVal = pVT_NULL; break;

    case VT_I1: pRetVal = pVT_I1; break;
    case VT_UI1: pRetVal = pVT_UI1; break;
    case VT_I2: pRetVal = pVT_I2; break;
    case VT_UI2: pRetVal = pVT_UI2; break;
    case VT_I4: pRetVal = pVT_I4; break;
    case VT_UI4: pRetVal = pVT_UI4; break;
    case VT_I8: pRetVal = pVT_I8; break;
    case VT_UI8: pRetVal = pVT_UI8; break;
    case VT_R4: pRetVal = pVT_R4; break;
    case VT_R8: pRetVal = pVT_R8; break;
    case VT_BOOL: pRetVal = pVT_BOOL; break;
    case VT_BSTR: pRetVal = pVT_BSTR; break;
    case VT_DISPATCH: pRetVal = pVT_DISPATCH; break;
    case VT_UNKNOWN: pRetVal = pVT_UNKNOWN; break;

    case VT_I1|VT_ARRAY: pRetVal = pVT_I1_ARRAY; break;
    case VT_UI1|VT_ARRAY: pRetVal = pVT_UI1_ARRAY; break;
    case VT_I2|VT_ARRAY: pRetVal = pVT_I2_ARRAY; break;
    case VT_UI2|VT_ARRAY: pRetVal = pVT_UI2_ARRAY; break;
    case VT_I4|VT_ARRAY: pRetVal = pVT_I4_ARRAY; break;
    case VT_UI4|VT_ARRAY: pRetVal = pVT_UI4_ARRAY; break;
    case VT_I8|VT_ARRAY: pRetVal = pVT_I8_ARRAY; break;
    case VT_UI8|VT_ARRAY: pRetVal = pVT_UI8_ARRAY; break;
    case VT_R4|VT_ARRAY: pRetVal = pVT_R4_ARRAY; break;
    case VT_R8|VT_ARRAY: pRetVal = pVT_R8_ARRAY; break;
    case VT_BOOL|VT_ARRAY: pRetVal = pVT_BOOL_ARRAY; break;
    case VT_BSTR|VT_ARRAY: pRetVal = pVT_BSTR_ARRAY; break;
    case VT_DISPATCH|VT_ARRAY: pRetVal = pVT_DISPATCH_ARRAY; break;
    case VT_UNKNOWN|VT_ARRAY: pRetVal = pVT_UNKNOWN_ARRAY; break;

    default: pRetVal = L"<unknown>";
    }

    return pRetVal;
}

//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a CIMTYPE, returns a pointer to a string that is the variant type
//*****************************************************************************
const WCHAR *TypeToString(CIMTYPE v)
{
    const static WCHAR *pCIM_UNKNOWN = L"CIM_UNKNOWN";

    const static WCHAR *pCIM_ILLEGAL = L"CIM_ILLEGAL";
    const static WCHAR *pCIM_EMPTY = L"CIM_EMPTY";
    const static WCHAR *pCIM_SINT8 = L"CIM_SINT8";
    const static WCHAR *pCIM_UINT8 = L"CIM_UINT8";
    const static WCHAR *pCIM_SINT16 = L"CIM_SINT16";
    const static WCHAR *pCIM_UINT16 = L"CIM_UINT16";
    const static WCHAR *pCIM_SINT32 = L"CIM_SINT32";
    const static WCHAR *pCIM_UINT32 = L"CIM_UINT32";
    const static WCHAR *pCIM_SINT64 = L"CIM_SINT64";
    const static WCHAR *pCIM_UINT64 = L"CIM_UINT64";
    const static WCHAR *pCIM_REAL32 = L"CIM_REAL32";
    const static WCHAR *pCIM_REAL64 = L"CIM_REAL64";
    const static WCHAR *pCIM_BOOLEAN = L"CIM_BOOLEAN";
    const static WCHAR *pCIM_STRING = L"CIM_STRING";
    const static WCHAR *pCIM_DATETIME = L"CIM_DATETIME";
    const static WCHAR *pCIM_REFERENCE = L"CIM_REFERENCE";
    const static WCHAR *pCIM_OBJECT = L"CIM_OBJECT";

    const static WCHAR *pCIM_ILLEGAL_ARRAY = L"CIM_ILLEGAL | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_EMPTY_ARRAY = L"CIM_EMPTY | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT8_ARRAY = L"CIM_SINT8 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT8_ARRAY = L"CIM_UINT8 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT16_ARRAY = L"CIM_SINT16 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT16_ARRAY = L"CIM_UINT16 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT32_ARRAY = L"CIM_SINT32 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT32_ARRAY = L"CIM_UINT32 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_SINT64_ARRAY = L"CIM_SINT64 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_UINT64_ARRAY = L"CIM_UINT64 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_REAL32_ARRAY = L"CIM_REAL32 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_REAL64_ARRAY = L"CIM_REAL64 | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_BOOLEAN_ARRAY = L"CIM_BOOLEAN | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_STRING_ARRAY = L"CIM_STRING | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_DATETIME_ARRAY = L"CIM_DATETIME | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_REFERENCE_ARRAY = L"CIM_REFERENCE | CIM_FLAG_ARRAY";
    const static WCHAR *pCIM_OBJECT_ARRAY = L"CIM_OBJECT | CIM_FLAG_ARRAY";

    const WCHAR *pRetVal;

    switch (v)
    {
        case CIM_ILLEGAL: pRetVal = pCIM_ILLEGAL; break;
        case CIM_EMPTY: pRetVal = pCIM_EMPTY; break;
        case CIM_SINT8: pRetVal = pCIM_SINT8; break;
        case CIM_UINT8: pRetVal = pCIM_UINT8; break;
        case CIM_SINT16: pRetVal = pCIM_SINT16; break;
        case CIM_UINT16: pRetVal = pCIM_UINT16; break;
        case CIM_SINT32: pRetVal = pCIM_SINT32; break;
        case CIM_UINT32: pRetVal = pCIM_UINT32; break;
        case CIM_SINT64: pRetVal = pCIM_SINT64; break;
        case CIM_UINT64: pRetVal = pCIM_UINT64; break;
        case CIM_REAL32: pRetVal = pCIM_REAL32; break;
        case CIM_REAL64: pRetVal = pCIM_REAL64; break;
        case CIM_BOOLEAN: pRetVal = pCIM_BOOLEAN; break;
        case CIM_STRING: pRetVal = pCIM_STRING; break;
        case CIM_DATETIME: pRetVal = pCIM_DATETIME; break;
        case CIM_REFERENCE: pRetVal = pCIM_REFERENCE; break;
        case CIM_OBJECT: pRetVal = pCIM_OBJECT; break;

        case CIM_SINT8 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT8_ARRAY; break;
        case CIM_UINT8 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT8_ARRAY; break;
        case CIM_SINT16 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT16_ARRAY; break;
        case CIM_UINT16 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT16_ARRAY; break;
        case CIM_SINT32 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT32_ARRAY; break;
        case CIM_UINT32 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT32_ARRAY; break;
        case CIM_SINT64 | CIM_FLAG_ARRAY: pRetVal = pCIM_SINT64_ARRAY; break;
        case CIM_UINT64 | CIM_FLAG_ARRAY: pRetVal = pCIM_UINT64_ARRAY; break;
        case CIM_REAL32 | CIM_FLAG_ARRAY: pRetVal = pCIM_REAL32_ARRAY; break;
        case CIM_REAL64 | CIM_FLAG_ARRAY: pRetVal = pCIM_REAL64_ARRAY; break;
        case CIM_BOOLEAN | CIM_FLAG_ARRAY: pRetVal = pCIM_BOOLEAN_ARRAY; break;
        case CIM_STRING | CIM_FLAG_ARRAY: pRetVal = pCIM_STRING_ARRAY; break;
        case CIM_DATETIME | CIM_FLAG_ARRAY: pRetVal = pCIM_DATETIME_ARRAY; break;
        case CIM_REFERENCE | CIM_FLAG_ARRAY: pRetVal = pCIM_REFERENCE_ARRAY; break;
        case CIM_OBJECT | CIM_FLAG_ARRAY: pRetVal = pCIM_OBJECT_ARRAY; break;

        default: pRetVal = pCIM_UNKNOWN; break;
    }

    return pRetVal;
}

//*****************************************************************************
// Function:   ValueToString
// Purpose:    Takes a variant, returns a string representation of that variant
//*****************************************************************************
WCHAR *ValueToString(CIMTYPE dwType, VARIANT *pValue, WCHAR **pbuf, WCHAR *fnHandler(VARIANT *pv))
{
    DWORD iTotBufSize;

    WCHAR *vbuf = NULL;
    WCHAR *buf = NULL;

    WCHAR lbuf[BLOCKSIZE];

    switch (pValue->vt)
    {
        case VT_EMPTY:
        {
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"<empty>");
            }
            break;
        }

        case VT_NULL:
        {
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"<null>");
            }
            break;
        }

        case VT_BOOL:
        {
            VARIANT_BOOL b = pValue->boolVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                if (!b)
                {
                    wcscpy(buf, L"FALSE");
                }
                else
                {
                    wcscpy(buf, L"TRUE");
                }
            }
            break;
        }

        case VT_I1:
        {
            char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                if (b >= 32)
                {
                    swprintf(buf, L"'%c' (%hd, 0x%hX)", b, (signed char)b, b);
                }
                else
                {
                    swprintf(buf, L"%hd (0x%hX)", (signed char)b, b);
                }
            }
            break;
        }

        case VT_UI1:
        {
            unsigned char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                if (b >= 32)
                {
                    swprintf(buf, L"'%c' (%hu, 0x%hX)", b, (unsigned char)b, b);
                }
                else
                {
                    swprintf(buf, L"%hu (0x%hX)", (unsigned char)b, b);
                }
            }
            break;
        }

        case VT_I2:
        {
            SHORT i = pValue->iVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%hd (0x%hX)", i, i);
            }
            break;
        }

        case VT_UI2:
        {
            USHORT i = pValue->uiVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%hu (0x%hX)", i, i);
            }
            break;
        }

        case VT_I4:
        {
            LONG l = pValue->lVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%d (0x%X)", l, l);
            }
            break;
        }

        case VT_UI4:
        {
            ULONG l = pValue->ulVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if (buf)
            {
                swprintf(buf, L"%u (0x%X)", l, l);
            }
            break;
        }

        case VT_R4:
        {
            float f = pValue->fltVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if (buf)
            {
                swprintf(buf, L"%10.4f", f);
            }
            break;
        }

        case VT_R8:
        {
            double d = pValue->dblVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if (buf)
            {
                swprintf(buf, L"%10.4f", d);
            }
            break;
        }

        case VT_BSTR:
        {
            if (dwType == CIM_SINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);

                buf = (WCHAR *)malloc(BLOCKSIZE);
                if (buf)
                {
                    swprintf(buf, L"%I64d", l, l);
                    }
            }
            else if (dwType == CIM_UINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);

                buf = (WCHAR *)malloc(BLOCKSIZE);
                if (buf)
                {
                    swprintf(buf, L"%I64u", l, l);
                }
            }
            else // string, datetime, reference
            {
                LPWSTR pWStr = pValue->bstrVal;
                buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
                if (buf)
                {
                    swprintf(buf, L"\"%wS\"", pWStr);
                }
            }
            break;
        }

        case VT_BOOL|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    VARIANT_BOOL v;
                    SafeArrayGetElement(pVec, &i, &v);
                    if (v)
                    {
                        wcscat(buf, L"TRUE");
                    }
                    else
                    {
                        wcscat(buf, L"FALSE");
                    }
                }
            }

            break;
        }

        case VT_I1|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");
                WCHAR *pos = buf;
                DWORD len;

                BYTE *pbstr;
                SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscpy(pos, L",");
                        pos += 1;
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    char v;
                    //            SafeArrayGetElement(pVec, &i, &v);
                    v = pbstr[i];

                    if (v < 32)
                    {
                        len = swprintf(lbuf, L"%hd (0x%X)", v, v);
                    }
                    else
                    {
                        len = swprintf(lbuf, L"'%c' %hd (0x%X)", v, v, v);
                    }

                    wcscpy(pos, lbuf);
                    pos += len;
                }
            }

            SafeArrayUnaccessData(pVec);

            break;
        }

        case VT_UI1|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");
                WCHAR *pos = buf;
                DWORD len;

                BYTE *pbstr;
                SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscpy(pos, L",");
                        pos += 1;
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    unsigned char v;
                    //            SafeArrayGetElement(pVec, &i, &v);
                    v = pbstr[i];

                    if (v < 32)
                    {
                        len = swprintf(lbuf, L"%hu (0x%X)", v, v);
                    }
                    else
                    {
                        len = swprintf(lbuf, L"'%c' %hu (0x%X)", v, v, v);
                    }

                    wcscpy(pos, lbuf);
                    pos += len;
                }
            }

            SafeArrayUnaccessData(pVec);

            break;
        }

        case VT_I2|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
					wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    SHORT v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%hd", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_UI2|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    USHORT v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%hu", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_I4|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    LONG v;
                    SafeArrayGetElement(pVec, &i, &v);
                    _ltow(v, lbuf, 10);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_UI4|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    ULONG v;
                    SafeArrayGetElement(pVec, &i, &v);
                    _ultow(v, lbuf, 10);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case CIM_REAL32|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    FLOAT v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%10.4f", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case CIM_REAL64|VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0)
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
				if (buf)
				{
	                wcscpy(buf, L"<empty array>");
				}
                break;
            }

            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if (buf)
            {
                wcscpy(buf, L"");

                for (long i = iLBound; i <= iUBound; i++)
                {
                    if (!bFirst)
                    {
                        wcscat(buf, L",");
                    }
                    else
                    {
                        bFirst = FALSE;
                    }

                    double v;
                    SafeArrayGetElement(pVec, &i, &v);
                    swprintf(lbuf, L"%10.4f", v);
                    wcscat(buf, lbuf);
                }
            }

            break;
        }

        case VT_BSTR|VT_ARRAY:
        {
            if (dwType == (CIM_UINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;

                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0)
                {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
					if (buf)
					{
	                    wcscpy(buf, L"<empty array>");
					}
                    break;
                }

                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if (buf)
                {
                    wcscpy(buf, L"");

                    for (long i = iLBound; i <= iUBound; i++)
                    {
                        if (!bFirst)
                        {
                            wcscat(buf, L",");
                        }
                        else
                        {
                            bFirst = FALSE;
                        }

                        BSTR v = NULL;

                        SafeArrayGetElement(pVec, &i, &v);

                        swprintf(lbuf, L"%I64u", _wtoi64(v));
                        wcscat(buf, lbuf);
                    }
                }
            }
            else if (dwType == (CIM_SINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;

                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0)
                {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
					if (buf)
					{
	                    wcscpy(buf, L"<empty array>");
					}
                    break;
                }

                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if (buf)
                {
                    wcscpy(buf, L"");

                    for (long i = iLBound; i <= iUBound; i++)
                    {
                        if (!bFirst)
                        {
                            wcscat(buf, L",");
                        }
                        else
                        {
                            bFirst = FALSE;
                        }

                        BSTR v = NULL;

                        SafeArrayGetElement(pVec, &i, &v);

                        swprintf(lbuf, L"%I64d", _wtoi64(v));
                        wcscat(buf, lbuf);
                    }
                }
            }
            else // string, datetime, reference
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                DWORD iNeed;
                size_t iVSize;
                DWORD iCurBufSize;

                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0)
                {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
					if (buf)
					{
	                    wcscpy(buf, L"<empty array>");
					}
                    break;
                }

                iTotBufSize = (iUBound - iLBound + 1) * BLOCKSIZE;
                buf = (WCHAR *)malloc(iTotBufSize);
                if (buf)
                {
                    buf[0] = L'\0';
                    iCurBufSize = 0;
                    iVSize = BLOCKSIZE;
                    vbuf = (WCHAR *)malloc(BLOCKSIZE);
                    if (vbuf)
                    {
                        size_t iLen;

                        for (long i = iLBound; i <= iUBound; i++)
                        {
                            BSTR v = NULL;
                            SafeArrayGetElement(pVec, &i, &v);
                            iLen = (wcslen(v) + 1) * sizeof(WCHAR);
                            if (iLen > iVSize)
                            {
                                WCHAR* pTmp  = (WCHAR *)realloc(vbuf, iLen + sizeof(WCHAR));

                                if (pTmp)
                                {
                                    vbuf = pTmp;
                                    iVSize = iLen;
                                }
                                else
                                {
                                    free(buf);
                                    buf = NULL;
                                    SysFreeString(v);
                                    break;
                                }
                            }

                            // String size + (quotes + comma + null)
                            iNeed = (swprintf(vbuf, L"%wS", v) + 4) * sizeof(WCHAR);
                            if (iNeed + iCurBufSize > iTotBufSize)
                            {
                                iTotBufSize += (iNeed * 2);  // Room enough for 2 more entries
                                WCHAR* pTmp = (WCHAR *)realloc(buf, iTotBufSize);

                                if (pTmp)
                                    buf = pTmp;
                                else
                                {
                                    free(buf);
                                    buf = NULL;
                                    SysFreeString(v);
                                    break;
                                }
                            }
                            wcscat(buf, L"\"");
                            wcscat(buf, vbuf);
                            if (i + 1 <= iUBound)
                            {
                                wcscat(buf, L"\",");
                            }
                            else
                            {
                                wcscat(buf, L"\"");
                            }
                            iCurBufSize += iNeed;
                            SysFreeString(v);
                        }
                        free(vbuf);
                    }
                }
            }

            break;
        }

        default:
        {
            if (fnHandler != NULL)
            {
                buf = fnHandler(pValue);
            }
            else
            {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if (buf)
                {
                    wcscpy(buf, L"<conversion error>");
                }
            }
            break;
        }
   }

   if (!buf)
   {
       PrintErrorAndExit("ValueToString() out of memory", S_OK, 0);
   }

   *pbuf = buf;
   return buf;
}

//*****************************************************************************
// Function:   cvt
// Purpose:    Converts unicode to oem for console output
// Note:       y must be freed by caller
//*****************************************************************************
char *cvt(WCHAR *x, char **y)
{
    int dwRet, i;
    i = WideCharToMultiByte( CP_OEMCP,
        0,
        x,
        -1,
        NULL,
        0,
        NULL,
        NULL);

    *y = (char *)calloc(i, 1);

    if (*y)
    {
        dwRet = WideCharToMultiByte( CP_OEMCP,
            0,
            x,
            -1,
            *y,
            i,
            NULL,
            NULL);

        if (dwRet == 0)
        {
            free(*y);
            *y = (char *)malloc(sizeof(CVTFAILED));
            if (*y)
            {
                memcpy(*y, CVTFAILED, sizeof(CVTFAILED));
            }
        }
    }
    else
    {
        PrintErrorAndExit("cvt() out of memory", S_OK, 0);
    }

    return *y;
}

//*****************************************************************************
// Function:   myWFPrintf
// Purpose:    Checks to see if outputing to console and converts strings
//             to oem if necessary.
// Note:       Returns number of characters written (ie if we write 3 oem
//             chars, it returns 3.  If it writes 4 wchars, it returns 4).
//*****************************************************************************
int myFWPrintf(FILE *f, WCHAR *fmt, ...)

{
    va_list    argptr;
    size_t i;

    int iSize = PAGESIZE;
    WCHAR *wszBuff = (WCHAR *)malloc(iSize);

    if (wszBuff)
    {
        wszBuff[(iSize/2)-2] = 0xffff;

        va_start(argptr, fmt);  // Init variable arguments

        // Format the string into a buffer.  Make sure the buffer is big enough
        while (_vsnwprintf(wszBuff, (iSize-1)/sizeof(WCHAR), fmt, argptr) == -1)
        {
            if (wszBuff[(iSize/2)-2] != 0xffff)
            {
                WCHAR* pTmp = (WCHAR *)realloc(wszBuff, iSize + PAGESIZE);

                if (pTmp)
                {
                    wszBuff = pTmp;                
                    wszBuff[(iSize/2)-2] = 0xffff;
                    iSize += PAGESIZE;
                }
                else
                {
                    wszBuff[(iSize/2)-2] = L'\0';
                    break;
                }

            }
            else
            {
                // unfortunately, _vsnwprintf won't handle the unicode character
                // 0xffff.  Since this isn't actually a valid unicode character,
                // we'll just ignore it.
                wcscpy(wszBuff, L"String contains 0xffff\n");
                break;
            }
        }

        if (f == stdout)
        {
            char *z = NULL;

            fputs(cvt(wszBuff,&z), f);
            i = strlen(z);
            free(z);
        }
        else
        {
            i = wcslen(wszBuff);
            fwrite(wszBuff, i * sizeof(WCHAR), 1, f);
        }

        free(wszBuff);
    }
    else
    {
        if (f == stdout)
        {
            char *szBuff = "myFWPrintf() out of memory";

            i = strlen(szBuff);
            fputs(szBuff, f);
        }
        else
        {
            wszBuff = L"myFWPrintf() out of memory";
            i = wcslen(wszBuff);
            fwrite(wszBuff, i * sizeof(WCHAR), 1, f);
        }
    }

    va_end(argptr);

    return (int)i;
}

//*****************************************************************************
// Function:   difftime
// Purpose:    Returns the elapsed time between two _timeb structures
// Note:       This is different from the crt routine which works on time_t
//             structures.
//*****************************************************************************
double difftime(struct _timeb finish, struct _timeb start)
{
    double dRet;

    if (start.millitm > finish.millitm)
    {
        dRet = ((finish.time - start.time) - 1) + (double)(((1000 + finish.millitm) - start.millitm) / 1000.0);
    }
    else
    {
        dRet = (finish.time - start.time) + (double)((finish.millitm - start.millitm) / 1000.0);
    }

    return dRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\commonfuncs.cpp ===
#include "stdafx.h"
#include <wininet.h>

#include "CommonFuncs.h"
#include "FileHash.h"

#define SAFE_LOCAL_SCRIPTS_KEY TEXT("Software\\Microsoft\\WBEM\\SafeLocalScripts")
#define VS_PATH_KEY TEXT("Software\\Microsoft\\VisualStudio\\7.0\\Setup\\VS")
#define DEVENV_VALUE TEXT("VS7EnvironmentLocation")
#define VC_PATH_KEY TEXT("Software\\Microsoft\\VisualStudio\\7.0\\Setup\\VC")
#define VC_PRODUCTDIR_VALUE TEXT("ProductDir")
#define VS_VER_INDEPENDANT_PATH_KEY TEXT("Software\\Microsoft\\VisualStudio")

TCHAR strVSPathKey[MAX_PATH * 2]= VS_PATH_KEY;
TCHAR strVCPathKey[MAX_PATH * 2] = VC_PATH_KEY;

HRESULT ConvertToTString(BSTR strPath,TCHAR **ppStr);

// QUESTIONS:
// - What is passed to SetSite when we are create in script?
// - If we are passed an IOleClientSite, is it a good idea to QueryService for
//   an IWebBrowserApp?
// - Is there a better way to get the IHTMLDocument2 when we are created through
//   script?

// Here are some general notes about what I've observed when creating objects
// in HTML with IE 5.x.

// Observed IE 5.x Behavior
// If an object implements IOleObject AND IObjectWithSite
// - For objects created in an HTML page with an <OBJECT...> tag, IE calls
//   IOleObject::SetClientSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object

// If an object implements IObjectWithSite (and NOT IOleObject)
// - For object created in HTML page with <OBJECT...> tag, IE calls
//   IObjectWithSite::SetSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object


//		BYTE *pbData = NULL;
//		DWORD dwSize;
//		GetSourceFromDoc(pDoc, &pbData, &dwSize);
// Get the original source to the document specified by pDoc
HRESULT GetSourceFromDoc(IHTMLDocument2 *pDoc, BYTE **ppbData, DWORD *pdwSize)
{
	HRESULT hr = E_FAIL;
	IPersistStreamInit *pPersistStreamInit = NULL;
	IStream *pStream = NULL;

	*ppbData = NULL;

	__try
	{
		if(FAILED(hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**) &pPersistStreamInit)))
			__leave;

		if (FAILED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			__leave;

		if(FAILED(hr = pPersistStreamInit->Save(pStream, TRUE)))
			__leave;

		// We are not responsible for freeing this HGLOBAL
		HGLOBAL hGlobal = NULL;
		if(FAILED(hr = GetHGlobalFromStream(pStream, &hGlobal)))
			__leave;

		STATSTG ss;
		if(FAILED(hr = pStream->Stat(&ss, STATFLAG_NONAME)))
			__leave;

		// This should never happen
		if(ss.cbSize.HighPart != 0)
			__leave;

		if(NULL == ((*ppbData) = new BYTE[ss.cbSize.LowPart]))
			__leave;
		
		LPVOID pHTMLText = NULL;
		if(NULL == (pHTMLText = GlobalLock(hGlobal)))
			__leave;

		*pdwSize = ss.cbSize.LowPart;
		memcpy(*ppbData, pHTMLText, ss.cbSize.LowPart);
		GlobalUnlock(hGlobal);
		hr = S_OK;

	}
	__finally
	{
		// If we did not finish, but we allocated memory, we free it.
		if(FAILED(hr) && (*ppbData)!=NULL)
			delete [] (*ppbData);

		if(pPersistStreamInit)
			pPersistStreamInit->Release();
		if(pStream)
			pStream->Release();
	}
	return hr;
}


// For a control specified by pUnk, get the IServiceProvider of the host
HRESULT GetSiteServices(IUnknown *pUnk, IServiceProvider **ppServProv)
{
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				hr = pSite->QueryInterface(IID_IServiceProvider, (void**)ppServProv);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)ppServProv);
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
	}
	return hr;
}

// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	HRESULT hr = E_FAIL;
	IServiceProvider* pServProv = NULL;
	IDispatch *pDisp = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnk, &pServProv)))
			__leave;

		if(FAILED(hr = pServProv->QueryService(SID_SContainerDispatch, IID_IDispatch, (void**)&pDisp)))
			__leave;

		hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}





// This function will Release() the current document and return a pointer to
// the parent document.  If no parent document is available, this function
// will return NULL (but will still release the current document)
IHTMLDocument2 *GetParentDocument(IHTMLDocument2 *pDoc)
{
	BSTR bstrURL = NULL;
	BSTR bstrURLParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	IHTMLWindow2 *pWndParentParent = NULL;
	IHTMLDocument2 *pDocParent = NULL;
	__try
	{
		if(FAILED(pDoc->get_URL(&bstrURL)))
			__leave;
		if(FAILED(pDoc->get_parentWindow(&pWndParent)))
			__leave;
		if(FAILED(pWndParent->get_parent(&pWndParentParent)))
			__leave;
		if(FAILED(pWndParentParent->get_document(&pDocParent)))
			__leave;
		if(FAILED(pDocParent->get_URL(&bstrURLParent)))
			__leave;
		// TODO: Make this more robust
		if(0 == lstrcmpW(bstrURL, bstrURLParent))
		{
			// We are at the top document.  Release the new document pointer we
			// just received.
			pDocParent->Release();
			pDocParent = NULL;
		}
	}
	__finally
	{
		if(bstrURL)
			SysFreeString(bstrURL);
		if(bstrURLParent)
			SysFreeString(bstrURLParent);
		if(pWndParent)
			pWndParent->Release();
		if(pWndParentParent)
			pWndParentParent->Release();
		if(pDoc)
			pDoc->Release();
	}
	return pDocParent;
}


// Try to append bstr2 to pbstr1.  If this function fails, pbstr1 will still
// point to the original valid allocated bstr.
HRESULT AppendBSTR(BSTR *pbstr1, BSTR bstr2)
{
	HRESULT hr = S_OK;
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr1)))
		hr = E_FAIL;
	if(FAILED(bstr.AppendBSTR(bstr2)))
		hr = E_FAIL;
	if(SUCCEEDED(hr))
	{
		SysFreeString(*pbstr1);
		*pbstr1 = bstr.Detach();
	}
	return hr;
}

BSTR AllocBSTR(LPCTSTR lpsz)
{
	CComBSTR bstr(lpsz);
	return bstr.Detach();
}

BOOL IsURLLocal(LPWSTR szURL)
{
	CComBSTR bstrURL(szURL);
        if ( !bstrURL )
            return FALSE;

	if(FAILED(bstrURL.ToLower()))
		return FALSE;

	// Make sure the URL starts with 'file://'
    // NOTE: Calling code may rely on the fact that this method verifies that
    // the URL starts with file://.  If you change this function to work
    // differently, you must examine the places that call this method so that
    // they don't rely on this assumption.
	if(0 != wcsncmp(bstrURL, L"file://", 7))
		return FALSE;
	
	// Make sure the next part is a drive letter, such as 'C:\'
	if(0 != wcsncmp(&(bstrURL[8]), L":\\", 2))
		return FALSE;

	WCHAR drive = bstrURL[7];
	// Make sure the URL points to drive 'a' to 'z'
	if(drive < 'a' || drive > 'z')
		return FALSE;

	TCHAR szDrive[4];
	StringCchCopy(szDrive,sizeof(szDrive),TEXT("c:\\"));		// 4505 in WMI
	szDrive[0] = (TCHAR)drive;

	UINT uDriveType = GetDriveType(szDrive);
	return (DRIVE_FIXED == uDriveType);
}

// Try to convert the BSTR to lower case.  If this function fails, pbstr will
// still point to the original valid allocated bstr.
HRESULT ToLowerBSTR(BSTR *pbstr)
{
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr)))
		return E_FAIL;
	if(FAILED(bstr.ToLower()))
		return E_FAIL;
	SysFreeString(*pbstr);
	*pbstr = bstr.Detach();
	return S_OK;
}

// For a given instance of an ActiveX control (represented by pUnk), and a
// specified strProgId, this function creates a 'full path' that can be checked
// in the registry to see if object creation should be allowed.  The full
// location is created from the following information
// 1) The name of the current EXE
// 2) The ProgId requested
// 3) The HREF of the current document
// 4) The HREF of every parent document up the available hierarchy
// All of the documents in the hierarchy must be on a local hard drive or the
// function will fail.  In addition, if any piece of informaiton along the way
// is not available, the function will fail.  This increases the security of
// our process.
// This function will also create a BSTR in *pbstrHash that contains the
// cumulative MD5 hash of the document and its parents.  This BSTR will be
// allocated by the function and should be freed by the caller.  If the
// function returns NULL for the full location, it will also return NULL for
// *pbstrHash
BSTR GetFullLocation(IUnknown *pUnk, BSTR strProgId, BSTR *pbstrHash)
{
	HRESULT hr = E_FAIL;
	IHTMLDocument2 *pDoc = NULL;
	BSTR bstrURL = NULL;
	BSTR bstrFullLocation = NULL;
	*pbstrHash = NULL;
	BYTE *pbData = NULL;
	BSTR bstrHash = NULL;

	__try
	{
		if(FAILED(GetDocument(pUnk, &pDoc)))
			__leave;

		TCHAR szFilename[_MAX_PATH];
		TCHAR szFilenameLong[_MAX_PATH];
		GetModuleFileName(NULL, szFilenameLong, _MAX_PATH);
		GetShortPathName(szFilenameLong, szFilename, _MAX_PATH);
		
		if(NULL == (bstrFullLocation = AllocBSTR(szFilename)))
			__leave;

		if(FAILED(AppendBSTR(&bstrFullLocation, strProgId)))
			__leave;

		if(NULL == (*pbstrHash = AllocBSTR(_T(""))))
			__leave;

		int nDepth = 0;
		do
		{
			// Make sure we don't get stuck in some infinite loop of parent
			// documents.  If we do get more than 100 levels of parent
			// documents, we assume failure
			if(++nDepth >= 100)
				__leave;

			if(FAILED(pDoc->get_URL(&bstrURL)))
				__leave;

			DWORD dwDataSize = 0;
			if(FAILED(GetSourceFromDoc(pDoc, &pbData, &dwDataSize)))
				__leave;

			MD5Hash hash;
			if(FAILED(hash.HashData(pbData, dwDataSize)))
				__leave;

			if(NULL == (bstrHash = hash.GetHashBSTR()))
				__leave;

			if(FAILED(AppendBSTR(pbstrHash, bstrHash)))
				__leave;

			SysFreeString(bstrHash);
			bstrHash = NULL;
			delete [] pbData;
			pbData = NULL;


			// Make sure every document is on the local hard drive
			if(!IsURLLocal(bstrURL))
				__leave;

			if(FAILED(AppendBSTR(&bstrFullLocation, bstrURL)))
				__leave;

			SysFreeString(bstrURL);
			bstrURL = NULL;
		} while (NULL != (pDoc = GetParentDocument(pDoc)));

		// Make sure we do not have any embeded NULLs.  If we do, we just
		// FAIL the call
		if(SysStringLen(bstrFullLocation) != wcslen(bstrFullLocation))
			__leave;

		// Make the location lower case
		if(FAILED(ToLowerBSTR(&bstrFullLocation)))
			__leave;

		// We've now created the normalized full location
		hr = S_OK;
	}
	__finally
	{
		// pDoc should be NULL if we got to the top of the hierarchy.  If not,
		// we should release it
		if(pDoc)
			pDoc->Release();

		// pbData should be NULL unless there was an error calculating the hash
		if(pbData)
			delete [] pbData;

		// bstrHash should be NULL unless there was a problem
		if(bstrHash)
			SysFreeString(bstrHash);

		// bstrURL should be NULL unless there was a problem
		if(bstrURL)
			SysFreeString(bstrURL);

		// If we didn't make it all the way to the end, we free the full location
		if(FAILED(hr) && bstrFullLocation)
		{
			SysFreeString(bstrFullLocation);
			bstrFullLocation = NULL;
		}

		// If we didn't make it all the way to the end, we free the checksum
		if(FAILED(hr) && *pbstrHash)
		{
			SysFreeString(*pbstrHash);
			*pbstrHash = NULL;
		}
	}

	return bstrFullLocation;
}

// This version of the control is hard coded to only allow ProgIds to be
// registered under restricted conditions.  In this version, this means
// that the process registering a ProgID must be DevEnv.exe, as specified
// by the value in:
// HKLM\Software\Microsoft\VisualStudio\7.0\Setup\VS\VS7EnvironmentLocation
// Also, only wbemscripting.swbemlocator and wbemscripting.swbemsink can
// be registered
HRESULT AreCrippledCriteriaMet(BSTR strProgId)
{
    BSTR bstrProgIdLowerCase = NULL;
    BSTR bstrModuleName = NULL;
    BSTR bstrDevEnvPath = NULL;
    HKEY hKeyVSPaths = NULL;
    HRESULT hr = E_FAIL;
    __try
    {
        ////////////////////////////////////////////////////////////////////////////////
        // Make sure the ProgId is wbemscripting.swbemsink or wbemscripting.swbemlocator

        // Copy strProgId to tempory BSTR
        if(NULL == (bstrProgIdLowerCase = SysAllocString(strProgId)))
            __leave;

        // Change it to lower case
        if(FAILED(ToLowerBSTR(&bstrProgIdLowerCase)))
            __leave;

        // See if the prog id is for the sink or locator.  If not, leave
        if(0 != wcscmp(bstrProgIdLowerCase, L"wbemscripting.swbemsink") && 0 != wcscmp(bstrProgIdLowerCase, L"wbemscripting.swbemlocator"))
            __leave;

        ////////////////////////////////////////////////////////////////////////////////
        // Make sure we are running from devenv.exe
        TCHAR szFilename[_MAX_PATH];
        TCHAR szFilenameLong[_MAX_PATH];
        TCHAR szDevEnvLong[_MAX_PATH];
        TCHAR szDevEnv[_MAX_PATH];
        GetModuleFileName(NULL, szFilenameLong, _MAX_PATH);
        GetShortPathName(szFilenameLong, szFilename, _MAX_PATH);

        // Make into BSTR
        if(NULL == (bstrModuleName = AllocBSTR(szFilename)))
            __leave;

        // Make lower case
        if(FAILED(ToLowerBSTR(&bstrModuleName)))
            __leave;

        // Open the registry key to get the path to DevEnv.exe
        if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,strVSPathKey,0,KEY_QUERY_VALUE,&hKeyVSPaths))
            __leave;

        DWORD cbValue = _MAX_PATH * sizeof(TCHAR);
        DWORD dwType = 0;
        if(ERROR_SUCCESS != RegQueryValueEx(hKeyVSPaths, DEVENV_VALUE, NULL, &dwType, (LPBYTE)szDevEnvLong, &cbValue))
            __leave;
        
        if(dwType != REG_SZ)
            __leave;

        GetShortPathName(szDevEnvLong, szDevEnv, _MAX_PATH);

        // make BSTR for devenv.exe path
        if(NULL == (bstrDevEnvPath = AllocBSTR(szDevEnv)))
            __leave;

        // Make lower case
        if(FAILED(ToLowerBSTR(&bstrDevEnvPath)))
            __leave;

        // If current process is not the registered DevEnv.exe, we will 'fail'
        if(0 != wcscmp(bstrModuleName, bstrDevEnvPath))
            __leave;

        hr = S_OK;
    }
    __finally
    {
        if(bstrProgIdLowerCase)
            SysFreeString(bstrProgIdLowerCase);
        if(bstrModuleName)
            SysFreeString(bstrModuleName);
        if(bstrDevEnvPath)
            SysFreeString(bstrDevEnvPath);
        if(hKeyVSPaths)
            RegCloseKey(hKeyVSPaths);
    }
    return hr;
}

// Makes sure the string starts with the specified string
// On success, it updates the passed in pointer to point to the next character
HRESULT StartsWith(LPCWSTR *ppsz, LPCWSTR pszTest)
{
    int len = wcslen(pszTest);
    if(0 != wcsncmp(*ppsz, pszTest, len))
        return E_FAIL;
    *ppsz += len;
    return S_OK;
}

// Makes sure the next character is 0 through 9, and updates the input pointer
// by one character
HRESULT NextCharacterIsDigit(LPCWSTR *ppsz)
{
    WCHAR c = **ppsz;
    if(c < L'0' || c > L'9')
        return E_FAIL;
    (*ppsz)++;
    return S_OK;
}

// For a special case, where the crippled criteria are met and we are dealking
// with a well known document, we will hard code acceptance of control creation
// This method tests if the crippled critera are met, and if this is a well
// known document
HRESULT IsWellKnownHostDocument(IUnknown *pUnk, BSTR strProgId)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;
    IHTMLDocument2 *pParentDoc = NULL;
    BSTR bstrURL = NULL;
    BSTR bstrDocumentFile = NULL;
    BSTR bstrVCPath = NULL;
    HKEY hKey = NULL;
    __try
    {
        // Make sure the crippled criteria are met.  In other words, we are
        // running in a known instance of devenv.exe, and we are requesting a
        // known ProgId
        if(FAILED(AreCrippledCriteriaMet(strProgId)))
            __leave;

        // Get the HTML Document
        if(FAILED(GetDocument(pUnk, &pDoc)))
            __leave;

        // If there is a parent document, this is not a well know document
        if(NULL != (pParentDoc = GetParentDocument(pDoc)))
            __leave;

        // Get the URL of the document
        if(FAILED(pDoc->get_URL(&bstrURL)))
            __leave;

        // Make sure the well known document canidate is on the local hard drive
        if(!IsURLLocal(bstrURL))
            __leave;

        // Open the registry key to get the VC path
        if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,strVCPathKey,0,KEY_QUERY_VALUE,&hKey))
            __leave;

        TCHAR szVCPath[_MAX_PATH];
        TCHAR szVCPathURL[_MAX_PATH*2];
        DWORD cbValue = _MAX_PATH * sizeof(TCHAR);
        DWORD dwType = 0;
        if(ERROR_SUCCESS != RegQueryValueEx(hKey, VC_PRODUCTDIR_VALUE, NULL, &dwType, (LPBYTE)szVCPath, &cbValue))
            __leave;
        
        if(dwType != REG_SZ)
            __leave;

        // Canonicalize the VC path
        cbValue = _MAX_PATH*2; // Length in TCHARs of szVCPathURL
        if(!InternetCanonicalizeUrl(szVCPath, szVCPathURL, &cbValue, 0))
            __leave;

        // make BSTR for devenv.exe path
        if(NULL == (bstrVCPath = AllocBSTR(szVCPathURL)))
            __leave;

        // Make lower case
        if(FAILED(ToLowerBSTR(&bstrVCPath)))
            __leave;

        // Make document path lower case
        if(FAILED(ToLowerBSTR(&bstrURL)))
            __leave;

        LPCWSTR szStartDoc = bstrURL;

        // Make sure we start with the correct VC directory
        if(FAILED(StartsWith(&szStartDoc, bstrVCPath)))
            __leave;

        // Make sure we next have "VCWizards\ClassWiz\ATL\"
        if(FAILED(StartsWith(&szStartDoc, L"vcwizards\\classwiz\\atl\\")))
            __leave;

        // Make sure we next have 'event\' or 'instance\'
        if(FAILED(StartsWith(&szStartDoc, L"event\\")) && FAILED(StartsWith(&szStartDoc, L"instance\\")))
            __leave;

        // Make sure we next have "html\"
        if(FAILED(StartsWith(&szStartDoc, L"html\\")))
            __leave;

        // Make sure the next four characters are numbers
        if(FAILED(NextCharacterIsDigit(&szStartDoc)))
            __leave;
        if(FAILED(NextCharacterIsDigit(&szStartDoc)))
            __leave;
        if(FAILED(NextCharacterIsDigit(&szStartDoc)))
            __leave;
        if(FAILED(NextCharacterIsDigit(&szStartDoc)))
            __leave;

        // Make sure what's left is '\wmiclass.htm'
        if(0 != wcscmp(szStartDoc, L"\\wmiclass.htm"))
            __leave;

        hr = S_OK;
    }
    __finally
    {
        if(pDoc)
            pDoc->Release();
        if(pParentDoc)
            pParentDoc->Release();
        if(bstrURL)
            SysFreeString(bstrURL);
        if(bstrDocumentFile)
            SysFreeString(bstrDocumentFile);
        if(bstrVCPath)
            SysFreeString(bstrVCPath);
        if(hKey)
            RegCloseKey(hKey);
    }
    return hr;
}


// For a given instance of an ActiveXControl (specified by pUnk), see if it is
// permitted to create the object specified by bstrProgId.  This is done by
// verifying that the control was created in an allowed HTML document.
HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName)
{
	BSTR bstrFullLocation = NULL;
	HRESULT hr = E_FAIL;
	HKEY hKey = NULL;
	LPTSTR pszValueName = NULL;
	LPTSTR pszValue = NULL;
	__try
	{
		BSTR bstrHash = NULL;

        // Make sure the crippled criteria are met
        if(FAILED(AreCrippledCriteriaMet(strProgId)))
            __leave;

        // We are going to hard code a specific set of conditions that are
        // allowed.  We will only do this if pstrValueName is NULL (which
        // happens during CreateObject and CanCreateObject).
        // NOTE: this performs a redundant check to make sure the crippled
        // criteria are met
        if(FAILED(IsWellKnownHostDocument(pUnk, strProgId)))
        {
            __leave;
        }

		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		// Open the registry key to see if this full location is registered
        if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,SAFE_LOCAL_SCRIPTS_KEY,0,KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE ,&hKey))
			__leave;

		// Get info on the max lenghts of values in this key
		DWORD cValues, cMaxValueNameLen, cMaxValueLen;
		if(ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, &cMaxValueNameLen, &cMaxValueLen, NULL, NULL))
			__leave;

		// Allocate space for the value name
		if(NULL == (pszValueName = new TCHAR[cMaxValueNameLen + 1]))
			__leave;

		// Allocate space for the value (this may be twice as big as necessary in UNICODE)
		if(NULL == (pszValue = new TCHAR[cMaxValueLen + 1]))
			__leave;
		for(DWORD dw = 0;dw<cValues;dw++)
		{
			DWORD cValueNameLen = cMaxValueNameLen+1;
			DWORD cbData = (cMaxValueLen+1)*sizeof(TCHAR);
			DWORD dwType;
			if(ERROR_SUCCESS != RegEnumValue(hKey, dw, pszValueName, &cValueNameLen, NULL, &dwType, (LPBYTE)pszValue, &cbData))
				continue;
			if(dwType != REG_SZ)
				continue;

			BSTR bstrValue = AllocBSTR(pszValue);

			if(!bstrValue)
				continue;

			// SEE IF WE HAVE A MATCH
			if(0 == wcscmp(bstrFullLocation, bstrValue))
			{
				// Return the ValueName if requested
				if(pstrValueName)
				{
					*pstrValueName = AllocBSTR(pszValueName);
				}

				hr = S_OK;
			}

			SysFreeString(bstrValue);

			if(SUCCEEDED(hr))
				__leave; // WE FOUND A MATCH
		}
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);
		if(hKey)
			RegCloseKey(hKey);
		if(pszValueName)
			delete [] pszValueName;
		if(pszValue)
			delete [] pszValue;
	}
	return hr;
}

// This function will register the location of the current ActiveX control
// (specified by pUnk) to be allowed to create objects of type strProgId
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	HRESULT hr = E_FAIL;
	BSTR bstrFullLocation = NULL;
	LPTSTR pszFullLocation = NULL;
	HKEY hKey = NULL;

	__try
	{
        // Make sure the crippled criteria are met
        if(FAILED(AreCrippledCriteriaMet(strProgId)))
            __leave;

		// See if we are already registered
		if(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, NULL)))
		{
			hr = S_OK;
			__leave;
		}

		// TODO: Maybe reuse some of the code from IsCreateObjectAllowed

		BSTR bstrHash = NULL;
		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		if(bstrFullLocation != NULL)
		{

#ifdef _UNICODE
			pszFullLocation = 	bstrFullLocation;
#else
			pszFullLocation = new TCHAR[SysStringLen(bstrFullLocation) + 1];

			
			if(pszFullLocation == NULL)
				__leave;

			if(0 == WideCharToMultiByte(CP_ACP, 0, bstrFullLocation, -1, pszFullLocation, (SysStringLen(bstrFullLocation) + 1) * sizeof(TCHAR), NULL, NULL))
				__leave;
		
#endif
		}
		if(NULL == pszFullLocation)
			__leave;

		// Create or open the registry key to store the registration
		if(ERROR_SUCCESS != RegCreateKeyEx(	HKEY_LOCAL_MACHINE,
											SAFE_LOCAL_SCRIPTS_KEY,
											0,
											TEXT(""),
											REG_OPTION_NON_VOLATILE,
											KEY_SET_VALUE | KEY_QUERY_VALUE,
											NULL,
											&hKey,
											NULL))
			__leave;

		// Find an empty slot (no more than 1000 registrations
		TCHAR sz[10];
		for(int i=1;i<1000;i++)
		{
			StringCchPrintf(sz,sizeof(sz),TEXT("%i"),i);
			DWORD cbValue;
			if(ERROR_SUCCESS != RegQueryValueEx(hKey, sz, NULL, NULL, NULL, &cbValue))
				break; // There is nothing in this slot
		}

		// See if we found a slot
		if(i>=1000)
			__leave;

		// Register the location
		if(ERROR_SUCCESS != RegSetValueEx(hKey, sz, 0, REG_SZ, (CONST BYTE *)pszFullLocation, (lstrlen(pszFullLocation) + 1) *sizeof(TCHAR)))
			__leave;

		// Registered!
		hr = S_OK;
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);

#ifndef _UNICODE
		if(	pszFullLocation)
			delete []pszFullLocation;
#endif
		if(hKey)
			RegCloseKey(hKey);
	}
	return hr;
}


// This function will remove any registration for the current document and
// strProgId
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	BSTR bstrValueName = NULL;

    // Make sure the crippled criteria are met
    if(FAILED(AreCrippledCriteriaMet(strProgId)))
        return E_FAIL;

	HKEY hKey = NULL;
	if(ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
		return E_FAIL;

	// Make sure to remove ALL instances of this doc/strProgId in the registry
	// NOTE: Each iteration of this loop allocates some space off of the stack
	// for the conversion to ANSI (if not UNICODE build).  This should not be a
	// problem since there should not be too many keys ever registered with the
	// same location.
	while(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, &bstrValueName)) && bstrValueName)
	{
		LPTSTR szValueName = NULL;
		if(FAILED(ConvertToTString(bstrValueName,&szValueName)))
		{
			SysFreeString(bstrValueName);
			return E_FAIL;
		}
		SysFreeString(bstrValueName);
		bstrValueName = NULL;
		RegDeleteValue(hKey, szValueName);
		delete [] szValueName;
	}
	RegCloseKey(hKey);
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// VC 6.0 did not ship with header files that included the CONFIRMSAFETY
// definition.
#ifndef CONFIRMSAFETYACTION_LOADOBJECT

EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY;
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
{
    CLSID       clsid;
    IUnknown *  pUnk;
    DWORD       dwFlags;
};
#endif

const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY = 
	{ 0x10200490, 0xfa38, 0x11d0, { 0xac, 0xe, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0 }};

///////////////////////////////////////////////////////////////////////////////

HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if (fSafetyEnabled)
		{
			if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
				__leave;

			if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
			
			// Ask security manager if we can create objects.
			DWORD dwPolicy = 0x12345678;
			if(FAILED(hr = pSecMan->ProcessUrlAction(URLACTION_ACTIVEX_RUN, (BYTE *)&dwPolicy, sizeof(dwPolicy), (BYTE *)&clsid, sizeof(clsid), 0, 0)))
				__leave;

			// TODO: BUG: If we are loaded in an HTA, hr returns S_OK, but 
			// dwPolicy only has the first byte set to zero.  See documentation
			// for ProcessUrlAction.
			// NOTE: This bug is caused by CClient::ProcessUrlAction in
			// nt\private\inet\mshtml\src\other\htmlapp\site.cxx.  This line
			// uses *pPolicy = dwPolicy, but pPolicy is a BYTE * so only the
			// first byte of the policy is copied to the output parameter.
			// To fix this, we check for hr==S_OK (as opposed to S_FALSE), and
			// see if dwPolicy is 0x12345600 (in other words, only the lower
			// byte of dwPolicy was changed).  As per the documentation, S_OK
			// alone should be enough to assume the dwPolicy was
			// URL_POLICY_ALLOW
			if(S_OK == hr && 0x12345600 == dwPolicy)
				dwPolicy = URLPOLICY_ALLOW;
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;;
			}
		}

		// Create the requested object
		if (FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)ppUnk)))
			__leave;
		
		if (fSafetyEnabled)
		{
			// Query the security manager to see if this object is safe to use.
			DWORD dwPolicy, *pdwPolicy;
			DWORD cbPolicy;
			CONFIRMSAFETY csafe;
			csafe.pUnk = *ppUnk;
			csafe.clsid = clsid;
			csafe.dwFlags = 0;
//			csafe.dwFlags = (fWillLoad ? CONFIRMSAFETYACTION_LOADOBJECT : 0);
			
			if(FAILED(hr = pSecMan->QueryCustomPolicy(GUID_CUSTOM_CONFIRMOBJECTSAFETY, (BYTE **)&pdwPolicy, &cbPolicy, (BYTE *)&csafe, sizeof(csafe), 0)))
				__leave;
			
			dwPolicy = URLPOLICY_DISALLOW;
			if (NULL != pdwPolicy)
			{
				if (sizeof(DWORD) <= cbPolicy)
					dwPolicy = *pdwPolicy;
				CoTaskMemFree(pdwPolicy);
			}
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;
			}
		}
		hr = S_OK;
	}
	__finally
	{
		// If we did not succeeded, we need to release the object we created (if any)
		if(FAILED(hr) && (*ppUnk))
		{
			(*ppUnk)->Release();
			*ppUnk = NULL;
		}

		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return hr;
}

BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
			__leave;

		if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
			__leave;
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return SUCCEEDED(hr);
}


HRESULT SetVSInstallDirectory(IDispatch * pEnv)
{
	HRESULT hr = E_FAIL;
	DISPID dispid;
	LPOLESTR szMember = OLESTR("RegistryRoot");;
	VARIANT varResult;
	VariantInit(&varResult);
	TCHAR *pTemp = NULL;
	DISPPARAMS dispParams;
	dispParams.cArgs = 0;
	dispParams.cNamedArgs = 0;
	dispParams.rgvarg = NULL;
	dispParams.rgdispidNamedArgs = NULL;

	if(pEnv)
	{
		hr = pEnv->GetIDsOfNames(IID_NULL ,&szMember,1, LOCALE_SYSTEM_DEFAULT,&dispid);

		if(SUCCEEDED(hr))
		{
			hr = pEnv->Invoke(dispid,IID_NULL,GetThreadLocale(),DISPATCH_PROPERTYGET,&dispParams,&varResult,NULL,NULL);
			if(SUCCEEDED(hr))
			{
				hr = ConvertToTString(varResult.bstrVal,&pTemp);
				if(SUCCEEDED(hr))
				{
					// Check if this is the standard VS Location in Registry
					if(_tcsncmp(pTemp,VS_VER_INDEPENDANT_PATH_KEY,_tcslen(VS_VER_INDEPENDANT_PATH_KEY)) == 0)
					{
						StringCchCopy(strVSPathKey,MAX_PATH * 2,pTemp);
						StringCchCopy(strVCPathKey,MAX_PATH * 2,pTemp);

						StringCchCat(strVSPathKey,MAX_PATH * 2,TEXT("\\Setup\\VS"));
						StringCchCat(strVCPathKey,MAX_PATH * 2,TEXT("\\Setup\\VC"));
					}
					else
					{
						hr = E_FAIL;
					}

					delete [] pTemp;
				}
				VariantClear(&varResult);
			}
		}
	}
	return hr;
}


HRESULT ConvertToTString(BSTR strPath,TCHAR **ppStr)
{
	HRESULT hr = E_OUTOFMEMORY;
#ifdef _UNICODE
		*ppStr = 	new TCHAR[SysStringLength(strPath) + 1];
		if(*ppStr)
		{
			StringCchCopy(*ppStr,sizeof(*ppStr),strPath);
			hr = S_OK;
		}
#else
		*ppStr = new TCHAR[SysStringLen(strPath) + 1];
		if(WideCharToMultiByte(CP_ACP, 0, strPath, -1, *ppStr, (SysStringLen(strPath) + 1) * sizeof(TCHAR), NULL, NULL))
		{
			hr = S_OK;
		}
		else
		    delete [] *ppStr;
#endif
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\commonfuncsunused.cpp ===
//This was alternative way to get to the internet host security manager (instead of using SID_SInternetHostSecurityManager)
#if 0
			if(FAILED(hr = GetDocument(pUnkControl, &pDoc)))
				__leave;

			if(FAILED(hr = pDoc->QueryInterface(IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
#endif









// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control is created in HTML, this function will return 
	// a pointer to the IHTMLDocument2.  To get to the IHTMLDocument2, controls
	// must implement IObjectWithSite.  If controls also implement IOleObject,
	// the method used to get to the IHTMLDocument2 is slightly different.
	// This function abstracts the difference between controls that implement
	// just IObjectWithSite and controls that implement BOTH IOleObject AND
	// IObjectWithSite.  This function also abstracts the different techniques
	// that need to be used depending on if the control was created through an
	// <OBJECT...> tag or if the control was created through JScript using
	// 'new ActiveXObject' or VBScript using 'CreateObject'
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				// We were passed an IOleClientSite!!! We can call GetContainer
				// and QI for the IHTMLDocument2 that we need
				if(FAILED(hr = pSite->GetContainer(&pContainer)))
					__leave;
				hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		// In case #1 above, we may have been passed an IOleClientSite to
		// IObjectWithSite::SetSite.  This happens if we were created with
		// an <OBJECT...> tag
		if(SUCCEEDED(pObjWithSite->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// We can now call GetContainer and QI for the IHTMLDocument2
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If we were not passed an IOleClientSite, it is possible that
			// we were created dynamically (with 'new ActiveXObject' in JScript,
			// or 'CreateObject' in VBScript).  We can use the following steps
			// to get to the IHTMLDocument2 that created the control:
			// 1) QI for IServiceProvider
			// 2) Call QueryService to get an IWebBrowserApp
			// 3) Call get_Document to get the IDispatch of the document
			// 4) QI for the IHTMLDocument2 interface.
			if(FAILED(hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)&pServProv)))
				__leave;
#if 0
			if(FAILED(hr = pServProv->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pWebApp)))
				__leave;
			if(FAILED(hr = pWebApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
#endif
//			hr = pServProv->QueryService(SID_SContainerDispatch, IID_IHTMLDocument2, (void**)ppDoc);
			if(FAILED(hr = pServProv->QueryService(SID_SContainerDispatch, IID_IDispatch, (void**)&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}




#if 0
// This function shows how to get to the IHTMLDocument2 that created a control
// in either situation (an <OBJECT...> tag or dynamically created controls in
// script).  It assumes that the control has just implement IObjectWithSite
// and NOT IOleObject.  If IOleObject is implemented, IE will NOT call
// IObjectWithSite::SetSite.
HRESULT GetDocumentFromObjectWithSite(IObjectWithSite *pObject, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control implements IObjectWithSite, this function will
	// return a pointer to the IHTMLDocument2 that is hosting the control 
	// (assuming that the control was created in an HTML page).
	// NOTE: If the ActiveX control has also implemented IOleObject, this
	// function cannot be used.  In that case, IE calls
	// IOleObject::SetClientSite instead of IObjectWithSite::SetSite to pass
	// the control an IOleClientSite object when the control is created in an
	// <OBJECT...> tag.  If the control is created dynamically in JScript with
	// 'new ActiveXObject' or VBScript with 'CreateObject', then
	// IObjectWithSite::SetSite is called.  If the ActiveXControl does not
	// implement IOleObject (but implements IObjectWithSite), IE will always
	// call IObjectWithSite::SetSite.  However, the object passed to SetSite
	// will still vary depending on if the control was created dynamically or
	// statically in an <OBJECT...> tag.  This function abstracts the
	// difference between the two situations.
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		if(SUCCEEDED(pObject->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// If the ActiveX control that implemented IObjectWithSite was
			// created on an HTML page using the <OBJECT...> tag, IE will call
			// SetSite with an IID_IOleClientSite.  We can call GetContainer
			// and the QI for the IHTMLDocument2.
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If the ActiveX control that implement IObjectWithSite was
			// created dynamically (with 'new ActiveXObject' in JScript, or
			// CreateObject in VBScript), we are passed a ??? object.  We can
			// QI for IServiceProvider, and get to an IWebBrowserApp through
			// QueryService.  Then, we can get IDispatch pointer of the 
			// document through get_Document, and finally QI for the
			// IHTMLDocument2 interface.
			if(FAILED(hr = pObject->GetSite(IID_IServiceProvider, (void**)&psp)))
				__leave;
			if(FAILED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
				__leave;
			if(FAILED(hr = pApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}
#endif
#if 0
HRESULT CWMIObjectBroker::GetDocument(IHTMLDocument2 **ppDoc)
{
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
//	if(SUCCEEDED(GetClientSite(&pSite)) && pSite)
	if(FALSE)
	{
		IOleContainer *pContainer;
		if(SUCCEEDED(hr = pSite->GetContainer(&pContainer)))
		{
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
			pContainer->Release();
		}
		pSite->Release();
	}
	else
	{
		IServiceProvider *psp = NULL;
		if(SUCCEEDED(hr = GetSite(IID_IServiceProvider, (void**)&psp)))
		{
			IWebBrowserApp *pApp = NULL;
			if(SUCCEEDED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
			{
				IDispatch *pDisp;
				if(SUCCEEDED(hr = pApp->get_Document(&pDisp)))
				{
					hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
					pDisp->Release();
				}
				pApp->Release();
			}
			psp->Release();
		}
	}
	return hr;
}
#endif

#if 0
	IHTMLDocument2 *pDoc2 = NULL;
	GetDocument(&pDoc2);

	IOleClientSite *pSite = NULL;
//	GetClientSite(&pSite);
	if(!pSite)
	{
		HRESULT hr = S_OK;
		hr = GetSite(IID_IOleClientSite, (void**)&pSite);
		hr = GetSite(IID_IServiceProvider, (void**)&pSite);
//		hr = GetSite(IID_IActiveScript, (void**)&pSite);
		hr = GetSite(IID_IOleContainer, (void**)&pSite);
		IServiceProvider *psp = NULL;
		hr = GetSite(IID_IServiceProvider, (void**)&psp);
		IWebBrowserApp *pApp = NULL;
		hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp);
		BSTR bstr;
//		pApp->get_LocationURL(&bstr);
		IHTMLDocument2 *pDoc;
		IDispatch *pDisp;
		pApp->get_Document(&pDisp);
		pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
		pDoc->get_URL(&bstr);
		bstr = NULL;
	}
	IOleContainer *pContainer;
	pSite->GetContainer(&pContainer);
	pSite->Release();
	IHTMLDocument2 *pDoc;
	pContainer->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
	BSTR bstrURL = NULL;
	pDoc->get_URL(&bstrURL);
	SysFreeString(bstrURL);
	IHTMLDocument2 *pDocParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	pDoc->get_parentWindow(&pWndParent);
	pWndParent->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);

	pDocParent->Release();
	IHTMLWindow2 *pWnd2 = NULL;
	pWndParent->get_top(&pWnd2);
	pWnd2->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\filehash.cpp ===
#include "stdafx.h"
#include "FileHash.h"



static DWORD crc_table[256];
static BOOL g_bCRC32Init = FALSE;

void InitCRC32Table()
{
	DWORD crc, poly;
	int i, j;

	poly = 0xEDB88320;
	for (i = 0; i < 256; i++)
	{
		crc = i;
		for (j = 8; j > 0; j--)
		{
			if (crc & 1)
				crc = (crc >> 1) ^ poly;
			else
				crc >>= 1;
		}
		crc_table[i] = crc;
	}
}

DWORD GetCRC32(BYTE *pData, DWORD dwSize)
{
	if(!g_bCRC32Init)
		InitCRC32Table();
	register unsigned long crc;
	BYTE *pEnd = pData + dwSize;
	crc = 0xFFFFFFFF;
	while (pData<pEnd)
		crc = ((crc>>8) & 0x00FFFFFF) ^ crc_table[ (crc^(*(pData++))) & 0xFF ];
	return ( crc^0xFFFFFFFF );
}

HRESULT GetCRC32(HANDLE hFile, DWORD dwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;

	if(0 == dwSize)
	{
		*pdwCRC32 = 0;
		return S_OK;
	}

	HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, dwSize, NULL);
	if(!hMapping)
		return hr;

	BYTE *pData = (BYTE*)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, dwSize);

	if(pData)
	{
		*pdwCRC32 = GetCRC32(pData, dwSize);
		hr = S_OK;
		UnmapViewOfFile(pData);
	}
	CloseHandle(hMapping);
	return hr;
}

HRESULT GetCRC32(TCHAR *szFile, DWORD *pdwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;
	HANDLE hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(INVALID_HANDLE_VALUE == hFile)
		return hr;

	DWORD dwHigh = 0;
	*pdwSize = GetFileSize(hFile, &dwHigh);

	// We don't support files larger than 4 gig
	if(0 == dwHigh)
		hr = GetCRC32(hFile, *pdwSize, pdwCRC32);

	CloseHandle(hFile);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\filehash.h ===
#pragma once

class MD5Hash
{
public:
	MD5Hash() {ZeroMemory(dwHash, sizeof(dwHash));}
	BSTR GetHashBSTR()
	{
		TCHAR szHash[33];
		for(int i=0;i<4;i++)
			StringCchPrintf(&szHash[i*8],sizeof(szHash)-(i * 8),_T("%08X"),dwHash[i]);			
		CComBSTR bstr(szHash);
		return bstr.Detach();
	}
	HRESULT HashData(LPBYTE pData, DWORD dwSize)
	{
		HRESULT hr = E_FAIL;
		HCRYPTPROV hProv = NULL;
		HCRYPTHASH hHash = NULL;
		__try
		{
			if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
				__leave;

			if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
				__leave;

			if(!CryptHashData(hHash, pData, dwSize, 0))
				__leave;

			DWORD dwSizeHash = 0;
			DWORD dwSizeDWORD = sizeof(dwSizeHash);
			if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&dwSizeHash, &dwSizeDWORD, 0))
				__leave;

			if(dwSizeDWORD != sizeof(dwSizeHash) || dwSizeHash != sizeof(dwHash))
				__leave;

			if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)dwHash, &dwSizeHash, 0))
				__leave;

			hr = S_OK;
		}
		__finally
		{
			if(hHash)
				CryptDestroyHash(hHash);
			if(hProv)
				CryptReleaseContext(hProv, 0);
		}
		return hr;
	}
protected:
	DWORD dwHash[4];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_)
#define AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <comdef.h>
#include <exdisp.h>
#include <shlobj.h>
#include <mshtml.h>
#include "strsafe.h"



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMIScriptUtils.rc
//
#define IDS_PROJNAME                    100
#define IDB_WMIOBJECTBROKER             101
#define IDR_WMIOBJECTBROKER             102
#define IDR_WMIOBJECTBROKERREGISTRATION 103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbroker.cpp ===
// WMIObjectBroker.cpp : Implementation of CWMIObjectBroker

#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBroker.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker




STDMETHODIMP CWMIObjectBroker::CreateObject(BSTR strProgId, IDispatch **obj)
{
	HRESULT hr = E_FAIL;
	CLSID clsid;
	IUnknown *pUnk = NULL;
	__try
	{
		BOOL fSafetyEnabled = TRUE;

		// TODO: Do we want this check to enable us to work from WSH?

		// BUG in IE/JScript/VBScript: We should be checking to see if 
		// m_dwCurrentSafety != INTERFACE_USES_SECURITY_MANAGER, but current
		// IE/JScript/VBScript versions do not call SetInterfaceSafetyOptions
		// with anything but INTERFACESAFE_FOR_UNTRUSTED_CALLER

		// If we are run though CScript.exe or WScript.exe, we will never be
		// asked to set safety options through SetInterfaceSafetyOptions.  In
		// addition, there will not be an InternetHostSecurityManager available
		// through our 'site'.  In this case, we allow any object to be created.
		if(m_dwCurrentSafety == 0 && !IsInternetHostSecurityManagerAvailable(GetUnknown()))
			fSafetyEnabled = FALSE;

		// We can override the safety check if this insance of the 'broker'
		// control is allowed to create the object specified by strProbId
		if(fSafetyEnabled && SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
			fSafetyEnabled = FALSE;

		// Convert the ProgId to a CLSID
		if(FAILED(hr = CLSIDFromProgID(strProgId, &clsid)))
			__leave;

		// Create the requested object
#if 0
		if(FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnk)))
			__leave;
#endif
		if(FAILED(hr = SafeCreateObject(GetUnknown(),fSafetyEnabled, clsid, &pUnk)))
			__leave;

		// Get the IDispatch for the caller
		hr = pUnk->QueryInterface(IID_IDispatch, (void**)obj);
	}
	__finally
	{
		if(pUnk)
			pUnk->Release();
	}
	return hr;
}

STDMETHODIMP CWMIObjectBroker::CanCreateObject(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CWMIObjectBroker::SetDevEnvironment(IDispatch *pEnv)
{
	return SetVSInstallDirectory(pEnv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbroker.h ===
// WMIObjectBroker.h : Declaration of the CWMIObjectBroker

#ifndef __WMIOBJECTBROKER_H_
#define __WMIOBJECTBROKER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker
class ATL_NO_VTABLE CWMIObjectBroker : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBroker, &CLSID_WMIObjectBroker2>,
	public IDispatchImpl<IWMIObjectBroker, &IID_IWMIObjectBroker, &LIBID_WMISCRIPTUTILSLib2>,
	public IObjectSafetyImpl<CWMIObjectBroker, INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACE_USES_SECURITY_MANAGER>,
	public IObjectWithSiteImpl<CWMIObjectBroker>
{
public:
	CWMIObjectBroker()
	{
	}


DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBroker)
	COM_INTERFACE_ENTRY(IWMIObjectBroker)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBroker
public:
	STDMETHOD(CanCreateObject)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(CreateObject)(BSTR strProgId, IDispatch **obj);
	STDMETHOD(SetDevEnvironment)(/*[in]*/ IDispatch *pEnv);

};

#endif //__WMIOBJECTBROKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbrokerregistration.cpp ===
// WMIObjectBrokerRegistration.cpp : Implementation of CWMIObjectBrokerRegistration
#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBrokerRegistration.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration


STDMETHODIMP CWMIObjectBrokerRegistration::Register(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(RegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CWMIObjectBrokerRegistration::UnRegister(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(UnRegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CWMIObjectBrokerRegistration::SetDevEnvironment(IDispatch *pEnv)
{
	return SetVSInstallDirectory(pEnv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbrokerregistration.h ===
// WMIObjectBrokerRegistration.h : Declaration of the CWMIObjectBrokerRegistration

#ifndef __WMIOBJECTBROKERREGISTRATION_H_
#define __WMIOBJECTBROKERREGISTRATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration
class ATL_NO_VTABLE CWMIObjectBrokerRegistration : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBrokerRegistration, &CLSID_WMIObjectBrokerRegistration2>,
	public IDispatchImpl<IWMIObjectBrokerRegistration, &IID_IWMIObjectBrokerRegistration, &LIBID_WMISCRIPTUTILSLib2>,
	public IObjectWithSiteImpl<CWMIObjectBrokerRegistration>
{
public:
	CWMIObjectBrokerRegistration()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKERREGISTRATION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBrokerRegistration
public:
	STDMETHOD(UnRegister)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(Register)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(SetDevEnvironment)(/*[in]*/ IDispatch *pEnv);
};

#endif //__WMIOBJECTBROKERREGISTRATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\dbarry.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    DBARRAY.H

Abstract:

    CDbArray template structures.

--*/

#ifndef _DBARRY_H_
#define _DBARRY_H_

class CDbArray
{
    int     m_nSize;            // apparent size
    int     m_nExtent;          // de facto size
    int     m_nGrowBy;
    void**  m_pArray;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiscriptutils.cpp ===
// WMIScriptUtils.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMIScriptUtilsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WMIScriptUtils.h"

#include "WMIScriptUtils_i.c"
#include "WMIObjectBroker.h"
#include "WMIObjectBrokerRegistration.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMIObjectBroker2, CWMIObjectBroker)
OBJECT_ENTRY(CLSID_WMIObjectBrokerRegistration2, CWMIObjectBrokerRegistration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WMISCRIPTUTILSLib2);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\dbavl.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    DBAVL.CPP

Abstract:

	Class CDbAvlTree

--*/
#ifndef _DBAVL_H_
#define _DBAVL_H_

struct AVLNode;

struct AVLNode
{
    int nBal;
    INT_PTR nKey;
    DWORD_PTR poData;
    AVLNode *poLeft;
    AVLNode *poRight;
	AVLNode *poIterLeft;
	AVLNode *poIterRight;
};

typedef AVLNode *PAVLNode;

class CDbAvlTree
{
    friend class CDbAvlTreeIterator;

    AVLNode *m_poRoot;
	AVLNode *m_poIterStart;
	AVLNode *m_poIterEnd;
    int      m_nKeyType;
    int      m_nNodeCount;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\export.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORT.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#include "Time.h"
#include "WbemCli.h"
#include "DbRep.h"
#include "Export.h"
#include "WbemUtil.h"


void CRepExporter::DumpInstanceString(INSTDEF* pInstDef, const wchar_t *wszKey, const wchar_t *pszClass)
{
    if (wszKey)
    {
        //Dump an instance block header
        DWORD dwSize = 0;
        DWORD adwBuffer[2];
        adwBuffer[0] = REP_EXPORT_INST_STR_TAG;
        adwBuffer[1] = (wcslen(wszKey) + 1) * sizeof (wchar_t);
        if ((WriteFile(g_hFile, adwBuffer, sizeof(adwBuffer), &dwSize, NULL) == 0) || (dwSize != sizeof(adwBuffer)))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S header.\n", wszKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, wszKey, (wcslen(wszKey) + 1) * sizeof (wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(wszKey) + 1) * sizeof (wchar_t)))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S.\n", wszKey, pszClass));
            throw FAILURE_WRITE;
        }
    }

    {
        //Dump the block
        DWORD dwSize = 0;
        DWORD *pdwObjectStream = Fixup((DWORD*)pInstDef->m_poObjectStream);
        DWORD dwCurSize = *(pdwObjectStream - 1);
        dwCurSize -= GetMMFBlockOverhead();
        if ((WriteFile(g_hFile, &dwCurSize, sizeof(DWORD), &dwSize, NULL) == 0) || (dwSize != sizeof(DWORD)))
        {
            if (wszKey)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of instance %S for class %S.\n", wszKey, pszClass));
            }
            else
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of class definition for class %S.\n", pszClass));
            }
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, pdwObjectStream, dwCurSize, &dwSize, NULL) == 0) || (dwSize != dwCurSize))
        {
            if (wszKey)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S.\n", wszKey, pszClass));
            }
            else
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write class definition for class %S.\n", pszClass));
            }
            throw FAILURE_WRITE;
        }
    }
}
void CRepExporter::DumpInstanceInt(INSTDEF* pInstDef, INT_PTR nKey, const wchar_t *pszClass)
{
    {
        //Dump an instance block header
        DWORD dwSize = 0;
        DWORD dwBuffer;
        dwBuffer = REP_EXPORT_INST_INT_TAG;
        if ((WriteFile(g_hFile, &dwBuffer, sizeof(DWORD), &dwSize, NULL) == 0) || (dwSize != sizeof(DWORD)))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S object and header.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, &nKey, sizeof(INT_PTR), &dwSize, NULL) == 0) || (dwSize != sizeof(INT_PTR)))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S object and header.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
    }
    {
        //Dump the block
        DWORD dwSize = 0;
        DWORD *pObjectStream = Fixup((DWORD*)pInstDef->m_poObjectStream);
        DWORD dwCurSize = *(pObjectStream - 1);
        dwCurSize -= GetMMFBlockOverhead();
        if ((WriteFile(g_hFile, &dwCurSize, sizeof(DWORD), &dwSize, NULL) == 0) || (dwSize != sizeof(DWORD)))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of instance %%d for class %S.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, pObjectStream, dwCurSize, &dwSize, NULL) == 0) || (dwSize != dwCurSize))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
    }
}
void CRepExporter::IterateKeyTree(const wchar_t *wszClassName, CLASSDEF *pOwningClass, AVLNode *pInstNode, BOOL bStringKey)
{
    if (pInstNode->poLeft)
    {
        IterateKeyTree(wszClassName, pOwningClass, Fixup(pInstNode->poLeft), bStringKey);
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    INSTDEF *pInstDef = Fixup((INSTDEF*)pInstNode->poData);
    if (Fixup(pInstDef->m_poOwningClass) == pOwningClass)
    {
        if (bStringKey)
            DumpInstanceString(pInstDef, Fixup((wchar_t*)pInstNode->nKey), wszClassName);
        else
            DumpInstanceInt(pInstDef, pInstNode->nKey, wszClassName);
    }

    if (pInstNode->poRight)
    {
        IterateKeyTree(wszClassName, pOwningClass, Fixup(pInstNode->poRight), bStringKey);
    }
}

void CRepExporter::DumpClass(CLASSDEF* pClassDef, const wchar_t *wszClassName)
{
    DWORD dwSize = 0;
    DWORD adwBuffer[6];
    adwBuffer[0] = REP_EXPORT_CLASS_TAG;
    adwBuffer[1] = (wcslen(wszClassName) + 1) * sizeof (wchar_t);
    if ((WriteFile(g_hFile, adwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write clas %S header.\n", wszClassName));
        throw FAILURE_WRITE;
    }
    if ((WriteFile(g_hFile, wszClassName, (wcslen(wszClassName) + 1) * sizeof (wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(wszClassName) + 1) * sizeof (wchar_t)))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write clas %S class name.\n", wszClassName));
        throw FAILURE_WRITE;
    }

    DumpInstanceString(Fixup(pClassDef->m_poClassDef), NULL, wszClassName);

    //Dump the children classes...
    AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD_PTR*)Fixup(Fixup(pClassDef->m_poOwningNs)->m_poClassTree))[0]));
    IterateClassNodes(pTreeNode, Fixdown(pClassDef));

    //Special cases!  We do not dump instances for the following classes...
    if ((_wcsicmp(wszClassName, L"__CIMOMIdentification") != 0))
    {
        //If we own the key tree, then we need to iterate through this...
        if (pClassDef->m_poKeyTree)
        {
            DWORD_PTR dwTreeNode = (((DWORD*)Fixup(pClassDef->m_poKeyTree))[0]);
            if (dwTreeNode)
            {
                AVLNode *pTreeNode2 = Fixup((AVLNode*)dwTreeNode);
                int keyType = GetAvlTreeNodeType(Fixup(pClassDef->m_poKeyTree));
                IterateKeyTree(wszClassName, pClassDef, pTreeNode2, (keyType == 0x1f));
            }

        }
    }
    adwBuffer[0] = REP_EXPORT_CLASS_END_TAG;
    adwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(adwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, adwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write class %S end marker.\n", wszClassName));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::IterateClassNodes(AVLNode *pClassNode, CLASSDEF *poParentClass)
{
    if (pClassNode->poLeft)
    {
        IterateClassNodes(Fixup((AVLNode *)pClassNode->poLeft), poParentClass);
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    CLASSDEF *pClassDef = Fixup((CLASSDEF*)pClassNode->poData);
    if (pClassDef->m_poSuperclass == poParentClass)
    {
        DumpClass(pClassDef, Fixup((wchar_t*)pClassNode->nKey));
    }

    if (pClassNode->poRight)
    {
        IterateClassNodes(Fixup((AVLNode *)pClassNode->poRight), poParentClass);
    }
}
void CRepExporter::IterateChildNamespaceTree(AVLNode *pNsNode)
{
    if (pNsNode->poLeft)
    {
        IterateChildNamespaceTree(Fixup((AVLNode *)pNsNode->poLeft));
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    NSREP *pNsDef = Fixup((NSREP*)pNsNode->poData);
    DumpNamespace(pNsDef);

    if (pNsNode->poRight)
    {
        IterateChildNamespaceTree(Fixup((AVLNode *)pNsNode->poRight));
    }
}

void CRepExporter::IterateChildNamespaces(RepCollection *childNamespaces)
{
    DWORD dwType;
    DWORD dwSize;
    DWORD_PTR dwItems;

    dwType = ((DWORD*)childNamespaces)[0];
    dwSize = ((DWORD*)childNamespaces)[1];
    dwItems = ((DWORD*)childNamespaces)[2];

    if ((dwType == 0) || (dwSize == 0))
        return;
    else if (dwType == 1)
    {
        //This is a pointer to a RepCollectionItem!
        RepCollectionItem *pRepCollectionItem = Fixup((RepCollectionItem*)dwItems);
        DumpNamespace(Fixup((NSREP*)pRepCollectionItem->poItem));
    }
    else if (dwType == 2)
    {
        CDbArray *pDbArray = Fixup((CDbArray*)dwItems);
        RepCollectionItem** apNsRepItem;
        apNsRepItem = Fixup((RepCollectionItem**)(((DWORD_PTR*)pDbArray)[3]));
        for (DWORD i = 0; i != dwSize; i++)
        {
            DumpNamespace(Fixup((NSREP*)(Fixup(apNsRepItem[i])->poItem)));
        }
    }
    else if (dwType == 3)
    {
        //This is a tree
        AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD_PTR*)Fixup(dwItems))[0]));
        IterateChildNamespaceTree(pTreeNode);
    }
    else
    {
        //this is a bug!
    }
}

void CRepExporter::DumpNamespace(NSREP *pNsRep)
{
    wchar_t *pszCurNs = Fixup(pNsRep->m_poName);

    DWORD dwSize = 0;
    DWORD dwBuffer[6];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_TAG;
    dwBuffer[1] = (wcslen(pszCurNs) + 1) * sizeof(wchar_t);

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S header.\n", pszCurNs));
        throw FAILURE_WRITE;
    }
    if ((WriteFile(g_hFile, pszCurNs, (wcslen(pszCurNs) + 1) * sizeof(wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(pszCurNs) + 1) * sizeof(wchar_t)))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S.\n", pszCurNs));
        throw FAILURE_WRITE;
    }

    DumpNamespaceSecurity(pNsRep);

    AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD_PTR*)Fixup(pNsRep->m_poClassTree))[0]));

    IterateClassNodes(pTreeNode, 0);

    IterateChildNamespaces(Fixup(pNsRep->m_poNamespaces));

    dwBuffer[0] = REP_EXPORT_NAMESPACE_END_TAG;
    dwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(dwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, dwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S end marker.\n", pszCurNs));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::DumpNamespaceSecurity(NSREP *pNsRep)
{
    //Default version does not have a security descriptor, so we need to
    //just dump a blank entry.
    DWORD dwSize = 0;
    DWORD dwBuffer[2];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_SEC_TAG;
    dwBuffer[1] = dwSize;

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security, %S.\n", Fixup(pNsRep->m_poName)));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::DumpRootBlock(DBROOT *pRootBlock)
{
    if (pRootBlock->m_dwFlags & DB_ROOT_INUSE)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write file header block.\n"));
        throw FAILURE_DIRTY;
    }
    char *pBuffer = REP_EXPORT_FILE_START_TAG;
    DWORD dwSizeBuffer = strlen(pBuffer);
    DWORD dwSize = 0;

    if ((WriteFile(g_hFile, pBuffer, dwSizeBuffer, &dwSize, NULL) == 0) || (dwSize != dwSizeBuffer))
    {
        throw(FAILURE_WRITE);
    }
    DumpNamespace(Fixup((NSREP*)pRootBlock->m_poRootNs));

    DWORD dwBuffer[6];
    dwBuffer[0] = REP_EXPORT_FILE_END_TAG;
    dwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(dwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, dwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write file trailer block.\n"));
        throw FAILURE_WRITE;
    }

}

void CRepExporter::DumpMMFHeader()
{
    MMF_ARENA_HEADER *pMMFHeader = m_pDbArena->GetMMFHeader();
    DumpRootBlock(Fixup((DBROOT*)pMMFHeader->m_dwRootBlock));

}

int CRepExporter::Export(CMMFArena2 *pDbArena, const TCHAR *pszFilename)
{
    DWORD dwVersion = NULL;
    HMODULE hModule = NULL;
    const char *pszDllName = NULL;
    int nRet = 0;

    m_pDbArena = pDbArena;

    g_hFile = CreateFile(pszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (g_hFile != INVALID_HANDLE_VALUE)
    {
        try
        {
            DumpMMFHeader();
            CloseHandle(g_hFile);
        }
        catch (int dProblem)
        {
            switch(dProblem)
            {
            case FAILURE_DIRTY:
                DEBUGTRACE((LOG_WBEMCORE, "Repository is marked as corrupt, therefore cannot export it.\n"));
                break;
            case FAILURE_WRITE:
                DEBUGTRACE((LOG_WBEMCORE, "Failure writing to the export file.  May be out of disk space, or may not have write access to this directory.\n"));
                break;
            default:
                DEBUGTRACE((LOG_WBEMCORE, "An unknown problem happened while traversing the repository.\n"));
                break;
            }
            CloseHandle(g_hFile);
            nRet = 1;
        }
        catch (...)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Traversal of repository file failed.  It may be corrupt.\n"));
            CloseHandle(g_hFile);
            DeleteFile(pszFilename);
            nRet = 1;
        }

    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to create file %s to export the repository.\n", pszFilename));
        nRet = 1;
    }
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv1.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV1.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#include "corepol.h"
#include "Export.h"

struct DBROOT;

void CRepExporterV1::DumpMMFHeader()
{
    DWORD_PTR*	pdwArena	= (DWORD_PTR*) Fixup((DWORD_PTR*)0);
    DBROOT*		pRootBlock	= (DBROOT*)pdwArena[9];

    DumpRootBlock(Fixup(pRootBlock));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\export.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORT.H

Abstract:

    Exporting

History:

--*/
#ifndef __export_h__
#define __export_h__

/*================================================================================
 *
 * EXPORT FILE FORMAT
 * ==================
 *
 * File Header Block:
 *		wchar_t wszFileHeader								= REP_EXPORT_FILE_START_TAG ("repexp2")
 *
 * Namespace Block:
 *		DWORD   dwObjectType								= REP_EXPORT_NAMESPACE_TAG (0x00000001)
 *		DWORD   dwNamespaceNameSize
 *		wchar_t wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *															  (\root\default\fred)
 *
 * Class Block:
 *		DWORD   dwObjectType								= REP_EXPORT_CLASS_TAG (0x00000002)
 *		DWORD   dwClassNameSize
 *		wchar_t wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		DWORD	adwClassObject[dwClassObjectSize]
 *
 * Instance Block - key of type int:
 *		DWORD   dwObjectType								= REP_EXPORT_INST_INT_TAG (0x00000003)
 *		DWORD   dwInstanceKey
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= REP_EXPORT_INST_STR_TAG (0x00000004)
 *		DWORD	dwInstanceKeySize
 *		DWORD	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *		
 * End of class block
 *		DWORD	dwObjectType								= REP_EXPORT_CLASS_END_TAG (0x00000005)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * End of namespace block
 *		DWORD	dwObjectType								= REP_EXPORT_NAMESPACE_END_TAG (0x00000006)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * Namespace security block
 *		DWORD	dwObjectType								= REP_EXPORT_NAMESPACE_SEC_TAG (0x00000007)
 *		DWORD	dwSecurityBlobSize
 *		DWORD	dwSecurityBlob[dwSecurityBlobSize]			= Security blob
 *		
 * End of file block
 *		DWORD	dwObjectType								= REP_EXPORT_FILE_END_TAG (0xFFFFFFFF)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * Ordering:
 *		File Header Block
 *			(one or more)
 *			Namespace Block
 *              Namespace security block
 *				(zero or more)
 *				{
 *					Namespace Block
 *	                  Namespace security block
 *						etc...
 *					End namespace block
 *					(or)
 *					Class Block
 *						(zero or more)
 *						{
 *							Instance Block
 *							(or)
 *							Class Block
 *								etc...
 *							End class block
 *						}
 *					End class block
 *				}
 *			End namespace block
 *		End of file block
 *
 *================================================================================
 */


#define FAILURE_DIRTY 1
#define FAILURE_WRITE 2

#define REP_EXPORT_FILE_START_TAG	 "repexp3"
#define REP_EXPORT_NAMESPACE_TAG	 0x00000001
#define REP_EXPORT_CLASS_TAG		 0x00000002
#define REP_EXPORT_INST_INT_TAG		 0x00000003
#define REP_EXPORT_INST_STR_TAG		 0x00000004
#define REP_EXPORT_CLASS_END_TAG	 0x00000005
#define REP_EXPORT_NAMESPACE_END_TAG 0x00000006
#define REP_EXPORT_NAMESPACE_SEC_TAG 0x00000007
#define REP_EXPORT_FILE_END_TAG		 0xFFFFFFFF

#define REP_EXPORT_END_TAG_SIZE		 0x00000010
#define REP_EXPORT_END_TAG_MARKER	 0xFF

#include "MMFArena2.h"

class CDbAvlTree;
struct DBROOT;
struct NSREP;
struct INSTDEF;
struct CLASSDEF;
struct AVLNode;
struct RepCollection;

class CRepExporter
{
protected:
	CMMFArena2 *m_pDbArena;
	HANDLE g_hFile;

	virtual void DumpInstanceString(INSTDEF* pInstDef, const wchar_t *wszKey, const wchar_t *pszClass);
	virtual void DumpInstanceInt(INSTDEF* pInstDef, INT_PTR nKey, const wchar_t *pszClass);
	virtual void IterateKeyTree(const wchar_t *wszClassName, CLASSDEF *pOwningClass, AVLNode *pInstNode, BOOL bStringKey);
	virtual void DumpClass(CLASSDEF* pClassDef, const wchar_t *wszClassName);
	virtual void IterateClassNodes(AVLNode *pClassNode, CLASSDEF *poParentClass);
	virtual void IterateChildNamespaceTree(AVLNode *pNsNode);
	virtual void IterateChildNamespaces(RepCollection *childNamespaces);
	virtual void DumpNamespace(NSREP *pNsRep);
	virtual void DumpNamespaceSecurity(NSREP *pNsRep);
	virtual void DumpRootBlock(DBROOT *pRootBlock);
	virtual void DumpMMFHeader();

	virtual DWORD GetMMFBlockOverhead() = 0;
	virtual int GetAvlTreeNodeType(CDbAvlTree *pTree) = 0;

public:
	virtual int Export(CMMFArena2 *pDbArena, const TCHAR *pszFilename);
	CRepExporter(){}
	virtual ~CRepExporter() {};
};

class  CRepExporterV1 : public CRepExporter
{
protected:
	//This is different from the standard base-class definition!
	DWORD GetMMFBlockOverhead() { return sizeof(MMF_BLOCK_HEADER); }
	virtual int GetAvlTreeNodeType(CDbAvlTree *pTree) { return ((int*)pTree)[1]; }
	void DumpMMFHeader();
};

class  CRepExporterV5 : public CRepExporterV1
{
protected:
	//This works in the same way as the standard base-class definition!
	virtual DWORD GetMMFBlockOverhead() { return (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER)); }
	void DumpMMFHeader();
};

class  CRepExporterV7 : public CRepExporterV5
{
protected:
	//This is different from the standard base-class definition!
	int GetAvlTreeNodeType(CDbAvlTree *pTree) { return ((int*)pTree)[3]; }
};

class  CRepExporterV9 : public CRepExporterV7
{
protected:
	void DumpNamespaceSecurity(NSREP *pNsRep);
};
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\dbrep.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    DBREP.H

Abstract:

	Object database class representations which are stored in the database.

History:

--*/
#ifndef _DBREP_H_
#define _DBREP_H_

#include <stdio.h>
#include <wbemcli.h>
#include <TIME.H>
#include "MMFArena2.h"
#include "dbavl.h"
#include "dbarry.h"
#include <wbemutil.h>

extern CMMFArena2* g_pDbArena;

struct NSREP;
struct CLASSDEF;
struct INSTDEF;
struct RepCollectionItem;
struct RepCollection;
struct PtrCollection;
struct SINDEXTABLE;
struct DANGREF;
struct DANGREFCLASS;
struct DANGREFKEY;
struct DANGLREFSCHEMA;
struct DANGREFSCHEMA;
struct DANGREFSCHEMACLASS;
struct DBROOT;

class DATABASE_CRITICAL_ERROR : public CX_Exception
{
};

//=============================================================================
//
//	RepCollectionItem
//
//	This structure is used to associate a key to the stored pointer when
//	we have a single item or an array of items.  The AvlTree has it's own
//	object to do this task so we do not need it for that.
//=============================================================================
struct RepCollectionItem
{
public:
	DWORD_PTR poKey;	//Offset within MMF of key.  We own this key value.
	DWORD_PTR poItem;	//Offset within MMF of item.  We do not own the object this points to!

};

struct RepCollection
{
private:
	enum { none, single_item, array, tree} m_repType;
	enum { MAX_ARRAY_SIZE = 10 };
	DWORD	m_dwSize;
	union
	{
		DWORD_PTR	 m_poSingleItem;
		CDbArray	*m_poDbArray;
		CDbAvlTree	*m_poDbAvlTree;
	};
};

//Repository of pointers stored in reference tables.
//If the list is one item it is a direct pointer, if a small number of items
//(say 10) it is a CDbArray, otherwise we use a CDbAvlTree.
struct PtrCollection
{
	enum { none, single_item, array, tree} m_repType;
	enum { MAX_ARRAY_SIZE = 10 };

	DWORD	m_dwSize;
	union
	{
		DWORD_PTR	m_poPtr;
		CDbArray   *m_poDbArray;
		CDbAvlTree *m_poDbAvlTree;
	};
};

struct NSREP
{
	enum { flag_normal = 0x1, flag_hidden = 0x2, flag_temp = 0x4,
		   flag_system = 0x8
		 };

	// Data members.
	// =============
	RepCollection *m_poNamespaces;		// Child namespaces, based ptr
	LPWSTR		m_poName;			 // Namespace name, based ptr
	INSTDEF	   *m_poObjectDef;		 // 'Real' object definition, based ptr
	DWORD		m_dwFlags;			 // Hidden, normal, temp, system, etc.
	CDbAvlTree *m_poClassTree;		 // Class tree by Name, CLASSDEF structs, based tr
	NSREP	   *m_poParentNs;		 // Owning namespace, based ptr
	DWORD_PTR	m_poSecurity;
};

/////////////////////////////////////////////////////////////////////////////

struct INSTDEF
{
	enum
	{
		genus_class = WBEM_GENUS_CLASS, 		//defined in IDL, 1
		genus_instance = WBEM_GENUS_INSTANCE,	//defined in IDL, 2
		compressed = 0x100
	};

	NSREP	 *m_poOwningNs; 			  // back ptr for debugging, based ptr
	CLASSDEF *m_poOwningClass;			  // back ptr for debugging, based ptr
	DWORD	  m_dwFlags;				  // Genus, etc.
	LPVOID	  m_poObjectStream; 		  // Ptr to object stream, based ptr
	PtrCollection *m_poRefTable;		   // List of references to this object
};


/////////////////////////////////////////////////////////////////////////////

#define MAX_SECONDARY_INDICES	4

struct SINDEXTABLE
{
	DWORD		m_aPropTypes[MAX_SECONDARY_INDICES];		// VT_ type of the property.
	LPWSTR		m_aPropertyNames[MAX_SECONDARY_INDICES];	// NULL entries indicate nothing
	CDbAvlTree *m_apoLookupTrees[MAX_SECONDARY_INDICES];		// Parallel to above names
};

/////////////////////////////////////////////////////////////////////////////
struct CLASSDEF
{
	enum {	keyed = 0x1,
			unkeyed = 0x2,
			indexed = 0x4,
			abstract = 0x08,
			borrowed_index = 0x10,
			dynamic = 0x20,
//			has_refs = 0x40,
			singleton = 0x80,
			compressed = 0x100,
			has_class_refs = 0x200
		 };
	
	// Data members.
	// =============
	NSREP		 *m_poOwningNs;		// Back reference to owning namespace, based ptr
	INSTDEF	     *m_poClassDef;		// Local definition mixed with instances, based ptr
	CLASSDEF	 *m_poSuperclass;	// Immediate parent class, based ptr
	DWORD		  m_dwFlags; 		// Various combinations of the above enum flags
	CDbAvlTree	 *m_poKeyTree;		// Instances by key, based ptr
	PtrCollection*m_poSubclasses;	// Child classes, based ptr
	SINDEXTABLE  *m_poSecondaryIx;	// Based ptr to secondary indices
	PtrCollection*m_poInboundRefClasses;	// Classes which may have dyn instances which reference
											// objects of this class
};

/////////////////////////////////////////////////////////////////////////////

struct DANGREF : public RepCollection
{
};

struct DANGREFCLASS : public RepCollection
{};
struct DANGREFKEY : public RepCollection
{};

/////////////////////////////////////////////////////////////////////////////
struct DANGLREFSCHEMA : public RepCollection
{};

struct DANGREFSCHEMA : public RepCollection
{};

struct DANGREFSCHEMACLASS : public RepCollection
{
};

/////////////////////////////////////////////////////////////////////////////

#define DB_ROOT_CLEAN		0x0
#define DB_ROOT_INUSE		0x1

struct DBROOT
{
public:
	time_t			m_tCreate;
	time_t			m_tUpdate;
	DWORD			m_dwFlags;				// in-use, stable, etc.
	NSREP		   *m_poRootNs; 			// ROOT namespace
	DANGREF 	   *m_poDanglingRefTbl; 	// Dangling reference table
	DANGREFSCHEMA  *m_poSchemaDanglingRefTbl;// Same as above but for schema-based fixups
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv5.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV5.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"

#include "corepol.h"
#include "Export.h"

void CRepExporterV5::DumpMMFHeader()
{
    MMF_ARENA_HEADER *pMMFHeader = m_pDbArena->GetMMFHeader();
    DumpRootBlock(Fixup((DBROOT*)pMMFHeader->m_dwRootBlock));

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv7.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV7.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"

//There is nothing different here from the base class.  All changes are in-line to the class definition!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv9.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV9.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#include "Time.h"
#include "WbemCli.h"
#include "DbRep.h"
#include "Export.h"
#include "WbemUtil.h"


void CRepExporterV9::DumpNamespaceSecurity(NSREP *pNsRep)
{
    //Default version does not have a security descriptor, so we need to
    //just dump a blank entry.
    DWORD dwSize = 0;
    DWORD dwBuffer[2];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_SEC_TAG;
    if (pNsRep->m_poSecurity)
        dwBuffer[1] = g_pDbArena->Size(pNsRep->m_poSecurity);
    else
        dwBuffer[1] = 0;

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security header, %S.\n", Fixup(pNsRep->m_poName)));
        throw FAILURE_WRITE;
    }

    if (dwBuffer[1] != 0)
    {
        if ((WriteFile(g_hFile, (void*)Fixup(pNsRep->m_poSecurity), dwBuffer[1], &dwSize, NULL) == 0) || (dwSize != dwBuffer[1]))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security block, %S.\n", Fixup(pNsRep->m_poName)));
            throw FAILURE_WRITE;
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\import.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    IMPORT.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <StdIo.h>
#include <ConIo.h>
#include <wbemint.h>
#include <WbemUtil.h>
#include <corex.h>
#include "upgrade.h"
#include "Import.h"
#include "export.h"
#include "reg.h"


template <class T> class CMyRelMe
{
    T m_p;
    public:
        CMyRelMe(T p) : m_p(p) {};
        ~CMyRelMe() { if (m_p) m_p->Release(); }
        void Set(T p) { m_p = p; }
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() {SysFreeString(m_str);}
};

bool CRepImporter::CheckOldSecurityClass(const wchar_t* wszClass)
{
    // check whether it is an old security class
    bool bOldSecurityClass = false;
    if(m_bSecurityMode)
    {
        if(!_wcsicmp(wszClass, L"__SecurityRelatedClass"))
            bOldSecurityClass = true;
        else if(!_wcsicmp(wszClass, L"__Subject"))
            bOldSecurityClass = true;
        else if(!_wcsicmp(wszClass, L"__User"))
            bOldSecurityClass = true;
        else if(!_wcsicmp(wszClass, L"__NTLMUser"))
            bOldSecurityClass = true;
        else if(!_wcsicmp(wszClass, L"__Group"))
            bOldSecurityClass = true;
        else if(!_wcsicmp(wszClass, L"__NTLMGroup"))
            bOldSecurityClass = true;
    }
    return bOldSecurityClass;
}

void CRepImporter::DecodeTrailer()
{
    DWORD dwTrailerSize = 0;
    DWORD dwTrailer[4];
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwTrailerSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        LogMessage(MSG_ERROR, "Failed to read a block trailer size.");
        throw FAILURE_READ;
    }
    if (dwTrailerSize != REP_EXPORT_END_TAG_SIZE)
    {
        LogMessage(MSG_ERROR, "Block trailer size is invalid.");
        throw FAILURE_INVALID_TRAILER;
    }
    if ((ReadFile(m_hFile, dwTrailer, REP_EXPORT_END_TAG_SIZE, &dwSize, NULL) == 0) || (dwSize != REP_EXPORT_END_TAG_SIZE))
    {
        LogMessage(MSG_ERROR, "Failed to read a block trailer.");
        throw FAILURE_READ;
    }
    for (int i = 0; i < 4; i++)
    {
        if (dwTrailer[i] != REP_EXPORT_FILE_END_TAG)
        {
            LogMessage(MSG_ERROR, "Block trailer has invalid contents.");
            throw FAILURE_INVALID_TRAILER;
        }
    }

}

void CRepImporter::DecodeInstanceInt(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass)
{
    char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read the key and object size
    INT_PTR dwKey = 0;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwKey, sizeof(INT_PTR), &dwSize, NULL) == 0) || (dwSize != sizeof(INT_PTR)))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve instance key for class %S. (i)", pszParentClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    DWORD dwHeader;
    if ((ReadFile(m_hFile, &dwHeader, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve instance object size for class %S. (i)", pszParentClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    char *pObjectBlob = new char[dwHeader];
    if (pObjectBlob == 0)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<char> delMe(pObjectBlob);

    //Read the blob
    if ((ReadFile(m_hFile, pObjectBlob, dwHeader, &dwSize, NULL) == 0) || (dwSize != dwHeader))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve instance information for class %S. (i)", pszParentClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    if (pNewParentClass == (_IWmiObject*)-1)
    {
        //We are working with a class which has problems... we need to ignore this instance...
        return;
    }

    // create old Nova-style instance
    HRESULT hr;
    _IWmiObject* pOldInstance = 0;
    CMyRelMe<_IWmiObject*> relMe(pOldInstance);
    _IWmiObject* pNewInstance = 0;
    CMyRelMe<_IWmiObject*> relMe2(pNewInstance);

    hr = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, dwSize, pObjectBlob, &pOldInstance);
    if (FAILED(hr))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to merge old instance (i); HRESULT = %#lx", hr);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_CANNOT_MERGE_INSTANCE;
    }
    if (pOldInstance == 0)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    relMe.Set(pOldInstance);

    // put the new instance into the repository
    hr = pNamespace->PutInstance(pOldInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
    if (FAILED(hr))
    {

        // Original put failed, so we will try to upgrade the instance and retry the put
        // upgrade to new Whistler instance
        hr = pOldInstance->Upgrade(pNewParentClass, 0L, &pNewInstance);
        if (FAILED(hr))
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to upgrade to new instance (i); HRESULT = %#lx", hr);
            LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_CANNOT_UPGRADE_INSTANCE;
        }
        if (pNewInstance == 0)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        relMe2.Set(pNewInstance);

        hr = pNamespace->PutInstance(pNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

        if ( FAILED(hr))
        {
            if (!CheckOldSecurityClass(pszParentClass))
            {
                StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to create instance %S.%d in repository. (i); HRESULT = %#lx", pszParentClass, dwKey, hr);
                LogMessage(MSG_ERROR, szMsg);
                throw FAILURE_CANNOT_CREATE_INSTANCE;
            }
            else
            {
                // This is an old Win9x security class, but it can't be put yet because the win9x users haven't been migrated at this point in setup.
                // Instead, write it out to the win9x security blob file so it can be processed later after setup is completed
                if (!AppendWin9xBlobFile(wszFullPath, pszParentClass, pNewInstance))
                {
                    StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to write Win9x security class to file for instance %S.%d", pszParentClass, dwKey);
                    LogMessage(MSG_ERROR, szMsg);
                }
            }
        }

    }
}

void CRepImporter::DecodeInstanceString(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass)
{
    char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read the key and object size
    DWORD dwKeySize;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwKeySize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve instance key size for class %S. (s)", pszParentClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    wchar_t *wszKey = new wchar_t[dwKeySize];
    if (wszKey == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe(wszKey);
    if ((ReadFile(m_hFile, wszKey, dwKeySize, &dwSize, NULL) == 0) || (dwSize != dwKeySize))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve instance key for class %S. (s)", pszParentClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    DWORD dwBlobSize;
    if ((ReadFile(m_hFile, &dwBlobSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve instance object size for %S.%S from import file. (s)", pszParentClass, wszKey);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    char *pObjectBlob = new char[dwBlobSize];
    if (pObjectBlob == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<char> delMe2(pObjectBlob);

    //Read the blob
    if ((ReadFile(m_hFile, pObjectBlob, dwBlobSize, &dwSize, NULL) == 0) || (dwSize != dwBlobSize))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve instance %S.%S from import file. (s)", pszParentClass, wszKey);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    if (pNewParentClass == (_IWmiObject*)-1)
    {
        //We are working with a class which has problems... we need to ignore this instance...
        return;
    }

    // create old Nova-style instance
    HRESULT hr;
    _IWmiObject* pOldInstance = 0;
    CMyRelMe<_IWmiObject*> relMe(pOldInstance);
    _IWmiObject* pNewInstance = 0;
    CMyRelMe<_IWmiObject*> relMe2(pNewInstance);

    hr = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, dwSize, pObjectBlob, &pOldInstance);
    if (FAILED(hr))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to merge old instance (s); HRESULT = %#lx", hr);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_CANNOT_MERGE_INSTANCE;
    }
    if (pOldInstance == 0)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    relMe.Set(pOldInstance);

    // put the instance into the repository
    // if this fails, upgrade and retry
    hr = pNamespace->PutInstance(pOldInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
    if (FAILED(hr))
    {

        // upgrade to new Whistler instance
        hr = pOldInstance->Upgrade(pNewParentClass, 0L, &pNewInstance);
        if (FAILED(hr))
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to upgrade to new instance (s); HRESULT = %#lx", hr);
            LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_CANNOT_UPGRADE_INSTANCE;
        }
        if (pNewInstance == 0)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        relMe2.Set(pNewInstance);

        hr = pNamespace->PutInstance(pNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

        if ( FAILED(hr))
        {
            if (!CheckOldSecurityClass(pszParentClass))
            {
                StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to create instance %S.%S in repository. (s); HRESULT = %#lx", pszParentClass, wszKey, hr);
                LogMessage(MSG_ERROR, szMsg);
                throw FAILURE_CANNOT_CREATE_INSTANCE;
            }
            else
            {
                // This is an old Win9x security class, but it can't be put yet because the win9x users haven't been migrated at this point in setup.
                // Instead, write it out to the win9x security blob file so it can be processed later after setup is completed
                if (!AppendWin9xBlobFile(wszFullPath, pszParentClass, pNewInstance))
                {
                    StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to write Win9x security class to file for instance %S.%S", pszParentClass, wszKey);
                    LogMessage(MSG_ERROR, szMsg);
                }
            }
        }
    }
}

void CRepImporter::DecodeClass(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *wszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass)
{
    char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read our current class from the file...
    HRESULT hr;
    DWORD dwClassSize = 0;
    DWORD dwSize = 0;
    _IWmiObject* pOldClass = 0;
    CMyRelMe<_IWmiObject*> relMe(pOldClass);
    _IWmiObject* pNewClass = 0;
    CMyRelMe<_IWmiObject*> relMe2(pNewClass);

    if ((ReadFile(m_hFile, &dwClassSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve class size for class with parent class %S.", wszParentClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    wchar_t *wszClass = new wchar_t[dwClassSize];
    if (wszClass == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe(wszClass);
    if ((ReadFile(m_hFile, wszClass, dwClassSize, &dwSize, NULL) == 0) || (dwSize != dwClassSize))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve class information for class with parent class %S.", wszParentClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    //Now we have the class blob...
    if ((ReadFile(m_hFile, &dwClassSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve class size for class %S.", wszClass);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    if (dwClassSize)
    {
        char *pClassBlob = new char[dwClassSize];
        if (pClassBlob == NULL)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        CVectorDeleteMe<char> delMe2(pClassBlob);
        if ((ReadFile(m_hFile, pClassBlob, dwClassSize, &dwSize, NULL) == 0) || (dwSize != dwClassSize))
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve class information for class %S.", wszClass);
            LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_READ;
        }

        if (pNewParentClass == (_IWmiObject*)-1)
        {
            // parent class was bad, so don't process this class
            pNewClass = (_IWmiObject*)-1;
        }
        else
        {
            // create old Nova-style class
            hr = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_CLASS, dwSize, pClassBlob, &pOldClass);
            if (FAILED(hr))
            {
                StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to merge old class; HRESULT = %#lx", hr);
                LogMessage(MSG_ERROR, szMsg);
                throw FAILURE_CANNOT_MERGE_CLASS;
            }
            if (pOldClass == 0)
            {
                throw FAILURE_OUT_OF_MEMORY;
            }
            relMe.Set(pOldClass);

            //If the class is a system class then we do not write it... it may have changed for starters,
            //but also we create all system classes when a new database/namespace is created...
            if (_wcsnicmp(wszClass, L"__", 2) != 0)
            {
                // put the class into the repository
                // if this fails, upgrade it and retry
                hr = pNamespace->PutClass(pOldClass, WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_FORCE_MODE, NULL, NULL);
                if (FAILED(hr))
                {

                    // upgrade to new Whistler class (note: pNewParentClass will be NULL for base classes)
                    hr = pOldClass->Upgrade(pNewParentClass, 0L, &pNewClass);
                    if (FAILED(hr))
                    {
                        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to upgrade to new class; HRESULT = %#lx", hr);
                        LogMessage(MSG_ERROR, szMsg);
                        throw FAILURE_CANNOT_UPGRADE_CLASS;
                    }
                    if (pNewClass == 0)
                    {
                        throw FAILURE_OUT_OF_MEMORY;
                    }
                    relMe2.Set(pNewClass);

                    // retry the put
                    hr = pNamespace->PutClass(pNewClass, WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_FORCE_MODE, NULL, NULL);

                    if ( FAILED(hr) )
                    {
                        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to create class for class %S; HRESULT = %#lx", wszClass, hr);
                        LogMessage(MSG_ERROR, szMsg);
                        throw FAILURE_CANNOT_CREATE_CLASS;
                    }
                }
            }

            // We need to re-get the class as class comparisons may fail to see
            // that this class is in fact the same as the one in the database!
            if ( NULL != pNewClass )
            {
                pNewClass->Release();
                pNewClass = 0;
                relMe2.Set(NULL);
            }

            BSTR bstrClassName = SysAllocString(wszClass);
            if (!bstrClassName)
                throw FAILURE_OUT_OF_MEMORY;
            CSysFreeMe fm(bstrClassName);
            hr = pNamespace->GetObject(bstrClassName, 0L, NULL, (IWbemClassObject**) &pNewClass, NULL);
            if (FAILED(hr))
            {
                if (_wcsnicmp(wszClass, L"__", 2) != 0)
                {
                    StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve class %S from the repository after creating it; HRESULT = %#lx", wszClass, hr);
                    LogMessage(MSG_ERROR, szMsg);
                    throw FAILURE_CANNOT_GET_PARENT_CLASS;
                }
                else
                {
                    if (_wcsicmp(wszClass, L"__CIMOMIdentification") != 0) // we don't want to warn about failures to retrieve this class
                    {
                        // couldn't get the system class
                        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve system class %S from the repository; HRESULT = %#lx", wszClass, hr);
                        LogMessage(MSG_WARNING, szMsg);
                    }

                    // set pointer to -1 and continue processing file
                    // old comment said: If this does not exist then it cannot be important!
                    pNewClass = (_IWmiObject*)-1;
                }
            }
            else
                relMe2.Set(pNewClass);
        }
    }
    else
    {
        // This is a situation where we have a class in the export file,
        // but the size is zero, so we just get the class from the repository.

        // ***** So what do we do about pOldClass?  At this point it is NULL.        *****
        // ***** We need the old class to be able to upgrade child classes properly. *****

        if (pNewParentClass == (_IWmiObject*)-1)
        {
            // parent class was bad, so don't process this class
            pNewClass = (_IWmiObject*)-1;
        }
        else
        {
            // get the class from the repository
            BSTR bstrClassName = SysAllocString(wszClass);
            if (!bstrClassName)
                throw FAILURE_OUT_OF_MEMORY;
            CSysFreeMe fm(bstrClassName);
            hr = pNamespace->GetObject(bstrClassName, 0L, NULL, (IWbemClassObject**) &pNewClass, NULL);
            if (FAILED(hr))
            {
                StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve class %S from the repository; HRESULT = %#lx", wszClass, hr);
                LogMessage(MSG_ERROR, szMsg);
                throw FAILURE_CANNOT_GET_PARENT_CLASS;
            }
            relMe2.Set(pNewClass);
        }
    }

    //Now we iterate through all child classes and instances until we get an end of class marker...
    while (1)
    {
        DWORD dwType = 0;
        if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            LogMessage(MSG_ERROR, "Failed to read next block type from import file.");
            throw FAILURE_READ;
        }
        if (dwType == REP_EXPORT_CLASS_TAG)
        {
            DecodeClass(pNamespace, wszFullPath, wszClass, pOldClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_INST_INT_TAG)
        {
            DecodeInstanceInt(pNamespace, wszFullPath, wszClass, pOldClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_INST_STR_TAG)
        {
            DecodeInstanceString(pNamespace, wszFullPath, wszClass, pOldClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_CLASS_END_TAG)
        {
            //That's the end of this class...
            DecodeTrailer();
            break;
        }
        else
        {
            LogMessage(MSG_ERROR, "Next block type in import file is invalid.");
            throw FAILURE_INVALID_TYPE;
        }
    }
}

void CRepImporter::DecodeNamespace(IWbemServices* pParentNamespace, const wchar_t *wszParentNamespace)
{
    char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read our current namespace from the file...
    DWORD dwNsSize = 0;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwNsSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve a namespace whose parent namespace is %S.", wszParentNamespace);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    wchar_t *wszNs = new wchar_t[dwNsSize];
    if (wszNs == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe(wszNs);
    if ((ReadFile(m_hFile, wszNs, dwNsSize, &dwSize, NULL) == 0) || (dwSize != dwNsSize))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve a namespace whose parent namespace is %S.", wszParentNamespace);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    if (wbem_wcsicmp(wszNs, L"security") == 0)
    {
        m_bSecurityMode = true;
    }

    wchar_t *wszFullPath = new wchar_t[wcslen(wszParentNamespace) + 1 + wcslen(wszNs) + 1];
    if (wszFullPath == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe2(wszFullPath);
    StringCchCopyW(wszFullPath, MAX_MSG_TEXT_LENGTH, wszParentNamespace);
    if (wcslen(wszParentNamespace) != 0)
    {
        StringCchCatW(wszFullPath, MAX_MSG_TEXT_LENGTH, L"\\");
    }
    StringCchCatW(wszFullPath, MAX_MSG_TEXT_LENGTH, wszNs);

    // open the namespace
    IWbemServices* pNamespace = NULL;
    CMyRelMe<IWbemServices*> relMe2(pNamespace);
    HRESULT hr;

    if (pParentNamespace)
    {
        BSTR bstrNamespace = SysAllocString(wszNs);
        if (!bstrNamespace)
            throw FAILURE_OUT_OF_MEMORY;
           CSysFreeMe fm(bstrNamespace);
        hr = pParentNamespace->OpenNamespace(bstrNamespace, WBEM_FLAG_CONNECT_REPOSITORY_ONLY, NULL, &pNamespace, NULL);
        if (FAILED(hr))
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve namespace %S from the repository; HRESULT = %#lx", wszFullPath, hr);
            LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_CANNOT_FIND_NAMESPACE;
        }
    }
    else // special start case for root
    {
        IWbemLocator* pLocator = NULL;
        CMyRelMe<IWbemLocator*> relMe(pLocator);
        hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, IID_IWbemLocator, (void**) &pLocator);
        if(FAILED(hr))
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to create instance of IWbemLocator; HRESULT = %#lx", hr);
            LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_CANNOT_CREATE_IWBEMLOCATOR;
        }
        else
        {
            relMe.Set(pLocator);
            BSTR bstrNamespace = SysAllocString(L"root");
            if (!bstrNamespace)
                throw FAILURE_OUT_OF_MEMORY;
               CSysFreeMe fm(bstrNamespace);
            hr = pLocator->ConnectServer(bstrNamespace, NULL, NULL, NULL, WBEM_FLAG_CONNECT_REPOSITORY_ONLY, NULL, NULL, &pNamespace);
            if (FAILED(hr))
            {
                StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to connect server; HRESULT = %#lx", hr);
                LogMessage(MSG_ERROR, szMsg);
                throw FAILURE_CANNOT_CONNECT_SERVER;
            }
        }
    }

    if (pNamespace == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    relMe2.Set(pNamespace);

    //Get and set the namespace security...
    DWORD dwBuffer[2];
    if ((ReadFile(m_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve a namespace security header for namespace %S.", wszFullPath);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    if (dwBuffer[0] != REP_EXPORT_NAMESPACE_SEC_TAG)
    {
        LogMessage(MSG_ERROR, "Expecting a namespace security blob and did not find it.");
        throw FAILURE_INVALID_TYPE;
    }
    if (dwBuffer[1] != 0)
    {
        char *pNsSecurity = new char[dwBuffer[1]];
        CVectorDeleteMe<char> delMe3(pNsSecurity);

        if (pNsSecurity == NULL)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        if ((ReadFile(m_hFile, pNsSecurity, dwBuffer[1], &dwSize, NULL) == 0) || (dwSize != dwBuffer[1]))
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to retrieve a namespace security blob for namespace %S.", wszFullPath);
            LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_READ;
        }

        // we have the security blob, now set the SECURITY_DESCRIPTOR property in the namespace
        DecodeNamespaceSecurity(pNamespace, pParentNamespace, pNsSecurity, dwBuffer[1], wszFullPath);
    }

    // create empty Nova-style class object for use in decoding base classes
    _IWmiObjectFactory* pObjFactory = NULL;
    CMyRelMe<_IWmiObjectFactory*> relMe3(pObjFactory);
    hr = CoCreateInstance(CLSID__WmiObjectFactory, NULL, CLSCTX_ALL, IID__IWmiObjectFactory, (void**) &pObjFactory);
    if(FAILED(hr))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to create instance of IWmiObjectFactory; HRESULT = %#lx", hr);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_CANNOT_CREATE_OBJECTFACTORY;
    }
    if (pObjFactory == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    relMe3.Set(pObjFactory);

    _IWmiObject* pBaseObject = NULL;
    CMyRelMe<_IWmiObject*> relMe4(pBaseObject);
    hr = pObjFactory->Create(NULL, 0L, CLSID__WbemEmptyClassObject, IID__IWmiObject, (void**) &pBaseObject);
    if(FAILED(hr))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to create instance of IWmiObject; HRESULT = %#lx", hr);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_CANNOT_CREATE_IWMIOBJECT;
    }
    if (pBaseObject == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    relMe4.Set(pBaseObject);

    //Now we need to iterate through the next set of blocks of namespace or class
    //until we get to an end of NS marker
    while (1)
    {
        DWORD dwType = 0;
        if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            LogMessage(MSG_ERROR, "Failed to read next block type (namespace/class) from import file.");
            throw FAILURE_READ;
        }
        if (dwType == REP_EXPORT_NAMESPACE_TAG)
        {
            DecodeNamespace(pNamespace, wszFullPath);
        }
        else if (dwType == REP_EXPORT_CLASS_TAG)
        {
            DecodeClass(pNamespace, wszFullPath, L"", pBaseObject, NULL);
        }
        else if (dwType == REP_EXPORT_NAMESPACE_END_TAG)
        {
            //That's the end of this namespace...
            DecodeTrailer();
            break;
        }
        else
        {
            LogMessage(MSG_ERROR, "Next block type (namespace/class) in import file is invalid.");
            throw FAILURE_INVALID_TYPE;
        }
    }

    m_bSecurityMode = false;
}

void CRepImporter::DecodeNamespaceSecurity(IWbemServices* pNamespace, IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwSize, const wchar_t* wszFullPath)
{
    char szMsg[MAX_MSG_TEXT_LENGTH];

    // determine whether we have an old Win9x pseudo-blob
    DWORD dwStoredAsNT = 0;
    if (pNsSecurity)
    {
        DWORD* pdwData = (DWORD*)pNsSecurity;
        DWORD dwBlobSize = *pdwData;
        pdwData++;
        DWORD dwVersion = *pdwData;
        if(dwVersion != 1 || dwBlobSize == 0 || dwBlobSize > 64000)
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Invalid namespace security blob header for namespace %S.", wszFullPath);
            LogMessage(MSG_ERROR, szMsg);
            return;
        }

        pdwData++;
        dwStoredAsNT = *pdwData;
    }

    if (!dwStoredAsNT)
    {
        // Do not process Win9x security blobs, because Win9x users haven't been migrated over yet at this point in setup.
        // Instead, write them out to a file to be processed after setup is complete.

        if (!AppendWin9xBlobFile(wszFullPath, dwSize, pNsSecurity))
        {
            StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Unable to write Win9x security blob to file for namespace %S.", wszFullPath);
            LogMessage(MSG_ERROR, szMsg);
        }
        return;
    }

    // now transform the old security blob that consisted of a header and array of ACE's
    // into a proper Security Descriptor that can be stored in the property

    CNtSecurityDescriptor mmfNsSD;
    if (!TransformBlobToSD(pParentNamespace, pNsSecurity, dwStoredAsNT, mmfNsSD))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to convert security blob to SD for namespace %S.", wszFullPath);
        LogMessage(MSG_ERROR, szMsg);
        return;
    }

    // now set the security
    if (!SetNamespaceSecurity(pNamespace, mmfNsSD))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to set namespace security for namespace %S.", wszFullPath);
        LogMessage(MSG_ERROR, szMsg);
        return;
    }
}

void CRepImporter::Decode()
{
    char pszBuff[7];
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, pszBuff, 7, &dwSize, NULL) == 0) || (dwSize != 7))
    {
        LogMessage(MSG_ERROR, "Failed to retrieve the import file header information.");
        throw FAILURE_READ;
    }
    if (strncmp(pszBuff, REP_EXPORT_FILE_START_TAG, 7) != 0)
    {
        LogMessage(MSG_ERROR, "The import file specified is not an import file.");
        throw FAILURE_INVALID_FILE;
    }

    //We should have a tag for a namespace...
    DWORD dwType = 0;
    if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        LogMessage(MSG_ERROR, "Failed to read next block type from import file.");
        throw FAILURE_READ;
    }
    if (dwType != REP_EXPORT_NAMESPACE_TAG)
    {
        LogMessage(MSG_ERROR, "Next block type in import file is invalid.");
        throw FAILURE_INVALID_TYPE;
    }
    DecodeNamespace(NULL, L"");

    // if we opened a Win9x security blob upgrade file, close it
    CloseWin9xBlobFile();

    // force ROOT\DEFAULT and ROOT\SECURITY namespaces to inherit their inheritable security settings
    ForceInherit();

    //Now we should have the file trailer
    if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
        LogMessage(MSG_ERROR, "Failed to read next block type (trailer) from import file.");
        throw FAILURE_READ;
    }
    if (dwType != REP_EXPORT_FILE_END_TAG)
    {
        LogMessage(MSG_ERROR, "Next block type (trailer) in import file is invalid.");
        throw FAILURE_INVALID_TYPE;
    }
    DecodeTrailer();
}

int CRepImporter::ImportRepository(const TCHAR *pszFromFile)
{
    LogMessage(MSG_INFO, "Beginning ImportRepository");

    int nRet = no_error;
    m_hFile = CreateFile(pszFromFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        try
        {
            Decode();
        }
        catch (CX_MemoryException)
        {
            LogMessage(MSG_ERROR, "Memory Exception.");
            nRet = out_of_memory;
        }
        catch (...)
        {
            LogMessage(MSG_ERROR, "Traversal of import file failed.");
            nRet = critical_error;
        }
        CloseHandle(m_hFile);
    }
    else
    {
        char szMsg[MAX_MSG_TEXT_LENGTH];
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Could not open the import file \"%s\" for reading.", pszFromFile);
        LogMessage(MSG_ERROR, szMsg);
        nRet = critical_error;
    }

    if (nRet == no_error)
        LogMessage(MSG_INFO, "ImportRepository completed successfully.");
    else
        LogMessage(MSG_ERROR, "ImportRepository failed to complete.");

    return nRet;
}

//***************************************************************************
//***************************************************************************
//
//  Helper functions for DecodeNamespaceSecurity
//
//***************************************************************************
//***************************************************************************

bool CRepImporter::TransformBlobToSD(IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD)
{
    // now transform the old security blob that consisted of a header and array of ACE's
    // into a proper Security Descriptor that can be stored in the property

    // build up an ACL from our blob, if we have one
    CNtAcl acl;

    if (pNsSecurity)
    {
        DWORD* pdwData = (DWORD*) pNsSecurity;
        pdwData += 3;
        int iAceCount = (int)*pdwData;
        pdwData += 2;
        BYTE* pAceData = (BYTE*)pdwData;

        PGENERIC_ACE pAce = NULL;
        for (int iCnt = 0; iCnt < iAceCount; iCnt++)
        {
            pAce = (PGENERIC_ACE)pAceData;
            if (!pAce)
            {
                LogMessage(MSG_ERROR, "Failed to access GENERIC_ACE within security blob");
                return false;
            }

            CNtAce ace(pAce);
            if(ace.GetStatus() != 0)
            {
                LogMessage(MSG_ERROR, "Failed to construct CNtAce from GENERIC_ACE");
                return false;
            }

            acl.AddAce(&ace);
            if (acl.GetStatus() != 0)
            {
                LogMessage(MSG_ERROR, "Failed to add ACE to ACL");
                return false;
            }

            pAceData += ace.GetSize();
        }
    }

    // a real SD was constructed and passed in by reference, now set it up properly
    SetOwnerAndGroup(mmfNsSD);
    mmfNsSD.SetDacl(&acl);
    if (mmfNsSD.GetStatus() != 0)
    {
        LogMessage(MSG_ERROR, "Failed to convert namespace security blob to SD");
        return false;
    }

    // add in the parent's inheritable aces, if this is not ROOT
    if (pParentNamespace)
    {
        if (!GetParentsInheritableAces(pParentNamespace, mmfNsSD))
        {
            LogMessage(MSG_ERROR, "Failed to inherit parent's inheritable ACE's");
            return false;
        }
    }

    return true;
}

bool CRepImporter::SetNamespaceSecurity(IWbemServices* pNamespace, CNtSecurityDescriptor& mmfNsSD)
{
    // now set the security

    if (!pNamespace)
        return false;

    IWbemClassObject* pThisNamespace = NULL;
    BSTR bstrNamespace = SysAllocString(L"__thisnamespace=@");
    if (!bstrNamespace)
        throw FAILURE_OUT_OF_MEMORY;
       CSysFreeMe fm(bstrNamespace);
    HRESULT hr = pNamespace->GetObject(bstrNamespace, 0, NULL, &pThisNamespace, NULL);
    if (FAILED(hr))
    {
        LogMessage(MSG_ERROR, "Failed to get singleton namespace object");
        return false;
    }
    CMyRelMe<IWbemClassObject*> relMe(pThisNamespace);


    //
    // Check to see if namespace contains any ALLOW or DENY ACEs for NETWORK/LOCAL SERVICE
    // If they do exist, we leave them as is, otherwise we want to add them to the SD.
    //
    if ( CheckNetworkLocalService ( mmfNsSD ) == false )
    {
        LogMessage(MSG_ERROR, "Failed to add NETWORK/LOCAL service ACEs");
        return false;
    }

    SAFEARRAY FAR* psa;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = mmfNsSD.GetSize();
    psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
    if (!psa)
        throw FAILURE_OUT_OF_MEMORY;

    char* pData = NULL;
    hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
    if (FAILED(hr))
    {
        LogMessage(MSG_ERROR, "Failed SafeArrayAccessData");
        return false;
    }
    memcpy(pData, mmfNsSD.GetPtr(), mmfNsSD.GetSize());
    hr = SafeArrayUnaccessData(psa);
    if (FAILED(hr))
    {
        LogMessage(MSG_ERROR, "Failed SafeArrayUnaccessData");
        return false;
    }
    pData = NULL;

    VARIANT var;
    var.vt = VT_UI1|VT_ARRAY;
    var.parray = psa;
    hr = pThisNamespace->Put(L"SECURITY_DESCRIPTOR" , 0, &var, 0);
    VariantClear(&var);
    if (FAILED(hr))
    {
        if (hr == WBEM_E_OUT_OF_MEMORY)
            throw FAILURE_OUT_OF_MEMORY;
        else
        {
            LogMessage(MSG_ERROR, "Failed to put SECURITY_DESCRIPTOR property");
            return false;
        }
    }

    hr = pNamespace->PutInstance(pThisNamespace, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
    if (FAILED(hr))
    {
        if (hr == WBEM_E_OUT_OF_MEMORY)
            throw FAILURE_OUT_OF_MEMORY;
        else
        {
            LogMessage(MSG_ERROR, "Failed to put back singleton instance");
            return false;
        }
    }
    return true;
}


/*
    --------------------------------------------------------------------------
   |
   | Checks to see if the namespace had a previous ACE with NETWORK or LOCAL
   | service accounts. If so, it simply leaves them, otherwise, it adds a 
   | ACE with default settings for these accounts. The default settings are:
   | WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER
   | The characteristics of the ACE is irrelevant. Only SID comparison applies.
   |
    --------------------------------------------------------------------------
*/
bool CRepImporter::CheckNetworkLocalService ( CNtSecurityDescriptor& mmfNsSD )
{
    DWORD dwAccessMaskNetworkLocalService = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;
    PSID pRawSid = NULL ;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    BOOL bStatus = TRUE ;
    BYTE flags = 0 ;

    CNtAcl* pAcl = mmfNsSD.GetDacl ( ) ;
    CDeleteMe<CNtAcl> AclDelete ( pAcl ) ;

    //
    // Start with NETWORK_SERVICE account
    //
    if(AllocateAndInitializeSid( &id, 1,
        SECURITY_NETWORK_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidNetworkService (pRawSid);
        FreeSid(pRawSid);
    
        {
            CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, 
                                                        ACCESS_ALLOWED_ACE_TYPE,
                                                        CONTAINER_INHERIT_ACE, 
                                                        SidNetworkService );
            if ( NULL == pace )
            {
                bStatus = FALSE ;
            }
            else
            {
                CDeleteMe<CNtAce> dm(pace);
                pAcl->AddAce(pace);
            }
        }
    }

    //
    // Next, LOCAL_SERVICE account
    //
    if ( bStatus == TRUE )
    {
        pRawSid = NULL ;
        if(AllocateAndInitializeSid( &id, 1,
            SECURITY_LOCAL_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
        {
            CNtSid SidLocalService (pRawSid);
            FreeSid(pRawSid);
        
            {
                CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, 
                                                           ACCESS_ALLOWED_ACE_TYPE,
                                                           CONTAINER_INHERIT_ACE, 
                                                           SidLocalService );
                if ( NULL == pace )
                {
                    bStatus = FALSE ;
                }
                else
                {
                    CDeleteMe<CNtAce> dm(pace);
                    pAcl->AddAce(pace);
                }
            }
        }
    }
    if ( bStatus == TRUE )
    {
        mmfNsSD.SetDacl ( pAcl ) ;
    }
    return bStatus ? true : false ;
}





bool CRepImporter::GetParentsInheritableAces(IWbemServices* pParentNamespace, CNtSecurityDescriptor &sd)
{
    if (!pParentNamespace)
        return false;

    // Get the parent namespace's SD
    CNtSecurityDescriptor sdParent;
    if (!GetSDFromNamespace(pParentNamespace, sdParent))
        return false;

    // strip out the inherited aces so we have a consistent SD
    if (!StripOutInheritedAces(sd))
        return false;

    // Go through the parents dacl and add any inheritable aces to ours.
    if (!CopyInheritAces(sd, sdParent))
        return false;

    return true;
}

bool CRepImporter::GetSDFromNamespace(IWbemServices* pNamespace, CNtSecurityDescriptor& sd)
{
    if (!pNamespace)
        return false;

    // get the singleton object
    IWbemClassObject* pThisNamespace = NULL;
    BSTR bstrNamespace = SysAllocString(L"__thisnamespace=@");
    if (!bstrNamespace)
        throw FAILURE_OUT_OF_MEMORY;
       CSysFreeMe fm(bstrNamespace);
    HRESULT hr = pNamespace->GetObject(bstrNamespace, 0, NULL, &pThisNamespace, NULL);
    if (FAILED(hr))
    {
        LogMessage(MSG_ERROR, "Failed to get singleton namespace object");
        return false;
    }
    CMyRelMe<IWbemClassObject*> relMe(pThisNamespace);

    // Get the security descriptor argument
    VARIANT var;
    VariantInit(&var);
    hr = pThisNamespace->Get(L"SECURITY_DESCRIPTOR", 0, &var, NULL, NULL);
    if (FAILED(hr))
    {
        VariantClear(&var);
        LogMessage(MSG_ERROR, "Failed to get SECURITY_DESCRIPTOR property");
        return false;
    }

    if(var.vt != (VT_ARRAY | VT_UI1))
    {
        VariantClear(&var);
        LogMessage(MSG_ERROR, "Failed to get SECURITY_DESCRIPTOR property due to incorrect variant type");
        return false;
    }

    SAFEARRAY* psa = var.parray;
    PSECURITY_DESCRIPTOR pSD;
    hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if (FAILED(hr))
    {
        VariantClear(&var);
        LogMessage(MSG_ERROR, "GetSDFromNamespace failed SafeArrayAccessData");
        return false;
    }

    BOOL bValid = IsValidSecurityDescriptor(pSD);
    if (!bValid)
    {
        VariantClear(&var);
        LogMessage(MSG_ERROR, "GetSDFromNamespace retrieved an invalid security descriptor");
        return false;
    }

    CNtSecurityDescriptor sdNew(pSD);

    // Check to make sure the owner and group is not NULL!!!!
    CNtSid *pTmpSid = sdNew.GetOwner();
    if (pTmpSid == NULL)
    {
        LogMessage(MSG_ERROR, "Security descriptor was retrieved and it had no owner");
    }
    delete pTmpSid;

    pTmpSid = sdNew.GetGroup();
    if (pTmpSid == NULL)
    {
        LogMessage(MSG_ERROR, "Security descriptor was retrieved and it had no group");
    }
    delete pTmpSid;
    
    sd = sdNew;
    SafeArrayUnaccessData(psa);
    VariantClear(&var);
    return true;
}

bool CRepImporter::StripOutInheritedAces(CNtSecurityDescriptor &sd)
{
    // Get the DACL
    CNtAcl* pAcl;
    pAcl = sd.GetDacl();
    if(!pAcl)
        return false;
    CDeleteMe<CNtAcl> dm(pAcl);

    // enumerate through the aces
    DWORD dwNumAces = pAcl->GetNumAces();
    BOOL bChanged = FALSE;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce *pAce = pAcl->GetAce(nIndex);
        if(pAce)
        {
            long lFlags = pAce->GetFlags();
            if(lFlags & INHERITED_ACE)
            {
                pAcl->DeleteAce(nIndex);
                bChanged = TRUE;
            }
        }
    }
    if(bChanged)
        sd.SetDacl(pAcl);
    return true;
}

bool CRepImporter::CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent)
{
    // Get the acl list for both SDs

    CNtAcl * pacl = sd.GetDacl();
    if(pacl == NULL)
        return false;
    CDeleteMe<CNtAcl> dm0(pacl);

    CNtAcl * paclParent = sdParent.GetDacl();
    if(paclParent == NULL)
        return false;
    CDeleteMe<CNtAcl> dm1(paclParent);

    int iNumParent = paclParent->GetNumAces();
    for(int iCnt = 0; iCnt < iNumParent; iCnt++)
    {
        CNtAce *pParentAce = paclParent->GetAce(iCnt);
        CDeleteMe<CNtAce> dm2(pParentAce);

        long lFlags = pParentAce->GetFlags();
        if(lFlags & CONTAINER_INHERIT_ACE)
        {

            if(lFlags & NO_PROPAGATE_INHERIT_ACE)
                lFlags ^= CONTAINER_INHERIT_ACE;
            lFlags |= INHERITED_ACE;

            // If this is an inherit only ace we need to clear this
            // in the children.
            // NT RAID: 161761        [marioh]
            if ( lFlags & INHERIT_ONLY_ACE )
                lFlags ^= INHERIT_ONLY_ACE;

            pParentAce->SetFlags(lFlags);
            pacl->AddAce(pParentAce);
        }
    }
    sd.SetDacl(pacl);
    return true;
}

BOOL CRepImporter::SetOwnerAndGroup(CNtSecurityDescriptor &sd)
{
    PSID pRawSid;
    BOOL bRet = FALSE;

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmins(pRawSid);
        bRet = sd.SetGroup(&SidAdmins);        // Access check doesn't really care what you put,
                                            // so long as you put something for the owner
        if(bRet)
            bRet = sd.SetOwner(&SidAdmins);
        FreeSid(pRawSid);
        return bRet;
    }
    return bRet;
}

void CRepImporter::ForceInherit()
{
    // force ROOT\DEFAULT and ROOT\SECURITY namespaces to inherit their inheritable security settings

    char szMsg[MAX_MSG_TEXT_LENGTH];

    IWbemLocator* pLocator = NULL;
    HRESULT hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, IID_IWbemLocator, (void**) &pLocator);
    if(FAILED(hr))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to create instance of IWbemLocator; HRESULT = %#lx", hr);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_CANNOT_CREATE_IWBEMLOCATOR;
    }
    CMyRelMe<IWbemLocator*> relMe1(pLocator);

    IWbemServices* pRootNamespace = NULL;
    ConnectNamespace(pLocator, L"root", &pRootNamespace);
    CMyRelMe<IWbemServices*> relMe2(pRootNamespace);

    if (!InheritSecurity(pLocator, pRootNamespace, L"root\\default"))
        LogMessage(MSG_ERROR, "Failed to force inherit for root\\default");

    if (!InheritSecurity(pLocator, pRootNamespace, L"root\\security"))
        LogMessage(MSG_ERROR, "Failed to force inherit for root\\security");
}

bool CRepImporter::InheritSecurity(IWbemLocator* pLocator, IWbemServices* pRootNamespace, const wchar_t* wszNamespace)
{
    IWbemServices* pNamespace = NULL;
    ConnectNamespace(pLocator, wszNamespace, &pNamespace);
    CMyRelMe<IWbemServices*> relMe(pNamespace);

    CNtSecurityDescriptor sdNamespace;
    if (!GetSDFromNamespace(pNamespace, sdNamespace))
        return false;

    if (!GetParentsInheritableAces(pRootNamespace, sdNamespace))
        return false;

    if (!SetNamespaceSecurity(pNamespace, sdNamespace))
        return false;

    return true;
}

void CRepImporter::ConnectNamespace(IWbemLocator* pLocator, const wchar_t* wszNamespaceName, IWbemServices** ppNamespace)
{
    char szMsg[MAX_MSG_TEXT_LENGTH];

    // get the namespace
    BSTR bstrNamespace = SysAllocString(wszNamespaceName);
    if (!bstrNamespace)
        throw FAILURE_OUT_OF_MEMORY;
    CSysFreeMe fm(bstrNamespace);

    HRESULT hres = pLocator->ConnectServer(bstrNamespace, NULL, NULL, NULL, WBEM_FLAG_CONNECT_REPOSITORY_ONLY, NULL, NULL, ppNamespace);
    if (FAILED(hres))
    {
        StringCchPrintfA(szMsg, MAX_MSG_TEXT_LENGTH, "Failed to connect server for namespace %S; HRESULT = %#lx", wszNamespaceName, hres);
        LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_CANNOT_CONNECT_SERVER;
    }
    if (!*ppNamespace)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
}

//***************************************************************************
//***************************************************************************
//
//  Helper functions for Win9x security processing
//
//***************************************************************************
//***************************************************************************

bool CRepImporter::AppendWin9xBlobFile(const wchar_t* wszFullPath, DWORD dwBlobSize, const char* pNsSecurity)
{
    // check whether we need to create the blob file
    if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
    {
        if (!CreateWin9xBlobFile())
            return false;
    }

    // write the blob header containing the type, namespace name size, and blob size to the file
    BLOB9X_SPACER header;
    header.dwSpacerType = BLOB9X_TYPE_SECURITY_BLOB;
    header.dwNamespaceNameSize = (wcslen(wszFullPath)+1)*sizeof(wchar_t);
    header.dwParentClassNameSize = 0;
    header.dwBlobSize = dwBlobSize;
    DWORD dwSize = 0;
    if (WriteFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) && (dwSize == sizeof(header)))
    {
        // write the namespace name to the file
        dwSize = 0;
        if (WriteFile(m_h9xBlobFile, wszFullPath, header.dwNamespaceNameSize, &dwSize, NULL) && (dwSize == header.dwNamespaceNameSize))
        {
            // write the blob to the file
            dwSize = 0;
            if (WriteFile(m_h9xBlobFile, pNsSecurity, dwBlobSize, &dwSize, NULL) && (dwSize == dwBlobSize))
                return true;
        }
    }
    
    // if we failed to write to the file, something is wrong with the file, so close and delete it
    DeleteWin9xBlobFile();
    return false;
}

bool CRepImporter::AppendWin9xBlobFile(const wchar_t* wszFullPath, const wchar_t* wszParentClass, _IWmiObject* pInstance)
{
    // check whether we need to create the blob file
    if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
    {
        if (!CreateWin9xBlobFile())
            return false;
    }

    //Get the size of the object
    DWORD dwObjPartLen = 0;
    HRESULT hRes = pInstance->Unmerge(0, 0, &dwObjPartLen, 0);

    //Allocate the size of the object
    BYTE *pObjPart = NULL;
    if (hRes == WBEM_E_BUFFER_TOO_SMALL)
    {
        hRes = WBEM_S_NO_ERROR;
        pObjPart = new BYTE[dwObjPartLen];
    }

    if (pObjPart)
    {
        CVectorDeleteMe<BYTE> delMe(pObjPart);
    
        //retrieve the object blob
        if (SUCCEEDED(hRes))
        {
            DWORD dwLen;
            hRes = pInstance->Unmerge(0, dwObjPartLen, &dwLen, pObjPart);
        }
            
        if (SUCCEEDED(hRes))
        {
            // write the blob header containing the type, namespace name size, parent class name size, and blob size to the file
            BLOB9X_SPACER header;
            header.dwSpacerType = BLOB9X_TYPE_SECURITY_INSTANCE;
            header.dwNamespaceNameSize = (wcslen(wszFullPath)+1)*sizeof(wchar_t);
            header.dwParentClassNameSize = (wcslen(wszParentClass)+1)*sizeof(wchar_t);
            header.dwBlobSize = dwObjPartLen;
            DWORD dwSize = 0;
            if (WriteFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) && (dwSize == sizeof(header)))
            {
                // write the namespace name to the file
                dwSize = 0;
                if (WriteFile(m_h9xBlobFile, wszFullPath, header.dwNamespaceNameSize, &dwSize, NULL) && (dwSize == header.dwNamespaceNameSize))
                {
                    // write the parent class name to the file
                    dwSize = 0;
                    if (WriteFile(m_h9xBlobFile, wszParentClass, header.dwParentClassNameSize, &dwSize, NULL) && (dwSize == header.dwParentClassNameSize))
                    {
                        // write the blob to the file
                        dwSize = 0;
                        if (WriteFile(m_h9xBlobFile, pObjPart, dwObjPartLen, &dwSize, NULL) && (dwSize == dwObjPartLen))
                            return true;
                    }
                }
            }
        }
    }
    
    // if we failed to write to the file, something is wrong with the file, so close and delete it
    DeleteWin9xBlobFile();
    return false;
}

bool CRepImporter::CreateWin9xBlobFile()
{
    // get the root directory of the repository
    wchar_t wszFilePath[MAX_PATH+1];
    if (!GetRepositoryDirectory(wszFilePath))
        return false;

    // append blob file name
    StringCchCatW(wszFilePath, MAX_PATH+1, BLOB9X_FILENAME);

    // create a new file in which to store blob info
    m_h9xBlobFile = CreateFileW(wszFilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
        return false;

    // write the blob file header
    BLOB9X_HEADER header;
    StringCchCopyA(header.szSignature, sizeof(header.szSignature)/sizeof(char), BLOB9X_SIGNATURE);
    DWORD dwSize = 0;
    if (WriteFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) && (dwSize == sizeof(header)))
        return true;

    // if we failed to write to the file we should close the handle and delete the file
    CloseHandle(m_h9xBlobFile);
    DeleteFileW(wszFilePath);
    m_h9xBlobFile = INVALID_HANDLE_VALUE;
    return false;
}

void CRepImporter::DeleteWin9xBlobFile()
{
    // close and invalidate the handle if necessary
    if (m_h9xBlobFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_h9xBlobFile);
        m_h9xBlobFile = INVALID_HANDLE_VALUE;
    }

    // delete the file
    wchar_t wszFilePath[MAX_PATH+1];
    if (GetRepositoryDirectory(wszFilePath))
    {
        StringCchCatW(wszFilePath, MAX_PATH+1, BLOB9X_FILENAME);
        DeleteFileW(wszFilePath);
    }
}

bool CRepImporter::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\WBEM\\CIMOM", 0, KEY_READ, &hKey))
        return false;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = (MAX_PATH + 1) * sizeof(wchar_t);
    long lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, (LPBYTE)wszTmp, &dwLen);
    RegCloseKey(hKey);
    if(lRes)
        return false;

    if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
        return false;

    return true;
}

bool CRepImporter::CloseWin9xBlobFile()
{
    // if no valid handle, then we don't have a file to close, return success
    if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
        return true;

    // write the end of blob file marker
    BLOB9X_SPACER trailer;
    trailer.dwSpacerType = BLOB9X_TYPE_END_OF_FILE;
    trailer.dwNamespaceNameSize = 0;
    trailer.dwParentClassNameSize = 0;
    trailer.dwBlobSize = 0;
    DWORD dwSize = 0;
    if ((WriteFile(m_h9xBlobFile, &trailer, sizeof(trailer), &dwSize, NULL) == 0) || (dwSize != sizeof(trailer)))
    {
        // if we failed to write the trailer, something is wrong with the file, so close and delete it
        DeleteWin9xBlobFile();
        return false;
    }

    CloseHandle(m_h9xBlobFile);
    m_h9xBlobFile = INVALID_HANDLE_VALUE;
    return true;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

extern HRESULT Traverse ( 

    IWbemServices *a_Service ,
    BSTR a_Namespace
) ;

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

PSID g_NetworkServiceSid = NULL ;
PSID g_LocalServiceSid = NULL ;

ACCESS_ALLOWED_ACE *g_NetworkService_Ace = NULL ;
WORD g_NetworkService_AceSize = 0 ;

ACCESS_ALLOWED_ACE *g_LocalService_Ace = NULL ;
WORD g_LocalService_AceSize = 0 ;

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT TraverseSetSecurity ( IWbemServices *a_Service ) 
{
    IClientSecurity *t_Security = NULL ;
    HRESULT t_Result = a_Service->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Security ) ;
    if ( SUCCEEDED ( t_Result ) )
    {
        t_Result = t_Security->SetBlanket ( 
            a_Service , 
            RPC_C_AUTHN_WINNT, 
            RPC_C_AUTHZ_NONE, 
            NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT , 
            RPC_C_IMP_LEVEL_IDENTIFY, 
            NULL,
            EOAC_NONE
        ) ;

        t_Security->Release () ;
    }

    return t_Result ;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT InsertServiceAccess (

    SAFEARRAY *a_Array ,
    SAFEARRAY *&a_NewArray
)
{
    HRESULT t_Result = S_OK ;

    if ( SafeArrayGetDim ( a_Array ) == 1 )
    {
        LONG t_Dimension = 1 ; 

        LONG t_Lower ;
        SafeArrayGetLBound ( a_Array , t_Dimension , & t_Lower ) ;

        LONG t_Upper ;
        SafeArrayGetUBound ( a_Array , t_Dimension , & t_Upper ) ;

        LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

        BYTE *t_SecurityDescriptor = new BYTE [ t_Count ] ;
        if ( t_SecurityDescriptor )
        {
            if ( t_Count ) 
            {
                for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
                {
                    BYTE t_Element ;
                    if ( SUCCEEDED ( SafeArrayGetElement ( a_Array , & t_ElementIndex , & t_Element ) ) )
                    {
                        t_SecurityDescriptor [ t_ElementIndex - t_Lower ] = t_Element ;
                    }
                    else
                    {
                        t_Result = WBEM_E_CRITICAL_ERROR ;
                        break ;
                    }
                }
            }
        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }

        if ( SUCCEEDED ( t_Result ) )
        {
            if ( IsValidSecurityDescriptor ( t_SecurityDescriptor ) == FALSE )
            {
                t_Result = WBEM_E_CRITICAL_ERROR ;
            }
        }

        bool t_NetworkServicePresent = false ;
        bool t_LocalServicePresent = false ;
        if ( SUCCEEDED ( t_Result ) )
        {
            BOOL t_AclPresent = FALSE ;
            BOOL t_AclDefaulted = FALSE ;
            ACL *t_Dacl = NULL ;

            BOOL t_Status = GetSecurityDescriptorDacl (t_SecurityDescriptor ,& t_AclPresent ,& t_Dacl ,& t_AclDefaulted) ;

            if (  t_Status )
            {
               DWORD SidNetworkSvcSize = GetLengthSid(g_NetworkServiceSid);
               DWORD SidLocalSvcSize = GetLengthSid(g_LocalServiceSid);

                ACCESS_ALLOWED_ACE * pACE = (ACCESS_ALLOWED_ACE *)(t_Dacl+1);
                for (USHORT i=0;i<t_Dacl->AceCount;i++)
                {
                    DWORD sidSize = GetLengthSid((PSID)&pACE->SidStart);
                    if ((sidSize == SidNetworkSvcSize) &&
                        (0 == memcmp(&pACE->SidStart,g_NetworkServiceSid,sidSize)))
                    {
                        t_NetworkServicePresent = true;
                    }
                    
                    if ((sidSize == SidLocalSvcSize) &&
                        (0 == memcmp(&pACE->SidStart,g_LocalServiceSid,sidSize)))
                    {
                        t_LocalServicePresent = true;
                    }
                    
                    pACE = (ACCESS_ALLOWED_ACE *)((BYTE *)pACE + pACE->Header.AceSize);
                }
            }
            else
            {
                t_Result = HRESULT_FROM_WIN32(GetLastError());
            }            
        }


        if ( SUCCEEDED ( t_Result ) ) 
        {
            SECURITY_DESCRIPTOR *t_AbsoluteSecurityDescriptor = NULL ;
            DWORD t_AbsoluteSecurityDescriptorSize = sizeof ( SECURITY_DESCRIPTOR ) ;

            PACL t_Dacl = NULL ;
            PACL t_Sacl = NULL ;
            PSID t_Owner = NULL ;
            PSID t_PrimaryGroup = NULL ;

            DWORD t_DaclSize = 0 ;
            DWORD t_SaclSize = 0 ;
            DWORD t_OwnerSize = 0 ;
            DWORD t_PrimaryGroupSize = 0 ;

            BOOL t_Status = MakeAbsoluteSD (t_SecurityDescriptor ,t_AbsoluteSecurityDescriptor ,& t_AbsoluteSecurityDescriptorSize ,
                                          t_Dacl,& t_DaclSize,t_Sacl,& t_SaclSize,t_Owner,& t_OwnerSize,t_PrimaryGroup,& t_PrimaryGroupSize) ;

            if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
            {
                WORD t_Extra = 0 ;
                if ( t_NetworkServicePresent == false )
                {
                    t_Extra = t_Extra + g_NetworkService_AceSize ;
                }

                if ( t_LocalServicePresent == false ) 
                {
                    t_Extra = t_Extra + g_LocalService_AceSize ;
                }

                t_DaclSize = t_DaclSize + t_Extra ;

                t_Dacl = ( PACL ) new BYTE [ t_DaclSize ] ;
                t_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
                t_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
                t_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;
            
                t_AbsoluteSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_AbsoluteSecurityDescriptorSize ] ;

                if ( t_AbsoluteSecurityDescriptor && t_Dacl && t_Sacl && t_Owner && t_PrimaryGroup )
                {
                    BOOL t_Status = InitializeSecurityDescriptor ( t_AbsoluteSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
                    if ( t_Status )
                    {
                        t_Status = MakeAbsoluteSD (t_SecurityDescriptor ,t_AbsoluteSecurityDescriptor ,& t_AbsoluteSecurityDescriptorSize ,
                            t_Dacl ,& t_DaclSize ,t_Sacl,& t_SaclSize,t_Owner,& t_OwnerSize,t_PrimaryGroup,& t_PrimaryGroupSize
                        ) ;

                        WORD t_AceCount = t_Dacl->AceCount ;

                        if ( t_Status )
                        {
                            t_Dacl->AclSize = ( WORD ) t_DaclSize ;

                            if ( t_NetworkServicePresent == false )
                            {
                                t_Status = AddAce ( t_Dacl , ACL_REVISION, t_AceCount ++ , g_NetworkService_Ace , g_NetworkService_AceSize) ;
                            }
                        }

                        if ( t_Status )
                        {
                            if ( t_LocalServicePresent == false )
                            {
                                t_Status = AddAce ( t_Dacl , ACL_REVISION, t_AceCount ++ , g_LocalService_Ace , g_LocalService_AceSize) ;
                            }
                        }

                        if ( t_Status == FALSE )
                        {
                            t_Result = WBEM_E_CRITICAL_ERROR ;
                        }
                    }
                }
            }

            if ( SUCCEEDED ( t_Result ) )
            {
                SECURITY_DESCRIPTOR *t_SecurityDescriptorRelative = NULL ;
                DWORD t_FinalLength = 0 ;

                t_Status = MakeSelfRelativeSD (t_AbsoluteSecurityDescriptor ,t_SecurityDescriptorRelative ,& t_FinalLength ) ;

                if ( t_Status == FALSE && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
                {
                    t_SecurityDescriptorRelative = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_FinalLength ] ;
                    if ( t_SecurityDescriptorRelative )
                    {
                        t_Status = InitializeSecurityDescriptor ( t_SecurityDescriptorRelative , SECURITY_DESCRIPTOR_REVISION ) ;
                        if ( t_Status )
                        {
                            t_Status = MakeSelfRelativeSD (t_AbsoluteSecurityDescriptor ,t_SecurityDescriptorRelative ,& t_FinalLength ) ;

                            if ( t_Status == FALSE )
                            {
                                t_Result = WBEM_E_CRITICAL_ERROR ;
                            }
                        }
                        else
                        {
                            t_Result = WBEM_E_CRITICAL_ERROR ;
                        }
                    }
                    else
                    {
                        t_Result = WBEM_E_OUT_OF_MEMORY ;                                    
                    }
                }
                else
                {
                    t_Result = WBEM_E_CRITICAL_ERROR ;
                }

                if ( SUCCEEDED ( t_Result ) )        
                {
                    SAFEARRAYBOUND t_Bounds ;
                    t_Bounds.lLbound = 0;
                    t_Bounds.cElements = t_FinalLength ;

                    a_NewArray = SafeArrayCreate ( VT_UI1 , 1 , & t_Bounds ) ;
                    if ( a_NewArray )
                    {
                        for ( LONG t_Index = 0 ; ( ( ULONG ) t_Index ) < t_FinalLength ; t_Index ++ )
                        {
                            BYTE t_Byte = * ( ( ( BYTE * ) t_SecurityDescriptorRelative ) + t_Index ) ;
                            t_Result = SafeArrayPutElement ( a_NewArray , & t_Index , & t_Byte ) ;
                            if ( FAILED ( t_Result ) )
                            {
                                break ;
                            }
                        }
                    }
                    else
                    {
                        t_Result = WBEM_E_OUT_OF_MEMORY ;                                    
                    }
                }

                delete [] ( BYTE * ) t_SecurityDescriptorRelative ;
            }

            delete [] ( BYTE * ) t_Dacl ;
            delete [] ( BYTE * ) t_Sacl ;
            delete [] ( BYTE * ) t_Owner ;
            delete [] ( BYTE * ) t_PrimaryGroup ;
        }

        delete [] t_SecurityDescriptor ;
    }
    else
    {
        t_Result = WBEM_E_CRITICAL_ERROR ;
    }

    return t_Result ;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT ConfigureSecurity (

    IWbemServices *a_Service 
)
{
    HRESULT t_Result = S_OK ;

    BSTR t_ObjectPath = SysAllocString ( L"__SystemSecurity" ) ;
    BSTR t_MethodName = SysAllocString ( L"GetSD" ) ;
    if ( t_ObjectPath && t_MethodName )
    {
        IWbemClassObject *t_Object = NULL ;

        t_Result = a_Service->ExecMethod (t_ObjectPath ,t_MethodName ,0 ,NULL ,NULL ,& t_Object ,NULL);

        if ( SUCCEEDED ( t_Result ) )
        {
            VARIANT t_Variant ;
            VariantInit ( & t_Variant ) ;

            LONG t_VarType = 0 ;
            LONG t_Flavour = 0 ;

            HRESULT t_Result = t_Object->Get ( L"SD" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
            if ( SUCCEEDED ( t_Result ) )
            {
                if ( t_Variant.vt == ( VT_UI1 | VT_ARRAY ) )
                {
                    SAFEARRAY *t_Array = t_Variant.parray ;
                    SAFEARRAY *t_NewArray = NULL ;

                    t_Result = InsertServiceAccess (t_Array ,t_NewArray ) ;

                    if ( SUCCEEDED ( t_Result ) )
                    {
                        BSTR t_Class = SysAllocString ( L"__SystemSecurity" ) ;
                        if ( t_Class )
                        {
                            IWbemClassObject *t_InObject = NULL ;
                            t_Result = a_Service->GetObject (t_Class ,0 , NULL , & t_InObject ,NULL ) ;

                            if ( SUCCEEDED ( t_Result ) )
                            {
                                BSTR t_SetMethodName = SysAllocString ( L"SetSD" ) ;
                                if ( t_SetMethodName )
                                {
                                    IWbemClassObject *t_InArgsClass = NULL ;
                                    t_Result = t_InObject->GetMethod (t_SetMethodName ,0 ,& t_InArgsClass ,NULL ) ;

                                    if ( SUCCEEDED ( t_Result ) )
                                    {
                                        IWbemClassObject *t_InArgs = NULL ;

                                        t_Result = t_InArgsClass->SpawnInstance ( 0 , & t_InArgs ) ;
                                        if ( SUCCEEDED ( t_Result ) )
                                        {
                                            VARIANT t_Variant ;
                                            VariantInit ( & t_Variant ) ;
                                            t_Variant.vt = VT_UI1 | VT_ARRAY ;
                                            t_Variant.parray = t_NewArray ;

                                            t_Result = t_InArgs->Put ( L"SD" ,0 ,& t_Variant ,CIM_UINT8 | CIM_FLAG_ARRAY) ;

                                            if ( SUCCEEDED ( t_Result ) )
                                            {
                                                IWbemClassObject *t_OutArgs = NULL ;
                                                a_Service->ExecMethod (t_ObjectPath ,t_SetMethodName ,0 ,NULL ,t_InArgs ,& t_OutArgs ,NULL ) ;

                                                if ( SUCCEEDED ( t_Result ) )
                                                {
                                                    if ( t_OutArgs )
                                                    {
                                                        t_OutArgs->Release () ;
                                                    }
                                                }
                                            }

                                            t_InArgs->Release () ;
                                        }

                                        t_InArgsClass->Release () ;
                                    }

                                    SysFreeString ( t_SetMethodName ) ;
                                }

                                t_InObject->Release () ;
                            }
                        }
                        else
                        {
                            t_Result = WBEM_E_OUT_OF_MEMORY ;
                        }

                        SafeArrayDestroy ( t_NewArray ) ;
                    }
                }
                else
                {
                    t_Result = WBEM_E_CRITICAL_ERROR ;
                }

                VariantClear ( & t_Variant ) ;
            }

            t_Object->Release () ;
        }
    }
    else
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }

    SysFreeString ( t_ObjectPath ) ;
    SysFreeString ( t_MethodName ) ;

    return t_Result ;
}


/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT Traverse ( 
    IWbemServices *a_Service ,
    BSTR a_Namespace
)
{
    if ( wcslen ( a_Namespace ) < ( MAX_MSG_TEXT_LENGTH >> 1 ) )
    {
        char t_Buffer [ MAX_MSG_TEXT_LENGTH ] ;
        StringCchPrintfA ( t_Buffer , MAX_MSG_TEXT_LENGTH, "\nTraversing [%S]" , a_Namespace ) ;
        LogMessage(MSG_INFO, t_Buffer);
    }

    HRESULT t_Result = ConfigureSecurity (a_Service ) ;

    if ( FAILED ( t_Result ) )
    {
        char t_Buffer [ MAX_MSG_TEXT_LENGTH ] ;
        StringCchPrintfA ( t_Buffer, MAX_MSG_TEXT_LENGTH , "\nConfiguration of Security failed [%lx]" , t_Result ) ;
        LogMessage(MSG_INFO, t_Buffer);
    }
    return t_Result ;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT ConfigureServiceSecurity ()
{
    IWbemLocator *t_Locator = NULL ;
    HRESULT t_Result = CoCreateInstance (CLSID_WbemLocator ,NULL ,CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
                                        IID_IUnknown ,( void ** )  & t_Locator);

    if ( SUCCEEDED ( t_Result ) )
    {
        BSTR t_Root = SysAllocString ( L"root" ) ;
        if ( t_Root )
        {
            IWbemServices *t_Service = NULL ;
            HRESULT t_Result = t_Locator->ConnectServer (t_Root ,NULL ,NULL,NULL ,0 ,NULL,NULL,&t_Service) ;

            if ( SUCCEEDED ( t_Result ) )
            {
                t_Result = TraverseSetSecurity ( t_Service ) ;
                if ( SUCCEEDED ( t_Result ) )
                {
                    t_Result = Traverse (t_Service ,t_Root ) ;
                }

                t_Service->Release () ;
            }
            else
            {
                char t_Buffer [ MAX_MSG_TEXT_LENGTH ] ;
                StringCchPrintfA ( t_Buffer , MAX_MSG_TEXT_LENGTH, "\nFailing Connecting to Namespace [%s] with result [%lx]" , t_Root , t_Result ) ;
                LogMessage(MSG_INFO, t_Buffer);
            }

            SysFreeString ( t_Root ) ;
        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }

        t_Locator->Release () ;
    }

    return t_Result ;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT InitializeConstants ()
{
    HRESULT t_Result = S_OK ;

    SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

    BOOL t_Status = AllocateAndInitializeSid (& t_NtAuthoritySid ,1 ,SECURITY_NETWORK_SERVICE_RID,0,0,0,0,0,0,0,& g_NetworkServiceSid) ;

    if ( t_Status )
    {
        DWORD t_SidLength = :: GetLengthSid ( g_NetworkServiceSid );
        g_NetworkService_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
        g_NetworkService_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ g_NetworkService_AceSize ] ;
        if ( g_NetworkService_Ace )
        {
            CopySid ( t_SidLength, (PSID) & g_NetworkService_Ace->SidStart, g_NetworkServiceSid ) ;
            g_NetworkService_Ace->Mask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;
            g_NetworkService_Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE ;
            g_NetworkService_Ace->Header.AceFlags = CONTAINER_INHERIT_ACE ;
            g_NetworkService_Ace->Header.AceSize = g_NetworkService_AceSize ;
        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }
    else
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }

    if ( SUCCEEDED ( t_Result ) )
    {
        t_Status = AllocateAndInitializeSid (& t_NtAuthoritySid ,1 ,SECURITY_LOCAL_SERVICE_RID,0,0,0,0,0,0,0,& g_LocalServiceSid) ;

        if ( t_Status )
        {
            DWORD t_SidLength = :: GetLengthSid ( g_LocalServiceSid );
            g_LocalService_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
            g_LocalService_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ g_LocalService_AceSize ] ;
            if ( g_LocalService_Ace )
            {
                CopySid ( t_SidLength, (PSID) & g_LocalService_Ace->SidStart, g_LocalServiceSid ) ;
                g_LocalService_Ace->Mask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;
                g_LocalService_Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE ;
                g_LocalService_Ace->Header.AceFlags = CONTAINER_INHERIT_ACE ;
                g_LocalService_Ace->Header.AceSize = g_LocalService_AceSize ;
            }
            else
            {
                t_Result = WBEM_E_OUT_OF_MEMORY ;
            }

        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }

    return t_Result ;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT UnInitializeConstants ()
{
    FreeSid ( g_NetworkServiceSid ) ;
    FreeSid ( g_LocalServiceSid ) ;

    delete [] ( ( BYTE * ) g_NetworkService_Ace ) ;
    delete [] ( ( BYTE * ) g_LocalService_Ace ) ;

    return S_OK ;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT UpdateServiceSecurity ()
{
    HRESULT t_Result = InitializeConstants () ;
    if ( SUCCEEDED ( t_Result ) )
    {
        t_Result = ConfigureServiceSecurity () ;

        UnInitializeConstants () ;
    }

    return t_Result ;
}

/******************************************************************************
 *
 *    Name:
 *
 *    
 *  Description:
 *
 *    
 *****************************************************************************/

HRESULT CheckForServiceSecurity ()
{
    Registry r(WBEM_REG_WBEM);
    if (r.GetStatus() != no_error)
    {
        LogMessage(MSG_ERROR, "Unable to access registry for UpdateServiceSecurity.");
        return WBEM_E_CRITICAL_ERROR ;
    }

    char *t_BuildVersion = NULL ;
    if ( r.GetStr ("Build", & t_BuildVersion ) )
    {
        LogMessage(MSG_ERROR, "Unable to get build version number for UpdateServiceSecurity.");
        return WBEM_E_CRITICAL_ERROR ;
    }

    if ( strlen ( t_BuildVersion ) >= 4 )
    {
        t_BuildVersion [ 4 ] = 0 ;
    }
    else
    {
        LogMessage(MSG_ERROR, "Unexpected build version number for UpdateServiceSecurity.");
        return WBEM_E_CRITICAL_ERROR ;
    }

    DWORD t_BuildVersionNumber = 0 ;
    if ( sscanf ( t_BuildVersion , "%lu" , & t_BuildVersionNumber ) == NULL )
    {
        LogMessage(MSG_ERROR, "Unable to convert build version number for UpdateServiceSecurity.");
        return WBEM_E_CRITICAL_ERROR ;
    }

    if ( t_BuildVersionNumber < 2600 )
    {
        LogMessage(MSG_INFO, "Operating System Version < WindowsXP (2600) UpdateServiceSecurity.");
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\mmfarena2.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    MMFARENA.H

Abstract:

    CArena derivative based on memory mapped files.

History:

    a-raymcc    23-Apr-96       Created
    paulall     23-Mar-98       Re-worked

--*/

#ifndef _MMFARENA_H_
#define _MMFARENA_H_

#include "corepol.h"
#include "FlexArry.h"

#if defined _WIN32
#define MMF_DELETED_MASK        0x80000000
#define MMF_REMOVE_DELETED_MASK 0x7FFFFFFF
#define MMF_DEBUG_DELETED_TAG   0xFFFFFFFF
#define MMF_DEBUG_INUSE_TAG     0xFEFEFEFE
#elif defined _WIN64
#define MMF_DELETED_MASK        0x8000000000000000
#define MMF_REMOVE_DELETED_MASK 0x7FFFFFFFFFFFFFFF
#define MMF_DEBUG_DELETED_TAG   0xFFFFFFFFFFFFFFFF
#define MMF_DEBUG_INUSE_TAG     0xFEFEFEFEFEFEFEFE
#endif

struct MMFOffsetItem;

#include "corex.h"
class DATABASE_FULL_EXCEPTION : public CX_Exception
{
};

//***************************************************************************
//
//  struct MMF_ARENA_HEADER
//
//  Root structure for MMF Arena.  This is recorded on the disk
//  image at the very beginning of the file.
//
//***************************************************************************

#pragma pack(4)                 // Require fixed aligment.

typedef struct
{
    // Version used to create file
    // vvvvvv MUST BE FIRST VALUE vvvvvvv
    DWORD  m_dwVersion;         // <<<<<< MUST BE FIRST VALUE!
    // ^^^^^^ MUST BE FIRST VALUE ^^^^^^^
    DWORD  m_dwGranularity;     // Granularity of allocation
    DWORD  m_dwCurrentSize;     // Current size of heap
    DWORD  m_dwMaxSize;         // Max heap size, -1= no limit
    DWORD  m_dwGrowBy;          // Bytes to grow by during out-of-heap

    DWORD_PTR  m_dwHeapExtent;      // First unused address
    DWORD_PTR  m_dwEndOfHeap;       // Last valid address + 1
    DWORD_PTR  m_dwFreeList;        // NULL if empty
    DWORD_PTR  m_dwRootBlock;       // Root block
    DWORD m_dwSizeOfFirstPage;  //Size of the first block

}   MMF_ARENA_HEADER;

typedef struct
{
    DWORD m_dwSize;         //Size of block.  Highest bit set when deleted.

}   MMF_BLOCK_HEADER;

typedef struct
{
    DWORD_PTR m_dwFLback;   //previous free block in the chain, NULL if not deleted
    DWORD m_dwCheckBlock[2];

}   MMF_BLOCK_TRAILER;

typedef struct
{
    DWORD_PTR m_dwFLnext;       //Next free block in the chain

}   MMF_BLOCK_DELETED;

typedef struct
{
    DWORD m_dwSize;             //Size of page

}   MMF_PAGE_HEADER;            //Page header... not there for first page.
#pragma pack()                  // Restore previous aligment.


//***************************************************************************
//
//  class CMMFArena2
//
//  Implements an offset-based heap over a memory-mapped file.
//
//***************************************************************************

class CMMFArena2
{
    DWORD  m_dwStatus;
    HANDLE m_hFile;
    MMF_ARENA_HEADER *m_pHeapDescriptor;
    DWORD m_dwCursor;
    DWORD m_dwMappingGranularity;
    DWORD m_dwMaxPageSize;
    CFlexArray m_OffsetManager;

    //Retrieves the size of the block from the header and removes the deleted bit
    DWORD GetSize(MMF_BLOCK_HEADER *pBlock) { return pBlock->m_dwSize & MMF_REMOVE_DELETED_MASK; }
    //Validates a pointer
    BOOL ValidateBlock(DWORD_PTR dwBlock)
#if (defined DEBUG || defined _DEBUG)
        ;
#pragma message("MMF heap validation enabled.")
#else
    { return TRUE;}
#endif

    MMFOffsetItem *OpenBasePage(DWORD &dwSizeOfRepository);

    MMFOffsetItem *OpenExistingPage(DWORD_PTR dwBaseOffset);

    void ClosePage(MMFOffsetItem *pOffsetItem);

    void CloseAllPages();

public:
    enum { create_new, use_existing };

    // Constructor.
    CMMFArena2();

    // Destructor.
    ~CMMFArena2();

    //Methods to open an MMF
    bool LoadMMF(const TCHAR *pszFile);
    DWORD Size(DWORD_PTR dwBlock);

    DWORD GetVersion() { return (m_pHeapDescriptor? m_pHeapDescriptor->m_dwVersion : 0); }
    DWORD GetStatus() { return m_dwStatus; }
    //Given an offset, returns a fixed up pointer
    LPBYTE OffsetToPtr(DWORD_PTR dwOffset);

    //Given a pointer, returns an offset from the start of the MMF
    DWORD_PTR  PtrToOffset(LPBYTE pBlock);
    MMF_ARENA_HEADER *GetMMFHeader() { return m_pHeapDescriptor; }
};

//***************************************************************************
//
//  Fixup helpers.
//
//  These are all strongly type variations of the same thing: they fix
//  up the based ptr to a dereferenceable pointer or take the ptr and
//  fix it back down to an offset.
//
//***************************************************************************
extern CMMFArena2* g_pDbArena;
template <class T> T Fixup(T ptr)
{ return T(g_pDbArena->OffsetToPtr(DWORD_PTR(ptr))); }
template <class T> T Fixdown(T ptr)
{ return T(g_pDbArena->PtrToOffset(LPBYTE(ptr))); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\import.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    Import.h

Abstract:

    Upgrade code

History:


--*/

#ifndef __wmi_import_h__
#define __wmi_import_h__

/*================================================================================
 *
 * EXPORT FILE FORMAT
 * ==================
 *
 * File Header Block:
 *		wchar_t wszFileHeader								= "repexp1"
 *
 * Namespace Block:
 *		DWORD   dwObjectType								= 0x00000001
 *		DWORD   dwNamespaceNameSize
 *		wchar_t wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *															  (\root\default\fred)
 *
 * Class Block:
 *		DWORD   dwObjectType								= 0x00000002
 *		DWORD   dwClassNameSize
 *		wchar_t wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		DWORD	adwClassObject[dwClassObjectSize]
 *
 * Instance Block - key of type int:
 *		DWORD   dwObjectType								= 0x00000003
 *		DWORD   dwInstanceKey
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= 0x00000004
 *		DWORD	dwInstanceKeySize
 *		DWORD	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *		
 * End of class block
 *		DWORD	dwObjectType								= 0x00000005
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of namespace block
 *		DWORD	dwObjectType								= 0x00000006
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of file block
 *		DWORD	dwObjectType								= 0xFFFFFFFF
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * Ordering:
 *		File Header Block
 *			(one or more)
 *			Namespace Block
 *				(zero or more)
 *				{
 *					Namespace Block
 *						etc...
 *					End namespace block
 *					(or)
 *					Class Block
 *						(zero or more)
 *						{
 *							Instance Block
 *							(or)
 *							Class Block
 *								etc...
 *							End class block
 *						}
 *					End class block
 *				}
 *			End namespace block
 *		End of file block
 *
 *================================================================================
 */

#include <wbemint.h>
#include <strutils.h>
#include "flexarry.h"
#include "winntsec.h"

#ifndef FULL_RIGHTS
#define FULL_RIGHTS WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                    WBEM_WRITE_PROVIDER | WRITE_DAC | READ_CONTROL | WBEM_ENABLE | WBEM_REMOTE_ACCESS
#endif

#define BLOB9X_FILENAME L"\\WBEM9xUpgd.dat"
#define BLOB9X_SIGNATURE "9xUpgrade"			//NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

#define BLOB9X_TYPE_SECURITY_BLOB		1
#define BLOB9X_TYPE_SECURITY_INSTANCE	2
#define BLOB9X_TYPE_END_OF_FILE			3

typedef struct _BLOB9X_HEADER
{
	char szSignature[10];
} BLOB9X_HEADER;

typedef struct _BLOB9X_SPACER
{
	DWORD dwSpacerType;
	DWORD dwNamespaceNameSize;
	DWORD dwParentClassNameSize;
	DWORD dwBlobSize;
} BLOB9X_SPACER;

class CRepImporter
{
private:
	HANDLE m_hFile;
	HANDLE m_h9xBlobFile;
	bool m_bSecurityMode;

	bool CheckOldSecurityClass(const wchar_t* wszClass);
	void DecodeTrailer();
	void DecodeInstanceInt(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass);
	void DecodeInstanceString(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass);
	void DecodeClass(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *wszParentClass, _IWmiObject *pOldParentClass, _IWmiObject *pNewParentClass);
	void DecodeNamespace(IWbemServices* pNamespace, const wchar_t *wszParentNamespace);
	void DecodeNamespaceSecurity(IWbemServices* pNamespace, IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwSize, const wchar_t* wszFullPath);
	void Decode();

	// helpers for DecodeNamespaceSecurity
	bool TransformBlobToSD(IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD);
	bool SetNamespaceSecurity(IWbemServices* pNamespace, CNtSecurityDescriptor& mmfNsSD);
	bool AddDefaultRootAces(CNtAcl * pacl);
	bool GetParentsInheritableAces(IWbemServices* pParentNamespace, CNtSecurityDescriptor &sd);
	bool StripOutInheritedAces(CNtSecurityDescriptor &sd);
	bool GetSDFromNamespace(IWbemServices* pNamespace, CNtSecurityDescriptor& sd);
	bool CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent);
	BOOL SetOwnerAndGroup(CNtSecurityDescriptor &sd);
	void ForceInherit();
	bool InheritSecurity(IWbemLocator* pLocator, IWbemServices* pRootNamespace, const wchar_t* wszNamespace);
	void ConnectNamespace(IWbemLocator* pLocator, const wchar_t* wszNamespaceName, IWbemServices** ppNamespace);
	bool CheckNetworkLocalService ( CNtSecurityDescriptor& sd ) ;

	// helpers for Win9x security processing
	bool AppendWin9xBlobFile(const wchar_t* wszFullPath, DWORD dwBlobSize, const char* pNsSecurity);
	bool AppendWin9xBlobFile(const wchar_t* wszFullPath, const wchar_t* wszParentClass, _IWmiObject* pInstance);
	bool CreateWin9xBlobFile();
	void DeleteWin9xBlobFile();
	bool GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
	bool CloseWin9xBlobFile();

public:
	CRepImporter() : m_hFile(INVALID_HANDLE_VALUE), m_h9xBlobFile(INVALID_HANDLE_VALUE), m_bSecurityMode(false){};

	int ImportRepository(const TCHAR *pszFromFile);

	enum { FAILURE_READ							= 1,
		   FAILURE_INVALID_FILE					= 2,
		   FAILURE_INVALID_TYPE					= 3,
		   FAILURE_INVALID_TRAILER				= 4,
		   FAILURE_CANNOT_FIND_NAMESPACE		= 5,
		   FAILURE_CANNOT_GET_PARENT_CLASS		= 6,
		   FAILURE_CANNOT_CREATE_INSTANCE		= 7,
		   FAILURE_CANNOT_ADD_NAMESPACE			= 8,
		   FAILURE_CANNOT_ADD_NAMESPACE_SECURITY= 9,
		   FAILURE_OUT_OF_MEMORY				= 10,
		   FAILURE_CANNOT_CREATE_IWBEMLOCATOR	= 11,
		   FAILURE_CANNOT_CONNECT_SERVER		= 12,
		   FAILURE_CANNOT_MERGE_INSTANCE		= 13,
		   FAILURE_CANNOT_UPGRADE_INSTANCE		= 14,
		   FAILURE_CANNOT_MERGE_CLASS			= 15,
		   FAILURE_CANNOT_UPGRADE_CLASS			= 16,
		   FAILURE_CANNOT_CREATE_CLASS			= 17,
		   FAILURE_CANNOT_CREATE_OBJECTFACTORY	= 18,
		   FAILURE_CANNOT_CREATE_IWMIOBJECT		= 19
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\main.cpp ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    DllRegServer implementation, and other important DLL entry points

History:


--*/

#include "precomp.h"
#include <wbemint.h>
#include <cominit.h>
#include "upgrade.h"
#include <str.h>

char g_szLangId[LANG_ID_STR_SIZE];

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during NT setup to perform various setup tasks
//          (This is not the normal use of DllRegisterServer!)
//
// Return:  NOERROR
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
	LogMessage(MSG_INFO, "================================================================================");
	LogMessage(MSG_INFO, "Beginning Wbemupgd.dll Registration");

	bool t_Upgrade = false ;
	HRESULT t_Result = CheckForServiceSecurity () ;
	if ( t_Result == S_FALSE )
	{
		t_Upgrade = true ;
	}

	RecordFileVersion();

	InitializeCom();

	CallEscapeRouteBeforeMofCompilation();
	DoCoreUpgrade(Core);
	CallEscapeRouteAfterMofCompilation();

	if ( t_Upgrade )
	{
		HRESULT t_Result = UpdateServiceSecurity () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			LogMessage(MSG_INFO, "Wbemupgd.dll Service Security upgrade succeeded.");
		}
		else
		{
			LogMessage(MSG_ERROR, "Wbemupgd.dll Service Security upgrade failed.");
		}
	}
	else
	{
		LogMessage(MSG_INFO, "Wbemupgd.dll Service Security upgrade not required.");
	}

	DoWDMNamespaceInit();

	SetWBEMBuildRegValue();

	EnableESS();

#ifdef _X86_
	RemoveOldODBC();
#endif

	CoUninitialize();

	ClearWMISetupRegValue();

	LogMessage(MSG_INFO, "Wbemupgd.dll Registration completed.");
	LogMessage(MSG_INFO, "================================================================================");

    return NOERROR;
}

//***************************************************************************
//
// MUI_InstallMFLFiles
//
// Purpose: Do the MUI MFL install
//
// Return:  bRet -- true indicates success
//***************************************************************************

BOOL CALLBACK MUI_InstallMFLFiles(wchar_t* pMUIInstallLanguage)
{
	LogMessage(MSG_INFO, "================================================================================");
	if (!pMUIInstallLanguage || !wcslen(pMUIInstallLanguage) || (wcslen(pMUIInstallLanguage) > MAX_MSG_TEXT_LENGTH))
	{
		LogMessage(MSG_ERROR, "MUI installation failed because no language code was passed.");
		LogMessage(MSG_INFO, "================================================================================");
		return FALSE;
	}

	char szTemp[MAX_MSG_TEXT_LENGTH];
	StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Beginning MUI installation for language %S.", pMUIInstallLanguage);
	LogMessage(MSG_INFO, szTemp);

	wcstombs(g_szLangId, pMUIInstallLanguage, LANG_ID_STR_SIZE);

	InitializeCom();

	CMultiString mszSystemMofs;
	GetStandardMofs(mszSystemMofs, MUI);
	
	bool bRet = DoMofLoad(L"MUI", mszSystemMofs);

	CoUninitialize();

	LogMessage(MSG_INFO, "MUI installation completed.");
	LogMessage(MSG_INFO, "================================================================================");

	return bRet;
}

//***************************************************************************
//
// LoadMofFiles
//
// Purpose: Call IMofCompiler on a list of MOF files
//
// Return:  bRet -- true indicates success
//***************************************************************************

BOOL LoadMofFiles(wchar_t* pComponentName, const char* rgpszMofFilename[])
{
    if (!pComponentName || !wcslen(pComponentName))
    {
        LogMessage(MSG_ERROR, "Component MOF load failed because no component name was passed.");
        return FALSE;
    }
    
    char szTemp[MAX_MSG_TEXT_LENGTH];
    StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Beginning %S MOF Installation", pComponentName);
    LogMessage(MSG_INFO, szTemp);
    
    if (!rgpszMofFilename)
    {
        LogMessage(MSG_ERROR, "Component MOF load failed because no file list was passed.");
        return FALSE;
    }
    
    InitializeCom();
    
    CMultiString mszMofs;
    GetMofList(rgpszMofFilename, mszMofs);
    
    bool bRet = DoMofLoad(pComponentName, mszMofs);
        
    CoUninitialize();
    
    StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "%S MOF Installation Completed", pComponentName);
    LogMessage(MSG_INFO, szTemp);
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\ocgen.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _OCGEN_H_
 #error "ocgen.h already included!"
#else
 #define _OCGEN_H_
#endif

#define UNICODE
#define _UNICODE

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

//#ifndef _RESOURCE_H_
// #include "resource.h"
//#endif

/*-[ types and defines ]-----------------------------------*/

#define IDS_DIALOG_CAPTION  1

// unicode version is for NT only.

#ifdef UNICODE
 #define NT
#endif
#ifdef ANSI
 #define WIN95
#endif

// just my preference

#define true    TRUE
#define false   FALSE

// to help root out hard coded strings that don't belong

#define FMT     TEXT

#define NullString(a)   *(a) = TCHAR('\0')

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA *Next;
    LPCTSTR ComponentId;
    HINF hinf;
    DWORDLONG Flags;
    LANGID LanguageId;
    TCHAR *SourcePath;
    OCMANAGER_ROUTINES HelperRoutines;
    EXTRA_ROUTINES ExtraRoutines;
    HSPFILEQ queue;
    LONG UnattendedOverride;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif

// from util.cpp

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... );
DWORD MsgBox(HWND hwnd, LPCTSTR fmt, LPCTSTR caption, UINT type, ... );
DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... );
DWORD TMBox(LPCTSTR fmt, ... );
#define mbox MBox
#define tmbox TMBox
void logOCNotification(DWORD msg, const TCHAR *component);
void logOCNotificationCompletion();
void loginit();
void log(TCHAR *fmt, ...);
void AssureTrailingBackslash(TCHAR *path);
BOOL IsNT();

#if defined(__cplusplus)
  extern "C" {
#endif

// from ocgen.cpp

BOOL  ToBeInstalled(TCHAR *component);
BOOL  WasInstalled(TCHAR *component);
DWORD SetupCurrentUser();
DWORD GetMyVersion(DWORD *major, DWORD *minor);
VOID  ReplaceExplorerStartMenuBitmap(VOID);
DWORD OcLog(LPCTSTR ComponentId, UINT level, LPCTSTR sz);

DWORD SysGetDebugLevel();

// from util.cpp

void DebugTraceNL(DWORD level, const TCHAR *text);
void DebugTrace(DWORD level, const TCHAR *text);
void DebugTraceOCNotification(DWORD msg, const TCHAR *component);
void DebugTraceFileCopy(const TCHAR *file);
void DebugTraceFileCopyError();
void DebugTraceDirCopy(const TCHAR *dir);

#if defined(__cplusplus)
  }
#endif

/*-[ global data ]-----------------------------------------*/

#ifndef _OCGEN_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle

// per-component info storage

EXTERN PPER_COMPONENT_DATA gcd;     // array of all components we are installing
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\mmfarena2.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    mmfarena2.cpp

Abstract:

    CMMFArena2 implementation (arenas based on memory-mapped files).
    Used for database upgrade

History:

--*/

#include "precomp.h"
#include <stdio.h>
#define DEPRECATE_SUPPORTED
#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>
#include "wbemutil.h"
#include "mmfarena2.h"

extern CMMFArena2 *  g_pDbArena;

#define MAX_PAGE_SIZE_WIN9X     0x200000    /*2MB*/
#define MAX_PAGE_SIZE_NT        0x3200000   /*50MB*/

struct MMFOffsetItem
{
    DWORD_PTR m_dwBaseOffset;
    LPBYTE    m_pBasePointer;
    HANDLE    m_hMappingHandle;
    DWORD     m_dwBlockSize;
};

#if (defined DEBUG || defined _DEBUG)
void MMFDebugBreak()
{
    DebugBreak();
}
#else
inline void MMFDebugBreak() {}
#endif

//***************************************************************************
//
//  CMMFArena2::CMMFArena2
//
//  Constructor.  Initialises a few things.
//
//***************************************************************************
CMMFArena2::CMMFArena2()
: m_dwStatus(0), m_hFile(INVALID_HANDLE_VALUE)
{
    g_pDbArena = this;

    //Get processor granularity
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    m_dwMappingGranularity = sysInfo.dwAllocationGranularity;
    m_dwMaxPageSize = MAX_PAGE_SIZE_NT;
}

//***************************************************************************
//
//  CMMFArena2::LoadMMF
//
//  Loads an existing MMF.  Loads in the base page and all pages following
//  that
//
//  pszFile         : Filename of the MMF to open
//
//  Return value    : false if we failed, true if we succeed.
//
//***************************************************************************
bool CMMFArena2::LoadMMF(const TCHAR *pszFile)
{
    //Open the file...
    m_hFile = CreateFile(
         pszFile,
         GENERIC_READ ,
         0,
         0,
         OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
         0
         );

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        _ASSERT(0, "WinMgmt: Failed to open existing repository file");
        m_dwStatus = 7;
        return false;
    }
    DWORD dwSizeOfRepository = 0;
    MMFOffsetItem *pOffsetItem = 0;

    //Open the base page...
    pOffsetItem = OpenBasePage(dwSizeOfRepository);
    if (pOffsetItem == 0)
    {
        _ASSERT(0, "WinMgmt: Failed to open base page in MMF");
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        return false;
    }

    //Add the details to the offset manager...
    int nStatus = -1;
    nStatus = m_OffsetManager.Add(pOffsetItem);
    if (nStatus)
    {
        _ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
        ClosePage(pOffsetItem);
        delete pOffsetItem;

        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }

    DWORD_PTR dwPageBase = 0;

    if (m_pHeapDescriptor->m_dwVersion == 9)
    {
        //Now loop through all the following pages and load them...
        DWORD dwSizeLastPage = 0;
        nStatus = -1;
        for (dwPageBase = pOffsetItem->m_dwBlockSize; dwPageBase < dwSizeOfRepository; dwPageBase += dwSizeLastPage)
        {
            //Open the next...
            pOffsetItem = OpenExistingPage(dwPageBase);
            if (pOffsetItem == 0)
            {
                _ASSERT(0, "WinMgmt: Failed to open an existing page in the MMF");
                //Failed to do that!
                CloseAllPages();
                CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;
                m_dwStatus = 7;
                return false;
            }
            //Add the information to the offset manager...
            nStatus = -1;
            nStatus = m_OffsetManager.Add(pOffsetItem);
            if (nStatus)
            {
                _ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
                //Failed to do that!
                ClosePage(pOffsetItem);
                delete pOffsetItem;
                CloseAllPages();
                CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;
                m_dwStatus = 7;
                throw CX_MemoryException();
            }
            dwSizeLastPage = pOffsetItem->m_dwBlockSize;
        }
    }
    else if ((m_pHeapDescriptor->m_dwVersion == 10) || (m_pHeapDescriptor->m_dwVersion < 9))
    {
        dwPageBase = pOffsetItem->m_dwBlockSize;
    }
    else
    {
        _ASSERT(0, "WinMgmt: Database error... Code has not been added to support the opening of this database!!!!!");
        ERRORTRACE((LOG_WBEMCORE, "Database error... Code has not been added to support the opening of this database!!!!!\n"));
    }

    //Create a mapping entry to mark the end of the MMF
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
    {
        _ASSERT(0, "WinMgmt: Out of memory");
        //Failed to do that!
        CloseAllPages();
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }
    pOffsetItem->m_dwBaseOffset = dwPageBase;
    pOffsetItem->m_dwBlockSize = 0;
    pOffsetItem->m_hMappingHandle = 0;
    pOffsetItem->m_pBasePointer = 0;
    nStatus = -1;
    nStatus = m_OffsetManager.Add(pOffsetItem);
    if (nStatus)
    {
        _ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
        //Failed to do that!
        ClosePage(pOffsetItem);
        delete pOffsetItem;
        CloseAllPages();
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }

    return true;
};

//***************************************************************************
//
//  CMMFArena2::OpenBasePage
//
//  Opens the MMF first page which has all the information about the rest
//  of the MMF as well as the first page of data.
//
//  dwSizeOfRepository  : Returns the current size of the repository
//
//  Return value    : Pointer to an offset item filled in with the base
//                    page information.  NULL if we fail to open the
//                    base page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::OpenBasePage(DWORD &dwSizeOfRepository)
{
    MMFOffsetItem *pOffsetItem = 0;
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
        throw CX_MemoryException();

    //Seek to the start of this page...
    if (SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        _ASSERT(0, "WinMgmt: Failed to set file pointer on MMF");
        delete pOffsetItem;
        return 0;
    }

    //Read in the hear information so we can find the size of this block...
    DWORD dwActualRead;
    MMF_ARENA_HEADER mmfHeader;
    if ((ReadFile(m_hFile, &mmfHeader, sizeof(MMF_ARENA_HEADER), &dwActualRead, 0) == 0) || (dwActualRead != sizeof(MMF_ARENA_HEADER)))
    {
        _ASSERT(0, "WinMgmt: Failed to read MMF header information");
        delete pOffsetItem;
        return 0;
    }

    //Record the current size information...
    dwSizeOfRepository = mmfHeader.m_dwCurrentSize;

    DWORD dwSizeToMap = 0;

    if ((mmfHeader.m_dwVersion < 9) || (mmfHeader.m_dwVersion == 10))
    {
        //old style database, we map in everything...
        dwSizeToMap = mmfHeader.m_dwCurrentSize;
    }
    else if (mmfHeader.m_dwVersion == 9)
    {
        //We get the first page...
        dwSizeToMap = mmfHeader.m_dwSizeOfFirstPage;
    }
    else
    {
        _ASSERT(0, "WinMgmt: Database error... Code has not been added to support the opening of this database!!!!!");
        ERRORTRACE((LOG_WBEMCORE, "Database error... Code has not been added to support the opening of this database!!!!!\n"));
    }

    //Create the file mapping for this page...
    HANDLE hMapping = CreateFileMapping(
        m_hFile,                            // Disk file
        0,                                  // No security
        PAGE_READONLY | SEC_COMMIT,      // Extend the file to match the heap size
        0,                                  // High-order max size
        dwSizeToMap,        // Low-order max size
        0                                   // No name for the mapping object
        );

    if (hMapping == NULL)
    {
        _ASSERT(0, "WinMgmt: Failed to create file mapping");
        delete pOffsetItem;
        return 0;
    }

    // Map this into memory...
    LPBYTE pBindingAddress = (LPBYTE)MapViewOfFile(hMapping,
                                                FILE_MAP_READ,
                                                 0,
                                                 0,
                                                 dwSizeToMap
                                                 );

    if (pBindingAddress == NULL)
    {
        _ASSERT(0, "WinMgmt: Failed to map MMF into memory");
        delete pOffsetItem;
        CloseHandle(hMapping);
        return 0;
    }

    //Record the base address of this because we need easy access to the header...
    m_pHeapDescriptor = (MMF_ARENA_HEADER*) pBindingAddress;

    //Create a mapping entry for this...
    pOffsetItem->m_dwBaseOffset = 0;
    pOffsetItem->m_dwBlockSize = dwSizeToMap;
    pOffsetItem->m_hMappingHandle = hMapping;
    pOffsetItem->m_pBasePointer = pBindingAddress;

    return pOffsetItem;
}

//***************************************************************************
//
//  CMMFArena2::OpenExistingPage
//
//  Opens the specified page from the repostory.
//
//  dwBaseOffset    : Offset within the MMF to map in.
//
//  Return value    : Pointer to an offset item filled in with the
//                    page information.  NULL if we fail to open the
//                    page.
//
//***************************************************************************

MMFOffsetItem *CMMFArena2::OpenExistingPage(DWORD_PTR dwBaseOffset)
{
    MMFOffsetItem *pOffsetItem = 0;
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
        throw CX_MemoryException();

    //Set the file pointer to the start of this page...
    if (SetFilePointer(m_hFile, (LONG)dwBaseOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        //We are in trouble!
        _ASSERT(0, "WinMgmt: Failed to determine the size of the next block to load");
		delete pOffsetItem;
        return 0;
    }

    //Read in the page information so we can find out how big the page is...
    DWORD dwActualRead = 0;
    MMF_PAGE_HEADER pageHeader;
    if ((ReadFile(m_hFile, &pageHeader, sizeof(MMF_PAGE_HEADER), &dwActualRead, 0) == 0) || (dwActualRead != sizeof(MMF_PAGE_HEADER)))
    {
        _ASSERT(0, "WinMgmt: Failed to read the next page block size");
		delete pOffsetItem;
        return 0;
    }

    //Create the file mapping...
    HANDLE hMapping;
    hMapping = CreateFileMapping(m_hFile,
                                 0,
                                 PAGE_READONLY| SEC_COMMIT,
                                 0,
                                 (LONG)dwBaseOffset + pageHeader.m_dwSize,
                                 0);

    if (hMapping == 0)
    {
        _ASSERT(0, "WinMgmt: Failed to map in part of the memory mapped file!");
		delete pOffsetItem;
        return 0;
    }

    //Map this into memory...
    LPBYTE pBindingAddress;
    pBindingAddress= (LPBYTE)MapViewOfFile(hMapping,
                                            FILE_MAP_READ,
                                            0,
                                            (LONG)dwBaseOffset,
                                            pageHeader.m_dwSize);
    if (pBindingAddress == 0)
    {
        _ASSERT(0, "WinMgmt: Failed to bind part of the memory mapped file into memory!");
		delete pOffsetItem;
		CloseHandle(hMapping);
        return 0;
    }

    //Record the information...
    pOffsetItem->m_dwBaseOffset = dwBaseOffset;
    pOffsetItem->m_dwBlockSize = pageHeader.m_dwSize;
    pOffsetItem->m_hMappingHandle = hMapping;
    pOffsetItem->m_pBasePointer = pBindingAddress;

    return pOffsetItem;
}

//***************************************************************************
//
//  CMMFArena2::ClosePage
//
//  Closes the page specified
//
//  pOffsetItem : Information about the page to close.
//
//  Return value    : None
//
//***************************************************************************

void CMMFArena2::ClosePage(MMFOffsetItem *pOffsetItem)
{
    if (pOffsetItem->m_hMappingHandle)
    {
        UnmapViewOfFile(pOffsetItem->m_pBasePointer);
        CloseHandle(pOffsetItem->m_hMappingHandle);
    }
}

//***************************************************************************
//
//  CMMFArena2::CloseAllPages
//
//  Closes all pages in the offset manager, deleting the pointers of the
//  objects in there.
//
//  Return value    : None
//
//***************************************************************************

void CMMFArena2::CloseAllPages()
{
    //Close each of the file mappings...
    for (int i = 0; i != m_OffsetManager.Size(); i++)
    {
        MMFOffsetItem *pItem = (MMFOffsetItem*)m_OffsetManager[i];
        ClosePage(pItem);
        delete pItem;
    }
    m_OffsetManager.Empty();
}

//***************************************************************************
//
//  CMMFArena2::~CMMFArena2
//
//  Destructor flushes the heap, unmaps the view and closes handles.
//
//***************************************************************************

CMMFArena2::~CMMFArena2()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        //Close each of the file mappings...
        CloseAllPages();
        //Close the file handle
        CloseHandle(m_hFile);
    }
}


//***************************************************************************
//
//  CMMFArena2::ValidateBlock
//
//  Validates the memory block as much as possible and calls a debug break
//  point if an error is detected.  Does this by analysing the size and
//  the trailer DWORDs
//
//  Parameters:
//      <dwBlock>               Offset of block to check
//
//  Return value:
//  TRUE if success.
//
//***************************************************************************
#if (defined DEBUG || defined _DEBUG)
BOOL CMMFArena2::ValidateBlock(DWORD_PTR dwBlock)
{
    try
    {
        MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
        MMF_BLOCK_TRAILER *pTrailer = GetTrailerBlock(pHeader);
        if (sizeof(pTrailer->m_dwCheckBlock))
        {
            DWORD dwCheckBit;

            //Is it deleted?
            if (pHeader->m_dwSize & MMF_DELETED_MASK)
            {
                //Yes it is, so the we check for 0xFFFF
                dwCheckBit = MMF_DEBUG_DELETED_TAG;
            }
            else
            {
                dwCheckBit = MMF_DEBUG_INUSE_TAG;
            }

            for (DWORD dwIndex = 0; dwIndex != (sizeof(pTrailer->m_dwCheckBlock) / sizeof(DWORD)); dwIndex++)
            {
                if (pTrailer->m_dwCheckBlock[dwIndex] != dwCheckBit)
                {
#ifdef DBG
                    wchar_t string[200];
                    StringCchPrintfW(string, 200, L"WinMgmt: MMF Arena heap corruption,offset = 0x%p\n", dwBlock);
                    OutputDebugString(string);
                    _ASSERT(0, string);
#endif
                    MMFDebugBreak();
                    return FALSE;
                }
            }
        }
        if (!(pHeader->m_dwSize & MMF_DELETED_MASK))
        {
            //We are not deleted, so we should have a trailer back pointer of NULL
            if (pTrailer->m_dwFLback != 0)
            {
#ifdef DBG
                wchar_t string[200];
                StringCchPrintfW(string, 200, L"WinMgmt: MMF Arena heap corruption, offset = 0x%p\n", dwBlock);
                OutputDebugString(string);
                _ASSERT(0, string);
#endif
                MMFDebugBreak();
                return FALSE;
            }

        }
    }
    catch (...)
    {
#ifdef DBG
        wchar_t string[200];
        StringCchPrintfW(string, 200, L"WinMgmt: MMF Arena heap corruption, offset = 0x%p\n", dwBlock);
        OutputDebugString(string);
        _ASSERT(0, string);
#endif
        MMFDebugBreak();
        return FALSE;
    }

    return TRUE;
}
#endif

//Some debugging functions...

//***************************************************************************
//
//  CMMFArena::GetHeapInfo
//
//  Gets detailed summary info about the heap.  Completely walks the
//  heap to do this.
//
//  Parameters:
//      <pdwTotalSize>          Receives the heap size.
//      <pdwActiveBlocks>       Receives the number of allocated blocks.
//      <pdwActiveBytes>        Receives the total allocated bytes.
//      <pdwFreeBlocks>         Receives the number of 'free' blocks.
//      <pdwFreeByte>           Receives the number of 'free' bytes.
//
//***************************************************************************
DWORD CMMFArena2::Size(DWORD_PTR dwBlock)
{
    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    //Set the address to point to the actual start of the block
    dwBlock -= sizeof(MMF_BLOCK_HEADER);

    //Check the block is valid...
    ValidateBlock(dwBlock);

    MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwBlock);

	if (pBlockHeader)
		return GetSize(pBlockHeader);
	else
		return 0;
}

//Given an offset, returns a fixed up pointer
LPBYTE CMMFArena2::OffsetToPtr(DWORD_PTR dwOffset)
{
    if (dwOffset == 0)
        return 0;

    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    try
    {
        LPBYTE pBlock = 0;
        int l = 0, u = m_OffsetManager.Size() - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (dwOffset < ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset)
            {
                u = m - 1;
            }
            else if (dwOffset >= ((MMFOffsetItem *)m_OffsetManager[m+1])->m_dwBaseOffset)
            {
                l = m + 1;
            }
            else
            {
                return ((MMFOffsetItem *)m_OffsetManager[m])->m_pBasePointer + (dwOffset - ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset);
            }
        }
    }
    catch (...)
    {
    }
#ifdef DBG    
    wchar_t string[220];
    StringCchPrintfW(string, 220, L"WinMgmt: Could not find the block requested in the repository, offset requested = 0x%p, end of repository = 0x%p\n", dwOffset, ((MMFOffsetItem *)m_OffsetManager[m_OffsetManager.Size()-1])->m_dwBaseOffset);
    OutputDebugStringW(string);
    _ASSERT(0, string);
#endif    
    MMFDebugBreak();
    return 0;
}

//Given a pointer, returns an offset from the start of the MMF
DWORD_PTR  CMMFArena2::PtrToOffset(LPBYTE pBlock)
{
    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    for (int i = 0; i < m_OffsetManager.Size(); i++)
    {
        register MMFOffsetItem *pItem = (MMFOffsetItem *)m_OffsetManager[i];
        if ((pBlock >= pItem->m_pBasePointer) &&
            (pBlock < (pItem->m_pBasePointer + pItem->m_dwBlockSize)))
        {
            return pItem->m_dwBaseOffset + (pBlock - pItem->m_pBasePointer);
        }
    }
#ifdef DBG    
    wchar_t string[220];
    StringCchPrintfW(string, 220, L"WinMgmt: Could not find the offset requested in the repository, pointer requested = 0x%p\n", pBlock);
    OutputDebugStringW(string);
    _ASSERT(0, string);
#endif    
    MMFDebugBreak();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\ocgen.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#define _OCGEN_CPP_
#define UNICODE
#define _UNICODE

#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <objbase.h>
#include <shlwapi.h>
#include <lm.h>
#include "ocgen.h"
#include <strsafe.h>
#pragma hdrstop

// also referred to in ocgen.h        // forward reference

DWORD OnPreinitialize();
DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc);
DWORD OnSetLanguage();
DWORD_PTR OnQueryImage();
DWORD OnSetupRequestPages(UINT type, PVOID srp);
DWORD OnQuerySelStateChange(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state, UINT flags);
DWORD OnCalcDiskSpace(LPCTSTR ComponentId, LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnNotificationFromQueue();
DWORD OnQueryStepCount();
DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnCleanup();
DWORD OnQueryState(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state);
DWORD OnNeedMedia();
DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnQuerySkipPage();
DWORD OnWizardCreated();
DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per);

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId);
PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId);
VOID  RemoveComponent(LPCTSTR ComponentId);
BOOL  StateInfo(PPER_COMPONENT_DATA cd, LPCTSTR SubcomponentId, BOOL *state);
DWORD RegisterServers(HINF hinf, LPCTSTR component, DWORD state);
DWORD EnumSections(HINF hinf, const TCHAR *component, const TCHAR *key, DWORD index, INFCONTEXT *pic, TCHAR *name);
DWORD RegisterServices(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD CleanupNetShares(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD RunExternalProgram(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);

// for determining prior install status of WMI components
bool IsMSIProviderPresent();


// for registering dlls

typedef HRESULT (__stdcall *pfn)(void);

#define KEYWORD_REGSVR       TEXT("RegSvr")
#define KEYWORD_UNREGSVR     TEXT("UnregSvr")
#define KEYWORD_UNINSTALL    TEXT("Uninstall")
#define KEYWORD_SOURCEPATH   TEXT("SourcePath")
#define KEYWORD_DELSHARE     TEXT("DelShare")
#define KEYWORD_ADDSERVICE   TEXT("AddService")
#define KEYWORD_DELSERVICE   TEXT("DelService")
#define KEYWORD_SHARENAME    TEXT("Share")
#define KEYWORD_RUN          TEXT("Run")
#define KEYVAL_SYSTEMSRC     TEXT("SystemSrc")
#define KEYWORD_COMMANDLINE  TEXT("CommandLine")
#define KEYWORD_TICKCOUNT    TEXT("TickCount")

// Services keywords/options
#define KEYWORD_SERVICENAME  TEXT("ServiceName")
#define KEYWORD_DISPLAYNAME  TEXT("DisplayName")
#define KEYWORD_SERVICETYPE  TEXT("ServiceType")
#define KEYWORD_STARTTYPE    TEXT("StartType")
#define KEYWORD_ERRORCONTROL TEXT("ErrorControl")
#define KEYWORD_IMAGEPATH    TEXT("BinaryPathName")
#define KEYWORD_LOADORDER    TEXT("LoadOrderGroup")
#define KEYWORD_DEPENDENCIES TEXT("Dependencies")
#define KEYWORD_STARTNAME    TEXT("ServiceStartName")
#define KEYWORD_PASSWORD     TEXT("Password")

#define KEYVAL_ON            TEXT("on")
#define KEYVAL_OFF           TEXT("off")
#define KEYVAL_DEFAULT       TEXT("default")

const char gszRegisterSvrRoutine[]   = "DllRegisterServer";
const char gszUnregisterSvrRoutine[] = "DllUnregisterServer";
BOOL g_fRebootNeed = FALSE;

PPER_COMPONENT_DATA _cd;

void av()
{
    _cd = NULL;
    _cd->hinf = NULL;
}


/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

/*
Not needed now as Wbemupgd.dll already has a DllMain.


BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{
    BOOL b;

    UNREFERENCED_PARAMETER(reserved);

    b = true;

    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        ghinst = hinstance;
        loginit();

        // Fall through to process first thread

    case DLL_THREAD_ATTACH:
        b = true;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return(b);
}
*/

DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR rc;

    DebugTraceOCNotification(Function, ComponentId);
    logOCNotification(Function, ComponentId);

    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OnPreinitialize();
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_SET_LANGUAGE:
        rc = OnSetLanguage();
        break;

    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;

    case OC_REQUEST_PAGES:
        rc = OnSetupRequestPages(Param1, Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(ComponentId, SubcomponentId, (HSPFILEQ)Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        rc = OnNotificationFromQueue();
        break;

    case OC_QUERY_STEP_COUNT:
        rc = OnQueryStepCount();
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_CLEANUP:
        rc = OnCleanup();
        break;

    case OC_QUERY_STATE:
    rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    case OC_NEED_MEDIA:
        rc = OnNeedMedia();
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(ComponentId,SubcomponentId);
        break;

    case OC_QUERY_SKIP_PAGE:
        rc = OnQuerySkipPage();
        break;

    case OC_WIZARD_CREATED:
        rc = OnWizardCreated();
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    DebugTrace(1, TEXT("processing completed"));
    logOCNotificationCompletion();

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/


/* OnPreinitialize()
 *
 * handler for OC_PREINITIALIZE
 */

DWORD
OnPreinitialize(
    VOID
    )
{
#ifdef ANSI
    return OCFLAG_ANSI;
#else
    return OCFLAG_UNICODE;
#endif
}

/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT context;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

 // assert(0);
 // av();

    // add component to linked list

    if (!(cd = AddNewComponent(ComponentId)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // store component inf handle

    cd->hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                                           ? NULL
                                           : psc->ComponentInfHandle;

    // open the inf

    if (cd->hinf)
        SetupOpenAppendInfFile(NULL, cd->hinf,NULL);

    // copy helper routines and flags

    cd->HelperRoutines = psc->HelperRoutines;

    cd->Flags = psc->SetupData.OperationFlags;

    cd->SourcePath = NULL;

#if 0
    // Setup the SourcePath.  Read inf and see if we should use the NT setup source.
    // If so, set to null and setupapi will take care of this for us.  If there is
    // something specified in the inf, use it, otherwise use what is passed to us.

    *buf = 0;
    rc = SetupFindFirstLine(cd->hinf,
                            ComponentId,
                            KEYWORD_SOURCEPATH,
                            &context);

    if (rc) {

        rc = SetupGetStringField(&context,
                                 1,
                                 buf,
                                 sizeof(buf) / sizeof(TCHAR),
                                 NULL);

    }

    if (!_tcsicmp(buf, KEYVAL_SYSTEMSRC)) {

        cd->SourcePath = NULL;

    } else {

        cd->SourcePath = (TCHAR *)LocalAlloc(LMEM_FIXED, SBUF_SIZE);
        if (!cd->SourcePath)
            return ERROR_CANCELLED;

        if (!*buf)
            _tcscpy(cd->SourcePath, psc->SetupData.SourcePath);
        else
            ExpandEnvironmentStrings(buf, cd->SourcePath, S_SIZE);
    }

#endif

    // play

    srand(GetTickCount());

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per)
{
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    memcpy(&cd->ExtraRoutines, per, per->size);

    return NO_ERROR;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD OnSetLanguage()
{
    return false;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD_PTR OnQueryImage()
{
    return (DWORD_PTR)LoadBitmap(NULL,MAKEINTRESOURCE(32754));     // OBM_CLOSE
}

/*
 * OnSetupRequestPages
 *
 * Prepares wizard pages and returns them to the OC Manager
 */

DWORD OnSetupRequestPages(UINT type, PVOID srp)
{
    return 0;
}

/*
 * OnWizardCreated()
 */

DWORD OnWizardCreated()
{
    return NO_ERROR;
}

/*
 * OnQuerySkipPage()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySkipPage()
{
    return false;
}

/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySelStateChange(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags)
{
    DWORD rc = true;

#if 0
//  if (!(flags & OCQ_ACTUAL_SELECTION)) {
        if (!_tcsicmp(SubcomponentId, TEXT("three"))) {
            if (!state) {
                return false;
            }
        }
        if (!_tcsicmp(ComponentId, TEXT("three"))) {
            if (!state) {
                return false;
            }
        }
        if (!_tcsicmp(SubcomponentId, TEXT("gs7"))) {
            if (state) {
                return false;
            }
        }
        if (!_tcsicmp(ComponentId, TEXT("gs7"))) {
            if (state) {
                return false;
            }
        }
//  }
#endif

    if (!rc && (flags & OCQ_ACTUAL_SELECTION))
        MessageBeep(MB_ICONEXCLAMATION);

    return rc;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD OnCalcDiskSpace(LPCTSTR ComponentId,
                      LPCTSTR SubcomponentId,
                      DWORD addComponent,
                      HDSKSPC dspace)
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];
    PPER_COMPONENT_DATA cd;

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    StringCchCopy(section, S_SIZE, SubcomponentId);

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   cd->hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        cd->hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnQueueFileOps()
 *
 * handler for OC_QUEUE_FILE_OPS
 */

DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    cd->queue = queue;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    StringCchPrintf(section, 256, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }

        // also, unregister the dlls and kill services before deletion

        SetupInstallServicesFromInfSection(cd->hinf, section, 0);
        SetupInstallFromInfSection(NULL,cd->hinf,section,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL);        
    }

    if (rc) {
        // if uninstalling, don't use version checks
        rc = SetupInstallFilesFromInfSection(cd->hinf,
                                             NULL,
                                             queue,
                                             section,
                                             cd->SourcePath,
                                             state ? SP_COPY_NEWER : 0);
    }

    if (!rc)
        return GetLastError();

    return NO_ERROR;
}

/*
 * OnNotificationFromQueue()
 *
 * handler for OC_NOTIFICATION_FROM_QUEUE
 *
 * NOTE: although this notification is defined,
 * it is currently unimplemented in oc manager
 */

DWORD OnNotificationFromQueue()
{
    return NO_ERROR;
}

/*
 * OnQueryStepCount
 *
 * handler forOC_QUERY_STEP_COUNT
 */

DWORD OnQueryStepCount()
{
    return 2;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT          context;
    TCHAR               section[256];
    BOOL                state;
    BOOL                rc;
    DWORD               Error = NO_ERROR;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    StringCchPrintf(section, 256, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }
    }

    if (state) { 
        //
        // installation
        //

        if (rc) {
            // process the inf file
            rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                            cd->hinf,                            // inf handle
                                            section,                             // name of component
                                            SPINST_ALL & ~SPINST_FILES,
                                            NULL,                                // relative key root
                                            NULL,                                // source root path
                                            0,                                   // copy flags
                                            NULL,                                // callback routine
                                            NULL,                                // callback routine context
                                            NULL,                                // device info set
                                            NULL);                               // device info struct
    
            if (rc) {
                rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);
                Error = GetLastError();        
            
                if (!rc && Error == ERROR_SECTION_NOT_FOUND) {
                    rc = TRUE;
                    Error = NO_ERROR;
                }
            
                if (rc) {
                    if (Error == ERROR_SUCCESS_REBOOT_REQUIRED) {
                        cd->HelperRoutines.SetReboot(cd->HelperRoutines.OcManagerContext,TRUE);
                    }
                    Error = NO_ERROR;
                    rc = RunExternalProgram(cd, section, state);            
                }
            }
        }

    } else { 
        
        //
        // uninstallation
        //
    
        if (rc)
        {

            rc = RunExternalProgram(cd, section, state);

        }
        if (rc) {
            
            rc = CleanupNetShares(cd, section, state);

        }
    }

    if (!rc && (Error == NO_ERROR) ) {
        Error = GetLastError( );
    }

    return Error;
}

/*
 * OnCleanup()
 *
 * handler for OC_CLEANUP
 */

DWORD OnCleanup()
{
    return NO_ERROR;
}

/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD OnQueryState(LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state)
{
    //
    // Override default state if MSI provider is already
    // present on the system and this is GUI-mode setup
    //
    PPER_COMPONENT_DATA cd;
    if (cd = LocateComponent(ComponentId))
    {
        if (!(cd->Flags & SETUPOP_STANDALONE))
        {
            if (state == OCSELSTATETYPE_CURRENT)
            {
                if (!_wcsicmp(ComponentId, L"wbemmsi") && !_wcsicmp(SubcomponentId, L"wbemmsi"))
                {
                    if (IsMSIProviderPresent())
                    {
                        return SubcompOn;
                    }
                }
            }
        }
    }

    return SubcompUseOcManagerDefault;
}

/*
 * OnNeedMedia()
 *
 * handler for OC_NEED_MEDIA
 */

DWORD OnNeedMedia()
{
    return false;
}

/*
 * OnAboutToCommitQueue()
 *
 * handler for OC_ABOUT_TO_COMMIT_QUEUE
 */

DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    //
    // only do stuff on uninstall
    //
    if (state) {
        return NO_ERROR;
    }

    // Fetch uninstall section name.
    rc = SetupFindFirstLine(
                    cd->hinf,
                    SubcomponentId,
                    KEYWORD_UNINSTALL,
                    &context);

    if (rc) {
        rc = SetupGetStringField(
                     &context,
                     1,
                     section,
                     sizeof(section) / sizeof(TCHAR),
                     NULL);
    }

    if (rc) 
        rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);

    if (rc) {
        rc = SetupInstallFromInfSection(
                    NULL,
                    cd->hinf,
                    section,
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL);        
    }
    
    if (rc) {
       SetLastError(NO_ERROR);
    }
    return GetLastError();

}

/*
 * AddNewComponent()
 *
 * add new compononent to the top of the component list
 */

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA data;

    data = (PPER_COMPONENT_DATA)LocalAlloc(LPTR,sizeof(PER_COMPONENT_DATA));
    if (!data)
        return data;

    data->ComponentId = (TCHAR *)LocalAlloc(LMEM_FIXED,
            (_tcslen(ComponentId) + 1) * sizeof(TCHAR));

    if(data->ComponentId)
    {
        StringCchCopy((TCHAR *)data->ComponentId, (_tcslen(ComponentId) + 1) * sizeof(TCHAR), ComponentId);

        // Stick at head of list
        data->Next = gcd;
        gcd = data;
    }
    else
    {
        LocalFree((HLOCAL)data);
        data = NULL;
    }

    return(data);
}

/*
 * LocateComponent()
 *
 * returns a compoent struct that matches the
 * passed component id.
 */

PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p;

    for (p = gcd; p; p=p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
            return p;
    }

    return NULL;
}

/*
 * RemoveComponent()
 *
 * yanks a component from our linked list of components
 */

VOID RemoveComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p, prev;

    for (prev = NULL, p = gcd; p; prev = p, p = p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
        {
            LocalFree((HLOCAL)p->ComponentId);

            if (p->SourcePath)
                LocalFree((HLOCAL)p->SourcePath);

            if (prev)
                prev->Next = p->Next;
            else
                gcd = p->Next;

            LocalFree((HLOCAL)p);

            return;
        }
    }
}

// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
StateInfo(
    PPER_COMPONENT_DATA cd,
    LPCTSTR             SubcomponentId,
    BOOL               *state
    )
{
    BOOL rc = TRUE;

    assert(state);

    // otherwise, check for a change in installation state

    *state = cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                    SubcomponentId,
                                                    OCSELSTATETYPE_CURRENT);

    if (*state == cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                         SubcomponentId,
                                                         OCSELSTATETYPE_ORIGINAL))
    {
        // no change
        rc = FALSE;
    }

    // if this is gui mode setup, presume the state has changed to force
    // an installation (or uninstallation)
    
    if (!(cd->Flags & SETUPOP_STANDALONE) && *state)
        rc = TRUE;

    return rc;
}

#if 0

//
// Andrewr -- get rid of RegisterServices and RegisterServers and have the oc gen component use setupapi instead.
//            this reduces the amount of redundant code
//

DWORD RegisterServices(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       buf[MAX_PATH];
    TCHAR       path[MAX_PATH];
    TCHAR       sname[S_SIZE];
    TCHAR       file[MAX_PATH];
    DWORD       section;
    ULONG       size;
	pfn         pfreg;
    HINSTANCE   hinst;
    HRESULT     hr;
    TCHAR      *keyword;
    SC_HANDLE   schSystem;

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if ( !schSystem ) {
        DWORD dwError = GetLastError( );

        if( !IsNT() && ( ERROR_CALL_NOT_IMPLEMENTED == dwError ) )
        {
            return( NO_ERROR );
        }
        else
        {
            return( dwError );
        }
    }

    if (state) {
        keyword = KEYWORD_ADDSERVICE;
    } else {
        keyword = KEYWORD_DELSERVICE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        SC_HANDLE   schService;

        CHAR Temp[SBUF_SIZE];
        TCHAR ServiceName[ SBUF_SIZE ];
        TCHAR DisplayName[ SBUF_SIZE ];
        DWORD ServiceType;
        DWORD StartType;
        DWORD ErrorControl;
        TCHAR ImagePath[ SBUF_SIZE ];
        TCHAR LoadOrder[ SBUF_SIZE ];
        TCHAR Dependencies[ SBUF_SIZE ];
        TCHAR StartName[ SBUF_SIZE ];
        TCHAR Password[ SBUF_SIZE ];

        BOOL fDisplayName  = FALSE;
        BOOL fServiceType  = FALSE;
        BOOL fStartType    = FALSE;
        BOOL fErrorControl = FALSE;
        BOOL fLoadOrder    = FALSE;
        BOOL fDependencies = FALSE;
        BOOL fStartName    = FALSE;
        BOOL fPassword     = FALSE;
        BOOL fDontReboot   = FALSE;

        //
        // Must have ServiceName
        //
        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SERVICENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SERVICENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ServiceName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SERVICENAME );
            continue;
        }

        if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_STARTTYPE, &sic))
        {
            if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
            {
                StartType = atoi( Temp );
                fStartType = TRUE;
            }
        }

        if ( state )
        {
            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_DISPLAYNAME, &sic))
            {
                if (SetupGetStringField(&sic, 1, DisplayName, SBUF_SIZE, NULL))
                {
                    fDisplayName = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_SERVICETYPE, &sic))
            {
                if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
                {
                    ServiceType = atoi( Temp );
                    fServiceType = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_ERRORCONTROL, &sic))
            {
                if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
                {
                    ErrorControl = atoi( Temp );
                    fErrorControl = TRUE;
                }
            }

            //
            // Must have ImagePath
            //
            if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_IMAGEPATH, &sic))
            {
                log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_IMAGEPATH );
                continue;
            }

            if (!SetupGetStringField(&sic, 1, ImagePath, SBUF_SIZE, NULL))
            {
                log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_IMAGEPATH );
                continue;
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_LOADORDER, &sic))
            {
                if (SetupGetStringField(&sic, 1, LoadOrder, SBUF_SIZE, NULL))
                {
                    fLoadOrder = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_DEPENDENCIES, &sic))
            {
                if (SetupGetStringField(&sic, 1, Dependencies, SBUF_SIZE-1, NULL))
                {
                    LPTSTR psz = Dependencies;
                    // needs to be a double-null terminated string
                    Dependencies[ lstrlen(Dependencies) + 1] = TEXT('\0');

                    // change commas into NULL characters
                    while ( *psz )
                    {
                        if ( *psz == TEXT(',') )
                        {
                            *psz = TEXT('\0');
                        }
                        psz++;
                    }
                    fDependencies = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_STARTNAME, &sic))
            {
                if (SetupGetStringField(&sic, 1, StartName, SBUF_SIZE, NULL))
                {
                    fStartName = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_PASSWORD, &sic))
            {
                if (SetupGetStringField(&sic, 1, Password, SBUF_SIZE, NULL))
                {
                    fPassword = TRUE;
                }
            }

            schService = CreateService(
                        schSystem,
                        ServiceName,
                        ( fDisplayName == TRUE  ? DisplayName   : ServiceName ),
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        ( fServiceType == TRUE  ? ServiceType   : SERVICE_WIN32_OWN_PROCESS),
                        ( fStartType == TRUE    ? StartType     : SERVICE_AUTO_START),
                        ( fErrorControl == TRUE ? ErrorControl  : SERVICE_ERROR_NORMAL),
                        ImagePath,
                        (fLoadOrder == TRUE     ? LoadOrder     : NULL),
                        NULL,   // tag id
                        ( fDependencies == TRUE ? Dependencies  : NULL ),
                        ( fStartName == TRUE    ? StartName     : NULL),
                        ( fPassword == TRUE     ? Password      : NULL ));

            if ( !schService )
            {
                DWORD Error = GetLastError( );
                log( TEXT("OCGEN: CreateService() error 0x%08x\r\n"), Error );
                return Error;
            }

            if ( (!fStartType)
               || ( fStartType && StartType == SERVICE_AUTO_START ))
            {
                if( !StartService( schService, 0, NULL ) )
                {
                    DWORD Error = GetLastError( );
                    switch ( Error )
                    {
                    case ERROR_SERVICE_EXISTS:
                        {
                            log( TEXT("OCGEN: %s was already exists.\r\n"), ServiceName );

                            if ( fStartType && StartType == SERVICE_BOOT_START )
                            {
                                fDontReboot = TRUE;
                            }
                        }
                        break;

                    case ERROR_SERVICE_ALREADY_RUNNING:
                        {
                            log( TEXT("OCGEN: %s was already started.\r\n"), ServiceName );

                            if ( fStartType && StartType == SERVICE_BOOT_START )
                            {
                                fDontReboot = TRUE;
                            }
                        }
                        break;

                    default:
                        log( TEXT("OCGEN: StartService() error 0x%08x\r\n"), Error );
                        return Error;
                    }
                }
            }
        }
        else
        {
            schService = OpenService( schSystem,
                                      ServiceName,
                                      STANDARD_RIGHTS_REQUIRED | DELETE );
            if ( schService )
            {
                SERVICE_STATUS ss;
                DeleteService( schService );
                ControlService( schService, SERVICE_CONTROL_STOP, &ss );
            }

        }

        //
        // BOOT drivers require a reboot unless they were already started.
        //
        if ( schService
           && fStartType && StartType == SERVICE_BOOT_START
           && fDontReboot == FALSE)
        {
            cd->HelperRoutines.SetReboot(cd->HelperRoutines.OcManagerContext, NULL);
        }

        if ( schService )
        {
            CloseServiceHandle( schService );
        }
    }

    return NO_ERROR;
}
#endif
#if 0

DWORD
RegisterServers(
    HINF    hinf,
    LPCTSTR component,
    DWORD   state
    )
{
    INFCONTEXT  ic;
    TCHAR       buf[MAX_PATH];
    TCHAR       path[MAX_PATH];
    TCHAR       sname[S_SIZE];
    TCHAR       file[MAX_PATH];
    DWORD       section;
    ULONG       size;
	pfn         pfreg;
    HINSTANCE   hinst;
    HRESULT     hr;
    TCHAR      *keyword;
    LPCSTR      routine;

    CoInitialize(NULL);

    if (state) {
        keyword = KEYWORD_REGSVR;
        routine = (LPCSTR)gszRegisterSvrRoutine;
    } else {
        keyword = KEYWORD_UNREGSVR;
        routine = (LPCSTR)gszUnregisterSvrRoutine;
    }

    for (section = 1;
         EnumSections(hinf, component, keyword, section, &ic, sname);
         section++)
    {
        if (!SetupGetTargetPath(hinf, NULL, sname, path, sizeof(path), &size))
            continue;
        PathAddBackslash(path);

        do {
            // get fully qualified path to dll to register

            if (!SetupGetStringField(&ic, 0, buf, sizeof(buf)/sizeof(buf[0]), NULL))
                continue;

            _tcscpy(file, path);
            _tcscat(file, buf);

            // call the dll's RegisterServer routine

            if (!(hinst = LoadLibrary(file)))
                continue;

            if (!(pfreg = (pfn)GetProcAddress(hinst, routine)))
                continue;

            hr = pfreg();
            assert(hr == NO_ERROR);

            FreeLibrary(hinst);

            // on to the next

        } while (SetupFindNextLine(&ic, &ic));
    }

	CoUninitialize();

    return TRUE;
}
#endif

                                          /*
 * EnumSections()
 *
 * finds the name of a section for a specified keyword
 */

DWORD
EnumSections(
    HINF hinf,
    const TCHAR *component,
    const TCHAR *key,
    DWORD index,
    INFCONTEXT *pic,
    TCHAR *name
    )
{
    TCHAR section[S_SIZE];

    if (!SetupFindFirstLine(hinf, component, NULL, pic))
        return 0;

    if (!SetupFindNextMatchLine(pic, key, pic))
        return 0;

    if (index > SetupGetFieldCount(pic))
        return 0;

    if (!SetupGetStringField(pic, index, section, sizeof(section)/sizeof(section[0]), NULL))
        return 0;

    if (name)
        StringCchCopy(name, S_SIZE, section);  // "name" buffer was allocated elsewhere and is S_SIZE characters in size

    return SetupFindFirstLine(hinf, section, NULL, pic);
}


DWORD
OcLog(
      LPCTSTR ComponentId,
      UINT level,
      LPCTSTR sz
      )
{
    TCHAR fmt[5000];
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    assert(cd->ExtraRoutines.LogError);
    assert(level);
    assert(sz);

    StringCchCopy(fmt, 5000, TEXT("%s: %s"));

    return cd->ExtraRoutines.LogError(cd->HelperRoutines.OcManagerContext,
                                      level,
                                      fmt,
                                      ComponentId,
                                      sz);
}

DWORD
CleanupNetShares(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    if (state) {
        return NO_ERROR;
    } else {
        keyword = KEYWORD_DELSHARE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        NET_API_STATUS netStat;

        CHAR Temp[SBUF_SIZE];
        TCHAR ShareName[ SBUF_SIZE ];

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SHARENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ShareName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

#ifdef UNICODE
        netStat = NetShareDel( NULL, ShareName, 0 );
#else // UNICODE
        WCHAR ShareNameW[ SBUF_SIZE ];
        mbstowcs( ShareNameW, ShareName, lstrlen(ShareName));
        netStat = NetShareDel( NULL, ShareNameW, 0 );
#endif // UNICODE
        if ( netStat != NERR_Success )
        {
            log( TEXT("OCGEN: Failed to remove %s share. Error 0x%08x\r\n"), ShareName, netStat );
            continue;
        }

        log( TEXT("OCGEN: %s share removed successfully.\r\n"), ShareName );
    }

    return TRUE;
}

DWORD
RunExternalProgram(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    keyword = KEYWORD_RUN;

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        TCHAR CommandLine[ SBUF_SIZE ];
        CHAR szTickCount[ SBUF_SIZE ];
        ULONG TickCount;
        BOOL b;
        STARTUPINFO startupinfo;
        PROCESS_INFORMATION process_information;
        DWORD dwErr;

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_COMMANDLINE , &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, CommandLine, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_TICKCOUNT, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        if (!SetupGetStringFieldA(&sic, 1, szTickCount, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        TickCount = atoi( szTickCount );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        b = CreateProcess( NULL,
                           CommandLine,
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_DEFAULT_ERROR_MODE,
                           NULL,
                           NULL,
                           &startupinfo,
                           &process_information );
        if ( !b )
        {
            log( TEXT("OCGEN: failed to spawn %s process.\r\n"), CommandLine );
            continue;
        }

        dwErr = WaitForSingleObject( process_information.hProcess, TickCount * 1000 );
        if ( dwErr != NO_ERROR )
        {
            log( TEXT("OCGEN: WaitForSingleObject() failed. Error 0x%08x\r\n"), dwErr );
            TerminateProcess( process_information.hProcess, -1 );
            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
            continue;
        }

        CloseHandle( process_information.hProcess );
        CloseHandle( process_information.hThread );

        log( TEXT("OCGEN: %s successfully completed within %u seconds.\r\n"), CommandLine, TickCount );
    }

    return TRUE;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Determine prior install status of WMI components
//

#define WBEM_REG_KEY  L"SOFTWARE\\Microsoft\\WBEM"
#define INSTALL_DIR   L"Installation Directory"
#define MSI_PROVIDER  L"msiprov.dll"
#define CLSID_KEY     L"Software\\classes\\CLSID"
#define CLSID_MSIPROV L"{BE0A9830-2B8B-11D1-A949-0060181EBBAD}"

bool IsMSIProviderPresent()
{
    bool bRet = false;

    //
    // First check for the present of the provider dll
    //
    HKEY hKey;
    long lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, WBEM_REG_KEY, 0, KEY_READ, &hKey);
    if(ERROR_SUCCESS == lRes)
    {
        WCHAR wszTmp[MAX_PATH + 1];
        DWORD dwLen = (MAX_PATH + 1)*sizeof(WCHAR);
        lRes = RegQueryValueEx(hKey, INSTALL_DIR, NULL, NULL, (LPBYTE)wszTmp, &dwLen);
        RegCloseKey(hKey);
        if(ERROR_SUCCESS == lRes)
        {
            WCHAR wszPath[MAX_PATH + 1];
            if (ExpandEnvironmentStrings(wszTmp, wszPath, MAX_PATH + 1))
            {
                StringCchCat(wszPath, MAX_PATH + 1, L"\\" MSI_PROVIDER);
                DWORD dwAttribs = GetFileAttributes(wszPath);
                if (dwAttribs != 0xFFFFFFFF)
                {
                    //
                    // The file exists, now check for its CLSID in the registry
                    //
                    WCHAR wszCLSIDKey[62]; // entire key is 61 characters long
                    StringCchCopy(wszCLSIDKey, 62, CLSID_KEY L"\\");
                    StringCchCat(wszCLSIDKey, 62, CLSID_MSIPROV);
                
                    lRes = RegOpenKey(HKEY_LOCAL_MACHINE, wszCLSIDKey, &hKey);
                    if(ERROR_SUCCESS == lRes)
                    {
                        RegCloseKey(hKey);
                        
                        //
                        // Both the file and the CLSID exist, so the provider is installed
                        //
                        bRet = true;
                    }
                }
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\precomp.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

History:

--*/
#ifndef __PRECOMP_H_
#define __PRECOMP_H_

#include <ole2.h>
#include <windows.h>

#include <comutil.h>

#define STRSAFE_NO_DEPRECATE

#include <strsafe.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\reg.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    reg.H

Abstract:

    Registry helper class

History:


--*/

#define WBEM_REG_WBEM					"Software\\Microsoft\\WBEM"
#define WBEM_REG_WINMGMT				"Software\\Microsoft\\WBEM\\CIMOM"
#define WBEM_REG_AUTORECOVER			"Autorecover MOFs"
#define WBEM_REG_AUTORECOVER_EMPTY		"Autorecover MOFs (empty)"
#define WBEM_REG_AUTORECOVER_RECOVERED	"Autorecover MOFs (recovered)"
#define SYSTEM_SETUP_REG				"System\\Setup"

class Registry
{
    HKEY	hPrimaryKey;
    HKEY	hSubkey;
    int		m_nStatus;
	LONG	m_nLastError;
public:
    enum { no_error, failed };

	Registry(char *pszLocalMachineStartKey);
	~Registry();
	int Open(HKEY hStart, const char *pszStartKey);
	int GetStr(const char *pszValueName, char **pValue);
	char* GetMultiStr(const char *pszValueName, DWORD &dwSize);
	int SetMultiStr(const char *pszValueName, const char*pData, DWORD dwSize);
	int DeleteEntry(const char *pszValueName);
	int SetStr(char *pszValueName, char *pszValue);
    int GetDWORD(TCHAR *pszValueName, DWORD *pdwValue);
	int GetStatus() { return m_nStatus;};
	LONG GetLastError() { return m_nLastError;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\str.cpp ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    str.cpp

Abstract:

    Implementation file for the string class

History:


--*/
#include "precomp.h"

char *__g_pszStringBlank = "\0";	//Needs to be double terminated for the multi-string!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\reg.cpp ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    reg.cpp

Abstract:

    Implementation of the registry helper class

History:


--*/
#include "precomp.h"
#include <stdio.h>
#define DEPRECATE_SUPPORTED
#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>
#include "reg.h"

Registry::Registry(char *pszLocalMachineStartKey)
{
    hPrimaryKey	= 0;
    hSubkey = 0;
    m_nStatus = Open(HKEY_LOCAL_MACHINE, pszLocalMachineStartKey);
    hSubkey = hPrimaryKey;
}
Registry::~Registry()
{
    if (hSubkey)
        RegCloseKey(hSubkey);
    if (hPrimaryKey != hSubkey)
        RegCloseKey(hPrimaryKey);
}
int Registry::Open(HKEY hStart, const char *pszStartKey)
{
    int nStatus = no_error;
    DWORD dwDisp = 0;

	m_nLastError = RegCreateKeyEx(hStart, pszStartKey,
									0, 0, 0,
									KEY_ALL_ACCESS, 0, &hPrimaryKey, &dwDisp);

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}
char* Registry::GetMultiStr(const char *pszValueName, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return NULL;
	}
	if (dwSize == 0)
	{
		return NULL;
	}

	//allocate the buffer required
	char *pData = new char[dwSize];
	if (!pData)
	{
		dwSize = 0;
		return NULL;
	}
	
	//get the values
	m_nLastError = RegQueryValueEx(hSubkey, 
								   pszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return NULL;
	}

	return pData;
}

int Registry::SetMultiStr(const char *pszValueName, const char*pszValue, DWORD dwSize)
{
	m_nLastError = RegSetValueEx(hSubkey, 
								 pszValueName, 
								 0, 
								 REG_MULTI_SZ, 
								 LPBYTE(pszValue), 
								 dwSize);

    if (m_nLastError != 0)
		return failed;

    return no_error;
}

int Registry::GetStr(const char *pszValueName, char **pValue)
{
    *pValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
		return failed;

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        return failed;

    char *p = new char[dwSize];
	if (!p)
		return failed;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
		char tTemp;

		// Get the initial length
        DWORD nSize = ExpandEnvironmentStrings(p,&tTemp,1) + 1;
        TCHAR* pTemp = new TCHAR[nSize+1];
		if (!pTemp)
			return failed;

        if (!ExpandEnvironmentStrings(p,pTemp,nSize+1))
		{
			delete [] p;
			delete [] pTemp;
			return failed;
		}

        delete [] p;
        *pValue = pTemp;
    }
    else
        *pValue = p;
    return no_error;
}

int Registry::DeleteEntry(const char *pszValueName)
{
	m_nLastError = RegDeleteValue(  hSubkey, pszValueName);
	if (m_nLastError != 0)
	{
		return failed;
	}
	else
		return no_error;
}
int Registry::SetStr(char *pszValueName, char *pszValue)
{
	m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(pszValue),
        strlen(pszValue) + 1);

    if (m_nLastError != 0)
		return failed;
    return no_error;
}

int Registry::GetDWORD(TCHAR *pszValueName, DWORD *pdwValue)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_DWORD)
        return failed;

    return no_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\upgrade.cpp ===
// Copyright (c) 2000 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <wbemint.h>
#include "upgrade.h"
#include "wbemutil.h"
#include "reg.h"
#include "export.h"
#include "import.h"
#include <WDMSHELL.h>
#include <wmimof.h>	
#include <wmicom.h>
#include <setupapi.h>
#include <persistcfg.h>
#include <str.h>
#include <helper.h>



//Handy pointer to the MMF arena which almost every file
//to do with the on-disk representation management uses.
CMMFArena2* g_pDbArena = 0;

bool DoCoreUpgrade(int nInstallType )
{
	LogMessage(MSG_INFO, "Beginning Core Upgrade");

	bool bRet = true;
	bool bCoreFailure = false;
	bool bExternalFailure = false;
	bool bOrgRepositoryPreserved = false;
	CMultiString mszSystemMofs;
	CMultiString mszExternalMofList;
	CString szFailedSystemMofs;
	CString szFailedExternalMofs;
	CString szMissingMofs;

	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoCoreUpgrade.");
		return false;
	}

    IWbemContext * pCtx = NULL;    
    HRESULT hRes = CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER,  
                                                         IID_IWbemContext, (LPVOID *) &pCtx);
    if (FAILED(hRes))
    {
        LogMessage(MSG_ERROR, "Unable to create CLSID_WbemContext.");
        return false;
    }
    OnDelete<IUnknown *,void(*)(IUnknown *),RM> rmCtx(pCtx);

    _variant_t Var = true;                
    if (FAILED(hRes = pCtx->SetValue(L"__MOFD_DO_STORE",0,&Var))) return false;

    IWinmgmtMofCompiler * pCompiler = NULL;
    SCODE sc = CoCreateInstance(CLSID_WinmgmtMofCompiler, 0, CLSCTX_INPROC_SERVER,  
                                                         IID_IWinmgmtMofCompiler, (LPVOID *) &pCompiler);    
    
    if(SUCCEEDED(sc))
	{
		GetStandardMofs(mszSystemMofs, nInstallType);
		UpgradeAutoRecoveryRegistry(mszSystemMofs, mszExternalMofList, szMissingMofs);
		WipeOutAutoRecoveryRegistryEntries();

		if (DoesFSRepositoryExist())
		{
			// check whether repository needs upgrading, and perform upgrade if necessary
			bOrgRepositoryPreserved = UpgradeRepository();
		}

		// if we find an MMF, convert it, regardless of whether another repository already exists
		if (DoesMMFRepositoryExist())
		{
			bOrgRepositoryPreserved = DoConvertRepository();
		}

		bRet = LoadMofList(pCtx,pCompiler, mszSystemMofs, szFailedSystemMofs);
		if (bRet == false)
			bCoreFailure = true;

		// if the repository did not exist when we began, 
		// or we had to create a new one due to an upgrade failure,
		// we need to reload external mofs
		if (!bOrgRepositoryPreserved)
		{
			bRet = LoadMofList(pCtx,pCompiler, mszExternalMofList, szFailedExternalMofs);
			if (bRet == false)
				bExternalFailure = true;
		}
		pCompiler->Release();

		//Part of the tidy-up code is to write back the registry entries, so here we go...
		WriteBackAutoRecoveryMofs(mszSystemMofs, mszExternalMofList);

		FILETIME ftCurTime;
		LARGE_INTEGER liCurTime;
		char szBuff[50];
		GetSystemTimeAsFileTime(&ftCurTime);
		liCurTime.LowPart = ftCurTime.dwLowDateTime;
		liCurTime.HighPart = ftCurTime.dwHighDateTime;
		_ui64toa(liCurTime.QuadPart, szBuff, 10);
		r.SetStr("Autorecover MOFs timestamp", szBuff);
	}
	else
	{
		bRet = false;
	}

	if (szFailedSystemMofs.Length())
	{
		LogMessage(MSG_ERROR, "The following WMI CORE MOF file(s) failed to load:");
		LogMessage(MSG_ERROR, szFailedSystemMofs);
	}
	else if (bCoreFailure)
	{
		LogMessage(MSG_NTSETUPERROR, "None of the WMI CORE MOFs could be loaded.");
	}
	else if (szFailedExternalMofs.Length())
	{
		LogMessage(MSG_ERROR, "The following External MOF file(s) failed to load:");
		LogMessage(MSG_ERROR, szFailedExternalMofs);
	}
	else if (bExternalFailure)
	{
		LogMessage(MSG_NTSETUPERROR, "None of the External MOFs could be loaded.");
	}
	else if (bRet == false)
	{
		LogMessage(MSG_NTSETUPERROR, "No MOFs could be loaded because the MOF Compiler failed to intialize.");
	}
	if (szMissingMofs.Length())
	{
		LogMessage(MSG_WARNING, "The following MOFs could not be found and were removed from the auto-recovery registry setting:");
		LogMessage(MSG_WARNING, szMissingMofs);
	}

	LogMessage(MSG_INFO, "Core Upgrade completed.");
	return bRet;
}

bool UpgradeAutoRecoveryRegistry(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList, CString &szMissingMofs)
{
	char* pszNewList = NULL;
	char* pszEmptyList = NULL;
	char* pszRecoveredList = NULL;
		
	try
	{
		//First we need to recover the existing entries...

		Registry r(WBEM_REG_WINMGMT);
		if (r.GetStatus() != no_error)
		{
			LogMessage(MSG_ERROR, "Unable to access registry for UpgradeAutoRecoveryRegistry.");
			return false;
		}

		DWORD dwSize = 0;
		pszNewList = r.GetMultiStr(WBEM_REG_AUTORECOVER, dwSize);
		pszEmptyList = r.GetMultiStr(WBEM_REG_AUTORECOVER_EMPTY, dwSize);
		pszRecoveredList = r.GetMultiStr(WBEM_REG_AUTORECOVER_RECOVERED, dwSize);
		CMultiString mszOtherMofs;

		//Lets work through the list in the new mof list if it exists...
		GetNewMofLists(pszNewList, mszSystemMofs, mszOtherMofs, szMissingMofs);

		//Lets work through the empty list first...
		GetNewMofLists(pszEmptyList, mszSystemMofs, mszOtherMofs, szMissingMofs);

		//Lets work through the recovered list next...
		GetNewMofLists(pszRecoveredList, mszSystemMofs, mszOtherMofs, szMissingMofs);

		//Now we copy across the other MOFs to the external list...
		CopyMultiString(mszOtherMofs, mszExternalMofList);
	}
	catch (...)
	{
		// assume something has corrupted the registry key, so toss out the work we've done so far (empty the lists)
		mszExternalMofList.Empty();
		szMissingMofs = "";
	}

	//Tidy up the memory...
	delete [] pszNewList;
	delete [] pszEmptyList;
	delete [] pszRecoveredList;

	//Now we are done with the registry.
	return true;
}

bool GetNewMofLists(const char *pszMofList, CMultiString &mszSystemMofs, CMultiString &mszOtherMofs, CString &szMissingMofs)
{
	// produce a standard mof list with only filenames and no paths to be used as our search list
	CMultiString mszStandardMofList;
	const char* pszFrom = mszSystemMofs;
	CString path;
	CString filename;
	while (pszFrom && *pszFrom)
	{
		ExtractPathAndFilename(pszFrom, path, filename);
		mszStandardMofList.AddUnique(filename);
		pszFrom += strlen(pszFrom) + 1;
	}

	// check each file to see if it is a standard mof
	const char *psz = pszMofList;
	while (psz && *psz)
	{
		if (FileExists(psz))
		{
			if (IsStandardMof(mszStandardMofList, psz))
			{
				// This means we will be loading it with this install,
				// so we don't need to do anything here...
			}
			else
			{
				mszOtherMofs.AddUnique(psz);
			}
		}
		else
		{
			if (szMissingMofs.Length())
			{
				szMissingMofs += "\n";
			}
			szMissingMofs += psz;
		}

		//Move on to the next string...
		psz += strlen(psz) + 1;
	}

	return true;
}

bool GetMofList(const char* rgpszMofFilename[], CMultiString &mszMofs)
{
	char* pszFullName = NULL;

	for (int i = 0; rgpszMofFilename[i] != NULL; i++)
	{
		pszFullName = GetFullFilename(rgpszMofFilename[i]);
		if (pszFullName)
		{
			if (FileExists(pszFullName))
				mszMofs.AddUnique(pszFullName);
			delete [] pszFullName;
			pszFullName = NULL;
		}
		else
		{
			char szTemp[MAX_MSG_TEXT_LENGTH];
			StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Failed GetFullFilename for %s in GetMofList.", rgpszMofFilename[i]);
			LogMessage(MSG_ERROR, szTemp);
			
			// do not return false here, keep processing other mofs
		}
	}

	return true;
}

bool FileExists(const char *pszFilename)
{
	char *szExpandedFilename = NULL;
	DWORD nRes = ExpandEnvironmentStrings(pszFilename,NULL,0); 
	if (nRes == 0)
	{
		size_t fileNameLen = strlen(pszFilename) + 1;
		szExpandedFilename = new char[fileNameLen];
		if (szExpandedFilename == NULL)
		{
			return false;
		}
		StringCchCopyA(szExpandedFilename, fileNameLen, pszFilename);
	}
	else
	{
		szExpandedFilename = new char[nRes];
		if (szExpandedFilename == NULL)
		{
			return false;
		}
		nRes = ExpandEnvironmentStrings(pszFilename,szExpandedFilename,nRes); 
		if (nRes == 0)
		{
			delete [] szExpandedFilename;
			return false;
		}
	}
	
	bool bExists = false;
	DWORD dwAttribs = GetFileAttributes(szExpandedFilename);
	if (dwAttribs != 0xFFFFFFFF)
	{
		bExists = true;
	}

	delete [] szExpandedFilename;
	return bExists;
}

bool IsStandardMof(CMultiString &mszStandardMofList, const char* pszMofFile)
{
	//For this one we need to loop though our standard MOF list to see if it appears
	//in the list.	Ignore the path if present and compare only the filename.
	CString path;
	CString filename;
	ExtractPathAndFilename(pszMofFile, path, filename);

	bool bFound = false;
	const char* pszCompare = mszStandardMofList;
	while (pszCompare && *pszCompare)
	{
		if (_stricmp(pszCompare, filename) == 0)
		{
			bFound = true;
			break;
		}
		pszCompare += strlen(pszCompare) + 1;
	}

	return bFound;
}

bool ExtractPathAndFilename(const char *pszFullPath, CString &path, CString &filename)
{
	size_t tmpNameLen = strlen(pszFullPath) + 1;
	char *pszTmpName = new char[tmpNameLen];
	if (pszTmpName == NULL)
		return false;

	StringCchCopyA(pszTmpName, tmpNameLen, pszFullPath);

	char *pszFilename = pszTmpName;
	char *psz = strtok(pszTmpName, "\\");
	while (psz != NULL)
	{
		pszFilename = psz;
		psz = strtok(NULL, "\\");

		if (psz != NULL)
		{
			path += pszFilename;
			path += "\\";
		}
	}

	filename = pszFilename;

	delete [] pszTmpName;
	
	return true;
}

bool CopyMultiString(CMultiString &mszFrom, CMultiString &mszTo)
{
	const char *pszFrom = mszFrom;
	while (pszFrom && *pszFrom)
	{
		//Due to the fact that we should not have duplicates in the list, we will now do
		//a check to inforce this...
		mszTo.AddUnique(pszFrom);

		pszFrom += strlen(pszFrom) + 1;
	}

	return true;
}

bool GetStandardMofs(CMultiString &mszSystemMofs, int nCurInstallType)
{
	// find the location of the inf
	char* pszWinDir = new char[_MAX_PATH+1];
	if (!pszWinDir)
	{
		LogMessage(MSG_ERROR, "Failed to allocate memory for pszWinDir for GetStandardMofs.");
		return FALSE;
	}
	if (!GetWindowsDirectory(pszWinDir, _MAX_PATH+1))
	{
		LogMessage(MSG_ERROR, "Failed to retrieve Windows directory for GetStandardMofs.");
		delete [] pszWinDir;
		return FALSE;
	}
	size_t fileNameLen = strlen(pszWinDir)+strlen("\\inf\\wbemoc.inf")+1;
	char* pszFileName = new char[fileNameLen];
	if (!pszFileName)
	{
		LogMessage(MSG_ERROR, "Failed to allocate memory for pszFileName for GetStandardMofs.");
		delete [] pszWinDir;
		return FALSE;
	}
	StringCchCopyA(pszFileName, fileNameLen, pszWinDir);
	StringCchCatA(pszFileName, fileNameLen, "\\inf\\wbemoc.inf");
	delete [] pszWinDir;

	// verify that inf exists
	if (!FileExists(pszFileName))
	{
		char szTemp[MAX_MSG_TEXT_LENGTH];
		StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Failed to locate inf file %s in GetStandardMofs.", pszFileName);
		LogMessage(MSG_ERROR, szTemp);
		delete [] pszFileName;
		return FALSE;
	}

	// GetPrivateProfileSection doesn't tell how large of a buffer is needed,
	// only how many chars it succeeded in copying, so I have to test to see
	// if I need to enlarge the buffer and try again
	const DWORD INITIAL_BUFFER_SIZE = 700;
	const DWORD BUFFER_SIZE_INCREMENT = 100;

	DWORD dwSize = INITIAL_BUFFER_SIZE;
	char* pszBuffer = new char[dwSize];
	if (!pszBuffer)
	{
		LogMessage(MSG_ERROR, "Failed to allocate memory for pszBuffer for GetStandardMofs.");
		delete [] pszFileName;
		return FALSE;
	}

	char* pszAppName = "WBEM.SYSTEMMOFS";
	DWORD dwCopied = GetPrivateProfileSection(pszAppName, pszBuffer, dwSize, pszFileName);
	 // if buffer isn't large enough, it copies dwSize - 2, so test for this
	while (dwCopied == (dwSize - 2))
	{
		delete [] pszBuffer;
		dwSize += BUFFER_SIZE_INCREMENT;
		pszBuffer = new char[dwSize];
		if (!pszBuffer)
		{
			LogMessage(MSG_ERROR, "Failed to allocate memory for pszBuffer for GetStandardMofs.");
			delete [] pszFileName;
			return FALSE;
		}
		dwCopied = GetPrivateProfileSection(pszAppName, pszBuffer, dwSize, pszFileName);
	}
	delete [] pszFileName;

	// now extract all the mofs from the buffer, get the full path, and store in the mof list
	char* pszFullName = NULL;
	char* psz = pszBuffer;
	char* pComment = NULL;
	while (psz[0] != '\0')
	{
		// if a comment is present after the filename, this will cut it off
		if (pComment = strchr(psz, ';'))
		{
			psz = strtok(psz, " \t;"); // there may be leading space or tabs as well as the semicolon
		}

		pszFullName = GetFullFilename(psz, (InstallType)nCurInstallType);
		if (pszFullName)
		{
			if (nCurInstallType != MUI || strstr(_strupr(pszFullName), ".MFL") != NULL)
			{
				if (FileExists(pszFullName))
					mszSystemMofs.AddUnique(pszFullName);
				else
				{
					char szTemp[MAX_MSG_TEXT_LENGTH];
					StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "GetStandardMofs failed to locate file %s.", pszFullName);
					LogMessage(MSG_ERROR, szTemp);
				}
			}
			delete [] pszFullName;
			pszFullName = NULL;
		}
		else
		{
			char szTemp[MAX_MSG_TEXT_LENGTH];
			StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Failed GetFullFilename for %s with install type = %i in GetStandardMofs.", psz, nCurInstallType);
			LogMessage(MSG_ERROR, szTemp);
			// do not return false here, keep processing other mofs
		}
		psz += (strlen(psz) + 1);

		if (pComment)
		{
			// skip over the comment at the end of the line
			psz += (strlen(psz) + 1);
			pComment = NULL;
		}
	}

	delete [] pszBuffer;

	return true;
}

char* GetFullFilename(const char *pszFilename, InstallType eInstallType)
{
	char *pszDirectory = NULL;
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for GetFullFilename.");
		return NULL;
	}

	if (r.GetStr("Working Directory", &pszDirectory))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Installation Directory from registry for GetFullFilename.");
		return NULL;
	}
	CString pszPathFilename(pszDirectory);
	if (eInstallType == MUI)
	{
		if (pszPathFilename.Length() && (pszPathFilename[pszPathFilename.Length()-1] != '\\'))
		{
			pszPathFilename += "\\MUI\\";
			pszPathFilename += g_szLangId;
		}
	}

	if (pszPathFilename.Length() && (pszPathFilename[pszPathFilename.Length()-1] != '\\'))
	{
		pszPathFilename += "\\";
	}
	pszPathFilename += pszFilename;

	delete [] pszDirectory;

	return pszPathFilename.Unbind();
}

bool WipeOutAutoRecoveryRegistryEntries()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for WipeOutAutoRecoveryRegistryEntries.");
		return false;
	}
	else
	{
		r.SetMultiStr(WBEM_REG_AUTORECOVER, "\0", 2);
		r.DeleteEntry(WBEM_REG_AUTORECOVER_EMPTY);
		r.DeleteEntry(WBEM_REG_AUTORECOVER_RECOVERED);
		return true;
	}
}

bool DoesMMFRepositoryExist()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoesMMFRepositoryExist.");
		return false;
	}

	char *pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	if (!pszDbDir)
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	CString szDbFilename(pszDbDir);
	if (szDbFilename.Length() != 0)
		szDbFilename += "\\";
	szDbFilename += "cim.rep";

	delete [] pszDbDir;
	
	return FileExists(szDbFilename);
}

bool DoesFSRepositoryExist()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoesMMFRepositoryExist.");
		return false;
	}

	char *pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	if (!pszDbDir || (strlen(pszDbDir) == 0))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	CString szDbFilename1(pszDbDir);
	szDbFilename1 += "\\FS\\MainStage.dat";
	CString szDbFilename2(pszDbDir);
	szDbFilename2 += "\\FS\\LowStage.dat";

	delete [] pszDbDir;
	
	return FileExists(szDbFilename1)||FileExists(szDbFilename2);
}


// This function is used to detect an earlier post-MMF repository version and upgrade it
// Returns TRUE if repository upgrade succeeded; FALSE in all other cases
bool UpgradeRepository()
{
	LogMessage(MSG_INFO, "Beginning repository upgrade");

	bool bRet = false;
	IWbemLocator *pLocator = NULL;
	HRESULT hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_ALL, IID_IWbemLocator,(void**)&pLocator);
	if(FAILED(hr))
	{
		LogMessage(MSG_ERROR, "WMI Repository upgrade failed CoCreateInstance.");
		return bRet;
	}
	
	IWbemServices *pNamespace = NULL;
	BSTR tmpStr = SysAllocString(L"root");

	hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, NULL, NULL, NULL, &pNamespace);
	if (SUCCEEDED(hr))
	{
		pNamespace->Release();
		LogMessage(MSG_INFO, "WMI Repository upgrade succeeded.");
		bRet = true;
	}
	else
	{
		if (hr == WBEM_E_DATABASE_VER_MISMATCH)
		{
			LogMessage(MSG_ERROR, "WMI Repository upgrade failed with WBEM_E_DATABASE_VER_MISMATCH.");

			// shut down so we can delete the repository
			ShutdownWinMgmt();

			// delete the repository so it can be rebuilt
			// try multiple times in case winmgmt hasn't shut down yet
			int nTry = 20;
			while (nTry--)
			{
				hr = MoveRepository();
				if (SUCCEEDED(hr))
				{
					break;
				}
				Sleep(500);
			}
			if (FAILED(hr))
			{
				LogMessage(MSG_ERROR, "WMI Repository upgrade failed to move repository to backup location.");
			}
		}
		else
		{
			LogMessage(MSG_ERROR, "WMI Repository upgrade failed ConnectServer.");
		}
	}

	SysFreeString(tmpStr);

	pLocator->Release();

	LogMessage(MSG_INFO, "Repository upgrade completed.");
	return bRet;
}

// This function is used to convert an old MMF repository to the current default repository
bool DoConvertRepository()
{
	// get MMF filename
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoConvertRepository.");
		return false;
	}

	char* pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DoConvertRepository");
		return false;
	}
	if (!pszDbDir)
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DoConvertRepository");
		return false;
	}

	CString szDbFilename(pszDbDir);
	delete [] pszDbDir;
	if (szDbFilename.Length() != 0)
		szDbFilename += "\\";
	szDbFilename += "cim.rep";

	// check that MMF really exists
	if (!FileExists(szDbFilename))
	{
		LogMessage(MSG_ERROR, "MMF Repository does not exist.");
		return false;
	}

	{	//Scope so that we delete the g_pDbArena before we try to delete the file
		// create arena and load MMF
		g_pDbArena = new CMMFArena2();
		if (g_pDbArena == 0)
		{
			LogMessage(MSG_ERROR, "Unable to create CMMFArena2");
			return false;
		}
		CDeleteMe<CMMFArena2> delMe1(g_pDbArena);
		if (!g_pDbArena->LoadMMF(szDbFilename) || (g_pDbArena->GetStatus() != no_error))
		{
			LogMessage(MSG_ERROR, "Error opening existing MMF");
			return false;
		}

		// get export filename
		TCHAR *pszFilename = GetFullFilename(WINMGMT_DBCONVERT_NAME);
		if (pszFilename == 0)
		{
			LogMessage(MSG_ERROR, "Unable to get DB name");
			return false;
		}
		CVectorDeleteMe<TCHAR> delMe2(pszFilename);

		// determine version of exporter to use
		CRepExporter*	pExporter	= NULL;
		DWORD			dwVersion	= g_pDbArena->GetVersion();
		MsgType			msgType		= MSG_INFO;
		char			szTemp[MAX_MSG_TEXT_LENGTH];
		StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Upgrading repository format.  Repository format version detected %lu.", dwVersion);
		switch (dwVersion)
		{
			case INTERNAL_DATABASE_VERSION:
			{
				pExporter = new CRepExporterV9;
				break;
			}
			case 3: //450 build
			{
				pExporter = new CRepExporterV1;
				break;
			}
			case 5: //500 series
			case 6: //600 series Nova M1
			{
				pExporter = new CRepExporterV5;
				break;
			}
			case 7: //900 series Nova M3 first attempt!
			case 8: //900 series... has null key trees until instance created
			{
				pExporter = new CRepExporterV7;
				break;
			}
			case 10: //9x version of version 9!
			{
				pExporter = new CRepExporterV9;
				break;
			}
			default:
			{
				StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Unsupported repository version detected.  Version found = %lu, version expected = %lu.", dwVersion, DWORD(INTERNAL_DATABASE_VERSION));
				msgType = MSG_ERROR;
			}
		}
		LogMessage(msgType, szTemp);

		// do we have an exporter?
		if (!pExporter)
		{
			LogMessage(MSG_ERROR, "Unable to create exporter object.");
			return false;
		}
		CDeleteMe<CRepExporter> delMe3(pExporter);

		// export the old repository
		if (pExporter->Export(g_pDbArena, pszFilename) != no_error)
		{
			LogMessage(MSG_ERROR, "Failed to export old WMI Repository.");
			return false;
		}
	

		// create new repository and import into it using IWbemServices
		CRepImporter import;
		if (import.ImportRepository(pszFilename) != no_error)
		{
			LogMessage(MSG_ERROR, "Failed to import data from old WMI Repository.");
			return false;
		}
		DeleteFile(pszFilename);
	}

	// conversion was successful, so now delete the old stuff
	DeleteMMFRepository();

	return true;
}

void DeleteMMFRepository()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DeleteMMFRepository.");
		return;
	}

	char* pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DeleteMMFRepository");
		return;
	}
	if (!pszDbDir)
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DeleteMMFRepository");
		return;
	}

	CString szDbFilename(pszDbDir);
	if (szDbFilename.Length() != 0)
		szDbFilename += "\\";
	szDbFilename += "cim.rep";

	CString szDbBackup(pszDbDir);
	if (szDbBackup.Length() != 0)
		szDbBackup += "\\";
	szDbBackup += "cim.rec";

	CString szDbNewFilename(pszDbDir);
	if (szDbNewFilename.Length() != 0)
		szDbNewFilename += "\\";
	szDbNewFilename += "cim.bak";

	delete [] pszDbDir;

	DeleteFile(szDbFilename);
	DeleteFile(szDbBackup);
	DeleteFile(szDbNewFilename);
}

void ShutdownWinMgmt()
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
	memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

	//Try killing WinMgmt
	char *pszFullPath = GetFullFilename("Winmgmt.exe");
	if (!pszFullPath)
	{
		LogMessage(MSG_NTSETUPERROR, "Could not shut down Winmgmt -- failed to get full path to Winmgmt.exe.");
		return;
	}

	size_t cmdLineLen = strlen("Winmgmt /kill") + 1;
	char *pszCommandLine = new char[cmdLineLen];
	if (!pszCommandLine)
	{

		LogMessage(MSG_NTSETUPERROR, "Could not shut down Winmgmt -- failed to allocate memory.");
		return;
	}
	StringCchCopyA(pszCommandLine, cmdLineLen, "Winmgmt /kill");
	if (CreateProcess(pszFullPath, pszCommandLine, 0, 0, FALSE, 0, 0, 0, &si, &pi))
	{
		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		Sleep(10000);
	}
	else
	{
		LogMessage(MSG_NTSETUPERROR, "Could not shut down Winmgmt -- failed to create process for Winmgmt.exe.");
	}
	delete [] pszCommandLine;
	delete [] pszFullPath;
}

/******************************************************************************
 *
 *	GetRepositoryDirectory
 *
 *	Description:
 *		Retrieves the location of the repository directory from the registry.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Array to store location in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = (MAX_PATH + 1)*sizeof(wchar_t);
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

HRESULT GetLoggingDirectory(wchar_t wszLoggingDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = sizeof(wszTmp);
    lRes = RegQueryValueExW(hKey, L"Logging Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszLoggingDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *	MoveRepository
 *
 *	Description:
 *		Move all files and directories under the repository directory
 *		to a backup location. The repository directory location is retrieved
 *		from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT MoveRepository()
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	wchar_t wszRepositoryMove[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
        for (int i=1; i<999; i++)
        {
    		StringCchPrintfW(wszRepositoryMove, MAX_PATH+1, L"%s.%03i", wszRepositoryDirectory, i);

            if (GetFileAttributesW(wszRepositoryMove) == 0xFFFFFFFF)
                break;
		}

		if (!MoveFileW(wszRepositoryDirectory, wszRepositoryMove))
			hres = WBEM_E_FAILED;
        else
        {
        	char szTemp[MAX_MSG_TEXT_LENGTH];

		    StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "wbemupgd.dll: The WMI repository has failed to upgrade. "
							"The repository has been backed up to %S and a new one created.",
							wszRepositoryMove);

		    LogMessage(MSG_NTSETUPERROR, szTemp);
        }

	}
	
	return hres;
}

bool LoadMofList(IWbemContext * pCtx, IWinmgmtMofCompiler * pCompiler, const char *mszMofs, CString &szMOFFailureList, long lOptionFlags, long lClassFlags)
{
	LogMessage(MSG_INFO, "Beginning MOF load");

	bool bRet = true;
	WCHAR wFileName[MAX_PATH+1];
	const char *pszMofs = mszMofs;
	char szTemp[MAX_MSG_TEXT_LENGTH+1];
	WBEM_COMPILE_STATUS_INFO statusInfo;

	// get logging directory or default if failed
	wchar_t wszMofcompLog[MAX_PATH+1];
	HRESULT hres = GetLoggingDirectory(wszMofcompLog);
	if (SUCCEEDED(hres))
	{
		StringCchCatW(wszMofcompLog, MAX_PATH+1, L"mofcomp.log");
	}
	else
	{
		StringCchCopyW(wszMofcompLog, MAX_PATH+1, L"<systemroot>\\system32\\wbem\\logs\\mofcomp.log");
	}

	// process each MOF
	while (*pszMofs != '\0')
	{
		char *szExpandedFilename = NULL;
		DWORD nRes = ExpandEnvironmentStrings(pszMofs,NULL,0); 
		if (nRes == 0)
		{
			size_t expandedFilenameLen = strlen(pszMofs) + 1;
			szExpandedFilename = new char[expandedFilenameLen];
			if (szExpandedFilename == NULL)
			{
				LogMessage(MSG_INFO, "Failed allocating memory for szExpandedFilename - 1.");

				bRet = false;
				break;
			}
			StringCchCopyA(szExpandedFilename, expandedFilenameLen, pszMofs);
		}
		else
		{
			szExpandedFilename = new char[nRes];
			if (szExpandedFilename == NULL)
			{
				LogMessage(MSG_INFO, "Failed allocating memory for szExpandedFilename - 2.");

				bRet = false;
				break;
			}
			nRes = ExpandEnvironmentStrings(pszMofs,szExpandedFilename,nRes); 
			if (nRes == 0)
			{
				LogMessage(MSG_INFO, "Failed expanding environment strings.");

				delete [] szExpandedFilename;
				bRet = false;
				break;
			}
		}
		
		StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "Processing %s", szExpandedFilename);
		LogMessage(MSG_INFO, szTemp);

		//Call MOF Compiler with (pszMofs);
               mbstowcs(wFileName, szExpandedFilename, MAX_PATH+1);

               SCODE sRet = pCompiler->WinmgmtCompileFile(wFileName,
                                                 NULL,
                                                 lOptionFlags,
                                                 lClassFlags,
                                                 0,
                                                 NULL, pCtx, &statusInfo);
               
		if (sRet != S_OK)
		{
			//This MOF failed to load.
			if (szMOFFailureList.Length())
				szMOFFailureList += "\n";
			szMOFFailureList += szExpandedFilename;

			StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "An error occurred while compiling the following MOF file: %s  "
							"Please refer to %S for more detailed information.",
							szExpandedFilename, wszMofcompLog);

			LogMessage(MSG_NTSETUPERROR, szTemp);

			bRet = false;
		}
		delete [] szExpandedFilename;

		//Move on to the next string
		pszMofs += strlen(pszMofs) + 1;
	}	// end while

	LogMessage(MSG_INFO, "MOF load completed.");

	return bRet;
}

bool WriteBackAutoRecoveryMofs(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList)
{
	CMultiString mszNewList;
	CopyMultiString(mszSystemMofs, mszNewList);
	CopyMultiString(mszExternalMofList, mszNewList);
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for WriteBackAutoRecoverMofs.");
		return false;
	}

	r.SetMultiStr(WBEM_REG_AUTORECOVER, mszNewList, mszNewList.Length() + 1);
	return true;
}

void LogMessage(MsgType msgType, const char *pszMessage)
{
	//Load messages from the resource
	char pszSetupMessage[10];
	switch (msgType)
	{
		case MSG_NTSETUPERROR:
			LogSetupError(pszMessage);
			// now fall through to next case
		case MSG_ERROR:
			StringCchCopyA(pszSetupMessage, 10, "ERROR: ");
			break;
		case MSG_WARNING:
			StringCchCopyA(pszSetupMessage, 10, "WARNING: ");
			break;
		case MSG_INFO:
		default:
			StringCchCopyA(pszSetupMessage, 10, "");
			break;
	}

	size_t newMessageLen = strlen(pszMessage) + 1;
	char* pszNewMessage = new char[newMessageLen];
	if (!pszNewMessage)
	{
		// we failed to allocate memory for the message, so no logging :(
		return;
	}
	StringCchCopyA(pszNewMessage, newMessageLen, pszMessage);

	// get log file path and name
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		// no messages will be logged because we don't know where to write the log :(
		delete [] pszNewMessage;
		return;		
	}	

	char* pszFullDirectory = NULL;
	if (r.GetStr("Logging Directory", &pszFullDirectory))
	{
		// no messages will be logged because we don't know where to write the log :(
		delete [] pszNewMessage;
		return;		
	}
	if (!pszFullDirectory)
	{
		// no messages will be logged because we don't know where to write the log :(
		delete [] pszNewMessage;
		return;		
	}

	char* pszFilename = "setup.log";
	size_t fullPathLen = strlen(pszFullDirectory) + strlen("\\") + strlen(pszFilename) + 1;
	char* pszFullPath = new char [fullPathLen];
	if (!pszFullPath)
	{
		// we failed to allocate memory for the path, so no logging :(
		delete [] pszNewMessage;
		return;
	}

	StringCchCopyA(pszFullPath, fullPathLen, pszFullDirectory);
	StringCchCatA(pszFullPath, fullPathLen, "\\");
	StringCchCatA(pszFullPath, fullPathLen, pszFilename);
	delete [] pszFullDirectory;

    // Get time
    char timebuf[64];
    time_t now = time(0);
    struct tm *local = localtime(&now);
    if(local)
    {
        StringCchCopyA(timebuf, 64, asctime(local));
        timebuf[strlen(timebuf) - 1] = 0;
    }
    else
        StringCchCopyA(timebuf,64, "unknown time");

	size_t timeLen = strlen(timebuf) + strlen("(): ") + 1;
	char* pszTime = new char [timeLen];
	if (!pszTime)
	{
		// we failed to allocate memory for the time, so no logging :(

		delete [] pszNewMessage;
		delete [] pszFullPath;
		return;
	}

	StringCchCopyA(pszTime, timeLen, "(");
	StringCchCatA(pszTime, timeLen, timebuf);
	StringCchCatA(pszTime, timeLen, "): ");

	// write messages to log file
	HANDLE hFile = CreateFile(pszFullPath, GENERIC_WRITE, 0, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		const char* pszCR = "\r\n";
		char* psz;
		DWORD dwWritten;
		SetFilePointer(hFile, 0, 0, FILE_END);
		psz = strtok(pszNewMessage, "\n");
		while (psz)
		{
			WriteFile(hFile, pszTime, strlen(pszTime), &dwWritten, 0);
			WriteFile(hFile, pszSetupMessage, strlen(pszSetupMessage), &dwWritten, 0);
			WriteFile(hFile, psz, strlen(psz), &dwWritten, 0);
			WriteFile(hFile, pszCR, strlen(pszCR), &dwWritten, 0);
			psz = strtok(NULL, "\n");
		}
		CloseHandle(hFile);
	}

	delete [] pszNewMessage;
	delete [] pszFullPath;
	delete [] pszTime;
}

void LogSetupError(const char *pszMessage)
{
	size_t tempLen = strlen(pszMessage) + 1;
	char* pszTemp = new char[tempLen];
	if (!pszTemp)
	{
		// we failed to allocate memory for the message, so no logging :(
		return;
	}
	StringCchCopyA(pszTemp, tempLen, pszMessage);

	char* psz;
	char* pszMessageLine;
	const char* pszCR = "\r\n";

	psz = strtok(pszTemp, "\n");
	while (psz)
	{
		size_t messageLineLen = strlen(psz) + strlen(pszCR) + 1;
		pszMessageLine = new char[messageLineLen];
		if (!pszMessageLine)
		{
			delete [] pszTemp;
			return;
		}
		StringCchCopyA(pszMessageLine, messageLineLen, psz);
		StringCchCatA(pszMessageLine, messageLineLen, pszCR);
		SetupLogError(pszMessageLine, LogSevError);
		delete [] pszMessageLine;

		psz = strtok(NULL, "\n");
	}

	delete [] pszTemp;
}

void ClearWMISetupRegValue()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() == no_error)
		r.SetStr("WMISetup", "0");
	else
		LogMessage(MSG_NTSETUPERROR, "Unable to clear WMI setup reg value.");
	r.DeleteEntry("KnownSvcs");
}

void SetWBEMBuildRegValue()
{
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_NTSETUPERROR, "Unable to set WBEM build reg value.");
		return;
	}
	
	char* pszBuildNo = new char[10];

	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(GetVersionEx(&os))
	{
		StringCchPrintfA(pszBuildNo, 10, "%lu.0000", os.dwBuildNumber);
	}
	r.SetStr("Build", pszBuildNo);

	delete [] pszBuildNo;
}

void RecordFileVersion()
{
	DWORD dwHandle;
	DWORD dwLen = GetFileVersionInfoSizeW(L"wbemupgd.dll", &dwHandle);

	if (dwLen)
	{
		BYTE* lpData = new BYTE[dwLen];

		if (lpData)
		{
			if (GetFileVersionInfoW(L"wbemupgd.dll", dwHandle, dwLen, lpData))
			{
				struct LANGANDCODEPAGE {
					WORD wLanguage;
					WORD wCodePage;
				} *lpTranslate;
				UINT cbTranslate;

				if (VerQueryValueW(lpData, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
				{
					wchar_t* pswzSubBlock = new wchar_t[dwLen];
					wchar_t* pwszFileVersion = NULL;
					UINT cbBytes;

					for(UINT i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++)
					{
						StringCchPrintfW(pswzSubBlock, dwLen, L"\\StringFileInfo\\%04x%04x\\FileVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

						// Retrieve file description for language and code page "i". 
						if (VerQueryValueW(lpData, pswzSubBlock, (LPVOID*)&pwszFileVersion, &cbBytes))
						{
							if (cbBytes)
							{
								wchar_t wszTemp[MAX_MSG_TEXT_LENGTH];
								StringCchPrintfW(wszTemp, MAX_MSG_TEXT_LENGTH, L"Current build of wbemupgd.dll is %s", pwszFileVersion);

								// once LogMessage is updated to handle wchars, this conversion can be removed
								char* szTemp = new char[MAX_MSG_TEXT_LENGTH+1];
								if (szTemp)
								{
									wcstombs(szTemp, wszTemp, MAX_MSG_TEXT_LENGTH+1);
									LogMessage(MSG_INFO, szTemp);
									delete [] szTemp;
								}
							}
						}
					}
					delete [] pswzSubBlock;
				}
			}
			delete [] lpData;
		}
	}
}

void CallEscapeRouteBeforeMofCompilation()
{
	HMODULE hDll = NULL;
	ESCDOOR_BEFORE_MOF_COMPILATION pfnEscRouteBeforeMofCompilation;
	char *pszFullPath = GetFullFilename("WmiEscpe.dll");
	if (!pszFullPath)
		return;

	hDll = LoadLibrary(pszFullPath);
	delete[] pszFullPath;
	if(hDll == NULL)
	{
		return;
	}
	pfnEscRouteBeforeMofCompilation =
		(ESCDOOR_BEFORE_MOF_COMPILATION)GetProcAddress((HMODULE)hDll, "EscRouteBeforeMofCompilation");

	if (pfnEscRouteBeforeMofCompilation == NULL)
	{
		if(hDll != NULL)
			FreeLibrary(hDll);
		return;
	}
	
	pfnEscRouteBeforeMofCompilation();
	if(hDll != NULL)
		FreeLibrary(hDll);
}

void CallEscapeRouteAfterMofCompilation()
{
	HMODULE hDll = NULL;
	ESCDOOR_AFTER_MOF_COMPILATION pfnEscRouteAfterMofCompilation;
	char *pszFullPath = GetFullFilename("WmiEscpe.dll");
	if (!pszFullPath)
		return;

	hDll = LoadLibrary(pszFullPath);
	delete[] pszFullPath;
	if(hDll == NULL)
	{
		return;
	}
	pfnEscRouteAfterMofCompilation =
		(ESCDOOR_AFTER_MOF_COMPILATION)GetProcAddress((HMODULE)hDll, "EscRouteAfterMofCompilation");

	if (pfnEscRouteAfterMofCompilation == NULL)
	{
		if(hDll != NULL)
			FreeLibrary(hDll);
		return;
	}
	
	pfnEscRouteAfterMofCompilation();
	if(hDll != NULL)
		FreeLibrary(hDll);
}

bool DoMofLoad(wchar_t* pComponentName, CMultiString& mszSystemMofs)
{
    bool bRet = true;
    bool bMofLoadFailure = false;
    CString szFailedSystemMofs;

    IWbemContext * pCtx = NULL;    
    HRESULT hRes = CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER,  
                                                         IID_IWbemContext, (LPVOID *) &pCtx);
    if (FAILED(hRes))
    {
        LogMessage(MSG_ERROR, "Unable to create CLSID_WbemContext.");
        return false;
    }
    OnDelete<IUnknown *,void(*)(IUnknown *),RM> rmCtx(pCtx);

    _variant_t Var = true;                
    if (FAILED(hRes = pCtx->SetValue(L"__MOFD_DO_STORE",0,&Var))) return false;

    IWinmgmtMofCompiler * pCompiler = NULL;
    SCODE sc = CoCreateInstance(CLSID_WinmgmtMofCompiler, 0, CLSCTX_INPROC_SERVER, IID_IWinmgmtMofCompiler, (LPVOID *) &pCompiler);
    
    if(SUCCEEDED(sc))
    {
        bRet = LoadMofList(pCtx,pCompiler, mszSystemMofs, szFailedSystemMofs, WBEM_FLAG_CONNECT_REPOSITORY_ONLY, 0);
        if (bRet == false)
            bMofLoadFailure = true;
        
        pCompiler->Release();
    }
    else
    {
        bRet = false;
    }
    
    if (szFailedSystemMofs.Length())
    {
        char szTemp[MAX_MSG_TEXT_LENGTH];
        StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "The following %S file(s) failed to load:", pComponentName);
        LogMessage(MSG_ERROR, szTemp);
        LogMessage(MSG_ERROR, szFailedSystemMofs);
    }
    else if (bMofLoadFailure)
    {
        char szTemp[MAX_MSG_TEXT_LENGTH];
        StringCchPrintfA(szTemp, MAX_MSG_TEXT_LENGTH, "None of the %S files could be loaded.", pComponentName);
        LogMessage(MSG_ERROR, szTemp);
    }
    else if (bRet == false)
    {
        LogMessage(MSG_ERROR, "No MOFs could be loaded because the MOF Compiler failed to intialize.");
    }
    return bRet;
}

// this call back is needed by the wdmlib functions called by DoWDMProviderInit()
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
	return;
}

bool DoWDMNamespaceInit()
{
	LogMessage(MSG_INFO, "Beginning WMI(WDM) Namespace Init");

	bool bRet = FALSE;

	IWbemLocator *pLocator = NULL;
	HRESULT hr = CoCreateInstance(CLSID_WbemAdministrativeLocator,NULL, CLSCTX_ALL, IID_IWbemLocator,(void**)&pLocator);
	if(SUCCEEDED(hr))
	{
		BSTR tmpStr = SysAllocString(L"root\\wmi");
		IWbemServices* pNamespace = NULL;
		hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, WBEM_FLAG_CONNECT_PROVIDERS, NULL, NULL, &pNamespace);
		if (SUCCEEDED(hr))
		{
			CHandleMap	HandleMap;
			CWMIBinMof Mof;
	
			if( SUCCEEDED( Mof.Initialize(&HandleMap, TRUE, WMIGUID_EXECUTE|WMIGUID_QUERY, pNamespace, pNamespace, NULL, NULL)))
			{
				Mof.ProcessListOfWMIBinaryMofsFromWMI();
			}

			pNamespace->Release();
			bRet = TRUE;
		}
		SysFreeString(tmpStr);
		pLocator->Release();
	}

	if (bRet)
		LogMessage(MSG_INFO, "WMI(WDM) Namespace Init Completed");
	else
		LogMessage(MSG_NTSETUPERROR, "WMI(WDM) Namespace Init Failed");

	return bRet;
}

bool EnableESS()
{
	CPersistentConfig cfg;
	bool bRet1 = (cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, 1) != 0);
        bool bRet2 = (cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_TO_BE_INITIALIZED,1) != 0);

	if (bRet1 && bRet2)
		LogMessage(MSG_INFO, "ESS enabled");
	else
		LogMessage(MSG_ERROR, "Failed to enable ESS");

	return (bRet1 && bRet2);
}

#ifdef _X86_
bool RemoveOldODBC()
{
	bool bRet = true;
	bool bDoUninstall = false;
	
	WCHAR strBuff[MAX_PATH + 30];
	DWORD dwSize = GetWindowsDirectoryW((LPWSTR) &strBuff, MAX_PATH);

	if ((dwSize > 1) && (dwSize < MAX_PATH) && (strBuff[dwSize] == L'\0'))
	{
		//can be c:\ or c:\windows
		if (strBuff[dwSize - 1] != L'\\')
		{
			StringCchCatW(strBuff, MAX_PATH+1, L"\\system32\\wbemdr32.dll");
			
			//we want dwSize to include the slash (may be used later)...
			dwSize++;
		}
		else
		{
			StringCchCatW(strBuff, MAX_PATH+1, L"system32\\wbemdr32.dll");
		}

		DWORD dwDummy = 0;
		DWORD dwInfSize = GetFileVersionInfoSizeW(strBuff, &dwDummy);

		if (dwInfSize > 0)
		{
			BYTE *verBuff = new BYTE[dwInfSize];

			if (verBuff)
			{
				if (GetFileVersionInfoW(strBuff, 0, dwInfSize, (LPVOID)verBuff))
				{
					VS_FIXEDFILEINFO *verInfo = NULL;
					UINT uVerInfoSize = 0;

					if (VerQueryValueW((const LPVOID)verBuff, L"\\", (LPVOID *)&verInfo, &uVerInfoSize) &&
						(uVerInfoSize == sizeof(VS_FIXEDFILEINFO)))
					{
						if (0x043D0000 > verInfo->dwFileVersionLS) //1085 = 43D
						{
							bDoUninstall = true;
							LogMessage(MSG_INFO, "Detected incompatible WBEM ODBC - removing");

							if (!DeleteFileW(strBuff))
							{
								if (!MoveFileExW(strBuff, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
								{
									bRet = false;
									LogMessage(MSG_INFO, "Failed to delete <system32>\\wbemdr32.dll");
								}
								else
								{
									LogMessage(MSG_INFO, "Will delete <system32>\\wbemdr32.dll on next reboot");
								}
							}
						}
					}
					else
					{
						GetLastError();
						LogMessage(MSG_INFO, "Failed to read ODBC Driver version info from resource buffer");
						bRet = false;
					}
				}
				else
				{
					GetLastError();
					LogMessage(MSG_INFO, "Failed to get ODBC Driver version info");
					bRet = false;
				}

				delete [] verBuff;
				verBuff = NULL;
			}
			else
			{
				bRet = false;
			}
		}
		else
		{
			dwDummy = GetLastError();

			if ((ERROR_FILE_NOT_FOUND != dwDummy) &&			// for some reason, the GetFileVersionInfoW function seems to be
				(ERROR_RESOURCE_DATA_NOT_FOUND != dwDummy) &&	// returning ERROR_RESOURCE_DATA_NOT_FOUND instead of ERROR_FILE_NOT_FOUND
				(ERROR_SUCCESS != dwDummy))						// when the file isn't present, so check against this value as well
			{
				LogMessage(MSG_INFO, "Failed to get ODBC Driver version size info");
				bRet = false;
			}
			else
			{
				//the driver isn't present clean up anything lying around
				LogMessage(MSG_INFO, "ODBC Driver <system32>\\wbemdr32.dll not present");
				bDoUninstall = true;
			}
		}
	}
	else
	{
		bRet = false;
	}

	if (bDoUninstall)
	{
		//
		//delete files and registry entries
		//leave ini entries as they were not added by us but by ODBC Mgr
		//

		strBuff[dwSize] = L'\0';
		StringCchCatW(strBuff, MAX_PATH + 30, L"system32\\wbem\\wbemdr32.chm");

		if (!DeleteFileW(strBuff))
		{
			if (ERROR_FILE_NOT_FOUND != GetLastError())
			{
				if (!MoveFileExW(strBuff, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
				{
					bRet = false;
					LogMessage(MSG_INFO, "Failed to delete <system32>\\wbem\\wbemdr32.chm");
				}
				else
				{
					LogMessage(MSG_INFO, "Will delete <system32>\\wbem\\wbemdr32.chm on next reboot");
				}
			}
		}

		strBuff[dwSize] = L'\0';
		StringCchCatW(strBuff, MAX_PATH + 30, L"help\\wbemdr32.chm");

		if (!DeleteFileW(strBuff))
		{
			if (ERROR_FILE_NOT_FOUND != GetLastError())
			{
				if (!MoveFileExW(strBuff, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
				{
					bRet = false;
					LogMessage(MSG_INFO, "Failed to delete <windir>\\help\\wbemdr32.chm");
				}
				else
				{
					LogMessage(MSG_INFO, "Will delete <windir>\\help\\wbemdr32.chm on next reboot");
				}
			}
		}

		LONG lErr = RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\ODBC\\ODBC.INI\\WBEM Source");

		if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
		{
			LogMessage(MSG_INFO, "Failed to delete registry key: SSoftware\\Microsoft\\ODBC\\ODBC.INI\\WBEM Source");
			bRet = false;
		}

		lErr = RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\ODBC\\ODBCINST.INI\\WBEM ODBC Driver");

		if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
		{
			LogMessage(MSG_INFO, "Failed to delete registry key: Software\\Microsoft\\ODBC\\ODBCINST.INI\\WBEM ODBC Driver");
			bRet = false;
		}

		Registry regODBC1("Software\\Microsoft\\ODBC\\ODBC.INI\\ODBC Data Sources");

		if (regODBC1.GetStatus() == no_error)
		{
			if (no_error != regODBC1.DeleteEntry("WBEM Source"))
			{
				if (ERROR_FILE_NOT_FOUND != regODBC1.GetLastError())
				{
					LogMessage(MSG_INFO, "Failed to delete registry value: Software\\Microsoft\\ODBC\\ODBC.INI\\ODBC Data Sources|WBEM Source");
					bRet = false;
				}
			}
		}
		else
		{
			bRet = false;
		}

		Registry regODBC2("Software\\Microsoft\\ODBC\\ODBCINST.INI\\ODBC Drivers");

		if (regODBC2.GetStatus() == no_error)
		{
			if (no_error != regODBC2.DeleteEntry("WBEM ODBC Driver"))
			{
				if (ERROR_FILE_NOT_FOUND != regODBC2.GetLastError())
				{
					LogMessage(MSG_INFO, "Failed to delete registry value: Software\\Microsoft\\ODBC\\ODBCINST.INI\\ODBC Drivers|WBEM ODBC Driver");
					bRet = false;
				}
			}
		}
		else
		{
			bRet = false;
		}
	}

	if (!bRet)
	{
		LogMessage(MSG_ERROR, "A failure in verifying or removing currently installed version of WBEM ODBC.");
	}
	else
	{
		LogMessage(MSG_INFO, "Successfully verified WBEM OBDC adapter (incompatible version removed if it was detected).");
	}

	return bRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\str.h ===
// Copyright (c) 1999 Microsoft Corporation
extern 	char *__g_pszStringBlank;

class CString
{
private:
	char *m_pszString;

	void DeleteString() { if (m_pszString != __g_pszStringBlank) delete [] m_pszString; } 
	char *DuplicateString()
	{
		size_t pszLen = strlen(m_pszString) + 1;
		char *psz = new char[pszLen];
		if (psz == NULL)
			return NULL;
		StringCchCopyA(psz, pszLen, m_pszString);
		return psz;
	}
public:
	CString() 
	{
		m_pszString = __g_pszStringBlank;
	}
	CString (const char *psz)
	{
		size_t pszLen = strlen(psz) + 1;
		m_pszString = new char[pszLen];
		if (m_pszString == 0)
		{
			m_pszString = __g_pszStringBlank;
		}
		else
		{
			StringCchCopyA(m_pszString, pszLen, psz);
		}
	}
	CString (CString &sz)
	{
		m_pszString = __g_pszStringBlank;
		*this = sz.m_pszString;
	}
	~CString() { DeleteString(); }
    size_t Length() const { return strlen(m_pszString); }    //09/17//int Length() const { return strlen(m_pszString); }
    CString& operator +=(const char *psz)
	{
		size_t bufLen = Length() + strlen(psz) + 1;
		char *pszNewString = new char[bufLen];
		if (pszNewString == NULL)
			return *this;
		StringCchCopyA(pszNewString, bufLen, m_pszString);
		StringCchCatA(pszNewString, bufLen, psz);

		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}
	CString &operator = (const char *psz)
	{
		size_t bufLen = strlen(psz) + 1;
		char *pszNewString = new char[bufLen];
		if (pszNewString == 0)
			return *this;
		StringCchCopyA(pszNewString, bufLen, psz);
		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}
	char *Unbind()
	{
		if (m_pszString != __g_pszStringBlank)
		{
			char *psz = m_pszString;
			m_pszString = __g_pszStringBlank;	//should always point to at least the default blank string
			return psz;
		}
		else
			return DuplicateString();
	}
	char operator[](size_t nIndex) const	//09/17//char operator[](int nIndex) const
	{
		if (nIndex > Length())
			nIndex = Length();
		return m_pszString[nIndex];
	}

	operator const char *() { return m_pszString; }
};


class CMultiString
{
private:
	char *m_pszString;

	void DeleteString() { if (m_pszString != __g_pszStringBlank) delete [] m_pszString; } 
	size_t Length(const char *psz) const	//09/17//int Length(const char *psz) const
	{
		size_t nLen = 0;
		while (*psz != '\0')
		{
			nLen += strlen(psz) + 1;
			psz += strlen(psz) + 1;
		}
		return nLen; 
	}
public:
	CMultiString() 
	{
		m_pszString = __g_pszStringBlank;
	}
	CMultiString (const char *psz)
	{
		size_t bufLen = strlen(psz) + 1;
		m_pszString = new char[bufLen];
		if (m_pszString == NULL)
		{
			m_pszString = __g_pszStringBlank;
		}
		else
		{
			StringCchCopyA(m_pszString, bufLen, psz);
		}
	}
	~CMultiString() { DeleteString(); }
    size_t Length() const //09/17//int Length() const
	{ 
		return Length(m_pszString);
	}
    CMultiString& operator +=(const char *psz)
	{
		size_t nLength = Length() + strlen(psz) + 3;
		char *pszNewString = new char[nLength];
		if (pszNewString == NULL)
			return *this;
		memcpy(pszNewString, m_pszString, Length());
		memcpy(pszNewString + Length(), psz, strlen(psz) + 1);
		pszNewString[Length() + strlen(psz) + 1] = '\0';

		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}

	void AddUnique(const char *pszNew)
	{
		bool bFound = false;
		const char *psz = m_pszString;
		while (psz && *psz)
		{
			if (_stricmp(psz, pszNew) == 0)
			{
				bFound = true;
				break;
			}
			psz += strlen(psz) + 1;
		}
		if (!bFound)
		{
			*this += pszNew;
		}
	}
	char operator[](size_t nIndex) const	//09/17//char operator[](int nIndex) const
	{
		if (nIndex > Length())
			nIndex = Length();
		return m_pszString[nIndex];
	}

	operator const char *() { return m_pszString; }

    CMultiString& Empty()
	{
		DeleteString();
		m_pszString = __g_pszStringBlank;
		return *this;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\util.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      util.cpp
 *
 *  Abstract:
 *
 *      This file communicates with  exchange
 *
 *  Author:
 *
 *      Pat Styles (patst) 25-March-1997
 *
 *  Environment:
 *
 *    User Mode
 */

#define _UTIL_CPP_
#define UNICODE
#define _UNICODE
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <tchar.h>
#include <time.h>
#include "ocgen.h"
#pragma hdrstop

TCHAR glabel[] = TEXT("\n[OCGEN] ");

// for logging

#define gsLogFile           TEXT("%windir%\\ocgen.log")
#define gsLogCompletionMsg  TEXT(" - complete\r\n")
#define gsLogInitMsg        TEXT("\r\n\r\nInitialize setup: OCGEN.DLL %s %s\r\n")

// for trace statements

#define gsTrace             TEXT("OCGEN.DLL: Trace")

typedef enum {

    nPreInit,               // OC_PREINITIALIZE
    nInit,                  // OC_INIT_COMPONENT
    nSetLang,               // OC_SET_LANGUAGE
    nQueryImage,            // OC_QUERY_IMAGE
    nRequestPages,          // OC_REQUEST_PAGES
    nQueryChangeSel,        // OC_QUERY_CHANGE_SEL_STATE
    nCalcSpace,             // OC_CALC_DISK_SPACE
    nQueueFile,             // OC_QUEUE_FILE_OPS
    nQueueNot,              // OC_NOTIFICATION_FROM_QUEUE
    nQueryStep,             // OC_QUERY_STEP_COUNT
    nComplete,              // OC_COMPLETE_INSTALLATION
    nCleanup,               // OC_CLEANUP
    nQueryState,            // OC_QUERY_STATE
    nNeedMedia,             // OC_NEED_MEDIA
    nAboutToCommit,         // OC_ABOUT_TO_COMMIT_QUEUE
    nQuerySkip,             // OC_QUERY_SKIP_PAGE  
    nWizardCreated,         // OC_WIZARD_CREATED
    nExtraRoutines,         // OC_EXTRA_ROUTINES
    nMaximum
} notifications;

typedef struct _OcMsgs {
    DWORD  msg;
    TCHAR *desc;
} OcMsgs;

OcMsgs gMsgs[nMaximum] = {
    {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                TEXT("OC_CLEANUP")},
    {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
    {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
};

TCHAR gUnknown[] = TEXT("Unknown Notification: ");

// determines whether or not to display debug info

DWORD gDebugLevel = (DWORD)-1;

// forward reference

TCHAR *NotificationText(DWORD msg);
BOOL  CheckLevel(DWORD level);

/*
 * DebugTrace()
 */

void DebugTrace(DWORD level, const TCHAR *text)
{
    if (!CheckLevel(level))
        return;

    OutputDebugString(text);
}

/*
 * DebugTraceNL()
 *
 * precedes a trace statement with a newline and id prefix
 */

void DebugTraceNL(DWORD level, const TCHAR *text)
{
    DebugTrace(level, glabel);
    DebugTrace(level, text);
}

/*
 * NotificationText()
 */

TCHAR *NotificationText(DWORD msg)
{
    int i;
    static TCHAR desc[S_SIZE];

    for (i = 0; i < nMaximum; i++)
    {
        if (gMsgs[i].msg == msg)
            return gMsgs[i].desc;
    }

    wsprintf(desc, TEXT("OC_%d: "), msg);
    return desc;
}

/*
 * DebugTraceOCNotification()
 */

void DebugTraceOCNotification(DWORD msg, const TCHAR *component)
{
    DebugTraceNL(1, NotificationText(msg));
    DebugTrace(1, TEXT(": "));
    DebugTrace(1, component);
    DebugTrace(1, TEXT(" - "));
}

/*
 * DebugTraceFileCopy()
 */

void DebugTraceFileCopy(const TCHAR *file)
{
    DebugTraceNL(5, TEXT("TreeCopy: FILE="));
    DebugTrace(5, file);
}

/*
 * DebugTraceFileCopyError()
 */

void DebugTraceFileCopyError()
{
    TCHAR buf[S_SIZE];
    
    _stprintf(buf, FMT(" FAILURE CODE:[%d] "), GetLastError());
    DebugTrace(5, buf);
}

/*
 * DebugTraceDirCopy()
 */

void DebugTraceDirCopy(const TCHAR *dir)
{
    DebugTraceNL(3, TEXT("TreeCopy: DIR="));
    DebugTrace(3, dir);
}


/*
 * CheckLevel()
 */

BOOL CheckLevel(DWORD level)
{
    if (gDebugLevel == (DWORD)-1)
        gDebugLevel = SysGetDebugLevel();

    return (gDebugLevel >= level);
}

/*
 * MsgBox
 *
 */

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... )
{
    static BOOL initialize = true;
    static TCHAR caption[S_SIZE];
    TCHAR  text[S_SIZE];
    TCHAR  format[S_SIZE];
    int    len;

    va_list vaList;

    assert(hwnd && textID && type);

    if (initialize)
    {
        len = LoadString(ghinst, IDS_DIALOG_CAPTION, caption, S_SIZE);
        assert(len);
        if (!len) {
            _tcscpy( caption, TEXT("Setup"));
        }
        initialize = false;
    }

    len = LoadString(ghinst, textID, format, S_SIZE);
    assert(len);
    if (!len) {
        _tcscpy( format, TEXT("Unknown Error"));
    }

    va_start(vaList, type);
    tvsprintf(text, format, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MsgBox(HWND hwnd, TCHAR *fmt, TCHAR *caption, UINT type, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(hwnd && text && caption && type);

    va_start(vaList, type);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt && caption);

    va_start(vaList, caption);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, caption, MB_ICONINFORMATION | MB_OK);
}

DWORD TMBox(LPCTSTR fmt, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, gsTrace, MB_ICONINFORMATION | MB_OK);
}

/*
 * SysGetDebugLevel()
 */

DWORD SysGetDebugLevel()
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, 
                     TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), 
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          TEXT("OCGen Debug Level"),
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}

/*
 * TCharStringToAnsiString
 */

DWORD TCharStringToAnsiString(TCHAR *tsz ,char *asz)
{
    DWORD count;

    assert(tsz && asz);

#ifdef UNICODE
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > S_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}

void logOCNotification(DWORD msg, const TCHAR *component)
{
    log(FMT("[%s - %s]"), component, NotificationText(msg));
}

void logOCNotificationCompletion()
{
    log(gsLogCompletionMsg);
}

void loginit()
{
    HANDLE hfile;
    TCHAR  logfile[MAX_PATH];
    char   fmt[S_SIZE];
    char   output[S_SIZE];
    char   time[S_SIZE];
    char   date[S_SIZE];
    DWORD  bytes;

//#ifdef DEBUG
    TCharStringToAnsiString(gsLogInitMsg, fmt);
    _strdate(date);
    _strtime(time);
    sprintf(output, fmt, date, time);

    // open the log file

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(logfile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void log(TCHAR *fmt, ...)
{
    TCHAR  logfile[MAX_PATH];
    TCHAR  text[S_SIZE];
    char   output[S_SIZE];
    DWORD  bytes;
    HANDLE hfile;

    va_list vaList;

//#ifdef DEBUG
    assert(fmt);

    // create the output string

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    TCharStringToAnsiString(text, output);

    // create the log file name in the root directory

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    // open the log file

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void AssureTrailingBackslash(TCHAR *path)
{
    TCHAR *p;
    
    assert(path && *path);

    p = path + _tcslen(path) - 1;
    if (*p != TEXT('\\'))
        _tcscat(path, TEXT("\\"));
}

BOOL IsNT()
{
    DWORD dwver;

    dwver = GetVersion();

    if (dwver < 0x8000000)
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\upgrade.h ===
// Copyright (c) 1999 Microsoft Corporation
#ifndef __UPGRADE_H_
#define __UPGRADE_H_

#include <wbemidl.h>

class CMultiString;
class CString;

#define ToHex(n)					((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define WINMGMT_DBCONVERT_NAME		__TEXT("upgrade.imp")
#define MAX_MSG_TITLE_LENGTH		255		//defined by Bakul for localization
#define MAX_MSG_TEXT_LENGTH			1024	//defined by Bakul for localization
#define INTERNAL_DATABASE_VERSION   9

#define LANG_ID_STR_SIZE			5
extern "C" char g_szLangId[LANG_ID_STR_SIZE];

typedef struct 
{
	const char*	pszMofFilename;				//MOF filename
	int			nInstallType;				//Selection of InstallType items
} MofDataTable;

enum InstallType 
{
	Core	= 1, 
	MUI		= 2
};

enum MsgType
{
	MSG_INFO,
	MSG_WARNING,
	MSG_ERROR,
	MSG_NTSETUPERROR
};

enum
{
	no_error,
	failed,
	critical_error,
	out_of_memory
};

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p = NULL) : m_p(p){}
    ~CDeleteMe() {delete m_p;}

    //  overwrites the previous pointer, does NOT delete it
    void operator= (T* p) {m_p = p;}
};

template<class T>
class CVectorDeleteMe
{
protected:
    T* m_p;
    T** m_pp;

public:
    CVectorDeleteMe(T* p) : m_p(p), m_pp(NULL){}
    CVectorDeleteMe(T** pp) : m_p(NULL), m_pp(pp){}
    ~CVectorDeleteMe() {if(m_p) delete [] m_p; else if(m_pp) delete [] *m_pp;}
};

typedef void (WINAPI *ESCDOOR_BEFORE_MOF_COMPILATION) ();
typedef void (WINAPI *ESCDOOR_AFTER_MOF_COMPILATION) ();

void			CallEscapeRouteAfterMofCompilation();
void			CallEscapeRouteBeforeMofCompilation();
void			ClearWMISetupRegValue();
bool			CopyMultiString(CMultiString &mszFrom, CMultiString &mszTo);
void			DeleteMMFRepository();
bool			DoConvertRepository();
bool			DoCoreUpgrade(int nInstallType=1);
bool			DoWDMNamespaceInit();
bool			DoesFSRepositoryExist();
bool			DoesMMFRepositoryExist();
bool			DoMofLoad(wchar_t* pComponentName, CMultiString& mszSystemMofs);
bool			EnableESS();
bool			ExtractPathAndFilename(const char *pszFullPath, CString &path, CString &filename);
bool			FileExists(const char *pszFilename);
char*			GetFullFilename(const char *pszFilename, InstallType eInstallType=Core);
bool			GetMofList(const char* rgpszMofFilename[], CMultiString &mszMofs);
bool			GetNewMofLists(const char *pszMofList, CMultiString &mszSystemMofs, CMultiString &mszOtherMofs, CString &szMissingMofs);
HRESULT			GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
bool			GetStandardMofs(CMultiString &mszSystemMofs, int nCurInstallType);
bool			IsStandardMof(CMultiString &mszStandardMofList, const char* pszMofFile);
bool			LoadMofList(IWbemContext *, IWinmgmtMofCompiler * pCompiler, const char *mszMofs, CString &szMOFsWhichFailedToLoad, long lOptionFlags = WBEM_FLAG_CONNECT_REPOSITORY_ONLY | WBEM_FLAG_DONT_ADD_TO_LIST, long lClassFlags = WBEM_FLAG_UPDATE_FORCE_MODE);
void			LogMessage(MsgType msgType, const char *pszMessage);
void			LogSetupError(const char *pszMessage);
void			RecordFileVersion();
void			SetWBEMBuildRegValue();
void			ShutdownWinMgmt();
bool			UpgradeAutoRecoveryRegistry(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList, CString &szMissingMofs);
bool			UpgradeRepository();
bool			WipeOutAutoRecoveryRegistryEntries();
bool			WriteBackAutoRecoveryMofs(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList);

HRESULT			MoveRepository();

extern HRESULT UpdateServiceSecurity () ;
extern HRESULT CheckForServiceSecurity () ;

#ifdef _X86_
bool			RemoveOldODBC();
#endif

#endif // __UPGRADE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\advanced.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "advanced.h"
#include "..\common\util.h"
#include "resource.h"
#include "EnvPage.h"
#include "PerfPage.h"
#include "StartupPage.h"
#include "helpid.h"
#include "common.h"


// Help IDs
DWORD aAdvancedHelpIds[] = {
//    IDC_ADV_PERF_TEXT,             (IDH_ADVANCED + 0),
    IDC_ADV_PERF_TEXT,             IDH_COMPUTER_MANAGEMENT_PERFORMANCE_GROUP_BOX,
//    IDC_ADV_PERF_BTN,              (IDH_ADVANCED + 1),
    IDC_ADV_PERF_BTN,              IDH_COMPUTER_MANAGEMENT_PERFORMANCE_SETTINGS_BUTTON,
    IDC_ADV_ENV_TEXT,              (IDH_ADVANCED + 2),
    IDC_ADV_ENV_BTN,               (IDH_ADVANCED + 3),
    IDC_ADV_RECOVERY_TEXT,         (IDH_ADVANCED + 4),
    IDC_ADV_RECOVERY_BTN,          (IDH_ADVANCED + 5),
    0, 0
};

//------------------------------------------------------
AdvancedPage::AdvancedPage(WbemServiceThread *serviceThread,
						   LONG_PTR lNotifyHandle, bool bDeleteHandle, TCHAR* pTitle)
							: WBEMPageHelper(serviceThread),
							CSnapInPropertyPageImpl<AdvancedPage> (pTitle),
									m_lNotifyHandle(lNotifyHandle),
									m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
}

//------------------------------------------------------
AdvancedPage::~AdvancedPage()
{
}

//----------------------------------------------
LRESULT AdvancedPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_hDlg = m_hWnd;

	if(m_serviceThread)
	{
		m_serviceThread->SendPtr(m_hWnd);
	}

	::EnableWindow(GetDlgItem(IDC_ADV_PERF_BTN), FALSE);
	::EnableWindow(GetDlgItem(IDC_ADV_ENV_BTN), FALSE);
	::EnableWindow(GetDlgItem(IDC_ADV_RECOVERY_BTN), FALSE);

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		if(SUCCEEDED(hr))
		{
			SetWbemService(pServices);
			pServices->Release();

			if(ServiceIsReady(NO_UI, 0, 0))
			{
				::EnableWindow(GetDlgItem(IDC_ADV_PERF_BTN), TRUE);
				::EnableWindow(GetDlgItem(IDC_ADV_ENV_BTN), TRUE);
				::EnableWindow(GetDlgItem(IDC_ADV_RECOVERY_BTN), TRUE);
			}
		}
	}

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"sysdm.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)aAdvancedHelpIds);

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"sysdm.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)aAdvancedHelpIds);

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DWORD dwResult = 0;

    switch (wID) 
	{
    case IDC_ADV_PERF_BTN:
		{
			g_fRebootRequired = FALSE;
			PerfPage perfPage(m_serviceThread);
			perfPage.DoModal(m_hDlg);
		}
        break;

    case IDC_ADV_ENV_BTN:
		{
			g_fRebootRequired = FALSE;
			EnvPage envPage(m_serviceThread);
			envPage.DoModal(m_hDlg);
		}
        break;

    case IDC_ADV_RECOVERY_BTN:
		{
			StartupPage startupPage(m_serviceThread);
			if(startupPage.DoModal(m_hDlg) == CLOSE_SNAPIN)
			{
				::PostMessage(GetParent(), WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), 0);
			}
		}
        break;

    default:
        return(FALSE);
    } // switch

    return(TRUE);
}

//----------------------------------------------
BOOL AdvancedPage::OnApply()
{
   // LPPSHNOTIFY psh;//TODO = (LPPSHNOTIFY)pnmh;

	// If the user is pressing "OK" and a reboot is required,
	// OLD WAY: send the PSM_REBOOTSYSTEM message.
	// NEW WAY: use WBEM.
	TCHAR msg[200] = {0};
	TCHAR caption[100] = {0};

	::LoadString(HINST_THISDLL,
					IDS_SYS_CHANGE_CAPTION, 
					caption, 100);

	::LoadString(HINST_THISDLL,
					IDS_MUST_RESTART, 
					msg, 200);

	if(/*(psh->lParam) && */
		g_fRebootRequired && 
		(::MessageBox(m_hDlg, msg, caption,
						MB_YESNO |
						MB_DEFBUTTON1 | 
						MB_ICONQUESTION) == IDYES))
	{
		//OLD WAY: PropSheet_RebootSystem(GetParent(hDlg));

		// call the helper in the base class.
		HRESULT hr = Reboot();

		if(FAILED(hr))
		{
			TCHAR format[100] = {0};
			memset(msg, 0, 200 * sizeof(TCHAR));
			memset(caption, 0, 100 * sizeof(TCHAR));

			::LoadString(HINST_THISDLL,
							IDS_ERR_EXECMETHOD_CAPTION, 
							caption, 100);

			::LoadString(HINST_THISDLL,
							IDS_ERR_EXECMETHOD, 
							format, 100);


            CHString errorDescription;
            CHString errorMessage;
		    ErrorLookup(hr, errorDescription);
            errorMessage.Format(format, errorDescription);

			::MessageBox(m_hWnd, errorMessage, caption,
							MB_OK| MB_ICONEXCLAMATION);
		}
	} // if
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\cmprops.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// CMProps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CMPropsps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
#include "CMProps.h"
#include "..\common\ServiceThread.h"
#include "CMProps_i.c"
#include "CMSnapin.h"


CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CMSnapin, CCMSnapin)
	OBJECT_ENTRY(CLSID_CMSnapinAbout, CCMSnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\cmsnapin.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "CMProps.h"
#include "CMSnapin.h"
#include "GeneralPage.h"
#include "NetIDPage.h"
#include "Advanced.h"

/////////////////////////////////////////////////////////////////////////////
// CCMSnapinComponentData

static const GUID CCMSnapinExtGUID_NODETYPE = 
{ 0x476e6446, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

//dep: static const GUID CCMSnapinExtGUID_NODETYPE = 
//{ 0x4e410f16, 0xabc1, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

const GUID*  CCMSnapinExtData::m_NODETYPE = &CCMSnapinExtGUID_NODETYPE;

//dep: const OLECHAR* CCMSnapinExtData::m_SZNODETYPE = OLESTR("4e410f16-abc1-11d0-b944-00c04fd8d5b0");
const OLECHAR* CCMSnapinExtData::m_SZNODETYPE = OLESTR("476e6446-aaff-11d0-b944-00c04fd8d5b0");

const OLECHAR* CCMSnapinExtData::m_SZDISPLAY_NAME = OLESTR("CMSnapin");
const CLSID* CCMSnapinExtData::m_SNAPIN_CLASSID = &CLSID_CMSnapin;

HRESULT CCMSnapinExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
												LONG_PTR handle, 
												IUnknown* pUnk,
												DATA_OBJECT_TYPES type)
{
//	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
        // refcount at 1 initially
		WbemServiceThread * pserviceThread = new WbemServiceThread;

		GeneralPage* pPage = new GeneralPage(pserviceThread, handle, true, NULL, m_pDataObject);
		lpProvider->AddPage(pPage->Create());

		NetworkIDPage* pPage2 = new NetworkIDPage(pserviceThread, handle);
		lpProvider->AddPage(pPage2->Create());

		AdvancedPage* pPage3 = new AdvancedPage(pserviceThread, handle);
		lpProvider->AddPage(pPage3->Create());

		pserviceThread->Release();
		
		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\advanced.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    advanced.h

Abstract:

    Public declarations for the Advanced tab of the System Control Panel 
    Applet.

Author:

    Scott Hallock (scotthal) 15-Oct-1997

--*/
#ifndef _SYSDM_ADVANCED_H_
#define _SYSDM_ADVANCED_H_
#pragma once

#include "atlsnap.h"
#include "resource.h"
#include "..\Common\WbemPageHelper.h"

//-----------------------------------------------------------------------------
class AdvancedPage : public CSnapInPropertyPageImpl<AdvancedPage>,
						public WBEMPageHelper
{
private:
	BOOL HandleCommand(HWND hDlg,
						WPARAM wParam,
						LPARAM lParam);
	BOOL HandleNotify(HWND hDlg,
						WPARAM wParam,
						LPARAM lParam);
public:

	AdvancedPage(WbemServiceThread *serviceThread,
				LONG_PTR lNotifyHandle, 
				bool bDeleteHandle = false, 
				TCHAR* pTitle = NULL);

	~AdvancedPage();

	enum { IDD = IDD_ADVANCED };

	typedef CSnapInPropertyPageImpl<AdvancedPage> _baseClass;

	BEGIN_MSG_MAP(AdvancedPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnConnected)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
		COMMAND_HANDLER(IDC_ADV_PERF_BTN, BN_CLICKED, CommandHandler)
		COMMAND_HANDLER(IDC_ADV_ENV_BTN, BN_CLICKED, CommandHandler)
		COMMAND_HANDLER(IDC_ADV_RECOVERY_BTN, BN_CLICKED, CommandHandler)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	BOOL OnApply();

	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;

};


#endif // _SYSDM_ADVANCED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\cmsnapin.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __CMSNAPIN_H_
#define __CMSNAPIN_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include <atlsnap.h>
#include "..\common\ServiceThread.h"


class CCMSnapinExtData : public CSnapInItemImpl<CCMSnapinExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;


	CCMSnapinExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CCMSnapinExtData()
	{
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									LONG_PTR handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

};

class CCMSnapin : public CComObjectRootEx<CComSingleThreadModel>,
					public CSnapInObjectRoot<0, CCMSnapin>,
					public IExtendPropertySheetImpl<CCMSnapin>,
					public CComCoClass<CCMSnapin, &CLSID_CMSnapin>,
					public ISnapinHelp
{
public:
	CCMSnapin()
	{
		m_pComponentData = this;
	}

EXTENSION_SNAPIN_DATACLASS(CCMSnapinExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CCMSnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CCMSnapinExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CCMSnapin)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

//DECLARE_REGISTRY_RESOURCEID(IDR_CMSNAPIN)

DECLARE_NOT_AGGREGATABLE(CCMSnapin)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		HRESULT hr;
		TCHAR pName[100] = {0};
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, 
			pName, 100) <= 0)
		{
			wcscpy(pName, _T("System Properties"));
		}

		TCHAR dispName[100] = {0};
        TCHAR szModule[_MAX_PATH+1];
        szModule[_MAX_PATH] = 0;
        ::GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        _stprintf( dispName,_T("@%s,-%d"), szModule, IDS_DISPLAY_NAME);

		
		_ATL_REGMAP_ENTRY regMap[] = {{ OLESTR("PRETTYNAME"), pName },
										{ OLESTR("NAMESTRINGINDIRECT"),dispName},
										{ 0, 0 }};

		hr = _Module.UpdateRegistryFromResourceD(IDR_CMSNAPIN, TRUE, regMap);

		return hr;
	}


	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile)
	{
		if(lpCompiledHelpFile == NULL)
			return E_POINTER;    

		wchar_t helpDir[_MAX_PATH];
		memset(helpDir, 0, _MAX_PATH);

		if(GetWindowsDirectory(helpDir, _MAX_PATH) != 0)
		{
			wcscat(helpDir, L"\\Help");
			wcscat(helpDir, L"\\sysprop.chm");

			*lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(helpDir) + 1) * 
															sizeof(wchar_t)));

			if(*lpCompiledHelpFile == NULL)        
				return E_OUTOFMEMORY;

			USES_CONVERSION;
			wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)helpDir));
			return S_OK;
		}
		return E_UNEXPECTED;
	}
};

class ATL_NO_VTABLE CCMSnapinAbout : public ISnapinAbout,
									public CComObjectRoot,
									public CComCoClass< CCMSnapinAbout, &CLSID_CMSnapinAbout>
{
public:
	DECLARE_REGISTRY(CCMSnapinAbout, _T("CMSnapinAbout.1"), _T("CMSnapinAbout.1"), IDS_CMSNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CCMSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_CMSNAPIN_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_CMSNAPIN_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_COMPUTER));
		return S_OK;
	}

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF *cMask)
	{
		*hSmallImage = *hSmallImageOpen = LoadBitmap(_Module.GetResourceInstance(), 
														MAKEINTRESOURCE(IDB_CMSNAPIN_16));
		
		*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_CMSNAPIN_32));
		*cMask = RGB(255,255,255);

		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\common.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Shared Dialog code
//
// 3-11-98 sburns



#ifndef COMMON_HPP_INCLUDED
#define COMMON_HPP_INCLUDED

#include <chstring.h>

// translates an hresult to an error string
// special cases WMI errors
// returns TRUE if lookup successful
bool ErrorLookup(HRESULT hr, CHString& message);

void
AppError(
   HWND           parent,
   HRESULT        hr,
   const CHString&  message);



void
AppMessage(HWND parent, const CHString& message);



void
AppMessage(HWND parent, int messageResID);



#endif   // COMMON_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\edtenvar.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.h

Abstract:

    Public declarations for the Edit Environment Variables dialog of the
    System Control Panel Applet
    
Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:


--*/
#pragma once

//
// Preprocessor definitions
//
#define SYSTEM_VAR        1
#define USER_VAR          2
#define INVALID_VAR_TYPE  0xeeee

#define EDIT_VAR          1
#define NEW_VAR           2
#define INVALID_EDIT_TYPE 0xeeee

#define EDIT_NO_CHANGE    0
#define EDIT_CHANGE       1
#define EDIT_ERROR       (-1)

#define EDIT_ENVVAR_CAPTION_LENGTH 128

//
// Global variables
//
#define BUFZ        4096

extern UINT g_VarType;
extern UINT g_EditType;
extern TCHAR g_szVarName[BUFZ];
extern TCHAR g_szVarValue[BUFZ];

//
// Function prototypes
//
INT_PTR APIENTRY EnvVarsEditDlg(
						IN HWND hDlg,
						IN UINT uMsg,
						IN WPARAM wParam,
						IN LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\edtenvar.cpp ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.h

Abstract:

    Implements the Edit Environment Variables dialog of the
    System Control Panel Applet

Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:

--*/
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "edtenvar.h"
#include "resource.h"
#include "..\common\util.h"

// Global Variables
UINT g_VarType = INVALID_VAR_TYPE;
UINT g_EditType = INVALID_EDIT_TYPE;
TCHAR g_szVarName[BUFZ];
TCHAR g_szVarValue[BUFZ];

// Help IDs
/*DWORD aEditEnvVarsHelpIds[] = {
    IDC_ENVVAR_EDIT_NAME_LABEL,  (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_NAME,        (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_VALUE_LABEL, (IDH_ENV_EDIT + 1),
    IDC_ENVVAR_EDIT_VALUE,       (IDH_ENV_EDIT + 1),
    0, 0
};
*/

// Function prototypes
BOOL InitEnvVarsEdit(HWND hDlg);
BOOL EnvVarsEditHandleCommand(HWND hDlg,
								WPARAM wParam,
								LPARAM lParam);

// Function implementation
//------------------------------------------------
INT_PTR APIENTRY EnvVarsEditDlg(HWND hDlg,
							UINT uMsg,
							WPARAM wParam,
							LPARAM lParam)
/*++

Routine Description:

    Handles messages sent to the New.../Edit... dialog.

Arguments:

    hDlg -
        Supplies the window handle

    uMsg -
        Supplies the message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled.
    FALSE if message was unhandled.

--*/
{
    BOOL fInitializing = FALSE;

    switch (uMsg) {
        case WM_INITDIALOG: {
            BOOL fSuccess = FALSE;

            fInitializing = TRUE;

            fSuccess = InitEnvVarsEdit(hDlg);
            if (!fSuccess) {
                EndDialog(hDlg, EDIT_ERROR);
            } // if

            fInitializing = FALSE;
            break;
        } // case WM_INITDIALOG

        case WM_COMMAND:
            return EnvVarsEditHandleCommand(hDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
//            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD) (LPSTR) aEditEnvVarsHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
//            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD) (LPSTR) aEditEnvVarsHelpIds);
            break;

        default:
            return(FALSE);
            break;

    } // switch (uMsg)

    return(TRUE);
}

//------------------------------------------------
BOOL InitEnvVarsEdit(HWND hDlg)
/*++

Routine Description:

    Initializes the Edit Environment Variables dialog by placing initial
    values into the text editing controls if necessary.

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szCaption[EDIT_ENVVAR_CAPTION_LENGTH] = {0};
    BOOL fRetVal = FALSE;
    INT  nResult = 0;

    __try {
        // limit variable names to 259 chars (arbitrary value, but will be in line with shell UI)
        SendDlgItemMessage(hDlg, IDC_ENVVAR_EDIT_NAME, EM_LIMITTEXT, 259, 0);
        // limit variable values to 1023 chars (arbitrary value, but will be in line with shell UI)
        SendDlgItemMessage(hDlg, IDC_ENVVAR_EDIT_VALUE, EM_LIMITTEXT, 1023, 0);

        switch (g_EditType) {
            //
            // If this is to be a New.. dialog, we only need to
            // load the proper capiton for the variable type
            //
            case NEW_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_NEW_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    case USER_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_NEW_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    default:
                        __leave;
                        break;
                } // switch (g_VarType)

                break;

            //
            // If this is to be an Edit.. dialog, then we need to load the
            // proper caption and fill in initial values for the edit
            // controls
            //
            case EDIT_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_EDIT_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                     case USER_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_EDIT_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;
    
                    default:
                         __leave;
                        break;
                } // switch (g_VarType)
        
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_NAME,
                    g_szVarName
                );
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_VALUE,
                    g_szVarValue
                );
        
                break;
        } // switch (g_EditType)

        fRetVal = SendMessage(
                GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
                EM_SETSEL,
                0,
                -1
        ) ? TRUE : FALSE;
        fRetVal = SendMessage(
                GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
                EM_SETSEL,
                0,
                -1
        ) ? TRUE : FALSE;
        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME));

        fRetVal = SetWindowText(hDlg, szCaption);

    } // __try
    __finally {
        //
        // Nothing to clean up.  __try is only there for __leave on
        // failure capability.
        //
    } // __finally

    return(fRetVal);
}

//------------------------------------------------
BOOL EnvVarsEditHandleCommand(HWND hDlg,
								WPARAM wParam,
							    LPARAM lParam)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to the Edit Environment Variables
    dialog

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_NAME,
                g_szVarName,
                BUFZ
            );
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_VALUE,
                g_szVarValue,
                BUFZ
            );
            EndDialog(hDlg, EDIT_CHANGE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, EDIT_NO_CHANGE);
            break;

        default:
            return(FALSE);
            break;

    } // switch (LOWORD(wParam))

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\common.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Shared Dialog code
//
// 3-11-98 sburns


#include "precomp.h"
#include "resource.h"
#include "common.h"

// translates an hresult to an error string
// special cases WMI errors
// returns TRUE if lookup successful
bool ErrorLookup(HRESULT hr, CHString& message)
{
    bool bRet = false;

    const HRESULT WMIErrorMask = 0x80041000;
    TCHAR buffer[MAX_PATH +2];  
    HMODULE hLib;
    TCHAR* pOutput = NULL;

    // if in this range, we'll see if wbem claims it
    if ((hr >= WMIErrorMask) && (hr <= (WMIErrorMask + 0xFFF))
        && ExpandEnvironmentStrings(L"%windir%\\system32\\wbem\\wmiutils.dll", buffer, MAX_PATH)
        && (hLib = LoadLibrary(buffer)))
    {
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                      FORMAT_MESSAGE_FROM_HMODULE | 
                      FORMAT_MESSAGE_FROM_SYSTEM,
                      hLib, hr, 0, (LPWSTR)&pOutput, 0, NULL);
        FreeLibrary(hLib);
    }
    else
    {
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                      FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL, hr, 0, (LPWSTR)&pOutput, 0, NULL);
    }

    if (pOutput)
    {
        bRet = true;
        message = pOutput;
        LocalFree(pOutput);
    }

    return bRet;
}

void AppError(HWND           parent,
			   HRESULT        hr,
			   const CHString&  message)
{

   //TODOerror(parent, hr, message, IDS_APP_TITLE);
}

void AppMessage(HWND parent, int messageResID)
{
   //TODOAppMessage(parent, String::load(messageResID));
}

void AppMessage(HWND parent, const CHString& message)
{

   /*TODOMessageBox(parent,
			  message,
			  CHString::load(IDS_APP_TITLE),
			  MB_OK | MB_ICONINFORMATION);
			  */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\envvar.h ===
//*************************************************************
//
//  Envvar.h   -    Header file for envvar.c
//
//  Microsoft Confidential
//  Copyright (c) 1996-1999 Microsoft Corporation
//  All rights reserved
//
//*************************************************************

#define MAX_USER_NAME   100


HPROPSHEETPAGE CreateEnvVarsPage (HINSTANCE hInst);
BOOL APIENTRY EnvVarsDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int GetSelectedItem (HWND hCtrl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\envpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __ENVPAGE__
#define __ENVPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"
#include "..\common\simplearray.h"
//-----------------------------------------------------------------------------
class EnvPage : public WBEMPageHelper
{
private:

	class ENVARS
	{
	public:
		bool   changed;
		LPTSTR userName;
		LPTSTR objPath;
		LPTSTR szValueName;
		LPTSTR szValue;
		LPTSTR szExpValue;
		ENVARS()
		{
			changed = false;
			objPath = NULL;
			userName = NULL;
            szValueName = NULL;
            szValue = NULL;
            szExpValue = NULL;
		}
		~ENVARS()
		{
			delete[] userName;
			delete[] objPath;
            delete[] szValueName;
            delete[] szValue;
            delete[] szExpValue;
		}
	};

	BOOL m_bEditSystemVars;
	BOOL m_bUserVars;
	bool m_currUserModified;
	bool m_SysModified;
	bstr_t m_currentUser;
	bool m_bLocal;

	void LoadUser(IWbemClassObject *envInst, 
					bstr_t userName, 
					HWND hwndUser);
	bool IsLoggedInUser(_bstr_t userName);
	void GetLoggedinUser(bstr_t *userName);

	BOOL Init(HWND hDlg);
	void CleanUp (HWND hDlg);
	void Save(HWND hDlg, int ID);
	int FindVar (HWND hwndLV, LPTSTR szVar);
	int GetSelectedItem (HWND hCtrl);
	void DoCommand(HWND hDlg, 
					HWND hwndCtl, 
					int idCtl, 
					int iNotify );
	int AddUniqueUser(HWND hwnd, LPCTSTR str);
	void EmptyListView(HWND hDlg, int ID);
	void DeleteVar(HWND hDlg,
					UINT VarType,
					LPCTSTR szVarName);
	void SetVar(HWND hDlg,
				UINT VarType,
				LPCTSTR szVarName,
				LPCTSTR szVarValue);
	void DoEdit(HWND hWnd,
				UINT VarType,
				UINT EditType,
				int iSelection);
	ENVARS *GetVar(HWND hDlg, 
					UINT VarType, 
					int iSelection);


	// deletions are saved here until committed.
	typedef CSimpleArray<ENVARS *> ENVLIST;
	ENVLIST m_killers;

	void KillLater(ENVARS *var);
	void KillThemAllNow(void);

public:

    EnvPage(WbemServiceThread *serviceThread);
	~EnvPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticEnvDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __ENVPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\envpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "EnvPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include "..\common\SshWbemHelpers.h"
#include <windowsx.h>
#include <commctrl.h>
#include "edtenvar.h"
#include "helpid.h"
#include "common.h"

// plagiarized without remorse from other WMI headers.
template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p) : m_p(p){}
    ~CDeleteMe() {delete m_p;}
};

// shows dialog box with exclamation icon
// expects strID string to be of the form:
// "Some thing bad happened for user %s: %s"
// where the second %s will be filled by format message applied to the hr
void EnvVarErrorDialog(HWND hParent, UINT strID, BSTR user, HRESULT hr)
{
    CHString errorDescription;
    CHString errorMessage;
    
    TCHAR formatString[1024];                        
	::LoadString(HINST_THISDLL, strID,  
                    formatString, 1024);

    TCHAR errorHeading[40];
    ::LoadString(HINST_THISDLL,IDS_ERR_HEADING,
                    errorHeading, 40);
	
	ErrorLookup(hr, errorDescription);        
    errorMessage.Format(formatString, user, errorDescription);

	::MessageBox(hParent,errorMessage,errorHeading, MB_OK | MB_ICONEXCLAMATION);
}


DWORD aEnvVarsHelpIds[] = {
    IDC_ENVVAR_SYS_USERGROUP,     IDH_NO_HELP,
    IDC_ENVVAR_SYS_LB_SYSVARS,    (IDH_ENV + 0),
    IDC_ENVVAR_SYS_SYSVARS,       (IDH_ENV + 0),
    IDC_ENVVAR_SYS_USERENV,       (IDH_ENV + 2),
    IDC_ENVVAR_SYS_LB_USERVARS,   (IDH_ENV + 2),
    IDC_ENVVAR_SYS_NEWUV,         (IDH_ENV + 7),
    IDC_ENVVAR_SYS_EDITUV,        (IDH_ENV + 8),
    IDC_ENVVAR_SYS_NDELUV,        (IDH_ENV + 9),
    IDC_ENVVAR_SYS_NEWSV,         (IDH_ENV + 10),
    IDC_ENVVAR_SYS_EDITSV,        (IDH_ENV + 11),
    IDC_ENVVAR_SYS_DELSV,         (IDH_ENV + 12),
    IDC_USERLIST,				  IDH_WBEM_ADVANCED_ENVARIABLE_USERVAR_LISTBOX,
	0,								0
};

//----------------------------------------------------------------------
INT_PTR CALLBACK StaticEnvDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	EnvPage *me = (EnvPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}

//--------------------------------------------------------------
EnvPage::EnvPage(WbemServiceThread *serviceThread)
						: WBEMPageHelper(serviceThread)
{
	m_bEditSystemVars = FALSE;
	m_bUserVars = FALSE;
	m_currUserModified = false;
	m_SysModified = false;

}

//--------------------------------------------------------------
INT_PTR EnvPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_ENVVARS),
						hDlg, StaticEnvDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
EnvPage::~EnvPage()
{
}

//--------------------------------------------------------------
INT_PTR CALLBACK EnvPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
    int i;

	m_hDlg = hwndDlg;

	switch (message) 
	{
	case WM_INITDIALOG:
		Init(m_hDlg);
		return TRUE; 
		break;

    case WM_NOTIFY:

        switch(((NMHDR FAR*)lParam)->code)
        {
        case LVN_KEYDOWN:
            switch(((NMHDR FAR*)lParam)->idFrom) 
			{
            case IDC_ENVVAR_SYS_LB_USERVARS:
                i = IDC_ENVVAR_SYS_NDELUV;
                break;
            case IDC_ENVVAR_SYS_LB_SYSVARS:
                i = IDC_ENVVAR_SYS_DELSV;
                break;
            default:
                return(FALSE);
                break;
            } // switch

            if(VK_DELETE == ((LV_KEYDOWN FAR *) lParam)->wVKey) 
			{
				HWND hwnd = GetDlgItem(m_hDlg, i);
				if(IsWindowEnabled(hwnd))
				{
					SendMessage(m_hDlg, WM_COMMAND,
									MAKEWPARAM(i, BN_CLICKED),
									(LPARAM)hwnd );
				}
				else
				{
					MessageBeep(MB_ICONASTERISK);
				}
            } // if (VK_DELETE...
            break;

        case NM_SETFOCUS:
            if(wParam == IDC_ENVVAR_SYS_LB_USERVARS) 
			{
                m_bUserVars = TRUE;
            } 
			else 
			{
                m_bUserVars = FALSE;
            }
            break;

        case NM_DBLCLK:
			{ //BEGIN
				HWND hWndTemp;

				switch(((NMHDR FAR*)lParam)->idFrom) 
				{
				case IDC_ENVVAR_SYS_LB_USERVARS:
					i = IDC_ENVVAR_SYS_EDITUV;
					break;

				case IDC_ENVVAR_SYS_LB_SYSVARS:
					i = IDC_ENVVAR_SYS_EDITSV;
					break;

				default:
					return(FALSE);
					break;
				} // switch

				hWndTemp = GetDlgItem(m_hDlg, i);

				if(IsWindowEnabled(hWndTemp)) 
				{
					SendMessage(m_hDlg, WM_COMMAND, 
								MAKEWPARAM(i, BN_CLICKED),
								(LPARAM)hWndTemp);
				} 
				else 
				{
					MessageBeep(MB_ICONASTERISK);
				}
			}//END
            break;

        default:
            return FALSE;
        } //endswitch(((NMHDR FAR*)lParam)->code)
        break;

    case WM_COMMAND:
        DoCommand(m_hDlg, (HWND)lParam, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_DESTROY:
        CleanUp(m_hDlg);
        break;

    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aEnvVarsHelpIds);

        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, 
					HELP_FILE, HELP_CONTEXTMENU, 
					(ULONG_PTR)(LPSTR)aEnvVarsHelpIds);
        break;

    default:
        return FALSE;
    }

	return FALSE; 
}

//------------------------------------------------------------
int EnvPage::AddUniqueUser(HWND hwnd, LPCTSTR str)
{
	// if it doesn't already exist...
	if(ComboBox_FindStringExact(hwnd, -1, str) == CB_ERR)
	{
		// add it.
		return ComboBox_AddString(hwnd, str);
	}
	return -1;
}

//------------------------------------------------------------
#define MAX_USER_NAME   100
#define BUFZ        4096
#define MAX_VALUE_LEN     1024
TCHAR szSysEnv[]  = TEXT( "System\\CurrentControlSet\\Control\\Session Manager\\Environment" );

BOOL EnvPage::Init(HWND hDlg)
{
    TCHAR szBuffer1[200] = {0};
    HWND hwndSys, hwndUser, hwndUserList;
	HRESULT hr = 0;

    LV_COLUMN col;
    LV_ITEM item;
    RECT rect;
    int cxFirstCol;
    unsigned int MaxScrollExtent = 0;

	IWbemClassObject *envInst = NULL;
	IEnumWbemClassObject *envEnum = NULL;
	bool bSysVar = false;
	DWORD uReturned = 0;
	bstr_t sSysUser("<SYSTEM>");  // magic string returned by provider
	bstr_t sUserName("UserName");
	bstr_t userName, firstUser;
	variant_t pVal, pVal1;

    // Create the first column
    LoadString(HINST_THISDLL, SYSTEM + 50, szBuffer1, 200);

    if (!GetClientRect(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS), &rect)) 
	{
        rect.right = 300;
    }

    cxFirstCol = (int)(rect.right * .3);

    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = cxFirstCol;
    col.pszText = szBuffer1;
    col.iSubItem = 0;

    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);

    // Create the second column
    LoadString(HINST_THISDLL, SYSTEM + 51, szBuffer1, 200);

    col.cx = rect.right - cxFirstCol - GetSystemMetrics(SM_CYHSCROLL);
    col.iSubItem = 1;

    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);

    ////////////////////////////////////////////////////////////////////
    // Display System Variables from wbem in listbox
    ////////////////////////////////////////////////////////////////////
    hwndSys = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
    hwndUser = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
    hwndUserList = GetDlgItem(hDlg, IDC_USERLIST);

    //  Try to open the System Environment variables area with
    //  Read AND Write permission.  If successful, then we allow
    //  the User to edit them the same as their own variables.
	m_bEditSystemVars = FALSE;
	RemoteRegWriteable(szSysEnv, m_bEditSystemVars);


    // Disable System Var Editing buttons if
    // user is not an administrator
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_NEWSV),
					m_bEditSystemVars);
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_EDITSV),
					m_bEditSystemVars);
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_DELSV),
					m_bEditSystemVars);

	if(m_serviceThread->m_machineName.length() > 0)
		m_bLocal = false;
	else
		m_bLocal = true;

	if((hr = m_WbemServices.CreateInstanceEnum(bstr_t("Win32_Environment"), 
												WBEM_FLAG_SHALLOW, 
												&envEnum)) == S_OK)
	{
		// get the first and only instance.
		while(SUCCEEDED(envEnum->Next(-1, 1, &envInst, &uReturned)) && 
			  (uReturned != 0))
		{
			//Get whether the 
			// who's variable.
			if(envInst->Get(sUserName, 0L, &pVal, NULL, NULL) == S_OK) 
			{
				userName = V_BSTR(&pVal);
                
				if( userName.length() > MaxScrollExtent ){

					 MaxScrollExtent = userName.length();
				}

				 // setup for which list box gets this instance.
				if(userName == sSysUser)
				{
					LoadUser(envInst, userName, hwndSys);
				}
				else 
				{
					if(m_bLocal == false)
					{
						if((firstUser.length() == 0) ||	// if the first user seen.
							(firstUser == userName))		// if seeing the firstUser again.
						{
							// save the first user.
							if(firstUser.length() == 0)
							{
								firstUser = userName;
							}
							AddUniqueUser(hwndUserList, userName);
							LoadUser(envInst, userName, hwndUser);
						}
						else
						{
							AddUniqueUser(hwndUserList, userName);
						}
					}
					else
					{
						if(IsLoggedInUser(userName))
						{
							if(firstUser.length() == 0)
							{
								firstUser = userName;
							}
							AddUniqueUser(hwndUserList, userName);
							LoadUser(envInst, userName, hwndUser);
						}
						else
						{
							AddUniqueUser(hwndUserList, userName);
						}
					}
				}
			} //endif who's variable.

			envInst->Release();

		} // endwhile envEnum

		envEnum->Release();

 		SendMessage( 
			hwndUserList,              	// handle to destination window 
			CB_SETHORIZONTALEXTENT,    	// message to send
			(WPARAM) (MaxScrollExtent * 8 ),// scrollable width
			0                          	// not used; must be zero
		);

        if(m_bLocal == false)
		{
			ComboBox_SetCurSel(hwndUserList, 0);
		}
		else
		{
			_bstr_t strLoggedinUser;
			GetLoggedinUser(&strLoggedinUser);
			SendMessage(hwndUserList,CB_SELECTSTRING,-1L,(LPARAM)(LPCTSTR)strLoggedinUser);
		}
	} //endif CreateInstanceEnum()

    // Select the first items in the listviews
    // It is important to set the User listview first, and
    // then the system.  When the system listview is set,
    // we will receive a LVN_ITEMCHANGED notification and
    // clear the focus in the User listview.  But when someone
    // tabs to the control the arrow keys will work correctly.
    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);

    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_SETUV), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_DELUV), FALSE);

    // Set extended LV style for whole line selection
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//  FindVar  
//
//  Find the USER Environment variable that matches passed string
//  and return its listview index or -1
//
////////////////////////////////////////////////////////////////////////////
int EnvPage::FindVar(HWND hwndLV, LPTSTR szVar)
{
    LV_FINDINFO FindInfo;

    FindInfo.flags = LVFI_STRING;
    FindInfo.psz = szVar;

    int n = ((int)SendMessage (hwndLV, LVM_FINDITEM, (WPARAM) -1, (LPARAM) &FindInfo)); 

    // list view seems to have trouble with long names, let's try it "by hand"
    if ((n == -1) && (_tcslen(szVar) > 200))
    {
        TCHAR* pBuf;
        int iCount = ListView_GetItemCount(hwndLV);
        LVITEM item;
        item.mask = LVIF_TEXT;
        item.iSubItem = 0;
        item.stateMask = 0;
        item.pszText = pBuf = new TCHAR[BUFZ +1];
        item.cchTextMax = BUFZ;

        if (pBuf)
        {
            for (int i = 0; i < iCount; i++)
            {
                // 'cuz the list view might change it??! (so say the docs)
                item.pszText = pBuf;

                item.iItem = i;
                if (ListView_GetItem(hwndLV, &item) && (0 == _tcsicmp(item.pszText, szVar)))
                {
                    n = i;
                    break;
                }
            }

            delete[] pBuf;
        }
    }

    return n;
}

////////////////////////////////////////////////////////////////////////////
//  Saves the environment variables
//  pops up error dialog on error.
////////////////////////////////////////////////////////////////////////////
void EnvPage::Save(HWND hDlg, int ID)
{
    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
	CWbemClassObject inst;
	bstr_t sSysUser("<SYSTEM>");  // magic string returned by provider
	bstr_t sUserName("UserName");
	bstr_t sVarName("Name");
	bstr_t sVarVal("VariableValue");
	bstr_t sSysVar("SystemVariable");
	HRESULT hr = 0;

    // track separately, since the hr could get reset in the loop.
    HRESULT hrFailure = 0;
    int iFailure;

    LV_ITEM item;
    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

	// purge the kill list.
	KillThemAllNow();

    hwndTemp = GetDlgItem (hDlg, ID);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    for(i = 0; i < n; i++) 
	{
        item.iItem = i;

        if(SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
            penvar = (ENVARS *) item.lParam;

			// if something changed.
			if(penvar->changed)
			{
				// if we need a new class object...
				if(penvar->objPath == NULL)
				{
					// must be a new one.
					CWbemClassObject cl = m_WbemServices.GetObject("Win32_Environment");
					inst = cl.SpawnInstance();
				}
				else
				{
					// get the old one.
					inst = m_WbemServices.GetObject(penvar->objPath);
				}

				if(!inst.IsNull())
				{
					if(ID == IDC_ENVVAR_SYS_LB_SYSVARS)
					{
						hr = inst.Put(sUserName, sSysUser);
						hr = inst.Put(sSysVar, true);
					}
					else if(ID == IDC_ENVVAR_SYS_LB_USERVARS)
					{
						hr = inst.Put(sUserName, m_currentUser);
						hr = inst.Put(sSysVar, false);
					}
					else
					{
						continue;
					}
					hr = inst.Put(sVarName, bstr_t(penvar->szValueName));
					hr = inst.Put(sVarVal, bstr_t(penvar->szExpValue));
					hr = m_WbemServices.PutInstance(inst);

                    if (FAILED(hr))
                    {
                        hrFailure = hr;
                        iFailure = i;
                    }
				}
	
			} //endif changed
        } 

    } //endfor

    if (FAILED(hrFailure))
        EnvVarErrorDialog(hDlg, IDS_ERR_ENVVAR_SAVE, 
                          IDC_ENVVAR_SYS_LB_SYSVARS ?  (BSTR)sSysUser : (BSTR)m_currentUser,
                          hrFailure);
}

////////////////////////////////////////////////////////////////////////////
//  EmptyListView
//
//  Frees memory allocated for environment variables
//
//  History:
//  19-Jan-1996 EricFlo Wrote it
////////////////////////////////////////////////////////////////////////////
void EnvPage::EmptyListView(HWND hDlg, int ID)
{
    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;

    //  Free alloc'd strings and memory for list box items.
    hwndTemp = GetDlgItem (hDlg, ID);
    n = (int) SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for(i = 0; i < n; i++) 
	{
        item.iItem = i;

        if(SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
            penvar = (ENVARS *) item.lParam;
        } 
		else 
		{
            penvar = NULL;
        }

        delete penvar;
    }
	ListView_DeleteAllItems(hwndTemp);
}

//------------------------------------------------------------
void EnvPage::CleanUp (HWND hDlg)
{
	EmptyListView(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
	EmptyListView(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
}

//----------------------------------------------------------------------
void EnvPage::DeleteVar(HWND hDlg,
						UINT VarType,
						LPCTSTR szVarName)
/*++

Routine Description:

    Deletes an environment variable of a given name and type

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type (user or system)

    szVarName -
        Supplies variable name

Return Value:

    None, although it really should have one someday.

--*/
{
    // TCHAR   szTemp2[MAX_PATH] = {0};
    TCHAR*  pszName;

    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;

    pszName = new TCHAR[_tcslen(szVarName) +2];
    if (!pszName)
        return; // see comment about return value...

    CDeleteMe<TCHAR> delName(pszName);

    // Delete listbox entry that matches value in szVarName
    //  If found, delete entry else ignore
    wsprintf(pszName, TEXT("%s"), szVarName);

    if(pszName[0] == TEXT('\0'))
        return;

    //  Determine which Listbox to use (SYSTEM or USER vars)
    switch(VarType) 
	{
    case SYSTEM_VAR:
        i = IDC_ENVVAR_SYS_LB_SYSVARS;
        break;

    case USER_VAR:
    default:
        i = IDC_ENVVAR_SYS_LB_USERVARS;
        break;

    } // switch (VarType)

    hwndTemp = GetDlgItem(hDlg, i);

    n = FindVar(hwndTemp, pszName);

    if(n != -1)
    {
        // Free existing strings (listbox and ours)
        item.mask = LVIF_PARAM;
        item.iItem = n;
        item.iSubItem = 0;

        if(SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
            penvar = (ENVARS *) item.lParam;

			// if cimom knows about it...
			if(penvar->objPath != NULL) 
			{
				// queue for later DeleteInstance().
				KillLater(penvar);

				if(m_bUserVars)
					m_currUserModified = true;
				else
					m_SysModified = true;

			}
			else // user must have added it and changed his mind..
			{
				// just forget about it.
				penvar = (ENVARS *) item.lParam;
		        delete penvar;
			} 
        } 
		else 
		{
            penvar = NULL;
        }

        SendMessage (hwndTemp, LVM_DELETEITEM, n, 0L);
        PropSheet_Changed(GetParent(hDlg), hDlg);

        // Fix selection state in listview
        if(n > 0) 
		{
            n--;
        }

        item.mask = LVIF_STATE;
        item.iItem = n;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendDlgItemMessage(hDlg, i,
                            LVM_SETITEMSTATE, n, (LPARAM) &item);

    }
}

//----------------------------------------------------------------------
void EnvPage::SetVar(HWND hDlg,
						UINT VarType,
						LPCTSTR szVarName,
						LPCTSTR szVarValue)
/*++

Routine Description:

    Given an environment variable's type (system or user), name, and value,
    creates a ENVVARS structure for that environment variable and inserts
    it into the proper list view control, deleteing any existing variable
    of the same name.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies the type of the environment variable (system or user)

    szVarName -
        Supplies the name of the environment variable

    szVarValue -
        Supplies the value of the environment variable

Return Value:

    None, although it really should have one someday.

--*/
{
    //TCHAR   szTemp2[MAX_PATH] = {0};
    TCHAR*  pszName;
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    LPTSTR  pszString;
    HWND    hwndTemp;
    int     idTemp;
    ENVARS *penvar = NULL;
    LV_ITEM item;

    pszName = new TCHAR[_tcslen(szVarName) +2];
    if (!pszName)
        return; // see comment about return value...

    CDeleteMe<TCHAR> delName(pszName);

    wsprintf(pszName, TEXT("%s"), szVarName);

    //  Strip trailing whitespace from end of Env Variable
    i = lstrlen(pszName) - 1;

    while(i >= 0)
    {
        if (_istspace(pszName[i]))
            pszName[i--] = TEXT('\0');
        else
            break;
    }

    // Make sure variable name does not contain the "=" sign.
    pszTemp = _tcspbrk (pszName, TEXT("="));

    if(pszTemp)
        *pszTemp = TEXT('\0');

    if(pszName[0] == TEXT('\0'))
        return;

    bBuffer = new TCHAR[BUFZ];
    pszString = (LPTSTR)new TCHAR[BUFZ];

    wsprintf(bBuffer, TEXT("%s"), szVarValue);

    //  Determine which Listbox to use (SYSTEM or USER vars)
    switch (VarType) 
	{
    case SYSTEM_VAR:
        idTemp = IDC_ENVVAR_SYS_LB_SYSVARS;
        break;

    case USER_VAR:
    default:
        idTemp = IDC_ENVVAR_SYS_LB_USERVARS;
        break;

    } // switch (VarType)

    hwndTemp = GetDlgItem(hDlg, idTemp);

    n = FindVar(hwndTemp, pszName);

    if (n != -1)
    {
        // Free existing strings (listview and ours)
        item.mask = LVIF_PARAM;
        item.iItem = n;
        item.iSubItem = 0;

        if(SendMessage(hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
			// we're just changing an old one.
            penvar = (ENVARS *) item.lParam;
            delete penvar->szValueName;
            delete penvar->szValue;
            delete penvar->szExpValue;
        } 
		else 
		{
            penvar = NULL;
        }

        SendMessage (hwndTemp, LVM_DELETEITEM, n, 0L);
    }
    
	if(penvar == NULL)
    {
        // Get some storage for new EnVar.
        penvar = new ENVARS;
		if (penvar == NULL)
			return;
		penvar->userName = CloneString(m_currentUser);
    }

	if((m_bLocal == true) && ((VarType == SYSTEM_VAR) || (IsLoggedInUser(penvar->userName))))
	{
		ExpandEnvironmentStrings(bBuffer, pszString, BUFZ);
	}
	else
	{
		_tcscpy(pszString,bBuffer);
	}

    if (penvar == NULL)
	return;
    penvar->szValueName = CloneString(pszName);
    penvar->szValue     = CloneString(bBuffer);
    penvar->szExpValue  = CloneString(pszString);
	penvar->changed		= true;

    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.iItem = ListView_GetItemCount(hwndTemp);
    item.iSubItem = 0;
    item.pszText = penvar->szValueName;
    item.lParam = (LPARAM) penvar;

    n = (int) SendMessage(hwndTemp, LVM_INSERTITEM, 0, (LPARAM) &item);

    if (n != -1) 
	{
        item.mask = LVIF_TEXT;
        item.iItem = n;
        item.iSubItem = 1;
        item.pszText = penvar->szExpValue;

        SendMessage(hwndTemp, LVM_SETITEMTEXT, n, (LPARAM) &item);

        item.mask = LVIF_STATE;
        item.iItem = n;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendDlgItemMessage(hDlg, idTemp,
                            LVM_SETITEMSTATE, n, (LPARAM) &item);
    }

    delete bBuffer;
    delete pszString;

	if(m_bUserVars)
		m_currUserModified = true;
	else
		m_SysModified = true;

}

//----------------------------------------------------------------------
void EnvPage::DoEdit(HWND hWnd,
						UINT VarType,
						UINT EditType,
						int iSelection)
/*++

Routine Description:

    Sets up for, executes, and cleans up after an Environment Variable
    New... or Edit... dialog.  Called when user presses a New... or Edit...
    button.

Arguments:

    hWnd -
        Supplies window handle

    VarType -
        Supplies the type of the variable:  User (USER_VAR) or 
        System (SYSTEM_VAR)

    EditType -
        Supplies the type of the edit:  create New (NEW_VAR) or 
        Edit existing (EDIT_VAR)

    iSelection -
        Supplies the currently selected variable of type VarType.  This
        value is ignored if EditType is NEW_VAR.

Return Value:

    None.  May alter the contents of a list view control as a side effect.

--*/
{
    INT_PTR Result = 0;
    BOOL fVarChanged = FALSE;
    HWND hWndLB = NULL;
    ENVARS *penvar = NULL;

    g_VarType = VarType;
    g_EditType = EditType;

    penvar = GetVar(hWnd, VarType, iSelection);

	// init the edit dialog controls.
    switch(EditType) 
	{
    case NEW_VAR:

        ZeroMemory((LPVOID) g_szVarName, (DWORD) BUFZ * sizeof(TCHAR));
        ZeroMemory((LPVOID) g_szVarValue, (DWORD) BUFZ * sizeof(TCHAR));
        break;

    case EDIT_VAR:

        if(penvar) 
		{
            wsprintf(g_szVarName, TEXT("%s"), penvar->szValueName);
            wsprintf(g_szVarValue, TEXT("%s"), penvar->szValue);
		}
		else
		{
			MessageBeep(MB_ICONASTERISK);
			return;
        } // if
        break;

    case INVALID_EDIT_TYPE:
    default:
        return;
    } // switch
    
	// call the edit dialog.
    Result = DialogBox(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_ENVVAREDIT),
						hWnd, EnvVarsEditDlg);

	// figure out what was changed.
	bool nameChanged = false;
    bool valueChanged = false;

    // Only update the list view control if the user
    // actually changed or created a variable
    switch (Result) 
	{
    case EDIT_CHANGE:

        if(EDIT_VAR == EditType) 
		{
			nameChanged = (lstrcmp(penvar->szValueName, g_szVarName) != 0);
			valueChanged = (lstrcmp(penvar->szValue, g_szVarValue) != 0);
        }
        else if(NEW_VAR == EditType)
		{
            nameChanged = (lstrlen(g_szVarName) != 0);
			valueChanged = (lstrlen(g_szVarValue) != 0);
        }

		 // if the name changed, its a whole new wbem class object.
		if(nameChanged)
		{
            if(EDIT_VAR == EditType) 
			{
				DeleteVar(hWnd, VarType, penvar->szValueName);
			}
            SetVar(hWnd, VarType, g_szVarName, g_szVarValue);
		}
        else if(valueChanged)
		{
			// keep the class object but change the value.
            SetVar(hWnd, VarType, g_szVarName, g_szVarValue);
		}

		// if anything changed...
		if(nameChanged || valueChanged)
		{
			// set the list's dirty flag.
			if(VarType == SYSTEM_VAR)
			{
				m_SysModified = true;
			}
			else if(VarType == USER_VAR)
			{
				m_currUserModified = true;
			}
        }
        break;

    default: 
		break;
    } // endswitch (Result)

    g_VarType = INVALID_VAR_TYPE;
    g_EditType = INVALID_EDIT_TYPE;
}

//-------------------------------------------------
EnvPage::ENVARS *EnvPage::GetVar(HWND hDlg, 
						UINT VarType, 
						int iSelection)
/*++

Routine Description:

    Returns a given System or User environment variable, as stored
    in the System or User environment variable listview control.

    Changing the structure returned by this routine is not
    recommended, because it will alter the values actually stored
    in the listview control.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type--System or User

    iSelection -
        Supplies the selection index into the listview control of
        the desired environment variable

Return Value:

    Pointer to a valid ENVARS structure if successful.

    NULL if unsuccessful.

--*/
{
    HWND hWndLB = NULL;
    ENVARS *penvar = NULL;
    LV_ITEM item;

    switch(VarType) 
	{
    case SYSTEM_VAR:
        hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
        break;

    case USER_VAR:
        hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
        break;

    case INVALID_VAR_TYPE:
    default:
        return NULL;
    } // switch (VarType)

    item.mask = LVIF_PARAM;
    item.iItem = iSelection;
    item.iSubItem = 0;
    if (SendMessage (hWndLB, LVM_GETITEM, 0, (LPARAM) &item)) 
	{
        penvar = (ENVARS *) item.lParam;
    } 
	else 
	{
        penvar = NULL;
    }
    
    return(penvar);
}

//----------------------------------------------------------------------
void EnvPage::DoCommand(HWND hDlg, HWND hwndCtl, int idCtl, int iNotify )
{
    int     i;
    ENVARS *penvar = NULL;

    switch (idCtl) 
	{
    case IDOK:
		if(m_currUserModified)
		{
			Save(m_hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
			m_currUserModified = false;
		}
		if(m_SysModified)
		{
			Save(m_hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
			m_SysModified = false;
		}

        EndDialog(hDlg, 0);
        break;

    case IDCANCEL:
        EndDialog(hDlg, 0);
        break;

    case IDC_ENVVAR_SYS_EDITSV:
        DoEdit(hDlg, SYSTEM_VAR, EDIT_VAR, 
					GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS)));

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        break;

    case IDC_ENVVAR_SYS_EDITUV:
        DoEdit(hDlg, USER_VAR, EDIT_VAR,
					GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS)));

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        break;

    case IDC_ENVVAR_SYS_NEWSV:
        DoEdit(hDlg, SYSTEM_VAR, NEW_VAR, -1);
        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        break;

    case IDC_ENVVAR_SYS_NEWUV:
        DoEdit(hDlg, USER_VAR, NEW_VAR, -1); 
        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        break;

    case IDC_ENVVAR_SYS_DELSV:
        i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        if(-1 != i) 
		{
            penvar = GetVar(hDlg, SYSTEM_VAR, i);
	    if (penvar)
            	DeleteVar(hDlg, SYSTEM_VAR, penvar->szValueName);
        } // endif

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        break;

    case IDC_ENVVAR_SYS_NDELUV:
        i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        if(-1 != i) 
		{
            penvar = GetVar(hDlg, USER_VAR, i);
            if (penvar)
		DeleteVar(hDlg, USER_VAR, penvar->szValueName);
        } // endif

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        break;

	// the combobox of user names.
	case IDC_USERLIST:
		{//BEGIN

			TCHAR userName[100] = {0};
			bstr_t sNewUser, sThisName;
			HRESULT hr = 0;
			IWbemClassObject *envInst = NULL;
			IEnumWbemClassObject *envEnum = NULL;
			DWORD uReturned = 0;
			bstr_t sUserName("UserName");
			variant_t pVal;
			int idx, changeMsg = IDNO;
		
			if (iNotify == CBN_SELENDOK)
			{
				// see if the user want to save his changes.
				if(m_currUserModified)
				{
					changeMsg = MsgBoxParam(m_hDlg, 
											IDS_CHANGINGUSER, IDS_TITLE, 
											MB_YESNOCANCEL | MB_ICONEXCLAMATION);
				}

				// well does he?
				switch(changeMsg)
				{
				case IDCANCEL:
					// stay put.
					return;
				case IDYES:
					Save(m_hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
					// NOTE: after saving. allow to fall through to repopulate the list.

				case IDNO:

					// reset contents here.
					EmptyListView(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
					
					m_currUserModified = false;

					// get new user's name.
					idx = ComboBox_GetCurSel(hwndCtl);
					if(ComboBox_GetLBText(hwndCtl, idx, userName))
					{
						sNewUser = userName;

						HWND hwndUser = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);

						// load his variables.
						if((hr = m_WbemServices.CreateInstanceEnum(bstr_t("Win32_Environment"), 
																	WBEM_FLAG_SHALLOW, 
																	&envEnum)) == S_OK)
						{
							// get the instance
							while(SUCCEEDED(envEnum->Next(-1, 1, &envInst, &uReturned)) && 
								  (uReturned != 0))
							{
								// who's variable.
								if (envInst->Get(sUserName, 0L, &pVal, NULL, NULL) == S_OK) 
								{
									 sThisName = V_BSTR(&pVal);

									 // setup for which list box gets this instance.
									if(sThisName == sNewUser)
									{
										LoadUser(envInst, sThisName, hwndUser);

									} //endif(sThisName == sNewUser)

								} //endif (envInst->Get(sUserName,

								envInst->Release();

							} // endwhile envEnum

							envEnum->Release();

						} //endif CreateInstanceEnum()

					} //endif(ComboBox_GetText

				}//end switch(Messagebox())

			} //endif (iNotify == CBN_SELCHANGE)

		}//END
		break;

    default:
        break;
    }
}

//---------------------------------------------------------------------------
void EnvPage::LoadUser(IWbemClassObject *envInst, 
						bstr_t userName, 
						HWND hwndUser)
{
	bstr_t sVarName("Name");
	bstr_t sVarVal("VariableValue");
	bstr_t sPath("__PATH");
	bstr_t sSysUser("<SYSTEM>");  // magic string returned by provider
	variant_t pVal, pVal1, pVal2;
	ENVARS *penvar = NULL;
	bstr_t  pszValue;
	bstr_t szTemp;
	bstr_t objPath;
	TCHAR  pszString[MAX_VALUE_LEN] = {0};
	int     n;
	LV_ITEM item;
	DWORD dwIndex = 0;

	m_currentUser = userName;

	// get the variable.
	if ((envInst->Get(sVarVal, 0L, &pVal, NULL, NULL) == S_OK) &&
		(envInst->Get(sVarName, 0L, &pVal1, NULL, NULL) == S_OK) &&
		(envInst->Get(sPath, 0L, &pVal2, NULL, NULL) == S_OK)) 
	{
		// extract.
		pszValue = V_BSTR(&pVal);
		szTemp = V_BSTR(&pVal1);
		objPath = V_BSTR(&pVal2);

		// store with list item.
		penvar = new ENVARS;
		if (penvar == NULL) //outofmemory
			return;

		penvar->objPath		= CloneString(objPath);
		penvar->userName	= CloneString(userName);
		penvar->szValueName = CloneString( szTemp );
		penvar->szValue     = CloneString( pszValue );

		if((m_bLocal == true) && ((userName == sSysUser) || (IsLoggedInUser(userName))))
		{
			ExpandEnvironmentStrings(pszValue, pszString, MAX_VALUE_LEN);
		}
		else
		{
			_tcscpy(pszString,pszValue);
		}

		penvar->szExpValue  = CloneString( pszString );
		penvar->changed		= false;

		// put in first column value (name).
		item.mask = LVIF_TEXT | LVIF_PARAM;
		item.iItem = (dwIndex - 1);
		item.iSubItem = 0;
		item.pszText = penvar->szValueName;
		item.lParam = (LPARAM) penvar;

		n = (int)SendMessage(hwndUser, LVM_INSERTITEM, 0, (LPARAM) &item);

		// did it go?
		if (n != -1) 
		{
			// do the second column value.
			item.mask = LVIF_TEXT;
			item.iItem = n;
			item.iSubItem = 1;
			item.pszText = penvar->szExpValue;

			SendMessage(hwndUser, LVM_SETITEMTEXT, n, (LPARAM) &item);
		}
	}
}

//---------------------------------------------------------------------------
bool EnvPage::IsLoggedInUser(bstr_t userName)
{
	TCHAR strUserName[1024];
	TCHAR strDomain[1024];
	_tcscpy(strDomain,_T(""));
	DWORD dwSize = 1024;
	DWORD dwDomSize = 1024;
	DWORD dwSidSize = 0;
	BYTE *buff;
	
	SID *sid = NULL;
	SID_NAME_USE sidName;
	
	if (!userName)
		return false;

	GetUserName(strUserName,&dwSize);
	LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	
	buff = new BYTE[dwSidSize];
	if(buff == NULL)
		return false;

	sid = (SID *)buff;
	
	BOOL bFlag = LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	delete []buff;
	_tcscat(strDomain,_T("\\"));
	_tcscat(strDomain,strUserName);

	if(_tcsicmp(strDomain,userName) == 0)
		return true;
	else
		return false;
}

//---------------------------------------------------------------------------
void EnvPage::GetLoggedinUser(bstr_t *userName)
{
	TCHAR strUserName[1024];
	TCHAR strDomain[1024];
	_tcscpy(strDomain,_T(""));
	DWORD dwSize = 1024;
	DWORD dwDomSize = 1024;
	DWORD dwSidSize = 0;
	BYTE *buff;
	
	SID *sid = NULL;
	SID_NAME_USE sidName;
	
	GetUserName(strUserName,&dwSize);
	LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	
	buff = new BYTE[dwSidSize];
	sid = (SID *)buff;
	
	BOOL bFlag = LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	delete []buff;
	_tcscat(strDomain,_T("\\"));
	_tcscat(strDomain,strUserName);
	
	*userName = strDomain;

}

//---------------------------------------------------------------------------
void EnvPage::KillLater(ENVARS *var)
{
	// remember this guy.
	m_killers.Add(var);
}

//---------------------------------------------------------------------------
void EnvPage::KillThemAllNow(void)
{
	ENVARS *var = NULL;

	if(m_killers.GetSize() > 0)
	{
		for(int it = 0; it < m_killers.GetSize(); it++)
		{
			var = m_killers[it];
			if(var->objPath != NULL)
			{
				m_WbemServices.DeleteInstance(var->objPath);
			}
			delete var;
		}
		m_killers.RemoveAll();
	}
}

//------------------------------------------------------------------------
int EnvPage::GetSelectedItem(HWND hCtrl)
{
    int i, n;

    n = (int)SendMessage(hCtrl, LVM_GETITEMCOUNT, 0, 0L);

    if (n != LB_ERR)
    {
        for (i = 0; i < n; i++)
        {
            if (SendMessage(hCtrl, LVM_GETITEMSTATE,
                             i, (LPARAM) LVIS_SELECTED) == LVIS_SELECTED) 
			{
                return i;
            }
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\helpid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    helpid.h

Abstract:

    Resource IDs for the System Control Panel Applet

Author:

    Scott Hallock (scotthal) 17-Oct-1997

Revision History:

    15-Oct-1997 scotthal
        Split Help IDs into their own header

--*/
#ifndef _SYSDM_HELPID_H_
#define _SYSDM_HELPID_H_

#define HELP_FILE           TEXT("sysdm.hlp")

#define IDH_HELPFIRST       5000

//
// Help IDs for the General tab
//
#define IDH_GENERAL         (IDH_HELPFIRST + 0000)
#define IDH_PERF            (IDH_HELPFIRST + 1000)
#define IDH_ENV             (IDH_HELPFIRST + 2000)
#define IDH_ENV_EDIT        (IDH_HELPFIRST + 2500)
#define IDH_STARTUP         (IDH_HELPFIRST + 3000)
#define IDH_HWPROFILE       (IDH_HELPFIRST + 4000)
#define IDH_USERPROFILE     (IDH_HELPFIRST + 5000)
#define IDH_HARDWARE        (IDH_HELPFIRST + 6000)
#define IDH_ADVANCED        (IDH_HELPFIRST + 7000)
#define IDH_DLGFIRST        (IDH_HELPFIRST + 3000)
#define IDH_DLG_VIRTUALMEM  (IDH_DLGFIRST + 41)

#define IDH_WBEM_ADVANCED_ENVARIABLE_USERVAR_LISTBOX  13002
#define IDH_WBEM_ADVANCED_STARTRECOVER_REMOTE_REBOOT  13003

//Special text for WMI snap-ins (different from shell text)
#define IDH_COMPUTER_MANAGEMENT_PERFORMANCE_GROUP_BOX 12008
#define IDH_COMPUTER_MANAGEMENT_PERFORMANCE_SETTINGS_BUTTON 12009

#endif // _SYSDM_HELPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\generalpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __GENERALPAGE__
#define __GENERALPAGE__
#pragma once

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "atlsnap.h"
#include "resource.h"
#include "..\Common\WbemPageHelper.h"
#include "..\common\serviceThread.h"

//-----------------------------------------------------------------------------
class GeneralPage : public CSnapInPropertyPageImpl<GeneralPage>,
						public WBEMPageHelper
{
private:

	IDataObject* m_pDataObject;
	CWbemClassObject m_OS;
	CWbemClassObject m_processor;
	CWbemClassObject m_memory;
	CWbemClassObject m_computer;
	// shared with the phone support dialog.
	bstr_t m_manufacturer;
	bool m_inited;
	HWND m_hAVI;
	void Init();
	bool CimomIsReady();
	void ConfigureProductID(LPTSTR lpPid);

public:

	GeneralPage(WbemServiceThread *serviceThread,
				LONG_PTR lNotifyHandle, 
				bool bDeleteHandle = false, 
				TCHAR* pTitle = NULL, 
				IDataObject* pDataObject = 0);

	~GeneralPage();

	enum { IDD = IDD_GENERAL };

	typedef CSnapInPropertyPageImpl<GeneralPage> _baseClass;

	BEGIN_MSG_MAP(GeneralPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnConnected)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
		MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		COMMAND_HANDLER(IDC_GEN_OEM_SUPPORT, BN_CLICKED, OnSupport)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSupport(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	BOOL OnApply();
	BOOL OnKillActive()
	{
		return (m_inited?TRUE:FALSE);
	}

    DWORD GetServerTypeResourceID(void);

	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;

};

INT_PTR CALLBACK PhoneSupportProc(HWND hDlg, 
								UINT uMsg,
							    WPARAM wParam, 
								LPARAM lParam);

#endif __GENERALPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\iddlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef IDDLG_HPP_INCLUDED
#define IDDLG_HPP_INCLUDED
#pragma once

#include "resource.h"

#include "..\Common\WbemPageHelper.h"
#include <chstring.h>
#include "state.h"

#define NET_API_STATUS DWORD
#define NETSETUP_NAME_TYPE DWORD
//---------------------------------------------------------------------
class IDChangesDialog : public CDialogImpl<IDChangesDialog>,
						public WBEMPageHelper
{
public:

	IDChangesDialog(WbemServiceThread *serviceThread,
					State &state);
	virtual ~IDChangesDialog();

	enum { IDD = IDD_CHANGES };

	BEGIN_MSG_MAP(IDChangesDialog)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		COMMAND_HANDLER(IDC_CHANGE, BN_CLICKED, OnCommand)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
	State &m_state;
	void enable();
	NET_API_STATUS myNetValidateName(const CHString&        name,
									NETSETUP_NAME_TYPE   nameType);
	bool validateName(HWND dialog,
					   int nameResID,
					   const CHString &name,
					   NETSETUP_NAME_TYPE nameType);
	bool validateShortComputerName(HWND dialog);
	bool onOKButton();
	bool validateDomainOrWorkgroupName(HWND dialog);
};

#endif IDDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\iddlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"
#include "moredlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "resource.h"
#include "..\common\util.h"
#include "IDDlg.h"
#include "NetUtility.h"
#include "NetHelpIDs.h"
#include "common.h"

static const DWORD _help_map[] =
{
   IDC_FULL_NAME,          IDH_IDENT_CHANGES_PREVIEW_NAME,
   IDC_NEW_NAME,           IDH_IDENT_CHANGES_NEW_NAME,
   IDC_MORE,               IDH_IDENT_CHANGES_MORE_BUTTON,
   IDC_DOMAIN_BUTTON,      IDH_IDENT_CHANGES_MEMBER_DOMAIN,
   IDC_WORKGROUP_BUTTON,   IDH_IDENT_CHANGES_MEMBER_WORKGRP,
   IDC_DOMAIN,             IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX,
   IDC_WORKGROUP,          IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX,
   IDC_FIND,               -1,
   0, 0
};


//---------------------------------------------------------------------
IDChangesDialog::IDChangesDialog(WbemServiceThread *serviceThread,
								 State &state) 
						: WBEMPageHelper(serviceThread),
						m_state(state)
{
}

//-------------------------------------------------------------
IDChangesDialog::~IDChangesDialog()
{
}

//----------------------------------------------------------
void IDChangesDialog::enable()
{
   bool networking_installed = m_state.IsNetworkingInstalled();
   BOOL workgroup = IsDlgButtonChecked(IDC_WORKGROUP_BUTTON) == BST_CHECKED;

   ::EnableWindow(GetDlgItem(IDC_DOMAIN),
					!workgroup && networking_installed);

   ::EnableWindow(GetDlgItem(IDC_FIND),
					!workgroup && networking_installed);

   ::EnableWindow(GetDlgItem(IDC_WORKGROUP),
					workgroup && networking_installed);

   bool b = false;
   if (workgroup)
   {
      b = !GetTrimmedDlgItemText(m_hWnd, IDC_WORKGROUP).IsEmpty();
   }
   else
   {
      b = !GetTrimmedDlgItemText(m_hWnd, IDC_DOMAIN).IsEmpty();
   }

   bool enable = m_state.ChangesNeedSaving() && b &&
					!GetTrimmedDlgItemText(m_hWnd, IDC_NEW_NAME).IsEmpty();
   
   ::EnableWindow(GetDlgItem(IDOK), enable);
}

//----------------------------------------------------------
LRESULT IDChangesDialog::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   m_hDlg = m_hWnd;

   SetDlgItemText(IDC_FULL_NAME, m_state.GetFullComputerName());
   SetDlgItemText(IDC_NEW_NAME, m_state.GetShortComputerName());

   bool joined_to_workgroup = m_state.IsMemberOfWorkgroup();

   CheckDlgButton(IDC_WORKGROUP_BUTTON,
					joined_to_workgroup ? BST_CHECKED : BST_UNCHECKED);

   CheckDlgButton(IDC_DOMAIN_BUTTON,
					joined_to_workgroup ? BST_UNCHECKED : BST_CHECKED);

   SetDlgItemText(joined_to_workgroup ? IDC_WORKGROUP : IDC_DOMAIN,
					m_state.GetDomainName());

   bool networking_installed = m_state.IsNetworkingInstalled();
   bool tcp_installed = networking_installed && IsTCPIPInstalled();

   int show = tcp_installed ? SW_SHOW : SW_HIDE;
   ::ShowWindow(GetDlgItem(IDC_FULL_LABEL), show);
   ::ShowWindow(GetDlgItem(IDC_FULL_NAME), show);
   ::ShowWindow(GetDlgItem(IDC_MORE), show);

   HWND new_name_edit = GetDlgItem(IDC_NEW_NAME);
   HWND domain_name_edit = GetDlgItem(IDC_DOMAIN);
//   Edit_LimitText(domain_name_edit, tcp_installed ? DNS::MAX_NAME_LENGTH : DNLEN);

//   Edit_LimitText(new_name_edit, tcp_installed ? DNS::MAX_LABEL_LENGTH : MAX_COMPUTERNAME_LENGTH);

   if (!tcp_installed)
   {
      // Set the uppercase style on the new name & domain edit boxes
      LONG style = ::GetWindowLong(new_name_edit, GWL_STYLE);
      style |= ES_UPPERCASE;
      ::SetWindowLong(new_name_edit, GWL_STYLE, style);

      style = ::GetWindowLong(domain_name_edit, GWL_STYLE);
      style |= ES_UPPERCASE;
      ::SetWindowLong(domain_name_edit, GWL_STYLE, style);
   }

   //TODO::Edit_LimitText(GetDlgItem(IDC_WORKGROUP), DNLEN);

   // no networking at all further restricts the UI to just NetBIOS-like
   // computer name changes.
   if (!networking_installed)
   {
      ::EnableWindow(GetDlgItem(IDC_DOMAIN_BUTTON), false);
      ::EnableWindow(GetDlgItem(IDC_WORKGROUP_BUTTON), false);
      ::EnableWindow(GetDlgItem(IDC_DOMAIN), false);
      ::EnableWindow(GetDlgItem(IDC_WORKGROUP), false);
      ::EnableWindow(GetDlgItem(IDC_GROUP), false);

	  TCHAR temp[256] = {0};
	  StringLoad(IDS_NAME_MESSAGE, temp, 256);
      ::SetWindowText(GetDlgItem(IDC_MESSAGE), temp);
   }
   else
   {
	  TCHAR temp[256] = {0};
	  StringLoad(IDS_NAME_AND_MEMBERSHIP_MESSAGE, temp, 256);
      ::SetWindowText(GetDlgItem(IDC_MESSAGE), temp);
   }

   enable();
	return S_OK;
}

//----------------------------------------------------------
NET_API_STATUS IDChangesDialog::myNetValidateName(const CHString&        name,
													NETSETUP_NAME_TYPE   nameType)
{
/*   ATLASSERT(!name.IsEmpty());

   if(!name.IsEmpty())
   {
      NET_API_STATUS status;// = ::NetValidateName(0, name,
//												0, 0, nameType);
      return status;
   }
*/
   return ERROR_INVALID_PARAMETER;
}

//----------------------------------------------------------
bool IDChangesDialog::validateName(HWND dialog,
								   int nameResID,
								   const CHString &name,
								   NETSETUP_NAME_TYPE nameType)
{
/*   ATLASSERT(IsWindow(dialog));
   ATLASSERT(nameResID);

   NET_API_STATUS status;// = myNetValidateName(name, nameType);
   if(status != NERR_Success)
   {
	  TCHAR temp[256] = {0};
	  StringLoad(IDS_VALIDATE_NAME_FAILED, temp, 256);
      gripe(dialog,
			 nameResID,
			 HRESULT_FROM_WIN32(status),
			 temp,
			 IDS_APP_TITLE);
      return false;
   }
*/
   return true;
}
   

// this is also good for the tcp/ip not installed case, as the edit control
// limits the text length, and we decided not to allow '.' in netbios names
// any longer

//----------------------------------------------------------
bool IDChangesDialog::validateShortComputerName(HWND dialog)
{
/*   ATLASSERT(IsWindow(dialog));

   if(!m_state.WasShortComputerNameChanged())
   {
      return true;
   }

   CHString name = m_state.GetShortComputerName();

   CHString message;
   switch (DNS::ValidateDNSLabelSyntax(name))
   {
      case DNS::VALID_LABEL:
      {
         if (state.IsNetworkingInstalled())
         {
            return validateName(dialog, IDC_NEW_NAME, name, NetSetupMachine);
         }
         else
         {
            return true;
         }
      }
      case DNS::LABEL_TOO_LONG:
      {
         message = String::format(IDS_COMPUTER_NAME_TOO_LONG,
								   name.c_str(),
								   DNS::MAX_LABEL_LENGTH);
         break;
      }
      case DNS::NON_RFC_LABEL:
      {
         message = String::format(IDS_NON_RFC_COMPUTER_NAME_SYNTAX, 
									name.c_str());
         if(MessageBox(dialog, message,
					   String::load(IDS_APP_TITLE),
					   MB_ICONWARNING | MB_YESNO) == IDYES)
         {
            return validateName(dialog, IDC_NEW_NAME, name, NetSetupMachine);
         }

         HWND edit = GetDlgItem(IDC_NEW_NAME);
         ::SendMessage(edit, EM_SETSEL, 0, -1);
         ::SetFocus(edit);
         return false;
      }
      case DNS::INVALID_LABEL:
      {
         message = CHString::format(IDS_BAD_COMPUTER_NAME_SYNTAX, 
									name.c_str());
         break;
      }
      default:
      {
         ATLASSERT(false);
         message = CHString::format(IDS_BAD_COMPUTER_NAME_SYNTAX, 
									name.c_str());
         break;
      }
   }

   gripe(dialog, IDC_NEW_NAME,
			message, IDS_APP_TITLE);
*/
   return false;
}

//----------------------------------------------------------
bool IDChangesDialog::validateDomainOrWorkgroupName(HWND dialog)
{
/*   ATLASSERT(IsWindow(dialog));

   if (!State::GetInstance().WasMembershipChanged())
   {
      return true;
   }

   NETSETUP_NAME_TYPE name_type = NetSetupWorkgroup;
   int name_id = IDC_WORKGROUP;
   if(IsDlgButtonChecked(IDC_DOMAIN_BUTTON) == BST_CHECKED)
   {
      name_type = NetSetupDomain;
      name_id = IDC_DOMAIN;
   }

   CHString name = GetTrimmedDlgItemText(m_hWnd, name_id);
   return validateName(dialog, name_id, name, name_type);
   */
	return false;
}

//----------------------------------------------------------
bool IDChangesDialog::onOKButton()
{
   ATLASSERT(m_state.ChangesNeedSaving());

   HourGlass(true);

   // computer primary DNS name has already been validated by
   // MoreChangesDialog

   // this is redundant, really, but I'm paranoid.
   m_state.SetShortComputerName(GetTrimmedDlgItemText(m_hWnd, IDC_NEW_NAME));
   bool workgroup = IsDlgButtonChecked(IDC_WORKGROUP_BUTTON) == BST_CHECKED;
   m_state.SetIsMemberOfWorkgroup(workgroup);
   if(workgroup)
   {
      m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_WORKGROUP));
   }
   else
   {
      m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_DOMAIN));
   }

   if(!validateShortComputerName(m_hWnd) ||
       !validateDomainOrWorkgroupName(m_hWnd))
   {
	   HourGlass(false);
      return false;
   }

   if(m_state.SaveChanges(m_hWnd))
   {
      AppMessage(m_hWnd, IDS_MUST_REBOOT);
      m_state.SetMustRebootFlag(true);      
      return true;
   }

   HourGlass(false);
   return false;
}

//----------------------------------------------------------
LRESULT IDChangesDialog::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
   switch(wID)
   {
      case IDC_MORE:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            MoreChangesDialog dlg(g_serviceThread, m_state);
            if (dlg.DoModal() == MoreChangesDialog::CHANGES_MADE)
            {
               SetDlgItemText(IDC_FULL_NAME, m_state.GetFullComputerName());               
               enable();
            }
         }
         break;
      }
      case IDC_WORKGROUP_BUTTON:
      case IDC_DOMAIN_BUTTON:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            bool workgroup = IsDlgButtonChecked(IDC_WORKGROUP_BUTTON) == BST_CHECKED;
            m_state.SetIsMemberOfWorkgroup(workgroup);
            if(workgroup)
            {
               m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_WORKGROUP));
            }
            else
            {
               m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_DOMAIN));
            }
            enable();
         }
         break;
      }
      case IDC_WORKGROUP:  // the editboxes
      case IDC_DOMAIN:
      {
         if (wNotifyCode == EN_CHANGE)
         {
            //TODOSetModified(wID);
            m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, wID));
            enable();
         }
         break;
      }
      case IDC_NEW_NAME:
      {
         if (wNotifyCode == EN_CHANGE)
         {
            //TODOSetChanged(wID);
            m_state.SetShortComputerName(GetTrimmedDlgItemText(m_hWnd, wID));
            SetDlgItemText(IDC_FULL_NAME, m_state.GetFullComputerName());
            enable();
         }
         break;
      }
      case IDOK:
      {
         if(wNotifyCode == BN_CLICKED)
         {
            if(onOKButton())
            {
               EndDialog(wID);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if(wNotifyCode == BN_CLICKED)
         {
            EndDialog(wID);
         }
         break;
      }

      default:
      {
		  bHandled = false;
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\generalpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"
#include "..\MMFUtil\MsgDlg.h"
#include "helpid.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "GeneralPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"

#include "..\Common\util.h"
#include <windowsx.h>


//--------------------------------------------------------------
GeneralPage::GeneralPage(WbemServiceThread *serviceThread,
						 LONG_PTR lNotifyHandle, bool bDeleteHandle, TCHAR* pTitle,
						 IDataObject* pDataObject)
				: WBEMPageHelper(serviceThread),
					CSnapInPropertyPageImpl<GeneralPage> (pTitle),
					m_lNotifyHandle(lNotifyHandle),
					m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
	m_inited = false;
	m_pDataObject = pDataObject;
}
//--------------------------------------------------------------
GeneralPage::~GeneralPage()
{
	if (m_bDeleteHandle)
		MMCFreeNotifyHandle(m_lNotifyHandle);
}

//-------------------------------------------------------------
bool GeneralPage::CimomIsReady()
{
	m_hDlg = m_hWnd;

	bool retval = ServiceIsReady(IDS_DISPLAY_NAME, 
								 IDS_CONNECTING,
								 IDS_BAD_CONNECT);

	if(retval)
	{
		if((bool)m_WbemServices)
		{
			IWbemClassObject *pInst = NULL;
			m_WbemServices.SetPriv();

			if((pInst = FirstInstanceOf((bstr_t)"Win32_OperatingSystem")) != NULL)
			{
				m_OS = pInst;
			}

			if((pInst = FirstInstanceOf("Win32_Processor")) != NULL)
			{
				m_processor = pInst;
			}

            if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
            {
                m_memory = pInst;
            }

			if((pInst = FirstInstanceOf("Win32_ComputerSystem")) != NULL)
			{
				m_computer = pInst;
			}
		}
		else
		{
			retval = false;
		}
	}
	return retval;
}

//-------------------------------------------------------------
void GeneralPage::ConfigureProductID(LPTSTR lpPid)
{
    TCHAR szBuf[64] = {0};

	// is it formatted already.
	if(lstrlen(lpPid) > 20)
	{
		return;
	}

    if (!lpPid || !(*lpPid) || (lstrlen(lpPid) < 20) ) {
        return;
    }

    szBuf[0] = lpPid[0];
    szBuf[1] = lpPid[1];
    szBuf[2] = lpPid[2];
    szBuf[3] = lpPid[3];
    szBuf[4] = lpPid[4];

    szBuf[5] = TEXT('-');

    szBuf[6] = lpPid[5];
    szBuf[7] = lpPid[6];
    szBuf[8] = lpPid[7];

    szBuf[9] = TEXT('-');

    szBuf[10] = lpPid[8];
    szBuf[11] = lpPid[9];
    szBuf[12] = lpPid[10];
    szBuf[13] = lpPid[11];
    szBuf[14] = lpPid[12];
    szBuf[15] = lpPid[13];
    szBuf[16] = lpPid[14];

    szBuf[17] = TEXT('-');

    szBuf[18] = lpPid[15];
    szBuf[19] = lpPid[16];
    szBuf[20] = lpPid[17];
    szBuf[21] = lpPid[18];
    szBuf[22] = lpPid[19];

    szBuf[23] = TEXT('\0');

    lstrcpy (lpPid, szBuf);

}


//Helper to split the caption of the OS to two controls to match the way shell displays it
void WrapTextToTwoControls(HWND hwndLine1, HWND hwndLine2, LPCTSTR szText)
{
	RECT rcCtl;
	SIZE size;
	int fit = 0;
	int length = 0;
	HDC hDC = NULL;
	HFONT hFont = NULL;
	HFONT hOldFont = NULL;
	LPTSTR pszTempBuffer = NULL;
	LPTSTR pszLineBreak = NULL;

	// Validate the arguments
	if(NULL == hwndLine1 || NULL == hwndLine2 || NULL == szText)
		goto FAIL;

	// Make sure we don't have a zero length string
	if(0 == (length = lstrlen(szText)))
		goto FAIL;

	// Get the size of the control for line 1
	if(!GetClientRect(hwndLine1, &rcCtl))
		goto FAIL;

	// Get the DC of line 1
	if(NULL == (hDC = ::GetDC(hwndLine1)))
		goto FAIL;

	// Get the font that is in use for line 1
	if(NULL == (hFont = (HFONT)::SendMessage(hwndLine1, WM_GETFONT, 0, 0)))
		goto FAIL;

	// Select the correct font into the DC
	if(NULL == (hOldFont = (HFONT)::SelectObject(hDC, hFont)))
		goto FAIL;

	// Find out how many characters of our string would fit into the control
	if(!GetTextExtentExPoint(hDC, szText, length, rcCtl.right, &fit, NULL, &size))
		goto FAIL;

	// If the 'fit' is not greater than 0 and less than length, just display everything on line 1 
	if(fit <= 0 || fit >= length)
		goto FAIL;

	// Allocate a buffer to play with
	if(NULL == (pszTempBuffer = new TCHAR[length+1]))
		goto FAIL;

	// Copy text into temporary buffer
	lstrcpy(pszTempBuffer, szText);

	// We will try to break line 1 right at the maximum number of characters
	pszLineBreak = pszTempBuffer + fit;

	// See if the natural break falls directly on a 'space'
	if(*pszLineBreak != _TEXT(' '))
	{
		// The number of characters that fit into line 1 falls in the middle of a word.  Find 
		// the last space that fits in the control.  If we do not find a space that fits in
		// line 1, just use the default behavior.

		// Terminate line 1 at the maximum characters
		*pszLineBreak = _TEXT('\0');

		// Find the last 'sace' on line 1
		if(NULL == (pszLineBreak = _tcsrchr(pszTempBuffer, _TEXT(' '))))
			goto FAIL;

		// Copy text into the temporary buffer again
		lstrcpy(pszTempBuffer, szText);
	}

	// Terminate line 1 right on the 'last' space that fits into the control
	*pszLineBreak = _TEXT('\0');

	// Set line one to everything up to the 'last' space that fits into the control
	SetWindowText(hwndLine1, pszTempBuffer);

	// Set line two to everything after the 'last' space that fit into line 1
	SetWindowText(hwndLine2, pszLineBreak+1);

	// Everything went OK;
	goto CLEANUP;
FAIL:
	// Default to putting all the text on line 1 if anything goes wrong
	::SetWindowText(hwndLine1, szText);
	::SetWindowText(hwndLine2, _TEXT(""));

CLEANUP:
	if(pszTempBuffer)
		delete[] pszTempBuffer;
	if(hOldFont && hDC)
		SelectObject(hDC, hOldFont);
	if(hDC && hwndLine1)
		ReleaseDC(hwndLine1, hDC);
}




//--------------------------------------------------------------
void GeneralPage::Init()
{
    TCHAR _scr1[640] = {0};
    TCHAR _scr2[640] = {0};
    TCHAR szNumBuf1[64] = {0};
    int   ctlid;

    // Set the default bitmap
    SetClearBitmap(GetDlgItem(IDC_GEN_WINDOWS_IMAGE ),
					MAKEINTRESOURCE( IDB_WINDOWS ), 0 );

    //
    // The caption is in the form:
    //      Microsoft Windows XP Server
    //
    // This is actually the caption + the product suite type.
    // Wrap the product suite type (Server above) into the
    // next static control.
    //
    // IDC_GEN_VERSION_0: Major branding ("Windows XP")
    // Default to Win32_OperatingSystem::Caption.
    //

    HWND hwndCtl1 = ::GetDlgItem(m_hWnd, IDC_GEN_VERSION_0);
    HWND hwndCtl2 = ::GetDlgItem(m_hWnd, IDC_GEN_VERSION_1);

    WrapTextToTwoControls(hwndCtl1, hwndCtl2, m_OS.GetString("Caption"));

    // Build and set the serial number string
    if (m_OS.GetBool("Debug")) 
    {
	_scr1[0] = TEXT(' ');
        LoadString(HINST_THISDLL,
                   IDS_DEBUG,
                   &_scr1[1],
                   ARRAYSIZE(_scr1));
    } 
    else 
    {
	_scr1[0] = TEXT('\0');
    }

    // IDC_GEN_VERSION_2: Version year ("Version 2002")
    //
    // Determine if we are targeting XP.  If not, default to
    // Win32_OperatingSystem::Version.
    //
    // Instead of checking if this is XP (based on "5.1" version), a safer bet
    // is to do this only if we are on the local box. Otherwise display the version from WMI.
    if(m_serviceThread->m_machineName.length() == 0)
    {
        LoadString(HINST_THISDLL, IDS_WINVER_YEAR, _scr2, ARRAYSIZE(_scr2));
        wcscat(_scr2, _scr1);
        SetDlgItemText(IDC_GEN_VERSION_2, _scr2);
    }
    else
    {
        wcscpy(_scr2, (wchar_t *)m_OS.GetString("Version"));
        wcscat(_scr2, _scr1);
        SetDlgItemText(IDC_GEN_VERSION_2, _scr2);
    }
	
    // IDC_GEN_SERVICE_PACK: Service pack (if any)
	SetDlgItemText(IDC_GEN_SERVICE_PACK, m_OS.GetString("CSDVersion"));

	// Do registered user info
	ctlid = IDC_GEN_REGISTERED_0;  // start here and use more as needed

	SetDlgItemText(ctlid++, m_OS.GetString("RegisteredUser"));

	// organization.
	SetDlgItemText(ctlid++, m_OS.GetString("Organization"));

	//productID
	wcscpy(_scr1, (wchar_t *)m_OS.GetString("SerialNumber"));
	ConfigureProductID(_scr1);
	SetDlgItemText(ctlid++, _scr1);

	// another product ID
	wcscpy(_scr1, (wchar_t *)m_OS.GetString("PlusProductID"));
	ConfigureProductID(_scr1);
	SetDlgItemText(ctlid++, _scr1);

	// Do machine info
	ctlid = IDC_GEN_MACHINE_0;  // start here and use controls as needed

	//TODO: get this property back.
	// if OEM ....
	m_manufacturer = m_computer.GetString("Manufacturer");
	if(m_manufacturer.length() > 0)
	{
		SetDlgItemText(ctlid++, m_manufacturer );
		SetDlgItemText(ctlid++, m_computer.GetString("Model"));

		// if there's support info...
		variant_t array;
		long LBound = 2147483647;
		long UBound = 2147483647;
		SAFEARRAY *supportArray = NULL;

		m_computer.Get("SupportContactDescription", (variant_t &)array);
		if(array.vt == (VT_ARRAY | VT_BSTR))
		{
			supportArray = V_ARRAY(&array);
			SafeArrayGetLBound(supportArray, 1, &LBound);
			SafeArrayGetUBound(supportArray, 1, &UBound);

			// turn on the button.
			HWND wnd = GetDlgItem(IDC_GEN_OEM_SUPPORT );
			::EnableWindow( wnd, TRUE );
			::ShowWindow( wnd, SW_SHOW );
		}

#ifdef DOES_NOT_WORK
		// Get the OEMLogo array.
		HBITMAP hDDBitmap;
		HRESULT hr;

		if(SUCCEEDED(hr = m_computer.GetDIB("OEMLogoBitmap", GetDC(),
								 hDDBitmap)))
		{
			::SendMessage(GetDlgItem(IDC_GEN_OEM_IMAGE), 
							STM_SETIMAGE, IMAGE_BITMAP, 
							(LPARAM)hDDBitmap);
            ::ShowWindow(GetDlgItem(IDC_GEN_OEM_NUDGE), SW_SHOWNA);
            ::ShowWindow(GetDlgItem(IDC_GEN_MACHINE), SW_HIDE);
		}
#endif // DOES_NOT_WORK

	} //endif OEM

	// Processor
	SetDlgItemText(ctlid++, m_processor.GetString("Name"));

	// Processor speed
	LoadString(HINST_THISDLL,
               IDS_XDOTX_MHZ,
               _scr2,
               ARRAYSIZE(_scr2));
    wsprintf(_scr1,
             _scr2,
             AddCommas(m_processor.GetLong("CurrentClockSpeed"), szNumBuf1));
	SetDlgItemText(ctlid++, _scr1);

	// Memory
    #define ONEMB   1048576 // 1MB == 1048576 bytes.
    _int64 nTotalBytes = m_computer.GetI64("TotalPhysicalMemory");

    //
    // WORKAROUND - NtQuerySystemInformation doesn't really return the
    // total available physical memory, it instead just reports the total
    // memory seen by the Operating System. Since some amount of memory
    // is reserved by BIOS, the total available memory is reported
    // incorrectly. To work around this limitation, we convert the total
    // bytes to the nearest 4MB value
    //
        
    double   nTotalMB = (double)(nTotalBytes / ONEMB);
    LONGLONG llMem = (LONGLONG)((ceil(ceil(nTotalMB) / 4.0) * 4.0) * ONEMB);

    StrFormatByteSize(llMem, szNumBuf1, ARRAYSIZE(szNumBuf1));
	LoadString(HINST_THISDLL, IDS_XDOTX_MB, _scr2, ARRAYSIZE(_scr2));
	wsprintf(_scr1, _scr2, szNumBuf1);
	SetDlgItemText(ctlid++, _scr1);
}


//--------------------------------------------------------------
LRESULT GeneralPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_serviceThread->Connect(m_pDataObject, m_hWnd);

	if(!m_inited)
	{
		HWND hAnim = GetDlgItem(IDC_ANIMATE);
		Animate_Open(hAnim, MAKEINTRESOURCE(IDR_AVIWAIT));

		TCHAR msg[50] = {0};
		::LoadString(HINST_THISDLL, IDS_UNAVAILABLE, msg, 50);
		SetDlgItemText(IDC_GEN_REGISTERED_0, msg);
	}
	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		if(SUCCEEDED(hr))
		{
			SetWbemService(pServices);
			pServices->Release();

			// check anyway, just to get the side affects.
			if(CimomIsReady())
			{
				HWND hwnd = GetDlgItem(IDC_GEN_WINDOWS_IMAGE);
				SetClearBitmap(hwnd, MAKEINTRESOURCE(IDB_WINDOWS), 0);
				::ShowWindow(hwnd, SW_SHOWNA);

				hwnd = GetDlgItem(IDC_ANIMATE);
				Animate_Close(hwnd);
				::ShowWindow(hwnd, SW_HIDE);

				Init();
				m_inited = true;
			}
			else
			{
				PropSheet_RemovePage(::GetParent(m_hWnd), 2, 0);
				PropSheet_RemovePage(::GetParent(m_hWnd), 1, 0);
			}
		}
	}
	else // connection failed.
	{
		CimomIsReady();  //courtesy call.
		PropSheet_RemovePage(::GetParent(m_hWnd), 2, 0);
		PropSheet_RemovePage(::GetParent(m_hWnd), 1, 0);

		HWND hwnd = GetDlgItem(IDC_GEN_WINDOWS_IMAGE);
		SetClearBitmap(hwnd, MAKEINTRESOURCE(IDB_WINDOWS), 0);
		::ShowWindow(hwnd, SW_SHOWNA);

		hwnd = GetDlgItem(IDC_ANIMATE);
		Animate_Close(hwnd);
		::ShowWindow(hwnd, SW_HIDE);

	}
	return S_OK;
}

//----------------------------------------------
DWORD aGeneralHelpIds[] = {
    IDC_GEN_WINDOWS_IMAGE,         IDH_NO_HELP,
    IDC_TEXT_1,                    (IDH_GENERAL + 0),
    IDC_GEN_VERSION_0,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_1,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_2,             (IDH_GENERAL + 1),
    IDC_GEN_SERVICE_PACK,          (IDH_GENERAL + 1),
    IDC_TEXT_3,                    (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_0,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_1,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 3),
    IDC_GEN_OEM_IMAGE,             IDH_NO_HELP,
    IDC_TEXT_4,                    (IDH_GENERAL + 6),
    IDC_GEN_MACHINE_0,             (IDH_GENERAL + 7),
    IDC_GEN_MACHINE_1,             (IDH_GENERAL + 8),
    IDC_GEN_MACHINE_2,             (IDH_GENERAL + 9),
    IDC_GEN_MACHINE_3,             (IDH_GENERAL + 10),
    IDC_GEN_MACHINE_4,             (IDH_GENERAL + 11),
    IDC_GEN_MACHINE_5,             IDH_NO_HELP,
    IDC_GEN_MACHINE_6,             IDH_NO_HELP,
    IDC_GEN_MACHINE_7,             IDH_NO_HELP,
    IDC_GEN_MACHINE_8,             IDH_NO_HELP,
    IDC_GEN_OEM_SUPPORT,           (IDH_GENERAL + 12),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 14),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 15),
    IDC_GEN_MACHINE,               (IDH_GENERAL + 7),
    IDC_GEN_OEM_NUDGE,             IDH_NO_HELP,
    0, 0
};

LRESULT GeneralPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"sysdm.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)aGeneralHelpIds);

	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"sysdm.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)aGeneralHelpIds);

	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnSupport(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TCHAR text[4096] = {0};
	BSTR temp;
	variant_t array;
	SAFEARRAY *supportArray = NULL;
	long LBound = 2147483647;
	long UBound = 2147483647;

	wcscpy(text, _T(""));

	m_computer.Get("SupportContactDescription", (variant_t &)array);
	supportArray = V_ARRAY(&array);
	SafeArrayGetLBound(supportArray, 1, &LBound);
	SafeArrayGetUBound(supportArray, 1, &UBound);

	for(long i = LBound; i <= UBound; i++)
	{
		SafeArrayGetElement(supportArray, &i, &temp);
		wcscat(text, temp);
		wcscat(text, _T("\r\n"));
	}

	// display the supportContact text.
	DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_PHONESUP),
					GetParent(), PhoneSupportProc, (LPARAM)text);

	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
			//TODO: reread the oemLogo property.
//        SetClearBitmap(GetDlgItem(IDC_GEN_OEM_IMAGE ), oemfile,
//						SCB_FROMFILE | SCB_REPLACEONLY );

        SetClearBitmap(GetDlgItem(IDC_GEN_WINDOWS_IMAGE ),
					    MAKEINTRESOURCE( IDB_WINDOWS ), 0 );
	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetClearBitmap( GetDlgItem(IDC_GEN_OEM_IMAGE ), NULL, 0 );
    SetClearBitmap( GetDlgItem(IDC_GEN_WINDOWS_IMAGE ), NULL, 0 );
	return S_OK;
}

//--------------------------------------------------------------
BOOL GeneralPage::OnApply()
{
//	SetWindowLong(DWL_MSGRESULT, PSNRET_NOERROR);
	return TRUE;
}

//----------------------------------------------------------
INT_PTR CALLBACK PhoneSupportProc(HWND hDlg, UINT uMsg,
							    WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) 
	{
    case WM_INITDIALOG:
		{
			HWND editBox = GetDlgItem(hDlg, IDC_SUPPORT_TEXT);

			// load the edit box.
			SendMessage (editBox, WM_SETREDRAW, FALSE, 0);

			Edit_SetText(editBox, (LPCTSTR)lParam);

			SendMessage (editBox, WM_SETREDRAW, TRUE, 0);

		} //end case

		break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
		{
        case IDOK:
        case IDCANCEL:
             EndDialog( hDlg, 0 );
             break;

        default:
             return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------
DWORD GeneralPage::GetServerTypeResourceID(void)
{
    // This code was taken from the shell internal api, IsOS,
    // located in nt\shell\inc\IsOS.c. This code was derived
    // specifically from the following IsOS() switch statements:
    //     OS_ADVSERVER
    //     OS_DATACENTER
    //     OS_EMBEDDED
    //     OS_PERSONAL
    //     OS_PROFESSIONAL
    //     OS_SERVER
    // These are the only interesting cases used by system cpl.
    //
    // Conditions intentionally verbose (not optimized) for sake
    // of readability.
    //

    variant_t var;
    LONG      ProductType  = 0;
    LONG      fProductSuite = 0;

    if (SUCCEEDED(m_OS.Get("ProductType", var)))
    {
        if (var.vt == VT_I4)
            ProductType = var.iVal;
    }

    if (SUCCEEDED(m_OS.Get("SuiteMask", var)))
    {
        if (var.vt == VT_I4)
            fProductSuite = var.iVal;
    }

    if ((ProductType == VER_NT_SERVER ||
         ProductType == VER_NT_DOMAIN_CONTROLLER) &&
        (fProductSuite & VER_SUITE_ENTERPRISE) &&
        !(fProductSuite & VER_SUITE_DATACENTER))
    {
        return IDS_WINVER_ADVANCEDSERVER;
    }
    else
    if ((ProductType == VER_NT_SERVER ||
         ProductType == VER_NT_DOMAIN_CONTROLLER) &&
        (fProductSuite & VER_SUITE_DATACENTER))
    {
        return IDS_WINVER_DATACENTER;
    }
    else
    if (fProductSuite & VER_SUITE_EMBEDDEDNT)
    {
        return IDS_WINVER_EMBEDDED;
    }
    else
    if (fProductSuite & VER_SUITE_PERSONAL)
    {
        return IDS_WINVER_PERSONAL;
    }
    else
    if (ProductType == VER_NT_WORKSTATION)
    {
        return IDS_WINVER_PROFESSIONAL;
    }
    else
    if ((ProductType == VER_NT_SERVER ||
         ProductType == VER_NT_DOMAIN_CONTROLLER) &&
        !(fProductSuite & VER_SUITE_ENTERPRISE) &&
        !(fProductSuite & VER_SUITE_DATACENTER))
    {
        return IDS_WINVER_SERVER;
    }
    else
    {
        return IDS_WINVER_SERVER;   // Generic catch-all.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\moredlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef MOREDLG_HPP_INCLUDED
#define MOREDLG_HPP_INCLUDED
#pragma once

#include "resource.h"

#include "..\Common\WbemPageHelper.h"
#include <chstring.h>
#include "state.h"

//---------------------------------------------------------------------
class MoreChangesDialog : public CDialogImpl<MoreChangesDialog>,
						public WBEMPageHelper
{
public:

	MoreChangesDialog(WbemServiceThread *serviceThread,
						State &state);
	virtual ~MoreChangesDialog();

	enum ExecuteResult
    {
       NO_CHANGES,
       CHANGES_MADE
    };

	enum { IDD = IDD_MORE };

	BEGIN_MSG_MAP(MoreChangesDialog)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		COMMAND_HANDLER(IDC_CHANGE, BN_CLICKED, OnCommand)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
	void enable();
	int onOKButton();

	State &m_state;
};

#endif MOREDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\moredlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"
#include "moredlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "resource.h"
#include "..\common\util.h"
#include "IDDlg.h"
#include "MoreDlg.h"
#include "NetUtility.h"
#include "NetHelpIDs.h"

static const DWORD _help_map[] =
{
   IDC_DNS,                IDH_IDENT_NAMES_DNS_NAME,
   IDC_CHANGE,             IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX,
   IDC_NETBIOS,            IDH_IDENT_NAMES_NETBIOS_NAME,
   0, 0
};

//---------------------------------------------------------------------
MoreChangesDialog::MoreChangesDialog(WbemServiceThread *serviceThread,
									 State &state) 
						: WBEMPageHelper(serviceThread),
						m_state(state)
{
}

//-------------------------------------------------------------
MoreChangesDialog::~MoreChangesDialog()
{
}

//----------------------------------------------------------
void MoreChangesDialog::enable()
{
   bool enabled = false;// = WasChanged(IDC_CHANGE) ||
				//	WasChanged(IDC_DNS) &&
				//	!GetTrimmedDlgItemText(m_hWnd, IDC_DNS).IsEmpty();

   ::EnableWindow(GetDlgItem(IDOK), enabled);
}

//----------------------------------------------------------
LRESULT MoreChangesDialog::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   m_hDlg = m_hWnd;

   // Marshalling shouldn't happen here.
	m_WbemServices = g_serviceThread->m_WbemServices;

	SetDlgItemText(IDC_DNS, m_state.GetComputerDomainDNSName());
   
	SetDlgItemText(IDC_NETBIOS, m_state.GetNetBIOSComputerName());
	CheckDlgButton(IDC_CHANGE, (m_state.GetSyncDNSNames() ? BST_CHECKED : BST_UNCHECKED));

	enable();
	return S_OK;
}

//----------------------------------------------------------
int MoreChangesDialog::onOKButton()
{
   int end_code = 0;

//   if(WasChanged(IDC_CHANGE))
   {
      m_state.SetSyncDNSNames(IsDlgButtonChecked(IDC_CHANGE) == BST_CHECKED);
      end_code = 1;
   }
      
//   if (WasChanged(IDC_DNS))
   {
      // compare the new value to the old one.  If they're different,
      // validate and save the new value
      CHString new_domain = GetTrimmedDlgItemText(m_hWnd, IDC_DNS);
      CHString old_domain = m_state.GetComputerDomainDNSName();

      if(new_domain.CompareNoCase(old_domain) != 0)
      {
/*         switch (DNS::ValidateDNSNameSyntax(new_domain))
         {
            case DNS::NON_RFC_NAME:
            {
               MessageBox(String::format(IDS_NON_RFC_NAME, 
							new_domain.c_str()),
							String::load(IDS_APP_TITLE),
							MB_OK | MB_ICONWARNING);
               // fall-thru
            }
            case DNS::VALID_NAME:
            {
               m_state.SetComputerDomainDNSName(new_domain);
               end_code = 1;
               break;
            }
            case DNS::INVALID_NAME:
            {
               end_code = -1;
               gripe(hwnd, IDC_DNS,
						String::format(IDS_BAD_DNS_SYNTAX, 
						new_domain.c_str()),
						IDS_APP_TITLE);
               break;
            }
            case DNS::NAME_TOO_LONG:
            {
               end_code = -1;               
               gripe(hwnd, IDC_DNS,
					String::format(IDS_DNS_NAME_TOO_LONG,
									new_domain.c_str(),
									DNS::MAX_NAME_LENGTH),
					IDS_APP_TITLE);
               break;
            }
            default:
            {
               assert(false);
               break;
            }
         }
*/
      }
   }

   return end_code;
}

//----------------------------------------------------------
LRESULT MoreChangesDialog::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
   switch (wID)
   {
      case IDOK:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            int end_code = onOKButton();
            if (end_code != -1)
            {
               EndDialog(end_code);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            // 0 => no changes made
            EndDialog(NO_CHANGES);
         }
         break;
      }
      case IDC_CHANGE:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            enable();
         }
         break;
      }
      case IDC_DNS:
      {
         if (wNotifyCode == EN_CHANGE)
         {
            enable();
         }
         break;
      }
      default:
      {
		  bHandled = false;
         break;
      }
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\netidpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __NETWORKIDPAGE__
#define __NETWORKIDPAGE__
#pragma once

#include "atlsnap.h"
#include "resource.h"
#include "state.h"
#include "..\Common\WbemPageHelper.h"

//---------------------------------------------------------------------
class NetworkIDPage : public CSnapInPropertyPageImpl<NetworkIDPage>,
						public WBEMPageHelper
{
public:

	NetworkIDPage(WbemServiceThread *serviceThread,
					LONG_PTR lNotifyHandle, 
					bool bDeleteHandle = false, 
					TCHAR* pTitle = NULL);

	~NetworkIDPage();

	enum { IDD = IDD_NETID };

	typedef CSnapInPropertyPageImpl<NetworkIDPage> _baseClass;

	BEGIN_MSG_MAP(NetworkIDPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnConnected)
		COMMAND_HANDLER(IDC_CHANGE, BN_CLICKED, OnChangeBtn)
		COMMAND_HANDLER(IDC_NETID_COMMENT, EN_CHANGE, OnComment)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnChangeBtn(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnComment(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	BOOL OnApply();
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
	State m_state;
	CWbemClassObject m_computer;
	CWbemClassObject m_OS;
	CWbemClassObject m_DNS;

	void refresh();
	bool CimomIsReady();

	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;

};

#endif __NETWORKIDPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\nethelpids.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#define IDH_IDENT_FULL_NAME			5101
#define IDH_IDENT_MEMBER_OF			5102
#define IDH_IDENT_CHANGE_BUTTON			5103
#define IDH_IDENT_CHANGES_NEW_NAME		5104
#define IDH_IDENT_CHANGES_PREVIEW_NAME	5105
#define IDH_IDENT_CHANGES_MORE_BUTTON		5106
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN	5107
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX	5108
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP	5109
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX 5110
#define IDH_IDENT_NAMES_DNS_NAME		5111
#define IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX 5112
#define IDH_IDENT_NAMES_NETBIOS_NAME		5113

//#define IDH_WBEM_NETID_COMPUTER_DESCRIPTION		13001 - use below instead
#define IDH_COMPUTER_DESCRIPTION		5115
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\netidpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "resource.h"
#include "..\common\util.h"
#include "NetIDPage.h"
#include "NetHelpIDs.h"
#include "iddlg.h"
#include "NetUtility.h"
#include <dsrole.h>

#define MAX_ID_LENGTH 256

//---------------------------------------------------------------------
NetworkIDPage::NetworkIDPage(WbemServiceThread *serviceThread,
							 LONG_PTR lNotifyHandle, 
							 bool bDeleteHandle, 
							 TCHAR* pTitle) 
						: WBEMPageHelper(serviceThread),
							CSnapInPropertyPageImpl<NetworkIDPage> (pTitle),
							m_lNotifyHandle(lNotifyHandle),
							m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
}

//-------------------------------------------------------------
NetworkIDPage::~NetworkIDPage()
{
}

//-------------------------------------------------------------
bool NetworkIDPage::CimomIsReady()
{
	m_hDlg = m_hWnd;

	bool retval = ServiceIsReady(NO_UI, 0, 0);

	if(retval)
	{
		// This where it should be marshalling into THIS thread.
		m_WbemServices = m_serviceThread->m_WbemServices;

		IWbemClassObject *pInst = NULL;

		if((pInst = FirstInstanceOf("Win32_ComputerSystem")) != NULL)
		{
			m_computer = pInst;
		}

		if((pInst = FirstInstanceOf((bstr_t)"Win32_OperatingSystem")) != NULL)
		{
			m_OS = pInst;
		}

		if((pInst = FirstInstanceOf((bstr_t)"Win32_NetworkAdaptorConfiguration")) != NULL)
		{
			m_DNS = pInst;
		}
		m_state.Init(m_computer, m_OS, m_DNS);
	}
	return retval;
}

//-------------------------------------------------------
LRESULT NetworkIDPage::OnChangeBtn(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
/*    IDChangesDialog dlg(g_serviceThread, m_state);
    dlg.DoModal();
    if(m_state.MustReboot())
    {
       PropSheet_RebootSystem(GetParent());
    }
    m_state.Refresh();
    refresh();*/
	return S_OK;
}

//----------------------------------------------------------
TCHAR szCommentReg[]  = TEXT( "System\\ControlSet001\\Services\\LanmanServer\\Parameters" );

void NetworkIDPage::refresh()
{

	DWORD role = (DWORD)m_computer.GetLong("DomainRole");

	bool memberOfWorkgroup = ((role == DsRole_RoleStandaloneWorkstation) ||
								(role == DsRole_RoleStandaloneServer));

	//If we have the DNSName property, use it, otherwise use the NetBios name like we used to...
   _bstr_t bstrComputer = m_computer.GetString("DNSHostName");
   if (bstrComputer.length() == 0)
	   		bstrComputer = m_computer.GetString("Name");

   _bstr_t bstrDomain   = m_computer.GetString("Domain");

   if( !memberOfWorkgroup ) {
	    bstrComputer += _T(".");
	    bstrComputer += bstrDomain;
   }

    _tcslwr(bstrComputer);

    SetDlgItemText(IDC_COMPUTER, bstrComputer);

    SetDlgItemText(IDC_DOMAIN, bstrDomain);

    SetDlgItemText(IDC_NETID_COMMENT, 
					m_OS.GetString("Description"));


	BOOL enable = FALSE;
	HWND hwnd = ::GetDlgItem(m_hWnd, IDC_NETID_COMMENT);
	RemoteRegWriteable(szCommentReg, enable);
	::EnableWindow(hwnd, enable);
	::SendMessage(hwnd, EM_LIMITTEXT, MAX_ID_LENGTH, 0);


//#ifdef NO_SYSTEM_CPL_EQUIVALENT_BEHAVIOR
	TCHAR temp[50] = {0};

	::LoadString(HINST_THISDLL,
					(memberOfWorkgroup ?
						IDS_MEMBER_OF_WORKGROUP :
						IDS_MEMBER_OF_DOMAIN),
					temp, 50);

   SetDlgItemText(IDC_MEMBER_OF, temp);
//#endif // NO_SYSTEM_CPL_EQUIVALENT_BEHAVIOR

   //bool show_change = IsCurrentUserAdministrator()
	//				  && !m_state.IsMachineDC()
	//				  && (m_state.IsNetworkingInstalled() || 
	//						m_state.IsMemberOfWorkgroup());

   //::EnableWindow(GetDlgItem(IDC_CHANGE), show_change);

   ::ShowWindow(GetDlgItem(IDC_SAVING_MESSAGE),
					m_state.NeedsReboot() ? SW_SHOW : SW_HIDE);
}


//----------------------------------------------------------
LRESULT NetworkIDPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(CimomIsReady())
	{
		refresh();
	}
	else
	{
		if(m_serviceThread)
		{
			m_serviceThread->SendPtr(m_hWnd);
		}

		// no connection yet.
		TCHAR msg[50] = {0};

		::LoadString(HINST_THISDLL, IDS_UNAVAILABLE, msg, 50);

		SetDlgItemText(IDC_COMPUTER, msg);
		SetDlgItemText(IDC_DOMAIN, msg);
		SetDlgItemText(IDC_NETID_COMMENT, msg);

		HWND hwnd = ::GetDlgItem(m_hWnd, IDC_NETID_COMMENT);
		::EnableWindow(hwnd, FALSE);
		::SendMessage(hwnd, EM_LIMITTEXT, 48, 0);


		::EnableWindow(GetDlgItem(IDC_CHANGE), FALSE);
	    ::ShowWindow(GetDlgItem(IDC_SAVING_MESSAGE), SW_HIDE);
	}

	return S_OK;
}

//----------------------------------------------------------
LRESULT NetworkIDPage::OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);		
		if(SUCCEEDED(hr))
		{
			SetWbemService(pServices);
			pServices->Release();

			if(CimomIsReady())
			{
				refresh();
			}
		}
	}
	else
	{
		::EnableWindow(GetDlgItem(IDC_NETID_COMMENT), FALSE);
	}

	return S_OK;
}

//--------------------------------------------------------------
LRESULT NetworkIDPage::OnComment(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	// activate Apply for the comment change
	::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
	return S_OK; 
}

//--------------------------------------------------------------
static const DWORD _help_map[] =
{
   IDC_COMPUTER,        IDH_IDENT_FULL_NAME,
   IDC_FULL_NAME,       IDH_IDENT_FULL_NAME,
   IDC_MEMBER_OF,       IDH_IDENT_MEMBER_OF,
   IDC_DOMAIN,          IDH_IDENT_MEMBER_OF,
   IDC_CHANGE,          IDH_IDENT_CHANGE_BUTTON,
   IDC_COMMENT,			IDH_COMPUTER_DESCRIPTION, //was IDH_WBEM_NETID_COMPUTER_DESCRIPTION
   IDC_NETID_COMMENT,   IDH_COMPUTER_DESCRIPTION, //was IDH_WBEM_NETID_COMPUTER_DESCRIPTION
   IDC_NETID_SELECT_ICON,   -1,
   IDC_PARA,				IDH_NO_HELP,
   0, 0
};

LRESULT NetworkIDPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"sysdm.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)_help_map);
	return S_OK;
}

//--------------------------------------------------------------
LRESULT NetworkIDPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"sysdm.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)_help_map);
	return S_OK;
}

//--------------------------------------------------------------
BOOL NetworkIDPage::OnApply()
{
	WCHAR szMsg[MAX_ID_LENGTH +2] = {0};
	HRESULT hr = 0;

	CWindow msgHWND(GetDlgItem(IDC_NETID_COMMENT));

	BOOL modified = (BOOL)msgHWND.SendMessage(EM_GETMODIFY);

	if((bool)m_WbemServices && modified)
	{
		::GetWindowText(msgHWND, szMsg, ARRAYSIZE(szMsg) -1);

		//Now create a new Instance and populate only the properties which are modified
		CWbemClassObject newinst = m_OS.SpawnInstance();
		hr = newinst.Put("Description", (bstr_t)szMsg);
		_bstr_t name;
		hr = m_OS.Get("Name",name);
		hr = newinst.Put("Name",name);
		hr = m_WbemServices.PutInstance(newinst);
		if(FAILED(hr))
		{
			TCHAR caption[50] = {0}, text[500] = {0};

			::LoadString(HINST_THISDLL, 
							IDS_DISPLAY_NAME,
							caption, 50);

			::LoadString(HINST_THISDLL, 
							IDS_CANT_WRITE_COMMENT,
							text, 500);

			::MessageBox(NULL, text, caption,
						MB_OK | MB_ICONHAND);

		}
	}

	return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\netutility.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// global utility functions
// 
// 8-14-97 sburns


// KMH: originally named burnslib\utility.* but that filename was
// getting a little overused.

// threadsafe

#include "precomp.h"
#include "netUtility.h"

#define ACCESS_READ  1
#define ACCESS_WRITE 2

int Round(double n)
{
   int n1 = (int) n;
   if (n - n1 >= 0.5)
   {
      return n1 + 1;
   }

   return n1;
}



// threadsafe

void gripe(HWND parentDialog, int editResID, int errStringResID)
{
   //gripe(parentDialog, editResID, String::load(errStringResID));
}



void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message,
		   int            titleResID)
{
   //gripe(parentDialog, editResID, message, String::load(titleResID));
}



void gripe(HWND parentDialog,
		   int editResID,
		   const CHString& message,
		   const CHString& title)
{
//   ATLASSERT(::IsWindow(parentDialog));   
//   ATLASSERT(!message.empty());
//   ATLASSERT(editResID > 0);

   ::MessageBox(parentDialog, message,
				title, MB_OK | MB_ICONERROR | MB_APPLMODAL);

   HWND edit = ::GetDlgItem(parentDialog, editResID);
   ::SendMessage(edit, EM_SETSEL, 0, -1);
   ::SetFocus(edit);
}



void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID)
{
   //gripe(parentDialog, editResID, hr, message, String::load(titleResID));
}
   


void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   const CHString&  title)
{
   //error(parentDialog, hr, message, title);

   HWND edit = ::GetDlgItem(parentDialog, editResID);
   ::SendMessage(edit, EM_SETSEL, 0, -1);
   ::SetFocus(edit);
}


// threadsafe

void gripe(HWND parentDialog, int editResID, const CHString& message)
{
   //gripe(parentDialog, editResID, message, String());
}



void FlipBits(long& bits, long mask, bool state)
{
 //  ATLASSERT(mask);

   if (state)
   {
      bits |= mask;
   }
   else
   {
      bits &= ~mask;
   }
}



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message)
{
   //error(parent, hr, message, String());
}



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID)
{
   //ATLASSERT(titleResID > 0);

   //error(parent, hr, message, String::load(titleResID));
}



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message,
		   const CHString&  title)
{
//   ATLASSERT(::IsWindow(parent));
//   ATLASSERT(!message.empty());

   CHString new_message = message + TEXT("\n\n");
   if (FAILED(hr))
   {
      if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
      {
//         new_message +=  GetErrorMessage(hr & 0x0000ffff);
      }
      else
      {
//         new_message += CHString::Format(IDS_HRESULT_SANS_MESSAGE, hr);
      }
   }

   MessageBox(parent, new_message,
				title, MB_ICONERROR | MB_OK | MB_APPLMODAL);
}



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID,
		   int            titleResID)
{
//   error(parent, hr, String::load(messageResID), String::load(titleResID));
}



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID)
{
  // error(parent, hr, String::load(messageResID));
}



BOOL IsCurrentUserAdministrator()
{   
   HANDLE hToken;
   DWORD  dwStatus;
   DWORD  dwAccessMask;
   DWORD  dwAccessDesired;
   DWORD  dwACLSize;
   DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
   PACL   pACL            = NULL;
   PSID   psidAdmin       = NULL;
   BOOL   bReturn         = FALSE;
   PRIVILEGE_SET   ps;
   GENERIC_MAPPING GenericMapping;   PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
   
   __try {
       // AccessCheck() requires an impersonation token.
       ImpersonateSelf(SecurityImpersonation);
       if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE,&hToken)) 
        {
            if (GetLastError() != ERROR_NO_TOKEN)
                __leave;// If the thread does not have an access token, we'll 
                // examine the access token associated with the process.
                if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
                __leave;
            }
            if (!AllocateAndInitializeSid(
                    &SystemSidAuthority, 
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0, &psidAdmin))
            __leave;
            psdAdmin = LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
            if (psdAdmin == NULL)
                __leave;
            if (!InitializeSecurityDescriptor(
                psdAdmin,
                SECURITY_DESCRIPTOR_REVISION))
            __leave;
  
            // Compute size needed for the ACL.
            dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid(psidAdmin) - sizeof(DWORD);      // Allocate memory for ACL.
            pACL = (PACL)LocalAlloc(LPTR, dwACLSize);
            if (pACL == NULL)
                __leave;      // Initialize the new ACL.
            if (!InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
                __leave;
            dwAccessMask= ACCESS_READ | ACCESS_WRITE;
      
            // Add the access-allowed ACE to the DACL.
            if (!AddAccessAllowedAce(pACL, ACL_REVISION2,
                dwAccessMask, psidAdmin))
                __leave;      // Set our DACL to the SD.
            if (!SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE))
                __leave;      // AccessCheck is sensitive about what is in the SD; set
            // the group and owner.
            SetSecurityDescriptorGroup(psdAdmin, psidAdmin, FALSE);
            SetSecurityDescriptorOwner(psdAdmin, psidAdmin, FALSE);
            if (!IsValidSecurityDescriptor(psdAdmin))
                __leave;
            dwAccessDesired = ACCESS_READ;      // 
            // Initialize GenericMapping structure even though we
            // won't be using generic rights.
            // 
            GenericMapping.GenericRead    = ACCESS_READ;
            GenericMapping.GenericWrite   = ACCESS_WRITE;
            GenericMapping.GenericExecute = 0;
            GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;
            
            if (!AccessCheck(psdAdmin, hToken, dwAccessDesired, 
                &GenericMapping, &ps, &dwStructureSize, &dwStatus, 
                &bReturn)) {
                __leave;
            }
            
      } __finally {      // Cleanup 
      RevertToSelf();
      if (pACL) LocalFree(pACL);
      if (psdAdmin) LocalFree(psdAdmin);  
      if (psidAdmin) FreeSid(psidAdmin);
   }   
   return bReturn;
}

bool IsTCPIPInstalled()
{

/*   HKEY key = 0;
   LONG result =
      Win::RegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Linkage"),
         KEY_QUERY_VALUE,
         key);

   if (result == ERROR_SUCCESS)
   {
      DWORD data_size = 0;
      result =
         Win::RegQueryValueEx(
            key,
            TEXT("Export"),
            0,
            0,
            &data_size);
      ATLASSERT(result == ERROR_SUCCESS);

      if (data_size > 2)
      {
         // the value is non-null
         return true;
      }
   }
*/
   return false;
}



CHString GetTrimmedDlgItemText(HWND parentDialog, UINT itemResID)
{
//   ATLASSERT(IsWindow(parentDialog));
//   ATLASSERT(itemResID > 0);

   HWND item = GetDlgItem(parentDialog, itemResID);
   if (!item)
   {
      // The empty string
      return CHString();
   }
   TCHAR temp[256] = {0};

   ::GetWindowText(item, temp, 256);
   return CHString(temp);
}


void StringLoad(UINT resID, LPCTSTR buf, UINT size)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\perfpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "PerfPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include <windowsx.h>
#include "helpid.h"

DWORD aPerformanceHelpIds[] = {
    IDOK,                        IDH_NO_HELP,
    IDCANCEL,                    IDH_NO_HELP,
    IDC_PERF_VM_ALLOCD,          (IDH_PERF + 1),
    IDC_PERF_VM_ALLOCD_LABEL,    (IDH_PERF + 1),
    IDC_PERF_GROUP,              -1,
    IDC_PERF_TEXT,               (IDH_PERF + 3),
    IDC_PERF_TEXT2,              -1,
    IDC_PERF_VM_ALLOCD_TEXT,     -1,
    IDC_PERF_WORKSTATION,        (IDH_PERF + 4),
    IDC_PERF_SERVER,             (IDH_PERF + 5),
    IDC_PERF_VM_GROUP,           -1,
    IDC_PERF_VM_ALLOCD_TEXT,     -1,
    IDC_PERF_CHANGE,             (IDH_PERF + 7),
    IDC_PERF_CACHE_GROUP,        -1,
    IDC_PERF_CACHE_TEXT,         -1,
    IDC_PERF_CACHE_TEXT2,        -1,
    IDC_PERF_APPS,               (IDH_PERF + 14),
    IDC_PERF_SYSCACHE,           (IDH_PERF + 15),
    0, 0
};


#define PROCESS_PRIORITY_SEPARATION_MIN     0
#define PROCESS_PRIORITY_SEPARATION_MAX     2

#define PERF_TYPEVARIABLE       1
#define PERF_TYPEFIXED          2

#define PERF_LENLONG            1
#define PERF_LENSHORT           2

#define OPTIMIZE_APPS           0
#define OPTIMIZE_CACHE          1

INT_PTR CALLBACK StaticPerfDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	PerfPage *me = (PerfPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
PerfPage::PerfPage(WbemServiceThread *serviceThread)
				: WBEMPageHelper(serviceThread)
{
    m_dwPrevCacheOption = m_dwCurCacheOption = 0;
	m_nowWorkstation = m_wasWorkstation = false;
	IWbemClassObject *pInst = NULL;

	// NOTE: This one's a little different. I create it right away so
	// I can use it as a helper even before I put up its' dlg.
	m_VDlg = new VirtualMemDlg(m_serviceThread);

	// its all in one class.
	if((pInst = FirstInstanceOf("Win32_OperatingSystem")) != NULL)
	{
		m_os = pInst;
	}
}
//--------------------------------------------------------------
INT_PTR PerfPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_PERFORMANCE),
						hDlg, StaticPerfDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
PerfPage::~PerfPage()
{
	delete m_VDlg;
}
//--------------------------------------------------------------
INT_PTR CALLBACK PerfPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
    static BOOL fVMInited = FALSE;
    DWORD dw;
	HRESULT hr = 0;
    BOOL bDirty = FALSE;

	m_hDlg = hwndDlg;

	switch (message) 
	{
	case WM_INITDIALOG:
		Init();
		return TRUE; 
		break;

    case WM_DESTROY:
        // If the dialog box is going away, then close the
        // registry key.
        if (fVMInited) 
		{
//            VirtualFreeStructures();
        }
        break;

    case WM_COMMAND: 
		
        switch (LOWORD(wParam)) 
		{
        case IDC_PERF_CHANGE: 

			dw = m_VDlg->DoModal(m_hDlg);

			if (fVMInited) 
			{
				unsigned long val = 0;
				m_VDlg->ComputeAllocated(&val);
	            SetDlgItemMB(m_hDlg, IDC_PERF_VM_ALLOCD, val);
			}
/*****************
			if((dw != RET_NO_CHANGE) && 
			   (dw != RET_CHANGE_NO_REBOOT)) 
			{
				MsgBoxParam(m_hDlg, SYSTEM + 39, IDS_TITLE,
							MB_OK | MB_ICONINFORMATION);

                g_fRebootRequired = TRUE;
			}
********************/
          
            break;
        case IDC_PERF_WORKSTATION:
            if(BN_CLICKED == HIWORD(wParam)) 
			{
				m_nowWorkstation = true;

                // Workstations have maximum foreground boost
                m_appBoost = PROCESS_PRIORITY_SEPARATION_MAX;

                // Workstations have variable, short quanta
                m_quantLength = PERF_LENSHORT;
                m_quantType = PERF_TYPEVARIABLE;
            }  
            break;

        case IDC_PERF_SERVER:
            if(BN_CLICKED == HIWORD(wParam)) 
			{
				m_nowWorkstation = false;

                // Servers have minimum foreground boost
                m_appBoost = PROCESS_PRIORITY_SEPARATION_MIN;

                // Servers have fixed, long quanta
                m_quantLength = PERF_LENLONG;
                m_quantType = PERF_TYPEFIXED;
            }
            break;

        case IDC_PERF_APPS:
            if(BN_CLICKED == HIWORD(wParam)) 
            {
                m_dwCurCacheOption = OPTIMIZE_APPS;
                g_fRebootRequired = (m_dwCurCacheOption != m_dwPrevCacheOption);
            }
            break;

        case IDC_PERF_SYSCACHE:
            if(BN_CLICKED == HIWORD(wParam)) 
            {
                m_dwCurCacheOption = OPTIMIZE_CACHE;
                g_fRebootRequired = (m_dwCurCacheOption != m_dwPrevCacheOption);
            }
            break;

		case IDOK:
			if (m_wasWorkstation != m_nowWorkstation)       // Change?
            {
				if((bool)m_os)
				{
					hr = m_os.Put(_T("ForegroundApplicationBoost"),
                                     variant_t((BYTE)m_appBoost));
					hr = m_os.Put(_T("QuantumType"),
                                      variant_t((BYTE)m_quantType));
					hr = m_os.Put(_T("QuantumLength"),
                                      variant_t((BYTE)m_quantLength));
                    bDirty = TRUE;
                }
                else
                {
                    MsgBoxParam(m_hDlg, IDS_LOST_CONNECTION, IDS_TITLE,
                                MB_OK | MB_ICONINFORMATION);
                    EndDialog(m_hDlg, 0);
                }
            }

            if (m_dwPrevCacheOption != m_dwCurCacheOption)  // Change?
			{
				if((bool)m_os)
				{
                    hr = m_os.Put(_T("LargeSystemCache"),
                                  (long)m_dwCurCacheOption);
                    if (SUCCEEDED(hr))
                    {
                        bDirty = TRUE;
                        MsgBoxParam(m_hDlg, IDS_MUST_REBOOT, IDS_SYS_CHANGE_CAPTION, MB_OK | MB_ICONINFORMATION, NULL, NULL);
                    }
                }
                else
                {
                    MsgBoxParam(m_hDlg, IDS_LOST_CONNECTION, IDS_TITLE,
                                MB_OK | MB_ICONINFORMATION);
                    EndDialog(m_hDlg, 0);
                }
            }

            if (bDirty)
            {
                hr = m_WbemServices.PutInstance(m_os,
                                                WBEM_FLAG_CREATE_OR_UPDATE);
            }
            EndDialog(m_hDlg, 0);
            break;

        case IDCANCEL:
            EndDialog(m_hDlg, 0);
            break;

        default: 
            break;
        } //endswitch LOWORD

        break;

    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aPerformanceHelpIds);

        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
		        (ULONG_PTR)(LPSTR)aPerformanceHelpIds);
        break;

    default:
        return FALSE;
	} 

	return FALSE; 
}

//--------------------------------------------------------------------
// TCHAR szPriKey[]  = TEXT("System\\CurrentControlSet\\Control\\PriorityControl");
TCHAR szPriMemoryKey[]  = TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

void PerfPage::Init(void)
{
	HRESULT h1 = 0, h2 = 0, h3 = 0;
    HRESULT hr;

	// if anything goes wrong, act like a server.
    m_appBoost = PROCESS_PRIORITY_SEPARATION_MIN;
    m_quantType = PERF_TYPEVARIABLE;
    m_quantLength = PERF_LENLONG;

	// if the class was found...
	if((bool)m_os)
	{
		// NOTE: I want the return codes. Dont use GetLong() is the case.
		h1 = m_os.Get(_T("QuantumType"), m_quantType);
		h2 = m_os.Get(_T("QuantumLength"), m_quantLength);
		h3 = m_os.Get(_T("ForegroundApplicationBoost"), m_appBoost);

		// did it all work?
		if((h1 == 0) && (h2 == 0) && (h3 == 0))
		{	        
            bool bWorkstation;

            // if it's never been set, quantLength & quantType are zero.
            //  - determine whether we're on wks or srv
            if ((m_quantLength == 0) && (m_quantType == 0))
            {
       			bWorkstation = true;
       			m_quantLength = PERF_LENSHORT;
                m_quantType = PERF_TYPEVARIABLE;

                IWbemClassObject *pInst = NULL;

                if (pInst = FirstInstanceOf("Win32_ComputerSystem"))
                {
                    CWbemClassObject obj = pInst;

                    long role;
                    obj.Get((bstr_t)"DomainRole", role);

                    if (role > 1)
                    {
                        bWorkstation = false;
               			m_quantLength = PERF_LENLONG;
                        m_quantType = PERF_TYPEFIXED;
                    }
                    
                    pInst->Release();
                }
                // else - we just use defaults from above

            }
            else if ((m_quantLength == PERF_LENSHORT) && 
			   (m_quantType == PERF_TYPEVARIABLE))
               bWorkstation = true;
            else
                bWorkstation = false;
            
            //-----------------------------------------
			// Short, Variable Quanta (or 2 zeros) == Workstation-like interactive response.
			// Long, Fixed Quanta == Server-like interactive response.
			if(bWorkstation)
			{
				m_appBoost = PROCESS_PRIORITY_SEPARATION_MAX;
			
				// to optimize Puts later.
				m_nowWorkstation = m_wasWorkstation = true;

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION),
									BST_CHECKED);

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SERVER),
									BST_UNCHECKED);

			}
			else // its a server.
			{
				m_appBoost = PROCESS_PRIORITY_SEPARATION_MIN;
				m_nowWorkstation = m_wasWorkstation = false;

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION),
									BST_UNCHECKED);

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SERVER),
									BST_CHECKED);

			}

			BOOL writable = TRUE;
			// NOTE: for backwards compability with wmi builds that didn't have this
			// method (in RemoteRegWriteable()), assume 'true' unless a newer build says you cant do this.

			RemoteRegWriteable(szPriMemoryKey, writable);
            ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_APPS), writable);
			::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE), writable);
            ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION), writable);
			::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SERVER), writable);

		} // endif it worked

    }
	else
	{
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION), FALSE);
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SERVER), FALSE);
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_APPS), FALSE);
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE), FALSE);
	} //endif class was found.

    //
    // Get LargeSystemCache property and set controls correspondingly.
    //
    hr = m_os.Get(_T("LargeSystemCache"), (long&)m_dwPrevCacheOption);
    m_dwCurCacheOption = m_dwPrevCacheOption;

    if (SUCCEEDED(hr))
    {
        if (m_dwPrevCacheOption == OPTIMIZE_APPS)
        {
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_APPS),
                                       BST_CHECKED);
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE),
                                       BST_UNCHECKED);
        }
        else if (m_dwPrevCacheOption == OPTIMIZE_CACHE)
        {
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_APPS),
                                       BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE),
                                       BST_CHECKED);
        }
        else        // Unsupported/unknown value - disable the controls.
        {
            ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_APPS), FALSE);
            ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE), FALSE);
        }
    }
    else
    {
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_APPS), FALSE);
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE), FALSE);
    }

    // Init the virtual memory part.
	unsigned long vAlloc = 0;
	bool enable = m_VDlg->ComputeAllocated(&vAlloc);
	if(enable)
	{
		SetDlgItemMB( m_hDlg, IDC_PERF_VM_ALLOCD, vAlloc );
	}
	else
	{
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_VM_ALLOCD_LABEL), FALSE);
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_VM_ALLOCD), FALSE);
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_CHANGE), FALSE);
		MsgBoxParam(m_hDlg, IDS_NO_VM, IDS_TITLE, MB_OK|MB_ICONWARNING);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\netutility.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// global utility functions
// 
// 8-14-97 sburns

                           
// KMH: originally named burnslib\utility.* but that filename was
// getting a little overused.

#ifndef UTILITY_HPP_INCLUDED
#define UTILITY_HPP_INCLUDED

#include <chstring.h>
#include <dsrole.h>

//TODO
#define SRV_RECORD_RESERVE = 100
#define MAX_NAME_LENGTH = 2-SRV_RECORD_RESERVE
#define MAX_LABEL_LENGTH = 2

#define BREAK_ON_FAILED_HRESULT(hr)                               \
   if (FAILED(hr))                                                \
   {                                                              \
      TRACE_HRESULT(hr);                                          \
      break;                                                      \
   }



void
error(HWND           parent,
	   HRESULT        hr,
	   const CHString&  message,
	   const CHString&  title);



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message);


void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID);



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID,
		   int            titleResID);



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID);



// Sets or clears a bit, or set of bits.
// 
// bits - bit set where bits will be set.
// 
// mask - mask of bits to be effected.
// 
// state - true to set the mask bits, false to clear them.

void FlipBits(long& bits, long mask, bool state);



// Present a message box dialog, set input focus back to a given edit
// box when the dialog is dismissed.
// 
// parentDialog - the parent window containing the control to receive focus.
//
// editResID - Resource ID of the edit box to which focus will be set.
// 
// errStringResID - Resource ID of the message text to be shown in the
// dialog.  The title of the dialog is "Error".

void gripe(HWND  parentDialog,
		   int   editResID,
		   int   errStringResID);



// Present a message box dialog, set input focus back to a given edit
// box when the dialog is dismissed.  The title of the message box is "Error".
// 
// parentDialog - the parent window containing the control to receive focus.

// editResID - Resource ID of the edit box to which focus will be set.
//
// message - Text to appear in the dialog.  The title is "Error".

void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message);


void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message,
		   int            titleResID);


// Present a message box dialog, set input focus back to a given edit
// box when the dialog is dismissed.
//
// parentDialog - the parent window containing the control to receive focus.
// 
// editResID - Resource ID of the edit box to which focus will be set.
//
// message - Text to appear in the dialog.
//
// title - The title of the message box.  An empty String causes the title
// to be "Error".

void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message,
		   const CHString&  title);



void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   const CHString&  title);



void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID);



// Returns the HINSTANCE of the DLL designated to contain all resources. 
//
// This function requires that the first module loaded (whether it be a DLL or
// EXE) set the global variable hResourceModuleHandle to the HINSTANCE of the
// module (DLL or EXE) that contains all of the program's binary resources.
// This should be done as early as possible in the module's startup code.


// Returns true if current process token contains administrators membership.

BOOL IsCurrentUserAdministrator();



// Returns true if tcp/ip protocol is installed and bound.

bool IsTCPIPInstalled();


// Return the next highest whole number greater than n if the
// fractional portion of n >= 0.5, otherwise return n.

int Round(double n);

CHString GetTrimmedDlgItemText(HWND parentDialog, UINT itemResID);

void StringLoad(UINT resID, LPCTSTR buf, UINT size);

#endif UTILITY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\rebootpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __REBOOTPAGE__
#define __REBOOTPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"

//-----------------------------------------------------------------------------
class RebootPage : public WBEMPageHelper
{
private:

	void Init(HWND hDlg);
	bool Doit(HWND hDlg);

	CWbemClassObject m_OS;

public:

    RebootPage(WbemServiceThread *serviceThread);
	~RebootPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticRebootDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __REBOOTPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\perfpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __PERFPAGE__
#define __PERFPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"
#include "VirtualMemDlg.h"

//-----------------------------------------------------------------------------
//  Reboot switch for crashdump dlg
#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10

#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)

class PerfPage : public WBEMPageHelper
{
private:

	VirtualMemDlg *m_VDlg;
	CWbemClassObject m_os;

	// the current values.
    long    m_appBoost;
    long    m_quantType;
    long    m_quantLength;
    DWORD   m_dwPrevCacheOption;
    DWORD   m_dwCurCacheOption;
    
	// before and after states of the radio buttons.
	bool    m_wasWorkstation;
	bool    m_nowWorkstation;

	void Init(void);

public:

    PerfPage(WbemServiceThread *serviceThread);
	~PerfPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticPerfDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __PERFPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
};

extern CExeModule  _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <math.h>


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CMProps.rc
//
#define CX_CDWN_OFFS                    0
#define IDS_DRIVES_DISPLAY_NAME         1
#define IDB_WINDOWS                     1
#define IDS_DISPLAY_NAME                1
#define IDI_COMPUTER                    2
#define IDS_DESCRIPTION                 2
#define IDS_DEBUG                       4
#define IDS_XDOTX_MB                    5
#define IDS_PAGESIZE                    6
#define IDS_CONNECTING                  7
#define IDS_USERENVVARS                 8
#define IDS_BAD_CONNECT                 8
#define IDS_TITLE                       9
#define IDC_TEXT_1                      10
#define IDC_TEXT_2                      11
#define IDC_TEXT_3                      12
#define IDC_TEXT_4                      13
#define PERF_ICON                       14
#define ENVVAR_ICON                     15
#define CRASHDUMP_ICON                  16
#define IDC_ADV_PERF_ICON               17
#define IDC_ADV_PERF_TEXT               18
#define IDC_ADV_PERF_BTN                19
#define IDC_ADV_ENV_ICON                20
#define IDC_ADV_ENV_TEXT                21
#define IDC_ADV_ENV_BTN                 30
#define IDC_ADV_RECOVERY_ICON           40
#define IDC_ADV_RECOVERY_TEXT           41
#define IDC_ADV_RECOVERY_BTN            50
#define IDC_GEN_WINDOWS_IMAGE           51
#define IDC_GEN_VERSION_0               52
#define IDC_GEN_VERSION_1               53
#define IDC_GEN_VERSION_2               54
#define IDC_GEN_SERVICE_PACK            55
#define IDC_GEN_REGISTERED_0            56
#define IDC_GEN_REGISTERED_1            57
#define IDC_GEN_REGISTERED_2            58
#define IDC_GEN_REGISTERED_3            59
#define IDC_GEN_OEM_NUDGE               60
#define IDC_GEN_MACHINE                 61
#define IDC_GEN_OEM_IMAGE               62
#define IDC_GEN_MACHINE_0               63
#define IDC_GEN_MACHINE_1               64
#define IDC_GEN_MACHINE_2               65
#define IDC_GEN_MACHINE_3               66
#define IDC_GEN_MACHINE_4               67
#define IDC_GEN_MACHINE_5               68
#define IDC_GEN_OEM_SUPPORT             69
#define IDC_GEN_MACHINE_6               70
#define IDC_GEN_MACHINE_7               71
#define IDC_GEN_MACHINE_8               72
#define IDC_SUPPORT_TEXT                73
#define IDC_NETIDC_PASSWORD_GB          74
#define IDC_NETIDC_DOMAIN_BTN           75
#define IDC_MEMBER_OF                   76
#define IDC_CHANGE                      77
#define IDD_NETID                       80
#define IDC_NETID_DESC_LABEL            80
#define IDC_COMMENT                     80
#define IDD_NETID_CHANGE                81
#define IDC_NETID_SELECT_ICON           82
#define IDC_NETID_DESCRIPTION           83
#define IDC_NETID_COMPUTERNAME          84
#define IDC_DOMAIN                      85
#define IDC_NETIDC_STATIC_DESC          86
#define IDC_NETID_COMMENT               86
#define IDC_NETIDC_STATIC_COMPUTER      87
#define IDC_COMPUTER                    88
#define IDC_NETIDC_DOMAIN_GB            89
#define IDC_NETIDC_WRKG_BTN             90
#define IDC_NETIDC_WRKG_EDIT            91
#define IDC_NETIDC_DOMAIN_EDIT          92
#define IDC_NETIDC_PASSWORD_CHK         93
#define IDC_NETIDC_PASSWORD_DESC        94
#define IDC_NETIDC_STATIC_USERNAME      95
#define IDC_NETIDC_USERNAME_EDIT        96
#define IDC_NETIDC_STATIC_PASSWORD      97
#define IDC_NETIDC_PASSWORD_EDIT        98
#define IDC_SAVING_MESSAGE              99
#define IDD_USERPROFILE                 100
#define IDD_GENERAL                     101
#define IDD_PHONESUP                    102
#define IDD_PERFORMANCE                 103
#define IDD_STARTUP                     104
#define IDD_ENVVARS                     105
#define DLG_VIRTUALMEM                  106
#define IDD_ADVANCED                    107
#define IDD_ENVVAREDIT                  108
#define IDD_SHUTDOWN                    109
#define IDS_PROJNAME                    110
#define IDB_CMSNAPIN_16                 111
#define IDB_CMSNAPIN_32                 112
#define IDS_CMSNAPIN_DESC               114
#define IDS_CMSNAPIN_PROVIDER           115
#define IDS_CMSNAPIN_VERSION            116
#define IDR_CMSNAPIN                    117
#define IDS_XDOTX_MHZ                   117
#define IDC_ACCOUNT_WIZARD_BUTTON       119
#define IDC_PERF_VM_ALLOCD_LABEL        197
#define IDC_PERF_VM_GROUP               198
#define IDC_PERF_SERVER                 199
#define INITS                           200
#define IDC_PERF_CONTROL                200
#define IDC_PERF_SYSCACHE               200
#define IDC_PERF_CHANGE                 201
#define IDC_PERF_VM_ALLOCD              202
#define IDC_PARA                        202
#define IDC_PERF_GROUP                  203
#define IDC_ANIMATE                     203
#define IDC_PERF_FIXED                  204
#define IDC_PERF_CACHE_GROUP            204
#define IDC_PERF_VARIABLE               205
#define IDC_EXAMPLE                     205
#define IDC_PERF_SHORT                  206
#define IDC_PERF_LONG                   207
#define IDC_PERF_TEXT                   208
#define IDC_PERF_WORKSTATION            209
#define SYSTEM                          210
#define IDC_PERF_VM_ALLOCD_TEXT         210
#define IDC_PERF_APPS                   211
#define IDC_PERF_CACHE_TEXT             212
#define IDC_PERF_TEXT2                  213
#define IDC_PERF_VM_ALLOCD2             214
#define IDC_PERF_CACHE_TEXT2            215
#define IDS_CHANGINGUSER                262
#define IDS_MAXKILLERS                  263
#define IDC_STARTUP_SYS_OS              300
#define IDC_STARTUP_SYS_SECONDS         301
#define IDC_STARTUP_SYS_SECSCROLL       302
#define IDC_STARTUP_SYS_ENABLECOUNTDOWN 303
#define IDC_STARTUP_SYSTEM_GRP          304
#define IDS_ERR_PAGECREATE              305
#define IDC_STARTUP_SYSTEM_GRP2         305
#define IDS_ERR_HEADING                 306
#define IDC_STARTUP_CDMP_OPTIONS        306
#define IDC_ENVVAR_SYS_LB_SYSVARS       400
#define IDC_ENVVAR_SYS_SYSVARS          401
#define IDC_ENVVAR_SYS_LB_USERVARS      402
#define IDC_ENVVAR_SYS_VAR              403
#define IDC_ENVVAR_SYS_VALUE            404
#define IDC_ENVVAR_SYS_SETUV            405
#define IDC_ENVVAR_SYS_DELUV            406
#define IDC_ENVVAR_SYS_NEWSV            407
#define IDC_ENVVAR_SYS_EDITSV           408
#define IDC_ENVVAR_SYS_DELSV            409
#define IDC_ENVVAR_SYS_USERENV          410
#define IDC_ENVVAR_SYS_USERGROUP        411
#define IDC_ENVVAR_SYS_NEWUV            412
#define IDC_ENVVAR_SYS_EDITUV           413
#define IDC_ENVVAR_SYS_NDELUV           414
#define IDC_ENVVAR_EDIT_NAME_LABEL      415
#define IDC_ENVVAR_EDIT_NAME            416
#define IDC_ENVVAR_EDIT_VALUE_LABEL     417
#define IDC_ENVVAR_EDIT_VALUE           418
#define IDS_NEW_SYSVAR_CAPTION          420
#define IDS_EDIT_SYSVAR_CAPTION         421
#define IDS_NEW_USERVAR_CAPTION         422
#define IDS_EDIT_USERVAR_CAPTION        423
#define IDS_ERR_EXECMETHOD              424
#define IDS_ERR_EXECMETHOD_CAPTION      425
#define IDS_ERR_ENVVAR_SAVE             426
#define IDS_ERR_ENVVAR_DELETE           427
#define IDC_STARTUP_CDMP_GRP            601
#define IDC_STARTUP_CDMP_TXT1           602
#define IDC_STARTUP_CDMP_LOG            603
#define IDC_STARTUP_CDMP_SEND           604
#define IDC_STARTUP_CDMP_WRITE          605
#define IDC_STARTUP_CDMP_FILENAME       606
#define IDC_STARTUP_CDMP_OVERWRITE      607
#define IDC_STARTUP_CDMP_AUTOREBOOT     608
#define IDC_STARTUP_CDMP_KERNELONLY     609
#define IDC_STARTUP_SYS_SECONDS_LABEL   610
#define IDD_CHANGES                     700
#define IDC_NEW_NAME                    701
#define IDC_FULL_NAME                   702
#define IDC_WORKGROUP_BUTTON            703
#define IDC_FIND                        704
#define IDC_WORKGROUP                   705
#define IDD_MORE                        706
#define IDC_DNS                         707
#define IDC_NETBIOS                     709
#define IDD_CREDENTIALS                 710
#define IDC_NAME                        711
#define IDC_PASSWORD                    712
#define IDC_MESSAGE                     713
#define IDC_FULL_LABEL                  714
#define IDC_MORE                        715
#define IDC_GROUP                       716
#define IDC_DOMAIN_BUTTON               717
#define IDS_UNKNOWN                     718
#define IDS_DEFAULT_WORKGROUP           719
#define IDS_ERROR_READING_MEMBERSHIP    720
#define IDS_APP_TITLE                   721
#define IDS_MEMBER_OF_WORKGROUP         722
#define IDS_MEMBER_OF_DOMAIN            723
#define IDS_NON_RFC_NAME                724
#define IDS_BAD_DNS_SYNTAX              725
#define IDS_DNS_NAME_TOO_LONG           726
#define IDS_COMPUTER_NAME_TOO_LONG      727
#define IDS_BAD_COMPUTER_NAME_SYNTAX    728
#define IDS_VALIDATE_NAME_FAILED        729
#define IDS_JOIN_DOMAIN_FAILED          730
#define IDS_SHORT_NAME_CHANGE_FAILED    731
#define IDS_RENAME_FAILED_JOINED_WITH_OLD_NAME 732
#define IDS_SET_DOMAIN_DNS_NAME_FAILED  733
#define IDS_UNJOIN_FAILED               734
#define IDS_JOIN_WORKGROUP_FAILED       735
#define IDS_RENAME_FAILED               736
#define IDS_COMPUTER_ACCOUNT_ORPHANED   737
#define IDS_NAME_CHANGED                738
#define IDS_WORKGROUP_WELCOME           739
#define IDS_DOMAIN_WELCOME              740
#define IDS_MUST_REBOOT                 741
#define IDS_NAME_AND_MEMBERSHIP_MESSAGE 742
#define IDS_NAME_MESSAGE                743
#define IDS_RENAME_CREDENTIALS          744
#define IDS_NAME_TRUNCATED              745
#define IDS_NON_RFC_COMPUTER_NAME_SYNTAX 746
#define IDS_CANT_WRITE_COMMENT          747
#define IDS_LOST_CONNECTION             748
#define IDS_NO_VM                       749
#define IDS_NO_DUMP                     750
#define IDS_SMALL_DUMP                  751
#define IDS_KERNEL_DUMP                 752
#define IDS_COMPLETE_DUMP               753
#define IDC_GEN_OS_NAME                 1001
#define IDC_USERLIST                    1002
#define IDC_REBOOT                      1005
#define IDC_EDIT_BOOT_INI               1006
#define IDC_EDIT_BOOT_INI_LABEL         1018
#define IDC_LOGOFF                      1017
#define IDC_SHUTDOWN                    1019
#define IDC_POWERDOWN                   1021
#define IDC_IFHUNG                      1022
#define IDC_ALWAYS                      1023
#define IDC_NEVER                       1024
#define IDC_ENABLEDELAY                 1027
#define IDD_VM_DRIVE_LABEL              1144
#define IDD_VM_SPACE_LABEL              1146
#define IDD_VM_MIN_LABEL                1148
#define IDD_VM_RECOMMEND_LABEL          1150
#define IDD_VM_ALLOCD_LABEL             1152
#define IDD_VM_DRIVE_HDR                1158
#define IDD_VM_PF_SIZE_LABEL            1159
#define IDD_VM_VOLUMES                  1160
#define IDD_VM_SF_DRIVE                 1161
#define IDD_VM_SF_SPACE                 1162
#define IDD_VM_SF_SIZE                  1163
#define IDD_VM_SF_SIZEMAX               1164
#define IDD_VM_SF_SET                   1165
#define IDD_VM_MIN                      1166
#define IDD_VM_RECOMMEND                1167
#define IDD_VM_ALLOCD                   1168
#define IDD_VM_ST_INITSIZE              1169
#define IDD_VM_ST_MAXSIZE               1170
#define IDD_VMEM_ICON                   1171
#define IDD_VMEM_MESSAGE                1172
#define IDD_VM_CUSTOMSIZE_RADIO         1173
#define IDD_VM_RAMBASED_RADIO           1174
#define IDD_VM_NOPAGING_RADIO           1175
#define IDD_HELP                        1176
#define IDR_AVIWAIT                     1177
#define IDS_BYTES                       10000
#define IDS_ORDERKB                     10001
#define IDS_ORDERMB                     10002
#define IDS_ORDERGB                     10003
#define IDS_ORDERTB                     10004
#define IDS_ORDERPB                     10005
#define IDS_ORDEREB                     10006
#define IDS_MB                          10007
#define IDS_UNAVAILABLE                 10008
#define IDS_SYS_CHANGE_CAPTION          10009
#define IDS_MUST_RESTART                10010
#define IDS_WINVER_VERSION              10011
#define IDS_WINVER_YEAR                 10012
#define IDS_WINVER_PERSONAL             10013
#define IDS_WINVER_PROFESSIONAL         10014
#define IDS_WINVER_SERVER               10015
#define IDS_WINVER_ADVANCEDSERVER       10016
#define IDS_WINVER_DATACENTER           10017
#define IDS_WINVER_EMBEDDED             10018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\rebootpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "RebootPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <windowsx.h>
#include "..\common\util.h"
#include "common.h"

//----------------------------------------------------------------------------
INT_PTR CALLBACK StaticRebootDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	RebootPage *me = (RebootPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
RebootPage::RebootPage(WbemServiceThread *serviceThread)
					: WBEMPageHelper(serviceThread)
{
	IWbemClassObject *pInst = NULL;
	pInst = FirstInstanceOf("Win32_OperatingSystem");
	if(pInst)
	{
		m_OS = pInst;
	}
}

//--------------------------------------------------------------
INT_PTR RebootPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN),
						hDlg, StaticRebootDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
RebootPage::~RebootPage()
{
}

//--------------------------------------------------------------
INT_PTR CALLBACK RebootPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	m_hDlg = hwndDlg;

    switch (message)
    {
    case WM_INITDIALOG:
        Init(hwndDlg);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
		{
        case IDOK:
            if(HIWORD(wParam) == BN_CLICKED) 
			{
				if(Doit(hwndDlg))
				{
			        EndDialog(hwndDlg, IDOK);
				}
            }
            break;

        case IDCANCEL:
	        EndDialog(hwndDlg, IDCANCEL);
			break;
        }
        break;

    case WM_HELP:      // F1
        break;

    case WM_CONTEXTMENU:      // right mouse click
//        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
//				(DWORD)(LPSTR)aStartupHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
//--------------------------------------------------------------
void RebootPage::Init(HWND hDlg)
{
	// set initial radio buttons.
	Button_SetCheck(GetDlgItem(hDlg, IDC_LOGOFF), BST_CHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_NEVER), BST_CHECKED);
	bstr_t version;

	if(m_OS == NULL)
	{
		return;
	}

	try
	{
		// if NT && greater >= 5.0....
		version = m_OS.GetString(_T("Version"));
	}
	catch(_com_error e)
	{
		return;
	}
	WCHAR major; int nMaj;
	if (!version)
		nMaj = 0;
	else
	{
		wcsncpy(&major, (wchar_t *)version, 1);
		nMaj = _wtoi(&major);
	}
	if(nMaj >= 5)
	{
		EnableWindow(GetDlgItem(hDlg, IDC_IFHUNG), TRUE);
	}
}
//-------------------------------------------------------------
// NOTE: maps the flag bit to the radio button IDs.
typedef struct 
{
	UINT bit;
	UINT ID;
} FLAGMAP;

FLAGMAP g_flagmap[] = {
	{EWX_LOGOFF,  IDC_LOGOFF},
	{EWX_POWEROFF,  IDC_POWERDOWN},
	{EWX_REBOOT,  IDC_REBOOT},
	{EWX_SHUTDOWN,  IDC_SHUTDOWN},

	{EWX_FORCE, IDC_ALWAYS},
	{/*EWX_FORCEIFHUNG*/ 0x10, IDC_IFHUNG}}; // needs NT5 hdr.


bool RebootPage::Doit(HWND hDlg)
{
	long flags = 0L;
	bstr_t path;
	HRESULT hr = 0;

	// find exactly ONE from the first 4...
	for(int i = 0; i <= 3; i++)
	{
		if(Button_GetCheck(GetDlgItem(hDlg, g_flagmap[i].ID)) & BST_CHECKED)
		{
			flags |= g_flagmap[i].bit;
			break; // found it; bail early.
		}
	}

	// and find ONE from the last 2.
	// NOTE: I dont check IDC_NEVER cuz that means 'no bit set'. Its just there
	// so the user can uncheck the last two.
	for(i = 4; i <= 5; i++)
	{
		if(Button_GetCheck(GetDlgItem(hDlg, g_flagmap[i].ID)) & BST_CHECKED)
		{
			flags |= g_flagmap[i].bit;
			break;  // found it; bail early.
		}
	}

	// call the helper in the base class.
	long retval = 0;

	hr = Reboot(flags, &retval);

	if(FAILED(hr) || (retval != 0))
	{
		TCHAR format[100] = {0};		
		TCHAR caption[100] = {0};

		::LoadString(HINST_THISDLL,
						IDS_ERR_EXECMETHOD_CAPTION, 
						caption, 100);

		::LoadString(HINST_THISDLL,
						IDS_ERR_EXECMETHOD, 
						format, 100);

        CHString errorDescription;
        CHString errorMessage;

		if(hr)
		{
    	    ErrorLookup(hr, errorDescription);
            errorMessage.Format(format, errorDescription);
		}
		else
		{
    	    ErrorLookup(retval, errorDescription);
            errorMessage.Format(format, errorDescription);

			// calling code gets confused if the 'retval' error isn't
			// reported back SOMEHOW. 
			hr = E_FAIL;
		}

		::MessageBox(hDlg, errorMessage, caption,
						MB_OK| MB_ICONEXCLAMATION);
	}

	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\settings.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state helper
// 
// 3-12-98 sburns



#ifndef SETTINGS_HPP_INCLUDED
#define SETTINGS_HPP_INCLUDED






#endif   // SETTINGS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\settings.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state helper
// 
// 3-12-98 sburns


#include "precomp.h"

#include "headers.hxx"
#include "settings.h"
#include "resource.h"
#include "common.h"



// Caller needs to delete info with ::DsRoleFreeMemory.

static DWORD myDsRoleGetPrimaryDomainInformation(
							DSROLE_PRIMARY_DOMAIN_INFO_BASIC*&  info)
{
   TRACE_FUNCTION(myDsRoleGetPrimaryDomainInformation);

   BYTE* buffer = 0;
   info = 0;

   TRACE(TEXT("Calling DsRoleGetPrimaryDomainInformation"));
   DWORD err =
      ::DsRoleGetPrimaryDomainInformation(
							 0, // this server
							 DsRolePrimaryDomainInfoBasic,
							 &buffer);

   TRACE(String::format(TEXT("Error 0x%1!X! (!0 => error)"), err));
   if (err == NO_ERROR)
   {
      info = (DSROLE_PRIMARY_DOMAIN_INFO_BASIC*) buffer;
      assert(info);

      TRACE(String::format(TEXT("MachineRole   : %1!d!"), info->MachineRole));
      TRACE(String::format(TEXT("Flags         : 0x%1!X!"), info->Flags));
      TRACE(String::format(TEXT("DomainNameFlat: %1"), info->DomainNameFlat));
      TRACE(String::format(TEXT("DomainNameDns : %1"), info->DomainNameDns));
      TRACE(String::format(TEXT("DomainTreeName: %1"), info->DomainTreeName));
   }

   return err;
}



void Settings::Refresh()
{
   String unknown = String::load(IDS_UNKNOWN);
   ComputerPrimaryDomainDNSName = unknown;
   DomainDNSName = unknown;
   FullComputerName = unknown;
   NetBIOSComputerName = unknown;
   NetBIOSDomainName = unknown;
   ShortComputerName = unknown;

   SyncDNSNames = true; // @@ read from registry
   JoinedToWorkgroup = true;

   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   DWORD err = myDsRoleGetPrimaryDomainInformation(info);
   if (err == NO_ERROR)
   {
      // this is the workgroup name iff JoinedToWorkgroup == true
      NetBIOSDomainName = info->DomainNameFlat;
      DomainDNSName = info->DomainNameDns;

      switch (info->MachineRole)
      {
         case DsRole_RoleBackupDomainController:
         case DsRole_RolePrimaryDomainController:
         {
            machine_is_dc = true;
            JoinedToWorkgroup = false;
            break;
         }
         case DSRole_RoleStandaloneWorkstation:
         case DsRole_RoleStandaloneServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = true;
            if (NetBIOSDomainName.empty())
            {
               NetBIOSDomainName =
                  String::load(IDS_DEFAULT_WORKGROUP);
            }
            break;
         }
         case DsRole_RoleMemberWorkstation:
         case DsRole_RoleMemberServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = false;
            break;
         }
         default:
         {
            assert(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   else
   {
      AppError(0, HRESULT_FROM_WIN32(err),
				 String::load(IDS_ERROR_READING_MEMBERSHIP));
   }

   // @@ call GetComputerNameEx here...

   NetBIOSComputerName = Win::GetComputerNameFromRegistry();
   ShortComputerName = NetBIOSComputerName;

   if (!JoinedToWorkgroup)
   {
      ComputerPrimaryDomainDNSName = DomainDNSName;
      FullComputerName =
            ShortComputerName
         +  TEXT(".")
         +  ComputerPrimaryDomainDNSName;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\startup.h ===
//*************************************************************
//
//  Startup.h   -    Header file for Startup.c
//
//  Microsoft Confidential
//  Copyright (c) 1996-1999 Microsoft Corporation
//  All rights reserved
//
//*************************************************************


HPROPSHEETPAGE CreateStartupPage (HINSTANCE hInst);
BOOL APIENTRY StartupDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void StartListInit( HWND hDlg, WPARAM wParam, LPARAM lParam );
int StartListExit(HWND hDlg, WPARAM wParam, LPARAM lParam );
void StartListDestroy(HWND hDlg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\startuppage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "StartupPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include <windowsx.h>
#include <commctrl.h>
#include <shellapi.h>
#include "RebootPage.h"
#include "helpid.h"
#include "NetUtility.h"

//  Reboot switch for crashdump dlg
#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10
#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)


#define FORMIN       0
#define FORMAX     999
// Length of WCHAR buffer needed to hold "Display startup list for..." value
#define FOR_MAX_LENGTH 20

// Default "Display startup list for..." value
#define FORDEF      30

#define NO_DUMP_OPTION          0
#define COMPLETE_DUMP_OPTION    1
#define KERNEL_DUMP_OPTION      2
#define SMALL_DUMP_OPTION       3

//
// Help ID's
//

DWORD aStartupHelpIds[] = {
    IDC_STARTUP_SYS_OS,                    (IDH_STARTUP + 0),
    IDC_STARTUP_SYS_ENABLECOUNTDOWN,       (IDH_STARTUP + 1),
    IDC_STARTUP_SYS_SECONDS,               (IDH_STARTUP + 2),
    IDC_STARTUP_SYS_SECONDS_LABEL,         (IDH_STARTUP + 2),
    IDC_STARTUP_CDMP_TXT1,                 (IDH_STARTUP + 3),
    IDC_STARTUP_CDMP_LOG,                  (IDH_STARTUP + 4),
    IDC_STARTUP_CDMP_SEND,                 (IDH_STARTUP + 5),
    IDC_STARTUP_CDMP_FILENAME,             (IDH_STARTUP + 7),
    IDC_STARTUP_CDMP_OVERWRITE,            (IDH_STARTUP + 13),
    IDC_STARTUP_CDMP_AUTOREBOOT,           (IDH_STARTUP + 9),
    IDC_STARTUP_SYSTEM_GRP,                (IDH_STARTUP + 10),
    IDC_STARTUP_SYS_SECSCROLL,             (IDH_STARTUP + 11),
    IDC_STARTUP_CDMP_GRP,                  (IDH_STARTUP + 12),
    IDC_STARTUP_SYSTEM_GRP2,               (IDH_STARTUP + 14),
    IDC_STARTUP_CDMP_OPTIONS,              (IDH_STARTUP + 8),
    IDC_EDIT_BOOT_INI_LABEL,               (IDH_STARTUP + 15),
    IDC_EDIT_BOOT_INI,                     (IDH_STARTUP + 16),
    IDC_REBOOT,            IDH_WBEM_ADVANCED_STARTRECOVER_REMOTE_REBOOT,
    0, 0
};


//----------------------------------------------------------------------------
INT_PTR CALLBACK StaticStartupDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	StartupPage *me = (StartupPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
StartupPage::StartupPage(WbemServiceThread *serviceThread)
					: WBEMPageHelper(serviceThread)
{
	IWbemClassObject *pInst = NULL;

	m_WbemServices.SetPriv();

	if((pInst = FirstInstanceOf("Win32_ComputerSystem")) != NULL)
	{
		m_computer = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_OperatingSystem")) != NULL)
	{
		m_OS = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_OSRecoveryConfiguration")) != NULL)
	{
		m_recovery = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
	{
		m_memory = pInst;
	}


	m_WbemServices.ClearPriv();

	m_writable = TRUE;
	m_lBound = 1;
    m_bDownlevelTarget = TRUE;  // Assume downlevel until proven otherwise.
}

//--------------------------------------------------------------
INT_PTR StartupPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_STARTUP),
						hDlg, StaticStartupDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
StartupPage::~StartupPage()
{
}

//--------------------------------------------------------------
BOOL StartupPage::CheckVal( HWND hDlg, WORD wID, WORD wMin, WORD wMax, WORD wMsgID )
{
    WORD nVal;
    BOOL bOK;
    HWND hVal;
    WCHAR szTemp[FOR_MAX_LENGTH];

    if( wMin > wMax )
    {
        nVal = wMin;
        wMin = wMax;
        wMax = nVal;
    }

    nVal = (WORD) GetDlgItemInt( hDlg, wID, &bOK, FALSE );

    //
    // This is a hack to make the null string act equivalent to zero
    //
    if (!bOK) {
       bOK = !GetDlgItemTextW( hDlg, wID, szTemp, FOR_MAX_LENGTH );
    }

    if( !bOK || ( nVal < wMin ) || ( nVal > wMax ) )
    {
		TCHAR megBuf[30] = {0};

        MsgBoxParam( hDlg, wMsgID, IDS_DISPLAY_NAME,
                      MB_OK | MB_ICONERROR);

        SendMessage( hDlg, WM_NEXTDLGCTL,
                     (WPARAM) ( hVal = GetDlgItem( hDlg, wID ) ), 1L );

//        SendMessage(hVal, EM_SETSEL, NULL, MAKELONG(0, 32767));

        SendMessage( hVal, EM_SETSEL, 0, 32767 );

        return( FALSE );
    }

    return( TRUE );
}

//--------------------------------------------------------------
INT_PTR CALLBACK StartupPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{ 
	m_hDlg = hwndDlg;

    switch (message)
    {
    case WM_INITDIALOG:
        Init(hwndDlg);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam)) 
		{
        case EN_CHANGE:
        case BN_CLICKED:
        case CBN_SELCHANGE:
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            break;
		}

        switch(LOWORD(wParam)) 
		{
        case IDC_STARTUP_SYS_ENABLECOUNTDOWN:
            if (HIWORD(wParam) == BN_CLICKED) 
			{
                BOOL bChecking = (WORD) !IsDlgButtonChecked(m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN);
                CheckDlgButton(m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, bChecking);
                EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), bChecking);
                EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECSCROLL), bChecking);

                if(bChecking)
                {
                    Edit_SetText(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), _T("30"));
                }
                else //unchecking it.
                {
                    Edit_SetText(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), _T("0"));
                }
				SendMessage((HWND) lParam, EM_SETSEL, 0, -1);

            }
            break;

        case IDC_STARTUP_SYS_SECONDS:
            if(HIWORD(wParam) == EN_UPDATE) 
			{
                if(!CheckVal(m_hDlg, IDC_STARTUP_SYS_SECONDS, FORMIN, FORMAX, SYSTEM+4)) 
				{
                    SetDlgItemInt(m_hDlg, IDC_STARTUP_SYS_SECONDS, FORDEF, FALSE); 
                    SendMessage((HWND) lParam, EM_SETSEL, 0, -1);
                    
                } // endif (!CheckVal()

            } // endif 
			break;

        case IDC_REBOOT:
            if(HIWORD(wParam) == BN_CLICKED) 
			{
				RebootPage dlg(m_serviceThread);
				if(dlg.DoModal(hwndDlg) == IDOK)
				{
					EnableWindow(GetDlgItem(hwndDlg, IDC_REBOOT), FALSE);
					m_serviceThread->DisconnectServer();
					EndDialog(m_hDlg, CLOSE_SNAPIN);
				}
            }
            break;

        case IDOK:
            if(HIWORD(wParam) == BN_CLICKED) 
			{
				if(Save())
				{
			        EndDialog(m_hDlg, IDOK);
				}
            }
            break;

        case IDCANCEL:
	        EndDialog(m_hDlg, IDCANCEL);
			break;

        case IDC_STARTUP_CDMP_OPTIONS: 
            OnCDMPOptionUpdate();
			break;

        case IDC_EDIT_BOOT_INI:
            if (m_serviceThread && m_serviceThread->LocalConnection())
            {
                //
                // Local-only option. The button has been disabled but
                // perform this anyway.
                //
                OnBootEdit();
            }
            break;

        }
        break;

    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aStartupHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
				(ULONG_PTR)(LPSTR) aStartupHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------
void StartupPage::OnCDMPOptionUpdate(void)
{
    HWND ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);
    DWORD dwDumpOption = ComboBox_GetCurSel(ComboHwnd);

    EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME),
                             dwDumpOption != NO_DUMP_OPTION);
    EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OVERWRITE),
                             dwDumpOption != NO_DUMP_OPTION);

    bstr_t debugPath;
    if (dwDumpOption == SMALL_DUMP_OPTION)
    {
        debugPath = m_recovery.GetString("MiniDumpDirectory");
    }
    else
    {
        debugPath = m_recovery.GetString("DebugFilePath");
    }

    Edit_SetText(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME), debugPath);
}

//--------------------------------------------------------------
#define BOOT_INI    _T("boot.ini")

void StartupPage::OnBootEdit(void)
{
    HKEY hReg;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                   &hReg) == ERROR_SUCCESS)
    {
        TCHAR szBootDir[4];
        DWORD dwType = REG_SZ;
        DWORD cbBootDir = sizeof(szBootDir);

        if (RegQueryValueEx(hReg,
                            _T("BootDir"),
                            NULL,
                            &dwType,
                            (LPBYTE)szBootDir,
                            &cbBootDir) == ERROR_SUCCESS)
        {
            if (dwType == REG_SZ)
            {
                TCHAR szBootIni[ARRAYSIZE(szBootDir) + ARRAYSIZE(BOOT_INI)];

                lstrcpy(szBootIni, szBootDir);
                lstrcat(szBootIni, BOOT_INI);
        
                ShellExecute(m_hDlg,
                             NULL,              // Default verb.
                             szBootIni,         // boot.ini path.
                             NULL,              // No parameters.
                             NULL,              // Default working dir.
                             SW_SHOWNORMAL);
            }
        }

        RegCloseKey(hReg);
    }
}

//--------------------------------------------------------------
#define ONE_MEG             1048576
long StartupPage::GetRAMSizeMB(void)
{
	IWbemClassObject *pInst = NULL;
	CWbemClassObject memory;
	long RAMsize = 0;

	if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
	{
		memory = pInst;
		long dwTotalPhys = memory.GetLong("TotalPhysicalMemory");
	    RAMsize = (dwTotalPhys / ONE_MEG) + 1;
	}
	return RAMsize;
}

//--------------------------------------------------------------
bool StartupPage::IsWorkstationProduct()
{
	bool retval = true;

	bstr_t name = m_OS.GetString("Name");

	if(name.length() > 0)
	{
		TCHAR sName[200] = {0};
		wcscpy(sName, name);
		if(wcsstr(sName, L"Server") != NULL)
		{
			retval = false;
		}
	}
	return retval;
}

//--------------------------------------------------------------
TCHAR szCrashKey[]  = TEXT("System\\CurrentControlSet\\Control\\CrashControl");

void StartupPage::Init(HWND hDlg)
{
    HWND ComboHwnd;
	variant_t array;
    DWORD dwDebugInfoType;

	// load the startup combobox.
    //
    // Must enable SE_SYSTEM_ENVIRONMENT_NAME privilege on ia64.
    //
#if defined(_IA64_)
    m_WbemServices.SetPriv();
#endif // IA64

	m_computer.Get("SystemStartupOptions", (variant_t &)array);

#if defined(_IA64_)
    m_WbemServices.ClearPriv();
#endif // IA64

 	if(array.vt & VT_ARRAY)
	{
		SAFEARRAY *startupArray = V_ARRAY(&array);
		long uBound = 1;
		BSTR temp;
        ComboHwnd = GetDlgItem(hDlg, IDC_STARTUP_SYS_OS);

		SafeArrayGetLBound(startupArray, 1, &m_lBound);
		SafeArrayGetUBound(startupArray, 1, &uBound);

		for (long i = m_lBound; i <= uBound; i++)
		{
			SafeArrayGetElement(startupArray, &i, &temp);
			ComboBox_AddString(ComboHwnd, temp);
		}

		// the first one is the selection we want (watch out for 'lBound' values)
		long idx = m_computer.GetLong("SystemStartupSetting");
		ComboBox_SetCurSel(ComboHwnd, idx - m_lBound);

		// 3 chars in the second's edit box.
		Edit_LimitText(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), 3);

		// limit spinner to 0 - 999.
		SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
							  UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));


		WCHAR buf[30] = {0};
		m_delay = 0;
		m_delay = (short)m_computer.GetLong("SystemStartupDelay");
		BOOL bChecked = (m_delay != 0);

		CheckDlgButton(m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, bChecked);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECONDS), bChecked);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECSCROLL), bChecked);
		Edit_SetText(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), _itow(m_delay, buf, 10));
	}
	
    if( !(array.vt & VT_ARRAY) || !IsCurrentUserAdministrator())
	{
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_OS), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);

	} // endif VT_ARRAY failure.

	// set all the recovery controls.
    // Special Case: Server Product does not want ability to disable logging
    // of crashdumps.
	WPARAM checkState;

	if(IsWorkstationProduct() == true)
	{
		checkState = (m_recovery.GetBool("WriteToSystemLog") ? BST_CHECKED : BST_UNCHECKED);
		Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG), checkState);
	}
	else
	{
		Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG), BST_CHECKED);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG),FALSE);
	}

    //
    // Load the dump options combo box.
    //
    dwDebugInfoType = GetDebugInfoType();

    TCHAR szBuf[MAX_PATH];  // The largest string loaded here is 24 chars.

    szBuf[0] = _T('\0');
    ComboHwnd = GetDlgItem(hDlg, IDC_STARTUP_CDMP_OPTIONS);
    LoadString(HINST_THISDLL,
               IDS_NO_DUMP,
               szBuf,
               sizeof(szBuf) / sizeof(TCHAR));
    ComboBox_AddString(ComboHwnd, szBuf);
    szBuf[0] = _T('\0');
    LoadString(HINST_THISDLL,
               IDS_COMPLETE_DUMP,
               szBuf,
               sizeof(szBuf) / sizeof(TCHAR));

    ComboBox_AddString(ComboHwnd, szBuf);
    szBuf[0] = _T('\0');
    LoadString(HINST_THISDLL,
               IDS_KERNEL_DUMP,
               szBuf,
               sizeof(szBuf) / sizeof(TCHAR));
    ComboBox_AddString(ComboHwnd, szBuf);

    if (!m_bDownlevelTarget)
    {
        szBuf[0] = _T('\0');
        LoadString(HINST_THISDLL,
                   IDS_SMALL_DUMP,
                   szBuf,
                   sizeof(szBuf) / sizeof(TCHAR));
        ComboBox_AddString(ComboHwnd, szBuf);
    }

    ComboBox_SetCurSel(ComboHwnd, dwDebugInfoType);

	checkState = (m_recovery.GetBool("SendAdminAlert") ? BST_CHECKED : BST_UNCHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_SEND), checkState);

    bstr_t debugPath;
    if (dwDebugInfoType == SMALL_DUMP_OPTION)
    {
        debugPath = m_recovery.GetString("MiniDumpDirectory");
    }
    else
    {
        debugPath = m_recovery.GetString("DebugFilePath");
    }
	Edit_SetText(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME), debugPath);

	checkState = (m_recovery.GetBool("OverwriteExistingDebugFile") ? BST_CHECKED : BST_UNCHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OVERWRITE), checkState);

	checkState = (m_recovery.GetBool("AutoReboot") ? BST_CHECKED : BST_UNCHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_AUTOREBOOT), checkState);

    //
    // Special case disable the overwrite and logfile controls if no debug
    // info option specified.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME),
                 dwDebugInfoType != NO_DUMP_OPTION);
    EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OVERWRITE),
                 dwDebugInfoType != NO_DUMP_OPTION);

    //
	// Test to determine if the user is an admin.
    //
	RemoteRegWriteable(szCrashKey, m_writable);

	if (!m_writable)
	{
        // Non-admin - disable controls.
        //
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG     ), FALSE);
	    EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_SEND    ), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OPTIONS), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_AUTOREBOOT), FALSE);
	}


	BOOL hasPriv = true, hasMethExecute = false;
	if(m_serviceThread && m_serviceThread->LocalConnection())
	{
		hasPriv = HasPriv(SE_SHUTDOWN_NAME);
	}

	hasMethExecute = HasPerm(WBEM_METHOD_EXECUTE);

    //
    // Enable the edit button for local-only.
    // Disable boot options label and edit button on i64.
    //
#if defined(_IA64_)
    EnableWindow(GetDlgItem (m_hDlg, IDC_EDIT_BOOT_INI), FALSE);
    EnableWindow(GetDlgItem (m_hDlg, IDC_EDIT_BOOT_INI_LABEL), FALSE);
#else
    EnableWindow(GetDlgItem (m_hDlg, IDC_EDIT_BOOT_INI_LABEL),
                m_writable ?
                    (m_serviceThread && m_serviceThread->LocalConnection()) :
                    FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BOOT_INI),
                m_writable ?
                    (m_serviceThread && m_serviceThread->LocalConnection()) :
                    FALSE);
#endif // IA64

	EnableWindow(GetDlgItem(hDlg, IDC_REBOOT),
                 m_writable ? (hasPriv && hasMethExecute) : FALSE);
}

//----------------------------------------------------------------------------
DWORD StartupPage::GetDebugInfoType(void)
{
    // NB: Whistler on, the win32 provider supports new DebugInfoType
    //     (none,complete,kernel,small) and MiniDumpDirectory properties.
    //     Logic is needed to compensate for downlevel machines.
    //
    //     *Important note*  The small dump option cannot be supported
    //     on Win2K since the provider doesn't.
    //
    DWORD dwDebugInfoType = 0;

    if (FAILED(m_recovery.Get("DebugInfoType", (long&)dwDebugInfoType)))
    {
        // Downlevel or error case.
        //
        if (!m_bDownlevelTarget)
        {
            // Bail. We've previously established this isn't downlevel
            // but now fail to read the property.
            //
            return NO_DUMP_OPTION;
        }

        m_bDownlevelTarget   = TRUE;
        bool bWriteDebugInfo = FALSE;

        if (FAILED(m_recovery.Get("WriteDebugInfo", bWriteDebugInfo)))
        {
            // Now we're clueless; default to (none).
            //
            bWriteDebugInfo = FALSE;
            dwDebugInfoType = NO_DUMP_OPTION;
        }

        if (bWriteDebugInfo)
        {
            bool bKernelDumpOnly;

            if (FAILED(m_recovery.Get("KernelDumpOnly", bKernelDumpOnly)))
            {
                // If we fail to get KernelDumpOnly we must assume complete,
                // since they've elected to write debugging info.
                //
                bKernelDumpOnly = FALSE;
            }

            if (bKernelDumpOnly)
            {
                dwDebugInfoType = KERNEL_DUMP_OPTION;
            }
            else
            {
                dwDebugInfoType = COMPLETE_DUMP_OPTION;
            }
        }
    }
    else
    {
        m_bDownlevelTarget = FALSE;
    }

    return dwDebugInfoType;
}

//----------------------------------------------------------------------------
HRESULT StartupPage::PutDebugInfoType(DWORD dwDebugInfoType)
{
    HRESULT hr;

    if (m_bDownlevelTarget)
    {
        switch (dwDebugInfoType)    // Intentionally verbose - compiler will
                                    // optimize.
        {
            case NO_DUMP_OPTION:
                hr = m_recovery.Put("WriteDebugInfo", (bool)FALSE);
                break;

            case COMPLETE_DUMP_OPTION:
                hr = m_recovery.Put("WriteDebugInfo", (bool)TRUE);
                if (SUCCEEDED(hr))
                {
                    hr = m_recovery.Put("KernelDumpOnly", (bool)FALSE);
                }
                break;

            case KERNEL_DUMP_OPTION:
                hr = m_recovery.Put("WriteDebugInfo", (bool)TRUE);
                if (SUCCEEDED(hr))
                {
                    hr = m_recovery.Put("KernelDumpOnly", (bool)TRUE);
                }
                break;

            case SMALL_DUMP_OPTION:
                ATLASSERT(!"Downlevel small dump option!");
                hr = E_FAIL;
                break;

            default:
                ATLASSERT(!"Downlevel unknown dump option!");
                hr = E_FAIL;
        }
    }
    else
    {
        hr = m_recovery.Put("DebugInfoType", (long)dwDebugInfoType);
    }

    return hr;
}

//----------------------------------------------------------------------------
#define MIN_SWAPSIZE        2       // Min swap file size.

int StartupPage::CoreDumpHandleOk(HWND hDlg)
{
    DWORD requiredFileSize = 0;
    int iRet = RET_NO_CHANGE;

     // Validate core dump filename
    if(!CoreDumpValidFile(hDlg)) 
	{
        SetFocus(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME));
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        iRet = RET_ERROR;
        return(iRet);
    }

    // If we are to write the dump file, it must be >= sizeof
    // phyical memory.
	// writing debug info?
    HWND ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);

    if (ComboBox_GetCurSel(ComboHwnd) != NO_DUMP_OPTION)
	{
		// go figure my pagefile requirements.
        requiredFileSize = ((DWORD)m_memory.GetLong("TotalPhysicalMemory") / 1024) + 1;
    } 
	else if(IsDlgButtonChecked(hDlg, IDC_STARTUP_CDMP_LOG) ||
            IsDlgButtonChecked(hDlg, IDC_STARTUP_CDMP_SEND)) 
	{
		// I'll need this much to write a reminder to myself to send an
		// alert or write to event log once I come back up.
        requiredFileSize = MIN_SWAPSIZE;
    }

	// size of swapfile on the boot partition.
	TCHAR bootDrv[4] = {0};
	DWORD bootPartitionPageFileSize = GetPageFileSize(bootDrv);

	// is it too small?
    if(bootPartitionPageFileSize < requiredFileSize) 
	{
	    DWORD Ret;
		TCHAR szTemp[30] = {0};

        // Warn that the dump file may be truncated.
        Ret = MsgBoxParam(hDlg, SYSTEM + 29, IDS_TITLE,
                           MB_ICONEXCLAMATION | MB_YESNO,
                           bootDrv, _itow(requiredFileSize, szTemp, 10));

        if(Ret == IDNO) 
		{
            return RET_ERROR;
        }
    }

    return(iRet);
}

//----------------------------------------------------------------------------
BOOL StartupPage::CoreDumpValidFile(HWND hDlg) 
{
    TCHAR szInputPath[MAX_PATH] = {0};
    TCHAR * pszPath = NULL;
    HWND ComboHwnd;

    ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);

    if (ComboBox_GetCurSel(ComboHwnd) != NO_DUMP_OPTION)
	{
        /*
         * get the filename
         */
        if(GetDlgItemText(hDlg, IDC_STARTUP_CDMP_FILENAME, szInputPath,
						     ARRAYSIZE(szInputPath)) == 0) 
		{
			//ERR: enter a filename for the dumpfile.
            MsgBoxParam(hDlg, SYSTEM+30, IDS_DISPLAY_NAME, MB_ICONSTOP | MB_OK);
            return FALSE;
        }

        //
        // For local paths only, confirm/validate the path. Remote validation
        // can be done later - too complicated, if not possible in the
        // Whistler timeframe.
        //

        if (m_serviceThread != NULL && m_serviceThread->LocalConnection())
        {
            /*
             * Expand any environment vars, and then check to make sure it
             * is a fully quallified path
             */
            // if it has a '%' in it, then try to expand it
            if (_tcschr(szInputPath, _T('%')) != NULL)
            {
                TCHAR szExpandedPath[MAX_PATH] = {0};
                DWORD cExpanded;
                cExpanded = ExpandEnvironmentStrings(szInputPath,
                                                    szExpandedPath,
                                     sizeof(szExpandedPath) / sizeof(TCHAR));

                if (cExpanded == 0 || _tcschr(szExpandedPath, _T('%')) != NULL)
                {
                    //
                    // Environment variable name(s) undefined or an error
                    // occurred during replacement.
                    //
                    MsgBoxParam(hDlg, SYSTEM+40, IDS_DISPLAY_NAME,
                                MB_ICONSTOP | MB_OK );
                    return FALSE;
                }
                else if (cExpanded > (sizeof(szExpandedPath) / sizeof(TCHAR)))
                {
                    TCHAR buf[10];
                    MsgBoxParam(hDlg, SYSTEM+33, IDS_DISPLAY_NAME,
                                MB_ICONSTOP | MB_OK, _ltow((DWORD)MAX_PATH,
                                                            buf,
                                                            10));
                    return FALSE;
                }
                else
                {
                    pszPath = szExpandedPath;
                }
            }
            else
            {
                pszPath = szInputPath;
            }

            // check to see that it already was cannonicalized

            TCHAR drv[_MAX_DRIVE] = {0};
            TCHAR path[_MAX_PATH] = {0};
            TCHAR fname[_MAX_FNAME] = {0};

            // build the instance path.
            _wsplitpath(pszPath, drv, path, fname, NULL);

            if((_tcslen(drv) == 0) || (_tcslen(path) == 0) ||
                (_tcslen(fname) == 0) )
            {
                // ERR: must be a full path.
                MsgBoxParam(hDlg, SYSTEM+34, IDS_DISPLAY_NAME,
                            MB_ICONSTOP | MB_OK );
                return FALSE;
            }

            /*
             * check the drive (don't allow remote)
             */
            if(!LocalDrive(pszPath)) 
            {
                // ERR: Local drives only
                MsgBoxParam(hDlg, SYSTEM+31, IDS_DISPLAY_NAME,
                            MB_ICONSTOP | MB_OK );
                return FALSE;
            }

            /*
             * if path is non-existent, tell user and let him decide what to
             * do
             */
            if(!DirExists(pszPath))
            { 
                if(MsgBoxParam(hDlg, SYSTEM+32, IDS_DISPLAY_NAME,
                                MB_ICONQUESTION | MB_YESNO ) == IDNO)
                {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

//----------------------------------------------------------------------------
DWORD StartupPage::GetPageFileSize(LPTSTR bootDrv)
{
	IWbemClassObject *pInst = NULL;
	CWbemClassObject OS;
	bstr_t path;
	DWORD cMegBootPF = 0;
	TCHAR szBootPath[_MAX_PATH] = {0};
	szBootPath[0] = 0;

	if(m_OS)
	{
		// WATCH: what's the value if GetWindowsDirectory fails?
		path = m_OS.GetString("WindowsDirectory");
		if(path.length())
		{
			// build the instance path.
			_tcscpy(szBootPath, _T("Win32_PageFileSetting=\""));
			_tcsncat(szBootPath, path, 3);
			_tcscat(szBootPath, _T("\\pagefile.sys\""));

			// while we're here....
			_tcsncpy(bootDrv, path, 3);

			m_page = m_WbemServices.GetObject(szBootPath);

			if(m_page)
			{
				// NOTE: We'll need this later to change the swapfile size.
/*				long dwTotalPhys = m_page.GetLong("Size");
				cMegBootPF = (dwTotalPhys / ONE_MEG) + 1;*/
				long dwMinPageFileSize = m_page.GetLong("InitialSize");
				cMegBootPF = dwMinPageFileSize;
			}
		}
	}
	return cMegBootPF;
}

//-------------------------------------------------------------
BOOL StartupPage::ExpandRemoteEnvPath(LPTSTR szPath, LPTSTR expPath, UINT size)
{
	//TODO: really expand the vars.
	_tcscpy(szPath, expPath);
	return TRUE;
}

//-------------------------------------------------------------
BOOL StartupPage::LocalDrive(LPCTSTR szPath)
{
	CWbemClassObject drive;
	TCHAR ltr[_MAX_PATH] = {0};
	long type = 0;
	BOOL retval = FALSE;
	__int64 free = 0;

	// build the instance path.
	_tcscpy(ltr, _T("win32_LogicalDisk=\""));
	_tcsncat(ltr, szPath, 2);
	_tcscat(ltr, _T("\""));

	// save the drive letter for msgs.
	_tcsncpy(m_DriveLtr, szPath, 2);

	drive = m_WbemServices.GetObject(ltr);
	if(drive)
	{
		type = drive.GetLong("DriveType");
		retval = ((type == DRIVE_REMOVABLE) ||
				  (type == DRIVE_FIXED));

		// WARNING: this is only here cuz the LocalDrive check happens
		// to come before the freespace check and I didn't want to do
		// another GetObject() over a potentially slow network.
		free = drive.GetI64("FreeSpace");
		m_freeSpace = (DWORD)(free / ONE_MEG);
	}
	return retval;
}

//-------------------------------------------------------------
BOOL StartupPage::DirExists(LPCTSTR szPath)
{
	BOOL exists = TRUE;
	CWbemClassObject drive;

	TCHAR objPath[_MAX_PATH] = {0}, drv[_MAX_DRIVE] = {0}, path[_MAX_PATH] = {0};

	// build the instance path.
	_wsplitpath(szPath, drv, path, NULL, NULL);
	path[_tcslen(path) - 1] = _T('\0');

	_tcscpy(objPath, _T("Win32_Directory=\""));
	_tcscat(objPath, drv);
	
	// double the whacks cuz wmi has bad syntax.
	TCHAR cooked[_MAX_PATH] = {0};
	TCHAR input[_MAX_PATH] = {0};

	int len = _tcslen(path);

	_tcscpy(input, path);

	for(int x = 0; x < len; x++)
	{
		_tcsncat(cooked, &input[x], 1);

		// if its a whack...
		if(input[x] == _T('\\'))
		{
			// have another pleeb.
			_tcscat(cooked, _T("\\"));			
		}
	} //endfor

	_tcscat(objPath, cooked);

	_tcscat(objPath, _T("\""));

	drive = m_WbemServices.GetObject(objPath);
	exists = (drive.IsNull() ? FALSE : TRUE);
	return exists;
}

//-------------------------------------------------------------
BOOL StartupPage::IsAlerterSvcStarted(HWND hDlg) 
{
	CWbemClassObject service;
	bool started = false;

	service = m_WbemServices.GetObject(_T("win32_Service=\"Alerter\""));
	if(service)
	{
		started = service.GetBool("started");

		if(!started)
		{
			// get the method signature. dummy wont actually be used.
			CWbemClassObject paramCls, inSig, dummy, outSig;

			// need to class def to get the method signature.
			paramCls = m_WbemServices.GetObject("win32_Service");

			if(paramCls)
			{
				HRESULT hr = paramCls.GetMethod(L"ChangeStartMode", inSig, outSig);

				// if got a good signature....
				if((bool)inSig)
				{
					bstr_t path = service.GetString(_T("__PATH"));

					inSig.Put(L"StartMode", (const _bstr_t&) L"Automatic");

					// make sure the service starts on bootup.
					hr = m_WbemServices.ExecMethod(path, L"ChangeStartMode",
													inSig, outSig);

					// did it work?
					if(SUCCEEDED(hr) && (bool)outSig)
					{
						// NOTE: this guy return STATUS codes.
						DWORD autoStart = outSig.GetLong(L"ReturnValue");

						if(autoStart == 0)
						{
							// now actually start the service.
							outSig = (IWbemClassObject *)0;

							// now call the method.
							hr = m_WbemServices.ExecMethod(path, L"StartService",
															dummy, outSig);

							// did the caller want the ReturnValue.
							if(SUCCEEDED(hr) && (bool)outSig)
							{
								// NOTE: this guy return STATUS codes.
								DWORD rv = outSig.GetLong(L"ReturnValue");
								started = ((rv == 0) ? true : false);
							}

						} //endif autoStart

					} //endif SUCCEEDED() execmMethod

				} //endif (bool)inSig

			} //endif paramCls

		} //endif !started

		if(!started) 
		{
			MsgBoxParam(hDlg, SYSTEM+35, IDS_DISPLAY_NAME, MB_ICONEXCLAMATION );
	    }
	}

    return started;
}

//-------------------------------------------------------------
bool StartupPage::Save(void)
{
    HRESULT hr;
    HWND    ComboHwnd;

	// if its writeable-- do the work.
	if(m_writable)
	{
		bool computerDirty = false, recoveryDirty = false;
		variant_t array;
		SAFEARRAY *startupArray = NULL;
		VARTYPE varType = VT_ARRAY;
        ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_SYS_OS);

		// see if the selection changed (watch out for 'lBound' values)
		long oldIdx = m_computer.GetLong("SystemStartupSetting");
		long newIdx = ComboBox_GetCurSel(ComboHwnd) + m_lBound;
		if(oldIdx != newIdx)
		{
			hr = m_computer.Put("SystemStartupSetting", variant_t((BYTE)newIdx));
			computerDirty = true;
		}

		// see if the delay changed.
		WCHAR oldBuf[30], newBuf[30];
		short delay = (short)m_computer.GetLong("SystemStartupDelay");
		_ltow(delay, oldBuf, 10);
		Edit_GetText(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), newBuf, 30);
		if(wcscmp(oldBuf, newBuf) != 0)
		{
            short newVal = (short)_wtol(newBuf);
			hr = m_computer.Put("SystemStartupDelay", variant_t(newVal));
			computerDirty = true;
		}

		// evaluate all the recovery controls.
		WPARAM oldCheckState = (m_recovery.GetBool("WriteToSystemLog") ? BST_CHECKED : BST_UNCHECKED);
		WPARAM newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_LOG));
		if(oldCheckState != newCheckState)
		{
			m_recovery.Put("WriteToSystemLog", (newCheckState == BST_CHECKED? true : false));
			recoveryDirty = true;
		}

		oldCheckState = (m_recovery.GetBool("SendAdminAlert") ? BST_CHECKED : BST_UNCHECKED);
		newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_SEND));
		// did the state change?
		if(oldCheckState != newCheckState)
		{
			m_recovery.Put("SendAdminAlert", (newCheckState == BST_CHECKED? true : false));
			recoveryDirty = true;

			// turning ON
			if(newCheckState == TRUE)
			{
				// NOTE: had to move this fragment up to avoid being trapped under the wcsicmp() condition.
				// If the Alert button is checked, make sure the alerter service is started.
				IsAlerterSvcStarted(m_hDlg);
			}
		}

        ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);
        DWORD dwOldDebugInfoType = GetDebugInfoType();
        DWORD dwNewDebugInfoType = ComboBox_GetCurSel(ComboHwnd);

        if (dwOldDebugInfoType != dwNewDebugInfoType)
        {
            // I detest this code. You add a member with a return code yet
            // nothing here checks them. At least keep the recover dirty
            // flag from being set and don't set the modify bit on the
            // filename edit control if the put fails.
            //
            hr = PutDebugInfoType(dwNewDebugInfoType);
            if (SUCCEEDED(hr))
            {
                recoveryDirty = true;
                Edit_SetModify(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME),
                                          TRUE);
            }
		}

        //
        // Only bother with these if other than "none" debug options is
        // specified.
        //
		if (dwNewDebugInfoType != NO_DUMP_OPTION)
		{
			oldCheckState = (m_recovery.GetBool("OverwriteExistingDebugFile") ? BST_CHECKED : BST_UNCHECKED);
			newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OVERWRITE));
			if(oldCheckState != newCheckState)
			{
				m_recovery.Put("OverwriteExistingDebugFile", (newCheckState == BST_CHECKED? true : false));
				recoveryDirty = true;
			}

			bstr_t oldDebugPath = m_recovery.GetString(
                                (dwOldDebugInfoType == SMALL_DUMP_OPTION) ?
                                    "MiniDumpDirectory" : "DebugFilePath");
			TCHAR newDebugPath[MAX_PATH];
			Edit_GetText(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME),
                        newDebugPath, sizeof(newDebugPath) / sizeof(TCHAR));

			if(_tcsicmp(oldDebugPath,newDebugPath) != 0)
			{
				if(RET_ERROR != CoreDumpHandleOk(m_hDlg))
				{
					m_recovery.Put(
                        (dwNewDebugInfoType == SMALL_DUMP_OPTION) ?
                            "MiniDumpDirectory" : "DebugFilePath",
                        (bstr_t)newDebugPath);
					recoveryDirty = true;
				}
				else 
				{
					long wl = GetWindowLongPtr(m_hDlg, DWLP_MSGRESULT);
					if(wl == PSNRET_INVALID_NOCHANGEPAGE)
					{
						return false;
					}
				}
			}
		} //endif 'WriteDebugInfo'

		oldCheckState = (m_recovery.GetBool("AutoReboot") ? BST_CHECKED : BST_UNCHECKED);
		newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_AUTOREBOOT));
		if(oldCheckState != newCheckState)
		{
			m_recovery.Put("AutoReboot", (newCheckState == BST_CHECKED? true : false));
			recoveryDirty = true;
		} 

		m_WbemServices.SetPriv();

		// who needs to be written?
		if(computerDirty)
		{
			hr = m_WbemServices.PutInstance(m_computer);
		}

		if(recoveryDirty)
		{
			//
			// Apparently recovery options don't require reboot in Whistler...
			//
			/*
			g_fRebootRequired = TRUE;

			MsgBoxParam(m_hDlg, SYSTEM + 39, IDS_TITLE,
							MB_OK | MB_ICONINFORMATION);
			*/

			hr = m_WbemServices.PutInstance(m_recovery);
		}
	
		m_WbemServices.ClearPriv();

	} //endif m_writable

	return true;  // close the dialog.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\startuppage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __STARTUPPAGE__
#define __STARTUPPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"

//-----------------------------------------------------------------------------
class StartupPage : public WBEMPageHelper
{
private:

	CWbemClassObject m_computer;
	CWbemClassObject m_OS;
	CWbemClassObject m_recovery;
	CWbemClassObject m_page;
	CWbemClassObject m_memory;

	BOOL m_writable;
    BOOL m_bDownlevelTarget;

	// helps deal with safe arrays that dont start at zero.
	long m_lBound;
    short m_delay;

	DWORD m_cMegBootPF;
	DWORD m_freeSpace;
	TCHAR m_DriveLtr[3];

	int CoreDumpHandleOk(HWND hDlg);
	long GetRAMSizeMB(void);

	BOOL CoreDumpValidFile(HWND hDlg);
    void OnCDMPOptionUpdate(void);
    void OnBootEdit(void);
	DWORD GetPageFileSize(LPTSTR bootDrv);

	BOOL ExpandRemoteEnvPath(LPTSTR szPath, LPTSTR expPath, UINT size);
	BOOL LocalDrive(LPCTSTR szPath);
	BOOL DirExists(LPCTSTR szPath);
	BOOL IsAlerterSvcStarted(HWND hDlg);

	void    Init(HWND hDlg);
    DWORD   GetDebugInfoType(void);
    HRESULT PutDebugInfoType(DWORD dwDebugInfoType);
	bool    Save(void);
	BOOL    CheckVal(HWND hDlg, WORD wID, WORD wMin, WORD wMax, WORD wMsgID);
	bool    IsWorkstationProduct(void);

public:

    StartupPage(WbemServiceThread *serviceThread);
	~StartupPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticStartupDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __STARTUPPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\state.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Tab state
//
// 3-11-98 sburns


#include "precomp.h"

#include "state.h"
#include "resource.h"
#include "common.h"
//#include "cred.h"

class Settings
{
public:
   void Refresh();

   CHString   ComputerDomainDNSName;
   CHString   DomainName;
   CHString   FullComputerName;
   CHString   ShortComputerName;
   CHString   NetBIOSComputerName;

   bool     SyncDNSNames;
   bool     JoinedToWorkgroup;
   bool     NeedsReboot;
};


//=========================================================
static bool       machine_is_dc = false;
static bool       networking_installed = false;
static Settings   original;
static Settings   current;
static const CHString SYNC_KEY(
   TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"));
static const CHString SYNC_VALUE(TEXT("SyncDomainWithMembership"));



//=========================================================
bool readSyncFlag()
{
   bool retval = true;
/*
   HKEY hKey = 0;
   do
   {
      LONG result =
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            SYNC_KEY,
            KEY_READ,
            hKey);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      // default is to sync.
      DWORD data = 1;
      DWORD data_size = sizeof(data);
      result = Win::RegQueryValueEx(
         hKey,
         SYNC_VALUE,
         0,
         (BYTE*) &data,
         &data_size);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      retval = data ? true : false;
   }
   while (0);

   if (hKey)
   {
      Win::RegCloseKey(hKey);
   }
*/
   return retval;
}


//=========================================================
void writeSyncFlag(bool flag)
{
	/*
   HKEY hKey = 0;
   do
   {
      LONG result =
         Win::RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            SYNC_KEY,
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            0,
            hKey,
            0);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      DWORD data = flag ? 1 : 0;
      DWORD data_size = sizeof(data);
      Win::RegSetValueEx(
         hKey,
         SYNC_VALUE,
         REG_DWORD,
         (BYTE*) &data,
         data_size);
   }
   while (0);

   if (hKey)
   {
      Win::RegCloseKey(hKey);
   }
   */
}



//=========================================================
bool isNetworkingInstalled()
{
/*   SC_HANDLE handle = ::OpenSCManager(0, 0, GENERIC_READ);
   if (!handle)
   {
      TRACE(TEXT("can't open SCM"));
      return false;
   }

   SC_HANDLE wks =
      ::OpenService(
         handle,
         TEXT("LanmanWorkstation"),
         SERVICE_QUERY_STATUS);
   if (!wks)
   {
      TRACE(TEXT("can't open workstation service: not installed"));
      ::CloseServiceHandle(handle);
      return false;
   }

   bool result = false;
   SERVICE_STATUS status;
   memset(&status, 0, sizeof(status));
   if (::QueryServiceStatus(wks, &status))
   {
      if (status.dwCurrentState == SERVICE_RUNNING)
      {
         result = true;
      }
   }

   ::CloseServiceHandle(wks);
   ::CloseServiceHandle(handle);

   TRACE(
      CHString::format(
         TEXT("workstation service %1 running"),
         result ? TEXT("is") : TEXT("is NOT")));

   return result;
   */
	return true;
}



//---------------------------------------------------------
State::State()
   : must_reboot(false)
{
   original.Refresh();
   current = original;
}



//---------------------------------------------------------
State::~State()
{
}


//=========================================================
void Settings::Refresh()
{
/*
   CHString unknown = CHString::load(IDS_UNKNOWN);
   ComputerDomainDNSName = unknown;
   DomainName = unknown;
   FullComputerName = unknown;
   ShortComputerName = unknown;

   SyncDNSNames = readSyncFlag();
   JoinedToWorkgroup = true;

   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   DWORD err = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (err == NO_ERROR)
   {
      if (info->DomainNameDns)
      {
         DomainName = info->DomainNameDns;
      }
      else if (info->DomainNameFlat)
      {
         DomainName = info->DomainNameFlat;
      }

      // this is the workgroup name iff JoinedToWorkgroup == true
      switch (info->MachineRole)
      {
         case DsRole_RoleBackupDomainController:
         case DsRole_RolePrimaryDomainController:
         {
            machine_is_dc = true;
            JoinedToWorkgroup = false;
            break;
         }
         case DSRole_RoleStandaloneWorkstation:
         case DsRole_RoleStandaloneServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = true;
            if (DomainName.empty())
            {
               DomainName = CHString::load(IDS_DEFAULT_WORKGROUP);
            }
            break;
         }
         case DsRole_RoleMemberWorkstation:
         case DsRole_RoleMemberServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = false;
            break;
         }
         default:
         {
            assert(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   else
   {
      AppError(0, HRESULT_FROM_WIN32(err),
				CHString::load(IDS_ERROR_READING_MEMBERSHIP));
   }

   networking_installed = isNetworkingInstalled();
   bool tcp_installed = networking_installed && IsTCPIPInstalled();
   CHString active_full_name;

   HKEY hkey = 0;
   LONG result =
      Win::RegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"),
         KEY_READ,
         hkey);
   if (result == ERROR_SUCCESS)
   {
      NetBIOSComputerName = Win::RegQueryValueSz(hkey, TEXT("ComputerName"));
   }
   Win::RegCloseKey(hkey);

   if (tcp_installed)
   {
      HKEY hkey = 0;
      LONG result =
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
            KEY_READ,
            hkey);
      if (result == ERROR_SUCCESS)
      {
         CHString active_short_name =
            Win::RegQueryValueSz(hkey, TEXT("Hostname"));
         CHString short_name =
            Win::RegQueryValueSz(hkey, TEXT("NV Hostname"));
         ShortComputerName =
            short_name.empty() ? active_short_name : short_name;

         CHString active_domain_name =
            Win::RegQueryValueSz(hkey, TEXT("Domain"));
         CHString domain_name =
            Win::RegQueryValueSz(hkey, TEXT("NV Domain"));
         ComputerDomainDNSName =
            domain_name.empty() ? active_domain_name : domain_name;

         FullComputerName =
            ShortComputerName + TEXT(".") + ComputerDomainDNSName;
         active_full_name =
            active_short_name + TEXT(".") + active_domain_name;

      }
      Win::RegCloseKey(hkey);
   }
   else
   {
      LONG result =
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"),
            KEY_READ,
            hkey);
      if (result == ERROR_SUCCESS)
      {
         active_full_name = Win::RegQueryValueSz(hkey, TEXT("ComputerName"));
      }

      Win::RegCloseKey(hkey);
      
      ShortComputerName = NetBIOSComputerName;
      FullComputerName = ShortComputerName;
   }

   NeedsReboot = active_full_name != FullComputerName;
   */
}

//---------------------------------------------------------
void State::Init(CWbemClassObject &computer, 
					CWbemClassObject &os, 
					CWbemClassObject dns)
{
	m_computer = computer;
	m_OS = os;
	m_DNS = dns;
}



//---------------------------------------------------------
void State::Refresh()
{
}



//---------------------------------------------------------
bool State::NeedsReboot() const
{
   return original.NeedsReboot;
}



//---------------------------------------------------------
bool State::IsMachineDC() const
{
   return machine_is_dc;
}



//---------------------------------------------------------
bool State::IsNetworkingInstalled() const
{
   return networking_installed;
}



//---------------------------------------------------------
CHString State::GetFullComputerName() const
{
   return current.FullComputerName;
}



//---------------------------------------------------------
CHString State::GetDomainName() const
{
   return current.DomainName;
}



//---------------------------------------------------------
void State::SetDomainName(const CHString& name)
{
   current.DomainName = name;
}



//---------------------------------------------------------
bool State::IsMemberOfWorkgroup() const
{
   return current.JoinedToWorkgroup;
}



//---------------------------------------------------------
void State::SetIsMemberOfWorkgroup(bool yesNo)
{
   current.JoinedToWorkgroup = yesNo;
}



//---------------------------------------------------------
CHString State::GetShortComputerName() const
{
   return current.ShortComputerName;
}



//---------------------------------------------------------
void State::SetShortComputerName(const CHString& name)
{
   current.ShortComputerName = name;
//   current.NetBIOSComputerName = DNS::HostnameToNetBIOSName(name);
   setFullComputerName();
}



//---------------------------------------------------------
bool State::WasShortComputerNameChanged() const
{
   return true;
      //original.ShortComputerName.icompare(current.ShortComputerName) != 0;
}



//---------------------------------------------------------
CHString State::GetComputerDomainDNSName() const
{
   return current.ComputerDomainDNSName;
}



//---------------------------------------------------------
void State::SetComputerDomainDNSName(const CHString& newName)
{
   current.ComputerDomainDNSName = newName;
   setFullComputerName();
}



//---------------------------------------------------------
void State::setFullComputerName()
{
   current.FullComputerName =
            current.ShortComputerName
         +  TEXT(".")
         +  current.ComputerDomainDNSName;
}



//---------------------------------------------------------
bool State::WasMembershipChanged() const
{
   return true;
//         original.DomainName.icompare(current.DomainName) != 0
//      || original.JoinedToWorkgroup != current.JoinedToWorkgroup;
}



//---------------------------------------------------------
bool State::ChangesNeedSaving() const
{
/*   if (
         original.ComputerDomainDNSName.icompare(
            current.ComputerDomainDNSName) != 0
      || WasMembershipChanged()
      || WasShortComputerNameChanged()
      || SyncDNSNamesWasChanged())
   {
      return true;
   }
*/
   return false;
}



//---------------------------------------------------------
bool State::GetSyncDNSNames() const
{
   return current.SyncDNSNames;
}



//---------------------------------------------------------
void State::SetSyncDNSNames(bool yesNo)
{
   current.SyncDNSNames = yesNo;
}



//---------------------------------------------------------
bool State::SyncDNSNamesWasChanged() const
{
   return original.SyncDNSNames != current.SyncDNSNames;
}



//---------------------------------------------------------
CHString massageUserName(const CHString& domainName, const CHString& userName)
{
/*   if (!domainName.IsEmpty() && !userName.IsEmpty())
   {
      static const CHString DOMAIN_SEP_CHAR = TEXT("\\");
      CHString name = userName;
      int pos = userName.find(DOMAIN_SEP_CHAR);

      if (pos == CHString::npos)
      {
         return domainName + DOMAIN_SEP_CHAR + name;
      }
   }
*/
   return userName;
}


//=======================================================
NET_API_STATUS myNetJoinDomain(
						   const CHString&  domain,
						   const CHString&  username,
						   const CHString&  password,
						   ULONG          flags)
{
/*   assert(!domain.empty());

   NET_API_STATUS status =
      ::NetJoinDomain(
         0, // this machine
         domain.c_str(),
         0, // default OU
         username.empty() ? 0 : username.c_str(),
         password.c_str(),
         flags);

   TRACE(CHString::format(TEXT("Error 0x%1!X! (!0 => error)"), status));

   return status;
   */
	return 0;
}



//=======================================================
HRESULT join(HWND dialog, const CHString& name, bool isWorkgroupJoin)
{
/*   assert(!name.empty());
   assert(Win::IsWindow(dialog));

   Win::CursorSetting cursor(IDC_WAIT);

   State& state = State::GetInstance();
   CHString username = massageUserName(name, state.GetUsername());
   CHString password = state.GetPassword();

   ULONG flags = 0;
   if (!isWorkgroupJoin)
   {
      flags =
            NETSETUP_JOIN_DOMAIN
         |  NETSETUP_ACCT_CREATE
         |  NETSETUP_DOMAIN_JOIN_IF_JOINED;
   }

   NET_API_STATUS status =
      myNetJoinDomain(name, username, password, flags);

   if (
         status == ERROR_ACCESS_DENIED
      && (flags & NETSETUP_ACCT_CREATE) )
   {
      // retry without account create flag for the case where the account
      // already exists
      TRACE(TEXT("Retry without account create flag"));
      status =
         myNetJoinDomain(
            name,
            username,
            password,
            flags & ~NETSETUP_ACCT_CREATE);
   }

   if (status == NERR_Success)
   {
      AppMessage(
         dialog,
         CHString::format(
            isWorkgroupJoin ? IDS_WORKGROUP_WELCOME : IDS_DOMAIN_WELCOME,
            name.c_str()));
   }

   return HRESULT_FROM_WIN32(status);
   */
	return 0;
}



//=======================================================
HRESULT rename(HWND dialog, const CHString& newName)
{
/*   assert(!newName.empty());
   assert(Win::IsWindow(dialog));

   Win::CursorSetting cursor(IDC_WAIT);

   State& state = State::GetInstance();
   CHString username =
      massageUserName(state.GetDomainName(), state.GetUsername());
   CHString password = state.GetPassword();

   ULONG flags = NETSETUP_ACCT_CREATE;

   TRACE(TEXT("Calling NetRenameMachineInDomain"));
   TRACE(               TEXT("lpServer         : (null)"));
   TRACE(CHString::format(TEXT("lpNewMachineName : %1"), newName.c_str()));
   TRACE(CHString::format(TEXT("lpAccount        : %1"), username.c_str()));
   TRACE(CHString::format(TEXT("fRenameOptions   : 0x%1!X!"), flags));

   NET_API_STATUS status =
      ::NetRenameMachineInDomain(
         0, // this machine
         newName.c_str(),
         username.empty() ? 0 : username.c_str(),
         password.c_str(),
         flags);

   TRACE(CHString::format(TEXT("Error 0x%1!X! (!0 => error)"), status));

   // if (status == NERR_Success)
   // {
   //    AppMessage(dialog, IDS_NAME_CHANGED);
   //    state.SetMustRebootFlag(true);
   // }

   return HRESULT_FROM_WIN32(status);
   */
	return 0;
}



//=======================================================
static NET_API_STATUS myNetUnjoinDomain(ULONG flags)
{
   return 0;
}



//=======================================================
HRESULT unjoin(HWND dialog, const CHString& domain)
{
	return S_OK;
}



//=======================================================
HRESULT setDomainDNSName(HWND dialog, const CHString& newDomainDNSName)
{
   return S_OK;
}



//=======================================================
HRESULT setShortName(HWND dialog, const CHString& newShortName)
{
   return S_OK;
}



//=======================================================
bool getCredentials(HWND dialog, int promptResID = 0)
{
   return true;
}



//------------------------------------------------------
bool State::doSaveDomainChange(HWND dialog)
{
   return true;
}



//------------------------------------------------------
bool State::doSaveWorkgroupChange(HWND dialog)
{
   return true;
}



//------------------------------------------------------
bool State::doSaveNameChange(HWND dialog)
{
   return true;
}



//------------------------------------------------------
bool State::SaveChanges(HWND dialog)
{
   return true;
}



//------------------------------------------------------
CHString State::GetUsername() const
{
   return username;
}



//------------------------------------------------------
CHString State::GetPassword() const
{
   return password;
}



//------------------------------------------------------
void State::SetMustRebootFlag(bool yesNo)
{
   must_reboot = yesNo;
}



//------------------------------------------------------
bool State::MustReboot() const
{
   return must_reboot;
}

//------------------------------------------------------
CHString State::GetNetBIOSComputerName() const
{
   return current.NetBIOSComputerName;
}

//------------------------------------------------------
CHString State::GetOriginalShortComputerName() const
{
   return original.ShortComputerName;
}

//------------------------------------------------------
void State::SetUsername(const CHString& name)
{
   username = name;
}

//------------------------------------------------------
void State::SetPassword(const CHString& pass)
{
   password = pass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\sysdm.h ===
//*************************************************************
//
//  Header file for sysdm applet
//
//  Microsoft Confidential
//  Copyright (c) 1996-1999 Microsoft Corporation
//  All rights reserved
//
//*************************************************************
#pragma once
#include <commctrl.h>
#include "startup.h"
#include "envvar.h"
#include "resource.h"
#include "..\Common\util.h"


//
// Global variables
//

extern HINSTANCE hInstance;
extern TCHAR g_szNull[];


//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SIZEOF(x)    sizeof(x)

#define SetLBWidth( hwndLB, szStr, cxCurWidth )     SetLBWidthEx( hwndLB, szStr, cxCurWidth, 0)

#define IsPathSep(ch)       ((ch) == TEXT('\\') || (ch) == TEXT('/'))
#define IsWhiteSpace(ch)    ((ch) == TEXT(' ') || (ch) == TEXT('\t') || (ch) == TEXT('\n') || (ch) == TEXT('\r'))
#define IsDigit(ch)         ((ch) >= TEXT('0') && (ch) <= TEXT('9'))

#define DigitVal(ch)        ((ch) - TEXT('0'))
#define FmtFree(s)          LocalFree(s)            /* Macro to free FormatMessage allocated strings */

//
//  Help IDs
//

#define HELP_FILE           TEXT("sysdm.hlp")

#define IDH_HELPFIRST       5000
#define IDH_GENERAL         (IDH_HELPFIRST + 0000)
#define IDH_PERF            (IDH_HELPFIRST + 1000)
#define IDH_ENV             (IDH_HELPFIRST + 2000)
#define IDH_STARTUP         (IDH_HELPFIRST + 3000)
#define IDH_HWPROFILE       (IDH_HELPFIRST + 4000)
#define IDH_USERPROFILE     (IDH_HELPFIRST + 5000)


//
// sysdm.c
//
int  StringToInt( LPTSTR sz );         // TCHAR aware atoi()
void IntToString( INT i, LPTSTR sz);   // TCHAR aware itoa()
LPTSTR SkipWhiteSpace( LPTSTR sz );

BOOL IsUserAdmin(VOID);


//
// envar.c
//

DWORD SetLBWidthEx (HWND hwndLB, LPTSTR szBuffer, DWORD cxCurWidth, DWORD cxExtra);
LPTSTR CloneString( LPTSTR pszSrc );


//
// virtual.c
//

VOID SetDlgItemMB(HWND hDlg, INT idControl, DWORD dwMBValue);
int MsgBoxParam( HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ... );
void HourGlass( BOOL bOn );
void ErrMemDlg( HWND hParent );
VOID SetDefButton(HWND hwndDlg, int idButton);


//
// sid.c
//

LPTSTR GetSidString(void);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (void);
VOID DeleteUserSid(PSID Sid);




//
// Debugging macros
//
#if DBG
#   define  DBG_CODE    1

void DbgPrintf( LPTSTR szFmt, ... );
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText );
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes);
HLOCAL MemFreeWorker(LPSTR szFile, int iLine, HLOCAL hMem);
void MemExitCheckWorker(void);


#   define  MemAlloc( f, s )    MemAllocWorker( __FILE__, __LINE__, f, s )
#   define  MemFree( h )        MemFreeWorker( __FILE__, __LINE__, h )
#   define  MEM_EXIT_CHECK()    MemExitCheckWorker()
#   define  DBGSTOP( t )        DbgStopX( __FILE__, __LINE__, TEXT(t) )
#   define  DBGSTOPX( f, l, t ) DbgStopX( f, l, TEXT(t) )
#   define  DBGPRINTF(p)        DbgPrintf p
#   define  DBGOUT(t)           DbgPrintf( TEXT("SYSCPL.CPL: %s\n"), TEXT(t) )
#else
#   define  MemAlloc( f, s )    LocalAlloc( f, s )
#   define  MemFree( h )        LocalFree( h )
#   define  MEM_EXIT_CHECK()
#   define  DBGSTOP( t )
#   define  DBGSTOPX( f, l, t )
#   define  DBGPRINTF(p)
#   define  DBGOUT(t)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\state.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state
// 
// 3-11-98 sburns



#ifndef STATE_HPP_INCLUDED
#define STATE_HPP_INCLUDED

#include <chstring.h>
#include "..\common\sshWbemHelpers.h"

// Singleton state of the UI.

#define NET_API_STATUS DWORD
class State
{
public:
   // Init() actually builds the instance
   State();

   // Delete destroys the instance
   ~State();

   void Init(CWbemClassObject &computer, 
				CWbemClassObject &os, 
				CWbemClassObject dns);

   void Refresh();

   bool ChangesNeedSaving() const;

   bool IsMachineDC() const;
   bool IsNetworkingInstalled() const;
   bool IsMemberOfWorkgroup() const;
   void SetIsMemberOfWorkgroup(bool yesNo);

   CHString GetComputerDomainDNSName() const;
   void SetComputerDomainDNSName(const CHString& newName);
   bool ComputerDomainDNSNameWasChanged() const;

   CHString GetFullComputerName() const;
   CHString GetNetBIOSComputerName() const;
   CHString GetShortComputerName() const;

   void SetShortComputerName(const CHString& name);
   bool WasShortComputerNameChanged() const;
   CHString GetOriginalShortComputerName() const;

   CHString GetDomainName() const;
   void SetDomainName(const CHString& name);
   bool WasMembershipChanged() const;

   bool GetSyncDNSNames() const;
   void SetSyncDNSNames(bool yesNo);
   bool SyncDNSNamesWasChanged() const;

   bool SaveChanges(HWND dialog);

   CHString GetUsername() const;
   void SetUsername(const CHString& name);

   CHString GetPassword() const;
   void SetPassword(const CHString& password);

   // indicates that changes have been made in this session.

   bool MustReboot() const;
   void SetMustRebootFlag(bool yesNo);

   // indicates that changes have been made in this or prior sessions.

   bool NeedsReboot() const;

private:
	CWbemClassObject m_computer;
	CWbemClassObject m_OS;
	CWbemClassObject m_DNS;

   // not implemented:  no copying allowed
   State(const State&);
   const State& operator=(const State&);

   bool doSaveDomainChange(HWND dialog);
   bool doSaveWorkgroupChange(HWND dialog);
   bool doSaveNameChange(HWND dialog);

   void setFullComputerName();

   CHString   username;
   CHString   password;
   bool     must_reboot;
};

#endif   // STATE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\virtualmemdlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#pragma once

#include "..\common\WBEMPageHelper.h"

// BUGBUG : Defining an NT-specific manifest just in case this compiles
//          for Win9x.  I'll remove it when I discover the proper manifest
//          or if this is whistler and on only.
//
#define NTONLY

class VirtualMemDlg : public WBEMPageHelper
{
private:
	//  Swap file structure
	class PAGING_FILE
	{
	public:
		PAGING_FILE()
		{
			// for information and error checking.
			name = NULL;
			volume = NULL;
			desc = NULL;
			pszPageFile = NULL;
			objPath = NULL;
			freeSpace = 0;
			totalSize = 0;
			bootDrive = false;
            fRamBasedPagefile = false;

			// user-definable.
			nMinFileSize = 0;
			nMaxFileSize = 0;
			nMinFileSizePrev = 0;
			nMaxFileSizePrev = 0;
			nAllocatedFileSize = 0;
		}
		~PAGING_FILE()
		{
			if(name) delete[] name;
			if(volume) delete[] volume;
			if(desc) delete[] desc;
			if(pszPageFile) delete[] pszPageFile;
			if(objPath) delete[] objPath;
		}
		LPTSTR name;				// drive letter from Win32_LogicalDisk.
		LPTSTR volume;				// volumeName from Win32_LogicalDisk.
		LPTSTR desc;				// driveType string from Win32_LogicalDisk.
		LPTSTR filesystem;          // filesystem string from Win32_LogicalDisk.
		LPTSTR pszPageFile;         // Path to page file if it exists on that drv
		LPTSTR objPath;				// the wbem object path.
		ULONG freeSpace;			// freespace from Win32_LogicalDisk.
		ULONG totalSize;			// totalSize from Win32_LogicalDisk.
		bool bootDrive;
        bool fRamBasedPagefile;     // Inidicates computed page file min/max
                                    // sizes based on available RAM.

		int nMinFileSize;           // Minimum size of pagefile in MB.
		int nMaxFileSize;           // Max size of pagefile in MB.
		int nMinFileSizePrev;       // Previous minimum size of pagefile in MB.
		int nMaxFileSizePrev;       // Previous max size of pagefile in MB.
		int nAllocatedFileSize;		// The actual size allocated
	};

	DWORD m_cxLBExtent;
	int   m_cxExtra;

    // TRUE if user has write access
    //      UNINITIALIZED UNTIL Init()
    BOOL  m_VMWriteAccess;

	// Initialized in LoadVolumeList (called from Init())
	// with Win32_OperatingSystem.PAEEnabled property value
	BOOL m_PAEEnabled;

	IEnumWbemClassObject *m_pgEnumSettings;
	IEnumWbemClassObject *m_pgEnumUsage;
	CWbemClassObject m_memory;
	CWbemClassObject m_registry, m_recovery;

    bool EnsureEnumerator(const bstr_t bstrClass);
	int CheckForRSLChange(HWND hDlg);
	int ComputeTotalMax(void);
	void GetRecoveryFlags(bool &bWrite, bool &bLog, bool &bSend);

	
	void LoadVolumeList(void);
	BOOL Init(HWND hDlg);
	void SelChange(HWND hDlg);
	DWORD GetMaxPagefileSizeInMB(PAGING_FILE *iDrive);
	bool SetNewSize(HWND hDlg);
	int UpdateWBEM(void);
	int PromptForReboot(HWND hDlg);
	void GetCurrRSL( LPDWORD pcmRSL, LPDWORD pcmUsed, LPDWORD pcmPPLim );
	void BuildLBLine(LPTSTR pszBuf, const PAGING_FILE *pgVal);
	unsigned long RecomputeAllocated(void);

	void FindSwapfile(PAGING_FILE *pgVar);

public:
	VirtualMemDlg(WbemServiceThread *serviceThread);
	~VirtualMemDlg();

	bool ComputeAllocated(unsigned long *value);

	bool DlgProc(HWND hDlg,
				UINT message,
				WPARAM wParam,
				LPARAM lParam);

	int DoModal(HWND hDlg);
};

INT_PTR CALLBACK StaticVirtDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\cmprops\virtualmemdlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Application specific
#include "sysdm.h"
#include "VirtualMemDlg.h"
#include "..\common\util.h"
#include <windowsx.h>
#include "helpid.h"
#include "shlwapi.h"
#include "common.h"

#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10

#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)

//==========================================================================
//                            Local Definitions
//==========================================================================

#define MAX_SIZE_LEN        8       // Max chars in the Swap File Size edit.
#define MAX_DRIVES          26      // Max number of drives.
#define MIN_SWAPSIZE        2       // Min swap file size (see note below).
#define MIN_FREESPACE       5       // Must have 5 meg free after swap file
#define MIN_SUGGEST         22      // Always suggest at least 22 meg
#define ONE_MEG             1048576

//New consts for Win Server 2003
#define MAX_SWAPSIZE_X86        (4 * 1024)            // 4 Gb (number stored in megabytes)
#define MAX_SWAPSIZE_X86_PAE    (16 * 1024 * 1024)    // 16 Tb
#define MAX_SWAPSIZE_IA64       (32 * 1024 * 1024)    // 32 Tb
#define MAX_SWAPSIZE_AMD64      (16 * 1024 * 1024)    // 16 Tb

#define MIN_FREESPACE_STR  _T("5")      //        equal their manifests.

#define TABSTOP_VOL         22
#define TABSTOP_SIZE        122

TCHAR gszPageFileSettings[]  = _T("Win32_PageFileSetting");
TCHAR gszPageFileUsage[]     = _T("Win32_PageFileUsage");
TCHAR gszLogicalFile[]       = _T("CIM_LogicalFile");
TCHAR gszAllocatedBaseSize[] = _T("AllocatedBaseSize");
TCHAR gszFileSize[]          = _T("FileSize");
TCHAR gszInitialSize[]       = _T("InitialSize");
TCHAR gszMaximumSize[]       = _T("MaximumSize");
TCHAR gszName[]              = _T("Name");
TCHAR gszPFNameFormat[]      = _T("%s\\\\pagefile.sys");


// My privilege 'handle' structure
typedef struct 
{
    HANDLE hTok;
    TOKEN_PRIVILEGES tp;
} PRIVDAT, *PPRIVDAT;

DWORD aVirtualMemHelpIds[] = {
    IDD_VM_VOLUMES,         -1,
    IDD_VM_DRIVE_HDR,       (IDH_DLG_VIRTUALMEM + 0),
    IDD_VM_PF_SIZE_LABEL,   (IDH_DLG_VIRTUALMEM + 1), 
    IDD_VM_DRIVE_LABEL,     (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SF_DRIVE,        (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SPACE_LABEL,     (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_SF_SPACE,        (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_ST_INITSIZE,     (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_SF_SIZE,         (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_ST_MAXSIZE,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SIZEMAX,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SET,          (IDH_DLG_VIRTUALMEM + 6),
    IDD_VM_MIN_LABEL,       (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_MIN,             (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_RECOMMEND_LABEL, (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_RECOMMEND,       (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_ALLOCD_LABEL,    (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_ALLOCD,          (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_CUSTOMSIZE_RADIO,(IDH_DLG_VIRTUALMEM + 12), //IDH_PERFOPT_ADVTAB_VIRTUALMEM_CUSTOM in sysdm.h
    IDD_VM_RAMBASED_RADIO,  (IDH_DLG_VIRTUALMEM + 13), //IDH_PERFOPT_ADVTAB_VIRTUALMEM_SYSMANAGED in sysdm.h
    IDD_VM_NOPAGING_RADIO,  (IDH_DLG_VIRTUALMEM + 14), //IDH_PERFOPT_ADVTAB_VIRTUALMEM_NOFILE in sysdm.h
    0,0
};

//==========================================================================
//                            Typedefs and Structs
//==========================================================================

// registry info for a page file (but not yet formatted).
//Note: since this structure gets passed to FormatMessage, all fields must
//be 4 bytes wide.
typedef struct
{
    LPTSTR pszName;
    DWORD  nMin;
    DWORD  nMax;
    DWORD  chNull;
} PAGEFILDESC;

//==========================================================================
//                     Global Data Declarations
//==========================================================================

//TCHAR  m_szSysHelp[] = TEXT("sysdm.hlp");
//TCHAR g_szSysDir[ MAX_PATH ];
//UINT g_wHelpMessage;

//==========================================================================
//                     Local Data Declarations
//==========================================================================
// Other VM Vars
BOOL gfCoreDumpChanged;

DWORD cmTotalVM;

//==========================================================================
//                      Local Function Prototypes
//==========================================================================
HRESULT QueryInstanceProperties(
                const TCHAR * pszClass,
                const TCHAR * pszRequestedProperties,
                const TCHAR * pszKeyPropertyName,
                const TCHAR * pszKeyPropertyValue,
                CWbemServices &Services,
                IWbemClassObject ** ppcoInst);

//--------------------------------------------------------------
INT_PTR CALLBACK StaticVirtDlgProc(HWND hwndDlg, UINT message, 
								WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	VirtualMemDlg *me = (VirtualMemDlg *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	}
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
VirtualMemDlg::VirtualMemDlg(WbemServiceThread *serviceThread)
				: WBEMPageHelper(serviceThread)
{
	IWbemClassObject *pInst = NULL;
    
    // this is initialized properly in Init()
    m_VMWriteAccess = FALSE;

	m_pgEnumSettings       = NULL;
	m_pgEnumUsage          = NULL;
	m_cxLBExtent           = 0;
	if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
	{
		m_memory = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_Registry")) != NULL)
	{
		m_registry = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_OSRecoveryConfiguration")) != NULL)
	{
		m_recovery = pInst;
	}
}

//--------------------------------------------------------------
VirtualMemDlg::~VirtualMemDlg()
{
	if(m_pgEnumSettings != NULL)
	{
		m_pgEnumSettings->Release();
		m_pgEnumSettings = NULL;
	}
	if(m_pgEnumUsage != NULL)
	{
		m_pgEnumUsage->Release();
		m_pgEnumUsage = NULL;
	}
}
//--------------------------------------------------------------
int VirtualMemDlg::DoModal(HWND hDlg)
{
	return (int) DialogBoxParam(HINST_THISDLL,
							(LPTSTR) MAKEINTRESOURCE(DLG_VIRTUALMEM), 
							hDlg,
							StaticVirtDlgProc,
							(LPARAM)this);
}
//--------------------------------------------------------------
int TranslateDlgItemInt( HWND hDlg, int id ) 
{
    /*
     * We can't just call GetDlgItemInt because the
     * string we are trying to translate looks like:
     *  nnn (MB), and the '(MB)' would break GetDlgInt.
     */
    TCHAR szBuffer[256] = {0};
    int i = 0;

    if (GetDlgItemText(hDlg, id, szBuffer,
            sizeof(szBuffer) / sizeof(*szBuffer))) 
	{
		_stscanf(szBuffer, _T("%d"), &i);
    }

    return i;
}


//----------------------------------------------------
bool VirtualMemDlg::DlgProc(HWND hDlg,
							UINT message,
							WPARAM wParam,
							LPARAM lParam)
{
    static int fEdtCtlHasFocus = 0;
	m_hDlg = hDlg;

    switch (message)
    {
    case WM_INITDIALOG:
        Init(hDlg);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_VM_VOLUMES:
             // Make edit control reflect the listbox selection.
            if (HIWORD(wParam) == LBN_SELCHANGE)
                SelChange(hDlg);

            break;

        case IDD_VM_SF_SET:
            if (SetNewSize(hDlg))
            {
                ::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), FALSE);
	            SetDefButton(hDlg, IDOK);
            }
            break;

        case IDOK:
        {
            int iRet = UpdateWBEM();
//            iRet |= PromptForReboot(hDlg);

            if (iRet & RET_CHANGE_NO_REBOOT) 
			{
                // We created a pagefile, turn off temp page file flag
                DWORD dwRegData;
                dwRegData = 0;
            }
            else
            {
                // reboot required, warn user & set global flag
                MsgBoxParam(m_hDlg, IDS_MUST_REBOOT, IDS_SYS_CHANGE_CAPTION, MB_OK | MB_ICONINFORMATION, NULL, NULL);
                g_fRebootRequired = true;
            }

            if (gfCoreDumpChanged)
                iRet |= RET_RECOVER_CHANGE;

            EndDialog(hDlg, iRet );
            HourGlass(FALSE);
            break;
        }

        case IDCANCEL:
            // get rid of changes and restore original values.
            EndDialog(hDlg, RET_NO_CHANGE);
            HourGlass(FALSE);
            break;

        case IDD_HELP:
            break;

        case IDD_VM_SF_SIZE:
        case IDD_VM_SF_SIZEMAX:
            switch(HIWORD(wParam))
            {
            case EN_CHANGE:
                if ((fEdtCtlHasFocus != 0) && m_VMWriteAccess)
				{
					::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), TRUE);
                    SetDefButton( hDlg, IDD_VM_SF_SET);
				}
                break;

            case EN_SETFOCUS:
                fEdtCtlHasFocus++;
                break;

            case EN_KILLFOCUS:
                fEdtCtlHasFocus--;
                break;
            }
            break;

        case IDD_VM_NOPAGING_RADIO:
        case IDD_VM_RAMBASED_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), FALSE );

                if (m_VMWriteAccess)
                {
				    ::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), TRUE);
                    SetDefButton( hDlg, IDD_VM_SF_SET);
                }
            }
            break;

        case IDD_VM_CUSTOMSIZE_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), TRUE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), TRUE );

                if (m_VMWriteAccess)
                {
                    ::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), TRUE);
                    SetDefButton( hDlg, IDD_VM_SF_SET);
                }
            }
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
		{
			PAGING_FILE *pgVal = NULL;
			HWND lbHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);
			int last = ListBox_GetCount(lbHWND);

			// zero-based loop.
			for(int x = 0; x < last; x++)
			{
				pgVal = (PAGING_FILE *)ListBox_GetItemData(lbHWND, x);
				delete pgVal;
			}
		}
		break;
    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aVirtualMemHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
				(ULONG_PTR)(LPSTR) aVirtualMemHelpIds);
        break;

    default:
	    return FALSE;
        break;
    }

    return TRUE;
}

//---------------------------------------------------------------
TCHAR szCrashControl[] = TEXT("System\\CurrentControlSet\\Control\\CrashControl");
TCHAR szMemMan[] = TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
TCHAR szRegSizeLim[] = TEXT("System\\CurrentControlSet\\Control");

BOOL VirtualMemDlg::Init(HWND hDlg)
{
    INT i;
    HWND hwndLB;
    INT aTabs[2];
    RECT rc;
	DWORD dwTotalPhys = 0;

    HourGlass(TRUE);

//    g_wHelpMessage    = RegisterWindowMessage( TEXT( "ShellHelp" ) );

    if(m_pgEnumUsage == NULL) 
	{
        //  Error - cannot even get list of paging files from WBEM
        MsgBoxParam(hDlg, SYSTEM+11, IDS_TITLE, MB_ICONEXCLAMATION);
        EndDialog(hDlg, RET_NO_CHANGE);
        HourGlass(FALSE);
        return FALSE;
    }

	BOOL vcVirtRO = TRUE, vcCoreRO = TRUE;

	RemoteRegWriteable(szCrashControl, vcCoreRO);
	RemoteRegWriteable(szMemMan, vcVirtRO);

	// EXCUSE: I wanted to preserve as much of the original logic but its
	// writability was reversed from my util so I do this wierd thing to
	// flip it back.
	vcCoreRO = !vcCoreRO;
	vcVirtRO = !vcVirtRO;

     // To change Virtual Memory size or Crash control, we need access
     // to both the CrashCtl key and the PagingFiles value in the MemMgr key
    if(vcVirtRO || vcCoreRO) 
	{
        // Disable some fields, because they only have Read access.
        EnableWindow(GetDlgItem(hDlg, IDD_VM_CUSTOMSIZE_RADIO), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_RAMBASED_RADIO), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_NOPAGING_RADIO), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_INITSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_MAXSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SET), FALSE);

        m_VMWriteAccess = FALSE;
    }
    else
        m_VMWriteAccess = TRUE;


    hwndLB = GetDlgItem(hDlg, IDD_VM_VOLUMES);
    aTabs[0] = TABSTOP_VOL;
    aTabs[1] = TABSTOP_SIZE;
    SendMessage(hwndLB, LB_SETTABSTOPS, 2, (LPARAM)&aTabs);

     // Since SetGenLBWidth only counts tabs as one character, we must compute
     // the maximum extra space that the tab characters will expand to and
     // arbitrarily tack it onto the end of the string width.
     //
     // cxExtra = 1st Tab width + 1 default tab width (8 chrs) - strlen("d:\t\t");
     //
     // (I know the docs for LB_SETTABSTOPS says that a default tab == 2 dlg
     // units, but I have read the code, and it is really 8 chars)
    rc.top = rc.left = 0;
    rc.bottom = 8;
    rc.right = TABSTOP_VOL + (4 * 8) - (4 * 4);
    MapDialogRect( hDlg, &rc );

    m_cxExtra = rc.right - rc.left;

    // List all drives
	LoadVolumeList();

    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZE, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);
    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZEMAX, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);

    // Get the total physical memory in the machine.
	dwTotalPhys = m_memory.GetLong("TotalPhysicalMemory");

	SetDlgItemMB(hDlg, IDD_VM_MIN, MIN_SWAPSIZE);

	// convert to KBs for the calculation.
	dwTotalPhys /= 1024;
	dwTotalPhys *= 3;
	dwTotalPhys >>=1;	// x*3/2 == 1.5*x more or less.
	i = (DWORD)dwTotalPhys;
	SetDlgItemMB(hDlg, IDD_VM_RECOMMEND, max(i, MIN_SUGGEST));

    // Select the first drive in the listbox.
    SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, 0, 0L);
    SelChange(hDlg);

	//since the data is already loaded into the listbox, we use this lightweight
	// way of calculating.
    SetDlgItemMB(hDlg, IDD_VM_ALLOCD, RecomputeAllocated());

    // Show RegQuota
	cmTotalVM = ComputeTotalMax();

    HourGlass(FALSE);

    return TRUE;
}

//-------------------------------------------------------------------
int VirtualMemDlg::ComputeTotalMax( void ) 
{
    INT nTotalAllocated = 0;
    INT i;

	HWND VolHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);
	int cItems = ListBox_GetCount(VolHWND);

    for(i = 0; i < cItems; i++) 
    {
		PAGING_FILE *pgVal = (PAGING_FILE *)ListBox_GetItemData(VolHWND, i);
        nTotalAllocated += pgVal->nMaxFileSize;
    }

    return nTotalAllocated;
}

//--------------------------------------------------------
void VirtualMemDlg::BuildLBLine(LPTSTR pszBuf,
								const PAGING_FILE *pgVal)
{
    //
    // Build a string according to the following format:
    //
    // C:  [   Vol_label  ]   %d   -   %d
    //

    TCHAR szVolume[MAX_PATH] = {0};
    TCHAR szTemp[MAX_PATH] = {0};
	
    if (pgVal->name != NULL)
    {
        lstrcpy(pszBuf, pgVal->name);
    }
    else
    {
        *pszBuf = _T('\0');
    }
    lstrcat(pszBuf, _T("\t"));

    if (pgVal->volume != NULL && *pgVal->volume)
    {
        lstrcat(pszBuf, _T("["));
		lstrcat(pszBuf, pgVal->volume);
		lstrcat(pszBuf, _T("]"));
    }

    if (!pgVal->fRamBasedPagefile && pgVal->nMinFileSize)
    {
        //
        // Drive has a page file with specific settings.
        //
		wsprintf(szTemp, _T("\t%d - %d"),  pgVal->nMinFileSize,
                    pgVal->nMaxFileSize);
        lstrcat(pszBuf, szTemp);
    }
    else
    {
        //
        // Either the page file size is derived from the RAM size or the
        // drive doesn't have a page file.
        //
        // In either case, do nothing else.
        //
    }
}

//--------------------------------------------------------------
void VirtualMemDlg::SelChange(HWND hDlg)
{
    TCHAR szTemp[MAX_PATH] = {0};
    INT iSel;
    INT nCrtRadioButtonId;
    PAGING_FILE *iDrive;
    BOOL fEditsEnabled;

	// where are we pointing now.
    if ((iSel = (INT)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, 
										LB_GETCURSEL, 0, 0)) == LB_ERR)
	{
        return;
	}

	// get its data.
    iDrive = (PAGING_FILE *)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
												LB_GETITEMDATA, iSel, 0);

	TCHAR volBuf[40] = {0};
	
	if(_tcslen(iDrive->volume) != 0)
	{
		_tcscpy(volBuf, _T("["));
		_tcscat(volBuf, iDrive->volume);
		_tcscat(volBuf, _T("]"));
	}

	wsprintf(szTemp, _T("%s  %s"), 
				iDrive->name, 
				volBuf);

    //LATER: should we also put up total drive size as well as free space?
    SetDlgItemText(hDlg, IDD_VM_SF_DRIVE, szTemp);

    if ( iDrive->fRamBasedPagefile )
    {
        //
        // Paging file size based on RAM size
        //

        nCrtRadioButtonId = IDD_VM_RAMBASED_RADIO;
        fEditsEnabled = FALSE;
    }
    else
    {
        if ( iDrive->nMinFileSize )
        {
            //
            // Custom size paging file
            //

            nCrtRadioButtonId = IDD_VM_CUSTOMSIZE_RADIO;
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, iDrive->nMinFileSize,
                            FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, iDrive->nMaxFileSize,
                            FALSE);
            fEditsEnabled = TRUE;
        }
        else
        {
            //
            // No paging file
            //

            nCrtRadioButtonId = IDD_VM_NOPAGING_RADIO;
            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));
            fEditsEnabled = FALSE;

            //
            // If the allocated size is zero, then this is a volume which
            // had a page file previously but does not now. In this case,
            // there is no settings/usage information in the repository.
            // Since the pagefile.sys file size is considered free space
            // in the free space size computation, then it needs to be
            // obtained here.
            //

            if ( iDrive->nAllocatedFileSize == 0 )
            {
                //
                // Fetch x:\pagefile.sys file size.
                //

	            CWbemClassObject LogicalFile;
                IWbemClassObject * pcoInst;
                HRESULT hr;

                wsprintf(szTemp, gszPFNameFormat, iDrive->name);

                hr = QueryInstanceProperties(gszLogicalFile,
                                             gszFileSize,
                                             gszName,
                                             szTemp,
                                             m_WbemServices,
                                             &pcoInst);

                LogicalFile = pcoInst;
                if (SUCCEEDED(hr))
                {
                    iDrive->nAllocatedFileSize =
                        (LogicalFile.GetLong(gszFileSize) / ONE_MEG);
                }
            }
        }
    }

    //
    // Set 'Space Available'.
    //

    SetDlgItemMB(hDlg, IDD_VM_SF_SPACE,
                    iDrive->freeSpace + iDrive->nAllocatedFileSize);
    //
    // Select the appropriate radio button
    //

    CheckRadioButton(
        hDlg,
        IDD_VM_CUSTOMSIZE_RADIO,
        IDD_VM_NOPAGING_RADIO,
        nCrtRadioButtonId );

    //
    // Enable/disable the min & max size edit boxes (if user has write access !)
    //
	if (m_VMWriteAccess)
	{
		EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), fEditsEnabled );
		EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), fEditsEnabled );
	}
}

//--------------------------------------------------------------
bool VirtualMemDlg::EnsureEnumerator(const bstr_t bstrClass)
{
	HRESULT hr = S_OK;
	
    //
    // This code used to retain/cache these interface ptrs and call
    // CreateInstanceEnum once. But the logic was commented out for
    // some reason with a comment that it was expensive to cache the
    // interfaces, although the data member was set each time with no
    // call to Release!).
    //

    if (lstrcmpi(gszPageFileSettings, bstrClass) == 0)
    {
        IEnumWbemClassObject * pgEnumSettings = NULL;
        hr = m_WbemServices.CreateInstanceEnum(bstrClass, WBEM_FLAG_SHALLOW, 
                                               &pgEnumSettings);
        if (SUCCEEDED(hr))
        {
            if (m_pgEnumSettings != NULL)
            {
                m_pgEnumSettings->Release();
            }
            m_pgEnumSettings = pgEnumSettings;
        }
    }
    else if (lstrcmpi(gszPageFileUsage, bstrClass) == 0)
    {
        IEnumWbemClassObject * pgEnumUsage = NULL;
        hr = m_WbemServices.CreateInstanceEnum(bstrClass,  WBEM_FLAG_SHALLOW, 
                                               &pgEnumUsage);
        if (SUCCEEDED(hr))
        {
            if (m_pgEnumUsage != NULL)
            {
                m_pgEnumUsage->Release();
            }
            m_pgEnumUsage = pgEnumUsage;
        }
    }
    else
    {
        // Do nothing.
    }

	return (SUCCEEDED(hr));
}
//--------------------------------------------------------------
void VirtualMemDlg::LoadVolumeList(void)
{
	IEnumWbemClassObject *diskEnum = NULL;
	IWbemClassObject *pInst = NULL;
	CWbemClassObject newInst;

	DWORD uReturned = 0;
	HRESULT hr = 0;

	bstr_t sNameProp(gszName);
	bstr_t sVolumeProp("VolumeName");
	bstr_t sFileSystemProp("FileSystem");
	bstr_t sDriveTypeProp("DriveType");
	bstr_t sFreeProp("FreeSpace");
	bstr_t sSizeProp("Size"), temp;
	long driveType;
	__int64 temp64 = 0;

	variant_t pVal;
	int idx;
	TCHAR volumeLine[100] = {0};

	PAGING_FILE *pgVar;

	HWND VolHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);

	// walk the disks.
	if(hr = m_WbemServices.ExecQuery(bstr_t("Select __PATH, DriveType from Win32_LogicalDisk"), 
												0, &diskEnum) == S_OK)
	{
		TCHAR bootLtr[2] = {0};
		if((pInst = FirstInstanceOf("Win32_OperatingSystem")) != NULL)
		{
			CWbemClassObject os = pInst;
			bstr_t temp = os.GetString(L"SystemDirectory");
			_tcsncpy(bootLtr, temp, 1);
			m_PAEEnabled = os.GetBool(L"PAEEnabled");
		}

		// get the first and only instance.
		while(SUCCEEDED(diskEnum->Next(-1, 1, &pInst, &uReturned)) && 
			  (uReturned != 0))
		{
			// get the DriveType.
			if ((pInst->Get(sDriveTypeProp, 0L, &pVal, NULL, NULL) == S_OK))
			{
				// look at the DriveType to see if this drive can have a swapfile.
				driveType = pVal;
				if(driveType == DRIVE_FIXED)
				{
					// it can so get the expensive properties now.
					// NOTE: This releases pInst; cuz you EXCHANGED 
					//   it for a better one.
					newInst = ExchangeInstance(&pInst);

					// extract.
					pgVar = new PAGING_FILE;

					pgVar->name = CloneString(newInst.GetString(sNameProp));
					pgVar->volume = CloneString(newInst.GetString(sVolumeProp));
					pgVar->filesystem = CloneString(newInst.GetString(sFileSystemProp));
					if(bootLtr[0] == pgVar->name[0])
					{
						pgVar->bootDrive = true;
					}

					temp64 = 0;
					temp = newInst.GetString(sFreeProp);
					_stscanf(temp, _T("%I64d"), &temp64);
					pgVar->freeSpace = (ULONG)(temp64 / ONE_MEG);

					temp64 = 0;
					temp = newInst.GetString(sSizeProp);
					_stscanf(temp, _T("%I64d"), &temp64);
					pgVar->totalSize = (ULONG)(temp64 / ONE_MEG);

					// match with a Win32_PageFileSettings if possible.
					FindSwapfile(pgVar);

					// add it to the listbox.
					BuildLBLine(volumeLine, pgVar);
					idx = ListBox_AddString(VolHWND, volumeLine);
					int nRet = ListBox_SetItemData(VolHWND, idx, pgVar);
					if(nRet == LB_ERR)
					{
						MessageBox(NULL,_T("Error"),_T("Error"),MB_OK);
					}

					m_cxLBExtent = SetLBWidthEx(VolHWND, volumeLine, m_cxLBExtent, m_cxExtra);

				} //endif drive can have swapfile.

			} //endif get the cheap variable.

			// in case it wasn't exchanged, release it now.
			if(pInst)
			{
				pInst->Release();
				pInst = NULL;
			}

		} // endwhile Enum

		diskEnum->Release();

	} //endif CreateInstanceEnum() SUCCEEDED (one way or another :)
}
//---------------------------------------------------------------
void VirtualMemDlg::FindSwapfile(PAGING_FILE *pgVar)
{
	IWbemClassObject *pInst = NULL;
	CWbemClassObject PFSettings;
	CWbemClassObject PFUsage;
	DWORD uReturned = 0;
	HRESULT hr = 0;

	bstr_t sNameProp(gszName);
	bstr_t sMaxProp(gszMaximumSize);
	bstr_t sInitProp(gszInitialSize);
	bstr_t sPathProp("__PATH");
	bstr_t sAllocSize(gszAllocatedBaseSize);

	variant_t pVal, pVal1, pVal2, pVal3;
	bstr_t bName;

	// do we have one?
	if(EnsureEnumerator(gszPageFileSettings))
	{
		m_pgEnumSettings->Reset();

		// walk through the pagefiles...
		while((hr = m_pgEnumSettings->Next(-1, 1, &pInst,
                                            &uReturned) == S_OK) && 
              (uReturned != 0))
		{
			PFSettings = pInst;
			// trying to match the drive letter.
			bName = PFSettings.GetString(sNameProp);

			if(_wcsnicmp((wchar_t *)bName, pgVar->name, 1) == 0)
			{
				// letter matched; get some details.
				pgVar->nMinFileSize = 
					pgVar->nMinFileSizePrev = PFSettings.GetLong(sInitProp);
				
                //
                // If the page file InitialSize property is zero, it is an
                // indication that the page file size is to be computed based
                // on RAM size.
                //
                pgVar->fRamBasedPagefile = (pgVar->nMinFileSize ?
                                                        FALSE : TRUE);

				pgVar->nMaxFileSize = 
					pgVar->nMaxFileSizePrev = PFSettings.GetLong(sMaxProp);

				pgVar->objPath = CloneString(PFSettings.GetString(sPathProp));

				pgVar->pszPageFile = CloneString(bName);
					
                //
                // Fetch the Win32_PageFileUsage.AllocatedBaseSize property.
                //
                TCHAR szTemp[sizeof(gszPFNameFormat) / sizeof(TCHAR)];
                wsprintf(szTemp, gszPFNameFormat, pgVar->name);

                IWbemClassObject * pcoInst;
                hr = QueryInstanceProperties(gszPageFileUsage,
                                             gszAllocatedBaseSize,
                                             gszName,
                                             szTemp,
                                             m_WbemServices,
                                             &pcoInst);

                PFUsage = pcoInst;
                if (SUCCEEDED(hr))
                {
                    pgVar->nAllocatedFileSize = PFUsage.GetLong(sAllocSize);
                }
                else
                {
                    pgVar->nAllocatedFileSize = 0;
                }

                // found the one and only-- cleanup early and bail out.
                pInst->Release();
                break; // while()

			} //endif match the drive letter.

			// in case that BREAK didn't jump over the endwhile()
			pInst->Release();

		} // endwhile envEnum

		// NOTE: The BREAK jumps here. Duplicate any cleanup from before the
		// endwhile.

	} //endif CreateInstanceEnum() SUCCEEDED one way or another :)
}

//--------------------------------------------------------------
// this version calculates based on pre-existing wbem data.
bool VirtualMemDlg::ComputeAllocated(unsigned long *value)
{
	bool retval = false;

	IWbemClassObject *pgInst = NULL;
	DWORD uReturned = 0;

	bstr_t sAllocSize(gszAllocatedBaseSize);

	variant_t pVal, pVal1;

	// do we have one?
	if(EnsureEnumerator(gszPageFileUsage))
	{
		m_pgEnumUsage->Reset();

		// get the first and only instance.
		while(SUCCEEDED(m_pgEnumUsage->Next(-1, 1, &pgInst, &uReturned)) && 
			  (uReturned != 0))
		{
			// get the variables.
			if((pgInst->Get(sAllocSize, 0L, &pVal1, NULL, NULL) == S_OK) &&
				(pVal1.vt == VT_I4))
			{
				*value += pVal1.ulVal;
			} //endif get the variable.
			pgInst->Release();

		} // endwhile envEnum
		retval = true;
	
	} //endif CreateInstanceEnum() SUCCEEDED (one way or another :)

	return retval;
}

//--------------------------------------------------------------
// this version calculates based on the listbox.
unsigned long VirtualMemDlg::RecomputeAllocated(void)
{
    unsigned long nTotalAllocated = 0;
	PAGING_FILE *pgVal = NULL;

	HWND lbHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);

	int last = ListBox_GetCount(lbHWND);

	// zero-based loop.
	for(int x = 0; x < last; x++)
	{
		pgVal = (PAGING_FILE *)ListBox_GetItemData(lbHWND, x);
        if ( pgVal->fRamBasedPagefile || pgVal->nMinFileSize )
        {
            //
            // Add in only pagefiles in use.
            //
            nTotalAllocated += pgVal->nAllocatedFileSize;
        }
	}
    return nTotalAllocated;
}

//--------------------------------------------------------------
void VirtualMemDlg::GetRecoveryFlags(bool &bWrite, bool &bLog, bool &bSend)
{
	if((bool)m_recovery)
	{
		bWrite = m_recovery.GetBool("WriteDebugInfo");
		bLog = m_recovery.GetBool("WriteToSystemLog");
		bSend = m_recovery.GetBool("SendAdminAlert");
	}
	else
	{
		bWrite = bLog = bSend = false;
	}
}

//--------------------------------------------------------------
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
/* THIS FUNCTION IS A REPLICA OF THE FUNCTION in \\depot\shell\cpls\system\util.c      */
/* OFCOURSE WITH A BIT OF MODIFICATION FOR USING WMI								   */
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/	
DWORD
VirtualMemDlg::GetMaxPagefileSizeInMB(
    PAGING_FILE *iDrive // drive to check on
)
{
#if defined(_AMD64_)
    return MAX_SWAPSIZE_AMD64;
#elif defined(_X86_)
    if (m_PAEEnabled && !(_wcsnicmp(iDrive->filesystem, L"NTFS",4)))
    {
        return MAX_SWAPSIZE_X86_PAE;
    }
    else
    {
        return MAX_SWAPSIZE_X86;
    }
#elif defined(_IA64_)
    return MAX_SWAPSIZE_IA64;
#else
    return 0;
#endif
}

//--------------------------------------------------------------
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
/* THIS FUNCTION IS A REPLICA OF THE FUNCTION in \\depot\shell\cpls\system\virtual.c   */
/* OFCOURSE WITH A BIT OF MODIFICATION FOR USING WMI								   */
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/	

bool VirtualMemDlg::SetNewSize(HWND hDlg)
{
    ULONG nSwapSize;
    ULONG nSwapSizeMax;
    BOOL fTranslated;
    INT iSel;
    PAGING_FILE *iDrive;
    TCHAR szTemp[MAX_PATH] = {0};
    ULONG nBootPF = 0;
    bool fRamBasedPagefile = FALSE;

	// get the item's data.
    if ((iSel = (INT)SendDlgItemMessage(
		         hDlg, IDD_VM_VOLUMES, LB_GETCURSEL,0, 0)) != LB_ERR)
	{		
		if ((LRESULT)(iDrive = (PAGING_FILE *)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
					   LB_GETITEMDATA, iSel, 0)) == LB_ERR)
		{
			return FALSE; //failure !
		}
	}
	
	// Initialize variables for crashdump.
    // nBootPF == crash dump size required.
    //
	bool bWrite = false, bLog = false, bSend = false;

	GetRecoveryFlags(bWrite, bLog, bSend);

    if (bWrite) 
	{
        nBootPF = -1;
    } 
	else if (bLog || bSend) 
	{
        nBootPF = MIN_SWAPSIZE;
    }

    if (nBootPF == -1) 
	{
        nBootPF = ((DWORD)m_memory.GetLong("TotalPhysicalMemory") / 1024);
    }

    if ( IsDlgButtonChecked( hDlg, IDD_VM_NOPAGING_RADIO ) == BST_CHECKED )
    {
        //
        // No paging file on this drive.
        //

        nSwapSize = 0;
        nSwapSizeMax = 0;
        fTranslated = TRUE;
    }
    else
    {
        if ( IsDlgButtonChecked( hDlg,
                                IDD_VM_RAMBASED_RADIO ) == BST_CHECKED )
        {
            MEMORYSTATUSEX MemoryInfo;

            //
            // User requested a RAM based page file. We will compute a page
            // file size based on the RAM currently available so that we can
            // benefit of all the verifications done below related to disk
            // space available etc.
            //
            // The final page file specification written to the registry will
            // contain zero sizes though because this is the way we signal
            // that we want a RAM based page file.
            //

            ZeroMemory (&MemoryInfo, sizeof MemoryInfo);
            MemoryInfo.dwLength =  sizeof MemoryInfo;

            if (GlobalMemoryStatusEx (&MemoryInfo))
            {
                fRamBasedPagefile = TRUE;

                //
                // We do not lose info because we first divide the RAM size to
                // 1Mb and only after that we convert to a DWORD.
                //

                nSwapSize = (DWORD)(MemoryInfo.ullTotalPhys / 0x100000) + 12;
                nSwapSizeMax = nSwapSize;
                fTranslated = TRUE;
            }
            else
            {
                nSwapSize = 0;
                nSwapSizeMax = 0;
                fTranslated = TRUE;
            }
        }
        else
        {
            //
            // User requested a custom size page file.
            //

            nSwapSize = (ULONG)GetDlgItemInt(hDlg, IDD_VM_SF_SIZE,
								            &fTranslated, FALSE);

		    // was it an integer?
            if (!fTranslated)
            {
			    // need a valid integer for initial size.
                MsgBoxParam(hDlg, SYSTEM+37, IDS_TITLE, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

		    // was it in range > 2MB
            if ((nSwapSize < MIN_SWAPSIZE && nSwapSize != 0))
            {
			    // initial value out of range.
                MsgBoxParam(hDlg, SYSTEM+13, IDS_TITLE, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

		    // deleting swapfile?
            if (nSwapSize == 0)
            {
                nSwapSizeMax = 0;
            }
            else // adding/changing.
            {
                nSwapSizeMax = (ULONG)GetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX,
							                        &fTranslated, FALSE);

			    // was it an integer?
                if (!fTranslated)
                {
				    // need an integer.
                    MsgBoxParam(hDlg, SYSTEM+38, IDS_TITLE,
                                MB_ICONEXCLAMATION);
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }

			    // in range?
                if (nSwapSizeMax < nSwapSize || nSwapSizeMax > GetMaxPagefileSizeInMB(iDrive))
                {
					TCHAR strTemp[16];
                    MsgBoxParam(hDlg, SYSTEM+14, IDS_TITLE,
                                MB_ICONEXCLAMATION, _ultow(GetMaxPagefileSizeInMB(iDrive), strTemp, 10));
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }
            }
        }
    }

	// if we have integers and the listbox has a good focus...
    if (fTranslated && iSel != LB_ERR)
    {
		// will it fit?
        if (nSwapSizeMax > iDrive->totalSize)
        {
			// nope.
            MsgBoxParam(hDlg, SYSTEM+16, IDS_TITLE, 
							MB_ICONEXCLAMATION, iDrive->name);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
            return FALSE;
        }

		//Actual FreeSpace is freespace in the disk + page file size.
		ULONG freeSpace = iDrive->freeSpace + iDrive->nAllocatedFileSize;

		// room to spare??
        if (nSwapSize > freeSpace)
        {
			// nope.
            MsgBoxParam(hDlg, SYSTEM+15, IDS_TITLE, MB_ICONEXCLAMATION);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

		// don't hog the last 5MB.
        if (nSwapSize != 0 && freeSpace - nSwapSize < MIN_FREESPACE)
        {
            MsgBoxParam(hDlg, SYSTEM+26, IDS_TITLE, MB_ICONEXCLAMATION,
                    MIN_FREESPACE_STR);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

		// max too big, should I just use all the space anyway.
        if (nSwapSizeMax > freeSpace)
        {
            if (MsgBoxParam(hDlg, SYSTEM+20, IDS_TITLE, MB_ICONINFORMATION |
                       MB_OKCANCEL, iDrive->name) == IDCANCEL)
            {
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                return FALSE;
            }
        }

		// enough room for core dumps??
        if (iDrive->bootDrive && nSwapSize < nBootPF) 
		{
             // The new boot drive page file size is less than we need for
             // crash control.  Inform the user.
            if (MsgBoxParam(hDlg, SYSTEM+29, IDS_TITLE, 
							MB_ICONEXCLAMATION |MB_YESNO, 
							iDrive->name, _itow(nBootPF, szTemp, 10)) != IDYES)
			{
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }
        }

        iDrive->nMinFileSize = nSwapSize;
        iDrive->nMaxFileSize = nSwapSizeMax;
        iDrive->fRamBasedPagefile = fRamBasedPagefile;

        BuildLBLine(szTemp, iDrive);

        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_DELETESTRING, iSel, 0);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_INSERTSTRING, iSel,
					        (LPARAM)szTemp);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETITEMDATA, iSel,
							(LPARAM)iDrive);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, iSel, 0L);

        m_cxLBExtent = SetLBWidthEx(GetDlgItem(hDlg, IDD_VM_VOLUMES),
                                    szTemp, m_cxLBExtent, m_cxExtra);

        if (!iDrive->fRamBasedPagefile && iDrive->nMinFileSize) 
		{
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, iDrive->nMinFileSize, FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, iDrive->nMaxFileSize, FALSE);
        }
        else 
		{
            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, _T(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, _T(""));
        }

	    SetDlgItemMB(hDlg, IDD_VM_ALLOCD, RecomputeAllocated());
        SetFocus(GetDlgItem(hDlg, IDD_VM_VOLUMES));
    }

    return true;
}

//--------------------------------------------------------------
int VirtualMemDlg::UpdateWBEM(void)
{
	int iRet = RET_NO_CHANGE;

    bool bRebootRequired = false;

	CWbemClassObject inst;
	bstr_t sNameProp(gszName);
	bstr_t sMaxProp(gszMaximumSize);
	bstr_t sInitProp(gszInitialSize);
	HRESULT hr = 0;
	PAGING_FILE *pgVal = NULL;
	HWND lbHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);
	int last = ListBox_GetCount(lbHWND);
    BOOL fNewPFInstance;
#ifdef NTONLY
    BOOL fCreatePFPrivEnabled = FALSE;
#endif // NTONLY

	// MAINTAINERS NOTE:
    //      the iRet value gets *overwritten* each time through the loop
    //      it looks to me like the flags should be OR'd together instead
    //      but it's way too scary to change it at this late date...
    for(int x = 0; x < last; x++)
	{
		// get it's state structure.
		pgVal = (PAGING_FILE *)ListBox_GetItemData(lbHWND, x);

        //
        // Should assert objPath != NULL && *pgVal->objPath != 0.
        // Do NOT assume when objPath is non-NULL that objPath
        // is a non-empty string.
        //
        fNewPFInstance = (pgVal->objPath == NULL || !*pgVal->objPath);

        if (!fNewPFInstance)
        {
            //
            // Instance doesn't yet exist, of course, if no object path.
            //
            inst = m_WbemServices.GetObject(pgVal->objPath);
        }
	
        //
        // This condition evaluates pagefile previous/current state.
        // Evaluate to true if:
        //     1. (MINprev != MINcur or MAXprev != MAXcur) - Simple case
        //        where the values changed.
        //     2. (RAMBasedPagefile == TRUE) - Important special case from
        //        custom to RAM-based AND all min/max prev/cur values
        //        coincidentally equal.
        //     3. (MINcur == 0) - Another special case from RAM-based to no
        //        pagefile.  In this case, min/max prev/cur values are all
        //        zero and the RAM-Based pagefile flag is FALSE. 
        //
        if ((pgVal->nMinFileSizePrev != pgVal->nMinFileSize  ||
             pgVal->nMaxFileSizePrev != pgVal->nMaxFileSize) ||
             pgVal->fRamBasedPagefile                        ||
             pgVal->nMinFileSize == 0)
        {
            // reboot required if a page file has *shrunk* in size
            if (pgVal->nMaxFileSizePrev > pgVal->nMaxFileSize)
                bRebootRequired = true;            

            if (pgVal->nMinFileSize != 0 || pgVal->fRamBasedPagefile)
            {
                //
                // Custom or RAM-based.  Note, the RAM-based pagefile flag
                // check seems redundant but it is important for error cases
                // in the SetSize code.
                //
                // Create the instance if it does not exist.
                //
                BOOL fCreate = FALSE, fModified = FALSE;

                if (inst.IsNull())
                {
			        inst = m_WbemServices.CreateInstance(
                                                    gszPageFileSettings);
                }

                //
                // Now write out changes. Sigh, too close to RC1 to rewrite
                // this existing code.
                //
			    if(!inst.IsNull())
			    {
                    if (fNewPFInstance) // Write name at creation time only.
                    {
                        BOOL fRet = TRUE;
#ifdef NTONLY
                        if (!fCreatePFPrivEnabled)
						{
                            //
                            // Pagefile creation requires pagefile creation
                            // privilege.
                            //
                            // Aargh! No return code to check here...
                            //
							m_WbemServices.SetPriv(SE_CREATE_PAGEFILE_NAME);
                            fCreatePFPrivEnabled = TRUE;
                        }
#endif // NTONLY
                        if (fRet)
                        {
				            TCHAR temp[30] = {0};
				            wsprintf(temp, _T("%s\\pagefile.sys"),
                                        pgVal->name);
				            hr = inst.Put(sNameProp, _bstr_t(temp));

                            if (SUCCEEDED(hr))
                            {
                                fModified = TRUE;
                            }
                        }
                    }

                    //
                    // Write zeros for min/max values when the page file
                    // size is to be computed based on RAM size.
                    //
                    if (pgVal->nMinFileSizePrev != pgVal->nMinFileSize)
                    {
				        hr = inst.Put(sInitProp,
                                        (pgVal->fRamBasedPagefile ? 0
                                            : (long)pgVal->nMinFileSize));

                        if (SUCCEEDED(hr))
                        {
                            fModified = TRUE;
                        }
                    }
                    if (pgVal->nMaxFileSizePrev != pgVal->nMaxFileSize)
                    {
				        hr = inst.Put(sMaxProp,
                                        (pgVal->fRamBasedPagefile ? 0
                                            : (long)pgVal->nMaxFileSize));

                        if (SUCCEEDED(hr))
                        {
                            fModified = TRUE;
                        }
                    }
                    if (fModified)
                    {
				        hr = m_WbemServices.PutInstance(
                                                inst,
                                                WBEM_FLAG_CREATE_OR_UPDATE,
                                                EOAC_STATIC_CLOAKING);
                    }
				    if(FAILED(hr))
				    {
					    CHString errorDescription;
                        CHString errorMessage;
                        
                        TCHAR formatString[1024];                        
					    ::LoadString(HINST_THISDLL,IDS_ERR_PAGECREATE,  
                                        formatString, 1024);

                        TCHAR errorHeading[20];
                        ::LoadString(HINST_THISDLL,IDS_ERR_HEADING,
                                        errorHeading, 20);
					    
					    ErrorLookup(hr, errorDescription);
                        
                        errorMessage.Format(formatString, errorDescription);

					    ::MessageBox(m_hDlg,errorMessage,errorHeading,MB_OK);
				    }
				    else
				    {
                        if (fModified)
                        {
					        iRet = RET_VIRTUAL_CHANGE;
				        }
				    }
			    }
            }
            else
            {
                //
                // No paging file. Delete the instance.
                //
                if (!inst.IsNull() && !fNewPFInstance &&
                        pgVal->objPath != NULL) // 3rd condition insures
                                                // extra safety.
                {
			        hr = m_WbemServices.DeleteInstance(pgVal->objPath);

                    // I'm taking it on faith that we can only get here 
                    // if we *deleted* a page file...
                    if (hr != WBEM_E_NOT_FOUND)
                        bRebootRequired = true;

                    if (SUCCEEDED(hr))
                    {
			            iRet = RET_VIRTUAL_CHANGE;
                    }
                }
            }
        }
	} // endfor

#ifdef NTONLY
    if (fCreatePFPrivEnabled)
    {
		m_WbemServices.ClearPriv();
    }
#endif // NTONLY

    if (!bRebootRequired)
        iRet |= RET_CHANGE_NO_REBOOT;

	return iRet;
}

//--------------------------------------------------------------
int VirtualMemDlg::PromptForReboot(HWND hDlg)
{
    int iReboot = RET_NO_CHANGE;
/*    int i;
    int iThisDrv;
    WCHAR us;
    LARGE_INTEGER liMin, liMax;
    NTSTATUS status;
    WCHAR wszPath[MAX_PATH*2];
    TCHAR szDrive[3] = {0};
    PRIVDAT pdOld;

    GetPageFilePrivilege( &pdOld );

    for (i = 0; i < MAX_DRIVES; i++)
    {
        // Did something change?
        if (apf[i].nMinFileSize != apf[i].nMinFileSizePrev ||
                apf[i].nMaxFileSize != apf[i].nMaxFileSizePrev ||
                apf[i].fCreateFile ) 
		{
             // If we are strictly creating a *new* page file, then
             // we can do it on the fly, otherwise we have to reboot.

            // assume we will have to reboot
            iThisDrv = RET_VIRTUAL_CHANGE;

            // IF we are not deleting a page file
            //          - AND -
            //    The Page file does not exist
            //          - OR -
            //    (This is a New page file AND We are allowed to erase the
            //      old, unused pagefile that exists there now)

            if (apf[i].nMinFileSize != 0 &&
                    ((GetFileAttributes(SZPageFileName(i)) == 0xFFFFFFFF &&
                    GetLastError() == ERROR_FILE_NOT_FOUND) ||
                    (apf[i].nMinFileSizePrev == 0 && MsgBoxParam(hDlg,
                    SYSTEM+25, IDS_TITLE, MB_ICONQUESTION | MB_YESNO,
                    SZPageFileName(i)) == IDYES)) ) 
			{

                DWORD cch;

                // Create the page file on the fly so JVert and MGlass will
                // stop bugging me!
                HourGlass(TRUE);

                // convert path drive letter to an NT device path
                wsprintf(szDrive, TEXT("%c:"), (TCHAR)(i + (int)TEXT('A')));
                cch = QueryDosDevice( szDrive, wszPath, sizeof(wszPath) /
                        sizeof(TCHAR));

                if (cch != 0) 
				{
                    // Concat the filename only (skip 'd:') to the nt device
                    // path, and convert it to a UNICODE_STRING
                    lstrcat( wszPath, SZPageFileName(i) + 2 );
                    RtlInitUnicodeString( &us, wszPath );

                    liMin.QuadPart = (LONGLONG)(apf[i].nMinFileSize * ONE_MEG);
                    liMax.QuadPart = (LONGLONG)(apf[i].nMaxFileSize * ONE_MEG);

                    status = NtCreatePagingFile ( &us, &liMin, &liMax, 0L );

                    if (NT_SUCCESS(status)) {
                        // made it on the fly, no need to reboot for this drive!
                        iThisDrv = RET_CHANGE_NO_REBOOT;
                    }
                }
                HourGlass(FALSE);
            }

            iReboot |= iThisDrv;
        }
    }

    ResetOldPrivilege( &pdOld );

    // If Nothing changed, then change our IDOK to IDCANCEL so System.cpl will
    // know not to reboot.
	*/
    return iReboot;
}

/************************************************************************
 *                                                                      *
 *  Function:       QueryInstanceProperties                             *
 *                                                                      *
 *  Description:    Returns requested object properties associated with *
 *                  the instance matching the key property value/name.  *
 *                                                                      *
 *  Arguments:      pszClass               -- Object class.             *
 *                  pszRequestedProperties -- Space-separated property  *
 *                                            names or *.               *
 *                  pszKeyPropertyName     -- Specific instance key     *
 *                                            property name.            *
 *                  pszKeyPropertyValue    -- Key property value.       *
 *                  Services               -- Wbem services.            *
 * 	                ppcoInstEnum           -- Returned instance.        *
 *                                                                      *
 *  Returns:        HRESULT                                             *
 *                                                                      *
 ***********************************************************************/

#define QUERY_INSTANCEPROPERTY  _T("SELECT %s FROM %s WHERE %s=\"%s\"")

HRESULT QueryInstanceProperties(
    const TCHAR * pszClass,
    const TCHAR * pszRequestedProperties,
    const TCHAR * pszKeyPropertyName,
    const TCHAR * pszKeyPropertyValue,
    CWbemServices &Services,
	IWbemClassObject ** ppcoInst)
{
    TCHAR * pszQuery;
    BSTR    bstrQuery;
    HRESULT hr;

    *ppcoInst = NULL;

    // Dislike multiple allocations of bstr_t.
    //
    pszQuery = new TCHAR[(sizeof(QUERY_INSTANCEPROPERTY) / sizeof(TCHAR)) +
                         lstrlen(pszClass)               +
                         lstrlen(pszRequestedProperties) +
                         lstrlen(pszKeyPropertyName)     +  // No +1 ala
                         lstrlen(pszKeyPropertyValue)];     // sizeof.

    if (pszQuery == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wsprintf(pszQuery, QUERY_INSTANCEPROPERTY, pszRequestedProperties,
                pszClass, pszKeyPropertyName, pszKeyPropertyValue); 

    // Sigh, must create a bstr.
    //
    bstrQuery = SysAllocString(pszQuery);
    delete pszQuery;

    if (bstrQuery == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    IEnumWbemClassObject * pecoInstEnum;
	hr = Services.ExecQuery(bstrQuery, 0, &pecoInstEnum);

    SysFreeString(bstrQuery);

    if (SUCCEEDED(hr))
    {
        DWORD uReturned = 0;
        hr = pecoInstEnum->Next(-1, 1, ppcoInst, &uReturned);
        pecoInstEnum->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\chstring1.h ===
// Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _CHSTRING1_H_
#define _CHSTRING1_H_
#pragma once

#include "CHString.h"

class CHString1 : public CHString
{
public:

	CHString1();
	CHString1(TCHAR ch, int nLength);
//	CHString1(LPCTSTR lpch, int nLength);

	#ifdef _UNICODE
		CHString1(LPCSTR lpsz);
	#else //_UNICODE
		CHString1(LPCWSTR lpsz);
	#endif //!_UNICODE

	CHString1(LPCTSTR lpsz);
	CHString1(const CHString& stringSrc);
	CHString1(const CHString1& stringSrc);

	BOOL LoadString(UINT nID);

protected:
	int LoadString(UINT nID,LPWSTR lpszBuf, UINT nMaxBuf);
};
#endif //_CHSTRING1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\chstring1.cpp ===
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "CHString1.h"

CHString1::CHString1() : CHString()
{
}

CHString1::CHString1(TCHAR ch, int nLength) : CHString(ch,nLength)
{
}

//CHString1::CHString1(LPCTSTR lpch, int nLength) : CHString(lpch,nLength)
//{
//}


#ifdef _UNICODE
CHString1::CHString1(LPCSTR lpsz) : CHString(lpsz)
{
}
#else //_UNICODE
CHString1::CHString1(LPCWSTR lpsz) : CHString(lpsz)
{
}
#endif //!_UNICODE

CHString1::CHString1(LPCTSTR lpsz) : CHString(lpsz)
{
}

CHString1::CHString1(const CHString& stringSrc) : CHString(stringSrc)
{
}

CHString1::CHString1(const CHString1& stringSrc) : CHString((CHString)stringSrc)
{
}

BOOL CHString1::LoadString(UINT nID)
{
    // try fixed buffer first (to avoid wasting space in the heap)

	#ifdef _UNICODE
		const UINT CHAR_FUDGE = 1;    // one WCHAR unused is good enough
	#else
		const UINT CHAR_FUDGE = 2;    // two BYTES unused for case of DBC last char
	#endif

	const UINT STR_BLK_SIZE = 256 ;

	int nLen = 0;
    int nSize = STR_BLK_SIZE;

    do
    {
        nSize += STR_BLK_SIZE;
        nLen = ::LoadStringW(_Module.GetModuleInstance(),nID, GetBuffer(nSize-1), nSize);

    } 
    while (nSize - nLen <= CHAR_FUDGE);

    ReleaseBuffer();

    return nLen > 0;
}

BOOL CHString1::LoadString(UINT nID,LPWSTR lpszBuf, UINT nMaxBuf)
{
	int nSize = 256;
	int nLen = ::LoadStringW(_Module.GetModuleInstance(), nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\connectthread.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "ConnectThread.h"
#include <process.h>
#include "..\common\T_DataExtractor.h"
#include <cominit.h>
#include <stdio.h>
#include "util.h"

//const wchar_t* MMC_SNAPIN_MACHINE_NAME = L"MMC_SNAPIN_MACHINE_NAME";

CLIPFORMAT WbemConnectThread::MACHINE_NAME_1 = 0;

//--------------------------
WbemConnectThread::WbemConnectThread()
{
    m_cRef = 1;
	m_hr = 0;
	m_status = notStarted;
	MACHINE_NAME_1 = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));
	m_machineName = L"AGAINWITHTEKLINGONS";
	m_credentials = 0;
	m_doWork = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_threadCmd = false;
	m_hThread = 0;
}

//----------------------------------------------------------------
WbemConnectThread::~WbemConnectThread()
{
	m_hr = 0;
	m_status = notStarted;
	m_notify.RemoveAll();
	if(m_hThread)
	{
		//TODO: If the thread is running we will have to terminate it.
		m_threadCmd = CT_EXIT;
		SetEvent(m_doWork);
		WaitForSingleObject((HANDLE)m_hThread, 5000);
	}

	if(m_doWork)
	{
		CloseHandle(m_doWork);
		m_doWork = 0;
	}

	if (m_credentials)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	};
}

//----------------------------------------------------------------

typedef struct
{
    wchar_t t[MAXCOMPUTER_NAME + 1];
} test;

//TODO: I don't know what this function does. But will try to find out

void WbemConnectThread::MachineName(IDataObject *_pDataObject, bstr_t *name)
{
    HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,sizeof(test));
    wchar_t     *pRet = NULL;
	HRESULT hr = 0;

    if(hMem != NULL)
    {
        STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};

        FORMATETC formatetc = { MACHINE_NAME_1,
								NULL,
								DVASPECT_CONTENT,
								-1,
								TYMED_HGLOBAL };

        if((hr = _pDataObject->GetDataHere(&formatetc, &stgmedium)) == S_OK )
        {
            *name = bstr_t((wchar_t *)hMem);
        }

		GlobalFree(hMem);
    }
}

//----------------------------------------------------------
HRESULT WbemConnectThread::EnsureThread(void)
{
	HRESULT retval = S_OK;

	if(m_hThread == 0)
	{
		// let the thread do the connect. The CWbemService class will
		// handle marshalling as its used by other threads.
		if((m_hThread = _beginthread(WbemConnectThreadProc, 0, (LPVOID)this)) == -1)
		{
			m_status = threadError;
			retval = E_FAIL;
		}
	}
	return retval;
}

//----------------------------------------------------------
HRESULT WbemConnectThread::Connect(bstr_t machineName,
								bstr_t ns,
								bool threaded /* = true */,
								LOGIN_CREDENTIALS *credentials /* = NULL */)
{
	m_nameSpace = ns;

	if((m_credentials != credentials) &&
		m_credentials && m_credentials->authIdent)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	}

	if(machineName.length() > 0)
	{
		m_credentials = credentials;
	}
	else
	{
		m_credentials = 0;
	}

	m_hr = 0;

	if(credentials)
	{
		m_machineName = _T("AGAINWITHTEKLINGONS");  // force a reconnect to
													// the same machine.
	}

	// put the name together.
	bstr_t newMachine;

	// disconnect from the old machine.
	DisconnectServer();
	m_machineName = machineName;
	int x;

	// if machine is whacked already...
	if(_tcsncmp(m_machineName, _T("\\"), 1) == 0)
	{
		// use it.
		m_nameSpace = m_machineName;

		if(((TCHAR*)ns != NULL) && (_tcslen(ns) > 0))
		{
			if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
			{
				m_nameSpace += _T("\\");
			}
		}
		m_nameSpace += ns;
	}
	else if(((x = m_machineName.length()) > 0))
	{
		// whack it myself.
		m_nameSpace = "\\\\";
		m_nameSpace += m_machineName;

		if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
		{
			m_nameSpace += _T("\\");
		}
		m_nameSpace += ns;
	}
	else
	{
		m_nameSpace = ns;
	}

	EnsureThread();
	m_threadCmd = CT_CONNECT;
	SetEvent(m_doWork);

	return E_FAIL;
}

bool WbemConnectThread::Connect(IDataObject *_pDataObject,
								HWND *hWnd /* = 0 */)
{
	m_nameSpace = "root\\cimv2";

	// put the name together.
	bstr_t newMachine;

	MachineName(_pDataObject, &newMachine);

    if(!newMachine) return false;

	// if reconnecting to another machine...
	if(newMachine != m_machineName)
	{
		// disconnect from the old machine.
		DisconnectServer();
		m_machineName = newMachine;

		int x;
		// if its whacked already...
		if(_tcsncmp((LPCTSTR)m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			m_nameSpace = m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}
		else if(((x = m_machineName.length()) > 0))
		{
			// whack it myself.
			m_nameSpace = "\\\\";
			m_nameSpace += m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}

		EnsureThread();
		m_threadCmd = CT_CONNECT;
		NotifyWhenDone(hWnd);
		SetEvent(m_doWork);
		return true;			//TODO: check this return value
	}
	else
	{
		// reconnecting to the same machine-- lie!!
		return true;
	}
	return false;
}

//----------------------------------------------------------
// Returns true if a msg will be sent.
// Returns false if its already over.
bool WbemConnectThread::NotifyWhenDone(HWND *dlg)
{
	switch(m_status)
	{
		case notStarted:
		case locating:
		case connecting:
			m_notify.Add(dlg);
			return true;
		case ready:
		case error:
		case cancelled:
			return false;
	}; // endswitch
	return false;
}

//------------------------------------------------
bool WbemConnectThread::isLocalConnection(void)
{
	return (m_machineName.length() == 0);
}

//------------------------------------------------
void WbemConnectThread::Cancel(void)
{
	m_status = cancelled;
	m_hr = WBEM_S_OPERATION_CANCELLED;
	Notify(0);
	m_machineName = L"AGAINWITHTEKLINGONS";
}

//------------------------------------------------
void WbemConnectThread::DisconnectServer(void)
{
	m_status = notStarted;
	m_notify.RemoveAll();
	m_machineName = L"AGAINWITHTEKLINGONS";

	m_WbemServices.DisconnectServer();
}

//------------------------------------------------
void WbemConnectThread::Notify(IStream *stream)
{
	HWND *hwnd;
	for(int i = 0; i < m_notify.GetSize(); i++)
	{
		hwnd = m_notify[i];
		if(hwnd && *hwnd)
		{
			PostMessage(*hwnd,
						WM_ASYNC_CIMOM_CONNECTED,
						0, (LPARAM)stream);
		}
	}
	m_notify.RemoveAll();
}

//-----------------------------------------------------------------
void WbemConnectThread::SendPtr(HWND hwnd)
{
	EnsureThread();
	m_hWndGetPtr = hwnd;
	m_threadCmd = CT_SEND_PTR;
	SetEvent(m_doWork);
}

//-----------------------------------------------------------------
HRESULT WbemConnectThread::ConnectNow()
{
	HRESULT retval = E_FAIL;

	m_status = connecting;

	try
	{
		m_hr = m_WbemServices.ConnectServer(m_nameSpace, m_credentials);
	}
	catch(CWbemException &e)
	{
		m_status = error;
		m_hr = e.GetErrorCode();
	}

	if(SUCCEEDED(m_hr))
	{
		m_status = ready;
		retval = S_OK;
	}
	else
	{
		m_status = error;
	}

	return retval;
}

void __cdecl WbemConnectThreadProc(LPVOID lpParameter)
{
	WbemConnectThread *pThreadObj = (WbemConnectThread *)lpParameter;

    pThreadObj->AddRef();
	
	IStream *pStream = 0;
	HRESULT hr = S_OK;
	HRESULT retval = E_FAIL; 
	CWbemServices pServices;

	CoInitialize(NULL);

    MSG msg;

	while(true)
	{
      
		DWORD res = MsgWaitForMultipleObjects (1,&pThreadObj->m_doWork, 
								   FALSE, -1, QS_ALLINPUT);
		if (res == WAIT_OBJECT_0 + 1)
		{
			while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			{
				DispatchMessage(&msg);
			}
			continue;
		}

		switch(pThreadObj->m_threadCmd)
		{
			case CT_CONNECT:
			{
				pStream = 0;

				/****************** VINOTH **************************************/
				retval = E_FAIL;
				pThreadObj->m_status = WbemConnectThread::connecting;

				try
				{
					pThreadObj->m_hr = pServices.ConnectServer(pThreadObj->m_nameSpace, pThreadObj->m_credentials);
				}
				catch(CWbemException &e)
				{
					pThreadObj->m_status = WbemConnectThread::error;
					pThreadObj->m_hr = e.GetErrorCode();
				}

				if(SUCCEEDED(pThreadObj->m_hr))
				{
					pThreadObj->m_status = WbemConnectThread::ready;
					retval = S_OK;
				}
				else
				{
					pThreadObj->m_status = WbemConnectThread::error;
				}

				/****************** END *****************************************/
				if(SUCCEEDED(retval))
				{
					IWbemServices *service = 0;
					pServices.GetServices(&service);
					hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
																service, &pStream);
					service->Release();
				}
				// does someone want a msg?
				pThreadObj->Notify(pStream);
				break;
			}
		case CT_SEND_PTR:
			if((bool)pServices)
			{
				IWbemServices *service = 0;
				pServices.GetServices(&service);

				hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
															service, &pStream);
				PostMessage(pThreadObj->m_hWndGetPtr,
							WM_ASYNC_CIMOM_CONNECTED,
							0, (LPARAM)pStream);
				
				service->Release();
			}
			break;
			case CT_EXIT:
			{
				break;
			}
		}

		if(pThreadObj->m_threadCmd == CT_EXIT)
		{
			pServices = (IWbemServices *)NULL;
			break;
		}
	}

    pServices = (IUnknown *)NULL;

    pThreadObj->Release();
    
 	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\connectthread.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __CONNECTTHREAD__
#define __CONNECTTHREAD__
#pragma once

#include "SshWbemHelpers.h"
#include "SimpleArray.h"

#define WM_ASYNC_CIMOM_CONNECTED (WM_USER + 20)
#define WM_CIMOM_RECONNECT (WM_USER + 21)

#define CT_CONNECT 0
#define CT_EXIT 1
#define CT_GET_PTR 2
#define CT_SEND_PTR 3

extern const wchar_t* MMC_SNAPIN_MACHINE_NAME;

void __cdecl WbemConnectThreadProc(LPVOID lpParameter);

class WbemConnectThread
{
private:
	
public:
    virtual ~WbemConnectThread();
	friend void __cdecl WbemConnectThreadProc(LPVOID lpParameter);

	WbemConnectThread();

    LONG AddRef(){ return InterlockedIncrement(&m_cRef); };
    LONG Release(){ LONG lTemp = InterlockedDecrement(&m_cRef); if (0 == lTemp) delete this; return lTemp; };

	// Start the connection attempt.
	HRESULT Connect(bstr_t machineName, 
					bstr_t ns,
					bool threaded = true,
					LOGIN_CREDENTIALS *credentials = NULL);

	bool Connect(IDataObject *_pDataObject, HWND *hWnd = 0);

	// Returns true if a msg will be sent. 
	// Returns false if its already over.
	bool NotifyWhenDone(HWND *dlg);

	void Cancel(void);
	void SendPtr(HWND hwnd);

	void DisconnectServer(void);
	typedef CSimpleArray<HWND *> NOTIFYLIST;

	bool isLocalConnection(void);

	typedef enum {
					notStarted, 
					locating, 
					connecting, 
					threadError, 
					error,
					cancelled, 
					ready
				} ServiceStatus;
	CWbemServices m_WbemServices;
	HRESULT m_hr;
	ServiceStatus m_status;
	bstr_t m_machineName;
	bstr_t m_nameSpace;

private:
	HRESULT ConnectNow();
	void MachineName(IDataObject *_pDataObject, bstr_t *name);
	static CLIPFORMAT MACHINE_NAME_1;
	void Notify(IStream *stream);
	HRESULT EnsureThread(void);

	int m_threadCmd;
	HWND m_hWndGetPtr;
	HANDLE m_doWork;
	NOTIFYLIST m_notify;
	IStream *m_pStream;
	UINT_PTR m_hThread;
	LOGIN_CREDENTIALS *m_credentials;
	LONG m_cRef;

};

#endif __CONNECTTHREAD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\pagehelper.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\MMFUtil\MsgDlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "util.h"
//#include "ConnectThread.h"
#include "PageHelper.h"
#include <stdarg.h>


BOOL PageHelper::g_fRebootRequired = FALSE;

//------------------------------------------------
PageHelper::PageHelper(CWbemServices &service)

{
	m_service = 0;
	m_WbemServices = service;
	m_WbemServices.GetServices(&m_service);
	m_WbemServices.SetBlanket(m_service);

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
PageHelper::PageHelper(WbemConnectThread * pConnectThread)

{
	m_pgConnectThread = pConnectThread;
	m_pgConnectThread->AddRef();
	m_service = 0;

	if(m_pgConnectThread->m_status == WbemConnectThread::ready)
	{
		m_WbemServices = m_pgConnectThread->m_WbemServices;
	}

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
PageHelper::~PageHelper()
{
	// in case ServiceThread still has a ptr to this
	//   handle. It knows not to use NULL HWNDs.
	m_AVIbox = 0;
	m_hDlg = NULL;
	if(m_service)
	{
		m_service->Release();
		m_service = 0;
	}
	m_WbemServices.DisconnectServer();
	m_pgConnectThread->Release();
}

//------------------------------------------------
CWbemClassObject PageHelper::ExchangeInstance(IWbemClassObject **ppbadInst)
{
	CWbemClassObject inst;
	_variant_t v1;

	if(SUCCEEDED((*ppbadInst)->Get(bstr_t("__PATH"), 0, &v1, NULL, NULL)))
	{
		inst = m_WbemServices.GetObject((_bstr_t) v1);
		(*ppbadInst)->Release();
		*ppbadInst = NULL;
	}
	return inst;
}
//------------------------------------------------
// get the first instance of the named class.
IWbemClassObject *PageHelper::FirstInstanceOf(bstr_t className)
{
	IWbemClassObject *pInst = NULL;
	ULONG uReturned;
	IEnumWbemClassObject *Enum = NULL;

	// get the class.
	if(SUCCEEDED(m_WbemServices.CreateInstanceEnum(className,
													WBEM_FLAG_SHALLOW,
													&Enum)))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	return pInst;
}

//---------------------------------------------------
LPTSTR PageHelper::CloneString( LPTSTR pszSrc )
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL)
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst)
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}
//*************************************************************
//
//  SetClearBitmap()
//
//  Purpose:    Sets or clears an image in a static control.
//
//  Parameters: control  -   handle of static control
//              resource -   resource / filename of bitmap
//              fl       -   SCB_ flags:
//                SCB_FROMFILE      'resource' specifies a filename instead of a resource
//                SCB_REPLACEONLY   only put the new image up if there was an old one
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

BOOL PageHelper::SetClearBitmap( HWND control,
									 LPCTSTR resource,
									 UINT fl )
{
    HBITMAP hbm = (HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0);

    if( hbm )
    {
        DeleteObject( hbm );
    }
    else if( fl & SCB_REPLACEONLY )
    {
        return FALSE;
    }

    if( resource )
    {
        SendMessage(control, STM_SETIMAGE, IMAGE_BITMAP,
					(LPARAM)LoadImage(	HINST_THISDLL,
										resource,
										IMAGE_BITMAP,
										0, 0,
										LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS |
										( ( fl & SCB_FROMFILE )? LR_LOADFROMFILE : 0 ) )
					);
    }

    return
        ((HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0) != NULL);
}

//------------------------------------------------------------
int PageHelper::MsgBoxParam(HWND hWnd,
								DWORD wText,
								DWORD wCaption,
								DWORD wType,
								LPTSTR var1,
								LPTSTR var2)
{
    TCHAR   szText[ 4 * MAX_PATH ] = {0}, szCaption[ 2 * MAX_PATH ] = {0};
    int     ival;

    if( !LoadString( HINST_THISDLL, wText, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}
	if(var2)
		wsprintf(szText, szCaption, var1, var2);
	else if(var1)
		wsprintf(szText, szCaption, var1);
	else
		wcscpy(szText, szCaption);

    if( !LoadString( HINST_THISDLL, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}

    ival = MessageBox( hWnd, szText, szCaption, wType);

    return ival;
}

//------------------------------------------------------------
void PageHelper::HourGlass( bool bOn )
{
    if( !GetSystemMetrics( SM_MOUSEPRESENT ) )
        ShowCursor( bOn );

    SetCursor( LoadCursor( NULL, bOn ? IDC_WAIT : IDC_ARROW ) );
}

////////////////////////////////////////////////////////////////////////////
//  SetLBWidthEx
//
//  Set the width of the listbox, in pixels, acording to the size of the
//  string passed in.
//
//  Note: this function is also used by the Virtual Memory dialog
//
//  History:
//  11-Jan-1996 JonPa   Created from SetGenLBWidth
////////////////////////////////////////////////////////////////////////////

DWORD PageHelper::SetLBWidthEx( HWND hwndLB,
									LPTSTR szBuffer,
									DWORD cxCurWidth,
									DWORD cxExtra)
{
    HDC     hDC;
    SIZE    Size;
    HFONT   hfont, hfontOld;

    // Get the new Win4.0 thin dialog font
    hfont = (HFONT)SendMessage(hwndLB, WM_GETFONT, 0, 0);

    hDC = GetDC(hwndLB);

    // if we got a font back, select it in this clean hDC
    if (hfont != NULL)
        hfontOld = (HFONT)SelectObject(hDC, hfont);


    // If cxExtra is 0, then give our selves a little breathing space.
    if (cxExtra == 0)
	{
        GetTextExtentPoint(hDC, TEXT("1234"), 4 , &Size);
        cxExtra = Size.cx;
    }

    // Set scroll width of listbox
    GetTextExtentPoint(hDC, szBuffer, lstrlen(szBuffer), &Size);

    Size.cx += cxExtra;

    // Get the name length and adjust the longest name
    if ((DWORD) Size.cx > cxCurWidth)
    {
        cxCurWidth = Size.cx;
        SendMessage (hwndLB, LB_SETHORIZONTALEXTENT, (DWORD)Size.cx, 0L);
    }

    // retstore the original font if we changed it.
    if (hfont != NULL)
        SelectObject(hDC, hfontOld);

    ReleaseDC(NULL, hDC);

    return cxCurWidth;

	return 1; // bs
}
//---------------------------------------------------
void PageHelper::SetDefButton(HWND hwndDlg,
								  int idButton)
{
    LRESULT lr;

    if(HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}

//-------------------------------------------------------------------
void PageHelper::SetDlgItemMB( HWND hDlg,
								  int idControl,
								  ULONG dwMBValue )
{
    TCHAR szBuf[20] = {0};
    wsprintf(szBuf, _T("%u MB"), dwMBValue);
    SetDlgItemText(hDlg, idControl, szBuf);
}

//--------------------------------------------------------------
void PageHelper::SetWbemService(IWbemServices *pServices)
{
	m_WbemServices = pServices;
}

//--------------------------------------------------------------
bool PageHelper::ServiceIsReady(UINT uCaption /* = 0*/,
									UINT uWaitMsg,
									UINT uBadMsg)
{
	switch(m_pgConnectThread->m_status)
	{
		// its already there.
		case WbemConnectThread::ready:
		{
			return true;
		}
		break;

		// its coming.
		case WbemConnectThread::notStarted:
		case WbemConnectThread::locating:
		case WbemConnectThread::connecting:
		{
			// let me know when its there.
			m_pgConnectThread->NotifyWhenDone(&m_hDlg);

			// also kill the cancel box at that time.
			m_AVIbox = 0;
			m_pgConnectThread->NotifyWhenDone(&m_AVIbox);

			if(uCaption != NO_UI)
			{
				TCHAR caption[100] = {0}, msg[256] = {0};

				::LoadString(HINST_THISDLL, uCaption,
								caption, 100);

				::LoadString(HINST_THISDLL, uWaitMsg,
								msg, 256);

				m_userCancelled = false;

				if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
				{
					m_pgConnectThread->Cancel();
					m_userCancelled = true;
					return false;
				}
			}
			break;
		}
		case WbemConnectThread::error:			// cant connect.
		case WbemConnectThread::threadError:	// cant start that thread.
		default:
		{
			if(::IsWindow(m_AVIbox))
			{
				PostMessage(m_AVIbox,
							WM_ASYNC_CIMOM_CONNECTED,
							0, 0);
				m_AVIbox = 0;
			}

			if(uCaption != NO_UI)
			{
				DisplayUserMessage(m_hDlg, HINST_THISDLL,
									uCaption, BASED_ON_SRC,
									ConnectServer,
									m_pgConnectThread->m_hr,
									MB_ICONSTOP);
			}
			return false;
		}
	}; //endswitch
	return true;
}

//----------------------------------------------------
HRESULT PageHelper::Reboot(UINT flags,
							   long *retval)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_FOUND;
	bstr_t path;
	CWbemClassObject paramCls;

	// need to class def to get the method signature.
	paramCls = m_WbemServices.GetObject("Win32_OperatingSystem");

	if(paramCls)
	{
		// get the method signature. dummy wont actually be used.
		CWbemClassObject dummy, inSig;

		hr = paramCls.GetMethod(L"Win32Shutdown",
									inSig, dummy);

		// if got a good signature....
		if((bool)inSig)
		{
			// find the OperatingSystem for the current service ptr.
			IWbemClassObject *pInst = NULL;
			pInst = FirstInstanceOf("Win32_OperatingSystem");
			if(pInst)
			{
				// wrap it for convenience.
				CWbemClassObject OS(pInst);
				path = OS.GetString(_T("__PATH"));

				// fill in the values.
				inSig.Put(_T("Flags"), (const long)flags);
				inSig.Put(_T("Reserved"), (long)0);

				// adjust privilege.
				m_WbemServices.SetPriv(SE_SHUTDOWN_NAME);

				// now call the method.
				hr = m_WbemServices.ExecMethod(path, L"Win32Shutdown",
												inSig, dummy);

				m_WbemServices.ClearPriv();

				// did the caller want the ReturnValue.
				if(SUCCEEDED(hr) && (bool)dummy && retval)
				{
					// NOTE: this guy return STATUS codes.
					*retval = dummy.GetLong(_T("ReturnValue"));
				}
			}
		}
	} //endif paramCls
	return hr;
}

//---------------------------------------------------------------
bool PageHelper::HasPriv(LPCTSTR privName)
{
    ImpersonateSelf(SecurityImpersonation);
	HANDLE hAccessToken = 0;
	bool retval = false;

	if(OpenThreadToken(GetCurrentThread(),
						TOKEN_QUERY,
						FALSE, &hAccessToken))
	{
		DWORD dwLen;
		TOKEN_PRIVILEGES bogus;

		// guaranteed to fail. Just figuring the size.
		GetTokenInformation(hAccessToken, TokenPrivileges,
								&bogus, 1, &dwLen);

	    BYTE* pBuffer = new BYTE[dwLen];
		if(pBuffer != NULL)
		{
			if(GetTokenInformation(hAccessToken, TokenPrivileges,
									pBuffer, dwLen, &dwLen))
			{
				TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
				LUID luidTgt;
				LookupPrivilegeValue(NULL, privName, &luidTgt);

				for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
				{
					if((pPrivs->Privileges[i].Luid.LowPart == luidTgt.LowPart) &&
						(pPrivs->Privileges[i].Luid.HighPart == luidTgt.HighPart))
					{
						retval = true;
						break;
					}
				}
			}
			delete [] pBuffer;
		}
		CloseHandle(hAccessToken);
	}
	else
	{
		DWORD err = GetLastError();
	}
	return retval;
}

//---------------------------------------------------------------
bool PageHelper::HasPerm(DWORD mask)
{
	// call the method..
	CWbemClassObject _in;
	CWbemClassObject _out;
	bool retval = true;
	// NOTE: for backwards compability with wmi builds that didn't have this
	// method, assume 'true' unless a newer build says you cant do this.

	HRESULT hr = m_WbemServices.GetMethodSignatures("__SystemSecurity",
													"GetCallerAccessRights",
													_in, _out);

	if(SUCCEEDED(hr))
	{
		hr = m_WbemServices.ExecMethod("__SystemSecurity",
										"GetCallerAccessRights",
										_in, _out);

		if(SUCCEEDED(hr) && (bool)_out)
		{
			hr = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
			if(SUCCEEDED(hr))
			{
				DWORD grantedMask = 0;
				grantedMask = (DWORD)_out.GetLong("Rights");

				retval = (bool)((mask & (DWORD)grantedMask) != 0);
			}
		}
	}
	return retval;
}

//--------------------------------------------------------------
HRESULT PageHelper::RemoteRegWriteable(const _bstr_t regPath,
											BOOL& writable)
{
	HRESULT hr = E_FAIL;

	// if not even connected yet...
	if(!(bool)m_defaultNS)
	{
		bstr_t defaultName;

		// already whacked...
		if(wcsncmp((wchar_t *)m_pgConnectThread->m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			defaultName = m_pgConnectThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else if(m_pgConnectThread->m_machineName.length() > 0) // not whacked but remote...
		{
			// whack it myself.
			defaultName = "\\\\";
			defaultName += m_pgConnectThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else  // must be local
		{
			defaultName = "root\\default";
		}

		m_defaultNS.ConnectServer(defaultName);

	}

	// do we need the signatures?
	if((bool)m_defaultNS && !(bool)m_checkAccessIn)
	{
		hr = m_defaultNS.GetMethodSignatures("StdRegProv", "CheckAccess",
												m_checkAccessIn,
												m_checkAccessOut);
	}
	// got connection and signatures already?
	if((bool)m_defaultNS && (bool)m_checkAccessIn)
	{
		// fill in the parms.
		m_checkAccessIn.Put("sSubKeyName", regPath);
		m_checkAccessIn.Put("uRequired", KEY_WRITE);

		// call.
        hr = m_defaultNS.ExecMethod("StdRegProv", "CheckAccess",
										m_checkAccessIn,
										m_checkAccessOut);

		// ExecMethod() itself worked.
		if(SUCCEEDED(hr))
		{
			// did CheckAccess() work.
			HRESULT hr1 = HRESULT_FROM_NT(m_checkAccessOut.GetLong("ReturnValue"));
			if(FAILED(hr1))
			{
				hr = hr1;
			}
			else
			{
				writable = m_checkAccessOut.GetBool("bGranted");
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\declspec.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//#define TRACKING 

// If we are building a the  DLL then define the 
// class as exported otherwise its imported.
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including DECLSPEC.H..." )

#undef POLARITY

#ifdef SHARE_SOURCE
#define POLARITY
#elif BUILDING_DLL
//#pragma message( "Building static library or DLL..." )
#define POLARITY __declspec( dllexport )
#else 
//#pragma message( "Building Client..." )
#define POLARITY __declspec( dllimport )
#endif

#endif COREPOL_HEADERFILE_IS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\pagehelper.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __PAGEHELPER__
#define __PAGEHELPER__

#pragma once

#include "..\common\SshWbemHelpers.h"
#include "..\common\ConnectThread.h"

#define SCB_FROMFILE     (0x1)
#define SCB_REPLACEONLY  (0x2)
#define CLOSE_SNAPIN	0xfdfd

#define WBEM_ENABLE             ( 0x0001 )   
#define WBEM_METHOD_EXECUTE     ( 0x0002 )   
#define WBEM_FULL_WRITE_REP     ( 0x001c )   
#define WBEM_PARTIAL_WRITE_REP  ( 0x0008 )   
#define WBEM_WRITE_PROVIDER     ( 0x0010 )   

class PageHelper
{
public:
	IWbemServices *m_service;
	CWbemServices m_WbemServices;
	bool m_okPressed;
	HWND m_hDlg;
	bool m_userCancelled; // the connectServer() thread.
	HWND m_AVIbox;

	PageHelper(CWbemServices &service);
	PageHelper(WbemConnectThread *connectThread);

	virtual ~PageHelper();

	CWbemClassObject ExchangeInstance(IWbemClassObject **ppbadInst);

	virtual bool GetOnOkPressed(void) {return m_okPressed;};

	// get the first instance of the named class.
	IWbemClassObject *FirstInstanceOf(bstr_t className);

	static LPTSTR CloneString( LPTSTR pszSrc );

	BOOL SetClearBitmap(HWND control, 
						LPCTSTR resource, 
						UINT fl);

	void HourGlass( bool bOn );

	int MsgBoxParam(HWND hWnd, 
					DWORD wText, 
					DWORD wCaption, 
					DWORD wType,
					LPTSTR var1 = NULL,
					LPTSTR var2 = NULL);

	DWORD SetLBWidthEx(HWND hwndLB, 
						LPTSTR szBuffer, 
						DWORD cxCurWidth, 
						DWORD cxExtra);

	void SetDefButton(HWND hwndDlg, 
						int idButton);

	void SetDlgItemMB(HWND hDlg, 
						int idControl, 
						ULONG dwMBValue );

	void SetWbemService(IWbemServices *pServices);

#define NO_UI 0  // for uCaption
	bool ServiceIsReady(UINT uCaption, 
						UINT uWaitMsg,
						UINT uBadMsg);

	HRESULT Reboot(UINT flags = EWX_REBOOT,
				   long *retval = NULL);

	
	HRESULT RemoteRegWriteable(const _bstr_t regPath,
								BOOL& writable);

	bool HasPerm(DWORD mask);
	bool HasPriv(LPCTSTR privName);

	static BOOL g_fRebootRequired;
	WbemConnectThread *m_pgConnectThread;

private:
	// these support efficiency in RemoteRegWriteable().
	CWbemClassObject m_checkAccessIn;
	CWbemClassObject m_checkAccessOut;
	CWbemServices m_defaultNS;
};

#endif __PAGEHELPER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#undef STRICT
#define STRICT


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;

#include <commdlg.h>
#include <commctrl.h>
#include <atlcom.h>

#define IS_BITSET(x, y) 	((x & y) == y)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\servicethread.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "ServiceThread.h"
#include <process.h>
#include "..\common\T_DataExtractor.h"
#include <cominit.h>
#include "util.h"

const wchar_t* MMC_SNAPIN_MACHINE_NAME = L"MMC_SNAPIN_MACHINE_NAME";

CLIPFORMAT WbemServiceThread::MACHINE_NAME = 0;

// Allows user to manually leave critical section, checks if inside before leaving
class CCheckedInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
    BOOL                m_fInside;
public:
    CCheckedInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs), m_fInside( FALSE )
    {
        EnterCriticalSection(m_pcs);
        m_fInside = TRUE;
    }
    ~CCheckedInCritSec()
    {
        Leave();
    }

    void Enter( void )
    {
        if ( !m_fInside )
        {
            EnterCriticalSection(m_pcs);
            m_fInside = TRUE;
        }
    }

    void Leave( void )
    {
        if ( m_fInside )
        {
            m_fInside = FALSE;
            LeaveCriticalSection(m_pcs);
        }
    }

    BOOL IsEntered( void )
    { return m_fInside; }
};

//--------------------------
WbemServiceThread::WbemServiceThread():
     m_cRef(1),
     m_pStream(NULL)
{
	m_hr = 0;
	m_status = notStarted;
	m_machineName = L"AGAINWITHTEKLINGONS";
	MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));
	m_credentials = 0;
	m_doWork = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_ptrReady = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_threadCmd = false;
	m_hThread = 0;
	InitializeCriticalSection(&notifyLock);
}

//----------------------------------------------------------------
WbemServiceThread::~WbemServiceThread()
{
	m_hr = 0;
	m_status = notStarted;
	m_notify.RemoveAll();
	if(m_hThread)
	{
		m_threadCmd = CT_EXIT;
		SetEvent(m_doWork);
		WaitForSingleObject((HANDLE)m_hThread, 5000);
	}

	if(m_doWork)
	{
		CloseHandle(m_doWork);
		m_doWork = 0;
	}
	if(m_ptrReady)
	{
		CloseHandle(m_ptrReady);
		m_ptrReady = 0;
	}

	if (m_credentials)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	};
	DeleteCriticalSection(&notifyLock);

	if (m_pStream)
		m_pStream->Release();

}

//----------------------------------------------------------------
typedef struct
{
    wchar_t t[MAXCOMPUTER_NAME + 1];
} test;

void WbemServiceThread::MachineName(IDataObject *_pDataObject, bstr_t *name)
{
    HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,sizeof(test));
    wchar_t     *pRet = NULL;
	HRESULT hr = 0;

    if(hMem != NULL)
    {
        STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};

        FORMATETC formatetc = { MACHINE_NAME,
								NULL,
								DVASPECT_CONTENT,
								-1,
								TYMED_HGLOBAL };

        if((hr = _pDataObject->GetDataHere(&formatetc, &stgmedium)) == S_OK )
        {
            *name = bstr_t((wchar_t *)hMem);
        }

		GlobalFree(hMem);
    }
}

//----------------------------------------------------------
HRESULT WbemServiceThread::EnsureThread(void)
{
	HRESULT retval = S_OK;

	if(m_hThread == 0)
	{
		// let the thread do the connect. The CWbemService class will
		// handle marshalling as its used by other threads.
		if((m_hThread = _beginthread(WbemServiceConnectThread, 0,
									(LPVOID)this)) == -1)
		{
			m_status = threadError;
			retval = E_FAIL;
		}
	}
	return retval;
}

//----------------------------------------------------------
HRESULT WbemServiceThread::Connect(bstr_t machineName,
								bstr_t ns,
								bool threaded /* = true */,
								LOGIN_CREDENTIALS *credentials, HWND notifiedWnd)
{
	if(ns.length() == 0)
	{
		ns = _T(""); //this allocates...
		if (&ns == NULL)
			return E_FAIL;
	}

	m_nameSpace = ns;

	if((m_credentials != credentials) &&
		m_credentials && m_credentials->authIdent)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	}

	if(machineName.length() > 0)
	{
		m_credentials = credentials;
	}
	else
	{
		m_credentials = 0;
		m_WbemServices.m_authIdent = 0;
		m_realServices.m_authIdent = 0;
	}
	m_hr = 0;
	if(credentials)
	{
		m_machineName = _T("AGAINWITHTEKLINGONS");  // force a reconnect to
													// the same machine.
	}

	// put the name together.
	bstr_t newMachine;

	// if reconnecting to another machine...
	//if(machineName != m_machineName)
	{
		// disconnect from the old machine.
		DisconnectServer();
		m_machineName = machineName;
		int x;

		// if machine is whacked already...
		if(_tcsncmp(m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			m_nameSpace = m_machineName;

			if(ns.length() > 0)
			{
				if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
				{
					m_nameSpace += _T("\\");
				}
			}
			m_nameSpace += ns;
		}
		else if(((x = m_machineName.length()) > 0))
		{
			// whack it myself.
			m_nameSpace = "\\\\";
			m_nameSpace += m_machineName;

			if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
			{
				m_nameSpace += _T("\\");
			}
			m_nameSpace += ns;
		}

		EnsureThread();
		NotifyWhenDone(notifiedWnd);

		m_threadCmd = CT_CONNECT;
		SetEvent(m_doWork);

	}
//	else
//	{
//		// reconnecting to the same machine-- lie!!
//		return WBEM_S_SAME;
//	}
	return E_FAIL;
}

//----------------------------------------------------------
// TODO: merge the Connects()
bool WbemServiceThread::Connect(IDataObject *_pDataObject, HWND hWnd )
{
	m_nameSpace = "root\\cimv2";

	// put the name together.
	bstr_t newMachine;

	MachineName(_pDataObject, &newMachine);

    if(!newMachine) return false;

	// if reconnecting to another machine...
	if(newMachine != m_machineName)
	{
		// disconnect from the old machine.
		DisconnectServer();
		m_machineName = newMachine;

		int x;
		// if its whacked already...
		if(_tcsncmp((LPCTSTR)m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			m_nameSpace = m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}
		else if(((x = m_machineName.length()) > 0))
		{
			// whack it myself.
			m_nameSpace = "\\\\";
			m_nameSpace += m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}

		EnsureThread();
		NotifyWhenDone(hWnd);
		m_threadCmd = CT_CONNECT;
		SetEvent(m_doWork);
	}
	else
	{
		// reconnecting to the same machine-- lie!!
		return true;
	}
	return false;
}

//----------------------------------------------------------
// Returns true if a msg will be sent.
// Returns false if its already over.
bool WbemServiceThread::NotifyWhenDone(HWND dlg)
{
	CCheckedInCritSec autoLock(&notifyLock);
		
	for (int i=0;i<m_notify.GetSize();i++)
		{
		if (dlg==m_notify[i]) { return false;}
		}
	
	switch(m_status)
	{
	case notStarted:
	case locating:
	case connecting:
		m_notify.Add(dlg);
		return true;

	case error:
	case ready:
	case cancelled:
		return false;

	}; // endswitch
	return false;
}

//------------------------------------------------
bool WbemServiceThread::LocalConnection(void)
{
	return (m_machineName.length() == 0);
}

//------------------------------------------------
void WbemServiceThread::Cancel(void)
{
	m_status = cancelled;
	m_hr = WBEM_S_OPERATION_CANCELLED;
	Notify(0);
	m_machineName = L"AGAINWITHTEKLINGONS";
}

//------------------------------------------------
void WbemServiceThread::DisconnectServer(void)
{
	m_status = notStarted;
	m_notify.RemoveAll();
	m_machineName = L"AGAINWITHTEKLINGONS";
	m_WbemServices.DisconnectServer();
}


//------------------------------------------------
void WbemServiceThread::Notify(IWbemServices *service)
{
	CCheckedInCritSec autoLock(&notifyLock);


	HWND hwnd;
	for(int i = 0; i < m_notify.GetSize(); i++)
	{
		hwnd = m_notify[i];
		if(hwnd)
		{
			IStream* pStream = 0;
			autoLock.Leave();
			if (service!=0) CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,service, &pStream);
			PostMessage(hwnd, WM_ASYNC_CIMOM_CONNECTED, 0, (LPARAM)pStream);
			autoLock.Enter();
		}
	}
	m_notify.RemoveAll();
}

//------------------------------------------------
void WbemServiceThread::NotifyError(void)
{
	IWbemServices * nullPtr = 0;
	Notify(nullPtr);
}

//-----------------------------------------------------------------
HRESULT WbemServiceThread::ConnectNow(bool real)
{
	HRESULT retval = E_FAIL;

	m_status = connecting;
    ATLTRACE(_T("ConnectServer() starting\n"));

	try
	{
		if(real)
		{
			m_hr = m_realServices.ConnectServer(m_nameSpace, m_credentials);
		}
		else
		{
			m_hr = m_WbemServices.ConnectServer(m_nameSpace, m_credentials);
		}
	}
	catch(CWbemException &e)
	{
		m_status = error;
		m_hr = e.GetErrorCode();
	}

	if(SUCCEEDED(m_hr))
	{
		if(m_status == cancelled)
		{
		}
		else
		{
			m_status = ready;
			retval = S_OK;
		}
        ATLTRACE(_T("ConnectServer() done\n"));
	}
	else
	{
		m_status = error;
        ATLTRACE(_T("ConnectServer() failed\n"));
	}

	return retval;
}

//-----------------------------------------------------------------
void WbemServiceThread::SendPtr(HWND hwnd)
{
	EnsureThread();
	m_hWndGetPtr = hwnd;
	m_threadCmd = CT_SEND_PTR;
	SetEvent(m_doWork);
}

//-----------------------------------------------------
void __cdecl WbemServiceConnectThread(LPVOID lpParameter)
{
	WbemServiceThread *me = (WbemServiceThread *)lpParameter;
	me->AddRef();
	IStream *pStream = 0;
	HRESULT hr = S_OK;
	HRESULT retval = E_FAIL;
	CWbemServices pServices;

	CoInitialize(NULL);

    MSG msg;

	while(true)
	{
      
		DWORD res = MsgWaitForMultipleObjects (1,&me->m_doWork, 
								   FALSE, -1, QS_ALLINPUT);
		if (res == WAIT_OBJECT_0 + 1)
		{
			while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			{
				DispatchMessage(&msg);
			}
			continue;
		}

		switch(me->m_threadCmd)
		{
		case CT_CONNECT:
			pStream = 0;
			/****************** VINOTH *****************************/

			me->m_status = WbemServiceThread::connecting;
			try
			{
				me->m_hr = pServices.ConnectServer(me->m_nameSpace, me->m_credentials);
			}
			catch(CWbemException &e)
			{
				me->m_status = WbemServiceThread::error;
				me->m_hr = e.GetErrorCode();
			}

			if(SUCCEEDED(me->m_hr))
			{
				if(me->m_status == WbemServiceThread::cancelled)
				{
				}
				else
				{
					me->m_status = WbemServiceThread::ready;
					retval = S_OK;
				}
			}
			else
			{
				me->m_status = WbemServiceThread::error;
			}


	/*************** END VINOTH ************************/
			if(SUCCEEDED(me->m_hr))
			{
				IWbemServices *service = 0;
				pServices.GetServices(&service);
				me->Notify(service);
				service->Release();
			} 
			else
			{
				me->NotifyError();	
			}
			
			break;

		case CT_SEND_PTR:
			if((bool)pServices)
			{
				IWbemServices *service = 0;
				pServices.GetServices(&service);

				if(me->m_threadCmd == CT_SEND_PTR)
				{
					hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
																service, &pStream);
					PostMessage(me->m_hWndGetPtr,
								WM_ASYNC_CIMOM_CONNECTED,
								0, (LPARAM)pStream);
				}
				service->Release();				
			}
			break;

		case CT_EXIT:
			pServices = (IWbemServices *)NULL;
			break;

		} //endswitch

	} //endwhile

    pServices = (IUnknown *)NULL;

	me->Release();
	
	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\servicethread.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SERVICETHREAD__
#define __SERVICETHREAD__
#pragma once

#include "SshWbemHelpers.h"
#include "SimpleArray.h"

#define WM_ASYNC_CIMOM_CONNECTED (WM_USER + 20)
#define WM_CIMOM_RECONNECT (WM_USER + 21)

extern const wchar_t* MMC_SNAPIN_MACHINE_NAME;


void __cdecl WbemServiceConnectThread(LPVOID lpParameter);

class WbemServiceThread
{
public:
	friend void __cdecl WbemServiceConnectThread(LPVOID lpParameter);

	WbemServiceThread();
	virtual ~WbemServiceThread();

	LONG AddRef(){  return InterlockedIncrement(&m_cRef); };
	LONG Release(){ LONG lTemp = InterlockedDecrement(&m_cRef); if (0 == lTemp) delete this; return lTemp; };

	bstr_t m_machineName;
	bstr_t m_nameSpace;
	HRESULT m_hr;
	CRITICAL_SECTION notifyLock;
	typedef enum {notStarted, 
				locating, 
				connecting, 
				threadError, 
				error,
				cancelled, 
				ready} ServiceStatus;

	ServiceStatus m_status;
	
	// Start the connection attempt.
	HRESULT Connect(bstr_t machineName, 
					bstr_t ns,
					bool threaded ,
					LOGIN_CREDENTIALS *credentials , HWND = 0);

	bool Connect(IDataObject *_pDataObject, HWND hWnd = 0);

	HRESULT ReConnect(void) 
	{
		DisconnectServer(); 
		return ConnectNow();
	}

	// Returns true if a msg will be sent. 
	// Returns false if its already over.
	bool NotifyWhenDone(HWND dlg);

	void Cancel(void);
	void DisconnectServer(void);
	typedef CSimpleArray<HWND> NOTIFYLIST;

	NOTIFYLIST m_notify;

	bool LocalConnection(void);
	void SendPtr(HWND hwnd);
	CWbemServices GetPtr(void);

	CWbemServices m_WbemServices;


    // this is set by the SomePage::OnConnect
    // and it is a "correctly marshaled version of the pointer"
	CWbemServices m_realServices;  // lives on the connection thread.
									// DONT had this out directly. Use
									// the Notify().

private:
	HRESULT ConnectNow(bool real = false);
	void MachineName(IDataObject *_pDataObject, bstr_t *name);
	static CLIPFORMAT MACHINE_NAME;

	HANDLE m_doWork, m_ptrReady;
#define CT_CONNECT 0
#define CT_EXIT 1
#define CT_GET_PTR 2
